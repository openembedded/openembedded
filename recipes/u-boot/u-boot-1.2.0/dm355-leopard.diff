 Makefile                                     |   36 
 board/davinci/Makefile                       |   47 
 board/davinci/config.mk                      |   27 
 board/davinci/davinci.c                      |  417 +
 board/davinci/dm644x_emac.c                  |  491 +
 board/davinci/dm644x_emac.h                  |  290 
 board/davinci/flash.c                        |  686 +
 board/davinci/flash_params.h                 |  319 
 board/davinci/lowlevel_init.S                |  764 ++
 board/davinci/nand.c                         |  111 
 board/davinci/soc.h                          |  339 
 board/davinci/timer.c                        |   73 
 board/davinci/timer.h                        |   51 
 board/davinci/types.h                        |   46 
 board/davinci/u-boot.lds                     |   52 
 board/dm355_evm/Makefile                     |   47 
 board/dm355_evm/config.mk                    |   25 
 board/dm355_evm/dm355_evm.c                  |  598 +
 board/dm355_evm/flash.c                      |  758 ++
 board/dm355_evm/flash_params.h               |  319 
 board/dm355_evm/lowlevel_init.S              |  766 ++
 board/dm355_evm/nand.c                       |  805 ++
 board/dm355_evm/timer.c                      |   72 
 board/dm355_evm/timer.h                      |   51 
 board/dm355_evm/types.h                      |   46 
 board/dm355_evm/u-boot.lds                   |   52 
 board/dm355_ipnc/Makefile                    |   47 
 board/dm355_ipnc/config.mk                   |   25 
 board/dm355_ipnc/dm355_ipnc.c                |  671 +
 board/dm355_ipnc/flash.c                     |  758 ++
 board/dm355_ipnc/flash_params.h              |  319 
 board/dm355_ipnc/lowlevel_init.S             |  766 ++
 board/dm355_ipnc/nand.c                      |  830 ++
 board/dm355_ipnc/timer.c                     |   72 
 board/dm355_ipnc/timer.h                     |   51 
 board/dm355_ipnc/types.h                     |   46 
 board/dm355_ipnc/u-boot.lds                  |   52 
 board/dm355_leopard/Makefile                 |   47 
 board/dm355_leopard/config.mk                |   25 
 board/dm355_leopard/dm355_leopard.c          |  671 +
 board/dm355_leopard/flash.c                  |  758 ++
 board/dm355_leopard/flash_params.h           |  319 
 board/dm355_leopard/lowlevel_init.S          |  766 ++
 board/dm355_leopard/nand.c                   |  830 ++
 board/dm355_leopard/timer.c                  |   72 
 board/dm355_leopard/timer.h                  |   51 
 board/dm355_leopard/types.h                  |   46 
 board/dm355_leopard/u-boot.lds               |   52 
 board/dm700/Makefile                         |   47 
 board/dm700/config.mk                        |   26 
 board/dm700/davinci_hd.c                     |  203 
 board/dm700/dm646x_emac.c                    |  506 +
 board/dm700/dm646x_emac.h                    |  321 
 board/dm700/flash.c                          |  686 +
 board/dm700/flash_params.h                   |  319 
 board/dm700/lowlevel_init.S                  |  725 ++
 board/dm700/nand.c                           |  111 
 board/dm700/soc.h                            |  349 +
 board/dm700/timer.c                          |   73 
 board/dm700/timer.h                          |   51 
 board/dm700/types.h                          |   46 
 board/dm700/u-boot.lds                       |   52 
 common/cmd_nand.c                            |   11 
 common/env_nand.c                            |   14 
 cpu/arm926ejs/config.mk                      |    4 
 cpu/arm926ejs/interrupts.c                   |  148 
 cpu/arm926ejs/interrupts.c.orig              |  191 
 drivers/Makefile                             |    4 
 drivers/davinci_i2c.c                        |  296 
 drivers/davinci_i2c.h                        |   87 
 drivers/dm9000.c                             |  370 +
 drivers/dm9000.h                             |  181 
 drivers/dm9000x.c                            |  124 
 drivers/nand/nand_base.c                     | 1404 ++--
 drivers/nand/nand_bbt.c                      |   17 
 drivers/nand/nand_ids.c                      |   44 
 drivers/nand/nand_util.c                     |    3 
 examples/hello_world.bin                     |binary
 examples/hello_world.srec                    |   36 
 include/asm-arm/arch-arm926ejs/emif_defs.h   |   59 
 include/asm-arm/arch-arm926ejs/nand_defs.h   |   92 
 include/asm-arm/arch-arm926ejs/types.h       |   31 
 include/asm-arm/arch/emif_defs.h             |   59 
 include/asm-arm/arch/nand_defs.h             |   92 
 include/asm-arm/arch/sizes.h                 |   51 
 include/asm-arm/arch/types.h                 |   31 
 include/asm-arm/proc/domain.h                |   50 
 include/asm-arm/proc/processor.h             |   74 
 include/asm-arm/proc/ptrace.h                |  109 
 include/asm-arm/proc/system.h                |  199 
 include/asm/arch-arm1136/bits.h              |   48 
 include/asm/arch-arm1136/clocks.h            |  112 
 include/asm/arch-arm1136/i2c.h               |  107 
 include/asm/arch-arm1136/mem.h               |  156 
 include/asm/arch-arm1136/mux.h               |  158 
 include/asm/arch-arm1136/omap2420.h          |  221 
 include/asm/arch-arm1136/sizes.h             |   49 
 include/asm/arch-arm1136/sys_info.h          |   82 
 include/asm/arch-arm1136/sys_proto.h         |   54 
 include/asm/arch-arm720t/hardware.h          |   43 
 include/asm/arch-arm720t/netarm_dma_module.h |  182 
 include/asm/arch-arm720t/netarm_eni_module.h |  121 
 include/asm/arch-arm720t/netarm_eth_module.h |  160 
 include/asm/arch-arm720t/netarm_gen_module.h |  186 
 include/asm/arch-arm720t/netarm_mem_module.h |  184 
 include/asm/arch-arm720t/netarm_registers.h  |   96 
 include/asm/arch-arm720t/netarm_ser_module.h |  347 
 include/asm/arch-arm720t/s3c4510b.h          |  272 
 include/asm/arch-arm925t/sizes.h             |   50 
 include/asm/arch-arm926ejs/emif_defs.h       |   59 
 include/asm/arch-arm926ejs/nand_defs.h       |   92 
 include/asm/arch-arm926ejs/sizes.h           |   51 
 include/asm/arch-arm926ejs/types.h           |   31 
 include/asm/arch-at91rm9200/AT91RM9200.h     |  762 ++
 include/asm/arch-at91rm9200/hardware.h       |   77 
 include/asm/arch-imx/imx-regs.h              |  577 +
 include/asm/arch-ixp/ixp425.h                |  543 +
 include/asm/arch-ixp/ixp425pci.h             |  312 
 include/asm/arch-ks8695/platform.h           |  306 
 include/asm/arch-omap/sizes.h                |   52 
 include/asm/arch-pxa/bitfield.h              |  112 
 include/asm/arch-pxa/hardware.h              |  158 
 include/asm/arch-pxa/mmc.h                   |  200 
 include/asm/arch-pxa/pxa-regs.h              | 2399 ++++++
 include/asm/arch-s3c24x0/memory.h            |  162 
 include/asm/arch-s3c44b0/hardware.h          |  281 
 include/asm/arch-sa1100/bitfield.h           |  112 
 include/asm/arch/emif_defs.h                 |   59 
 include/asm/arch/nand_defs.h                 |   92 
 include/asm/arch/sizes.h                     |   51 
 include/asm/arch/types.h                     |   31 
 include/asm/atomic.h                         |  113 
 include/asm/bitops.h                         |  144 
 include/asm/byteorder.h                      |   32 
 include/asm/errno.h                          |  138 
 include/asm/global_data.h                    |   66 
 include/asm/hardware.h                       |   18 
 include/asm/io.h                             |  307 
 include/asm/mach-types.h                     | 9415 +++++++++++++++++++++++++++
 include/asm/memory.h                         |  137 
 include/asm/posix_types.h                    |   79 
 include/asm/proc-armv/domain.h               |   50 
 include/asm/proc-armv/processor.h            |   74 
 include/asm/proc-armv/ptrace.h               |  109 
 include/asm/proc-armv/system.h               |  199 
 include/asm/proc/domain.h                    |   50 
 include/asm/proc/processor.h                 |   74 
 include/asm/proc/ptrace.h                    |  109 
 include/asm/proc/system.h                    |  199 
 include/asm/processor.h                      |  134 
 include/asm/ptrace.h                         |   33 
 include/asm/setup.h                          |  269 
 include/asm/sizes.h                          |   52 
 include/asm/string.h                         |   47 
 include/asm/types.h                          |   50 
 include/asm/u-boot-arm.h                     |   62 
 include/asm/u-boot.h                         |   60 
 include/config.h                             |    2 
 include/config.mk                            |    3 
 include/configs/davinci.h                    |  222 
 include/configs/dm355_evm.h                  |  227 
 include/configs/dm355_ipnc.h                 |  234 
 include/configs/dm355_leopard.h              |  234 
 include/configs/dm700.h                      |  204 
 include/configs/omap2420h4.h                 |    2 
 include/flash.h                              |    2 
 include/linux/mtd/nand.h                     |  190 
 include/linux/mtd/nand_ids.h                 |    1 
 include/version_autogenerated.h              |    1 
 lib_arm/board.c                              |    8 
 tools/crc32.c                                |  198 
 tools/environment.c                          |  214 
 176 files changed, 44713 insertions(+), 982 deletions(-)
diff -Nurd u-boot-1.2.0/Makefile u-boot-1.2.0-leopard/Makefile
--- u-boot-1.2.0/Makefile	2007-01-06 20:13:11.000000000 -0300
+++ u-boot-1.2.0-leopard/Makefile	2009-03-10 02:16:35.000000000 -0300
@@ -125,7 +125,7 @@
 CROSS_COMPILE = powerpc-linux-
 endif
 ifeq ($(ARCH),arm)
-CROSS_COMPILE = arm-linux-
+CROSS_COMPILE = arm_v5t_le-
 endif
 ifeq ($(ARCH),i386)
 ifeq ($(HOSTARCH),i386)
@@ -233,10 +233,12 @@
 __OBJS := $(subst $(obj),,$(OBJS))
 __LIBS := $(subst $(obj),,$(LIBS))
 
+U-BOOT = u-boot-1.2.0-$(BOARD).bin
+
 #########################################################################
 #########################################################################
 
-ALL = $(obj)u-boot.srec $(obj)u-boot.bin $(obj)System.map $(U_BOOT_NAND)
+ALL = $(obj)u-boot.srec $(obj)$(U-BOOT) $(obj)System.map $(U_BOOT_NAND)
 
 all:		$(ALL)
 
@@ -249,7 +251,10 @@
 $(obj)u-boot.bin:	$(obj)u-boot
 		$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
 
-$(obj)u-boot.img:	$(obj)u-boot.bin
+$(obj)$(U-BOOT):   $(obj)u-boot
+		$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(obj)u-boot.img:	$(obj)$(U-BOOT)
 		./tools/mkimage -A $(ARCH) -T firmware -C none \
 		-a $(TEXT_BASE) -e 0 \
 		-n $(shell sed -n -e 's/.*U_BOOT_VERSION//p' $(VERSION_FILE) | \
@@ -277,8 +282,8 @@
 $(NAND_SPL):	version
 		$(MAKE) -C nand_spl/board/$(BOARDDIR) all
 
-$(U_BOOT_NAND):	$(NAND_SPL) $(obj)u-boot.bin
-		cat $(obj)nand_spl/u-boot-spl-16k.bin $(obj)u-boot.bin > $(obj)u-boot-nand.bin
+$(U_BOOT_NAND):	$(NAND_SPL) $(obj)$(U-BOOT)
+		cat $(obj)nand_spl/u-boot-spl-16k.bin $(obj)$(U-BOOT) > $(obj)u-boot-nand.bin
 
 version:
 		@echo -n "#define U_BOOT_VERSION \"U-Boot " > $(VERSION_FILE); \
@@ -320,7 +325,7 @@
 
 #########################################################################
 else
-all $(obj)u-boot.hex $(obj)u-boot.srec $(obj)u-boot.bin \
+all $(obj)u-boot.hex $(obj)u-boot.srec $(obj)$(U-BOOT) \
 $(obj)u-boot.img $(obj)u-boot.dis $(obj)u-boot \
 $(SUBDIRS) version gdbtools updater env depend \
 dep tags ctags etags $(obj)System.map:
@@ -336,7 +341,7 @@
 #########################################################################
 
 unconfig:
-	@rm -f $(obj)include/config.h $(obj)include/config.mk \
+	@rm -rf $(obj)include/config.h $(obj)include/config.mk \
 		$(obj)board/*/config.tmp $(obj)board/*/*/config.tmp
 
 #========================================================================
@@ -1858,6 +1863,21 @@
 mx1fs2_config	:	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm920t mx1fs2 NULL imx
 
+davinci_config :    unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs davinci
+
+dm700_config :    unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs dm700
+
+dm355_evm_config :    unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs dm355_evm
+
+dm355_ipnc_config :    unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs dm355_ipnc
+	
+dm355_leopard_config:    unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs dm355_leopard
+
 netstar_32_config	\
 netstar_config:		unconfig
 	@mkdir -p $(obj)include
@@ -2333,7 +2353,7 @@
 	rm -f $(obj)u-boot $(obj)u-boot.map $(obj)u-boot.hex $(ALL)
 	rm -f $(obj)tools/crc32.c $(obj)tools/environment.c $(obj)tools/env/crc32.c
 	rm -f $(obj)tools/inca-swap-bytes $(obj)cpu/mpc824x/bedbug_603e.c
-	rm -f $(obj)include/asm/proc $(obj)include/asm/arch $(obj)include/asm
+	rm -rf $(obj)include/asm/proc $(obj)include/asm/arch $(obj)include/asm
 	[ ! -d $(OBJTREE)/nand_spl ] || find $(obj)nand_spl -lname "*" -print | xargs rm -f
 
 ifeq ($(OBJTREE),$(SRCTREE))
diff -Nurd u-boot-1.2.0/board/davinci/Makefile u-boot-1.2.0-leopard/board/davinci/Makefile
--- u-boot-1.2.0/board/davinci/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/davinci/Makefile	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= davinci.o flash.o timer.o dm644x_emac.o nand.o
+SOBJS	:= lowlevel_init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $^
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff -Nurd u-boot-1.2.0/board/davinci/config.mk u-boot-1.2.0-leopard/board/davinci/config.mk
--- u-boot-1.2.0/board/davinci/config.mk	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/davinci/config.mk	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,27 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+# David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+#
+# (C) Copyright 2003
+# Texas Instruments, <www.ti.com>
+# Swaminathan <swami.iyer@ti.com>
+#
+# Davinci EVM board (ARM925EJS) cpu
+# see http://www.ti.com/ for more information on Texas Instruments
+#
+# Davinci EVM has 1 bank of 256 MB DDR RAM 
+# Physical Address:
+# 8000'0000 to 9000'0000
+#
+#
+# Linux-Kernel is expected to be at 8000'8000, entry 8000'8000
+# (mem base + reserved)
+#
+# we load ourself to 8100 '0000
+#
+#
+
+#Provide a atleast 16MB spacing between us and the Linux Kernel image
+TEXT_BASE = 0x81080000
+BOARDLIBS = drivers/nand/libnand.a
diff -Nurd u-boot-1.2.0/board/davinci/davinci.c u-boot-1.2.0-leopard/board/davinci/davinci.c
--- u-boot-1.2.0/board/davinci/davinci.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/davinci/davinci.c	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,417 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ Modifications:
+ ver. 1.0: Oct 2005, Swaminathan S
+ *
+ */
+
+#include <common.h>
+#include <i2c.h>
+
+#if 0
+void flash__init (void);
+void ether__init (void);
+#endif
+#define PLL1_PLLM   *(volatile unsigned int *)0x01c40910
+#define PLL2_PLLM   *(volatile unsigned int *)0x01c40D10
+#define PLL2_DIV2   *(volatile unsigned char *)0x01c40D1C
+
+void davinci_psc_all_enable(void);
+
+/*******************************************
+ Routine: delay
+ Description:  Delay function
+*******************************************/
+static inline void delay (unsigned long loops)
+{
+	       __asm__ volatile ("1:\n"
+		     "subs %0, %1, #1\n"
+		     "bne 1b":"=r" (loops):"0" (loops));
+}
+
+/*******************************************
+ Routine: board_init
+ Description:  Board Initialization routine
+*******************************************/
+int board_init (void)
+{
+    	  DECLARE_GLOBAL_DATA_PTR;
+
+        /* arch number of DaVinci DVDP-Board */
+        gd->bd->bi_arch_number = 901;
+
+      	/* adress of boot parameters */
+       	gd->bd->bi_boot_params = LINUX_BOOT_PARAM_ADDR;
+        /* Configure MUX settings */
+
+      /* Power on required peripherals */
+    	davinci_psc_all_enable();
+#if 0
+      	/* this speeds up your boot a quite a bit.  However to make it
+ 	 *  work, you need make sure your kernel startup flush bug is fixed.
+	 *  ... rkw ...
+	 */
+	icache_enable ();
+#endif
+      	inittimer ();
+
+      	return 0;
+}
+
+/* PSC Domains */
+#define LPSC_VPSSMSTR       0       // VPSS Master LPSC
+#define LPSC_VPSSSLV        1       // VPSS Slave LPSC
+#define LPSC_TPCC           2       // TPCC LPSC
+#define LPSC_TPTC0          3       // TPTC0 LPSC
+#define LPSC_TPTC1          4       // TPTC1 LPSC
+#define LPSC_EMAC           5       // EMAC LPSC
+#define LPSC_EMAC_WRAPPER   6       // EMAC WRAPPER LPSC
+#define LPSC_MDIO           7       // MDIO LPSC
+#define LPSC_IEEE1394       8       // IEEE1394 LPSC
+#define LPSC_USB            9       // USB LPSC
+#define LPSC_ATA            10      // ATA LPSC
+#define LPSC_VLYNQ          11      // VLYNQ LPSC
+#define LPSC_UHPI           12      // UHPI LPSC
+#define LPSC_DDR_EMIF       13      // DDR_EMIF LPSC
+#define LPSC_AEMIF          14      // AEMIF LPSC
+#define LPSC_MMC_SD         15      // MMC_SD LPSC
+#define LPSC_MEMSTICK       16      // MEMSTICK LPSC
+#define LPSC_McBSP          17      // McBSP LPSC
+#define LPSC_I2C            18      // I2C LPSC
+#define LPSC_UART0          19      // UART0 LPSC
+#define LPSC_UART1          20      // UART1 LPSC
+#define LPSC_UART2          21      // UART2 LPSC
+#define LPSC_SPI            22      // SPI LPSC
+#define LPSC_PWM0           23      // PWM0 LPSC
+#define LPSC_PWM1           24      // PWM1 LPSC
+#define LPSC_PWM2           25      // PWM2 LPSC
+#define LPSC_GPIO           26      // GPIO LPSC
+#define LPSC_TIMER0         27      // TIMER0 LPSC
+#define LPSC_TIMER1         28      // TIMER1 LPSC
+#define LPSC_TIMER2         29      // TIMER2 LPSC
+#define LPSC_SYSTEM_SUBSYS  30      // SYSTEM SUBSYSTEM LPSC
+#define LPSC_ARM            31      // ARM LPSC
+#define LPSC_SCR2           32      // SCR2 LPSC
+#define LPSC_SCR3           33      // SCR3 LPSC
+#define LPSC_SCR4           34      // SCR4 LPSC
+#define LPSC_CROSSBAR       35      // CROSSBAR LPSC
+#define LPSC_CFG27          36      // CFG27 LPSC
+#define LPSC_CFG3           37      // CFG3 LPSC
+#define LPSC_CFG5           38      // CFG5 LPSC
+#define LPSC_GEM            39      // GEM LPSC
+#define LPSC_IMCOP          40      // IMCOP LPSC
+
+#define CHP_SHRTSW          *( volatile unsigned int* )( 0x01C40038 )   
+#define GBLCTL              *( volatile unsigned int* )( 0x01C41010 ) 
+#define EPCPR               *( volatile unsigned int* )( 0x01C41070 )
+#define EPCCR               *( volatile unsigned int* )( 0x01C41078 )
+#define PTCMD               *( volatile unsigned int* )( 0x01C41120 )
+#define PTSTAT              *( volatile unsigned int* )( 0x01C41128 )
+#define PDSTAT              *( volatile unsigned int* )( 0x01C41200 )
+#define PDSTAT1             *( volatile unsigned int* )( 0x01C41204 )
+#define PDCTL               *( volatile unsigned int* )( 0x01C41300 )
+#define PDCTL1              *( volatile unsigned int* )( 0x01C41304 )
+#define VBPR                *( volatile unsigned int* )( 0x20000020 )
+
+/**************************************
+ Routine: board_setup_psc_on
+ Description:  Enable a PSC domain
+**************************************/
+void board_setup_psc_on( unsigned int domain, unsigned int id )
+{
+        volatile unsigned int* mdstat = ( unsigned int* )( 0x01C41800 + 4 * id );
+	      volatile unsigned int* mdctl  = ( unsigned int* )( 0x01C41A00 + 4 * id );
+
+	      *mdctl |= 0x00000003; // Set PowerDomain to turn on
+
+    	  if ( ( PDSTAT & 0x00000001 ) == 0 )
+    	  {
+                PDCTL1 |= 0x1;
+        	      PTCMD = ( 1 << domain );
+        	      while ( ( ( ( EPCPR >> domain ) & 1 ) == 0 ) );
+
+        	      PDCTL1 |= 0x100 ;
+        	      while( ! ( ( ( PTSTAT >> domain ) & 1 ) == 0 ) );
+    	  }
+    	  else
+    	  {
+        	      PTCMD = ( 1<<domain );
+        	      while( ! ( ( ( PTSTAT >> domain ) & 1 ) == 0 ) );
+    	  }
+
+    	  while( ! ( ( *mdstat & 0x0000001F ) == 0x3 ) );
+}
+
+/**************************************
+ Routine: davinci_psc_all_enable
+ Description:  Enable all PSC domains
+**************************************/
+void davinci_psc_all_enable(void)
+{
+#define PSC_ADDR            0x01C41000
+#define PTCMD               (PSC_ADDR+0x120)
+#define PTSTAT              (PSC_ADDR+0x128)
+
+        unsigned int alwaysOnPdNum = 0, dspPdNum = 1, i;
+	int waiting;
+	unsigned int state;
+
+    	  /* This function turns on all clocks in the ALWAYSON and DSP Power
+	       * Domains.  Note this function assumes that the Power Domains are
+	       * already on.
+	       */
+#if 0
+    	  /* Write ENABLE (0x3) to all 41 MDCTL[i].NEXT bit fields. */
+    	  for( i = 0; i < 41; i++){
+                *(volatile unsigned int*) (PSC_ADDR+0xA00+4*i) =
+				        *(volatile unsigned int*) (PSC_ADDR+0xA00+4*i) | 0x3;
+    	  }
+
+    	  /* For special workaround:  Set MDCTL[i].EMURSTIE to 0x1 for all of the
+	       * following Modules.  VPSSSLV, EMAC, EMACCTRL, MDIO, USB, ATA, VLYNQ,
+         * HPI, DDREMIF, AEMIF, MMCSD, MEMSTICK, ASP, GPIO, IMCOP.
+         */
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*1) = *(unsigned int*) (PSC_ADDR+0xA00+4*1) | 0x203;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*5) = *(unsigned int*) (PSC_ADDR+0xA00+4*5) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*6) = *(unsigned int*) (PSC_ADDR+0xA00+4*6) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*7) = *(unsigned int*) (PSC_ADDR+0xA00+4*7) | 0x203;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*9) = *(unsigned int*) (PSC_ADDR+0xA00+4*9) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*10) = *(unsigned int*) (PSC_ADDR+0xA00+4*10) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*11) = *(unsigned int*) (PSC_ADDR+0xA00+4*11) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*12) = *(unsigned int*) (PSC_ADDR+0xA00+4*12) | 0x203;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*13) = *(unsigned int*) (PSC_ADDR+0xA00+4*13) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*14) = *(unsigned int*) (PSC_ADDR+0xA00+4*14) | 0x203;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*15) = *(unsigned int*) (PSC_ADDR+0xA00+4*15) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*16) = *(unsigned int*) (PSC_ADDR+0xA00+4*16) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*17) = *(unsigned int*) (PSC_ADDR+0xA00+4*17) | 0x203;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*19) = *(unsigned int*) (PSC_ADDR+0xA00+4*19) | 0x203;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*26) = *(unsigned int*) (PSC_ADDR+0xA00+4*26) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*40) = *(unsigned int*) (PSC_ADDR+0xA00+4*40) | 0x203;*/
+#endif
+
+        /* For special workaround:  Clear MDCTL[i].EMURSTIE to 0x0 for all of the following Modules.
+         *  VPSSSLV, EMAC, EMACCTRL, MDIO, USB, ATA, VLYNQ,
+         *  HPI, DDREMIF, AEMIF, MMCSD, MEMSTICK, ASP, GPIO, IMCOP.
+         */
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*1) = *(unsigned int*) (PSC_ADDR+0xA00+4*1) & 0x003;*/
+        *(volatile unsigned int*) (PSC_ADDR+0xA00+4*5) = *(unsigned int*) (PSC_ADDR+0xA00+4*5) | 0x003;
+        *(volatile unsigned int*) (PSC_ADDR+0xA00+4*6) = *(unsigned int*) (PSC_ADDR+0xA00+4*6) | 0x003;
+        *(volatile unsigned int*) (PSC_ADDR+0xA00+4*7) = *(unsigned int*) (PSC_ADDR+0xA00+4*7) | 0x003;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*9) = *(unsigned int*) (PSC_ADDR+0xA00+4*9) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*10) = *(unsigned int*) (PSC_ADDR+0xA00+4*10) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*11) = *(unsigned int*) (PSC_ADDR+0xA00+4*11) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*12) = *(unsigned int*) (PSC_ADDR+0xA00+4*12) & 0x003;*/
+        *(volatile unsigned int*) (PSC_ADDR+0xA00+4*13) = *(unsigned int*) (PSC_ADDR+0xA00+4*13) | 0x003;
+        *(volatile unsigned int*) (PSC_ADDR+0xA00+4*14) = *(unsigned int*) (PSC_ADDR+0xA00+4*14) | 0x003;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*15) = *(unsigned int*) (PSC_ADDR+0xA00+4*15) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*16) = *(unsigned int*) (PSC_ADDR+0xA00+4*16) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*17) = *(unsigned int*) (PSC_ADDR+0xA00+4*17) & 0x003;*/
+        *(volatile unsigned int*) (PSC_ADDR+0xA00+4*19) = *(unsigned int*) (PSC_ADDR+0xA00+4*19) | 0x003;
+        *(volatile unsigned int*) (PSC_ADDR+0xA00+4*18) = *(unsigned int*) (PSC_ADDR+0xA00+4*18) | 0x003;
+        *(volatile unsigned int*) (PSC_ADDR+0xA00+4*28) = *(unsigned int*) (PSC_ADDR+0xA00+4*28) | 0x003;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*26) = *(unsigned int*) (PSC_ADDR+0xA00+4*26) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*40) = *(unsigned int*) (PSC_ADDR+0xA00+4*40) & 0x003;*/
+
+    	  /* Set PTCMD.GO0 to 0x1 to initiate the state transtion for Modules in
+	       * the ALWAYSON Power Domain
+	       */
+    	  *(volatile unsigned int*) PTCMD = (1<<alwaysOnPdNum);
+
+    	  /* Wait for PTSTAT.GOSTAT0 to clear to 0x0 */
+    	  while(! (((*(volatile unsigned int*) PTSTAT >> alwaysOnPdNum) & 0x00000001) == 0));
+
+	/* DO GEM AND IMCOP INITIALIZATION, ONLY IF DSP POWER DOMAIN IS OFF... */     
+        /* NOTE: this is a precise and refined sequence - use extreme care if modifying! */     
+        if ((PDSTAT1 & 0x1F) == 0) {     
+             
+            /* set PSC FORCE mode; may not be necessary, added per reference code */     
+            GBLCTL = GBLCTL | 0x01;     
+             
+            /* set DSP power domain next state to ON */     
+            PDCTL1 = PDCTL1 | 0x01;     
+      
+            /* ensure external power indicator is cleared */     
+            PDCTL1 = PDCTL1 & 0xFFFFFEFF;     
+      
+            /* enable DSP module */     
+            *(volatile unsigned int*) (PSC_ADDR+0xA00+4*LPSC_GEM) =      
+                (*(volatile unsigned int*) (PSC_ADDR+0xA00+4*LPSC_GEM) & 0xFFFFFFE0) | 0x3;     
+      
+            /* hold DSP in reset on next power ON */     
+            *(volatile unsigned int*) (PSC_ADDR+0xA00+4*LPSC_GEM) =      
+            *(volatile unsigned int*) (PSC_ADDR+0xA00+4*LPSC_GEM) & 0xFFFFFEFF;     
+      
+            /* set IMCOP to enable state */     
+            *(volatile unsigned int*) (PSC_ADDR+0xA00+4*LPSC_IMCOP) =      
+            (*(volatile unsigned int*) (PSC_ADDR+0xA00+4*LPSC_IMCOP) & 0xFFFFFFE0) | 0x3;     
+      
+            /* hold IMCOP in reset on next power ON */     
+            *(volatile unsigned int*) (PSC_ADDR+0xA00+4*LPSC_IMCOP) =      
+            *(volatile unsigned int*) (PSC_ADDR+0xA00+4*LPSC_IMCOP) & 0xFFFFFEFF;     
+      
+            /* start power state transitions for DSP power domain */     
+            *(volatile unsigned int*) PTCMD = (1<<dspPdNum);     
+      
+            /* wait for external power control pending to assert */     
+            for (i = 0, waiting = 1; (i < 100) && waiting; i++) {     
+                if (((EPCPR >> dspPdNum) & 0x00000001) == 1) {     
+                    waiting = 0;     
+                }     
+            }     
+      
+            /* close rail shorting switch */     
+            CHP_SHRTSW = 0x1;     
+      
+            /* set external power good indicator */     
+            PDCTL1 = PDCTL1 | 0x0100;     
+      
+            /* clear external power control pending register bit */     
+            EPCCR = (1 << dspPdNum);     
+      
+            /* wait for DSP domain transitions to complete */     
+            for (i = 0, waiting = 1; (i < 100) && waiting; i++) {     
+                state = *(volatile unsigned int*) PTSTAT;     
+                if (((state >> dspPdNum) & 0x00000001) == 0) {     
+                    waiting = 0;     
+                }     
+            }     
+      
+            /* turn off PSC FORCE mode */     
+            GBLCTL = GBLCTL & 0xFFFFFFFE;     
+      
+    } /* END GEM AND IMCOP INITIALIZATION */ 
+
+        /* Bringup UART out of reset here since NS16650 code that we are using from uBoot
+         * will not do it
+         */
+#define UARTPWREMU_MGMT     0x01c20030
+        *(volatile unsigned int*) UARTPWREMU_MGMT = 0x0000E003;
+        
+	/* Enable GIO3.3V cells used for EMAC */
+#define VDD3P3V_PWDN        0x01c40048
+        *(volatile unsigned int*) VDD3P3V_PWDN = 0;
+
+#define PINMUX0     0x01C40000
+#define PINMUX4     0x01C40004
+
+        /* Enable UART0 MUX lines */
+        *(volatile unsigned int *)PINMUX4 |= 1;
+        /* Enable EMAC and AEMIF pins */
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+        *(volatile unsigned int*) PINMUX0 = 0x80000000;
+#else
+        *(volatile unsigned int*) PINMUX0 = 0x80000C1F;
+#endif
+
+	/* Enable I2C pin Mux */
+        *(volatile unsigned int *)PINMUX4 |= (1 << 7);
+
+	/* Set the Bus Priority Register to appropriate value */
+	VBPR = 0x20;
+}
+
+/******************************
+ Routine: misc_init_r
+ Description:  Misc. init
+******************************/
+int misc_init_r (void)
+{
+	char temp[20];
+	char rtcdata[10] = { 2, 1, 0, 0, 0, 0, 0, 0, 0, 0};
+	char emac_read_addr [10] = { 0x7f, 0 }, i= 0;
+        int clk = 0;
+
+        clk = ((PLL2_PLLM + 1) * 27) / (PLL2_DIV2 + 1);
+
+        printf ("ARM Clock :- %dMHz\n", ((((PLL1_PLLM + 1) * 27 ) / 2)) );
+        printf ("DDR Clock :- %dMHz\n", (clk/2));
+
+	i2c_write (0x50, 0x00, 1, emac_read_addr, 2);
+	i2c_read (0x50, 0x00, 1, emac_read_addr, 6);
+        temp[0] = (emac_read_addr[0] & 0xF0) >> 4;
+        temp[1] = (emac_read_addr[0] & 0x0F);
+        temp[2] = ':';
+        temp[3] = (emac_read_addr[1] & 0xF0) >> 4;
+        temp[4] = (emac_read_addr[1] & 0x0F);
+        temp[5] = ':';
+        temp[6] = (emac_read_addr[2] & 0xF0) >> 4;
+        temp[7] = (emac_read_addr[2] & 0x0F);
+        temp[8] = ':';
+        temp[9] = (emac_read_addr[3] & 0xF0) >> 4;
+        temp[10]= (emac_read_addr[3] & 0x0F);
+        temp[11]= ':';
+        temp[12]= (emac_read_addr[4] & 0xF0) >> 4;
+        temp[13]= (emac_read_addr[4] & 0x0F);
+        temp[14]= ':';
+        temp[15]= (emac_read_addr[5] & 0xF0) >> 4;
+        temp[16]= (emac_read_addr[5] & 0x0F);
+                                                                               
+        for (i = 0; i < 17; i++)
+        {
+        if (temp[i] == ':')
+                continue;
+        else if (temp[i] >= 0 && temp[i] <= 9)
+                temp[i] = temp[i] + 48;
+        else
+                temp[i] = temp[i] + 87;
+        }
+                   
+	temp [17] = 0;                                                            
+	if ((emac_read_addr [0] != 0xFF) ||
+	    (emac_read_addr [1] != 0xFF) ||	
+	    (emac_read_addr [2] != 0xFF) ||	
+	    (emac_read_addr [3] != 0xFF) ||	
+	    (emac_read_addr [4] != 0xFF) ||	
+	    (emac_read_addr [5] != 0xFF))
+	{ 
+		setenv ("ethaddr", temp);
+	}
+
+	i2c_read (0x39, 0x00, 1, &i, 1);
+	
+    if ( !getenv("videostd") )
+	    setenv ("videostd", ((i  & 0x80)?"pal":"ntsc"));
+	
+	i2c_write (0x23, 0x00, 1, rtcdata, 2);
+	i2c_read (0x23, 0x00, 1, rtcdata, 1);
+
+	if (rtcdata[0] == 10)
+		printf ("MSP430 Firmware supports AM/PM Feature\n");
+	else
+		printf ("MSP430 Firmware does not support AM/PM Feature\n");	
+
+        return (0);
+}
+
+/******************************
+ Routine: dram_init
+ Description:  Memory Info
+******************************/
+int dram_init (void)
+{
+        DECLARE_GLOBAL_DATA_PTR;
+
+	      gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	      gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+        return 0;
+}
+
diff -Nurd u-boot-1.2.0/board/davinci/dm644x_emac.c u-boot-1.2.0-leopard/board/davinci/dm644x_emac.c
--- u-boot-1.2.0/board/davinci/dm644x_emac.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/davinci/dm644x_emac.c	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,491 @@
+/*
+ * dm644x_emac.c
+ *
+ * TI DaVinci (DM644X) EMAC peripheral driver source for DV-EVM
+ *
+ * Copyright (C) 2005 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ 
+ * Modifications:
+ * ver. 1.0: Sep 2005, Anant Gole - Created EMAC version for uBoot.
+ * ver  1.1: Nov 2005, Anant Gole - Extended the RX logic for multiple descriptors
+ *
+ */
+ 
+#include <common.h>
+#include <command.h>
+#include <net.h>
+#include "dm644x_emac.h"
+
+#ifdef CONFIG_DRIVER_TI_EMAC
+
+#if (CONFIG_COMMANDS & CFG_CMD_NET)
+
+unsigned int emac_dbg = 0;
+#define debug_emac(fmt,args...)	if (emac_dbg) printf (fmt ,##args)
+
+/* EMAC internal functions - called when eth_xxx functions are invoked by the kernel */
+static int emac_hw_init (void);
+static int emac_open (void);
+static int emac_close (void);
+static int emac_send_packet (volatile void *packet, int length);
+static int emac_rcv_packet (void);
+
+/* The driver can be entered at any of the following entry points */
+extern int eth_init (bd_t * bd);
+extern void eth_halt (void);
+extern int eth_rx (void);
+extern int eth_send (volatile void *packet, int length);
+
+int eth_hw_init (void)
+{
+    return emac_hw_init();
+}
+
+int eth_init (bd_t * bd)
+{
+    return emac_open ();
+}
+
+void eth_halt ()
+{
+    emac_close ();
+}
+
+int eth_send (volatile void *packet, int length)
+{
+    return emac_send_packet (packet, length);
+}
+
+int eth_rx ()
+{
+    return emac_rcv_packet ();
+}
+
+
+static char emac_mac_addr[] = { 0x00, 0x00, 0x5b, 0xee, 0xde, 0xad };
+
+/*
+ * This function must be called before emac_open() if you want to override
+ * the default mac address.
+ */
+
+void emac_set_mac_addr (const char *addr)
+{
+    int i;
+
+    for (i = 0; i < sizeof (emac_mac_addr); i++) {
+        emac_mac_addr[i] = addr[i];
+    }
+}
+
+/***************************
+ * EMAC Global variables
+ ***************************/ 
+ 
+/* EMAC Addresses */
+static volatile emac_regs* adap_emac = (emac_regs *) EMAC_BASE_ADDR;
+static volatile ewrap_regs* adap_ewrap = (ewrap_regs *) EMAC_WRAPPER_BASE_ADDR;
+static volatile mdio_regs* adap_mdio = (mdio_regs *) EMAC_MDIO_BASE_ADDR;
+
+/* EMAC descriptors */
+static volatile emac_desc *emac_rx_desc = (emac_desc *) (EMAC_WRAPPER_RAM_ADDR + EMAC_RX_DESC_BASE);
+static volatile emac_desc *emac_tx_desc = (emac_desc *) (EMAC_WRAPPER_RAM_ADDR + EMAC_TX_DESC_BASE);
+static volatile emac_desc *emac_rx_active_head = 0;
+static volatile emac_desc *emac_rx_active_tail = 0;
+static int emac_rx_queue_active = 0;
+
+/* EMAC link status */
+static int emac_link_status = 0; /* 0 = link down, 1 = link up */
+
+/* Receive packet buffers */
+static unsigned char emac_rx_buffers[EMAC_MAX_RX_BUFFERS * (EMAC_MAX_ETHERNET_PKT_SIZE + EMAC_PKT_ALIGN)];
+
+/* This function initializes the emac hardware */
+static int emac_hw_init (void)
+{
+    /* Enabling power and reset from outside the module is required */
+    return (0);
+}
+
+/* Read a PHY register via MDIO inteface */
+static int mdio_read(int phy_addr, int reg_num)
+{
+    adap_mdio->USERACCESS0 = MDIO_USERACCESS0_GO | MDIO_USERACCESS0_WRITE_READ | 
+                             ((reg_num & 0x1F) << 21) | 
+                             ((phy_addr & 0x1F) << 16);
+
+    /* Wait for command to complete */ 
+    while ((adap_mdio->USERACCESS0 & MDIO_USERACCESS0_GO) != 0);    
+
+    return (adap_mdio->USERACCESS0 & 0xFFFF);
+}
+
+/* Write to a PHY register via MDIO inteface */
+void mdio_write(int phy_addr, int reg_num, unsigned int data)
+{
+    /* Wait for User access register to be ready */
+    while ((adap_mdio->USERACCESS0 & MDIO_USERACCESS0_GO) != 0);    
+    
+    adap_mdio->USERACCESS0 = MDIO_USERACCESS0_GO | MDIO_USERACCESS0_WRITE_WRITE | 
+                             ((reg_num & 0x1F) << 21) | 
+                             ((phy_addr & 0x1F) << 16) |
+                             (data & 0xFFFF);
+}
+
+
+/* Get PHY link state - this function accepts a PHY mask for the caller to
+ * find out if any of the passed PHY addresses is connected
+ */
+int mdio_get_link_state(unsigned int phy_mask)
+{
+    unsigned int act_phy, phy_addr = 0, link_state = 0;
+    unsigned int config;
+
+    act_phy =  (adap_mdio->ALIVE & phy_mask);
+    
+    if (act_phy) 
+    {            
+        /* find the phy number */
+        while(act_phy) 
+        {
+            while(!(act_phy & 0x1)) 
+            {
+                phy_addr++; 
+                act_phy >>= 1;
+            }
+            /* Read the status register from PHY */
+            link_state = ((mdio_read(phy_addr, MII_STATUS_REG) & 0x4) >> 2);
+            if(link_state == 1) 
+            { 
+                /* The link can break off anytime, hence adding the fix for boosting the PHY signal
+                 * strength here so that everytime the link is found, this can be done and ensured
+                 * that we dont miss it
+                 */
+                 config = mdio_read(phy_addr, MII_DIGITAL_CONFIG_REG);
+                 config |= 0x800;
+                 mdio_write(phy_addr, MII_DIGITAL_CONFIG_REG, config);
+                 /* Read back to verify */
+                 config = mdio_read(phy_addr, MII_DIGITAL_CONFIG_REG);
+                 
+                break;
+            } 
+            else 
+            {
+                /* If no link, go to next phy. */                    
+                act_phy >>= 1;
+                phy_addr++;  
+            }
+        }
+    }
+    return link_state;    
+}
+
+/*
+ * The kernel calls this function when someone wants to use the device,
+ * typically 'ifconfig ethX up'.
+ */
+static int emac_open (void)
+{
+    volatile unsigned int *addr;
+    unsigned int clkdiv, cnt;
+    volatile emac_desc *rx_desc;
+    
+    debug_emac("+ emac_open\n");
+            
+    /* Reset EMAC module and disable interrupts in wrapper */
+    adap_emac->SOFTRESET = 1;
+    while (adap_emac->SOFTRESET != 0);
+    adap_ewrap->EWCTL = 0;
+    for (cnt=0; cnt < 5; cnt++) {
+        clkdiv = adap_ewrap->EWCTL;
+    }
+    
+    rx_desc = emac_rx_desc;
+
+    adap_emac->TXCONTROL = 0x1;
+    adap_emac->RXCONTROL = 0x1;
+        
+    /* Set MAC Addresses & Init multicast Hash to 0 (disable any multicast receive) */
+    /* Using channel 0 only - other channels are disabled */
+    adap_emac->MACINDEX = 0;
+    adap_emac->MACADDRHI = (emac_mac_addr[3] << 24) | (emac_mac_addr[2] << 16) |
+                            (emac_mac_addr[1] << 8)  | (emac_mac_addr[0]);
+    adap_emac->MACADDRLO = ((emac_mac_addr[5] << 8) | emac_mac_addr[4]);
+    
+    adap_emac->MACHASH1 = 0;
+    adap_emac->MACHASH2 = 0;
+    
+    /* Set source MAC address - REQUIRED */
+    adap_emac->MACSRCADDRHI = (emac_mac_addr[3] << 24) | (emac_mac_addr[2] << 16) |
+                              (emac_mac_addr[1] << 8)  | (emac_mac_addr[0]);
+    adap_emac->MACSRCADDRLO = ((emac_mac_addr[4] << 8) | emac_mac_addr[5]);
+    
+    /* Set DMA 8 TX / 8 RX Head pointers to 0 */
+    addr = &adap_emac->TX0HDP;
+    for( cnt=0; cnt<16; cnt++ )
+        *addr++ = 0;
+    addr = &adap_emac->RX0HDP;
+    for( cnt=0; cnt<16; cnt++ )
+        *addr++ = 0;
+
+    /* Clear Statistics (do this before setting MacControl register) */
+    addr = &adap_emac->RXGOODFRAMES;
+    for( cnt=0; cnt < EMAC_NUM_STATS; cnt++ )
+        *addr++ = 0;
+
+    /* No multicast addressing */
+    adap_emac->MACHASH1 = 0 ;
+    adap_emac->MACHASH2 = 0 ;
+    
+    /* Create RX queue and set receive process in place */
+    emac_rx_active_head = emac_rx_desc;
+    for (cnt=0; cnt < EMAC_MAX_RX_BUFFERS; cnt++)
+    {
+        rx_desc->next = (unsigned int) (rx_desc + 1);
+        rx_desc->buffer = &emac_rx_buffers[cnt * (EMAC_MAX_ETHERNET_PKT_SIZE + EMAC_PKT_ALIGN)];
+        rx_desc->buff_off_len = EMAC_MAX_ETHERNET_PKT_SIZE;
+        rx_desc->pkt_flag_len = EMAC_CPPI_OWNERSHIP_BIT;
+        ++rx_desc;
+    }
+    
+    /* Set the last descriptor's "next" parameter to 0 to end the RX desc list */
+    --rx_desc;
+    rx_desc->next = 0;
+    emac_rx_active_tail = rx_desc;
+    emac_rx_queue_active = 1;
+    
+    /* Enable TX/RX */
+    adap_emac->RXMAXLEN = EMAC_MAX_ETHERNET_PKT_SIZE;
+    adap_emac->RXBUFFEROFFSET = 0;
+    
+    /* No fancy configs - Use this for promiscous for debug - EMAC_RXMBPENABLE_RXCAFEN_ENABLE */
+    adap_emac->RXMBPENABLE = EMAC_RXMBPENABLE_RXBROADEN ;
+
+    /* Enable ch 0 only */
+    adap_emac->RXUNICASTSET = 0x1; 
+    
+    /* Enable MII interface and Full duplex mode */
+    adap_emac->MACCONTROL = (EMAC_MACCONTROL_MIIEN_ENABLE | EMAC_MACCONTROL_FULLDUPLEX_ENABLE); 
+    
+    /* Init MDIO & get link state */
+    clkdiv = (EMAC_MDIO_BUS_FREQ / EMAC_MDIO_CLOCK_FREQ) - 1;
+    adap_mdio->CONTROL = ((clkdiv & 0xFF) | MDIO_CONTROL_ENABLE | MDIO_CONTROL_FAULT);  
+    emac_link_status = mdio_get_link_state(EMAC_MDIO_PHY_MASK);
+    
+    /* Start receive process */
+    adap_emac->RX0HDP = (unsigned int) emac_rx_desc;
+    
+    debug_emac("- emac_open\n");
+
+    return (1);
+}
+
+/* EMAC Channel Teardown */
+void emac_ch_teardown(int ch)
+{
+    volatile unsigned int dly = 0xFF;
+    volatile unsigned int cnt;
+    
+    debug_emac("+ emac_ch_teardown\n");
+    
+    if (ch == EMAC_CH_TX)
+    {
+        /* Init TX channel teardown */
+        adap_emac->TXTEARDOWN = 1;
+        for( cnt = 0; cnt != 0xFFFFFFFC; cnt = adap_emac->TX0CP){
+            /* Wait here for Tx teardown completion interrupt to occur 
+             * Note: A task delay can be called here to pend rather than 
+             * occupying CPU cycles - anyway it has been found that teardown 
+             * takes very few cpu cycles and does not affect functionality */
+            --dly;
+            udelay(1);
+            if (dly == 0) break;
+        }
+        adap_emac->TX0CP = cnt;
+        adap_emac->TX0HDP = 0;
+    }
+    else
+    {
+        /* Init RX channel teardown */
+        adap_emac->RXTEARDOWN = 1;
+        for( cnt = 0; cnt != 0xFFFFFFFC; cnt = adap_emac->RX0CP){
+            /* Wait here for Tx teardown completion interrupt to occur 
+             * Note: A task delay can be called here to pend rather than 
+             * occupying CPU cycles - anyway it has been found that teardown 
+             * takes very few cpu cycles and does not affect functionality */
+            --dly;
+            udelay(1);
+            if (dly == 0) break;
+        }
+        adap_emac->RX0CP = cnt;
+        adap_emac->RX0HDP = 0;
+    }
+    
+    debug_emac("- emac_ch_teardown\n");
+}
+
+/*
+ * This is called by the kernel in response to 'ifconfig ethX down'.  It
+ * is responsible for cleaning up everything that the open routine
+ * does, and maybe putting the card into a powerdown state.
+ */
+static int emac_close (void)
+{
+    debug_emac("+ emac_close\n");
+    
+    emac_ch_teardown(EMAC_CH_TX); /* TX Channel teardown */
+    emac_ch_teardown(EMAC_CH_RX); /* RX Channel teardown */
+
+    /* Reset EMAC module and disable interrupts in wrapper */
+    adap_emac->SOFTRESET = 1;
+    adap_ewrap->EWCTL = 0;
+    
+    debug_emac("- emac_close\n");
+    return (1);
+}
+
+static int tx_send_loop = 0;
+
+/*
+ * This function sends a single packet on the network and returns
+ * positive number (number of bytes transmitted) or negative for error
+ */
+static int emac_send_packet (volatile void *packet, int length)
+{
+    int ret_status = -1;
+    tx_send_loop = 0;
+    
+    /* Return error if no link */
+    emac_link_status = mdio_get_link_state(EMAC_MDIO_PHY_MASK);
+    if (emac_link_status == 0)
+    {
+        printf("WARN: emac_send_packet: No link\n");
+        return (ret_status);
+    }
+    
+    /* Check packet size and if < EMAC_MIN_ETHERNET_PKT_SIZE, pad it up */
+    if (length < EMAC_MIN_ETHERNET_PKT_SIZE)
+    {
+      length = EMAC_MIN_ETHERNET_PKT_SIZE;
+    }
+
+    /* Populate the TX descriptor */
+    emac_tx_desc->next         = 0;
+    emac_tx_desc->buffer       = (unsigned char *)packet;
+    emac_tx_desc->buff_off_len = (length & 0xFFFF);
+    emac_tx_desc->pkt_flag_len = ((length & 0xFFFF) | 
+                                  EMAC_CPPI_SOP_BIT | 
+                                  EMAC_CPPI_OWNERSHIP_BIT | 
+                                  EMAC_CPPI_EOP_BIT);
+    /* Send the packet */
+    adap_emac->TX0HDP = (unsigned int) emac_tx_desc;
+    
+    /* Wait for packet to complete or link down */
+    while (1)
+    {
+        emac_link_status = mdio_get_link_state(EMAC_MDIO_PHY_MASK);
+        if (emac_link_status == 0)
+        {
+            emac_ch_teardown(EMAC_CH_TX);
+            return (ret_status);
+        }
+        if (adap_emac->TXINTSTATRAW & 0x1)
+        {
+            ret_status = length;
+            break;
+        }
+        ++tx_send_loop;
+    }
+
+    return (ret_status);
+    
+}
+
+/*
+ * This function handles receipt of a packet from the network
+ */
+static int emac_rcv_packet (void)
+{
+    volatile emac_desc *rx_curr_desc;
+    volatile emac_desc *curr_desc;
+    volatile emac_desc *tail_desc;
+    unsigned int status, ret= -1;
+    
+    rx_curr_desc = emac_rx_active_head;
+    status = rx_curr_desc->pkt_flag_len;
+    if ((rx_curr_desc) && ((status & EMAC_CPPI_OWNERSHIP_BIT) == 0))
+    {
+        if (status & EMAC_CPPI_RX_ERROR_FRAME) {
+            /* Error in packet - discard it and requeue desc */
+		    printf("WARN: emac_rcv_pkt: Error in packet\n");
+        }
+        else {
+            NetReceive(rx_curr_desc->buffer, (rx_curr_desc->buff_off_len & 0xFFFF));
+		    ret = rx_curr_desc->buff_off_len & 0xFFFF;
+        }
+
+        /* Ack received packet descriptor */
+        adap_emac->RX0CP = (unsigned int) rx_curr_desc;
+        curr_desc = rx_curr_desc;
+        emac_rx_active_head = rx_curr_desc->next;
+        
+        if (status & EMAC_CPPI_EOQ_BIT) {
+            if (emac_rx_active_head) {
+                adap_emac->RX0HDP = (unsigned int) emac_rx_active_head;
+            } else {
+                emac_rx_queue_active = 0;
+                printf("INFO:emac_rcv_packet: RX Queue not active\n");
+            }
+        }
+        
+        /* Recycle RX descriptor */        
+        rx_curr_desc->buff_off_len = EMAC_MAX_ETHERNET_PKT_SIZE;
+        rx_curr_desc->pkt_flag_len = EMAC_CPPI_OWNERSHIP_BIT;
+        rx_curr_desc->next = 0;
+
+        if (emac_rx_active_head == 0) {
+            printf("INFO: emac_rcv_pkt: active queue head = 0\n");
+            emac_rx_active_head = curr_desc;
+            emac_rx_active_tail = curr_desc;
+            if (emac_rx_queue_active != 0) {
+                adap_emac->RX0HDP = (unsigned int) emac_rx_active_head;
+                printf("INFO: emac_rcv_pkt: active queue head = 0, HDP fired\n");
+                emac_rx_queue_active = 1;
+            }
+        } else {
+
+            tail_desc = emac_rx_active_tail;
+            emac_rx_active_tail = curr_desc;
+            tail_desc->next = curr_desc;
+            status = tail_desc->pkt_flag_len;
+            if (status & EMAC_CPPI_EOQ_BIT) {
+                adap_emac->RX0HDP = (unsigned int) curr_desc;
+                status &= ~EMAC_CPPI_EOQ_BIT;
+                tail_desc->pkt_flag_len = status;
+            }
+        }   
+	    return ret;
+    }
+    return (0);
+}
+
+#endif /* CONFIG_COMMANDS & CFG_CMD_NET */
+
+#endif /* CONFIG_DRIVER_TI_EMAC */
diff -Nurd u-boot-1.2.0/board/davinci/dm644x_emac.h u-boot-1.2.0-leopard/board/davinci/dm644x_emac.h
--- u-boot-1.2.0/board/davinci/dm644x_emac.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/davinci/dm644x_emac.h	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,290 @@
+/*
+ * dm644x_emac.h
+ *
+ * TI DaVinci (DM644X) EMAC peripheral driver header for DV-EVM
+ *
+ * Copyright (C) 2005 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ 
+ * Modifications:
+ * ver. 1.0: Sep 2005, TI PSP Team - Created EMAC version for uBoot.
+ *
+ */
+ 
+#ifndef _DM644X_EMAC_H_
+#define _DM644X_EMAC_H_
+
+/***********************************************
+ ********** Configurable items *****************
+ ***********************************************/
+ 
+/* Addresses of EMAC module in DaVinci */
+#define EMAC_BASE_ADDR             (0x01C80000)
+#define EMAC_WRAPPER_BASE_ADDR     (0x01C81000)
+#define EMAC_WRAPPER_RAM_ADDR      (0x01C82000)
+#define EMAC_MDIO_BASE_ADDR        (0x01C84000)
+
+/* MDIO module input frequency */
+#define EMAC_MDIO_BUS_FREQ          76500000    /* PLL/6 - 76.5 MHz */
+/* MDIO clock output frequency */
+#define EMAC_MDIO_CLOCK_FREQ        2200000     /* 2.2 MHz */
+
+/* PHY mask - set only those phy number bits where phy is/can be connected */
+#define EMAC_MDIO_PHY_MASK          0xFFFFFFFF
+
+/* Ethernet Min/Max packet size */
+#define EMAC_MIN_ETHERNET_PKT_SIZE  60
+#define EMAC_MAX_ETHERNET_PKT_SIZE  1518
+#define EMAC_PKT_ALIGN              18  /* 1518 + 18 = 1536 (packet aligned on 32 byte boundry) */
+
+/* Number of RX packet buffers
+ * NOTE: Only 1 buffer supported as of now 
+ */
+#define EMAC_MAX_RX_BUFFERS         10
+
+/***********************************************
+ ******** Internally used macros ***************
+ ***********************************************/
+
+#define EMAC_CH_TX                  1 
+#define EMAC_CH_RX                  0
+
+/* Each descriptor occupies 4, lets start RX desc's at 0 and 
+ * reserve space for 64 descriptors max
+ */
+#define EMAC_RX_DESC_BASE           0x0
+#define EMAC_TX_DESC_BASE           0x1000
+
+/* EMAC Teardown value */
+#define EMAC_TEARDOWN_VALUE         0xFFFFFFFC
+
+/* MII Status Register */
+#define MII_STATUS_REG              1
+
+/* Intel LXT971 Digtal Config Register */
+#define MII_DIGITAL_CONFIG_REG      26
+
+/* Number of statistics registers */
+#define EMAC_NUM_STATS              36
+
+/* EMAC Descriptor */
+typedef volatile struct _emac_desc 
+{
+  unsigned int      next;           /* Pointer to next descriptor in chain */
+  unsigned char     *buffer;        /* Pointer to data buffer              */
+  unsigned int      buff_off_len;   /* Buffer Offset(MSW) and Length(LSW)  */
+  unsigned int      pkt_flag_len;   /* Packet Flags(MSW) and Length(LSW)   */
+} emac_desc;
+
+/* CPPI bit positions */
+#define EMAC_CPPI_SOP_BIT               (0x80000000)  /*(1 << 31)*/
+#define EMAC_CPPI_EOP_BIT               (0x40000000)  /*(1 << 30*/
+#define EMAC_CPPI_OWNERSHIP_BIT         (0x20000000)  /*(1 << 29)*/
+#define EMAC_CPPI_EOQ_BIT               (0x10000000)  /*(1 << 28)*/
+#define EMAC_CPPI_TEARDOWN_COMPLETE_BIT (0x08000000)  /*(1 << 27)*/
+#define EMAC_CPPI_PASS_CRC_BIT          (0x04000000)  /*(1 << 26)*/
+
+#define EMAC_CPPI_RX_ERROR_FRAME        (0x03FC0000)
+
+#define EMAC_MACCONTROL_MIIEN_ENABLE        (0x20)
+#define EMAC_MACCONTROL_FULLDUPLEX_ENABLE   (0x1)
+
+#define EMAC_RXMBPENABLE_RXCAFEN_ENABLE     (0x200000)
+#define EMAC_RXMBPENABLE_RXBROADEN          (0x2000)
+
+
+#define MDIO_CONTROL_ENABLE             (0x40000000)
+#define MDIO_CONTROL_FAULT              (0x80000)
+#define MDIO_USERACCESS0_GO             (0x80000000)
+#define MDIO_USERACCESS0_WRITE_READ     (0x0)
+#define MDIO_USERACCESS0_WRITE_WRITE    (0x40000000)
+
+
+
+/* EMAC Register overlay */
+
+/* Ethernet MAC Register Overlay Structure */
+typedef volatile struct  {
+    unsigned int TXIDVER;
+    unsigned int TXCONTROL;
+    unsigned int TXTEARDOWN;
+    unsigned char RSVD0[4];
+    unsigned int RXIDVER;
+    unsigned int RXCONTROL;
+    unsigned int RXTEARDOWN;
+    unsigned char RSVD1[100];
+    unsigned int TXINTSTATRAW;
+    unsigned int TXINTSTATMASKED;
+    unsigned int TXINTMASKSET;
+    unsigned int TXINTMASKCLEAR;
+    unsigned int MACINVECTOR;
+    unsigned char RSVD2[12];
+    unsigned int RXINTSTATRAW;
+    unsigned int RXINTSTATMASKED;
+    unsigned int RXINTMASKSET;
+    unsigned int RXINTMASKCLEAR;
+    unsigned int MACINTSTATRAW;
+    unsigned int MACINTSTATMASKED;
+    unsigned int MACINTMASKSET;
+    unsigned int MACINTMASKCLEAR;
+    unsigned char RSVD3[64];
+    unsigned int RXMBPENABLE;
+    unsigned int RXUNICASTSET;
+    unsigned int RXUNICASTCLEAR;
+    unsigned int RXMAXLEN;
+    unsigned int RXBUFFEROFFSET;
+    unsigned int RXFILTERLOWTHRESH;
+    unsigned char RSVD4[8];
+    unsigned int RX0FLOWTHRESH;
+    unsigned int RX1FLOWTHRESH;
+    unsigned int RX2FLOWTHRESH;
+    unsigned int RX3FLOWTHRESH;
+    unsigned int RX4FLOWTHRESH;
+    unsigned int RX5FLOWTHRESH;
+    unsigned int RX6FLOWTHRESH;
+    unsigned int RX7FLOWTHRESH;
+    unsigned int RX0FREEBUFFER;
+    unsigned int RX1FREEBUFFER;
+    unsigned int RX2FREEBUFFER;
+    unsigned int RX3FREEBUFFER;
+    unsigned int RX4FREEBUFFER;
+    unsigned int RX5FREEBUFFER;
+    unsigned int RX6FREEBUFFER;
+    unsigned int RX7FREEBUFFER;
+    unsigned int MACCONTROL;
+    unsigned int MACSTATUS;
+    unsigned int EMCONTROL;
+    unsigned int FIFOCONTROL;
+    unsigned int MACCONFIG;
+    unsigned int SOFTRESET;
+    unsigned char RSVD5[88];
+    unsigned int MACSRCADDRLO;
+    unsigned int MACSRCADDRHI;
+    unsigned int MACHASH1;
+    unsigned int MACHASH2;
+    unsigned int BOFFTEST;
+    unsigned int TPACETEST;
+    unsigned int RXPAUSE;
+    unsigned int TXPAUSE;
+    unsigned char RSVD6[16];
+    unsigned int RXGOODFRAMES;
+    unsigned int RXBCASTFRAMES;
+    unsigned int RXMCASTFRAMES;
+    unsigned int RXPAUSEFRAMES;
+    unsigned int RXCRCERRORS;
+    unsigned int RXALIGNCODEERRORS;
+    unsigned int RXOVERSIZED;
+    unsigned int RXJABBER;
+    unsigned int RXUNDERSIZED;
+    unsigned int RXFRAGMENTS;
+    unsigned int RXFILTERED;
+    unsigned int RXQOSFILTERED;
+    unsigned int RXOCTETS;
+    unsigned int TXGOODFRAMES;
+    unsigned int TXBCASTFRAMES;
+    unsigned int TXMCASTFRAMES;
+    unsigned int TXPAUSEFRAMES;
+    unsigned int TXDEFERRED;
+    unsigned int TXCOLLISION;
+    unsigned int TXSINGLECOLL;
+    unsigned int TXMULTICOLL;
+    unsigned int TXEXCESSIVECOLL;
+    unsigned int TXLATECOLL;
+    unsigned int TXUNDERRUN;
+    unsigned int TXCARRIERSENSE;
+    unsigned int TXOCTETS;
+    unsigned int FRAME64;
+    unsigned int FRAME65T127;
+    unsigned int FRAME128T255;
+    unsigned int FRAME256T511;
+    unsigned int FRAME512T1023;
+    unsigned int FRAME1024TUP;
+    unsigned int NETOCTETS;
+    unsigned int RXSOFOVERRUNS;
+    unsigned int RXMOFOVERRUNS;
+    unsigned int RXDMAOVERRUNS;
+    unsigned char RSVD7[624];
+    unsigned int MACADDRLO;
+    unsigned int MACADDRHI;
+    unsigned int MACINDEX;
+    unsigned char RSVD8[244];
+    unsigned int TX0HDP;
+    unsigned int TX1HDP;
+    unsigned int TX2HDP;
+    unsigned int TX3HDP;
+    unsigned int TX4HDP;
+    unsigned int TX5HDP;
+    unsigned int TX6HDP;
+    unsigned int TX7HDP;
+    unsigned int RX0HDP;
+    unsigned int RX1HDP;
+    unsigned int RX2HDP;
+    unsigned int RX3HDP;
+    unsigned int RX4HDP;
+    unsigned int RX5HDP;
+    unsigned int RX6HDP;
+    unsigned int RX7HDP;
+    unsigned int TX0CP;
+    unsigned int TX1CP;
+    unsigned int TX2CP;
+    unsigned int TX3CP;
+    unsigned int TX4CP;
+    unsigned int TX5CP;
+    unsigned int TX6CP;
+    unsigned int TX7CP;
+    unsigned int RX0CP;
+    unsigned int RX1CP;
+    unsigned int RX2CP;
+    unsigned int RX3CP;
+    unsigned int RX4CP;
+    unsigned int RX5CP;
+    unsigned int RX6CP;
+    unsigned int RX7CP;
+} emac_regs;
+
+/* EMAC Wrapper Register Overlay */
+typedef volatile struct  {
+    volatile unsigned char RSVD0[4100];
+    volatile unsigned int EWCTL;
+    volatile unsigned int EWINTTCNT;
+} ewrap_regs;
+
+
+/* EMAC MDIO Register Overlay */
+typedef volatile struct  {
+    volatile unsigned int VERSION;
+    volatile unsigned int CONTROL;
+    volatile unsigned int ALIVE;
+    volatile unsigned int LINK;
+    volatile unsigned int LINKINTRAW;
+    volatile unsigned int LINKINTMASKED;
+    volatile unsigned char RSVD0[8];
+    volatile unsigned int USERINTRAW;
+    volatile unsigned int USERINTMASKED;
+    volatile unsigned int USERINTMASKSET;
+    volatile unsigned int USERINTMASKCLEAR;
+    volatile unsigned char RSVD1[80];
+    volatile unsigned int USERACCESS0;
+    volatile unsigned int USERPHYSEL0;
+    volatile unsigned int USERACCESS1;
+    volatile unsigned int USERPHYSEL1;
+} mdio_regs;
+
+
+#endif  /* _DM644X_EMAC_H_ */
diff -Nurd u-boot-1.2.0/board/davinci/flash.c u-boot-1.2.0-leopard/board/davinci/flash.c
--- u-boot-1.2.0/board/davinci/flash.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/davinci/flash.c	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,686 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2003
+ * Reinhard Meyer, EMK Elektronik GmbH, r.meyer@emk-elektronik.de
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */	
+
+#include <common.h>
+#include <linux/byteorder/swab.h>
+#include "types.h"
+
+flash_info_t	flash_info[CFG_MAX_FLASH_BANKS]; /* info for FLASH chips */
+
+#if defined (CFG_DAVINCI)
+  typedef unsigned short FLASH_PORT_WIDTH;
+  typedef volatile unsigned short FLASH_PORT_WIDTHV;
+  #define	FLASH_ID_MASK	0xFF
+
+  #define FPW	FLASH_PORT_WIDTH
+  #define FPWV	FLASH_PORT_WIDTHV
+
+  #define FLASH_CYCLE1	0x0555
+  #define FLASH_CYCLE2	0x02aa
+  #define FLASH_ID1		0
+  #define FLASH_ID2		1
+  #define FLASH_ID3		0x0e
+  #define FLASH_ID4		0x0F
+  #define SWAP(x)			__swab16(x)
+#endif
+
+#if defined (CONFIG_TOP860)
+  typedef unsigned short FLASH_PORT_WIDTH;
+  typedef volatile unsigned short FLASH_PORT_WIDTHV;
+  #define	FLASH_ID_MASK	0xFF
+
+  #define FPW	FLASH_PORT_WIDTH
+  #define FPWV	FLASH_PORT_WIDTHV
+
+  #define FLASH_CYCLE1	0x0555
+  #define FLASH_CYCLE2	0x02aa
+  #define FLASH_ID1		0
+  #define FLASH_ID2		1
+  #define FLASH_ID3		0x0e
+  #define FLASH_ID4		0x0F
+#endif
+
+#if defined (CONFIG_TOP5200) && !defined (CONFIG_LITE5200)
+  typedef unsigned char FLASH_PORT_WIDTH;
+  typedef volatile unsigned char FLASH_PORT_WIDTHV;
+  #define	FLASH_ID_MASK	0xFF
+
+  #define FPW	FLASH_PORT_WIDTH
+  #define FPWV	FLASH_PORT_WIDTHV
+
+  #define FLASH_CYCLE1	0x0aaa
+  #define FLASH_CYCLE2	0x0555
+  #define FLASH_ID1		0
+  #define FLASH_ID2		2
+  #define FLASH_ID3		0x1c
+  #define FLASH_ID4		0x1E
+#endif
+
+#if defined (CONFIG_TOP5200) && defined (CONFIG_LITE5200)
+  typedef unsigned char FLASH_PORT_WIDTH;
+  typedef volatile unsigned char FLASH_PORT_WIDTHV;
+  #define	FLASH_ID_MASK	0xFF
+
+  #define FPW	FLASH_PORT_WIDTH
+  #define FPWV	FLASH_PORT_WIDTHV
+
+  #define FLASH_CYCLE1	0x0555
+  #define FLASH_CYCLE2	0x02aa
+  #define FLASH_ID1		0
+  #define FLASH_ID2		1
+  #define FLASH_ID3		0x0E
+  #define FLASH_ID4		0x0F
+#endif
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size(FPWV *addr, flash_info_t *info);
+static void flash_reset(flash_info_t *info);
+static int write_word(flash_info_t *info, FPWV *dest, FPW data);
+static flash_info_t *flash_get_info(ulong base);
+void inline spin_wheel (void);
+
+/*-----------------------------------------------------------------------
+ * flash_init()
+ *
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long flash_init (void)
+{
+	unsigned long size = 0;
+	int i = 0;
+	extern void flash_preinit(void);
+	extern void flash_afterinit(uint, ulong, ulong);
+	ulong flashbase = CFG_FLASH_BASE;
+
+	/*flash_preinit();*/
+
+	/* There is only ONE FLASH device */
+	memset(&flash_info[i], 0, sizeof(flash_info_t));
+	flash_info[i].size =
+			flash_get_size((FPW *)flashbase, &flash_info[i]);
+	size += flash_info[i].size;
+
+#if CFG_MONITOR_BASE >= CFG_FLASH_BASE
+	/* monitor protection ON by default */
+	flash_protect(FLAG_PROTECT_SET,
+		      CFG_MONITOR_BASE,
+		      CFG_MONITOR_BASE+monitor_flash_len-1,
+		      flash_get_info(CFG_MONITOR_BASE));
+#endif
+
+#ifdef	CFG_ENV_IS_IN_FLASH
+	/* ENV protection ON by default */
+	flash_protect(FLAG_PROTECT_SET,
+		      CFG_ENV_ADDR,
+		      CFG_ENV_ADDR+CFG_ENV_SIZE-1,
+		      flash_get_info(CFG_ENV_ADDR));
+#endif
+
+
+	/*flash_afterinit(i, flash_info[i].start[0], flash_info[i].size);*/
+	return size ? size : 1;
+}
+
+/*-----------------------------------------------------------------------
+ */
+static void flash_reset(flash_info_t *info)
+{
+	FPWV *base = (FPWV *)(info->start[0]);
+
+	/* Put FLASH back in read mode */
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL)
+		*base = (FPW)0x00FF00FF;	/* Intel Read Mode */
+	else if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD)
+		*base = (FPW)0x00F000F0;	/* AMD Read Mode */
+}
+
+
+void flash_reset_sector(flash_info_t *info, ULONG addr)
+{  
+	// Reset Flash to be in Read Array Mode 
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL)
+		*(FPWV *)addr = (FPW)0x00FF00FF;	/* Intel Read Mode */
+	else if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD)
+		*(FPWV *)addr = (FPW)0x00F000F0;	/* AMD Read Mode */
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+static flash_info_t *flash_get_info(ulong base)
+{
+	int i;
+	flash_info_t * info;
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i ++) {
+		info = & flash_info[i];
+		if (info->size &&
+			info->start[0] <= base && base <= info->start[0] + info->size - 1)
+			break;
+	}
+
+	return i == CFG_MAX_FLASH_BANKS ? 0 : info;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+void flash_print_info (flash_info_t *info)
+{
+	int i;
+	uchar *boottype;
+	uchar *bootletter;
+	uchar *fmt;
+	uchar botbootletter[] = "B";
+	uchar topbootletter[] = "T";
+	uchar botboottype[] = "bottom boot sector";
+	uchar topboottype[] = "top boot sector";
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		printf ("missing or unknown FLASH type\n");
+		return;
+	}
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case FLASH_MAN_AMD:	printf ("MY AMD ");		break;
+#if 0
+	case FLASH_MAN_BM:	printf ("BRIGHT MICRO ");	break;
+	case FLASH_MAN_FUJ:	printf ("FUJITSU ");		break;
+	case FLASH_MAN_SST:	printf ("SST ");		break;
+	case FLASH_MAN_STM:	printf ("STM ");		break;
+#endif
+	case FLASH_MAN_INTEL:	printf ("INTEL ");		break;
+	default:		printf ("Unknown Vendor ");	break;
+	}
+
+	/* check for top or bottom boot, if it applies */
+	if (info->flash_id & FLASH_BTYPE) {
+		boottype = botboottype;
+		bootletter = botbootletter;
+	}
+	else {
+		boottype = topboottype;
+		bootletter = topbootletter;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_AM160T:
+	case FLASH_AM160B:
+		fmt = "29LV160%s (16 Mbit, %s)\n";
+		break;
+	case FLASH_AMLV640U:
+		fmt = "29LV640M (64 Mbit)\n";
+		break;
+	case FLASH_AMDLV065D:
+		fmt = "29LV065D (64 Mbit)\n";
+		break;
+	case FLASH_AMLV256U:
+		fmt = "29LV256M (256 Mbit)\n";
+		break;
+	case FLASH_28F128P30T:
+		fmt = "28F128P30T\n";
+		break;
+	default:
+		fmt = "Unknown Chip Type\n";
+		break;
+	}
+
+	printf (fmt, bootletter, boottype);
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+		info->size >> 20,
+		info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+
+	for (i=0; i<info->sector_count; ++i) {
+		ulong	size;
+		int		erased;
+		ulong	*flash = (unsigned long *) info->start[i];
+
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+
+		/*
+		 * Check if whole sector is erased
+		 */
+		size =
+			(i != (info->sector_count - 1)) ?
+			(info->start[i + 1] - info->start[i]) >> 2 :
+		(info->start[0] + info->size - info->start[i]) >> 2;
+
+		for (
+			flash = (unsigned long *) info->start[i], erased = 1;
+				(flash != (unsigned long *) info->start[i] + size) && erased;
+					flash++
+			)
+			erased = *flash == ~0x0UL;
+
+		printf (" %08lX %s %s",
+			info->start[i],
+			erased ? "E": " ",
+			info->protect[i] ? "(RO)" : "    ");
+	}
+
+	printf ("\n");
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+/*
+ * The following code cannot be run from FLASH!
+ */
+
+ulong flash_get_size (FPWV *addr, flash_info_t *info)
+{
+	int		i;
+
+	/* Write auto select command: read Manufacturer ID */
+	/* Write auto select command sequence and test FLASH answer */
+	addr[FLASH_CYCLE1] = (FPW)0x00AA00AA;	/* for AMD, Intel ignores this */
+	addr[FLASH_CYCLE2] = (FPW)0x00550055;	/* for AMD, Intel ignores this */
+	addr[FLASH_CYCLE1] = (FPW)0x00900090;	/* selects Intel or AMD */
+
+	/* The manufacturer codes are only 1 byte, so just use 1 byte.
+	 * This works for any bus width and any FLASH device width.
+	 */
+	udelay(100);
+	switch (addr[FLASH_ID1] & 0xff) {
+
+	case (uchar)AMD_MANUFACT:
+		printf ("MY AMD ", addr[FLASH_ID1] & 0xff);
+		info->flash_id = FLASH_MAN_AMD;
+		break;
+
+	case (uchar)INTEL_MANUFACT:
+                printf ("INTEL ", addr[FLASH_ID1] & 0xff);
+		info->flash_id = FLASH_MAN_INTEL;
+		break;
+
+	default:
+		printf ("unknown vendor=%x ", addr[FLASH_ID1] & 0xff);
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		break;
+	}
+
+	/* Check 16 bits or 32 bits of ID so work on 32 or 16 bit bus. */
+	if (info->flash_id != FLASH_UNKNOWN) switch ((FPW)addr[FLASH_ID2]) {
+
+	case (FPW)AMD_ID_LV160B:
+		info->flash_id += FLASH_AM160B;
+		info->sector_count = 35;
+		info->size = 0x00200000;
+		info->start[0] = (ulong)addr;
+		info->start[1] = (ulong)addr + 0x4000;
+		info->start[2] = (ulong)addr + 0x6000;
+		info->start[3] = (ulong)addr + 0x8000;
+		for (i = 4; i < info->sector_count; i++)
+		{
+			info->start[i] = (ulong)addr + 0x10000 * (i-3);
+		}
+		break;
+
+	case (FPW)AMD_ID_LV065D:
+		info->flash_id += FLASH_AMDLV065D;
+		info->sector_count = 128;
+		info->size = 0x00800000;
+		for (i = 0; i < info->sector_count; i++)
+		{
+			info->start[i] = (ulong)addr + 0x10000 * i;
+		}
+		break;
+
+	case (FPW)AMD_ID_MIRROR:
+		/* MIRROR BIT FLASH, read more ID bytes */
+		if ((FPW)addr[FLASH_ID3] == (FPW)AMD_ID_LV640U_2 &&
+			(FPW)addr[FLASH_ID4] == (FPW)AMD_ID_LV640U_3)
+		{
+			info->flash_id += FLASH_AMLV640U;
+			info->sector_count = 128;
+			info->size = 0x00800000;
+			for (i = 0; i < info->sector_count; i++)
+			{
+				info->start[i] = (ulong)addr + 0x10000 * i;
+			}
+			break;
+		}
+		if ((FPW)addr[FLASH_ID3] == (FPW)AMD_ID_LV256U_2 &&
+			(FPW)addr[FLASH_ID4] == (FPW)AMD_ID_LV256U_3)
+		{
+			/* attention: only the first 16 MB will be used in u-boot */
+			info->flash_id += FLASH_AMLV256U;
+			info->sector_count = 256;
+			info->size = 0x01000000;
+			for (i = 0; i < info->sector_count; i++)
+			{
+				info->start[i] = (ulong)addr + 0x10000 * i;
+			}
+			break;
+		}
+	case (FPW)INTEL_ID_28F128P30T:
+		/* Intel StrataFlash 28F128P30T */
+		info->flash_id += FLASH_28F128P30T;
+		info->sector_count = 131;
+		info->size = 0x01000000;
+		for (i = 0; i < info->sector_count; i++)
+		{
+			if (i < 127)
+				info->start[i] = (ulong)addr + 0x20000 * i;
+			else
+				info->start[i] = (ulong)addr + 0xfe0000 + 0x8000 * (i-127);
+		}
+		break;
+
+		/* fall thru to here ! */
+	default:
+		printf ("unknown AMD device=%x %x %x",
+			(FPW)addr[FLASH_ID2],
+			(FPW)addr[FLASH_ID3],
+			(FPW)addr[FLASH_ID4]);
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0x800000;
+		break;
+	}
+
+	/* Put FLASH back in read mode */
+	flash_reset(info);
+
+	return (info->size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int	flash_erase (flash_info_t *info, int s_first, int s_last)
+{
+	FPWV *addr;
+	int flag, prot, sect;
+	int intel = (info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL;
+	ulong start, now, last;
+	int rcode = 0;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		if (info->flash_id == FLASH_UNKNOWN) {
+			printf ("- missing\n");
+		} else {
+			printf ("- no sectors to erase\n");
+		}
+		return 1;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_AM160B:
+	case FLASH_AMLV640U:
+		break;
+	case FLASH_AMLV256U:
+		break;
+	case FLASH_28F128P30T:
+		break;
+	case FLASH_UNKNOWN:
+	default:
+		printf ("Can't erase unknown flash type %08lx - aborted\n",
+			info->flash_id);
+		return 1;
+	}
+
+	prot = 0;
+	for (sect=s_first; sect<=s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n",
+			prot);
+	} else {
+		printf ("\n");
+	}
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect<=s_last && rcode == 0; sect++) {
+
+		if (info->protect[sect] != 0)	/*bmw           esteem192e     ispan         mx1fs2       RPXlite      tqm8540
+ protected, skip it */
+			continue;
+
+		printf ("Erasing sector %2d ... ", sect);
+		addr = (FPWV *)(info->start[sect]);
+
+		if (intel) {
+			*addr = (FPW)0x00600060; /* unlock block setup */
+			*addr = (FPW)0x00d000d0; /* unlock block confirm */
+			*addr = (FPW)0x00500050; /* clear status register */
+			*addr = (FPW)0x00200020; /* erase setup */
+			*addr = (FPW)0x00D000D0; /* erase confirm */
+			while((*addr & 0x80) == 0);
+			printf("done.\n");
+		}
+		else {
+			/* must be AMD style if not Intel */
+			FPWV *base;		/* first address in bank */
+
+			base = (FPWV *)(info->start[0]);
+			base[FLASH_CYCLE1] = (FPW)0x00AA00AA;	/* unlock */
+			base[FLASH_CYCLE2] = (FPW)0x00550055;	/* unlock */
+			base[FLASH_CYCLE1] = (FPW)0x00800080;	/* erase mode */
+			base[FLASH_CYCLE1] = (FPW)0x00AA00AA;	/* unlock */
+			base[FLASH_CYCLE2] = (FPW)0x00550055;	/* unlock */
+			*addr = (FPW)0x00300030;	/* erase sector */
+			while (*((vHwdptr)addr) != 0xffff);
+			printf("done.\n");
+		}
+
+	}
+
+	/* Put FLASH back in read mode */
+	flash_reset(info);
+
+	printf (" Erase Operation Completed.\n");
+	return rcode;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+int write_buff (flash_info_t *info, uchar *src, ulong addr, ulong cnt)
+{
+	FPW data = 0; /* 16 or 32 bit word, matches flash bus width on MPC8XX */
+	int bytes;	  /* number of bytes to program in current word		*/
+	int left;	  /* number of bytes left to program			*/
+	int res;
+	ulong cp, wp;
+	int count, i, l, rc, port_width;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		return 4;
+		}
+
+	/* get lower word aligned address */
+	wp = (addr & ~1);
+	port_width = 2;
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+		for (; i < port_width && cnt > 0; ++i) {
+			data = (data << 8) | *src++;
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < port_width; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+
+		if ((rc = write_word (info, wp, SWAP (data))) != 0) {
+			return (rc);
+		}
+		wp += port_width;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	count = 0;
+	while (cnt >= port_width) {
+		data = 0;
+		for (i = 0; i < port_width; ++i) {
+			data = (data << 8) | *src++;
+		}
+		if ((rc = write_word (info, wp, SWAP (data))) != 0) {
+			return (rc);
+		}
+		wp += port_width;
+		cnt -= port_width;
+
+		if (count++ > 0x800) {
+			spin_wheel ();
+			count = 0;
+		}
+	}
+
+	if (cnt == 0) {
+		return (0);
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < port_width && cnt > 0; ++i, ++cp) {
+		data = (data << 8) | *src++;
+		--cnt;
+	}
+	for (; i < port_width; ++i, ++cp) {
+		data = (data << 8) | (*(uchar *) cp);
+	}
+
+	return (write_word (info, wp, SWAP (data)));
+}
+
+/*-----------------------------------------------------------------------
+ * Write a word to Flash
+ * A word is 16 or 32 bits, whichever the bus width of the flash bank
+ * (not an individual chip) is.
+ *
+ * returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+static int write_word (flash_info_t *info, FPWV *plAddress, FPW ulData)
+{
+	ulong start;
+	int flag;
+	int res = 0;	/* result, assume success	*/
+	FPWV *base;		/* first address in flash bank	*/
+	volatile USHORT *psAddress;
+	volatile USHORT *address_cs;
+	USHORT tmp;
+	ULONG tmp_ptr;
+
+	// Lower WORD.
+	psAddress = (USHORT *)plAddress;
+	tmp_ptr  = (ULONG) plAddress;
+	address_cs = (USHORT *) (tmp_ptr & 0xFE000000);
+
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL)
+	{
+		*plAddress = (FPW)0x00400040;
+		*plAddress = ulData;
+		while ((*plAddress & 0x80) == 0);
+	}
+	else if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD)
+	{
+		*((vHwdptr)address_cs + 0x555) = ((Hwd)0xAA);
+		*((vHwdptr)address_cs + 0x2AA) = ((Hwd)0x55);
+		*((vHwdptr)address_cs + 0x555) = ((Hwd)0xA0);
+		*psAddress = ulData;
+		// Wait for ready.
+		while (1)
+		{
+			tmp = *psAddress; 
+			if( (tmp & 0x80)  == (ulData & 0x80)) 
+			{
+				break;
+			}
+			else
+			{
+				if(tmp & 0x20)             // Exceeded Time Limit
+			{
+				tmp = *psAddress; 
+				if( (tmp & 0x80)  == (ulData & 0x80)) 
+				{
+					break; 
+				}
+				else
+				{
+				  	flash_reset_sector(info, (ULONG) psAddress);
+			      	return 1;
+				}	
+			}
+			}
+		}
+	}
+
+	// Return to read mode
+	flash_reset_sector(info, (ULONG) psAddress);
+
+	// Verify the data.
+	if (*psAddress != ulData)
+	{
+     	return 1;
+	printf("Write of one 16-bit word failed\n");
+	}
+	return 0;
+}
+
+void inline spin_wheel (void)
+{
+	static int p = 0;
+	static char w[] = "\\/-";
+
+	printf ("\010%c", w[p]);
+	(++p == 3) ? (p = 0) : 0;
+}
diff -Nurd u-boot-1.2.0/board/davinci/flash_params.h u-boot-1.2.0-leopard/board/davinci/flash_params.h
--- u-boot-1.2.0/board/davinci/flash_params.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/davinci/flash_params.h	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,319 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ *
+ */
+#ifndef _FLASH_PARAMSH_
+#define _FLASH_PARAMSH_
+//
+//Structs
+//
+typedef struct _PageInfo
+{
+    	ULONG	reserved;
+    	BYTE  	BlockReserved;
+    	BYTE  	BadBlockFlag;
+    	USHORT	reserved2;
+}PageInfo, *PPageInfo;
+
+typedef struct
+{
+	ULONG ReturnValue;
+	ULONG ReadAddress;
+	ULONG WriteAddress;
+	ULONG Size;
+} Download_Parms, *PDownload_Parms;
+
+#define NO_ERROR            0
+#define CORRECTED_ERROR     1
+#define ECC_ERROR           2
+#define UNCORRECTED_ERROR   3
+
+
+#define BIT0    0x00000001
+#define BIT1    0x00000002
+#define BIT2    0x00000004
+#define BIT3    0x00000008
+#define BIT4    0x00000010
+#define BIT5    0x00000020
+#define BIT6    0x00000040
+#define BIT7    0x00000080
+#define BIT8    0x00000100
+#define BIT9    0x00000200
+#define BIT10   0x00000400
+#define BIT11   0x00000800
+#define BIT12   0x00001000
+#define BIT13   0x00002000
+#define BIT14   0x00004000
+#define BIT15   0x00008000
+#define BIT16   0x00010000
+#define BIT17   0x00020000
+#define BIT18   0x00040000
+#define BIT19   0x00080000
+#define BIT20   0x00100000
+#define BIT21   0x00200000
+#define BIT22   0x00400000
+#define BIT23   0x00800000
+#define BIT24   0x01000000
+#define BIT25   0x02000000
+#define BIT26   0x04000000
+#define BIT27   0x08000000
+#define BIT28   0x10000000
+#define BIT29   0x20000000
+#define BIT30   0x40000000
+#define BIT31   0x80000000
+
+
+
+//  Status bit pattern
+#define STATUS_READY                0x40
+#define STATUS_ERROR                0x01
+//
+//NOR SUPPORT
+//
+// Flash ID Commands INTEL
+#define INTEL_ID_CMD       ((Hwd)0x0090)     	// INTEL ID CMD
+#define INTEL_MANF_ID      ((Hwd)0x0089)     	// INTEL Manf ID expected
+#define INTEL_DEVICE_8T    ((Hwd)0x88F1)     	// INTEL 8Mb top device code
+#define INTEL_DEVICE_8B    ((Hwd)0x88F2)     	// INTEL 8Mb bottom device code
+#define INTEL_DEVICE_16T   ((Hwd)0x88F3)     	// INTEL 16Mb top device code
+#define INTEL_DEVICE_16B   ((Hwd)0x88F4)     	// INTEL 16Mb bottom device code
+#define INTELS_J3_DEVICE_32   ((Hwd)0x0016)     // INTEL Strata J3 32Mb device code
+#define INTELS_J3_DEVICE_64   ((Hwd)0x0017)     // INTEL Strata J3 64Mb device code
+#define INTELS_J3_DEVICE_128  ((Hwd)0x0018)     // INTEL Strata J3 128Mb device code
+#define INTELS_K3_DEVICE_64   ((Hwd)0x8801)     // INTEL Strata K3 64Mb device code
+#define INTELS_K3_DEVICE_128  ((Hwd)0x8802)    	// INTEL Strata K3 128Mb device code
+#define INTELS_K3_DEVICE_256  ((Hwd)0x8803)     // INTEL Strata K3 256Mb device code
+#define INTELS_W18_DEVICE_128T  ((Hwd)0x8876)   // INTEL Wirless Flash Top 128 Mb device code
+#define INTELS_W18_DEVICE_128B  ((Hwd)0x8867)   // INTEL Wirless Flash Bottom 128 Mb device code
+#define INTELS_L18_DEVICE_128T  ((Hwd)0x880C)   // INTEL Wirless Flash Top 128 Mb device code
+#define INTELS_L18_DEVICE_128B  ((Hwd)0x880F)   // INTEL Wirless Flash Bottom 128 Mb device code
+#define INTELS_L18_DEVICE_256T  ((Hwd)0x880D)   // INTEL Wirless Flash Top 256 Mb device code
+#define INTELS_L18_DEVICE_256B  ((Hwd)0x8810)  	// INTEL Wirless Flash Bottom 256 Mb device code
+#define INTELS_K18_DEVICE_256B  ((Hwd)0x8807)  	// INTEL Wirless Flash Bottom 256 Mb device code
+#define AMD1_DEVICE_ID     ((Hwd)0x2253)   // AMD29DL323CB
+#define AMD2_DEVICE_ID     ((Hwd)0x2249)   // AMD29LV160D
+#define AMD3_DEVICE_ID1    ((Hwd)0x2212)   // AMD29LV256M
+#define AMD3_DEVICE_ID2    ((Hwd)0x2201)   // AMD29LV256M
+// Flash ID Commands FUJITSU (Programs like AMD)
+#define FUJITSU_MANF_ID    ((Hwd)0x04)        // Fujitsu Manf ID expected
+#define FUJITSU1_DEVICE_ID     ((Hwd)0x2253)  // MBM29DL323BD
+//Micron Programs Like Intel or Micron
+#define MICRON_MANF_ID      ((Hwd)0x002C)     	// MICRON Manf ID expected
+#define MICRON_MT28F_DEVICE_128T ((Hwd)0x4492)	// MICRON Flash device Bottom 128 Mb
+//Samsung Programs like AMD
+#define SAMSUNG_MANF_ID      	((Hwd)0x00EC)     	//SAMSUNG Manf ID expected
+#define SAMSUNG_K8S2815E_128T  	((Hwd) 0x22F8)  	//SAMSUNG NOR Flash device TOP 128 Mb
+// Flash Erase Commands AMD and FUJITSU
+// Flash ID Commands AMD
+#define AMD_ID_CMD0        ((Hwd)0xAA)     // AMD ID CMD 0
+#define AMD_CMD0_ADDR       0x555          // AMD CMD0 Offset
+#define AMD_ID_CMD1        ((Hwd)0x55)     // AMD ID CMD 1
+#define AMD_CMD1_ADDR	    0x2AA          // AMD CMD1 Offset
+#define AMD_ID_CMD2        ((Hwd)0x90)     // AMD ID CMD 2
+#define AMD_CMD2_ADDR	    0x555          // AMD CMD2 Offset
+#define AMD_MANF_ID        ((Hwd)0x01)     // AMD Manf ID expected
+#define AMD_DEVICE_ID_MULTI   ((Hwd)0x227E)// Indicates Multi-Address Device ID
+#define AMD_DEVICE_ID_OFFSET 0x1
+#define AMD_DEVICE_ID_OFFSET1 0x0E         // First Addr for Multi-Address ID
+#define AMD_DEVICE_ID_OFFSET2 0x0F         // Second Addr for Multi-Address ID
+#define AMD_DEVICE_RESET   ((Hwd)0x00F0)   // AMD Device Reset Command
+#define AMD_ERASE_CMD0    ((Hwd)0xAA)
+#define AMD_ERASE_CMD1    ((Hwd)0x55)
+#define AMD_ERASE_CMD2    ((Hwd)0x80)
+#define AMD_ERASE_CMD3    ((Hwd)0xAA)     	// AMD29LV017B Erase CMD 3
+#define AMD_ERASE_CMD4    ((Hwd)0x55)     	// AMD29LV017B Erase CMD 4
+#define AMD_ERASE_CMD5    ((Hwd)0x10)     	// AMD29LV017B Erase CMD 5
+#define AMD_ERASE_DONE    ((Hwd)0xFFFF)     // AMD29LV017B Erase Done
+#define AMD_ERASE_BLK_CMD0	((Hwd)0xAA)
+#define AMD_ERASE_BLK_CMD1	((Hwd)0x55)
+#define AMD_ERASE_BLK_CMD2	((Hwd)0x80)
+#define AMD_ERASE_BLK_CMD3	((Hwd)0xAA)
+#define AMD_ERASE_BLK_CMD4	((Hwd)0x55)
+#define AMD_ERASE_BLK_CMD5	((Hwd)0x30)
+#define AMD_PROG_CMD0    ((Hwd)0xAA)
+#define AMD_PROG_CMD1    ((Hwd)0x55)
+#define AMD_PROG_CMD2    ((Hwd)0xA0)
+#define AMD2_ERASE_CMD0    ((Hwd)0x00AA)     // AMD29DL800B Erase CMD 0
+#define AMD2_ERASE_CMD1    ((Hwd)0x0055)     // AMD29DL800B Erase CMD 1
+#define AMD2_ERASE_CMD2    ((Hwd)0x0080)     // AMD29DL800B Erase CMD 2
+#define AMD2_ERASE_CMD3    ((Hwd)0x00AA)     // AMD29DL800B Erase CMD 3
+#define AMD2_ERASE_CMD4    ((Hwd)0x0055)     // AMD29DL800B Erase CMD 4
+#define AMD2_ERASE_CMD5    ((Hwd)0x0030)     // AMD29DL800B Erase CMD 5
+#define AMD2_ERASE_DONE    ((Hwd)0x00FF)     // AMD29DL800B Erase Done
+#define AMD_WRT_BUF_LOAD_CMD0           ((Hwd)0xAA)
+#define AMD_WRT_BUF_LOAD_CMD1           ((Hwd)0x55)
+#define AMD_WRT_BUF_LOAD_CMD2           ((Hwd)0x25)
+#define AMD_WRT_BUF_CONF_CMD0           ((Hwd)0x29)
+#define AMD_WRT_BUF_ABORT_RESET_CMD0    ((Hwd)0xAA)
+#define AMD_WRT_BUF_ABORT_RESET_CMD1    ((Hwd)0x55)
+#define AMD_WRT_BUF_ABORT_RESET_CMD2    ((Hwd)0xF0)
+// Flash Erase Commands INTEL
+#define INTEL_ERASE_CMD0   ((Hwd)0x0020)     // INTEL Erase CMD 0
+#define INTEL_ERASE_CMD1   ((Hwd)0x00D0)     // INTEL Erase CMD 1
+#define INTEL_ERASE_DONE   ((Hwd)0x0080)     // INTEL Erase Done
+#define INTEL_READ_MODE    ((Hwd)0x00FF)     // INTEL Read Array Mode
+#define STRATA_READ        0x4
+#define STRATA_WRITE       0x8
+// Flash Block Information
+// Intel Burst devices:
+//   2MB each (8 8KB [param] and 31 64KB [main] blocks each) for 8MB total
+#define NUM_INTEL_BURST_BLOCKS 8
+#define PARAM_SET0  0
+#define MAIN_SET0   1
+#define PARAM_SET1  2
+#define MAIN_SET1   3
+#define PARAM_SET2  4
+#define MAIN_SET2   5
+#define PARAM_SET3  6
+#define MAIN_SET3   7
+// Intel Strata devices:
+//   4MB each (32 128KB blocks each) for 8MB total
+//   8MB each (64 128KB blocks each) for 16MB total
+//  16MB each (128 128KB blocks each) for 32MB total
+#define NUM_INTEL_STRATA_BLOCKS 8
+#define BLOCK_SET0  0
+#define BLOCK_SET1  1
+#define BLOCK_SET2  2
+#define BLOCK_SET3  3
+#define BLOCK_SET4  4
+#define BLOCK_SET5  5
+#define BLOCK_SET6  6
+#define BLOCK_SET7  7
+// For AMD Flash
+#define NUM_AMD_SECTORS 8  // Only using the first 8 8-KB sections (64 KB Total)
+#define AMD_ADDRESS_CS_MASK		0xFE000000	//--AMD-- Set-up as 0xFE000000 per Jon Hunter (Ti)
+// Flash Types
+enum NORFlashType {
+	FLASH_NOT_FOUND,
+	FLASH_UNSUPPORTED,
+	FLASH_AMD_LV017_2MB,             	// (AMD AM29LV017B-80RFC/RE)
+	FLASH_AMD_DL800_1MB_BOTTOM,		  	// (AMD AM29DL800BB-70EC)
+	FLASH_AMD_DL800_1MB_TOP,			// (AMD AM29DL800BT-70EC)
+	FLASH_AMD_DL323_4MB_BOTTOM,		  	// (AMD AM29DL323CB-70EC)
+	FLASH_AMD_DL323_4MB_TOP,			// (AMD AM29DL323BT-70EC)
+	FLASH_AMD_LV160_2MB_BOTTOM,
+	FLASH_AMD_LV160_2MB_TOP,
+	FLASH_AMD_LV256M_32MB,             	// (AMD AM29LV256MH/L)
+	FLASH_INTEL_BURST_8MB_BOTTOM,	   	// (Intel DT28F80F3B-95)
+	FLASH_INTEL_BURST_8MB_TOP,		   	// (Intel DT28F80F3T-95)
+	FLASH_INTEL_BURST_16MB_BOTTOM,	   	// (Intel DT28F160F3B-95)
+	FLASH_INTEL_BURST_16MB_TOP,		   	// (Intel DT28F160F3T-95)
+	FLASH_INTEL_STRATA_J3_4MB,		   	// (Intel DT28F320J3A)
+	FLASH_INTEL_STRATA_J3_8MB,		   	// (Intel DT28F640J3A)
+	FLASH_INTEL_STRATA_J3_16MB,		   	// (Intel DT28F128J3A)
+	FLASH_FUJITSU_DL323_4MB_BOTTOM,    	// (Fujitsu DL323 Bottom
+	FLASH_INTEL_STRATA_K3_8MB,		   	// (Intel 28F64K3C115)
+	FLASH_INTEL_STRATA_K3_16MB,        	// (Intel 28F128K3C115)
+	FLASH_INTEL_STRATA_K3_32MB,        	// (Intel 28F256K3C115)
+	FLASH_INTEL_W18_16MB_TOP,    		// (Intel 28F128W18T) }
+	FLASH_INTEL_W18_16MB_BOTTOM,  		// (Intel 28F128W18B) }
+	FLASH_INTEL_L18_16MB_TOP,    		// (Intel 28F128L18T) }
+	FLASH_INTEL_L18_16MB_BOTTOM,  		// (Intel 28F128L18B) }
+	FLASH_INTEL_L18_32MB_TOP,    		// (Intel 28F256L18T) }
+	FLASH_INTEL_L18_32MB_BOTTOM,  		// (Intel 28F256L18B) }
+	FLASH_INTEL_K18_32MB_BOTTOM,  		// (Intel 28F256K18B) }
+	FLASH_MICRON_16MB_TOP,				// (Micron MT28F160C34 )
+	FLASH_SAMSUNG_16MB_TOP				// (Samsung K8S281ETA)
+};
+////NAND SUPPORT
+//
+enum NANDFlashType {
+	NANDFLASH_NOT_FOUND,
+	NANDFLASH_SAMSUNG_32x8_Q,             	// (Samsung K9F5608Q0B)
+	NANDFLASH_SAMSUNG_32x8_U,             	// (Samsung K9F5608U0B)
+	NANDFLASH_SAMSUNG_16x16_Q,             	// (Samsung K9F5616Q0B)
+	NANDFLASH_SAMSUNG_16x16_U,             	// (Samsung K9F5616U0B)
+	NANDFLASH_SAMSUNG_16x8_U				// (Samsung K9F1G08QOM)
+};
+// Samsung Manufacture Code
+#define SAMSUNG_MANUFACT_ID	0xEC
+// Samsung Nand Flash Device ID
+#define SAMSUNG_K9F5608Q0B	0x35
+#define SAMSUNG_K9F5608U0B	0x75
+#define SAMSUNG_K9F5616Q0B	0x45
+#define SAMSUNG_K9F5616U0B	0x55
+//  MACROS for NAND Flash support
+//  Flash Chip Capability
+#define NUM_BLOCKS                  0x800       //  32 MB On-board NAND flash.
+#define PAGE_SIZE                 	512
+#define SPARE_SIZE                  16
+#define PAGES_PER_BLOCK             32
+#define PAGE_TO_BLOCK(page)     	((page) >> 5 )
+#define BLOCK_TO_PAGE(block)      	((block)  << 5 )
+#define FILE_TO_PAGE_SIZE(fs) 		((fs / PAGE_SIZE) + ((fs % PAGE_SIZE) ? 1 : 0))
+//  For flash chip that is bigger than 32 MB, we need to have 4 step address
+#ifdef NAND_SIZE_GT_32MB
+#define NEED_EXT_ADDR               1
+#else
+#define NEED_EXT_ADDR               0
+#endif
+// Nand flash block status definitions.
+#define BLOCK_STATUS_UNKNOWN	0x01
+#define BLOCK_STATUS_BAD		0x02
+#define BLOCK_STATUS_READONLY	0x04
+#define BLOCK_STATUS_RESERVED   0x08
+#define BLOCK_RESERVED			0x01
+#define BLOCK_READONLY			0x02
+#define BADBLOCKMARK            0x00
+//  NAND Flash Command. This appears to be generic across all NAND flash chips
+#define CMD_READ                0x00        //  Read
+#define CMD_READ1               0x01        //  Read1
+#define CMD_READ2               0x50        //  Read2
+#define CMD_READID              0x90        //  ReadID
+#define CMD_WRITE               0x80        //  Write phase 1
+#define CMD_WRITE2              0x10        //  Write phase 2
+#define CMD_ERASE               0x60        //  Erase phase 1
+#define CMD_ERASE2              0xd0        //  Erase phase 2
+#define CMD_STATUS              0x70        //  Status read
+#define CMD_RESET               0xff        //  Reset
+//
+//Prototpyes
+//
+// NOR Flash Dependent Function Pointers
+void (*User_Hard_Reset_Flash)(void);
+void (*User_Soft_Reset_Flash)(unsigned long addr);
+void (*User_Flash_Erase_Block)(unsigned long addr);
+void (*User_Flash_Erase_All)(unsigned long addr);
+void (*User_Flash_Write_Entry)(void);
+int (*User_Flash_Write)(unsigned long *addr, unsigned short data);
+int (*User_Flash_Optimized_Write)(unsigned long *addr, unsigned short data[], unsigned long);
+void (*User_Flash_Write_Exit)(void);
+// Flash AMD Device Dependent Routines
+void AMD_Hard_Reset_Flash(void);
+void AMD_Soft_Reset_Flash(unsigned long);
+void AMD_Flash_Erase_Block(unsigned long);
+void AMD_Flash_Erase_All(unsigned long);
+int AMD_Flash_Write(unsigned long *, unsigned short);
+int AMD_Flash_Optimized_Write(unsigned long *addr, unsigned short data[], unsigned long length);
+void AMD_Write_Buf_Abort_Reset_Flash( unsigned long plAddress );
+// Flash Intel Device Dependent Routines
+void INTEL_Hard_Reset_Flash(void);
+void INTEL_Soft_Reset_Flash(unsigned long addr);
+void INTEL_Flash_Erase_Block(unsigned long);
+int INTEL_Flash_Write(unsigned long *addr, unsigned short data);
+int INTEL_Flash_Optimized_Write(unsigned long *addr, unsigned short data[], unsigned long length);
+
+//General Functions
+void Flash_Do_Nothing(void);
+
+#endif
+
+
diff -Nurd u-boot-1.2.0/board/davinci/lowlevel_init.S u-boot-1.2.0-leopard/board/davinci/lowlevel_init.S
--- u-boot-1.2.0/board/davinci/lowlevel_init.S	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/davinci/lowlevel_init.S	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,764 @@
+/*
+ * Board specific setup info
+ *
+ * (C) Copyright 2003
+ * Texas Instruments, <www.ti.com>
+ * Kshitij Gupta <Kshitij@ti.com>
+ *
+ * Modified for OMAP 1610 H2 board by Nishant Kamat, Jan 2004
+ *
+ * Modified for OMAP 5912 OSK board by Rishi Bhattacharya, Apr 2004
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ * 
+ * Modified for DV-EVM board by Rishi Bhattacharya, Apr 2005
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * Modified for DV-EVM board by Swaminathan S, Nov 2005
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+#if defined(CONFIG_OMAP1610)
+#include <./configs/omap1510.h> 
+#endif
+
+_TEXT_BASE:
+	.word	TEXT_BASE	/* sdram load addr from config.mk */
+
+.global reset_cpu
+reset_cpu:
+	bl reset_processor
+
+
+.globl lowlevel_init
+lowlevel_init:
+	/*mov	pc,	lr*/
+	
+	/*------------------------------------------------------*
+	 * mask all IRQs by setting all bits in the EINT default *
+	 *------------------------------------------------------*/
+	mov	r1, #0x00000000
+	ldr	r0, =EINT_ENABLE0
+	str	r1, [r0]
+	ldr	r0, =EINT_ENABLE1
+	str	r1, [r0]
+
+	/*------------------------------------------------------*
+	 * Put the GEM in reset		    		  *
+ 	 *------------------------------------------------------*/
+
+      /* Put the GEM in reset */
+  	LDR R8, PSC_GEM_FLAG_CLEAR
+	LDR R6, MDCTL_GEM
+	LDR R7, [R6]
+	AND R7, R7, R8
+	STR R7, [R6]
+
+	/* Enable the Power Domain Transition Command */
+	LDR R6, PTCMD_0
+	LDR R7, [R6]
+	ORR R7, R7, #0x2
+	STR R7, [R6]
+
+	/* Check for Transition Complete(PTSTAT) */
+checkStatClkStopGem:
+	LDR R6, PTSTAT_0
+	LDR R7, [R6]
+    	AND R7, R7, #0x2
+    	CMP R7, #0x0
+    	BNE checkStatClkStopGem
+
+	/* Check for GEM Reset Completion */
+checkGemStatClkStop:
+	LDR R6, MDSTAT_GEM
+	LDR R7, [R6]
+    	AND R7, R7, #0x100
+    	CMP R7, #0x0
+    	BNE checkGemStatClkStop
+
+	/* Do this for enabling a WDT initiated reset this is a workaround
+	   for a chip bug.  Not required under normal situations */
+	LDR R6, P1394
+	MOV R10, #0x0	
+	STR R10, [R6]
+
+	/*------------------------------------------------------*
+	 * Enable L1 & L2 Memories in Fast mode                 *
+	 *------------------------------------------------------*/
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x1
+	STR R10, [R6]
+
+	LDR R6, MMARG_BRF0
+	LDR R10, MMARG_BRF0_VAL
+	STR R10, [R6]
+
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x0
+	STR R10, [R6]
+	/*------------------------------------------------------*
+	 * DDR2 PLL Intialization			    	*
+ 	 *------------------------------------------------------*/
+	
+      /* Select the Clock Mode Depending on the Value written in the Boot Table by the run script */
+	MOV R10, #0x0
+	LDR R6, PLL2_CTL   
+	LDR R7, PLL_CLKSRC_MASK
+	LDR R8, [R6]
+	AND R8, R8, R7
+	MOV R9, R10, LSL #0x8
+	ORR R8, R8, R9
+	STR R8, [R6]
+	
+	/* Select the PLLEN source */
+	LDR R7, PLL_ENSRC_MASK
+	AND R8, R8, R7
+	STR R8, [R6]
+	
+	/* Bypass the PLL */
+	LDR R7, PLL_BYPASS_MASK
+	AND R8, R8, R7
+	STR R8, [R6]
+	
+	/* Wait for few cycles to allow PLLEN Mux switches properly to bypass Clock */
+	MOV R10, #0x20 
+WaitPPL2Loop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE WaitPPL2Loop	
+
+     /* Reset the PLL */
+    	LDR R7, PLL_RESET_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+     /* Power up the PLL */
+    	LDR R7, PLL_PWRUP_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+     /* Enable the PLL from Disable Mode */
+    	LDR R7, PLL_DISABLE_ENABLE_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+	/* Program the PLL Multiplier */
+	LDR R6, PLL2_PLLM
+	/*MOV R2, #0x13 Orig value */
+	/*MOV R2, #0xB 165MHz */
+	/*MOV R2, #0xD 189 MHz */
+	MOV R2, #0x17 /* 162 MHz */
+	STR R2, [R6]   /* R2 */
+
+	/* Program the PLL2 Divisior Value */
+	LDR R6, PLL2_DIV2
+	MOV R3, #0x1 /* Orig */
+	/*MOV R3, #0x0*/
+	STR R3, [R6]    /* R3 */
+
+	/* Program the PLL2 Divisior Value */
+	LDR R6, PLL2_DIV1
+	/*MOV R4, #0x9 Orig */
+	/*MOV R4, #0x5 165MHz */
+	/*MOV R4, #0x6 189 MHz */
+	MOV R4, #0xB /* 54 MHz */
+	STR R4, [R6]    /* R4 */
+
+      /* PLL2 DIV1 MMR */
+	LDR R8, PLL2_DIV_MASK
+	LDR R6, PLL2_DIV2
+	LDR R9, [R6]
+	AND R8, R8, R9
+	MOV R9, #0X1
+	MOV R9, R9, LSL #15
+	ORR R8, R8, R9
+	STR R8, [R6]
+
+	/* Program the GOSET bit to take new divier values */
+	LDR R6, PLL2_PLLCMD
+	LDR R7, [R6]
+	ORR R7, R7, #0x1
+	STR R7, [R6]
+
+      /* Wait for Done */
+    	LDR R6, PLL2_PLLSTAT
+doneLoop_0:    
+    	LDR R7, [R6]
+    	AND R7, R7, #0x1
+    	CMP R7, #0x0
+    	BNE doneLoop_0
+
+      /* PLL2 DIV2 MMR */
+	LDR R8, PLL2_DIV_MASK
+	LDR R6, PLL2_DIV1
+	LDR R9, [R6]
+	AND R8, R8, R9
+	MOV R9, #0X1
+	MOV R9, R9, LSL #15
+	ORR R8, R8, R9
+	STR R8, [R6]
+
+	/* Program the GOSET bit to take new divier values */
+	LDR R6, PLL2_PLLCMD
+	LDR R7, [R6]
+	ORR R7, R7, #0x1
+	STR R7, [R6]
+
+     /* Wait for Done */
+    	LDR R6, PLL2_PLLSTAT
+doneLoop:    
+    	LDR R7, [R6]
+    	AND R7, R7, #0x1
+    	CMP R7, #0x0
+    	BNE doneLoop
+    				
+	/* Wait for PLL to Reset Properly */
+	MOV R10, #0x218  
+ResetPPL2Loop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE ResetPPL2Loop
+    
+    	/* Bring PLL out of Reset */
+    	LDR R6, PLL2_CTL    	
+    	LDR R8, [R6]
+    	ORR R8, R8, #0x08
+    	STR R8, [R6]
+     	
+     /* Wait for PLL to Lock */
+	LDR R10, PLL_LOCK_COUNT    
+PLL2Lock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE PLL2Lock
+    
+     /* Enable the PLL */
+    	LDR R6, PLL2_CTL    	
+    	LDR R8, [R6]
+    	ORR R8, R8, #0x01
+    	STR R8, [R6]
+
+	/*------------------------------------------------------*
+	 * Issue Soft Reset to DDR Module		    		  *
+ 	 *------------------------------------------------------*/
+
+      /* Shut down the DDR2 LPSC Module */
+  	LDR R8, PSC_FLAG_CLEAR
+	LDR R6, MDCTL_DDR2_0
+	LDR R7, [R6]
+	AND R7, R7, R8
+	ORR R7, R7, #0x3
+	STR R7, [R6]  
+
+	/* Enable the Power Domain Transition Command */
+	LDR R6, PTCMD_0
+	LDR R7, [R6]
+	ORR R7, R7, #0x1
+	STR R7, [R6]    
+	
+	/* Check for Transition Complete(PTSTAT) */
+checkStatClkStop:	
+	LDR R6, PTSTAT_0
+	LDR R7, [R6]
+    	AND R7, R7, #0x1	
+    	CMP R7, #0x0
+    	BNE checkStatClkStop  
+    
+	/* Check for DDR2 Controller Enable Completion */
+checkDDRStatClkStop:	
+	LDR R6, MDSTAT_DDR2_0
+	LDR R7, [R6]
+    	AND R7, R7, #0x1F	
+    	CMP R7, #0x3
+    	BNE checkDDRStatClkStop  
+
+	/*------------------------------------------------------*
+	 * Program DDR2 MMRs for 162MHz Setting	    		  *
+ 	 *------------------------------------------------------*/
+	
+	/* Program PHY Control Register */
+	LDR R6, DDRCTL
+	LDR R7, DDRCTL_VAL
+	STR R7, [R6]
+
+	/* Program SDRAM Bank Config Register */
+	LDR R6, SDCFG
+	LDR R7, SDCFG_VAL
+	STR R7, [R6]
+
+	/* Program SDRAM TIM-0 Config Register */
+	LDR R6, SDTIM0
+	LDR R7, SDTIM0_VAL_162MHz
+	STR R7, [R6]		
+
+	/* Program SDRAM TIM-1 Config Register */
+	LDR R6, SDTIM1
+	LDR R7, SDTIM1_VAL_162MHz
+	STR R7, [R6]		
+
+	/* Program the SDRAM Bang Config Control Register */
+	LDR R10, MASK_VAL
+	LDR R8, SDCFG
+	LDR R9, SDCFG_VAL
+	AND R9, R9, R10
+	STR R9, [R8]
+
+	/* Program SDRAM TIM-1 Config Register */
+	LDR R6, SDREF
+	LDR R7, SDREF_VAL
+	STR R7, [R6]		
+
+        /*------------------------------------------------------*
+         * Issue Soft Reset to DDR Module                                 *
+         *------------------------------------------------------*/
+                                                                                
+        /* Issue a Dummy DDR2 read/write */
+        LDR R8, DDR2_VAL
+        LDR R7, DUMMY_VAL
+        STR R7, [R8]
+        LDR R7, [R8]
+                                                                                
+      /* Shut down the DDR2 LPSC Module */
+        LDR R8, PSC_FLAG_CLEAR
+        LDR R6, MDCTL_DDR2_0
+        LDR R7, [R6]
+        AND R7, R7, R8
+        ORR R7, R7, #0x1
+        STR R7, [R6]
+                                                                                
+        /* Enable the Power Domain Transition Command */
+        LDR R6, PTCMD_0
+        LDR R7, [R6]
+        ORR R7, R7, #0x1
+        STR R7, [R6]
+                                                                                
+        /* Check for Transition Complete(PTSTAT) */
+checkStatClkStop2:
+        LDR R6, PTSTAT_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1
+        CMP R7, #0x0
+        BNE checkStatClkStop2
+                                                                                
+        /* Check for DDR2 Controller Enable Completion */
+checkDDRStatClkStop2:
+        LDR R6, MDSTAT_DDR2_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1F
+        CMP R7, #0x1
+        BNE checkDDRStatClkStop2
+
+        /*------------------------------------------------------*
+         * Turn DDR2 Controller Clocks On                                 *
+         *------------------------------------------------------*/
+                                                                                
+     /* Enable the DDR2 LPSC Module */
+        LDR R6, MDCTL_DDR2_0
+        LDR R7, [R6]
+        ORR R7, R7, #0x3
+        STR R7, [R6]
+                                                                                
+        /* Enable the Power Domain Transition Command */
+        LDR R6, PTCMD_0
+        LDR R7, [R6]
+        ORR R7, R7, #0x1
+        STR R7, [R6]
+                                                                                
+        /* Check for Transition Complete(PTSTAT) */
+checkStatClkEn2:
+        LDR R6, PTSTAT_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1
+        CMP R7, #0x0
+        BNE checkStatClkEn2
+                                                                                
+        /* Check for DDR2 Controller Enable Completion */
+checkDDRStatClkEn2:
+        LDR R6, MDSTAT_DDR2_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1F
+        CMP R7, #0x3
+        BNE checkDDRStatClkEn2
+                                                                                
+        /*  DDR Writes and Reads */
+        LDR R6, CFGTEST
+        MOV R3, #0x1
+        STR R3, [R6]    /* R3 */
+
+	/*------------------------------------------------------*
+	 * System PLL Intialization			    		  *
+ 	 *------------------------------------------------------*/
+
+      /* Select the Clock Mode Depending on the Value written in the Boot Table by the run script */
+	MOV R2, #0x0
+	LDR R6, PLL1_CTL   
+	LDR R7, PLL_CLKSRC_MASK
+	LDR R8, [R6]
+	AND R8, R8, R7
+	MOV R9, R2, LSL #0x8
+	ORR R8, R8, R9
+	STR R8, [R6]
+	
+	/* Select the PLLEN source */
+	LDR R7, PLL_ENSRC_MASK
+	AND R8, R8, R7
+	STR R8, [R6]
+	
+	/* Bypass the PLL */
+	LDR R7, PLL_BYPASS_MASK
+	AND R8, R8, R7
+	STR R8, [R6]
+	
+	/* Wait for few cycles to allow PLLEN Mux switches properly to bypass Clock */
+	MOV R10, #0x20 
+
+WaitLoop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE WaitLoop	
+
+     /* Reset the PLL */
+    	LDR R7, PLL_RESET_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+      /* Disable the PLL */
+    	ORR R8, R8, #0x10    
+    	STR R8, [R6]
+
+      /* Power up the PLL */
+    	LDR R7, PLL_PWRUP_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+      /* Enable the PLL from Disable Mode */
+    	LDR R7, PLL_DISABLE_ENABLE_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+	/* Program the PLL Multiplier */
+	LDR R6, PLL1_PLLM
+	/*MOV R3, #0x10  As per Amit, PLL should be in normal mode i.e X by 16 */
+	/*MOV R3, #0x11  As per Ebby 486 MHz */
+	/*MOV R3, #0x14  For 567MHz */
+	MOV R3, #0x15 /* For 594MHz */
+	STR R3, [R6]      
+
+	/* Wait for PLL to Reset Properly */
+	MOV R10, #0xFF 
+
+ResetLoop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE ResetLoop
+    
+      /* Bring PLL out of Reset */
+    	LDR R6, PLL1_CTL    	
+    	ORR R8, R8, #0x08
+    	STR R8, [R6]
+     	
+      /* Wait for PLL to Lock */
+	LDR R10, PLL_LOCK_COUNT    
+
+PLL1Lock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE PLL1Lock
+    
+      /* Enable the PLL */
+    	ORR R8, R8, #0x01
+    	STR R8, [R6]
+
+	nop
+	nop	
+	nop
+	nop
+
+	/*------------------------------------------------------*
+	 * AEMIF configuration for NOR Flash (double check)     *
+	 *------------------------------------------------------*/
+	LDR R0, _PINMUX0
+	LDR R1, _DEV_SETTING
+	STR R1, [R0]
+
+ 	LDR R0, WAITCFG   
+	LDR R1, WAITCFG_VAL 
+	LDR R2, [R0]
+	ORR R2, R2, R1
+	STR R2, [R0]    
+
+	LDR R0, ACFG3
+	LDR R1, ACFG3_VAL
+	LDR R2, [R0]
+	AND R1, R2, R1
+	STR R1, [R0]
+
+	LDR R0, ACFG4
+	LDR R1, ACFG4_VAL
+	LDR R2, [R0]
+	AND R1, R2, R1
+	STR R1, [R0]
+
+	LDR R0, ACFG5
+	LDR R1, ACFG5_VAL
+	LDR R2, [R0]
+	AND R1, R2, R1
+	STR R1, [R0]     
+
+	/*--------------------------------------*
+	 * VTP manual Calibration               *
+	 *--------------------------------------*/
+	LDR R0, VTPIOCR
+	LDR R1, VTP_MMR0
+	STR R1, [R0]
+
+	LDR R0, VTPIOCR
+	LDR R1, VTP_MMR1
+	STR R1, [R0]
+	
+     /* Wait for 33 VTP CLK cycles.  VRP operates at 27 MHz */
+	LDR R10, VTP_LOCK_COUNT    
+VTPLock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE VTPLock
+
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x1
+	STR R10, [R6]
+
+	LDR R6, DDRVTPR
+	LDR R7, [R6]
+	AND R7, R7, #0x1F
+	AND R8, R7, #0x3E0
+	ORR R8, R7, R8
+	LDR R7, VTP_RECAL
+	ORR R8, R7, R8
+	LDR R7, VTP_EN
+	ORR R8, R7, R8
+	STR R8, [R0]
+
+
+     /* Wait for 33 VTP CLK cycles.  VRP operates at 27 MHz */
+	LDR R10, VTP_LOCK_COUNT    
+VTP1Lock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE VTP1Lock
+
+	LDR R1, [R0]
+	LDR R2, VTP_MASK
+	AND R2, R1, R2
+	STR R2, [R0]
+
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x0
+	STR R10, [R6]
+
+
+	/* Start MPU Timer 1 */
+/*	MOV R10, #0x1AFFFFFF
+
+WaitRam:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE WaitRam
+*/
+
+	/* back to arch calling code */
+	mov	pc,	lr
+
+	/* the literal pools origin */
+	.ltorg
+
+REG_TC_EMIFS_CONFIG:		/* 32 bits */
+	.word 0xfffecc0c
+REG_TC_EMIFS_CS0_CONFIG:	/* 32 bits */
+	.word 0xfffecc10
+REG_TC_EMIFS_CS1_CONFIG:	/* 32 bits */
+	.word 0xfffecc14
+REG_TC_EMIFS_CS2_CONFIG:	/* 32 bits */
+	.word 0xfffecc18
+REG_TC_EMIFS_CS3_CONFIG:	/* 32 bits */
+	.word 0xfffecc1c
+
+_PINMUX0:		.word 0x01C40000		/* Device Configuration Registers */
+_PINMUX1:		.word 0x01C40004		/* Device Configuration Registers */
+
+_DEV_SETTING:		.word 0x00000C1F
+
+AEMIF_BASE_ADDR:	.word 0x01E00000
+WAITCFG:         	.word 0x01E00004
+ACFG2:           	.word 0x01E00010
+ACFG3:           	.word 0x01E00014
+ACFG4:           	.word 0x01E00018
+ACFG5:           	.word 0x01E0001C
+
+WAITCFG_VAL:     	.word 0x0
+ACFG2_VAL:       	.word 0x3FFFFFFD
+ACFG3_VAL:       	.word 0x3FFFFFFD
+ACFG4_VAL:       	.word 0x3FFFFFFD
+ACFG5_VAL:       	.word 0x3FFFFFFD
+
+MDCTL_DDR2:		.word 0x01C41A34
+PTCMD:		.word 0x01C41120
+PTSTAT:		.word 0x01C41128
+MDSTAT_DDR2:	.word 0x01C41834
+
+MDCTL_TPCC:		.word	0x01C41A08
+MDSTAT_TPCC:	.word 0x01C41808
+
+MDCTL_TPTC0:	.word	0x01C41A0C
+MDSTAT_TPTC0:	.word 0x01C4180C
+
+MDCTL_TPTC1:	.word	0x01C41A10
+MDSTAT_TPTC1:	.word 0x01C41810
+
+DDR2DEBUG:		.word 0x8FFFF000
+
+/* EINT0 register */
+EINT_ENABLE0:
+	.word 0x01c48018
+
+/* EINT1 register */
+EINT_ENABLE1:
+	.word 0x01c4801C
+
+CLEAR_FLAG:				.word 0xFFFFFFFF
+EDMA_PARAM0_D_S_BIDX_VAL: 	.word 0x00010001
+PSC_FLAG_CLEAR:			.word 0xFFFFFFE0
+PSC_GEM_FLAG_CLEAR:			.word 0xFFFFFEFF
+MDCTL_TPCC_SYNC:			.word 0x01C41A08
+MDSTAT_TPCC_SYNC:			.word 0x01C41808
+
+MDCTL_TPTC0_SYNC:			.word 0x01C41A0C
+MDSTAT_TPTC0_SYNC:		.word 0x01C4180C
+
+MDCTL_TPTC1_SYNC:			.word 0x01C41A10
+MDSTAT_TPTC1_SYNC:		.word 0x01C41810
+
+PTCMD_SYNC:				.word 0x01C41120
+PTSTAT_SYNC:			.word 0x01C41128
+DATA_MAX:				.word 0x0000FFFF
+SPIN_ADDR:				.word 0x00003FFC   /* ARM PC value(B $) for the DSP Test cases */
+SPIN_OPCODE:			.word 0xEAFFFFFE
+
+/* Interrupt Clear Register */
+FIQ0_CLEAR:				.word 0x01C48000
+FIQ1_CLEAR:				.word 0x01C48004
+IRQ0_CLEAR:				.word 0x01C48008
+IRQ1_CLEAR:				.word 0x01C4800C
+
+/* DDR2 MMR & CONFIGURATION VALUES for 75 MHZ */
+DDRCTL:				.word	0x200000E4
+SDREF:				.word	0x2000000C
+SDCFG:				.word	0x20000008
+SDTIM0:				.word	0x20000010
+SDTIM1:				.word	0x20000014
+SDSTAT:				.word 0x20000004
+VTPIOCR:				.word 0x200000F0  /* VTP IO Control register */
+DDRVTPR:				.word 0x01C42030  /* DDR VPTR MMR */
+DFT_ENABLE:				.word 0x01C4004C
+VTP_MMR0:				.word 0x201F
+VTP_MMR1:				.word 0xA01F
+PCH_MASK:				.word 0x3E0
+VTP_LOCK_COUNT:				.word 0x5b0
+VTP_MASK:				.word 0xFFFFDFFF
+VTP_RECAL:				.word 0x40000
+VTP_EN:					.word 0x02000
+
+
+CFGTEST:				.word	0x80010000
+
+/* original values					
+DDRCTL_VAL:				.word	0x50006405
+SDCFG_VAL:				.word	0x00008832
+MASK_VAL:                    	.word 0x00000FFF
+SDTIM0_VAL_135MHz:		.word	0x30923A91
+SDTIM1_VAL_135MHz:		.word	0x0019c722
+SDREF_VAL:				.word 0x000005c3
+*/
+
+/* 162MHz as per GEL file for DVEVM with Micron DDR2 SDRAM */
+DDRCTL_VAL:                     .word   0x50006405
+SDCFG_VAL:                      .word   0x00178632           /* CL=3 for MT47H64M16BT-5E */
+MASK_VAL:                       .word   0xFFFF7FFF
+SDTIM0_VAL_162MHz:              .word   0x28923211
+SDTIM1_VAL_162MHz:              .word   0x0016c722
+SDREF_VAL:                      .word   0x000004F0
+
+/* GEM Power Up & LPSC Control Register */
+CHP_SHRTSW:				.word 0x01C40038
+
+PD1_CTL:				.word	0x01C41304
+EPCPR:				.word	0x01C41070
+EPCCR:				.word	0x01C41078
+MDCTL_GEM:				.word	0x01C41A9C
+MDSTAT_GEM:				.word 0x01C4189C
+MDCTL_IMCOP:			.word	0x01C41AA0
+MDSTAT_IMCOP:			.word 0x01C418A0
+
+PTCMD_0:				.word 0x01C41120
+PTSTAT_0:				.word 0x01C41128
+P1394:					.word 0x01C41a20
+
+PLL_CLKSRC_MASK: 			.word 0xFFFFFEFF  /* Mask the Clock Mode bit and it is programmble through the run script */
+PLL_ENSRC_MASK:  			.word 0xFFFFFFDF  /* Select the PLLEN source */
+PLL_BYPASS_MASK: 			.word 0xFFFFFFFE  /* Put the PLL in BYPASS, eventhough the device */
+PLL_RESET_MASK:  			.word 0xFFFFFFF7  /* Put the PLL in Reset Mode */
+PLL_PWRUP_MASK:  			.word 0xFFFFFFFD  /* PLL Power up Mask Bit  */
+PLL_DISABLE_ENABLE_MASK:	.word 0xFFFFFFEF  /* Enable the PLL from Disable */
+PLL_LOCK_COUNT:          	.word 0x2000
+
+/* PLL1-SYSTEM PLL MMRs */
+PLL1_CTL:				.word 0x01C40900 
+PLL1_PLLM:				.word 0x01C40910
+
+/* PLL2-SYSTEM PLL MMRs */
+PLL2_CTL:				.word 0x01C40D00 
+PLL2_PLLM:				.word 0x01C40D10
+PLL2_DIV2:				.word 0x01C40D1C
+PLL2_DIV1:				.word 0x01C40D18
+PLL2_PLLCMD:			.word 0x01C40D38
+PLL2_PLLSTAT:			.word 0x01C40D3C	
+PLL2_BPDIV:				.word 0x01C40D2C
+PLL2_DIV_MASK:			.word 0xFFFF7FFF
+
+
+MDCTL_DDR2_0:			.word 0x01C41A34
+MDSTAT_DDR2_0:			.word 0x01C41834
+DLLPWRUPMASK:			.word 0xFFFFFFEF
+DDR2_ADDR:			.word 0x80000000
+
+DFT_BASEADDR:			.word 0x01C42000
+MMARG_BRF0:			.word 0x01C42010     /* BRF margin mode 0     (Read / write)*/
+MMARG_G10:			.word 0x01C42018     /*GL margin mode 0      (Read / write)*/
+MMARG_BRF0_VAL:			.word 0x00444400
+DDR2_VAL:			.word 0x80000000
+DUMMY_VAL:			.word 0xA55AA55A
+
+/* command values */
+.equ CMD_SDRAM_NOP,		0x00000000
+.equ CMD_SDRAM_PRECHARGE,	0x00000001
+.equ CMD_SDRAM_AUTOREFRESH,	0x00000002
+.equ CMD_SDRAM_CKE_SET_HIGH,	0x00000007
diff -Nurd u-boot-1.2.0/board/davinci/nand.c u-boot-1.2.0-leopard/board/davinci/nand.c
--- u-boot-1.2.0/board/davinci/nand.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/davinci/nand.c	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,111 @@
+/*
+ * NAND driver for TI DaVinci based boards.
+ *
+ * Copyright (C) 2007 Sergey Kubushyn <ksi@koi8.net>
+ *
+ * Based on Linux DaVinci NAND driver by TI. Original copyright follows:
+ */
+
+/*
+ *
+ * linux/drivers/mtd/nand/nand_davinci.c
+ *
+ * NAND Flash Driver
+ *
+ * Copyright (C) 2006 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ *
+ *  Overview:
+ *   This is a device driver for the NAND flash device found on the
+ *   DaVinci board which utilizes the Samsung k9k2g08 part.
+ *
+ Modifications:
+ ver. 1.0: Feb 2005, Vinod/Sudhakar
+ -
+ *
+ */
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+#if !defined(CFG_NAND_LEGACY)
+
+#include "soc.h"
+#include <nand.h>
+#include <asm/arch/nand_defs.h>
+#include <asm/arch/emif_defs.h>
+
+extern struct nand_chip nand_dev_desc[CFG_MAX_NAND_DEVICE];
+
+static void nand_davinci_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+	struct		nand_chip *this = mtd->priv;
+	u_int32_t	IO_ADDR_W = (u_int32_t)this->IO_ADDR_W;
+
+	IO_ADDR_W &= ~(MASK_ALE|MASK_CLE);
+
+	switch (cmd) {
+		case NAND_CTL_SETCLE:
+			IO_ADDR_W |= MASK_CLE;
+			break;
+		case NAND_CTL_SETALE:
+			IO_ADDR_W |= MASK_ALE;
+			break;
+	}
+
+	this->IO_ADDR_W = (void *)IO_ADDR_W;
+}
+
+static int nand_davinci_dev_ready(struct mtd_info *mtd)
+{
+	emifregs	emif_addr;
+
+	emif_addr = (emifregs)CSL_EMIF_1_REGS;
+
+	return(emif_addr->NANDFSR & 0x1);
+}
+
+static int nand_davinci_waitfunc(struct mtd_info *mtd, struct nand_chip *this, int state)
+{
+	while(!nand_davinci_dev_ready(mtd)) {;}
+	*NAND_CE0CLE = NAND_STATUS;
+	return(*NAND_CE0DATA);
+}
+
+int board_nand_init(struct nand_chip *nand)
+{
+	nand->IO_ADDR_R   = (void  __iomem *)NAND_CE0DATA;
+	nand->IO_ADDR_W   = (void  __iomem *)NAND_CE0DATA;
+	nand->chip_delay  = 0;
+	nand->options     = 0;
+	nand->eccmode     = NAND_ECC_SOFT;
+
+	/* Set address of hardware control function */
+	nand->hwcontrol = nand_davinci_hwcontrol;
+
+	nand->dev_ready = nand_davinci_dev_ready;
+	nand->waitfunc = nand_davinci_waitfunc;
+
+	return 0;
+}
+
+#else
+#error "U-Boot legacy NAND support not available for DaVinci chips"
+#endif
+#endif	/* CFG_USE_NAND */
diff -Nurd u-boot-1.2.0/board/davinci/soc.h u-boot-1.2.0-leopard/board/davinci/soc.h
--- u-boot-1.2.0/board/davinci/soc.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/davinci/soc.h	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,339 @@
+/*
+ *
+ *  Copyright (C) 2004 Texas Instruments.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ * Modifications:
+ * ver. 1.0: Oct 2005, Swaminathan S
+ *
+ */
+
+#ifndef _SOC_H
+#define _SOC_H
+
+#include <asm/arch/types.h>
+
+#define CSL_IDEF_INLINE static inline
+/*****************************************************************************\
+* Peripheral Instance counts
+\*****************************************************************************/
+
+#define CSL_UART_CNT                 3
+#define CSL_I2C_CNT                  1
+#define CSL_TMR_CNT                  4
+#define CSL_WDT_CNT                  1
+#define CSL_PWM_CNT                  3
+#define CSL_PLLC_CNT                 2
+#define CSL_PWR_SLEEP_CTRL_CNT       1
+#define CSL_SYS_DFT_CNT              1
+#define CSL_INTC_CNT                 1
+#define CSL_IEEE1394_CNT             1
+#define CSL_USBOTG_CNT               1
+#define CSL_ATA_CNT                  1
+#define CSL_SPI_CNT                  1
+#define CSL_GPIO_CNT                 1
+#define CSL_UHPI_CNT                 1
+#define CSL_VPSS_REGS_CNT            1
+#define CSL_EMAC_CTRL_CNT            1
+#define CSL_EMAC_WRAP_CNT            1
+#define CSL_EMAC_RAM_CNT             1
+#define CSL_MDIO_CNT                 1
+#define CSL_EMIF_CNT                 1
+#define CSL_NAND_CNT                 1
+#define CSL_MCBSP_CNT                1
+#define CSL_MMCSD_CNT                1
+#define CSL_MS_CNT                   1
+#define CSL_DDR_CNT                  1
+#define CSL_VLYNQ_CNT                1
+#define CSL_PMX_CNT                  1
+
+/*****************************************************************************\
+* Peripheral Instance enumeration
+\*****************************************************************************/
+
+/** @brief Peripheral Instance for UART  */
+#define CSL_UART_1                          (0) /** Instance 1 of UART   */
+
+/** @brief Peripheral Instance for UART  */
+#define CSL_UART_2                          (1) /** Instance 2 of UART   */
+
+/** @brief Peripheral Instance for UART  */
+#define CSL_UART_3                          (2) /** Instance 3 of UART   */
+
+/** @brief Peripheral Instance for I2C   */
+#define CSL_I2C                             (0) /** Instance 1 of I2C    */
+
+/** @brief Peripheral Instance for Tmr0  */
+#define CSL_TMR_1                           (0) /** Instance 1 of Tmr    */
+
+/** @brief Peripheral Instance for Tmr1  */
+#define CSL_TMR_2                           (1) /** Instance 2 of Tmr    */
+
+/** @brief Peripheral Instance for Tmr2  */
+#define CSL_TMR_3                           (2) /** Instance 3 of Tmr    */
+
+/** @brief Peripheral Instance for Tmr3  */
+#define CSL_TMR_4                           (3) /** Instance 4 of Tmr    */
+
+/** @brief Peripheral Instance for WDT   */
+#define CSL_WDT                             (0) /** Instance of WDT      */
+
+/** @brief Peripheral Instance for PWM   */
+#define CSL_PWM_1                           (0) /** Instance 1 of PWM    */
+
+/** @brief Peripheral Instance for PWM   */
+#define CSL_PWM_2                           (1) /** Instance 2 of PWM    */
+
+/** @brief Peripheral Instance for PWM   */
+#define CSL_PWM_3                           (2) /** Instance 3 of PWM    */
+
+/** @brief Peripheral Instance for PLLC  */
+#define CSL_PLLC_1                          (0) /** Instance 1 of PLLC   */
+
+/** @brief Peripheral Instance for PLLC  */
+#define CSL_PLLC_2                          (1) /** Instance 2 of PLLC   */
+
+/** @brief Peripheral Instance for CSL_PWR_SLEEP_CTRL  */
+#define CSL_PWR_SLEEP_CTRL                  (0) /** Instance 1 of PWR_SLEEP_CTRL    */
+
+/** @brief Peripheral Instance for SYS_DFT  */
+#define CSL_SYS_DFT                         (0) /** Instance 1 of SYS_DFT*/
+
+/** @brief Peripheral Instance for INTC   */
+#define CSL_INTC                            (0) /** Instance 1 of INTC   */
+
+/** @brief Peripheral Instance for IEEE 1394  */
+#define CSL_IEEE1394                       (0) /** Instance 1 of IEEE 1394     */
+
+/** @brief Peripheral Instance for USBOTG  */
+#define CSL_USBOTG                          (0) /** Instance 1 of USBOTG */
+
+/** @brief Peripheral Instance for ATA   */
+#define CSL_ATA_PRIMARY                     (0) /** Instance 1 of ATA    */
+
+/** @brief Peripheral Instance for ATA   */
+#define CSL_ATA_SECONDARY                   (1) /** Instance 2 of ATA    */
+
+/** @brief Peripheral Instance for SPI   */
+#define CSL_SPI                             (0) /** Instance 1 of SPI    */
+
+/** @brief Peripheral Instance for GPIO  */
+#define CSL_GPIO                            (0) /** Instance 1 of GPIO   */
+
+/** @brief Peripheral Instance for UHPI  */
+#define CSL_UHPI                            (0) /** Instance 1 of UHPI   */
+
+/** @brief Peripheral Instance for VPSS_REGS  */
+#define CSL_VPSS_REGS                       (0) /** Instance 1 of VPSS_REGS     */
+
+/** @brief Peripheral Instance for EMAC_CTRL  */
+#define CSL_EMAC_CTRL                       (0) /** Instance 1 of EMAC_CTRL     */
+
+/** @brief Peripheral Instance for EMAC_WRAP  */
+#define CSL_EMAC_WRAP                       (0) /** Instance 1 of EMAC_WRAP     */
+
+/** @brief Peripheral Instance for EMAC_RAM  */
+#define CSL_EMAC_RAM                        (0) /** Instance 1 of EMAC_RAM      */
+
+/** @brief Peripheral Instance for MDIO  */
+#define CSL_MDIO                            (0) /** Instance 1 of MDIO   */
+
+/** @brief Peripheral Instance for EMIF  */
+#define CSL_EMIF                            (0) /** Instance 1 of EMIF   */
+
+/** @brief Peripheral Instance for NAND  */
+#define CSL_NAND                            (0) /** Instance 1 of NAND   */
+
+/** @brief Peripheral Instance for MCBSP */
+#define CSL_MCBSP                           (0) /** Instance 1 of MCBSP  */
+
+/** @brief Peripheral Instance for MMCSD */
+#define CSL_MMCSD                           (0) /** Instance 1 of MMCSD  */
+
+/** @brief Peripheral Instance for MS    */
+#define CSL_MS                              (0) /** Instance 1 of MS     */
+
+/** @brief Peripheral Instance for DDR    */
+#define CSL_DDR                             (0) /** Instance 1 of DDR    */
+
+/** @brief Peripheral Instance for VLYNQ */
+#define CSL_VLYNQ                           (0) /** Instance 1 of VLYNQ  */
+
+/** @brief Peripheral Instance for PMX */
+#define CSL_PMX                             (0) /** Instance 1 of PMX    */
+
+/*****************************************************************************\
+* Peripheral Base Address
+\*****************************************************************************/
+
+#define CSL_UART_1_REGS                  (0x01C20000)
+#define CSL_UART_2_REGS                  (0x01C20400)
+#define CSL_UART_3_REGS                  (0x01C20800)
+#define CSL_I2C_1_REGS                   (0x01C21000)
+#define CSL_TMR_1_REGS                   (0x01C21400)
+#define CSL_TMR_2_REGS                   (0x01C21400)
+#define CSL_TMR_3_REGS                   (0x01C21800)
+#define CSL_TMR_4_REGS                   (0x01C21800)
+#define CSL_WDT_1_REGS                   (0x01C21C00)
+#define CSL_PWM_1_REGS                   (0x01C22000)
+#define CSL_PWM_2_REGS                   (0x01C22400)
+#define CSL_PWM_3_REGS                   (0x01C22800)
+#define CSL_PLLC_1_REGS                  (0x01C40800)
+#define CSL_PLLC_2_REGS                  (0x01C40C00)
+#define CSL_PWR_SLEEP_CTRL_1_REGS        (0x01C41000)
+#define CSL_SYS_DFT_1_REGS               (0x01C42000)
+#define CSL_INTC1_REGS                   (0x01C48000)
+#define CSL_IEEE1394_1_REGS              (0x01C60000)
+#define CSL_USBOTG_1_REGS                (0x01C48000)
+#define CSL_ATA_1_REGS                   (0x01C66000)
+#define CSL_SPI_1_REGS                   (0x01C66800)
+#define CSL_GPIO_1_REGS                  (0x01C67000)
+#define CSL_UHPI_1_REGS                  (0x01C67800)
+#define CSL_VPSS_REGS_1_REGS             (0x01C70000)
+#define CSL_EMAC_CTRL_1_REGS             (0x01C80000)
+#define CSL_EMAC_WRAP_1_REGS             (0x01C81000)
+#define CSL_EMAC_RAM_1_REGS              (0x01C82000)
+#define CSL_MDIO_1_REGS                  (0x01C84000)
+#define CSL_EMIF_1_REGS                  (0x01E00000)
+#define CSL_NAND_1_REGS                  (0x01E00000)
+#define CSL_MCBSP_1_REGS                 (0x01E02000)
+#define CSL_MMCSD_1_REGS                 (0x01E10000)
+#define CSL_MS_1_REGS                    (0x01E20000)
+#define CSL_DDR_1_REGS                   (0x20000000)
+#define CSL_VLYNQ_1_REGS                 (0x01E01000)
+#define CSL_PMX_1_REGS                   (0x01DEAD00) // TODO: Get correct base address.
+#define DAVINCI_ASYNC_EMIF_DATA_CE0_BASE (0x02000000)
+#define DAVINCI_ASYNC_EMIF_DATA_CE1_BASE (0x04000000)
+#define DAVINCI_ASYNC_EMIF_DATA_CE2_BASE (0x06000000)
+#define DAVINCI_ASYNC_EMIF_DATA_CE3_BASE (0x08000000)
+#define DAVINCI_VLYNQ_REMOTE_BASE        (0x0c000000)
+
+/* Added for EDMA  */
+/** @brief Base address of Channel controller  memory mapped registers */
+#define CSL_EDMACC_1_REGS                 (0x01C00000u)
+#define CSL_EDMA_1                         0
+
+
+/*****************************************************************************\
+* Interrupt/Exception Counts
+\*****************************************************************************/
+
+#define _CSL_INTC_EVENTID__INTC0CNT     (8)      /* ARM exception count     */
+#define _CSL_INTC_EVENTID__INTC1CNT     (64)     /* Level-1 Interrupt count */
+
+/**
+ * @brief   Count of the number of interrupt-events
+ */
+#define CSL_INTC_EVENTID_CNT        \
+    (_CSL_INTC_EVENTID__INTC0CNT + _CSL_INTC_EVENTID__INTC1CNT)
+
+/*****************************************************************************\
+* Interrupt Event IDs
+\*****************************************************************************/
+
+#define   _CSL_INTC_EVENTID__SPURIOUS         (0)
+#define   _CSL_INTC_EVENTID__INTC1START       (0)
+
+#define   CSL_INTC_EVENTID_VD0           (_CSL_INTC_EVENTID__INTC1START + 0)  /**< VPSS - CCDC      */
+#define   CSL_INTC_EVENTID_VD1           (_CSL_INTC_EVENTID__INTC1START + 1)  /**< VPSS - CCDC      */
+#define   CSL_INTC_EVENTID_VD2           (_CSL_INTC_EVENTID__INTC1START + 2)  /**< VPSS - CCDC      */
+#define   CSL_INTC_EVENTID_HIST          (_CSL_INTC_EVENTID__INTC1START + 3)  /**< VPSS - Histogram */
+#define   CSL_INTC_EVENTID_H3A           (_CSL_INTC_EVENTID__INTC1START + 4)  /**< VPSS - AE/AWB/AF */
+#define   CSL_INTC_EVENTID_PRVU          (_CSL_INTC_EVENTID__INTC1START + 5)  /**< VPSS - Previewer */
+#define   CSL_INTC_EVENTID_RSZ           (_CSL_INTC_EVENTID__INTC1START + 6)  /**< VPSS - Resizer   */
+#define   CSL_INTC_EVENTID_VFOC          (_CSL_INTC_EVENTID__INTC1START + 7)  /**< VPSS - Focus     */
+#define   CSL_INTC_EVENTID_VENC          (_CSL_INTC_EVENTID__INTC1START + 8)  /**< VPSS - VPBE      */
+#define   CSL_INTC_EVENTID_ASQ           (_CSL_INTC_EVENTID__INTC1START + 9)  /**< IMCOP - Sqr      */
+#define   CSL_INTC_EVENTID_IMX           (_CSL_INTC_EVENTID__INTC1START + 10) /**< IMCOP - iMX      */
+#define   CSL_INTC_EVENTID_VLCD          (_CSL_INTC_EVENTID__INTC1START + 11) /**< IMCOP - VLCD     */
+#define   CSL_INTC_EVENTID_USBC          (_CSL_INTC_EVENTID__INTC1START + 12) /**< USB OTG Collector*/
+#define   CSL_INTC_EVENTID_EMAC          (_CSL_INTC_EVENTID__INTC1START + 13) /**< CPGMAC Wrapper   */
+#define   CSL_INTC_EVENTID_1394          (_CSL_INTC_EVENTID__INTC1START + 14) /**< IEEE1394         */
+#define   CSL_INTC_EVENTID_1394WK        (_CSL_INTC_EVENTID__INTC1START + 15) /**< IEEE1394         */
+#define   CSL_INTC_EVENTID_CC0           (_CSL_INTC_EVENTID__INTC1START + 16) /**< 3PCC Region 0    */
+#define   CSL_INTC_EVENTID_CCERR         (_CSL_INTC_EVENTID__INTC1START + 17) /**< 3PCC Error       */
+#define   CSL_INTC_EVENTID_TCERR0        (_CSL_INTC_EVENTID__INTC1START + 18) /**< 3PTC0 Error      */
+#define   CSL_INTC_EVENTID_TCERR1        (_CSL_INTC_EVENTID__INTC1START + 19) /**< 3PTC1 Error      */
+#define   CSL_INTC_EVENTID_PSCINT        (_CSL_INTC_EVENTID__INTC1START + 20) /**< PSC - ALLINT     */
+#define   CSL_INTC_EVENTID_RSVD21        (_CSL_INTC_EVENTID__INTC1START + 21) /**< Reserved         */
+#define   CSL_INTC_EVENTID_ATA           (_CSL_INTC_EVENTID__INTC1START + 22) /**< ATA/IDE          */
+#define   CSL_INTC_EVENTID_HPIINT        (_CSL_INTC_EVENTID__INTC1START + 23) /**< UHPI             */
+#define   CSL_INTC_EVENTID_MBX           (_CSL_INTC_EVENTID__INTC1START + 24) /**< McBSP            */
+#define   CSL_INTC_EVENTID_MBR           (_CSL_INTC_EVENTID__INTC1START + 25) /**< McBSP            */
+#define   CSL_INTC_EVENTID_MMCSD         (_CSL_INTC_EVENTID__INTC1START + 26) /**< MMC/SD           */
+#define   CSL_INTC_EVENTID_SDIO          (_CSL_INTC_EVENTID__INTC1START + 27) /**< MMC/SD           */
+#define   CSL_INTC_EVENTID_MS            (_CSL_INTC_EVENTID__INTC1START + 28) /**< Memory Stick     */
+#define   CSL_INTC_EVENTID_DDR           (_CSL_INTC_EVENTID__INTC1START + 29) /**< DDR EMIF         */
+#define   CSL_INTC_EVENTID_EMIF          (_CSL_INTC_EVENTID__INTC1START + 30) /**< Async EMIF       */
+#define   CSL_INTC_EVENTID_VLQ           (_CSL_INTC_EVENTID__INTC1START + 31) /**< VLYNQ            */
+#define   CSL_INTC_EVENTID_TIMER0INT12   (_CSL_INTC_EVENTID__INTC1START + 32) /**< Timer 0 - TINT12 */
+#define   CSL_INTC_EVENTID_TIMER0INT34   (_CSL_INTC_EVENTID__INTC1START + 33) /**< Timer 0 - TINT34 */
+#define   CSL_INTC_EVENTID_TIMER1INT12   (_CSL_INTC_EVENTID__INTC1START + 34) /**< Timer 1 - TINT12 */
+#define   CSL_INTC_EVENTID_TIMER1INT34   (_CSL_INTC_EVENTID__INTC1START + 35) /**< Timer 2 - TINT34 */
+#define   CSL_INTC_EVENTID_PWM0          (_CSL_INTC_EVENTID__INTC1START + 36) /**< PWM0             */
+#define   CSL_INTC_EVENTID_PWM1          (_CSL_INTC_EVENTID__INTC1START + 37) /**< PWM1             */
+#define   CSL_INTC_EVENTID_PWM2          (_CSL_INTC_EVENTID__INTC1START + 38) /**< PWM2             */
+#define   CSL_INTC_EVENTID_I2C           (_CSL_INTC_EVENTID__INTC1START + 39) /**< I2C              */
+#define   CSL_INTC_EVENTID_UART0         (_CSL_INTC_EVENTID__INTC1START + 40) /**< UART0            */
+#define   CSL_INTC_EVENTID_UART1         (_CSL_INTC_EVENTID__INTC1START + 41) /**< UART1            */
+#define   CSL_INTC_EVENTID_UART2         (_CSL_INTC_EVENTID__INTC1START + 42) /**< UART2            */
+#define   CSL_INTC_EVENTID_SPI0          (_CSL_INTC_EVENTID__INTC1START + 43) /**< SPI              */
+#define   CSL_INTC_EVENTID_SPI1          (_CSL_INTC_EVENTID__INTC1START + 44) /**< SPI              */
+#define   CSL_INTC_EVENTID_WDT           (_CSL_INTC_EVENTID__INTC1START + 45) /**< Timer 3 - TINT12 */
+#define   CSL_INTC_EVENTID_DSP0          (_CSL_INTC_EVENTID__INTC1START + 46) /**< DSP Controller   */
+#define   CSL_INTC_EVENTID_DSP1          (_CSL_INTC_EVENTID__INTC1START + 47) /**< DSP Controller   */
+#define   CSL_INTC_EVENTID_GPIO0         (_CSL_INTC_EVENTID__INTC1START + 48) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIO1         (_CSL_INTC_EVENTID__INTC1START + 49) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIO2         (_CSL_INTC_EVENTID__INTC1START + 50) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIO3         (_CSL_INTC_EVENTID__INTC1START + 51) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIO4         (_CSL_INTC_EVENTID__INTC1START + 52) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIO5         (_CSL_INTC_EVENTID__INTC1START + 53) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIO6         (_CSL_INTC_EVENTID__INTC1START + 54) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIO7         (_CSL_INTC_EVENTID__INTC1START + 55) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIOBNK0      (_CSL_INTC_EVENTID__INTC1START + 56) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIOBNK1      (_CSL_INTC_EVENTID__INTC1START + 57) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIOBNK2      (_CSL_INTC_EVENTID__INTC1START + 58) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIOBNK3      (_CSL_INTC_EVENTID__INTC1START + 59) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIOBNK4      (_CSL_INTC_EVENTID__INTC1START + 60) /**< GPIO             */
+#define   CSL_INTC_EVENTID_COMMTX        (_CSL_INTC_EVENTID__INTC1START + 61) /**< ARMSS            */
+#define   CSL_INTC_EVENTID_COMMRX        (_CSL_INTC_EVENTID__INTC1START + 62) /**< ARMSS            */
+#define   CSL_INTC_EVENTID_EMU           (_CSL_INTC_EVENTID__INTC1START + 63) /**< E2ICE            */
+
+#define   _CSL_INTC_EVENTID__INTC1END    (_CSL_INTC_EVENTID__INTC1START + _CSL_INTC_EVENTID__INTC1CNT - 1)
+
+
+#define    _CSL_INTC_EVENTID__INTC0START (_CSL_INTC_EVENTID__INTC1END + 1)
+
+#define    CSL_INTC_EVENTID_RESET        (_CSL_INTC_EVENTID__INTC0START + 0)  /**< the RESET exception vector   */
+#define    CSL_INTC_EVENTID_UNDEF        (_CSL_INTC_EVENTID__INTC0START + 1)  /**< the UNDEF exception vector   */
+#define    CSL_INTC_EVENTID_SWI          (_CSL_INTC_EVENTID__INTC0START + 2)  /**< the SWI exception vector     */
+#define    CSL_INTC_EVENTID_PREABT       (_CSL_INTC_EVENTID__INTC0START + 3)  /**< the PREABT exception vector  */
+#define    CSL_INTC_EVENTID_DATABT       (_CSL_INTC_EVENTID__INTC0START + 4)  /**< the DATABT exception vector  */
+#define    CSL_INTC_EVENTID_IRQ          (_CSL_INTC_EVENTID__INTC0START + 6)  /**< the IRQ exception vector     */
+#define    CSL_INTC_EVENTID_FIQ          (_CSL_INTC_EVENTID__INTC0START + 7)  /**< the FIQ exception vector     */
+
+#define    _CSL_INTC_EVENTID__INTC0END   (_CSL_INTC_EVENTID__INTC0START + _CSL_INTC_EVENTID__INTC0CNT - 1)
+
+#define    CSL_INTC_EVENTID_INVALID      (-1)                                 /**< Invalid Event-ID */
+
+#endif
diff -Nurd u-boot-1.2.0/board/davinci/timer.c u-boot-1.2.0-leopard/board/davinci/timer.c
--- u-boot-1.2.0/board/davinci/timer.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/davinci/timer.c	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,73 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ Modifications:
+ ver. 1.0: Oct 2005, Swaminathan S
+ *
+ */
+
+#include "soc.h"
+#include "timer.h"
+
+/* Use Timer 3&4 (Timer 2) */
+#define TIMER_BASE_ADDR	CSL_TMR_1_REGS
+
+davinci_timer_reg    *davinci_timer = (davinci_timer_reg *) TIMER_BASE_ADDR;
+
+/* Timer Initialize */
+void inittimer(void)
+{
+        /* disable Timer 1 & 2 timers */
+        davinci_timer->tcr = 0;
+
+        /* Set timers to unchained dual 32 bit timers, Unreset timer34 */
+        davinci_timer->tgcr = 0x0;
+        davinci_timer->tgcr = 0x6;
+
+        /* Program the timer12 counter register - set the prd12 for right count */
+        davinci_timer->tim34 = 0;
+
+        /* The timer is programmed to expire after 0xFFFFFFFF ticks */
+        davinci_timer->prd34 = 0xFFFFFFFF;
+
+        /* Enable timer34 */
+        davinci_timer->tcr = (0x80 << 16); /* Timer34 continously enabled, Timer12 disabled */
+}
+
+/************************************************************
+********************** Reset Processor **********************
+************************************************************/
+#define WDT_BASE_ADDR          CSL_WDT_1_REGS
+
+
+void reset_processor(void)
+{
+        davinci_timer_reg *davinci_wdt = (davinci_timer_reg *) WDT_BASE_ADDR;
+        davinci_wdt->tgcr   = 0x00000008;
+        davinci_wdt->tgcr  |= 0x00000003;
+        davinci_wdt->tim12  = 0x00000000;
+        davinci_wdt->tim34  = 0x00000000;
+        davinci_wdt->prd12  = 0x00000000;
+        davinci_wdt->prd34  = 0x00000000;
+        davinci_wdt->tcr   |= 0x00000040;
+        davinci_wdt->wdtcr |= 0x00004000;
+        davinci_wdt->wdtcr  = 0xA5C64000;
+        davinci_wdt->wdtcr  = 0xDA7E4000;
+}
diff -Nurd u-boot-1.2.0/board/davinci/timer.h u-boot-1.2.0-leopard/board/davinci/timer.h
--- u-boot-1.2.0/board/davinci/timer.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/davinci/timer.h	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,51 @@
+/*
+ *
+ *  Copyright (C) 2004 Texas Instruments.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ * Modifications:
+ * ver. 1.0: Oct 2005, Swaminathan S
+ *
+ */
+#ifndef __TIMER_H__
+#define __TIMER_H__
+
+typedef volatile struct davinci_timer_reg_t
+{
+    unsigned int pid12;         /* 0x0 */
+    unsigned int emumgt_clksped;/* 0x4 */
+    unsigned int gpint_en;      /* 0x8 */
+    unsigned int gpdir_dat;     /* 0xC */
+    unsigned int tim12;         /* 0x10 */
+    unsigned int tim34;         /* 0x14 */
+    unsigned int prd12;         /* 0x18 */
+    unsigned int prd34;         /* 0x1C */
+    unsigned int tcr;           /* 0x20 */
+    unsigned int tgcr;          /* 0x24 */
+    unsigned int wdtcr;         /* 0x28 */
+    unsigned int tlgc;          /* 0x2C */
+    unsigned int tlmr;          /* 0x30 */
+} davinci_timer_reg;
+
+#endif  /* __TIMER_H__ */
+
diff -Nurd u-boot-1.2.0/board/davinci/types.h u-boot-1.2.0-leopard/board/davinci/types.h
--- u-boot-1.2.0/board/davinci/types.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/davinci/types.h	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,46 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ *
+ */
+#ifndef _TYPESH_
+#define _TYPESH_
+
+typedef unsigned long 	ULONG;
+typedef unsigned short 	USHORT;
+typedef unsigned long   BOOL;
+typedef unsigned int	WORD;
+typedef char            CHAR;
+typedef unsigned char   BYTE, *LPBYTE, UCHAR, *PUCHAR, PBYTE;
+
+#define FALSE           0
+#define TRUE            1
+
+#define NULL			0
+
+typedef unsigned short int Hwd;
+typedef volatile unsigned short int vHwd;
+typedef unsigned short int *  Hwdptr;
+typedef volatile unsigned short int * vHwdptr;
+//typedef volatile unsigned int * vHwdptr;
+
+
+#endif
+
diff -Nurd u-boot-1.2.0/board/davinci/u-boot.lds u-boot-1.2.0-leopard/board/davinci/u-boot.lds
--- u-boot-1.2.0/board/davinci/u-boot.lds	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/davinci/u-boot.lds	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,52 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+	. = ALIGN(4);
+	.text	:
+	{
+	  cpu/arm926ejs/start.o	(.text)
+	  *(.text)
+	}
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+	. = ALIGN(4);
+	.data : { *(.data) }
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -Nurd u-boot-1.2.0/board/dm355_evm/Makefile u-boot-1.2.0-leopard/board/dm355_evm/Makefile
--- u-boot-1.2.0/board/dm355_evm/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_evm/Makefile	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= dm355_evm.o flash.o nand.o timer.o 
+SOBJS	:= lowlevel_init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $^
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff -Nurd u-boot-1.2.0/board/dm355_evm/config.mk u-boot-1.2.0-leopard/board/dm355_evm/config.mk
--- u-boot-1.2.0/board/dm355_evm/config.mk	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_evm/config.mk	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,25 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+# David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+#
+# (C) Copyright 2003
+# Texas Instruments, <www.ti.com>
+# Swaminathan <swami.iyer@ti.com>
+#
+# Davinci EVM board (ARM925EJS) cpu
+# see http://www.ti.com/ for more information on Texas Instruments
+#
+# Davinci EVM has 1 bank of 256 MB DDR RAM 
+# Physical Address:
+# 8000'0000 to 9000'0000
+#
+# Linux-Kernel is expected to be at 8000'8000, entry 8000'8000
+# (mem base + reserved)
+#
+# we load ourself to 8100 '0000
+# 
+#
+
+#Provide a atleast 16MB spacing between us and the Linux Kernel image
+TEXT_BASE = 0x81080000
diff -Nurd u-boot-1.2.0/board/dm355_evm/dm355_evm.c u-boot-1.2.0-leopard/board/dm355_evm/dm355_evm.c
--- u-boot-1.2.0/board/dm355_evm/dm355_evm.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_evm/dm355_evm.c	2008-01-05 03:44:03.000000000 -0300
@@ -0,0 +1,598 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ Modifications:
+ ver. 1.0: Oct 2005, Swaminathan S
+ *
+ */
+#include <common.h>
+#include <i2c.h>
+#include <asm/io.h>
+
+#define inw(a) __raw_readw(a)
+#define outw(a,v) __raw_writew(a,v)
+
+
+#define PLL1_PLLM    *(volatile unsigned int *)0x01c40910
+#define PLL2_PLLM    *(volatile unsigned int *)0x01c40D10
+#define PLL2_DIV2    *(volatile unsigned char *)0x01c40D1C
+#define PLL2_PREDIV  *(volatile unsigned int *)0x01C40D14
+#define PLL1_PLLDIV3 *(volatile unsigned int *)0x01C40920
+#define PLL1_POSTDIV *(volatile unsigned int *)0x01C40928
+#define PLL1_PLLDIV4 *(volatile unsigned int *)0x01C40960
+#define SYSTEM_MISC  *(volatile unsigned int *)0x01C40038
+#define MACH_DM350_EVM	1381
+
+void davinci_psc_all_enable(void);
+short MSP430_getReg( short reg, unsigned short *regval );
+unsigned int UARTSendInt(unsigned int value);
+
+/*******************************************
+ Routine: delay
+ Description:  Delay function
+*******************************************/
+static inline void delay (unsigned long loops)
+{
+__asm__ volatile ("1:\n"
+		     "subs %0, %1, #1\n"
+		     "bne 1b":"=r" (loops):"0" (loops));
+}
+
+/*******************************************
+ Routine: board_init
+ Description:  Board Initialization routine
+*******************************************/
+int board_init (void)
+{
+    	  DECLARE_GLOBAL_DATA_PTR;
+
+        /* arch number of DaVinci DVDP-Board */
+        gd->bd->bi_arch_number = MACH_DM350_EVM;
+
+      	/* adress of boot parameters */
+       	gd->bd->bi_boot_params = LINUX_BOOT_PARAM_ADDR;
+        /* Configure MUX settings */
+
+      /* Power on required peripherals 
+    	davinci_psc_all_enable(); */
+#if 0
+      	/* this speeds up your boot a quite a bit.  However to make it
+ 	 *  work, you need make sure your kernel startup flush bug is fixed.
+	 *  ... rkw ...
+	 */
+	icache_enable ();
+
+#endif
+      	inittimer ();
+
+      	return 0;
+}
+
+/* PSC Domains */
+
+#define LPSC_VPSSMSTR       0       // VPSS Master LPSC
+#define LPSC_VPSSSLV        1       // VPSS Slave LPSC
+#define LPSC_TPCC           2       // TPCC LPSC
+#define LPSC_TPTC0          3       // TPTC0 LPSC
+#define LPSC_TPTC1          4       // TPTC1 LPSC
+#define PAL_SYS_CLK_MODULE_SPI1 6 /**<SPI1 LPSC Module No*/
+#define PAL_SYS_CLK_MODULE_MMCSD1 7 /**<MMCSD1 LPSC Module No*/
+#define LPSC_USB            9       // USB LPSC
+#define PAL_SYS_CLK_MODULE_PWM3 10  /**<PWM3 LPSC Module No*/
+#define PAL_SYS_CLK_MODULE_SPI2 11  /**<SPI2 LPSC Module No*/
+#define PAL_SYS_CLK_MODULE_RTO 12   /**<TIMER2 LPSC Module No*/
+#define LPSC_DDR_EMIF       13      // DDR_EMIF LPSC
+#define LPSC_AEMIF          14      // AEMIF LPSC
+#define LPSC_MMC_SD         15      // MMC_SD LPSC
+#define LPSC_MEMSTICK       16      // MEMSTICK LPSC
+#define PAL_SYS_CLK_MODULE_ASP 17   /**<AEMIF LPSC Module No*/
+#define LPSC_I2C            18      // I2C LPSC
+#define LPSC_UART0          19      // UART0 LPSC
+#define LPSC_UART1          20      // UART1 LPSC
+#define LPSC_UART2          21      // UART2 LPSC
+#define LPSC_SPI            22      // SPI LPSC
+#define LPSC_PWM0           23      // PWM0 LPSC
+#define LPSC_PWM1           24      // PWM1 LPSC
+#define LPSC_PWM2           25      // PWM2 LPSC
+#define LPSC_GPIO           26      // GPIO LPSC
+#define LPSC_TIMER0         27      // TIMER0 LPSC
+#define LPSC_TIMER1         28      // TIMER1 LPSC
+#define LPSC_TIMER2         29      // TIMER2 LPSC
+#define LPSC_SYSTEM_SUBSYS  30      // SYSTEM SUBSYSTEM LPSC
+#define LPSC_ARM            31      // ARM LPSC
+#define PAL_SYS_CLK_MODULE_VPSS_DAC 40  /**<VPSS DAC LPSC Module No*/
+
+#define EPCPR               *( unsigned int* )( 0x01C41070 )
+#define PTCMD               *( unsigned int* )( 0x01C41120 )
+#define PTSTAT              *( unsigned int* )( 0x01C41128 )
+#define PDSTAT              *( unsigned int* )( 0x01C41200 )
+#define PDSTAT1             *( unsigned int* )( 0x01C41204 )
+#define PDCTL               *( unsigned int* )( 0x01C41300 )
+#define PDCTL1              *( unsigned int* )( 0x01C41304 )
+#define VBPR                *( unsigned int* )( 0x20000020 )
+
+/**************************************
+ Routine: board_setup_psc_on
+ Description:  Enable a PSC domain
+**************************************/
+void board_setup_psc_on( unsigned int domain, unsigned int id )
+{
+        volatile unsigned int* mdstat = ( unsigned int* )( 0x01C41800 + 4 * id );
+	      volatile unsigned int* mdctl  = ( unsigned int* )( 0x01C41A00 + 4 * id );
+
+	      *mdctl |= 0x00000003; // Set PowerDomain to turn on
+
+    	  if ( ( PDSTAT & 0x00000001 ) == 0 )
+    	  {
+                PDCTL1 |= 0x1;
+        	      PTCMD = ( 1 << domain );
+        	      while ( ( ( ( EPCPR >> domain ) & 1 ) == 0 ) );
+
+        	      PDCTL1 |= 0x100 ;
+        	      while( ! ( ( ( PTSTAT >> domain ) & 1 ) == 0 ) );
+    	  }
+    	  else
+    	  {
+        	      PTCMD = ( 1<<domain );
+        	      while( ! ( ( ( PTSTAT >> domain ) & 1 ) == 0 ) );
+    	  }
+
+    	  while( ! ( ( *mdstat & 0x0000001F ) == 0x3 ) );
+}
+
+/**************************************
+ Routine: davinci_psc_all_enable
+ Description:  Enable all PSC domains
+**************************************/
+void davinci_psc_all_enable(void)
+{
+#define PSC_ADDR            0x01C41000
+#define PTCMD               (PSC_ADDR+0x120)
+#define PTSTAT              (PSC_ADDR+0x128)
+
+        unsigned int alwaysOnPdNum = 0, dspPdNum = 1, i;
+
+    	  /* This function turns on all clocks in the ALWAYSON and DSP Power
+	       * Domains.  Note this function assumes that the Power Domains are
+	       * already on.
+	       */
+#if 0
+    	  /* Write ENABLE (0x3) to all 41 MDCTL[i].NEXT bit fields. */
+    	  for( i = 0; i < 41; i++){
+                *(volatile unsigned int*) (PSC_ADDR+0xA00+4*i) =
+				        *(volatile unsigned int*) (PSC_ADDR+0xA00+4*i) | 0x3;
+    	  }
+
+    	  /* For special workaround:  Set MDCTL[i].EMURSTIE to 0x1 for all of the
+	       * following Modules.  VPSSSLV, EMAC, EMACCTRL, MDIO, USB, ATA, VLYNQ,
+         * HPI, DDREMIF, AEMIF, MMCSD, MEMSTICK, ASP, GPIO, IMCOP.
+         */
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*1) = *(unsigned int*) (PSC_ADDR+0xA00+4*1) | 0x203;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*5) = *(unsigned int*) (PSC_ADDR+0xA00+4*5) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*6) = *(unsigned int*) (PSC_ADDR+0xA00+4*6) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*7) = *(unsigned int*) (PSC_ADDR+0xA00+4*7) | 0x203;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*9) = *(unsigned int*) (PSC_ADDR+0xA00+4*9) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*10) = *(unsigned int*) (PSC_ADDR+0xA00+4*10) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*11) = *(unsigned int*) (PSC_ADDR+0xA00+4*11) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*12) = *(unsigned int*) (PSC_ADDR+0xA00+4*12) | 0x203;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*13) = *(unsigned int*) (PSC_ADDR+0xA00+4*13) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*14) = *(unsigned int*) (PSC_ADDR+0xA00+4*14) | 0x203;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*15) = *(unsigned int*) (PSC_ADDR+0xA00+4*15) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*16) = *(unsigned int*) (PSC_ADDR+0xA00+4*16) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*17) = *(unsigned int*) (PSC_ADDR+0xA00+4*17) | 0x203;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*19) = *(unsigned int*) (PSC_ADDR+0xA00+4*19) | 0x203;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*26) = *(unsigned int*) (PSC_ADDR+0xA00+4*26) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*40) = *(unsigned int*) (PSC_ADDR+0xA00+4*40) | 0x203;*/
+#endif
+
+        /* For special workaround:  Clear MDCTL[i].EMURSTIE to 0x0 for all of the following Modules.
+         *  VPSSSLV, EMAC, EMACCTRL, MDIO, USB, ATA, VLYNQ,
+         *  HPI, DDREMIF, AEMIF, MMCSD, MEMSTICK, ASP, GPIO, IMCOP.
+         */
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*1) = *(unsigned int*) (PSC_ADDR+0xA00+4*1) & 0x003;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*5) = *(unsigned int*) (PSC_ADDR+0xA00+4*5) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*6) = *(unsigned int*) (PSC_ADDR+0xA00+4*6) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*7) = *(unsigned int*) (PSC_ADDR+0xA00+4*7) | 0x003;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*9) = *(unsigned int*) (PSC_ADDR+0xA00+4*9) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*10) = *(unsigned int*) (PSC_ADDR+0xA00+4*10) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*11) = *(unsigned int*) (PSC_ADDR+0xA00+4*11) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*12) = *(unsigned int*) (PSC_ADDR+0xA00+4*12) & 0x003;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*13) = *(unsigned int*) (PSC_ADDR+0xA00+4*13) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*14) = *(unsigned int*) (PSC_ADDR+0xA00+4*14) | 0x003;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*15) = *(unsigned int*) (PSC_ADDR+0xA00+4*15) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*16) = *(unsigned int*) (PSC_ADDR+0xA00+4*16) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*17) = *(unsigned int*) (PSC_ADDR+0xA00+4*17) & 0x003;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*19) = ((*(unsigned int*) (PSC_ADDR+0xA00+4*19))&0xFFFFFFF8) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*20) = ((*(unsigned int*) (PSC_ADDR+0xA00+4*20))&0xFFFFFFF8) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*21) = ((*(unsigned int*) (PSC_ADDR+0xA00+4*21))&0xFFFFFFF8) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*18) = *(unsigned int*) (PSC_ADDR+0xA00+4*18) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*28) = *(unsigned int*) (PSC_ADDR+0xA00+4*28) | 0x003;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*26) = *(unsigned int*) (PSC_ADDR+0xA00+4*26) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*40) = *(unsigned int*) (PSC_ADDR+0xA00+4*40) & 0x003;*/
+
+    	  /* Set PTCMD.GO0 to 0x1 to initiate the state transtion for Modules in
+	       * the ALWAYSON Power Domain
+	       */
+    	  *(volatile unsigned int*) PTCMD = (1<<alwaysOnPdNum);
+
+
+    	  /* Wait for PTSTAT.GOSTAT0 to clear to 0x0 */
+    	  while(! (((*(volatile unsigned int*) PTSTAT >> alwaysOnPdNum) & 0x00000001) == 0));
+
+	/* Wait for PTSTAT.GOSTAT0 to clear to 0x0 */
+          while(! ((*(unsigned int*) (PSC_ADDR+0x800+4*19)& 0x0000001F ) == 0x3));
+	/* Wait for PTSTAT.GOSTAT0 to clear to 0x0 */
+          while(! ((*(unsigned int*) (PSC_ADDR+0x800+4*20)& 0x0000001F ) == 0x3));
+	/* Wait for PTSTAT.GOSTAT0 to clear to 0x0 */
+          while(! ((*(unsigned int*) (PSC_ADDR+0x800+4*21)& 0x0000001F ) == 0x3));
+        /* Bringup UART out of reset here since NS16650 code that we are using from uBoot
+         * will not do it
+         */
+
+#define UART0PWREMU_MGMT     0x01c20030
+        *(volatile unsigned int*) UART0PWREMU_MGMT |= 0x00008001;
+
+
+#define UART1PWREMU_MGMT     0x01c20430
+        *(volatile unsigned int*) UART1PWREMU_MGMT |= 0x00008001;
+
+#define UART2PWREMU_MGMT     0x01e06030
+        *(volatile unsigned int*) UART2PWREMU_MGMT |= 0x00008001;
+
+#define PINMUX3     0x01C4000C
+        /* Enable UART1 MUX Lines */
+        *(volatile unsigned int *)PINMUX3 |= 0x00600000;
+	
+				/* Enable UART2 MUX Lines */
+        *(volatile unsigned int *)PINMUX3 |= 0x0000AA00;
+
+	/* Set the Bus Priority Register to appropriate value */
+	VBPR = 0x20;
+}
+
+/******************************
+ Routine: misc_init_r
+ Description:  Misc. init
+******************************/
+int misc_init_r (void)
+{
+	char temp[20], *env=0;
+	char rtcdata[10] = { 4, 1, 0, 0, 0, 0, 0, 0, 0, 0};
+    int clk = 0;
+    unsigned short regval=0 ;
+
+    clk = ((PLL2_PLLM + 1) * 24) / ((PLL2_PREDIV & 0x1F) + 1); 
+
+    printf ("ARM Clock :- %dMHz\n", ( ( ((PLL1_PLLM+1)*24 )/(2*(7+1)*((SYSTEM_MISC & 0x2)?2:1 )))) );
+    printf ("DDR Clock :- %dMHz\n", (clk/2));
+
+    if ( !(env=getenv("videostd")) || !strcmp(env,"ntsc") || !strcmp(env, "pal") )
+    {
+        MSP430_getReg( 0x04, &regval);
+        //printf("regval is %x\n",regval);
+        setenv ("videostd", ((regval  & 0x10)?"ntsc":"pal"));
+    }
+
+    return (0);
+}
+
+/******************************
+ Routine: dram_init
+ Description:  Memory Info
+******************************/
+int dram_init (void)
+{
+        DECLARE_GLOBAL_DATA_PTR;
+
+	      gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	      gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+        return 0;
+}
+
+
+typedef int     Bool;
+#define TRUE        ((Bool) 1)
+#define FALSE       ((Bool) 0)
+
+
+typedef int             Int;
+typedef unsigned int    Uns;    /* deprecated type */
+typedef char            Char;
+typedef char *          String;
+typedef void *          Ptr;
+
+/* unsigned quantities */
+typedef unsigned int    Uint32;
+typedef unsigned short  Uint16;
+typedef unsigned char   Uint8;
+
+/* signed quantities */
+typedef int             Int32;
+typedef short           Int16;
+typedef char            Int8;
+
+/* volatile unsigned quantities */
+typedef volatile unsigned int       VUint32;
+typedef volatile unsigned short     VUint16;
+typedef volatile unsigned char      VUint8;
+
+/* volatile signed quantities */
+typedef volatile int                VInt32;
+typedef volatile short              VInt16;
+typedef volatile char               VInt8;
+
+typedef struct _uart_regs
+{
+    VUint32 RBR;
+    VUint32 IER;
+    VUint32 IIR;
+    VUint32 LCR;
+    VUint32 MCR;
+    VUint32 LSR;
+    VUint32 MSR;
+    VUint32 SCR;
+    VUint8 DLL;
+    VUint8 RSVDO[3];
+    VUint8 DLH;
+    VUint8 RSVD1[3];
+    VUint32 PID1;
+    VUint32 PID2;
+    VUint32 PWREMU_MGNT;
+} uartRegs;
+
+#define THR RBR
+#define FCR IIR
+
+#define UART0 ((uartRegs*) 0x01C20000)
+
+#define MAXSTRLEN 256
+#define E_PASS    0x00000000u
+#define E_FAIL    0x00000001u
+#define E_TIMEOUT 0x00000002u
+
+
+
+// Send specified number of bytes
+
+Int32 GetStringLen(Uint8* seq)
+{
+    Int32 i = 0;
+    while ((seq[i] != 0) && (i<MAXSTRLEN)){ i++;}
+    if (i == MAXSTRLEN)
+        return -1;
+    else
+        return i;
+}
+
+Uint32 UARTSendData(Uint8* seq, Bool includeNull)
+{
+    Uint32 status = 0;
+    Int32 i,numBytes;
+    Uint32 timerStatus = 0x1000000;
+
+    numBytes = includeNull?(GetStringLen(seq)+1):(GetStringLen(seq));
+
+    for(i=0;i<numBytes;i++) {
+        /* Enable Timer one time */
+        //TIMER0Start();
+        do{
+            status = (UART0->LSR)&(0x60);
+            //timerStatus = TIMER0Status();
+            timerStatus--;
+        } while (!status && timerStatus);
+
+        if(timerStatus == 0)
+            return E_TIMEOUT;
+
+        // Send byte
+        (UART0->THR) = seq[i];
+    }
+    return E_PASS;
+}
+
+Uint32 UARTSendInt(Uint32 value)
+{
+    char seq[9];
+    Uint32 i,shift,temp;
+
+    for( i = 0; i < 8; i++)
+    {
+        shift = ((7-i)*4);
+        temp = ((value>>shift) & (0x0000000F));
+        if (temp > 9)
+        {
+            temp = temp + 7;
+        }
+        seq[i] = temp + 48;
+        seq[i] = temp + 48;
+    }
+    seq[8] = 0;
+    return UARTSendData(seq, FALSE);
+}
+
+#define I2C_BASE                0x01C21000
+#define	I2C_OA			(I2C_BASE + 0x00)
+#define I2C_IE                  (I2C_BASE + 0x04)
+#define I2C_STAT                (I2C_BASE + 0x08)
+#define I2C_SCLL                (I2C_BASE + 0x0c)
+#define I2C_SCLH                (I2C_BASE + 0x10)
+#define I2C_CNT                 (I2C_BASE + 0x14)
+#define I2C_DRR                 (I2C_BASE + 0x18)
+#define I2C_SA                  (I2C_BASE + 0x1c)
+#define I2C_DXR                 (I2C_BASE + 0x20)
+#define I2C_CON                 (I2C_BASE + 0x24)
+#define I2C_IV                  (I2C_BASE + 0x28)
+#define I2C_PSC                 (I2C_BASE + 0x30)
+
+#define I2C_CON_EN      (1 << 5)       /* I2C module enable */
+#define I2C_CON_STB     (1 << 4)       /* Start byte mode (master mode only) */
+#define I2C_CON_MST     (1 << 10)      /* Master/slave mode */
+#define I2C_CON_TRX     (1 << 9)       /* Transmitter/receiver mode (master mode only) */
+#define I2C_CON_XA      (1 << 8)       /* Expand address */
+#define I2C_CON_STP     (1 << 11)      /* Stop condition (master mode only) */
+#define I2C_CON_STT     (1 << 13)      /* Start condition (master mode only) */
+
+#define I2C_STAT_BB     (1 << 12)       /* Bus busy */
+#define I2C_STAT_ROVR   (1 << 11)       /* Receive overrun */
+#define I2C_STAT_XUDF   (1 << 10)       /* Transmit underflow */
+#define I2C_STAT_AAS    (1 << 9)        /* Address as slave */
+#define I2C_STAT_SCD    (1 << 5)        /* Stop condition detect */
+#define I2C_STAT_XRDY   (1 << 4)        /* Transmit data ready */
+#define I2C_STAT_RRDY   (1 << 3)        /* Receive data ready */
+#define I2C_STAT_ARDY   (1 << 2)        /* Register access ready */
+#define I2C_STAT_NACK   (1 << 1)        /* No acknowledgment interrupt enable */
+#define I2C_STAT_AL     (1 << 0)        /* Arbitration lost interrupt enable */
+
+static Int16 I2C_init(void );
+static Int16 I2C_close(void );
+static Int16 I2C_reset( void);
+static Int16 I2C_write( Uint16 i2c_addr, Uint8* data, Uint16 len );
+static Int16 I2C_read( Uint16 i2c_addr, Uint8* data, Uint16 len );
+Int32 i2c_timeout = 0x10000;
+
+Int16 MSP430_getReg( Int16 reg, Uint16 *regval )
+{
+    volatile Int16 retcode;
+    Uint8 msg[2];
+
+    I2C_reset();
+    udelay(10000);
+    /* Send Msg */
+    msg[0] = (Uint8)(reg & 0xff);
+    if ( retcode = I2C_write( 0x25, msg, 1) )
+    {
+        return retcode;
+    }
+
+    if ( retcode = I2C_read(  0x25, msg, 1 ) )
+    {
+        return retcode;
+    }
+
+    *regval = msg[0];
+
+    /* Wait 1 msec */
+    udelay( 1000 );
+
+    return 0;
+}
+
+static Int16 I2C_init( )
+{
+    outw(0, I2C_CON);                // Reset I2C
+    outw(26,I2C_PSC);               // Config prescaler for 27MHz
+    outw(20,I2C_SCLL);              // Config clk LOW for 20kHz
+    outw(20,I2C_SCLH);               // Config clk HIGH for 20kHz
+    outw(inw(I2C_CON) | I2C_CON_EN,I2C_CON);        // Release I2C from reset
+    return 0;
+}
+
+/* ------------------------------------------------------------------------ *
+ *                                                                          *
+ *  _I2C_close( )                                                           *
+ *                                                                          *
+ * ------------------------------------------------------------------------ */
+static Int16 I2C_close( )
+{
+        outw(0,I2C_CON);                      // Reset I2C
+        return 0;
+}
+
+/* ------------------------------------------------------------------------ *
+ *                                                                          *
+ *  _I2C_reset( )                                                           *
+ *                                                                          *
+ * ------------------------------------------------------------------------ */
+static Int16 I2C_reset( )
+{
+    I2C_close( );
+    I2C_init( );
+    return 0;
+}
+
+static Int16 I2C_write( Uint16 i2c_addr, Uint8* data, Uint16 len )
+{
+    Int32 timeout, i, status;
+
+        outw(len, I2C_CNT);                    // Set length
+        outw(i2c_addr, I2C_SA);               // Set I2C slave address
+        outw(0x2000               // Set for Master Write
+             | 0x0200
+             | 0x0400
+             | I2C_CON_EN
+             | 0x4000, I2C_CON );
+
+        udelay( 10 );                        // Short delay
+
+        for ( i = 0 ; i < len ; i++ )
+        {
+            outw( data[i],I2C_DXR);;            // Write
+
+            timeout = i2c_timeout;
+            do
+            {
+                if ( timeout-- < 0  )
+                {
+                    I2C_reset( );
+                    return -1;
+                }
+            } while ( ( inw(I2C_STAT) & I2C_STAT_XRDY ) == 0 );// Wait for Tx Ready
+        }
+
+        outw( inw(I2C_CON) | 0x0800, I2C_CON);             // Generate STOP
+
+        return 0;
+
+}
+static Int16 I2C_read( Uint16 i2c_addr, Uint8* data, Uint16 len )
+{
+    Int32 timeout, i, status;
+
+    outw( len, I2C_CNT);                    // Set length
+    outw( i2c_addr, I2C_SA);               // Set I2C slave address
+    outw( 0x2000               // Set for Master Read
+          | 0x0400
+          | I2C_CON_EN
+          | 0x4000,I2C_CON);
+
+    udelay( 10 );                        // Short delay
+
+    for ( i = 0 ; i < len ; i++ )
+    {
+        timeout = i2c_timeout;
+
+        /* Wait for Rx Ready */
+        do
+        {
+            if ( timeout-- < 0 )
+            {
+                I2C_reset( );
+                return -1;
+            }
+        } while ( ( inw(I2C_STAT) & I2C_STAT_RRDY ) == 0 );// Wait for Rx Ready
+
+        data[i] = inw(I2C_DRR);            // Read
+    }
+
+      //I2C_ICMDR |= ICMDR_STP;             // Generate STOP
+    return 0;
+}
+
diff -Nurd u-boot-1.2.0/board/dm355_evm/flash.c u-boot-1.2.0-leopard/board/dm355_evm/flash.c
--- u-boot-1.2.0/board/dm355_evm/flash.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_evm/flash.c	2008-01-05 03:44:03.000000000 -0300
@@ -0,0 +1,758 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2003
+ * Reinhard Meyer, EMK Elektronik GmbH, r.meyer@emk-elektronik.de
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */	
+
+#include <common.h>
+#include <linux/byteorder/swab.h>
+#include "types.h"
+
+#if !defined(CFG_NO_FLASH)
+flash_info_t	flash_info[CFG_MAX_FLASH_BANKS]; /* info for FLASH chips */
+
+#if defined (CFG_DM355_EVM)
+  typedef unsigned short FLASH_PORT_WIDTH;
+  typedef volatile unsigned short FLASH_PORT_WIDTHV;
+  #define	FLASH_ID_MASK	0xFF
+
+  #define FPW	FLASH_PORT_WIDTH
+  #define FPWV	FLASH_PORT_WIDTHV
+
+  #define EVMDM355_FLASH_CTL555        *(u16*)( CFG_FLASH_BASE + (0x555 << 1))
+  #define EVMDM355_FLASH_CTL2AA        *(u16*)( CFG_FLASH_BASE + (0x2aa << 1))
+  #define EVMDM355_CPLD                *(u16*)( CFG_FLASH_BASE + (0x1c000 << 0) )
+  #define EVMDM355_CPLD_MASK           0x3FC000
+
+  #define FLASH_CYCLE1	(0x0555)
+  #define FLASH_CYCLE2	(0x02aa)
+  #define FLASH_ID1		0
+  #define FLASH_ID2		1
+  #define FLASH_ID3		0x0e
+  #define FLASH_ID4		0x0F
+  #define SWAP(x)			__swab16(x)
+#endif
+
+#if defined (CONFIG_TOP860)
+  typedef unsigned short FLASH_PORT_WIDTH;
+  typedef volatile unsigned short FLASH_PORT_WIDTHV;
+  #define	FLASH_ID_MASK	0xFF
+
+  #define FPW	FLASH_PORT_WIDTH
+  #define FPWV	FLASH_PORT_WIDTHV
+
+  #define FLASH_CYCLE1	0x0555
+  #define FLASH_CYCLE2	0x02aa
+  #define FLASH_ID1		0
+  #define FLASH_ID2		1
+  #define FLASH_ID3		0x0e
+  #define FLASH_ID4		0x0F
+#endif
+
+#if defined (CONFIG_TOP5200) && !defined (CONFIG_LITE5200)
+  typedef unsigned char FLASH_PORT_WIDTH;
+  typedef volatile unsigned char FLASH_PORT_WIDTHV;
+  #define	FLASH_ID_MASK	0xFF
+
+  #define FPW	FLASH_PORT_WIDTH
+  #define FPWV	FLASH_PORT_WIDTHV
+
+  #define FLASH_CYCLE1	(0x0aaa << 1)
+  #define FLASH_CYCLE2	(0x0555 << 1)
+  #define FLASH_ID1		0
+  #define FLASH_ID2		2
+  #define FLASH_ID3		0x1c
+  #define FLASH_ID4		0x1E
+#endif
+
+#if defined (CONFIG_TOP5200) && defined (CONFIG_LITE5200)
+  typedef unsigned char FLASH_PORT_WIDTH;
+  typedef volatile unsigned char FLASH_PORT_WIDTHV;
+  #define	FLASH_ID_MASK	0xFF
+
+  #define FPW	FLASH_PORT_WIDTH
+  #define FPWV	FLASH_PORT_WIDTHV
+
+  #define FLASH_CYCLE1	0x0555
+  #define FLASH_CYCLE2	0x02aa
+  #define FLASH_ID1		0
+  #define FLASH_ID2		1
+  #define FLASH_ID3		0x0E
+  #define FLASH_ID4		0x0F
+#endif
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size(FPWV *addr, flash_info_t *info);
+static void flash_reset(flash_info_t *info);
+static int write_word(flash_info_t *info, FPWV *dest, FPW data);
+static flash_info_t *flash_get_info(ulong base);
+void inline spin_wheel (void);
+
+/*-----------------------------------------------------------------------
+ * flash_init()
+ *
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long flash_init (void)
+{
+	unsigned long size = 0;
+	int i = 0;
+    u16   mfgid, devid;
+	extern void flash_preinit(void);
+	extern void flash_afterinit(uint, ulong, ulong);
+	ulong flashbase = CFG_FLASH_BASE;
+
+#if 0
+    EVMDM355_CPLD = 0;
+    EVMDM355_FLASH_CTL555 = 0xf0;
+
+    EVMDM355_FLASH_CTL555 = 0xaa;
+    EVMDM355_FLASH_CTL2AA = 0x55;
+    EVMDM355_FLASH_CTL555 = 0x90;
+	/* The manufacturer codes are only 1 byte, so just use 1 byte.
+	 * This works for any bus width and any FLASH device width.
+	 */
+	udelay(100);
+    mgfid = *((u16*)CFG_FLASH_BASE);
+    devid = *((u16*)CFG_FLASH_BASE +1);
+
+    *((u8 *)CFG_FLASH_BASE) = 0xf0;
+
+    printf("MFGID %x \n", mfgid);
+    printf("DEVIU %x \n", devid);
+    if ((mfgid != 0x0001) || (devid != 0x227e))
+        return 1;
+#endif
+
+	/*flash_preinit();*/
+
+	/* There is only ONE FLASH device */
+	memset(&flash_info[i], 0, sizeof(flash_info_t));
+	flash_info[i].size =
+			flash_get_size((FPW *)flashbase, &flash_info[i]);
+	size += flash_info[i].size;
+
+#if CFG_MONITOR_BASE >= CFG_FLASH_BASE
+	/* monitor protection ON by default */
+	flash_protect(FLAG_PROTECT_SET,
+		      CFG_MONITOR_BASE,
+		      CFG_MONITOR_BASE+monitor_flash_len-1,
+		      flash_get_info(CFG_MONITOR_BASE));
+#endif
+
+#ifdef	CFG_ENV_IS_IN_FLASH
+	/* ENV protection ON by default */
+	flash_protect(FLAG_PROTECT_SET,
+		      CFG_ENV_ADDR,
+		      CFG_ENV_ADDR+CFG_ENV_SIZE-1,
+		      flash_get_info(CFG_ENV_ADDR));
+#endif
+
+
+	/*flash_afterinit(i, flash_info[i].start[0], flash_info[i].size);*/
+	return size ? size : 1;
+}
+
+/*-----------------------------------------------------------------------
+ */
+static void flash_reset(flash_info_t *info)
+{
+	FPWV *base = (FPWV *)(info->start[0]);
+
+	/* Put FLASH back in read mode */
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL)
+		*base = (FPW)0x00FF00FF;	/* Intel Read Mode */
+	else if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD)
+		*base = (FPW)0x00F000F0;	/* AMD Read Mode */
+}
+
+
+void flash_reset_sector(flash_info_t *info, ULONG addr)
+{  
+	// Reset Flash to be in Read Array Mode 
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL)
+		*(FPWV *)addr = (FPW)0x00FF00FF;	/* Intel Read Mode */
+	else if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD)
+		*(FPWV *)addr = (FPW)0x00F000F0;	/* AMD Read Mode */
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+static flash_info_t *flash_get_info(ulong base)
+{
+	int i;
+	flash_info_t * info;
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i ++) {
+		info = & flash_info[i];
+		if (info->size &&
+			info->start[0] <= base && base <= info->start[0] + info->size - 1)
+			break;
+	}
+
+	return i == CFG_MAX_FLASH_BANKS ? 0 : info;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+void flash_print_info (flash_info_t *info)
+{
+	int i;
+	uchar *boottype;
+	uchar *bootletter;
+	uchar *fmt;
+	uchar botbootletter[] = "B";
+	uchar topbootletter[] = "T";
+	uchar botboottype[] = "bottom boot sector";
+	uchar topboottype[] = "top boot sector";
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		printf ("missing or unknown FLASH type\n");
+		return;
+	}
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case FLASH_MAN_AMD:	printf ("MY AMD ");		break;
+#if 0
+	case FLASH_MAN_BM:	printf ("BRIGHT MICRO ");	break;
+	case FLASH_MAN_FUJ:	printf ("FUJITSU ");		break;
+	case FLASH_MAN_SST:	printf ("SST ");		break;
+	case FLASH_MAN_STM:	printf ("STM ");		break;
+#endif
+	case FLASH_MAN_INTEL:	printf ("INTEL ");		break;
+	default:		printf ("Unknown Vendor ");	break;
+	}
+
+	/* check for top or bottom boot, if it applies */
+	if (info->flash_id & FLASH_BTYPE) {
+		boottype = botboottype;
+		bootletter = botbootletter;
+	}
+	else {
+		boottype = topboottype;
+		bootletter = topbootletter;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_AM160T:
+	case FLASH_AM160B:
+		fmt = "29LV160%s (16 Mbit, %s)\n";
+		break;
+	case FLASH_AMLV640U:
+		fmt = "29LV640M (64 Mbit)\n";
+		break;
+	case FLASH_AMDLV065D:
+		fmt = "29LV065D (64 Mbit)\n";
+		break;
+	case FLASH_AMLV256U:
+		fmt = "29LV256M (256 Mbit)\n";
+		break;
+	case FLASH_28F128P30T:
+		fmt = "28F128P30T\n";
+		break;
+    case FLASH_S29GL256N:
+        fmt = "S29GL256N\n";
+        break;
+	default:
+		fmt = "Unknown Chip Type\n";
+		break;
+	}
+
+	printf (fmt, bootletter, boottype);
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+		info->size >> 20,
+		info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+
+	for (i=0; i<info->sector_count; ++i) {
+		ulong	size;
+		int		erased;
+		ulong	*flash = (unsigned long *) info->start[i];
+
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+
+		/*
+		 * Check if whole sector is erased
+		 */
+		size =
+			(i != (info->sector_count - 1)) ?
+			(info->start[i + 1] - info->start[i]) >> 2 :
+		(info->start[0] + info->size - info->start[i]) >> 2;
+
+		for (
+			flash = (unsigned long *) info->start[i], erased = 1;
+				(flash != (unsigned long *) info->start[i] + size) && erased;
+					flash++
+			)
+			erased = *flash == ~0x0UL;
+
+		printf (" %08lX %s %s",
+			info->start[i],
+			erased ? "E": " ",
+			info->protect[i] ? "(RO)" : "    ");
+	}
+
+	printf ("\n");
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+/*
+ * The following code cannot be run from FLASH!
+ */
+
+ulong flash_get_size (FPWV *addr, flash_info_t *info)
+{
+	int		i;
+    u16     mfgid, devid, id3,id4;
+    
+
+	/* Write auto select command: read Manufacturer ID */
+	/* Write auto select command sequence and test FLASH answer */
+    //EVMDM355_CPLD = 0;
+	addr[FLASH_CYCLE1] = (FPW)0x00AA00AA;	/* for AMD, Intel ignores this */
+	addr[FLASH_CYCLE2] = (FPW)0x00550055;	/* for AMD, Intel ignores this */
+	addr[FLASH_CYCLE1] = (FPW)0x00900090;	/* selects Intel or AMD */
+#if 0
+    EVMDM355_FLASH_CTL555 = 0xf0;
+
+    EVMDM355_FLASH_CTL555 = 0xaa;
+    EVMDM355_FLASH_CTL2AA = 0x55;
+    EVMDM355_FLASH_CTL555 = 0x90;
+#endif
+
+	/* The manufacturer codes are only 1 byte, so just use 1 byte.
+	 * This works for any bus width and any FLASH device width.
+	 */
+	udelay(100);
+
+	switch ( (mfgid = addr[FLASH_ID1]) & 0xff) {
+
+	case (uchar)AMD_MANUFACT:
+		printf ("MY AMD ", addr[FLASH_ID1] & 0xff);
+		info->flash_id = FLASH_MAN_AMD;
+		break;
+
+	case (uchar)INTEL_MANUFACT:
+                printf ("INTEL %x", addr[FLASH_ID1] & 0xff);
+		info->flash_id = FLASH_MAN_INTEL;
+		break;
+
+	default:
+		printf ("unknown vendor=%x ", addr[FLASH_ID1] & 0xff);
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		break;
+	}
+
+	/* Check 16 bits or 32 bits of ID so work on 32 or 16 bit bus. */
+	if (info->flash_id != FLASH_UNKNOWN) switch (devid = (FPW)addr[FLASH_ID2]) {
+
+	case (FPW)AMD_ID_LV160B:
+		info->flash_id += FLASH_AM160B;
+		info->sector_count = 35;
+		info->size = 0x00200000;
+		info->start[0] = (ulong)addr;
+		info->start[1] = (ulong)addr + 0x4000;
+		info->start[2] = (ulong)addr + 0x6000;
+		info->start[3] = (ulong)addr + 0x8000;
+		for (i = 4; i < info->sector_count; i++)
+		{
+			info->start[i] = (ulong)addr + 0x10000 * (i-3);
+		}
+		break;
+
+	case (FPW)AMD_ID_LV065D:
+		info->flash_id += FLASH_AMDLV065D;
+		info->sector_count = 128;
+		info->size = 0x00800000;
+		for (i = 0; i < info->sector_count; i++)
+		{
+			info->start[i] = (ulong)addr + 0x10000 * i;
+		}
+		break;
+
+	case (FPW)AMD_ID_MIRROR:
+		/* MIRROR BIT FLASH, read more ID bytes */
+        id3 = (FPW)addr[FLASH_ID3];
+        id4 = (FPW)addr[FLASH_ID4];
+		if ((FPW)addr[FLASH_ID3] == (FPW)AMD_ID_LV640U_2 &&
+			(FPW)addr[FLASH_ID4] == (FPW)AMD_ID_LV640U_3)
+		{
+			info->flash_id += FLASH_AMLV640U;
+			info->sector_count = 128;
+			info->size = 0x00800000;
+			for (i = 0; i < info->sector_count; i++)
+			{
+				info->start[i] = (ulong)addr + 0x10000 * i;
+			}
+			break;
+		}
+		else if ((FPW)addr[FLASH_ID3] == (FPW)AMD_ID_LV256U_2 &&
+			(FPW)addr[FLASH_ID4] == (FPW)AMD_ID_LV256U_3)
+		{
+			/* attention: only the first 16 MB will be used in u-boot */
+			info->flash_id += FLASH_AMLV256U;
+			info->sector_count = 256;
+			info->size = 0x01000000;
+			for (i = 0; i < info->sector_count; i++)
+			{
+				info->start[i] = (ulong)addr + 0x10000 * i;
+			}
+			break;
+		}
+        else
+        {
+            /* This is the default NOR flash for DM355 */
+			info->flash_id += FLASH_S29GL256N;
+			info->sector_count = 256;
+			info->size = 0x02000000;
+			for (i = 0; i < info->sector_count; i++)
+			{
+                info->start[i] = (ulong)addr + 0x20000 * i;
+			}
+			break;
+        }
+	case (FPW)INTEL_ID_28F128P30T:
+		/* Intel StrataFlash 28F128P30T */
+		info->flash_id += FLASH_28F128P30T;
+		info->sector_count = 131;
+		info->size = 0x01000000;
+		for (i = 0; i < info->sector_count; i++)
+		{
+			if (i < 127)
+				info->start[i] = (ulong)addr + 0x20000 * i;
+			else
+				info->start[i] = (ulong)addr + 0xfe0000 + 0x8000 * (i-127);
+		}
+		break;
+
+		/* fall thru to here ! */
+	default:
+		printf ("unknown AMD device=%x %x %x",
+			(FPW)addr[FLASH_ID2],
+			(FPW)addr[FLASH_ID3],
+			(FPW)addr[FLASH_ID4]);
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0x800000;
+		break;
+	}
+
+	/* Put FLASH back in read mode */
+	flash_reset(info);
+
+	return (info->size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int	flash_erase (flash_info_t *info, int s_first, int s_last)
+{
+	FPWV *addr;
+	int flag, prot, sect;
+	int intel = (info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL;
+	ulong start, now, last;
+	int rcode = 0;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		if (info->flash_id == FLASH_UNKNOWN) {
+			printf ("- missing\n");
+		} else {
+			printf ("- no sectors to erase\n");
+		}
+		return 1;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_AM160B:
+	case FLASH_AMLV640U:
+		break;
+	case FLASH_AMLV256U:
+		break;
+	case FLASH_28F128P30T:
+		break;
+    case FLASH_S29GL256N:
+        break;
+	case FLASH_UNKNOWN:
+	default:
+		printf ("Can't erase unknown flash type %08lx - aborted\n",
+			info->flash_id);
+		return 1;
+	}
+
+	prot = 0;
+	for (sect=s_first; sect<=s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n",
+			prot);
+	} else {
+		printf ("\n");
+	}
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect<=s_last && rcode == 0; sect++) {
+
+		if (info->protect[sect] != 0)	/*bmw           esteem192e     ispan         mx1fs2       RPXlite      tqm8540
+ protected, skip it */
+			continue;
+
+		printf ("Erasing sector %2d ... ", sect);
+        
+        if ( sect == s_first )
+        {
+		    addr = (FPWV *)(((info->start[sect]) & EVMDM355_CPLD_MASK) >> 14 );
+        }
+        else
+        { 
+            addr += 2;
+        }
+
+        EVMDM355_CPLD = addr; 
+
+		if (intel) {
+			*addr = (FPW)0x00600060; /* unlock block setup */
+			*addr = (FPW)0x00d000d0; /* unlock block confirm */
+			*addr = (FPW)0x00500050; /* clear status register */
+			*addr = (FPW)0x00200020; /* erase setup */
+			*addr = (FPW)0x00D000D0; /* erase confirm */
+			while((*addr & 0x80) == 0);
+			printf("done.\n");
+		}
+		else {
+			/* must be AMD style if not Intel */
+			FPWV *base;		/* first address in bank */
+
+			base = (FPWV *)(info->start[0]);
+			base[FLASH_CYCLE1] = (FPW)0x00AA00AA;	/* unlock */
+			base[FLASH_CYCLE2] = (FPW)0x00550055;	/* unlock */
+			base[FLASH_CYCLE1] = (FPW)0x00800080;	/* erase mode */
+			base[FLASH_CYCLE1] = (FPW)0x00AA00AA;	/* unlock */
+			base[FLASH_CYCLE2] = (FPW)0x00550055;	/* unlock */
+			base[0] = (FPW)0x00300030;	/* erase sector */
+			while (!(*((vHwdptr)base) & 0x80));
+			printf("done.\n");
+		}
+
+
+	}
+
+    EVMDM355_CPLD = 0; 
+	/* Put FLASH back in read mode */
+	flash_reset(info);
+
+	printf (" Erase Operation Completed.\n");
+	return rcode;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+int write_buff (flash_info_t *info, uchar *src, ulong addr, ulong cnt)
+{
+	FPW data = 0; /* 16 or 32 bit word, matches flash bus width on MPC8XX */
+	int bytes;	  /* number of bytes to program in current word		*/
+	int left;	  /* number of bytes left to program			*/
+	int res;
+	ulong cp, wp;
+	int count, i, l, rc, port_width;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		return 4;
+		}
+
+	/* get lower word aligned address */
+	wp = (addr & ~1);
+	port_width = 2;
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+		for (; i < port_width && cnt > 0; ++i) {
+			data = (data << 8) | *src++;
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < port_width; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+
+		if ((rc = write_word (info, wp, SWAP (data))) != 0) {
+			return (rc);
+		}
+		wp += port_width;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	count = 0;
+	while (cnt >= port_width) {
+		data = 0;
+		for (i = 0; i < port_width; ++i) {
+			data = (data << 8) | *src++;
+		}
+		if ((rc = write_word (info, wp, SWAP (data))) != 0) {
+			return (rc);
+		}
+		wp += port_width;
+		cnt -= port_width;
+
+		if (count++ > 0x800) {
+			spin_wheel ();
+			count = 0;
+		}
+	}
+
+	if (cnt == 0) {
+		return (0);
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < port_width && cnt > 0; ++i, ++cp) {
+		data = (data << 8) | *src++;
+		--cnt;
+	}
+	for (; i < port_width; ++i, ++cp) {
+		data = (data << 8) | (*(uchar *) cp);
+	}
+
+	return (write_word (info, wp, SWAP (data)));
+}
+
+/*-----------------------------------------------------------------------
+ * Write a word to Flash
+ * A word is 16 or 32 bits, whichever the bus width of the flash bank
+ * (not an individual chip) is.
+ *
+ * returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+static int write_word (flash_info_t *info, FPWV *plAddress, FPW ulData)
+{
+	ulong start;
+	int flag;
+	int res = 0;	/* result, assume success	*/
+	FPWV *base;		/* first address in flash bank	*/
+	volatile USHORT *psAddress;
+	volatile USHORT *address_cs;
+	USHORT tmp;
+	ULONG tmp_ptr;
+
+	// Lower WORD.
+	psAddress = (USHORT *)plAddress;
+	tmp_ptr  = (ULONG) plAddress;
+	address_cs = (USHORT *) (tmp_ptr & 0xFE000000);
+
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL)
+	{
+		*plAddress = (FPW)0x00400040;
+		*plAddress = ulData;
+		while ((*plAddress & 0x80) == 0);
+	}
+	else if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD)
+	{
+		*((vHwdptr)address_cs + 0x555) = ((Hwd)0xAA);
+		*((vHwdptr)address_cs + 0x2AA) = ((Hwd)0x55);
+		*((vHwdptr)address_cs + 0x555) = ((Hwd)0xA0);
+		*psAddress = ulData;
+		// Wait for ready.
+		while (1)
+		{
+			tmp = *psAddress; 
+			if( (tmp & 0x80)  == (ulData & 0x80)) 
+			{
+				break;
+			}
+			else
+			{
+				if(tmp & 0x20)             // Exceeded Time Limit
+			{
+				tmp = *psAddress; 
+				if( (tmp & 0x80)  == (ulData & 0x80)) 
+				{
+					break; 
+				}
+				else
+				{
+				  	flash_reset_sector(info, (ULONG) psAddress);
+			      	return 1;
+				}	
+			}
+			}
+		}
+	}
+
+	// Return to read mode
+	flash_reset_sector(info, (ULONG) psAddress);
+
+	// Verify the data.
+	if (*psAddress != ulData)
+	{
+     	return 1;
+	printf("Write of one 16-bit word failed\n");
+	}
+	return 0;
+}
+
+void inline spin_wheel (void)
+{
+	static int p = 0;
+	static char w[] = "\\/-";
+
+	printf ("\010%c", w[p]);
+	(++p == 3) ? (p = 0) : 0;
+}
+#endif
diff -Nurd u-boot-1.2.0/board/dm355_evm/flash_params.h u-boot-1.2.0-leopard/board/dm355_evm/flash_params.h
--- u-boot-1.2.0/board/dm355_evm/flash_params.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_evm/flash_params.h	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,319 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ *
+ */
+#ifndef _FLASH_PARAMSH_
+#define _FLASH_PARAMSH_
+//
+//Structs
+//
+typedef struct _PageInfo
+{
+    	ULONG	reserved;
+    	BYTE  	BlockReserved;
+    	BYTE  	BadBlockFlag;
+    	USHORT	reserved2;
+}PageInfo, *PPageInfo;
+
+typedef struct
+{
+	ULONG ReturnValue;
+	ULONG ReadAddress;
+	ULONG WriteAddress;
+	ULONG Size;
+} Download_Parms, *PDownload_Parms;
+
+#define NO_ERROR            0
+#define CORRECTED_ERROR     1
+#define ECC_ERROR           2
+#define UNCORRECTED_ERROR   3
+
+
+#define BIT0    0x00000001
+#define BIT1    0x00000002
+#define BIT2    0x00000004
+#define BIT3    0x00000008
+#define BIT4    0x00000010
+#define BIT5    0x00000020
+#define BIT6    0x00000040
+#define BIT7    0x00000080
+#define BIT8    0x00000100
+#define BIT9    0x00000200
+#define BIT10   0x00000400
+#define BIT11   0x00000800
+#define BIT12   0x00001000
+#define BIT13   0x00002000
+#define BIT14   0x00004000
+#define BIT15   0x00008000
+#define BIT16   0x00010000
+#define BIT17   0x00020000
+#define BIT18   0x00040000
+#define BIT19   0x00080000
+#define BIT20   0x00100000
+#define BIT21   0x00200000
+#define BIT22   0x00400000
+#define BIT23   0x00800000
+#define BIT24   0x01000000
+#define BIT25   0x02000000
+#define BIT26   0x04000000
+#define BIT27   0x08000000
+#define BIT28   0x10000000
+#define BIT29   0x20000000
+#define BIT30   0x40000000
+#define BIT31   0x80000000
+
+
+
+//  Status bit pattern
+#define STATUS_READY                0x40
+#define STATUS_ERROR                0x01
+//
+//NOR SUPPORT
+//
+// Flash ID Commands INTEL
+#define INTEL_ID_CMD       ((Hwd)0x0090)     	// INTEL ID CMD
+#define INTEL_MANF_ID      ((Hwd)0x0089)     	// INTEL Manf ID expected
+#define INTEL_DEVICE_8T    ((Hwd)0x88F1)     	// INTEL 8Mb top device code
+#define INTEL_DEVICE_8B    ((Hwd)0x88F2)     	// INTEL 8Mb bottom device code
+#define INTEL_DEVICE_16T   ((Hwd)0x88F3)     	// INTEL 16Mb top device code
+#define INTEL_DEVICE_16B   ((Hwd)0x88F4)     	// INTEL 16Mb bottom device code
+#define INTELS_J3_DEVICE_32   ((Hwd)0x0016)     // INTEL Strata J3 32Mb device code
+#define INTELS_J3_DEVICE_64   ((Hwd)0x0017)     // INTEL Strata J3 64Mb device code
+#define INTELS_J3_DEVICE_128  ((Hwd)0x0018)     // INTEL Strata J3 128Mb device code
+#define INTELS_K3_DEVICE_64   ((Hwd)0x8801)     // INTEL Strata K3 64Mb device code
+#define INTELS_K3_DEVICE_128  ((Hwd)0x8802)    	// INTEL Strata K3 128Mb device code
+#define INTELS_K3_DEVICE_256  ((Hwd)0x8803)     // INTEL Strata K3 256Mb device code
+#define INTELS_W18_DEVICE_128T  ((Hwd)0x8876)   // INTEL Wirless Flash Top 128 Mb device code
+#define INTELS_W18_DEVICE_128B  ((Hwd)0x8867)   // INTEL Wirless Flash Bottom 128 Mb device code
+#define INTELS_L18_DEVICE_128T  ((Hwd)0x880C)   // INTEL Wirless Flash Top 128 Mb device code
+#define INTELS_L18_DEVICE_128B  ((Hwd)0x880F)   // INTEL Wirless Flash Bottom 128 Mb device code
+#define INTELS_L18_DEVICE_256T  ((Hwd)0x880D)   // INTEL Wirless Flash Top 256 Mb device code
+#define INTELS_L18_DEVICE_256B  ((Hwd)0x8810)  	// INTEL Wirless Flash Bottom 256 Mb device code
+#define INTELS_K18_DEVICE_256B  ((Hwd)0x8807)  	// INTEL Wirless Flash Bottom 256 Mb device code
+#define AMD1_DEVICE_ID     ((Hwd)0x2253)   // AMD29DL323CB
+#define AMD2_DEVICE_ID     ((Hwd)0x2249)   // AMD29LV160D
+#define AMD3_DEVICE_ID1    ((Hwd)0x2212)   // AMD29LV256M
+#define AMD3_DEVICE_ID2    ((Hwd)0x2201)   // AMD29LV256M
+// Flash ID Commands FUJITSU (Programs like AMD)
+#define FUJITSU_MANF_ID    ((Hwd)0x04)        // Fujitsu Manf ID expected
+#define FUJITSU1_DEVICE_ID     ((Hwd)0x2253)  // MBM29DL323BD
+//Micron Programs Like Intel or Micron
+#define MICRON_MANF_ID      ((Hwd)0x002C)     	// MICRON Manf ID expected
+#define MICRON_MT28F_DEVICE_128T ((Hwd)0x4492)	// MICRON Flash device Bottom 128 Mb
+//Samsung Programs like AMD
+#define SAMSUNG_MANF_ID      	((Hwd)0x00EC)     	//SAMSUNG Manf ID expected
+#define SAMSUNG_K8S2815E_128T  	((Hwd) 0x22F8)  	//SAMSUNG NOR Flash device TOP 128 Mb
+// Flash Erase Commands AMD and FUJITSU
+// Flash ID Commands AMD
+#define AMD_ID_CMD0        ((Hwd)0xAA)     // AMD ID CMD 0
+#define AMD_CMD0_ADDR       0x555          // AMD CMD0 Offset
+#define AMD_ID_CMD1        ((Hwd)0x55)     // AMD ID CMD 1
+#define AMD_CMD1_ADDR	    0x2AA          // AMD CMD1 Offset
+#define AMD_ID_CMD2        ((Hwd)0x90)     // AMD ID CMD 2
+#define AMD_CMD2_ADDR	    0x555          // AMD CMD2 Offset
+#define AMD_MANF_ID        ((Hwd)0x01)     // AMD Manf ID expected
+#define AMD_DEVICE_ID_MULTI   ((Hwd)0x227E)// Indicates Multi-Address Device ID
+#define AMD_DEVICE_ID_OFFSET 0x1
+#define AMD_DEVICE_ID_OFFSET1 0x0E         // First Addr for Multi-Address ID
+#define AMD_DEVICE_ID_OFFSET2 0x0F         // Second Addr for Multi-Address ID
+#define AMD_DEVICE_RESET   ((Hwd)0x00F0)   // AMD Device Reset Command
+#define AMD_ERASE_CMD0    ((Hwd)0xAA)
+#define AMD_ERASE_CMD1    ((Hwd)0x55)
+#define AMD_ERASE_CMD2    ((Hwd)0x80)
+#define AMD_ERASE_CMD3    ((Hwd)0xAA)     	// AMD29LV017B Erase CMD 3
+#define AMD_ERASE_CMD4    ((Hwd)0x55)     	// AMD29LV017B Erase CMD 4
+#define AMD_ERASE_CMD5    ((Hwd)0x10)     	// AMD29LV017B Erase CMD 5
+#define AMD_ERASE_DONE    ((Hwd)0xFFFF)     // AMD29LV017B Erase Done
+#define AMD_ERASE_BLK_CMD0	((Hwd)0xAA)
+#define AMD_ERASE_BLK_CMD1	((Hwd)0x55)
+#define AMD_ERASE_BLK_CMD2	((Hwd)0x80)
+#define AMD_ERASE_BLK_CMD3	((Hwd)0xAA)
+#define AMD_ERASE_BLK_CMD4	((Hwd)0x55)
+#define AMD_ERASE_BLK_CMD5	((Hwd)0x30)
+#define AMD_PROG_CMD0    ((Hwd)0xAA)
+#define AMD_PROG_CMD1    ((Hwd)0x55)
+#define AMD_PROG_CMD2    ((Hwd)0xA0)
+#define AMD2_ERASE_CMD0    ((Hwd)0x00AA)     // AMD29DL800B Erase CMD 0
+#define AMD2_ERASE_CMD1    ((Hwd)0x0055)     // AMD29DL800B Erase CMD 1
+#define AMD2_ERASE_CMD2    ((Hwd)0x0080)     // AMD29DL800B Erase CMD 2
+#define AMD2_ERASE_CMD3    ((Hwd)0x00AA)     // AMD29DL800B Erase CMD 3
+#define AMD2_ERASE_CMD4    ((Hwd)0x0055)     // AMD29DL800B Erase CMD 4
+#define AMD2_ERASE_CMD5    ((Hwd)0x0030)     // AMD29DL800B Erase CMD 5
+#define AMD2_ERASE_DONE    ((Hwd)0x00FF)     // AMD29DL800B Erase Done
+#define AMD_WRT_BUF_LOAD_CMD0           ((Hwd)0xAA)
+#define AMD_WRT_BUF_LOAD_CMD1           ((Hwd)0x55)
+#define AMD_WRT_BUF_LOAD_CMD2           ((Hwd)0x25)
+#define AMD_WRT_BUF_CONF_CMD0           ((Hwd)0x29)
+#define AMD_WRT_BUF_ABORT_RESET_CMD0    ((Hwd)0xAA)
+#define AMD_WRT_BUF_ABORT_RESET_CMD1    ((Hwd)0x55)
+#define AMD_WRT_BUF_ABORT_RESET_CMD2    ((Hwd)0xF0)
+// Flash Erase Commands INTEL
+#define INTEL_ERASE_CMD0   ((Hwd)0x0020)     // INTEL Erase CMD 0
+#define INTEL_ERASE_CMD1   ((Hwd)0x00D0)     // INTEL Erase CMD 1
+#define INTEL_ERASE_DONE   ((Hwd)0x0080)     // INTEL Erase Done
+#define INTEL_READ_MODE    ((Hwd)0x00FF)     // INTEL Read Array Mode
+#define STRATA_READ        0x4
+#define STRATA_WRITE       0x8
+// Flash Block Information
+// Intel Burst devices:
+//   2MB each (8 8KB [param] and 31 64KB [main] blocks each) for 8MB total
+#define NUM_INTEL_BURST_BLOCKS 8
+#define PARAM_SET0  0
+#define MAIN_SET0   1
+#define PARAM_SET1  2
+#define MAIN_SET1   3
+#define PARAM_SET2  4
+#define MAIN_SET2   5
+#define PARAM_SET3  6
+#define MAIN_SET3   7
+// Intel Strata devices:
+//   4MB each (32 128KB blocks each) for 8MB total
+//   8MB each (64 128KB blocks each) for 16MB total
+//  16MB each (128 128KB blocks each) for 32MB total
+#define NUM_INTEL_STRATA_BLOCKS 8
+#define BLOCK_SET0  0
+#define BLOCK_SET1  1
+#define BLOCK_SET2  2
+#define BLOCK_SET3  3
+#define BLOCK_SET4  4
+#define BLOCK_SET5  5
+#define BLOCK_SET6  6
+#define BLOCK_SET7  7
+// For AMD Flash
+#define NUM_AMD_SECTORS 8  // Only using the first 8 8-KB sections (64 KB Total)
+#define AMD_ADDRESS_CS_MASK		0xFE000000	//--AMD-- Set-up as 0xFE000000 per Jon Hunter (Ti)
+// Flash Types
+enum NORFlashType {
+	FLASH_NOT_FOUND,
+	FLASH_UNSUPPORTED,
+	FLASH_AMD_LV017_2MB,             	// (AMD AM29LV017B-80RFC/RE)
+	FLASH_AMD_DL800_1MB_BOTTOM,		  	// (AMD AM29DL800BB-70EC)
+	FLASH_AMD_DL800_1MB_TOP,			// (AMD AM29DL800BT-70EC)
+	FLASH_AMD_DL323_4MB_BOTTOM,		  	// (AMD AM29DL323CB-70EC)
+	FLASH_AMD_DL323_4MB_TOP,			// (AMD AM29DL323BT-70EC)
+	FLASH_AMD_LV160_2MB_BOTTOM,
+	FLASH_AMD_LV160_2MB_TOP,
+	FLASH_AMD_LV256M_32MB,             	// (AMD AM29LV256MH/L)
+	FLASH_INTEL_BURST_8MB_BOTTOM,	   	// (Intel DT28F80F3B-95)
+	FLASH_INTEL_BURST_8MB_TOP,		   	// (Intel DT28F80F3T-95)
+	FLASH_INTEL_BURST_16MB_BOTTOM,	   	// (Intel DT28F160F3B-95)
+	FLASH_INTEL_BURST_16MB_TOP,		   	// (Intel DT28F160F3T-95)
+	FLASH_INTEL_STRATA_J3_4MB,		   	// (Intel DT28F320J3A)
+	FLASH_INTEL_STRATA_J3_8MB,		   	// (Intel DT28F640J3A)
+	FLASH_INTEL_STRATA_J3_16MB,		   	// (Intel DT28F128J3A)
+	FLASH_FUJITSU_DL323_4MB_BOTTOM,    	// (Fujitsu DL323 Bottom
+	FLASH_INTEL_STRATA_K3_8MB,		   	// (Intel 28F64K3C115)
+	FLASH_INTEL_STRATA_K3_16MB,        	// (Intel 28F128K3C115)
+	FLASH_INTEL_STRATA_K3_32MB,        	// (Intel 28F256K3C115)
+	FLASH_INTEL_W18_16MB_TOP,    		// (Intel 28F128W18T) }
+	FLASH_INTEL_W18_16MB_BOTTOM,  		// (Intel 28F128W18B) }
+	FLASH_INTEL_L18_16MB_TOP,    		// (Intel 28F128L18T) }
+	FLASH_INTEL_L18_16MB_BOTTOM,  		// (Intel 28F128L18B) }
+	FLASH_INTEL_L18_32MB_TOP,    		// (Intel 28F256L18T) }
+	FLASH_INTEL_L18_32MB_BOTTOM,  		// (Intel 28F256L18B) }
+	FLASH_INTEL_K18_32MB_BOTTOM,  		// (Intel 28F256K18B) }
+	FLASH_MICRON_16MB_TOP,				// (Micron MT28F160C34 )
+	FLASH_SAMSUNG_16MB_TOP				// (Samsung K8S281ETA)
+};
+////NAND SUPPORT
+//
+enum NANDFlashType {
+	NANDFLASH_NOT_FOUND,
+	NANDFLASH_SAMSUNG_32x8_Q,             	// (Samsung K9F5608Q0B)
+	NANDFLASH_SAMSUNG_32x8_U,             	// (Samsung K9F5608U0B)
+	NANDFLASH_SAMSUNG_16x16_Q,             	// (Samsung K9F5616Q0B)
+	NANDFLASH_SAMSUNG_16x16_U,             	// (Samsung K9F5616U0B)
+	NANDFLASH_SAMSUNG_16x8_U				// (Samsung K9F1G08QOM)
+};
+// Samsung Manufacture Code
+#define SAMSUNG_MANUFACT_ID	0xEC
+// Samsung Nand Flash Device ID
+#define SAMSUNG_K9F5608Q0B	0x35
+#define SAMSUNG_K9F5608U0B	0x75
+#define SAMSUNG_K9F5616Q0B	0x45
+#define SAMSUNG_K9F5616U0B	0x55
+//  MACROS for NAND Flash support
+//  Flash Chip Capability
+#define NUM_BLOCKS                  0x800       //  32 MB On-board NAND flash.
+#define PAGE_SIZE                 	512
+#define SPARE_SIZE                  16
+#define PAGES_PER_BLOCK             32
+#define PAGE_TO_BLOCK(page)     	((page) >> 5 )
+#define BLOCK_TO_PAGE(block)      	((block)  << 5 )
+#define FILE_TO_PAGE_SIZE(fs) 		((fs / PAGE_SIZE) + ((fs % PAGE_SIZE) ? 1 : 0))
+//  For flash chip that is bigger than 32 MB, we need to have 4 step address
+#ifdef NAND_SIZE_GT_32MB
+#define NEED_EXT_ADDR               1
+#else
+#define NEED_EXT_ADDR               0
+#endif
+// Nand flash block status definitions.
+#define BLOCK_STATUS_UNKNOWN	0x01
+#define BLOCK_STATUS_BAD		0x02
+#define BLOCK_STATUS_READONLY	0x04
+#define BLOCK_STATUS_RESERVED   0x08
+#define BLOCK_RESERVED			0x01
+#define BLOCK_READONLY			0x02
+#define BADBLOCKMARK            0x00
+//  NAND Flash Command. This appears to be generic across all NAND flash chips
+#define CMD_READ                0x00        //  Read
+#define CMD_READ1               0x01        //  Read1
+#define CMD_READ2               0x50        //  Read2
+#define CMD_READID              0x90        //  ReadID
+#define CMD_WRITE               0x80        //  Write phase 1
+#define CMD_WRITE2              0x10        //  Write phase 2
+#define CMD_ERASE               0x60        //  Erase phase 1
+#define CMD_ERASE2              0xd0        //  Erase phase 2
+#define CMD_STATUS              0x70        //  Status read
+#define CMD_RESET               0xff        //  Reset
+//
+//Prototpyes
+//
+// NOR Flash Dependent Function Pointers
+void (*User_Hard_Reset_Flash)(void);
+void (*User_Soft_Reset_Flash)(unsigned long addr);
+void (*User_Flash_Erase_Block)(unsigned long addr);
+void (*User_Flash_Erase_All)(unsigned long addr);
+void (*User_Flash_Write_Entry)(void);
+int (*User_Flash_Write)(unsigned long *addr, unsigned short data);
+int (*User_Flash_Optimized_Write)(unsigned long *addr, unsigned short data[], unsigned long);
+void (*User_Flash_Write_Exit)(void);
+// Flash AMD Device Dependent Routines
+void AMD_Hard_Reset_Flash(void);
+void AMD_Soft_Reset_Flash(unsigned long);
+void AMD_Flash_Erase_Block(unsigned long);
+void AMD_Flash_Erase_All(unsigned long);
+int AMD_Flash_Write(unsigned long *, unsigned short);
+int AMD_Flash_Optimized_Write(unsigned long *addr, unsigned short data[], unsigned long length);
+void AMD_Write_Buf_Abort_Reset_Flash( unsigned long plAddress );
+// Flash Intel Device Dependent Routines
+void INTEL_Hard_Reset_Flash(void);
+void INTEL_Soft_Reset_Flash(unsigned long addr);
+void INTEL_Flash_Erase_Block(unsigned long);
+int INTEL_Flash_Write(unsigned long *addr, unsigned short data);
+int INTEL_Flash_Optimized_Write(unsigned long *addr, unsigned short data[], unsigned long length);
+
+//General Functions
+void Flash_Do_Nothing(void);
+
+#endif
+
+
diff -Nurd u-boot-1.2.0/board/dm355_evm/lowlevel_init.S u-boot-1.2.0-leopard/board/dm355_evm/lowlevel_init.S
--- u-boot-1.2.0/board/dm355_evm/lowlevel_init.S	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_evm/lowlevel_init.S	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,766 @@
+/*
+ * Board specific setup info
+ *
+ * (C) Copyright 2003
+ * Texas Instruments, <www.ti.com>
+ * Kshitij Gupta <Kshitij@ti.com>
+ *
+ * Modified for OMAP 1610 H2 board by Nishant Kamat, Jan 2004
+ *
+ * Modified for OMAP 5912 OSK board by Rishi Bhattacharya, Apr 2004
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ * 
+ * Modified for DV-EVM board by Rishi Bhattacharya, Apr 2005
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * Modified for DV-EVM board by Swaminathan S, Nov 2005
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+#if defined(CONFIG_OMAP1610)
+#include <./configs/omap1510.h> 
+#endif
+
+_TEXT_BASE:
+	.word	TEXT_BASE	/* sdram load addr from config.mk */
+
+.global reset_cpu
+reset_cpu:
+	bl reset_processor
+
+
+.globl lowlevel_init
+lowlevel_init:
+	/*mov	pc,	lr*/
+	
+	/*------------------------------------------------------*
+	 * mask all IRQs by setting all bits in the EINT default *
+	 *------------------------------------------------------*/
+	mov	r1, #0x00000000
+	ldr	r0, =EINT_ENABLE0
+	str	r1, [r0]
+	ldr	r0, =EINT_ENABLE1
+	str	r1, [r0]
+
+	/*------------------------------------------------------*
+	 * Put the GEM in reset		    		  *
+ 	 *------------------------------------------------------*/
+
+      /* Put the GEM in reset */
+  	/* bhavinp: commented: No GEM in DM350*/	
+#if 0
+	LDR R8, PSC_GEM_FLAG_CLEAR
+	LDR R6, MDCTL_GEM
+	LDR R7, [R6]
+	AND R7, R7, R8
+	STR R7, [R6]
+
+	/* Enable the Power Domain Transition Command */
+	LDR R6, PTCMD_0
+	LDR R7, [R6]
+	ORR R7, R7, #0x2
+	STR R7, [R6]
+
+	/* Check for Transition Complete(PTSTAT) */
+checkStatClkStopGem:
+	LDR R6, PTSTAT_0
+	LDR R7, [R6]
+    	AND R7, R7, #0x2
+    	CMP R7, #0x0
+    	BNE checkStatClkStopGem
+
+	/* Check for GEM Reset Completion */
+checkGemStatClkStop:
+	LDR R6, MDSTAT_GEM
+	LDR R7, [R6]
+    	AND R7, R7, #0x100
+    	CMP R7, #0x0
+    	BNE checkGemStatClkStop
+
+	/* Do this for enabling a WDT initiated reset this is a workaround
+	   for a chip bug.  Not required under normal situations */
+	LDR R6, P1394
+	MOV R10, #0x0	
+	STR R10, [R6]
+#endif 	//bhavinp: commented: End
+	/*------------------------------------------------------*
+	 * Enable L1 & L2 Memories in Fast mode                 *
+	 *------------------------------------------------------*/
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x1
+	STR R10, [R6]
+
+	LDR R6, MMARG_BRF0
+	LDR R10, MMARG_BRF0_VAL
+	STR R10, [R6]
+
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x0
+	STR R10, [R6]
+	/*------------------------------------------------------*
+	 * DDR2 PLL Intialization			    	*
+ 	 *------------------------------------------------------*/
+	
+      /* Select the Clock Mode Depending on the Value written in the Boot Table by the run script */
+	MOV R10, #0x0
+	LDR R6, PLL2_CTL   
+	LDR R7, PLL_CLKSRC_MASK
+	LDR R8, [R6]
+	AND R8, R8, R7
+	MOV R9, R10, LSL #0x8
+	ORR R8, R8, R9
+	STR R8, [R6]
+	
+	/* Select the PLLEN source */
+	LDR R7, PLL_ENSRC_MASK
+	AND R8, R8, R7
+	STR R8, [R6]
+	
+	/* Bypass the PLL */
+	LDR R7, PLL_BYPASS_MASK
+	AND R8, R8, R7
+	STR R8, [R6]
+	
+	/* Wait for few cycles to allow PLLEN Mux switches properly to bypass Clock */
+	MOV R10, #0x20 
+WaitPPL2Loop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE WaitPPL2Loop	
+
+     /* Reset the PLL */
+    	LDR R7, PLL_RESET_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+     /* Power up the PLL */
+    	LDR R7, PLL_PWRUP_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+     /* Enable the PLL from Disable Mode */
+    	LDR R7, PLL_DISABLE_ENABLE_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+	/* Program the PLL Multiplier */
+	LDR R6, PLL2_PLLM
+	/*MOV R2, #0x13 Orig value */
+	/*MOV R2, #0xB 165MHz */
+	/*MOV R2, #0xD 189 MHz */
+	MOV R2, #0x17 /* 162 MHz */
+	STR R2, [R6]   /* R2 */
+
+	/* Program the PLL2 Divisior Value */
+	LDR R6, PLL2_DIV2
+	MOV R3, #0x1 /* Orig */
+	/*MOV R3, #0x0*/
+	STR R3, [R6]    /* R3 */
+
+	/* Program the PLL2 Divisior Value */
+	LDR R6, PLL2_DIV1
+	/*MOV R4, #0x9 Orig */
+	/*MOV R4, #0x5 165MHz */
+	/*MOV R4, #0x6 189 MHz */
+	MOV R4, #0xB /* 54 MHz */
+	STR R4, [R6]    /* R4 */
+
+      /* PLL2 DIV1 MMR */
+	LDR R8, PLL2_DIV_MASK
+	LDR R6, PLL2_DIV2
+	LDR R9, [R6]
+	AND R8, R8, R9
+	MOV R9, #0X1
+	MOV R9, R9, LSL #15
+	ORR R8, R8, R9
+	STR R8, [R6]
+
+	/* Program the GOSET bit to take new divier values */
+	LDR R6, PLL2_PLLCMD
+	LDR R7, [R6]
+	ORR R7, R7, #0x1
+	STR R7, [R6]
+
+      /* Wait for Done */
+    	LDR R6, PLL2_PLLSTAT
+doneLoop_0:    
+    	LDR R7, [R6]
+    	AND R7, R7, #0x1
+    	CMP R7, #0x0
+    	BNE doneLoop_0
+
+      /* PLL2 DIV2 MMR */
+	LDR R8, PLL2_DIV_MASK
+	LDR R6, PLL2_DIV1
+	LDR R9, [R6]
+	AND R8, R8, R9
+	MOV R9, #0X1
+	MOV R9, R9, LSL #15
+	ORR R8, R8, R9
+	STR R8, [R6]
+
+	/* Program the GOSET bit to take new divier values */
+	LDR R6, PLL2_PLLCMD
+	LDR R7, [R6]
+	ORR R7, R7, #0x1
+	STR R7, [R6]
+
+     /* Wait for Done */
+    	LDR R6, PLL2_PLLSTAT
+doneLoop:    
+    	LDR R7, [R6]
+    	AND R7, R7, #0x1
+    	CMP R7, #0x0
+    	BNE doneLoop
+    				
+	/* Wait for PLL to Reset Properly */
+	MOV R10, #0x218  
+ResetPPL2Loop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE ResetPPL2Loop
+    
+    	/* Bring PLL out of Reset */
+    	LDR R6, PLL2_CTL    	
+    	LDR R8, [R6]
+    	ORR R8, R8, #0x08
+    	STR R8, [R6]
+     	
+     /* Wait for PLL to Lock */
+	LDR R10, PLL_LOCK_COUNT    
+PLL2Lock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE PLL2Lock
+    
+     /* Enable the PLL */
+    	LDR R6, PLL2_CTL    	
+    	LDR R8, [R6]
+    	ORR R8, R8, #0x01
+    	STR R8, [R6]
+
+	/*------------------------------------------------------*
+	 * Issue Soft Reset to DDR Module		    		  *
+ 	 *------------------------------------------------------*/
+
+      /* Shut down the DDR2 LPSC Module */
+  	LDR R8, PSC_FLAG_CLEAR
+	LDR R6, MDCTL_DDR2_0
+	LDR R7, [R6]
+	AND R7, R7, R8
+	ORR R7, R7, #0x3
+	STR R7, [R6]  
+
+	/* Enable the Power Domain Transition Command */
+	LDR R6, PTCMD_0
+	LDR R7, [R6]
+	ORR R7, R7, #0x1
+	STR R7, [R6]    
+	
+	/* Check for Transition Complete(PTSTAT) */
+checkStatClkStop:	
+	LDR R6, PTSTAT_0
+	LDR R7, [R6]
+    	AND R7, R7, #0x1	
+    	CMP R7, #0x0
+    	BNE checkStatClkStop  
+    
+	/* Check for DDR2 Controller Enable Completion */
+checkDDRStatClkStop:	
+	LDR R6, MDSTAT_DDR2_0
+	LDR R7, [R6]
+    	AND R7, R7, #0x1F	
+    	CMP R7, #0x3
+    	BNE checkDDRStatClkStop  
+
+	/*------------------------------------------------------*
+	 * Program DDR2 MMRs for 162MHz Setting	    		  *
+ 	 *------------------------------------------------------*/
+	
+	/* Program PHY Control Register */
+	LDR R6, DDRCTL
+	LDR R7, DDRCTL_VAL
+	STR R7, [R6]
+
+	/* Program SDRAM Bank Config Register */
+	LDR R6, SDCFG
+	LDR R7, SDCFG_VAL
+	STR R7, [R6]
+
+	/* Program SDRAM TIM-0 Config Register */
+	LDR R6, SDTIM0
+	LDR R7, SDTIM0_VAL_162MHz
+	STR R7, [R6]		
+
+	/* Program SDRAM TIM-1 Config Register */
+	LDR R6, SDTIM1
+	LDR R7, SDTIM1_VAL_162MHz
+	STR R7, [R6]		
+
+	/* Program the SDRAM Bang Config Control Register */
+	LDR R10, MASK_VAL
+	LDR R8, SDCFG
+	LDR R9, SDCFG_VAL
+	AND R9, R9, R10
+	STR R9, [R8]
+
+	/* Program SDRAM TIM-1 Config Register */
+	LDR R6, SDREF
+	LDR R7, SDREF_VAL
+	STR R7, [R6]		
+
+        /*------------------------------------------------------*
+         * Issue Soft Reset to DDR Module                                 *
+         *------------------------------------------------------*/
+                                                                                
+        /* Issue a Dummy DDR2 read/write */
+        LDR R8, DDR2_VAL
+        LDR R7, DUMMY_VAL
+        STR R7, [R8]
+        LDR R7, [R8]
+                                                                                
+      /* Shut down the DDR2 LPSC Module */
+        LDR R8, PSC_FLAG_CLEAR
+        LDR R6, MDCTL_DDR2_0
+        LDR R7, [R6]
+        AND R7, R7, R8
+        ORR R7, R7, #0x1
+        STR R7, [R6]
+                                                                                
+        /* Enable the Power Domain Transition Command */
+        LDR R6, PTCMD_0
+        LDR R7, [R6]
+        ORR R7, R7, #0x1
+        STR R7, [R6]
+                                                                                
+        /* Check for Transition Complete(PTSTAT) */
+checkStatClkStop2:
+        LDR R6, PTSTAT_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1
+        CMP R7, #0x0
+        BNE checkStatClkStop2
+                                                                                
+        /* Check for DDR2 Controller Enable Completion */
+checkDDRStatClkStop2:
+        LDR R6, MDSTAT_DDR2_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1F
+        CMP R7, #0x1
+        BNE checkDDRStatClkStop2
+
+        /*------------------------------------------------------*
+         * Turn DDR2 Controller Clocks On                                 *
+         *------------------------------------------------------*/
+                                                                                
+     /* Enable the DDR2 LPSC Module */
+        LDR R6, MDCTL_DDR2_0
+        LDR R7, [R6]
+        ORR R7, R7, #0x3
+        STR R7, [R6]
+                                                                                
+        /* Enable the Power Domain Transition Command */
+        LDR R6, PTCMD_0
+        LDR R7, [R6]
+        ORR R7, R7, #0x1
+        STR R7, [R6]
+                                                                                
+        /* Check for Transition Complete(PTSTAT) */
+checkStatClkEn2:
+        LDR R6, PTSTAT_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1
+        CMP R7, #0x0
+        BNE checkStatClkEn2
+                                                                                
+        /* Check for DDR2 Controller Enable Completion */
+checkDDRStatClkEn2:
+        LDR R6, MDSTAT_DDR2_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1F
+        CMP R7, #0x3
+        BNE checkDDRStatClkEn2
+                                                                                
+        /*  DDR Writes and Reads */
+        LDR R6, CFGTEST
+        MOV R3, #0x1
+        STR R3, [R6]    /* R3 */
+
+	/*------------------------------------------------------*
+	 * System PLL Intialization			    		  *
+ 	 *------------------------------------------------------*/
+
+      /* Select the Clock Mode Depending on the Value written in the Boot Table by the run script */
+	MOV R2, #0x0
+	LDR R6, PLL1_CTL   
+	LDR R7, PLL_CLKSRC_MASK
+	LDR R8, [R6]
+	AND R8, R8, R7
+	MOV R9, R2, LSL #0x8
+	ORR R8, R8, R9
+	STR R8, [R6]
+	
+	/* Select the PLLEN source */
+	LDR R7, PLL_ENSRC_MASK
+	AND R8, R8, R7
+	STR R8, [R6]
+	
+	/* Bypass the PLL */
+	LDR R7, PLL_BYPASS_MASK
+	AND R8, R8, R7
+	STR R8, [R6]
+	
+	/* Wait for few cycles to allow PLLEN Mux switches properly to bypass Clock */
+	MOV R10, #0x20 
+
+WaitLoop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE WaitLoop	
+
+     /* Reset the PLL */
+    	LDR R7, PLL_RESET_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+      /* Disable the PLL */
+    	ORR R8, R8, #0x10    
+    	STR R8, [R6]
+
+      /* Power up the PLL */
+    	LDR R7, PLL_PWRUP_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+      /* Enable the PLL from Disable Mode */
+    	LDR R7, PLL_DISABLE_ENABLE_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+	/* Program the PLL Multiplier */
+	LDR R6, PLL1_PLLM
+	/*MOV R3, #0x10  As per Amit, PLL should be in normal mode i.e X by 16 */
+	/*MOV R3, #0x11  As per Ebby 486 MHz */
+	/*MOV R3, #0x14  For 567MHz */
+	MOV R3, #0x15 /* For 594MHz */
+	STR R3, [R6]      
+
+	/* Wait for PLL to Reset Properly */
+	MOV R10, #0xFF 
+
+ResetLoop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE ResetLoop
+    
+      /* Bring PLL out of Reset */
+    	LDR R6, PLL1_CTL    	
+    	ORR R8, R8, #0x08
+    	STR R8, [R6]
+     	
+      /* Wait for PLL to Lock */
+	LDR R10, PLL_LOCK_COUNT    
+
+PLL1Lock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE PLL1Lock
+    
+      /* Enable the PLL */
+    	ORR R8, R8, #0x01
+    	STR R8, [R6]
+
+	nop
+	nop	
+	nop
+	nop
+
+	/*------------------------------------------------------*
+	 * AEMIF configuration for NOR Flash (double check)     *
+	 *------------------------------------------------------*/
+	LDR R0, _PINMUX0
+	LDR R1, _DEV_SETTING
+	STR R1, [R0]
+
+ 	LDR R0, WAITCFG   
+	LDR R1, WAITCFG_VAL 
+	LDR R2, [R0]
+	ORR R2, R2, R1
+	STR R2, [R0]    
+
+	LDR R0, ACFG3
+	LDR R1, ACFG3_VAL
+	LDR R2, [R0]
+	AND R1, R2, R1
+	STR R1, [R0]
+
+	LDR R0, ACFG4
+	LDR R1, ACFG4_VAL
+	LDR R2, [R0]
+	AND R1, R2, R1
+	STR R1, [R0]
+
+	LDR R0, ACFG5
+	LDR R1, ACFG5_VAL
+	LDR R2, [R0]
+	AND R1, R2, R1
+	STR R1, [R0]     
+
+	/*--------------------------------------*
+	 * VTP manual Calibration               *
+	 *--------------------------------------*/
+	LDR R0, VTPIOCR
+	LDR R1, VTP_MMR0
+	STR R1, [R0]
+
+	LDR R0, VTPIOCR
+	LDR R1, VTP_MMR1
+	STR R1, [R0]
+	
+     /* Wait for 33 VTP CLK cycles.  VRP operates at 27 MHz */
+	LDR R10, VTP_LOCK_COUNT    
+VTPLock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE VTPLock
+
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x1
+	STR R10, [R6]
+
+	LDR R6, DDRVTPR
+	LDR R7, [R6]
+	AND R7, R7, #0x1F
+	AND R8, R7, #0x3E0
+	ORR R8, R7, R8
+	LDR R7, VTP_RECAL
+	ORR R8, R7, R8
+	LDR R7, VTP_EN
+	ORR R8, R7, R8
+	STR R8, [R0]
+
+
+     /* Wait for 33 VTP CLK cycles.  VRP operates at 27 MHz */
+	LDR R10, VTP_LOCK_COUNT    
+VTP1Lock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE VTP1Lock
+
+	LDR R1, [R0]
+	LDR R2, VTP_MASK
+	AND R2, R1, R2
+	STR R2, [R0]
+
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x0
+	STR R10, [R6]
+
+
+	/* Start MPU Timer 1 */
+/*	MOV R10, #0x1AFFFFFF
+
+WaitRam:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE WaitRam
+*/
+
+	/* back to arch calling code */
+	mov	pc,	lr
+
+	/* the literal pools origin */
+	.ltorg
+
+REG_TC_EMIFS_CONFIG:		/* 32 bits */
+	.word 0xfffecc0c
+REG_TC_EMIFS_CS0_CONFIG:	/* 32 bits */
+	.word 0xfffecc10
+REG_TC_EMIFS_CS1_CONFIG:	/* 32 bits */
+	.word 0xfffecc14
+REG_TC_EMIFS_CS2_CONFIG:	/* 32 bits */
+	.word 0xfffecc18
+REG_TC_EMIFS_CS3_CONFIG:	/* 32 bits */
+	.word 0xfffecc1c
+
+_PINMUX0:		.word 0x01C40000		/* Device Configuration Registers */
+_PINMUX1:		.word 0x01C40004		/* Device Configuration Registers */
+
+_DEV_SETTING:		.word 0x00000C1F
+
+AEMIF_BASE_ADDR:	.word 0x01E10000
+WAITCFG:         	.word 0x01E10004
+ACFG2:           	.word 0x01E10010
+ACFG3:           	.word 0x01E10014
+ACFG4:           	.word 0x01E10018
+ACFG5:           	.word 0x01E1001C
+
+WAITCFG_VAL:     	.word 0x0
+ACFG2_VAL:       	.word 0x3FFFFFFD
+ACFG3_VAL:       	.word 0x3FFFFFFD
+ACFG4_VAL:       	.word 0x3FFFFFFD
+ACFG5_VAL:       	.word 0x3FFFFFFD
+
+MDCTL_DDR2:		.word 0x01C41A34
+PTCMD:		.word 0x01C41120
+PTSTAT:		.word 0x01C41128
+MDSTAT_DDR2:	.word 0x01C41834
+
+MDCTL_TPCC:		.word	0x01C41A08
+MDSTAT_TPCC:	.word 0x01C41808
+
+MDCTL_TPTC0:	.word	0x01C41A0C
+MDSTAT_TPTC0:	.word 0x01C4180C
+
+MDCTL_TPTC1:	.word	0x01C41A10
+MDSTAT_TPTC1:	.word 0x01C41810
+
+DDR2DEBUG:		.word 0x8FFFF000
+
+/* EINT0 register */
+EINT_ENABLE0:
+	.word 0x01c48018
+
+/* EINT1 register */
+EINT_ENABLE1:
+	.word 0x01c4801C
+
+CLEAR_FLAG:				.word 0xFFFFFFFF
+EDMA_PARAM0_D_S_BIDX_VAL: 	.word 0x00010001
+PSC_FLAG_CLEAR:			.word 0xFFFFFFE0
+PSC_GEM_FLAG_CLEAR:			.word 0xFFFFFEFF
+MDCTL_TPCC_SYNC:			.word 0x01C41A08
+MDSTAT_TPCC_SYNC:			.word 0x01C41808
+
+MDCTL_TPTC0_SYNC:			.word 0x01C41A0C
+MDSTAT_TPTC0_SYNC:		.word 0x01C4180C
+
+MDCTL_TPTC1_SYNC:			.word 0x01C41A10
+MDSTAT_TPTC1_SYNC:		.word 0x01C41810
+
+PTCMD_SYNC:				.word 0x01C41120
+PTSTAT_SYNC:			.word 0x01C41128
+DATA_MAX:				.word 0x0000FFFF
+SPIN_ADDR:				.word 0x00003FFC   /* ARM PC value(B $) for the DSP Test cases */
+SPIN_OPCODE:			.word 0xEAFFFFFE
+
+/* Interrupt Clear Register */
+FIQ0_CLEAR:				.word 0x01C48000
+FIQ1_CLEAR:				.word 0x01C48004
+IRQ0_CLEAR:				.word 0x01C48008
+IRQ1_CLEAR:				.word 0x01C4800C
+
+/* DDR2 MMR & CONFIGURATION VALUES for 75 MHZ */
+DDRCTL:				.word	0x200000E4
+SDREF:				.word	0x2000000C
+SDCFG:				.word	0x20000008
+SDTIM0:				.word	0x20000010
+SDTIM1:				.word	0x20000014
+SDSTAT:				.word 0x20000004
+VTPIOCR:				.word 0x200000F0  /* VTP IO Control register */
+DDRVTPR:				.word 0x01C42030  /* DDR VPTR MMR */
+DFT_ENABLE:				.word 0x01C4004C
+VTP_MMR0:				.word 0x201F
+VTP_MMR1:				.word 0xA01F
+PCH_MASK:				.word 0x3E0
+VTP_LOCK_COUNT:				.word 0x5b0
+VTP_MASK:				.word 0xFFFFDFFF
+VTP_RECAL:				.word 0x40000
+VTP_EN:					.word 0x02000
+
+
+CFGTEST:				.word	0x80010000
+
+/* original values					
+DDRCTL_VAL:				.word	0x50006405
+SDCFG_VAL:				.word	0x00008832
+MASK_VAL:                    	.word 0x00000FFF
+SDTIM0_VAL_135MHz:		.word	0x30923A91
+SDTIM1_VAL_135MHz:		.word	0x0019c722
+SDREF_VAL:				.word 0x000005c3
+*/
+
+/* 162MHz as per GEL file for DVEVM with Micron DDR2 SDRAM */
+DDRCTL_VAL:                     .word   0x50006405
+SDCFG_VAL:                      .word   0x00178632           /* CL=3 for MT47H64M16BT-5E */
+MASK_VAL:                       .word   0xFFFF7FFF
+SDTIM0_VAL_162MHz:              .word   0x28923211
+SDTIM1_VAL_162MHz:              .word   0x0016c722
+SDREF_VAL:                      .word   0x000004F0
+
+/* GEM Power Up & LPSC Control Register */
+CHP_SHRTSW:				.word 0x01C40038
+
+PD1_CTL:				.word	0x01C41304
+EPCPR:				.word	0x01C41070
+EPCCR:				.word	0x01C41078
+MDCTL_GEM:				.word	0x01C41A9C
+MDSTAT_GEM:				.word 0x01C4189C
+MDCTL_IMCOP:			.word	0x01C41AA0
+MDSTAT_IMCOP:			.word 0x01C418A0
+
+PTCMD_0:				.word 0x01C41120
+PTSTAT_0:				.word 0x01C41128
+P1394:					.word 0x01C41a20
+
+PLL_CLKSRC_MASK: 			.word 0xFFFFFEFF  /* Mask the Clock Mode bit and it is programmble through the run script */
+PLL_ENSRC_MASK:  			.word 0xFFFFFFDF  /* Select the PLLEN source */
+PLL_BYPASS_MASK: 			.word 0xFFFFFFFE  /* Put the PLL in BYPASS, eventhough the device */
+PLL_RESET_MASK:  			.word 0xFFFFFFF7  /* Put the PLL in Reset Mode */
+PLL_PWRUP_MASK:  			.word 0xFFFFFFFD  /* PLL Power up Mask Bit  */
+PLL_DISABLE_ENABLE_MASK:	.word 0xFFFFFFEF  /* Enable the PLL from Disable */
+PLL_LOCK_COUNT:          	.word 0x2000
+
+/* PLL1-SYSTEM PLL MMRs */
+PLL1_CTL:				.word 0x01C40900 
+PLL1_PLLM:				.word 0x01C40910
+
+/* PLL2-SYSTEM PLL MMRs */
+PLL2_CTL:				.word 0x01C40D00 
+PLL2_PLLM:				.word 0x01C40D10
+PLL2_DIV2:				.word 0x01C40D1C
+PLL2_DIV1:				.word 0x01C40D18
+PLL2_PLLCMD:			.word 0x01C40D38
+PLL2_PLLSTAT:			.word 0x01C40D3C	
+PLL2_BPDIV:				.word 0x01C40D2C
+PLL2_DIV_MASK:			.word 0xFFFF7FFF
+
+
+MDCTL_DDR2_0:			.word 0x01C41A34
+MDSTAT_DDR2_0:			.word 0x01C41834
+DLLPWRUPMASK:			.word 0xFFFFFFEF
+DDR2_ADDR:			.word 0x80000000
+
+DFT_BASEADDR:			.word 0x01C42000
+MMARG_BRF0:			.word 0x01C42010     /* BRF margin mode 0     (Read / write)*/
+MMARG_G10:			.word 0x01C42018     /*GL margin mode 0      (Read / write)*/
+MMARG_BRF0_VAL:			.word 0x00444400
+DDR2_VAL:			.word 0x80000000
+DUMMY_VAL:			.word 0xA55AA55A
+
+/* command values */
+.equ CMD_SDRAM_NOP,		0x00000000
+.equ CMD_SDRAM_PRECHARGE,	0x00000001
+.equ CMD_SDRAM_AUTOREFRESH,	0x00000002
+.equ CMD_SDRAM_CKE_SET_HIGH,	0x00000007
diff -Nurd u-boot-1.2.0/board/dm355_evm/nand.c u-boot-1.2.0-leopard/board/dm355_evm/nand.c
--- u-boot-1.2.0/board/dm355_evm/nand.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_evm/nand.c	2008-01-05 03:44:03.000000000 -0300
@@ -0,0 +1,805 @@
+/*
+ * NAND driver for TI DaVinci based boards.
+ *
+ * Copyright (C) 2007 Sergey Kubushyn <ksi@koi8.net>
+ *
+ * Based on Linux DaVinci NAND driver by TI. Original copyright follows:
+ */
+
+/*
+ *
+ * linux/drivers/mtd/nand/nand_dm355.c
+ *
+ * NAND Flash Driver
+ *
+ * Copyright (C) 2006 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ *
+ *  Overview:
+ *   This is a device driver for the NAND flash device found on the
+ *   DaVinci board which utilizes the Samsung k9k2g08 part.
+ *
+ Modifications:
+ ver. 1.0: Feb 2005, Vinod/Sudhakar
+ -
+ *
+ */
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+#if !defined(CFG_NAND_LEGACY)
+
+#include <asm/arch/types.h>
+//#include "soc.h"
+#include <nand.h>
+#include <asm/arch/nand_defs.h>
+#include <asm/arch/emif_defs.h>
+
+#define NAND_Ecc_P1e            (1 << 0)
+#define NAND_Ecc_P2e            (1 << 1)
+#define NAND_Ecc_P4e            (1 << 2)
+#define NAND_Ecc_P8e            (1 << 3)
+#define NAND_Ecc_P16e           (1 << 4)
+#define NAND_Ecc_P32e           (1 << 5)
+#define NAND_Ecc_P64e           (1 << 6)
+#define NAND_Ecc_P128e          (1 << 7)
+#define NAND_Ecc_P256e          (1 << 8)
+#define NAND_Ecc_P512e          (1 << 9)
+#define NAND_Ecc_P1024e         (1 << 10)
+#define NAND_Ecc_P2048e         (1 << 11)
+
+#define NAND_Ecc_P1o            (1 << 16)
+#define NAND_Ecc_P2o            (1 << 17)
+#define NAND_Ecc_P4o            (1 << 18)
+#define NAND_Ecc_P8o            (1 << 19)
+#define NAND_Ecc_P16o           (1 << 20)
+#define NAND_Ecc_P32o           (1 << 21)
+#define NAND_Ecc_P64o           (1 << 22)
+#define NAND_Ecc_P128o          (1 << 23)
+#define NAND_Ecc_P256o          (1 << 24)
+#define NAND_Ecc_P512o          (1 << 25)
+#define NAND_Ecc_P1024o         (1 << 26)
+#define NAND_Ecc_P2048o         (1 << 27)
+
+#define TF(value)       (value ? 1 : 0)
+
+#define P2048e(a)       (TF(a & NAND_Ecc_P2048e)        << 0 )
+#define P2048o(a)       (TF(a & NAND_Ecc_P2048o)        << 1 )
+#define P1e(a)          (TF(a & NAND_Ecc_P1e)           << 2 )
+#define P1o(a)          (TF(a & NAND_Ecc_P1o)           << 3 )
+#define P2e(a)          (TF(a & NAND_Ecc_P2e)           << 4 )
+#define P2o(a)          (TF(a & NAND_Ecc_P2o)           << 5 )
+#define P4e(a)          (TF(a & NAND_Ecc_P4e)           << 6 )
+#define P4o(a)          (TF(a & NAND_Ecc_P4o)           << 7 )
+
+#define P8e(a)          (TF(a & NAND_Ecc_P8e)           << 0 )
+#define P8o(a)          (TF(a & NAND_Ecc_P8o)           << 1 )
+#define P16e(a)         (TF(a & NAND_Ecc_P16e)          << 2 )
+#define P16o(a)         (TF(a & NAND_Ecc_P16o)          << 3 )
+#define P32e(a)         (TF(a & NAND_Ecc_P32e)          << 4 )
+#define P32o(a)         (TF(a & NAND_Ecc_P32o)          << 5 )
+#define P64e(a)         (TF(a & NAND_Ecc_P64e)          << 6 )
+#define P64o(a)         (TF(a & NAND_Ecc_P64o)          << 7 )
+
+#define P128e(a)        (TF(a & NAND_Ecc_P128e)         << 0 )
+#define P128o(a)        (TF(a & NAND_Ecc_P128o)         << 1 )
+#define P256e(a)        (TF(a & NAND_Ecc_P256e)         << 2 )
+#define P256o(a)        (TF(a & NAND_Ecc_P256o)         << 3 )
+#define P512e(a)        (TF(a & NAND_Ecc_P512e)         << 4 )
+#define P512o(a)        (TF(a & NAND_Ecc_P512o)         << 5 )
+#define P1024e(a)       (TF(a & NAND_Ecc_P1024e)        << 6 )
+#define P1024o(a)       (TF(a & NAND_Ecc_P1024o)        << 7 )
+
+#define P8e_s(a)        (TF(a & NAND_Ecc_P8e)           << 0 )
+#define P8o_s(a)        (TF(a & NAND_Ecc_P8o)           << 1 )
+#define P16e_s(a)       (TF(a & NAND_Ecc_P16e)          << 2 )
+#define P16o_s(a)       (TF(a & NAND_Ecc_P16o)          << 3 )
+#define P1e_s(a)        (TF(a & NAND_Ecc_P1e)           << 4 )
+#define P1o_s(a)        (TF(a & NAND_Ecc_P1o)           << 5 )
+#define P2e_s(a)        (TF(a & NAND_Ecc_P2e)           << 6 )
+#define P2o_s(a)        (TF(a & NAND_Ecc_P2o)           << 7 )
+
+#define P4e_s(a)        (TF(a & NAND_Ecc_P4e)           << 0 )
+#define P4o_s(a)        (TF(a & NAND_Ecc_P4o)           << 1 )
+
+#define CSL_EMIF_1_REGS    0x01E10000
+
+#define NAND4BITECCLOAD		(0x01E10000 +0xBC)
+#define NAND4BITECC1        (0x01E10000 +0xC0)
+#define NAND4BITECC2        (0x01E10000 +0xC4) 
+#define NAND4BITECC3        (0x01E10000 +0xC8)
+#define NAND4BITECC4        (0x01E10000 +0xCC)
+
+#define NANDERRADD1		    (0x01E10000 +0xD0)
+#define NANDERRADD2		    (0x01E10000 +0xD4)
+#define NANDERRVAL1		    (0x01E10000 +0xD8)
+#define NANDERRVAL2		    (0x01E10000 +0xDC)
+
+/* Definitions for 4-bit hardware ECC */
+#define NAND_4BITECC_MASK		0x03FF03FF
+#define EMIF_NANDFSR_ECC_STATE_MASK  	0x00000F00
+#define ECC_STATE_NO_ERR		0x0
+#define ECC_STATE_TOO_MANY_ERRS		0x1
+#define ECC_STATE_ERR_CORR_COMP_P	0x2
+#define ECC_STATE_ERR_CORR_COMP_N	0x3
+#define ECC_MAX_CORRECTABLE_ERRORS	0x4
+extern struct nand_chip nand_dev_desc[CFG_MAX_NAND_DEVICE];
+
+static void nand_dm350evm_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+	struct		nand_chip *this = mtd->priv;
+	u_int32_t	IO_ADDR_W = (u_int32_t)this->IO_ADDR_W;
+	u_int32_t	IO_ADDR_R = (u_int32_t)this->IO_ADDR_R;
+
+	IO_ADDR_W &= ~(MASK_ALE|MASK_CLE);
+
+	switch (cmd) {
+		case NAND_CTL_SETCLE:
+			IO_ADDR_W |= MASK_CLE;
+			break;
+		case NAND_CTL_SETALE:
+			IO_ADDR_W |= MASK_ALE;
+			break;
+	}
+
+	this->IO_ADDR_W = (void *)IO_ADDR_W;
+}
+
+static int nand_dm350evm_dev_ready(struct mtd_info *mtd)
+{
+	emifregs	emif_addr = (emifregs)CSL_EMIF_1_REGS;
+
+	return(emif_addr->NANDFSR) /*& 0x1)*/;
+}
+
+static int nand_dm350evm_waitfunc(struct mtd_info *mtd, struct nand_chip *this, int state)
+{
+	while(!nand_dm350evm_dev_ready(mtd)) {;}
+	*NAND_CE0CLE = NAND_STATUS;
+	return(*NAND_CE0DATA);
+}
+
+static void nand_dm355evm_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+        emifregs    emif_addr;
+
+	    emif_addr = (emifregs)CSL_EMIF_1_REGS;
+        emif_addr->NANDFCR |= (1 << 8);
+}
+
+static u32 nand_dm355evm_readecc(struct mtd_info *mtd, u32  Reg)
+{
+        u32      l = 0;
+        emifregs    emif_addr;
+	    emif_addr = (emifregs)CSL_EMIF_1_REGS;
+
+        if (Reg == 1)
+                l = emif_addr->NANDF1ECC;
+        else if (Reg == 2)
+                l = emif_addr->NANDF2ECC;
+        else if (Reg == 3)
+                l = emif_addr->NANDF3ECC;
+        else if (Reg == 4)
+                l = emif_addr->NANDF4ECC;
+
+        return l;
+}
+
+static int nand_dm355evm_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
+				      u_char *ecc_code)
+{
+        unsigned int      l;
+        int               reg;
+        int               n;
+        struct nand_chip *this = mtd->priv;
+
+        if (this->eccmode == NAND_ECC_HW12_2048)
+                n = 4;
+        else
+                n = 1;
+
+        reg = 1;
+        while (n--) {
+                l = nand_dm355evm_readecc(mtd, reg);
+                *ecc_code++ = l;          // P128e, ..., P1e
+                *ecc_code++ = l >> 16;    // P128o, ..., P1o
+                // P2048o, P1024o, P512o, P256o, P2048e, P1024e, P512e, P256e
+                *ecc_code++ = ((l >> 8) & 0x0f) | ((l >> 20) & 0xf0);
+                reg++;
+        }
+        return 0;
+}
+
+static void nand_dm355evm_gen_true_ecc(u8 *ecc_buf)
+{
+        u32 tmp = ecc_buf[0] | (ecc_buf[1] << 16) | ((ecc_buf[2] & 0xF0) << 20) | ((ecc_buf[2] & 0x0F) << 8);
+
+        ecc_buf[0] = ~(P64o(tmp) | P64e(tmp) | P32o(tmp) | P32e(tmp) | P16o(tmp) | P16e(tmp) | P8o(tmp) | P8e(tmp) );
+        ecc_buf[1] = ~(P1024o(tmp) | P1024e(tmp) | P512o(tmp) | P512e(tmp) | P256o(tmp) | P256e(tmp) | P128o(tmp) | P128e(tmp));
+        ecc_buf[2] = ~( P4o(tmp) | P4e(tmp) | P2o(tmp) | P2e(tmp) | P1o(tmp) | P1e(tmp) | P2048o(tmp) | P2048e(tmp));
+}
+
+static int nand_dm355evm_compare_ecc(u8 *     ecc_data1,   /* read from NAND memory */
+                                    u8 *     ecc_data2,   /* read from register */
+                                    u8 *     page_data)
+{
+        u32    i;
+        u8     tmp0_bit[8], tmp1_bit[8], tmp2_bit[8];
+        u8     comp0_bit[8], comp1_bit[8], comp2_bit[8];
+        u8     ecc_bit[24];
+        u8     ecc_sum = 0;
+        u8     find_bit = 0;
+        u32    find_byte = 0;
+        int    isEccFF;
+
+        isEccFF = ((*(u32 *)ecc_data1 & 0xFFFFFF) == 0xFFFFFF);
+
+        nand_dm355evm_gen_true_ecc(ecc_data1);
+        nand_dm355evm_gen_true_ecc(ecc_data2);
+
+        for (i = 0; i <= 2; i++) {
+                *(ecc_data1 + i) = ~(*(ecc_data1 + i));
+                *(ecc_data2 + i) = ~(*(ecc_data2 + i));
+        }
+
+        for (i = 0; i < 8; i++) {
+                tmp0_bit[i]      = *ecc_data1 % 2;
+                *ecc_data1       = *ecc_data1 / 2;
+        }
+
+        for (i = 0; i < 8; i++) {
+                tmp1_bit[i]      = *(ecc_data1 + 1) % 2;
+                *(ecc_data1 + 1) = *(ecc_data1 + 1) / 2;
+        }
+
+        for (i = 0; i < 8; i++) {
+                tmp2_bit[i]      = *(ecc_data1 + 2) % 2;
+                *(ecc_data1 + 2) = *(ecc_data1 + 2) / 2;
+        }
+
+        for (i = 0; i < 8; i++) {
+                comp0_bit[i]     = *ecc_data2 % 2;
+                *ecc_data2       = *ecc_data2 / 2;
+        }
+
+        for (i = 0; i < 8; i++) {
+                comp1_bit[i]     = *(ecc_data2 + 1) % 2;
+                *(ecc_data2 + 1) = *(ecc_data2 + 1) / 2;
+        }
+
+        for (i = 0; i < 8; i++) {
+                comp2_bit[i]     = *(ecc_data2 + 2) % 2;
+                *(ecc_data2 + 2) = *(ecc_data2 + 2) / 2;
+        }
+
+        for (i = 0; i< 6; i++ )
+                ecc_bit[i] = tmp2_bit[i + 2] ^ comp2_bit[i + 2];
+
+        for (i = 0; i < 8; i++)
+                ecc_bit[i + 6] = tmp0_bit[i] ^ comp0_bit[i];
+
+        for (i = 0; i < 8; i++)
+                ecc_bit[i + 14] = tmp1_bit[i] ^ comp1_bit[i];
+
+        ecc_bit[22] = tmp2_bit[0] ^ comp2_bit[0];
+        ecc_bit[23] = tmp2_bit[1] ^ comp2_bit[1];
+
+        for (i = 0; i < 24; i++)
+                ecc_sum += ecc_bit[i];
+
+        switch (ecc_sum) {
+        case 0:
+                /* Not reached because this function is not called if
+                   ECC values are equal */
+                return 0;
+
+        case 1:
+                /* Uncorrectable error */
+                DEBUG (MTD_DEBUG_LEVEL0, "ECC UNCORRECTED_ERROR 1\n");
+                return -1;
+
+        case 12:
+                /* Correctable error */
+                find_byte = (ecc_bit[23] << 8) +
+                            (ecc_bit[21] << 7) +
+                            (ecc_bit[19] << 6) +
+                            (ecc_bit[17] << 5) +
+                            (ecc_bit[15] << 4) +
+                            (ecc_bit[13] << 3) +
+                            (ecc_bit[11] << 2) +
+                            (ecc_bit[9]  << 1) +
+                            ecc_bit[7];
+
+                find_bit = (ecc_bit[5] << 2) + (ecc_bit[3] << 1) + ecc_bit[1];
+
+                DEBUG (MTD_DEBUG_LEVEL0, "Correcting single bit ECC error at offset: %d, bit: %d\n", find_byte, find_bit);
+
+                page_data[find_byte] ^= (1 << find_bit);
+
+                return 0;
+
+        default:
+                if (isEccFF) {
+                        if (ecc_data2[0] == 0 && ecc_data2[1] == 0 && ecc_data2[2] == 0)
+                                return 0;
+                }
+                DEBUG (MTD_DEBUG_LEVEL0, "UNCORRECTED_ERROR default\n");
+                return -1;
+        }
+}
+
+static int nand_dm355evm_correct_data(struct mtd_info *mtd, u_char *dat,
+				     u_char *read_ecc, u_char *calc_ecc)
+{
+	int r = 0;
+#if 0
+	if (memcmp(read_ecc, calc_ecc, 3) != 0) {
+		u_char read_ecc_copy[3], calc_ecc_copy[3];
+		int i;
+
+		for (i = 0; i < 3; i++) {
+			read_ecc_copy[i] = read_ecc[i];
+			calc_ecc_copy[i] = calc_ecc[i];
+		}
+		r = nand_dm355_1bit_compare_ecc(read_ecc_copy, calc_ecc_copy,
+						  dat);
+	}
+#endif
+	return r;
+}
+
+/*
+ * 4-bit ECC routines
+ */
+
+/*
+ * Instead of placing the spare data at the end of the page, the 4-bit ECC
+ * hardware generator requires that the page be subdivided into 4 subpages,
+ * each with its own spare data area.  This structure defines the format of
+ * each of these subpages.
+ */
+static struct page_layout_item nand_dm355_hw10_512_layout[] = {
+	{.type = ITEM_TYPE_DATA,.length = 512},
+	{.type = ITEM_TYPE_OOB,.length = 6,},
+	{.type = ITEM_TYPE_ECC,.length = 10,},
+	{.type = 0,.length = 0,},
+};
+
+static struct nand_oobinfo nand_dm355_hw10_512_oobinfo = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	/*
+	 * We actually have 40 bytes of ECC per page, but the nand_oobinfo
+	 * structure definition limits us to a maximum of 32 bytes.  This
+	 * doesn't matter, because out page_layout_item structure definition
+	 * determines where our ECC actually goes in the flash page.
+	 */
+	.eccbytes = 32,
+	.eccpos = {6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
+		   22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+		   38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
+		   54, 55,
+		   },
+	.oobfree = {{0, 6}, {16, 6}, {32, 6}, {48, 6}},
+};
+
+/*
+ * We should always have a flash-based bad block table.  However, if one isn't
+ * found then all blocks will be scanned to look for factory-marked bad blocks.
+ * We supply a null pattern so that no blocks will be detected as bad.
+ */
+static struct nand_bbt_descr nand_dm355_hw10_512_badblock_pattern = {
+	.options = 0,
+	.offs = 0,
+	.len = 0,
+	.pattern = NULL,
+};
+
+/*
+ * When using 4-bit ECC with a 2048-byte data + 64-byte spare page size, the
+ * oob is scattered throughout the page in 4 16-byte chunks instead of being
+ * grouped together at the end of the page.  This means that the factory
+ * bad-block markers at offsets 2048 and 2049 will be overwritten when data
+ * is written to the flash.  Thus, we cannot use the factory method to mark
+ * or detect bad blocks and must rely on a flash-based bad block table instead.
+ *
+ */
+static int nand_dm355_hw10_512_block_bad(struct mtd_info *mtd, loff_t ofs,
+					   int getchip)
+{
+	return 0;
+}
+
+static int nand_dm355_hw10_512_block_markbad(struct mtd_info *mtd, loff_t ofs)
+{
+	struct nand_chip *this = mtd->priv;
+	int block;
+
+	/* Get block number */
+	block = ((int)ofs) >> this->bbt_erase_shift;
+	if (this->bbt)
+		this->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
+
+	/* Do we have a flash based bad block table ? */
+	if (this->options & NAND_USE_FLASH_BBT)
+		return nand_update_bbt(mtd, ofs);
+
+	return 0;
+}
+
+static void nand_dm355_4bit_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	struct nand_chip *this = mtd->priv;
+    emifregs    emif_addr = (emifregs)CSL_EMIF_1_REGS;
+	u32 val;
+
+	switch (mode) {
+	case NAND_ECC_WRITE:
+	case NAND_ECC_READ:
+		/*
+		 * Start a new ECC calculation for reading or writing 512 bytes
+		 *  of data.
+		 */
+		val = (emif_addr->NANDFCR & ~(3 << 4))
+		    | (1 << 12);
+        emif_addr->NANDFCR = val;
+		break;
+	case NAND_ECC_WRITEOOB:
+	case NAND_ECC_READOOB:
+		/*
+		 * Terminate ECC calculation by performing a dummy read of an
+		 * ECC register.  Our hardware ECC generator supports including
+		 * the OOB in the ECC calculation, but the NAND core code
+		 * doesn't really support that.  We will only calculate the ECC
+		 * on the data; errors in the non-ECC bytes in the OOB will not
+		 * be detected or corrected.
+		 */
+        val = emif_addr->NANDF1ECC;
+		break;
+	case NAND_ECC_WRITESYN:
+	case NAND_ECC_READSYN:
+		/*
+		 * Our ECC calculation has already been terminated, so no need
+		 * to do anything here.
+		 */
+		break;
+	default:
+		break;
+	}
+}
+
+static u32 nand_dm355_4bit_readecc(struct mtd_info *mtd, unsigned int ecc[4])
+{
+    emifregs    emif_addr = (emifregs)CSL_EMIF_1_REGS;
+
+	ecc[0] = (*(dv_reg_p) NAND4BITECC1) & NAND_4BITECC_MASK;
+	ecc[1] = (*(dv_reg_p) NAND4BITECC2) & NAND_4BITECC_MASK;
+	ecc[2] = (*(dv_reg_p) NAND4BITECC3) & NAND_4BITECC_MASK;
+	ecc[3] = (*(dv_reg_p) NAND4BITECC4) & NAND_4BITECC_MASK;
+
+	return 0;
+}
+
+static int nand_dm355_4bit_calculate_ecc(struct mtd_info *mtd,
+					   const u_char * dat,
+					   u_char * ecc_code)
+{
+	unsigned int hw_4ecc[4] = { 0, 0, 0, 0 };
+	unsigned int const1 = 0, const2 = 0;
+	unsigned char count1 = 0;
+
+	/*
+	 * Since the NAND_HWECC_SYNDROME option is enabled, this routine is
+	 * only called just after the data and oob have been written.  The
+	 * ECC value calculated by the hardware ECC generator is available
+	 * for us to read.
+	 */
+	nand_dm355_4bit_readecc(mtd, hw_4ecc);
+
+	/*Convert 10 bit ecc value to 8 bit */
+	for (count1 = 0; count1 < 2; count1++) {
+		const2 = count1 * 5;
+		const1 = count1 * 2;
+
+		/* Take first 8 bits from val1 (count1=0) or val5 (count1=1) */
+		ecc_code[const2] = hw_4ecc[const1] & 0xFF;
+
+		/*
+		 * Take 2 bits as LSB bits from val1 (count1=0) or val5
+		 * (count1=1) and 6 bits from val2 (count1=0) or val5 (count1=1)
+		 */
+		ecc_code[const2 + 1] =
+		    ((hw_4ecc[const1] >> 8) & 0x3) | ((hw_4ecc[const1] >> 14) &
+						      0xFC);
+
+		/*
+		 * Take 4 bits from val2 (count1=0) or val5 (count1=1) and
+		 * 4 bits from val3 (count1=0) or val6 (count1=1)
+		 */
+		ecc_code[const2 + 2] =
+		    ((hw_4ecc[const1] >> 22) & 0xF) |
+		    ((hw_4ecc[const1 + 1] << 4) & 0xF0);
+
+		/*
+		 * Take 6 bits from val3(count1=0) or val6 (count1=1) and
+		 * 2 bits from val4 (count1=0) or  val7 (count1=1)
+		 */
+		ecc_code[const2 + 3] =
+		    ((hw_4ecc[const1 + 1] >> 4) & 0x3F) |
+		    ((hw_4ecc[const1 + 1] >> 10) & 0xC0);
+
+		/* Take 8 bits from val4 (count1=0) or val7 (count1=1) */
+		ecc_code[const2 + 4] = (hw_4ecc[const1 + 1] >> 18) & 0xFF;
+	}
+
+	return 0;
+}
+
+static int nand_dm355_4bit_compare_ecc(struct mtd_info *mtd, u8 * read_ecc,	/* read from NAND */
+					 u8 * page_data)
+{
+	struct nand_chip *this = mtd->priv;
+	struct nand_dm355_info *info = this->priv;
+	unsigned short ecc_10bit[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+	int i;
+	unsigned int hw_4ecc[4] = { 0, 0, 0, 0 }, iserror = 0;
+	unsigned short *pspare = NULL, *pspare1 = NULL;
+	unsigned int numErrors, errorAddress, errorValue;
+    emifregs    emif_addr = (emifregs)CSL_EMIF_1_REGS;
+	u32 val;
+
+	/*
+	 * Check for an ECC where all bytes are 0xFF.  If this is the case, we
+	 * will assume we are looking at an erased page and we should ignore the
+	 * ECC.
+	 */
+	for (i = 0; i < 10; i++) {
+		if (read_ecc[i] != 0xFF)
+			break;
+	}
+	if (i == 10)
+		return 0;
+
+	/* Convert 8 bit in to 10 bit */
+	pspare = (unsigned short *)&read_ecc[2];
+	pspare1 = (unsigned short *)&read_ecc[0];
+	/* Take 10 bits from 0th and 1st bytes */
+	ecc_10bit[0] = (*pspare1) & 0x3FF;	/* 10 */
+	/* Take 6 bits from 1st byte and 4 bits from 2nd byte */
+	ecc_10bit[1] = (((*pspare1) >> 10) & 0x3F)
+	    | (((pspare[0]) << 6) & 0x3C0);	/* 6 + 4 */
+	/* Take 4 bits form 2nd bytes and 6 bits from 3rd bytes */
+	ecc_10bit[2] = ((pspare[0]) >> 4) & 0x3FF;	/* 10 */
+	/*Take 2 bits from 3rd byte and 8 bits from 4th byte */
+	ecc_10bit[3] = (((pspare[0]) >> 14) & 0x3)
+	    | ((((pspare[1])) << 2) & 0x3FC);	/* 2 + 8 */
+	/* Take 8 bits from 5th byte and 2 bits from 6th byte */
+	ecc_10bit[4] = ((pspare[1]) >> 8)
+	    | ((((pspare[2])) << 8) & 0x300);	/* 8 + 2 */
+	/* Take 6 bits from 6th byte and 4 bits from 7th byte */
+	ecc_10bit[5] = (pspare[2] >> 2) & 0x3FF;	/* 10 */
+	/* Take 4 bits from 7th byte and 6 bits from 8th byte */
+	ecc_10bit[6] = (((pspare[2]) >> 12) & 0xF)
+	    | ((((pspare[3])) << 4) & 0x3F0);	/* 4 + 6 */
+	/*Take 2 bits from 8th byte and 8 bits from 9th byte */
+	ecc_10bit[7] = ((pspare[3]) >> 6) & 0x3FF;	/* 10 */
+
+	/*
+	 * Write the parity values in the NAND Flash 4-bit ECC Load register.
+	 * Write each parity value one at a time starting from 4bit_ecc_val8
+	 * to 4bit_ecc_val1.
+	 */
+	for (i = 7; i >= 0; i--)
+    {
+       *(dv_reg_p)NAND4BITECCLOAD = ecc_10bit[i];  
+    }
+
+	/*
+	 * Perform a dummy read to the EMIF Revision Code and Status register.
+	 * This is required to ensure time for syndrome calculation after
+	 * writing the ECC values in previous step.
+	 */
+	val = emif_addr->ERCSR;
+
+	/*
+	 * Read the syndrome from the NAND Flash 4-Bit ECC 1-4 registers.
+	 * A syndrome value of 0 means no bit errors. If the syndrome is
+	 * non-zero then go further otherwise return.
+	 */
+	nand_dm355_4bit_readecc(mtd, hw_4ecc);
+
+	if (hw_4ecc[0] == ECC_STATE_NO_ERR && hw_4ecc[1] == ECC_STATE_NO_ERR &&
+	    hw_4ecc[2] == ECC_STATE_NO_ERR && hw_4ecc[3] == ECC_STATE_NO_ERR)
+		return 0;
+
+	/*
+	 * Clear any previous address calculation by doing a dummy read of an
+	 * error address register.
+	 */
+	val = *(dv_reg_p)NANDERRADD1;
+
+	/*
+	 * Set the addr_calc_st bit(bit no 13) in the NAND Flash Control
+	 * register to 1.
+	 */
+    
+    emif_addr->NANDFCR |= (1 << 13);
+
+	/*
+	 * Wait for the corr_state field (bits 8 to 11)in the
+	 * NAND Flash Status register to be equal to 0x0, 0x1, 0x2, or 0x3.
+	 */
+    do {
+        iserror = emif_addr->NANDFSR & 0xC00;
+    } while (iserror);       
+
+	iserror = emif_addr->NANDFSR;
+	iserror &= EMIF_NANDFSR_ECC_STATE_MASK;
+	iserror = iserror >> 8;
+
+#if 0
+	do {
+		iserror = emif_addr->NANDFSR;
+		iserror &= EMIF_NANDFSR_ECC_STATE_MASK;
+		iserror = iserror >> 8;
+	} while ((ECC_STATE_NO_ERR != iserror) &&
+		 (ECC_STATE_TOO_MANY_ERRS != iserror) &&
+		 (ECC_STATE_ERR_CORR_COMP_P != iserror) &&
+		 (ECC_STATE_ERR_CORR_COMP_N != iserror));
+#endif
+	/*
+	 * ECC_STATE_TOO_MANY_ERRS (0x1) means errors cannot be
+	 * corrected (five or more errors).  The number of errors
+	 * calculated (err_num field) differs from the number of errors
+	 * searched.  ECC_STATE_ERR_CORR_COMP_P (0x2) means error
+	 * correction complete (errors on bit 8 or 9).
+	 * ECC_STATE_ERR_CORR_COMP_N (0x3) means error correction
+	 * complete (error exists).
+	 */
+
+	if (iserror == ECC_STATE_NO_ERR)
+		return 0;
+	else if (iserror == ECC_STATE_TOO_MANY_ERRS)
+    {
+        printf("too many erros to be corrected!\n");
+		return -1;
+    }
+
+#if 1
+	numErrors = ((emif_addr->NANDFSR >> 16) & 0x3) + 1;
+
+	/* Read the error address, error value and correct */
+	for (i = 0; i < numErrors; i++) {
+		if (i > 1) {
+			errorAddress =
+			    ((*(dv_reg_p)(NANDERRADD2) >>
+			      (16 * (i & 1))) & 0x3FF);
+			errorAddress = ((512 + 7) - errorAddress);
+			errorValue =
+			    ((*(dv_reg_p)(NANDERRVAL2) >>
+			      (16 * (i & 1))) & 0xFF);
+		} else {
+			errorAddress =
+			    ((*(dv_reg_p)(NANDERRADD1) >>
+			      (16 * (i & 1))) & 0x3FF);
+			errorAddress = ((512 + 7) - errorAddress);
+			errorValue =
+			    ((*(dv_reg_p)(NANDERRVAL1) >>
+			      (16 * (i & 1))) & 0xFF);
+		}
+		/* xor the corrupt data with error value */
+		if (errorAddress < 512)
+			page_data[errorAddress] ^= errorValue;
+	}
+#else
+	numErrors = ((emif_addr->NANDFSR >> 16) & 0x3);
+        // bit 9:0
+        errorAddress = 519 - (*(dv_reg_p)NANDERRADD1 & (0x3FF));
+        errorValue   = (*(dv_reg_p)NANDERRVAL1) & (0x3FF);
+        page_data[errorAddress] ^= (char)errorValue;
+
+        if(numErrors == 0)
+            return numErrors;
+        else {
+            // bit 25:16
+            errorAddress = 519 - ( (*(dv_reg_p)NANDERRADD1 & (0x3FF0000))>>16 );
+            errorValue   = (*(dv_reg_p)NANDERRVAL1) & (0x3FF);
+            page_data[errorAddress] ^= (char)errorValue;
+
+            if(numErrors == 1)
+                return numErrors;
+            else {
+                // bit 9:0
+                errorAddress = 519 - (*(dv_reg_p)NANDERRADD2 & (0x3FF));
+                errorValue = (*(dv_reg_p)NANDERRVAL2) & (0x3FF);
+                page_data[errorAddress] ^= (char)errorValue;
+
+                if (numErrors == 2)
+                    return numErrors;
+                else {
+                    // bit 25:16
+                    errorAddress = 519 - ( (*(dv_reg_p)NANDERRADD2 & (0x3FF0000))>>16 );
+                    errorValue = (*(dv_reg_p)NANDERRVAL2) & (0x3FF);
+                    page_data[errorAddress] ^= (char)errorValue;
+                }
+            }
+        }
+#endif
+
+	return numErrors;
+}
+
+static int nand_dm355_4bit_correct_data(struct mtd_info *mtd, u_char * dat,
+					  u_char * read_ecc, u_char * calc_ecc)
+{
+	int r = 0;
+
+	/*
+	 * dat points to 512 bytes of data.  read_ecc points to the start of the
+	 * oob area for this subpage, so the ecc values start at offset 6.
+	 * The calc_ecc pointer is not needed since our caclulated ECC is
+	 * already latched in the hardware ECC generator.
+	 */
+#if 1
+	r = nand_dm355_4bit_compare_ecc(mtd, read_ecc + 6, dat);
+#endif
+
+	return r;
+}
+int board_nand_init(struct nand_chip *nand)
+{
+#if 0
+	nand->IO_ADDR_R   = (void  __iomem *)NAND_CE0DATA;
+	nand->IO_ADDR_W   = (void  __iomem *)NAND_CE0DATA;
+#endif
+	nand->chip_delay  = 0;
+	nand->options     = NAND_USE_FLASH_BBT /*| NAND_BBT_LASTBLOCK*/;
+//	nand->eccmode     = NAND_ECC_SOFT;
+#if 0 
+	nand->eccmode     = NAND_ECC_HW3_512;
+	nand->calculate_ecc =  nand_dm355evm_calculate_ecc;
+	nand->correct_data	 = nand_dm355evm_correct_data;
+	nand->enable_hwecc	 = nand_dm355evm_enable_hwecc;
+#else
+	nand->eccmode     = NAND_ECC_HW10_512;
+	nand->options     = NAND_USE_FLASH_BBT | NAND_HWECC_SYNDROME;
+    nand->autooob = &nand_dm355_hw10_512_oobinfo;
+	nand->layout = nand_dm355_hw10_512_layout;
+	nand->calculate_ecc = nand_dm355_4bit_calculate_ecc;
+	nand->correct_data = nand_dm355_4bit_correct_data;
+	nand->enable_hwecc = nand_dm355_4bit_enable_hwecc;
+	//nand->block_bad = nand_dm355_hw10_512_block_bad;
+	nand->block_markbad = nand_dm355_hw10_512_block_markbad;
+	//nand->badblock_pattern =
+	 //   &nand_dm355_hw10_512_badblock_pattern;
+    
+#endif
+	/* Set address of hardware control function */
+	nand->hwcontrol = nand_dm350evm_hwcontrol;
+
+	//nand->dev_ready = nand_dm350evm_dev_ready;
+	//nand->waitfunc = nand_dm350evm_waitfunc;
+
+	return 0;
+}
+
+#else
+#error "U-Boot legacy NAND support not available for DaVinci chips"
+#endif
+#endif	/* CFG_USE_NAND */
diff -Nurd u-boot-1.2.0/board/dm355_evm/timer.c u-boot-1.2.0-leopard/board/dm355_evm/timer.c
--- u-boot-1.2.0/board/dm355_evm/timer.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_evm/timer.c	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,72 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ Modifications:
+ ver. 1.0: Oct 2005, Swaminathan S
+ *
+ */
+
+#include "timer.h"
+
+/* Use Timer 3&4 (Timer 2) */
+#define TIMER_BASE_ADDR	0x01C21400
+
+dm350_timer_reg    *dm350_timer = (dm350_timer_reg *) TIMER_BASE_ADDR;
+
+/* Timer Initialize */
+void inittimer(void)
+{
+        /* disable Timer 1 & 2 timers */
+        dm350_timer->tcr = 0;
+
+        /* Set timers to unchained dual 32 bit timers, Unreset timer34 */
+        dm350_timer->tgcr = 0x0;
+        dm350_timer->tgcr = 0x6;
+
+        /* Program the timer12 counter register - set the prd12 for right count */
+        dm350_timer->tim34 = 0;
+
+        /* The timer is programmed to expire after 0xFFFFFFFF ticks */
+        dm350_timer->prd34 = 0xFFFFFFFF;
+
+        /* Enable timer34 */
+        dm350_timer->tcr = (0x80 << 16); /* Timer34 continously enabled, Timer12 disabled */
+}
+
+/************************************************************
+********************** Reset Processor **********************
+************************************************************/
+#define WDT_BASE_ADDR          0x01C21C00
+
+
+void reset_processor(void)
+{
+        dm350_timer_reg *dm350_wdt = (dm350_timer_reg *) WDT_BASE_ADDR;
+        dm350_wdt->tgcr   = 0x00000008;
+        dm350_wdt->tgcr  |= 0x00000003;
+        dm350_wdt->tim12  = 0x00000000;
+        dm350_wdt->tim34  = 0x00000000;
+        dm350_wdt->prd12  = 0x00000000;
+        dm350_wdt->prd34  = 0x00000000;
+        dm350_wdt->tcr   |= 0x00000040;
+        dm350_wdt->wdtcr |= 0x00004000;
+        dm350_wdt->wdtcr  = 0xA5C64000;
+        dm350_wdt->wdtcr  = 0xDA7E4000;
+}
diff -Nurd u-boot-1.2.0/board/dm355_evm/timer.h u-boot-1.2.0-leopard/board/dm355_evm/timer.h
--- u-boot-1.2.0/board/dm355_evm/timer.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_evm/timer.h	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,51 @@
+/*
+ *
+ *  Copyright (C) 2004 Texas Instruments.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ * Modifications:
+ * ver. 1.0: Oct 2005, Swaminathan S
+ *
+ */
+#ifndef __TIMER_H__
+#define __TIMER_H__
+
+typedef volatile struct dm350_timer_reg_t
+{
+    unsigned int pid12;         /* 0x0 */
+    unsigned int emumgt_clksped;/* 0x4 */
+    unsigned int gpint_en;      /* 0x8 */
+    unsigned int gpdir_dat;     /* 0xC */
+    unsigned int tim12;         /* 0x10 */
+    unsigned int tim34;         /* 0x14 */
+    unsigned int prd12;         /* 0x18 */
+    unsigned int prd34;         /* 0x1C */
+    unsigned int tcr;           /* 0x20 */
+    unsigned int tgcr;          /* 0x24 */
+    unsigned int wdtcr;         /* 0x28 */
+    unsigned int tlgc;          /* 0x2C */
+    unsigned int tlmr;          /* 0x30 */
+} dm350_timer_reg;
+
+#endif  /* __TIMER_H__ */
+
diff -Nurd u-boot-1.2.0/board/dm355_evm/types.h u-boot-1.2.0-leopard/board/dm355_evm/types.h
--- u-boot-1.2.0/board/dm355_evm/types.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_evm/types.h	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,46 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ *
+ */
+#ifndef _TYPESH_
+#define _TYPESH_
+
+typedef unsigned long 	ULONG;
+typedef unsigned short 	USHORT;
+typedef unsigned long   BOOL;
+typedef unsigned int	WORD;
+typedef char            CHAR;
+typedef unsigned char   BYTE, *LPBYTE, UCHAR, *PUCHAR, PBYTE;
+
+#define FALSE           0
+#define TRUE            1
+
+#define NULL			0
+
+typedef unsigned short int Hwd;
+typedef volatile unsigned short int vHwd;
+typedef unsigned short int *  Hwdptr;
+typedef volatile unsigned short int * vHwdptr;
+//typedef volatile unsigned int * vHwdptr;
+
+
+#endif
+
diff -Nurd u-boot-1.2.0/board/dm355_evm/u-boot.lds u-boot-1.2.0-leopard/board/dm355_evm/u-boot.lds
--- u-boot-1.2.0/board/dm355_evm/u-boot.lds	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_evm/u-boot.lds	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,52 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+	. = ALIGN(4);
+	.text	:
+	{
+	  cpu/arm926ejs/start.o	(.text)
+	  *(.text)
+	}
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+	. = ALIGN(4);
+	.data : { *(.data) }
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -Nurd u-boot-1.2.0/board/dm355_ipnc/Makefile u-boot-1.2.0-leopard/board/dm355_ipnc/Makefile
--- u-boot-1.2.0/board/dm355_ipnc/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_ipnc/Makefile	2008-01-05 03:45:25.000000000 -0300
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= dm355_ipnc.o flash.o nand.o timer.o 
+SOBJS	:= lowlevel_init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $^
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff -Nurd u-boot-1.2.0/board/dm355_ipnc/config.mk u-boot-1.2.0-leopard/board/dm355_ipnc/config.mk
--- u-boot-1.2.0/board/dm355_ipnc/config.mk	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_ipnc/config.mk	2008-01-31 04:18:33.000000000 -0300
@@ -0,0 +1,25 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+# David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+#
+# (C) Copyright 2003
+# Texas Instruments, <www.ti.com>
+# Swaminathan <swami.iyer@ti.com>
+#
+# Davinci EVM board (ARM925EJS) cpu
+# see http://www.ti.com/ for more information on Texas Instruments
+#
+# Davinci EVM has 1 bank of 256 MB DDR RAM 
+# Physical Address:
+# 8000'0000 to 9000'0000
+#
+# Linux-Kernel is expected to be at 8000'8000, entry 8000'8000
+# (mem base + reserved)
+#
+# we load ourself to 8100 '0000
+# 
+#
+
+#Provide a atleast 16MB spacing between us and the Linux Kernel image
+TEXT_BASE = 0x81080000
diff -Nurd u-boot-1.2.0/board/dm355_ipnc/dm355_ipnc.c u-boot-1.2.0-leopard/board/dm355_ipnc/dm355_ipnc.c
--- u-boot-1.2.0/board/dm355_ipnc/dm355_ipnc.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_ipnc/dm355_ipnc.c	2009-02-13 04:25:31.000000000 -0300
@@ -0,0 +1,671 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ Modifications:
+ ver. 1.0: Oct 2005, Swaminathan S
+ *
+ */
+#include <common.h>
+#include <i2c.h>
+#include <asm/io.h>
+
+#define inw(a) __raw_readw(a)
+#define outw(a,v) __raw_writew(a,v)
+
+
+#define PLL1_PLLM    *(volatile unsigned int *)0x01c40910
+#define PLL2_PLLM    *(volatile unsigned int *)0x01c40D10
+#define PLL2_DIV2    *(volatile unsigned char *)0x01c40D1C
+#define PLL2_PREDIV  *(volatile unsigned int *)0x01C40D14
+#define PLL1_PLLDIV3 *(volatile unsigned int *)0x01C40920
+#define PLL1_POSTDIV *(volatile unsigned int *)0x01C40928
+#define PLL1_PLLDIV4 *(volatile unsigned int *)0x01C40960
+#define SYSTEM_MISC  *(volatile unsigned int *)0x01C40038
+#define MACH_DM350_IPNC	1381
+
+#define W_SETUP       	0x1	    //0~f         
+#define W_STROBE        0x3	    //0~3f
+#define W_HOLD        	0x1	    //0~7
+#define R_SETUP       	0x1	    //0~f         
+#define R_STROBE      	0x3	    //0~3f
+#define R_HOLD        	0x1     //0~7
+
+#define TA            			3     //0~3
+#define A_SIZE        			1     //1:16 bit 0:8bit
+#define DM9000_TIMING  		W_SETUP<<26 | W_STROBE<<20 | W_HOLD <<17 | R_SETUP<<13 | R_STROBE<<7 | R_HOLD <<4 | TA<<2 | A_SIZE
+
+
+
+/* GIO register */
+#define	GIO_BINTEN		              0x01C67008		/* GPIO Interrupt Per-Bank Enable Register */
+#define GIO_DIR01			       0x01C67010		
+#define GIO_OUT_DATA01			0x01C67014		
+#define GIO_SET_DATA01			0x01C67018		
+#define GIO_CLR_DATA01			0x01C6701C		
+#define	GIO_SET_RIS_TRIG01	0x01C67024		    
+#define	GIO_SET_FAL_TRIG01	0x01C6702c		
+#define	GIO_A2CR		              0x01e10014
+
+#define GIO_DIR23			       0x01C67038		
+#define GIO_OUT_DATA23			0x01C6703c		
+#define GIO_SET_DATA23			0x01C67040		
+#define GIO_CLR_DATA23			0x01C67044		
+
+#define GIO_DIR45			       (0x01C67060)		
+#define GIO_OUT_DATA45			(0x01C67064)		
+#define GIO_SET_DATA45			(0x01C67068)		
+#define GIO_CLR_DATA45			(0x01C6706C)
+
+#define GIO_DIR06			      (0x01C67088)		
+#define GIO_OUT_DATA06			(0x01C6708C)		
+#define GIO_SET_DATA06			(0x01C67090)		
+#define GIO_CLR_DATA06			(0x01C67094)
+
+void davinci_psc_all_enable(void);
+short MSP430_getReg( short reg, unsigned short *regval );
+unsigned int UARTSendInt(unsigned int value);
+
+/*******************************************
+ Routine: delay
+ Description:  Delay function
+*******************************************/
+static inline void delay (unsigned long loops)
+{
+__asm__ volatile ("1:\n"
+		     "subs %0, %1, #1\n"
+		     "bne 1b":"=r" (loops):"0" (loops));
+}
+
+/*******************************************
+ Routine: board_init
+ Description:  Board Initialization routine
+*******************************************/
+int board_init (void)
+{
+    	  DECLARE_GLOBAL_DATA_PTR;
+        int i;
+        /* arch number of DaVinci DVDP-Board */
+        gd->bd->bi_arch_number = MACH_DM350_IPNC;
+
+      	/* adress of boot parameters */
+       	gd->bd->bi_boot_params = LINUX_BOOT_PARAM_ADDR;
+#if 1	
+#define PINMUX3	    0x01C4000C
+		*(volatile unsigned int *)PINMUX3 &= 0XF8FFFFFF; // GIO9 & 10 are IO
+		
+ 	      /* Interrupt set GIO9	*/
+	      *((volatile unsigned int *) GIO_BINTEN) |=0x01; //bank 0	
+	      /* set GIO9input  */
+	       *((volatile unsigned int *) GIO_DIR01) |=(1<<9);	 
+	      /* Both edge tigger GIO9 */
+	       *((volatile unsigned int *) GIO_SET_RIS_TRIG01) |=(1<<9);          	
+
+		  	/* set GIO5 output, imager reset  */
+		printf("pull down gio5\n");
+		*((volatile unsigned int *) GIO_DIR01) &= ~(1<<5);	
+		*((volatile unsigned int *) GIO_SET_DATA01) &= ~(1<<5); // output Low
+	
+			/* set GIO10 output  */
+			printf("pull up gio10\n");
+	       *((volatile unsigned int *) GIO_DIR01) &= ~(1<<10);	
+		   *((volatile unsigned int *) GIO_SET_DATA01) |= (1<<10); // output Hi
+
+
+	      	/* set GIO32 output	*/
+	      *((volatile unsigned int *) GIO_DIR23) &= ~(1<<0);  
+	      *((volatile unsigned int *) GIO_SET_DATA23) |= (1<<0); // output Hi
+	      	/* set GIO102 output	*/	   
+#define PINMUX0     0x01C40000
+        /* Enable UART1 MUX Lines */
+        *(volatile unsigned int *)PINMUX0 &= ~3;	
+        *((volatile unsigned int *) GIO_DIR06) &= ~(1<<6);     
+	      *((volatile unsigned int *) GIO_SET_DATA06) |= (1<<6); // output Hi 
+
+	      /* CE01:External Memory setting */
+       	/* PLL1 404MHZ	EMIF 101MHZ  unit 10 ns   */ 
+      
+	    /*  *((volatile unsigned int *) GIO_A2CR) =  DM9000_TIMING ; */	 						
+#endif
+        /* Configure MUX settings */
+
+      /* Power on required peripherals 
+    	davinci_psc_all_enable(); */
+#if 0
+      	/* this speeds up your boot a quite a bit.  However to make it
+ 	 *  work, you need make sure your kernel startup flush bug is fixed.
+	 *  ... rkw ...
+	 */
+	icache_enable ();
+
+#endif
+      	inittimer ();
+
+      	return 0;
+}
+
+/* PSC Domains */
+
+#define LPSC_VPSSMSTR       0       // VPSS Master LPSC
+#define LPSC_VPSSSLV        1       // VPSS Slave LPSC
+#define LPSC_TPCC           2       // TPCC LPSC
+#define LPSC_TPTC0          3       // TPTC0 LPSC
+#define LPSC_TPTC1          4       // TPTC1 LPSC
+#define PAL_SYS_CLK_MODULE_SPI1 6 /**<SPI1 LPSC Module No*/
+#define PAL_SYS_CLK_MODULE_MMCSD1 7 /**<MMCSD1 LPSC Module No*/
+#define LPSC_USB            9       // USB LPSC
+#define PAL_SYS_CLK_MODULE_PWM3 10  /**<PWM3 LPSC Module No*/
+#define PAL_SYS_CLK_MODULE_SPI2 11  /**<SPI2 LPSC Module No*/
+#define PAL_SYS_CLK_MODULE_RTO 12   /**<TIMER2 LPSC Module No*/
+#define LPSC_DDR_EMIF       13      // DDR_EMIF LPSC
+#define LPSC_AEMIF          14      // AEMIF LPSC
+#define LPSC_MMC_SD         15      // MMC_SD LPSC
+#define LPSC_MEMSTICK       16      // MEMSTICK LPSC
+#define PAL_SYS_CLK_MODULE_ASP 17   /**<AEMIF LPSC Module No*/
+#define LPSC_I2C            18      // I2C LPSC
+#define LPSC_UART0          19      // UART0 LPSC
+#define LPSC_UART1          20      // UART1 LPSC
+#define LPSC_UART2          21      // UART2 LPSC
+#define LPSC_SPI            22      // SPI LPSC
+#define LPSC_PWM0           23      // PWM0 LPSC
+#define LPSC_PWM1           24      // PWM1 LPSC
+#define LPSC_PWM2           25      // PWM2 LPSC
+#define LPSC_GPIO           26      // GPIO LPSC
+#define LPSC_TIMER0         27      // TIMER0 LPSC
+#define LPSC_TIMER1         28      // TIMER1 LPSC
+#define LPSC_TIMER2         29      // TIMER2 LPSC
+#define LPSC_SYSTEM_SUBSYS  30      // SYSTEM SUBSYSTEM LPSC
+#define LPSC_ARM            31      // ARM LPSC
+#define PAL_SYS_CLK_MODULE_VPSS_DAC 40  /**<VPSS DAC LPSC Module No*/
+
+#define EPCPR               *( unsigned int* )( 0x01C41070 )
+#define PTCMD               *( unsigned int* )( 0x01C41120 )
+#define PTSTAT              *( unsigned int* )( 0x01C41128 )
+#define PDSTAT              *( unsigned int* )( 0x01C41200 )
+#define PDSTAT1             *( unsigned int* )( 0x01C41204 )
+#define PDCTL               *( unsigned int* )( 0x01C41300 )
+#define PDCTL1              *( unsigned int* )( 0x01C41304 )
+#define VBPR                *( unsigned int* )( 0x20000020 )
+
+/**************************************
+ Routine: board_setup_psc_on
+ Description:  Enable a PSC domain
+**************************************/
+void board_setup_psc_on( unsigned int domain, unsigned int id )
+{
+        volatile unsigned int* mdstat = ( unsigned int* )( 0x01C41800 + 4 * id );
+	      volatile unsigned int* mdctl  = ( unsigned int* )( 0x01C41A00 + 4 * id );
+
+	      *mdctl |= 0x00000003; // Set PowerDomain to turn on
+
+    	  if ( ( PDSTAT & 0x00000001 ) == 0 )
+    	  {
+                PDCTL1 |= 0x1;
+        	      PTCMD = ( 1 << domain );
+        	      while ( ( ( ( EPCPR >> domain ) & 1 ) == 0 ) );
+
+        	      PDCTL1 |= 0x100 ;
+        	      while( ! ( ( ( PTSTAT >> domain ) & 1 ) == 0 ) );
+    	  }
+    	  else
+    	  {
+        	      PTCMD = ( 1<<domain );
+        	      while( ! ( ( ( PTSTAT >> domain ) & 1 ) == 0 ) );
+    	  }
+
+    	  while( ! ( ( *mdstat & 0x0000001F ) == 0x3 ) );
+}
+
+/**************************************
+ Routine: davinci_psc_all_enable
+ Description:  Enable all PSC domains
+**************************************/
+void davinci_psc_all_enable(void)
+{
+#define PSC_ADDR            0x01C41000
+#define PTCMD               (PSC_ADDR+0x120)
+#define PTSTAT              (PSC_ADDR+0x128)
+
+        unsigned int alwaysOnPdNum = 0, dspPdNum = 1, i;
+
+    	  /* This function turns on all clocks in the ALWAYSON and DSP Power
+	       * Domains.  Note this function assumes that the Power Domains are
+	       * already on.
+	       */
+#if 0
+    	  /* Write ENABLE (0x3) to all 41 MDCTL[i].NEXT bit fields. */
+    	  for( i = 0; i < 41; i++){
+                *(volatile unsigned int*) (PSC_ADDR+0xA00+4*i) =
+				        *(volatile unsigned int*) (PSC_ADDR+0xA00+4*i) | 0x3;
+    	  }
+
+    	  /* For special workaround:  Set MDCTL[i].EMURSTIE to 0x1 for all of the
+	       * following Modules.  VPSSSLV, EMAC, EMACCTRL, MDIO, USB, ATA, VLYNQ,
+         * HPI, DDREMIF, AEMIF, MMCSD, MEMSTICK, ASP, GPIO, IMCOP.
+         */
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*1) = *(unsigned int*) (PSC_ADDR+0xA00+4*1) | 0x203;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*5) = *(unsigned int*) (PSC_ADDR+0xA00+4*5) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*6) = *(unsigned int*) (PSC_ADDR+0xA00+4*6) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*7) = *(unsigned int*) (PSC_ADDR+0xA00+4*7) | 0x203;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*9) = *(unsigned int*) (PSC_ADDR+0xA00+4*9) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*10) = *(unsigned int*) (PSC_ADDR+0xA00+4*10) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*11) = *(unsigned int*) (PSC_ADDR+0xA00+4*11) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*12) = *(unsigned int*) (PSC_ADDR+0xA00+4*12) | 0x203;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*13) = *(unsigned int*) (PSC_ADDR+0xA00+4*13) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*14) = *(unsigned int*) (PSC_ADDR+0xA00+4*14) | 0x203;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*15) = *(unsigned int*) (PSC_ADDR+0xA00+4*15) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*16) = *(unsigned int*) (PSC_ADDR+0xA00+4*16) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*17) = *(unsigned int*) (PSC_ADDR+0xA00+4*17) | 0x203;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*19) = *(unsigned int*) (PSC_ADDR+0xA00+4*19) | 0x203;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*26) = *(unsigned int*) (PSC_ADDR+0xA00+4*26) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*40) = *(unsigned int*) (PSC_ADDR+0xA00+4*40) | 0x203;*/
+#endif
+
+        /* For special workaround:  Clear MDCTL[i].EMURSTIE to 0x0 for all of the following Modules.
+         *  VPSSSLV, EMAC, EMACCTRL, MDIO, USB, ATA, VLYNQ,
+         *  HPI, DDREMIF, AEMIF, MMCSD, MEMSTICK, ASP, GPIO, IMCOP.
+         */
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*1) = *(unsigned int*) (PSC_ADDR+0xA00+4*1) & 0x003;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*5) = *(unsigned int*) (PSC_ADDR+0xA00+4*5) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*6) = *(unsigned int*) (PSC_ADDR+0xA00+4*6) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*7) = *(unsigned int*) (PSC_ADDR+0xA00+4*7) | 0x003;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*9) = *(unsigned int*) (PSC_ADDR+0xA00+4*9) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*10) = *(unsigned int*) (PSC_ADDR+0xA00+4*10) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*11) = *(unsigned int*) (PSC_ADDR+0xA00+4*11) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*12) = *(unsigned int*) (PSC_ADDR+0xA00+4*12) & 0x003;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*13) = *(unsigned int*) (PSC_ADDR+0xA00+4*13) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*14) = *(unsigned int*) (PSC_ADDR+0xA00+4*14) | 0x003;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*15) = *(unsigned int*) (PSC_ADDR+0xA00+4*15) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*16) = *(unsigned int*) (PSC_ADDR+0xA00+4*16) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*17) = *(unsigned int*) (PSC_ADDR+0xA00+4*17) & 0x003;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*19) = ((*(unsigned int*) (PSC_ADDR+0xA00+4*19))&0xFFFFFFF8) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*20) = ((*(unsigned int*) (PSC_ADDR+0xA00+4*20))&0xFFFFFFF8) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*21) = ((*(unsigned int*) (PSC_ADDR+0xA00+4*21))&0xFFFFFFF8) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*18) = *(unsigned int*) (PSC_ADDR+0xA00+4*18) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*28) = *(unsigned int*) (PSC_ADDR+0xA00+4*28) | 0x003;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*26) = *(unsigned int*) (PSC_ADDR+0xA00+4*26) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*40) = *(unsigned int*) (PSC_ADDR+0xA00+4*40) & 0x003;*/
+
+    	  /* Set PTCMD.GO0 to 0x1 to initiate the state transtion for Modules in
+	       * the ALWAYSON Power Domain
+	       */
+    	  *(volatile unsigned int*) PTCMD = (1<<alwaysOnPdNum);
+
+
+    	  /* Wait for PTSTAT.GOSTAT0 to clear to 0x0 */
+    	  while(! (((*(volatile unsigned int*) PTSTAT >> alwaysOnPdNum) & 0x00000001) == 0));
+
+	/* Wait for PTSTAT.GOSTAT0 to clear to 0x0 */
+          while(! ((*(unsigned int*) (PSC_ADDR+0x800+4*19)& 0x0000001F ) == 0x3));
+	/* Wait for PTSTAT.GOSTAT0 to clear to 0x0 */
+          while(! ((*(unsigned int*) (PSC_ADDR+0x800+4*20)& 0x0000001F ) == 0x3));
+	/* Wait for PTSTAT.GOSTAT0 to clear to 0x0 */
+          while(! ((*(unsigned int*) (PSC_ADDR+0x800+4*21)& 0x0000001F ) == 0x3));
+        /* Bringup UART out of reset here since NS16650 code that we are using from uBoot
+         * will not do it
+         */
+
+#define UART0PWREMU_MGMT     0x01c20030
+        *(volatile unsigned int*) UART0PWREMU_MGMT |= 0x00008001;
+
+
+#define UART1PWREMU_MGMT     0x01c20430
+        *(volatile unsigned int*) UART1PWREMU_MGMT |= 0x00008001;
+
+#define UART2PWREMU_MGMT     0x01e06030
+        *(volatile unsigned int*) UART2PWREMU_MGMT |= 0x00008001;
+
+#define PINMUX3     0x01C4000C
+        /* Enable UART1 MUX Lines */
+        *(volatile unsigned int *)PINMUX3 |= 0x00600000;
+	
+				/* Enable UART2 MUX Lines */
+        *(volatile unsigned int *)PINMUX3 |= 0x0000AA00;
+
+	/* Set the Bus Priority Register to appropriate value */
+	VBPR = 0x20;
+}
+
+/******************************
+ Routine: misc_init_r
+ Description:  Misc. init
+******************************/
+int misc_init_r (void)
+{
+	char temp[20], *env=0;
+	char rtcdata[10] = { 4, 1, 0, 0, 0, 0, 0, 0, 0, 0};
+    int clk = 0;
+    unsigned short regval=0 ;
+
+    clk = ((PLL2_PLLM + 1) * 24) / ((PLL2_PREDIV & 0x1F) + 1); 
+
+    printf ("ARM Clock :- %dMHz\n", ( ( ((PLL1_PLLM+1)*24 )/(2*(7+1)*((SYSTEM_MISC & 0x2)?2:1 )))) );
+    printf ("DDR Clock :- %dMHz\n", (clk/2));
+
+	/* set GIO5 output, imager reset  */
+	printf("pull up gio5\n");
+	*((volatile unsigned int *) GIO_SET_DATA01) |= (1<<5); // output High
+		   
+    return (0);
+}
+
+/******************************
+ Routine: dram_init
+ Description:  Memory Info
+******************************/
+int dram_init (void)
+{
+        DECLARE_GLOBAL_DATA_PTR;
+
+	      gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	      gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+        return 0;
+}
+
+
+typedef int     Bool;
+#define TRUE        ((Bool) 1)
+#define FALSE       ((Bool) 0)
+
+
+typedef int             Int;
+typedef unsigned int    Uns;    /* deprecated type */
+typedef char            Char;
+typedef char *          String;
+typedef void *          Ptr;
+
+/* unsigned quantities */
+typedef unsigned int    Uint32;
+typedef unsigned short  Uint16;
+typedef unsigned char   Uint8;
+
+/* signed quantities */
+typedef int             Int32;
+typedef short           Int16;
+typedef char            Int8;
+
+/* volatile unsigned quantities */
+typedef volatile unsigned int       VUint32;
+typedef volatile unsigned short     VUint16;
+typedef volatile unsigned char      VUint8;
+
+/* volatile signed quantities */
+typedef volatile int                VInt32;
+typedef volatile short              VInt16;
+typedef volatile char               VInt8;
+
+typedef struct _uart_regs
+{
+    VUint32 RBR;
+    VUint32 IER;
+    VUint32 IIR;
+    VUint32 LCR;
+    VUint32 MCR;
+    VUint32 LSR;
+    VUint32 MSR;
+    VUint32 SCR;
+    VUint8 DLL;
+    VUint8 RSVDO[3];
+    VUint8 DLH;
+    VUint8 RSVD1[3];
+    VUint32 PID1;
+    VUint32 PID2;
+    VUint32 PWREMU_MGNT;
+} uartRegs;
+
+#define THR RBR
+#define FCR IIR
+
+#define UART0 ((uartRegs*) 0x01C20000)
+#define UART1 ((uartRegs*) 0x01C20400)
+
+#define MAXSTRLEN 256
+#define E_PASS    0x00000000u
+#define E_FAIL    0x00000001u
+#define E_TIMEOUT 0x00000002u
+
+
+
+// Send specified number of bytes
+
+Int32 GetStringLen(Uint8* seq)
+{
+    Int32 i = 0;
+    while ((seq[i] != 0) && (i<MAXSTRLEN)){ i++;}
+    if (i == MAXSTRLEN)
+        return -1;
+    else
+        return i;
+}
+
+Uint32 UARTSendData(Uint8* seq, Bool includeNull)
+{
+    Uint32 status = 0;
+    Int32 i,numBytes;
+    Uint32 timerStatus = 0x1000000;
+
+    numBytes = includeNull?(GetStringLen(seq)+1):(GetStringLen(seq));
+
+    for(i=0;i<numBytes;i++) {
+        /* Enable Timer one time */
+        //TIMER0Start();
+        do{
+            status = (UART0->LSR)&(0x60);
+            //timerStatus = TIMER0Status();
+            timerStatus--;
+        } while (!status && timerStatus);
+
+        if(timerStatus == 0)
+            return E_TIMEOUT;
+
+        // Send byte
+        (UART0->THR) = seq[i];
+    }
+    return E_PASS;
+}
+
+Uint32 UARTSendInt(Uint32 value)
+{
+    char seq[9];
+    Uint32 i,shift,temp;
+
+    for( i = 0; i < 8; i++)
+    {
+        shift = ((7-i)*4);
+        temp = ((value>>shift) & (0x0000000F));
+        if (temp > 9)
+        {
+            temp = temp + 7;
+        }
+        seq[i] = temp + 48;
+        seq[i] = temp + 48;
+    }
+    seq[8] = 0;
+    return UARTSendData(seq, FALSE);
+}
+
+#define I2C_BASE                0x01C21000
+#define	I2C_OA			(I2C_BASE + 0x00)
+#define I2C_IE                  (I2C_BASE + 0x04)
+#define I2C_STAT                (I2C_BASE + 0x08)
+#define I2C_SCLL                (I2C_BASE + 0x0c)
+#define I2C_SCLH                (I2C_BASE + 0x10)
+#define I2C_CNT                 (I2C_BASE + 0x14)
+#define I2C_DRR                 (I2C_BASE + 0x18)
+#define I2C_SA                  (I2C_BASE + 0x1c)
+#define I2C_DXR                 (I2C_BASE + 0x20)
+#define I2C_CON                 (I2C_BASE + 0x24)
+#define I2C_IV                  (I2C_BASE + 0x28)
+#define I2C_PSC                 (I2C_BASE + 0x30)
+
+#define I2C_CON_EN      (1 << 5)       /* I2C module enable */
+#define I2C_CON_STB     (1 << 4)       /* Start byte mode (master mode only) */
+#define I2C_CON_MST     (1 << 10)      /* Master/slave mode */
+#define I2C_CON_TRX     (1 << 9)       /* Transmitter/receiver mode (master mode only) */
+#define I2C_CON_XA      (1 << 8)       /* Expand address */
+#define I2C_CON_STP     (1 << 11)      /* Stop condition (master mode only) */
+#define I2C_CON_STT     (1 << 13)      /* Start condition (master mode only) */
+
+#define I2C_STAT_BB     (1 << 12)       /* Bus busy */
+#define I2C_STAT_ROVR   (1 << 11)       /* Receive overrun */
+#define I2C_STAT_XUDF   (1 << 10)       /* Transmit underflow */
+#define I2C_STAT_AAS    (1 << 9)        /* Address as slave */
+#define I2C_STAT_SCD    (1 << 5)        /* Stop condition detect */
+#define I2C_STAT_XRDY   (1 << 4)        /* Transmit data ready */
+#define I2C_STAT_RRDY   (1 << 3)        /* Receive data ready */
+#define I2C_STAT_ARDY   (1 << 2)        /* Register access ready */
+#define I2C_STAT_NACK   (1 << 1)        /* No acknowledgment interrupt enable */
+#define I2C_STAT_AL     (1 << 0)        /* Arbitration lost interrupt enable */
+
+static Int16 I2C_init(void );
+static Int16 I2C_close(void );
+static Int16 I2C_reset( void);
+static Int16 I2C_write( Uint16 i2c_addr, Uint8* data, Uint16 len );
+static Int16 I2C_read( Uint16 i2c_addr, Uint8* data, Uint16 len );
+Int32 i2c_timeout = 0x10000;
+
+Int16 MSP430_getReg( Int16 reg, Uint16 *regval )
+{
+    volatile Int16 retcode;
+    Uint8 msg[2];
+
+    I2C_reset();
+    udelay(10000);
+    /* Send Msg */
+    msg[0] = (Uint8)(reg & 0xff);
+    if ( retcode = I2C_write( 0x25, msg, 1) )
+    {
+        return retcode;
+    }
+
+    if ( retcode = I2C_read(  0x25, msg, 1 ) )
+    {
+        return retcode;
+    }
+
+    *regval = msg[0];
+
+    /* Wait 1 msec */
+    udelay( 1000 );
+
+    return 0;
+}
+
+static Int16 I2C_init( )
+{
+    outw(0, I2C_CON);                // Reset I2C
+    outw(26,I2C_PSC);               // Config prescaler for 27MHz
+    outw(20,I2C_SCLL);              // Config clk LOW for 20kHz
+    outw(20,I2C_SCLH);               // Config clk HIGH for 20kHz
+    outw(inw(I2C_CON) | I2C_CON_EN,I2C_CON);        // Release I2C from reset
+    return 0;
+}
+
+/* ------------------------------------------------------------------------ *
+ *                                                                          *
+ *  _I2C_close( )                                                           *
+ *                                                                          *
+ * ------------------------------------------------------------------------ */
+static Int16 I2C_close( )
+{
+        outw(0,I2C_CON);                      // Reset I2C
+        return 0;
+}
+
+/* ------------------------------------------------------------------------ *
+ *                                                                          *
+ *  _I2C_reset( )                                                           *
+ *                                                                          *
+ * ------------------------------------------------------------------------ */
+static Int16 I2C_reset( )
+{
+    I2C_close( );
+    I2C_init( );
+    return 0;
+}
+
+static Int16 I2C_write( Uint16 i2c_addr, Uint8* data, Uint16 len )
+{
+    Int32 timeout, i, status;
+
+        outw(len, I2C_CNT);                    // Set length
+        outw(i2c_addr, I2C_SA);               // Set I2C slave address
+        outw(0x2000               // Set for Master Write
+             | 0x0200
+             | 0x0400
+             | I2C_CON_EN
+             | 0x4000, I2C_CON );
+
+        udelay( 10 );                        // Short delay
+
+        for ( i = 0 ; i < len ; i++ )
+        {
+            outw( data[i],I2C_DXR);;            // Write
+
+            timeout = i2c_timeout;
+            do
+            {
+                if ( timeout-- < 0  )
+                {
+                    I2C_reset( );
+                    return -1;
+                }
+            } while ( ( inw(I2C_STAT) & I2C_STAT_XRDY ) == 0 );// Wait for Tx Ready
+        }
+
+        outw( inw(I2C_CON) | 0x0800, I2C_CON);             // Generate STOP
+
+        return 0;
+
+}
+static Int16 I2C_read( Uint16 i2c_addr, Uint8* data, Uint16 len )
+{
+    Int32 timeout, i, status;
+
+    outw( len, I2C_CNT);                    // Set length
+    outw( i2c_addr, I2C_SA);               // Set I2C slave address
+    outw( 0x2000               // Set for Master Read
+          | 0x0400
+          | I2C_CON_EN
+          | 0x4000,I2C_CON);
+
+    udelay( 10 );                        // Short delay
+
+    for ( i = 0 ; i < len ; i++ )
+    {
+        timeout = i2c_timeout;
+
+        /* Wait for Rx Ready */
+        do
+        {
+            if ( timeout-- < 0 )
+            {
+                I2C_reset( );
+                return -1;
+            }
+        } while ( ( inw(I2C_STAT) & I2C_STAT_RRDY ) == 0 );// Wait for Rx Ready
+
+        data[i] = inw(I2C_DRR);            // Read
+    }
+
+      //I2C_ICMDR |= ICMDR_STP;             // Generate STOP
+    return 0;
+}
+
diff -Nurd u-boot-1.2.0/board/dm355_ipnc/flash.c u-boot-1.2.0-leopard/board/dm355_ipnc/flash.c
--- u-boot-1.2.0/board/dm355_ipnc/flash.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_ipnc/flash.c	2008-01-05 03:45:25.000000000 -0300
@@ -0,0 +1,758 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2003
+ * Reinhard Meyer, EMK Elektronik GmbH, r.meyer@emk-elektronik.de
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */	
+
+#include <common.h>
+#include <linux/byteorder/swab.h>
+#include "types.h"
+
+#if !defined(CFG_NO_FLASH)
+flash_info_t	flash_info[CFG_MAX_FLASH_BANKS]; /* info for FLASH chips */
+
+#if define (CFG_DM355_IPNC)
+  typedef unsigned short FLASH_PORT_WIDTH;
+  typedef volatile unsigned short FLASH_PORT_WIDTHV;
+  #define	FLASH_ID_MASK	0xFF
+
+  #define FPW	FLASH_PORT_WIDTH
+  #define FPWV	FLASH_PORT_WIDTHV
+
+  #define EVMDM355_FLASH_CTL555        *(u16*)( CFG_FLASH_BASE + (0x555 << 1))
+  #define EVMDM355_FLASH_CTL2AA        *(u16*)( CFG_FLASH_BASE + (0x2aa << 1))
+  #define EVMDM355_CPLD                *(u16*)( CFG_FLASH_BASE + (0x1c000 << 0) )
+  #define EVMDM355_CPLD_MASK           0x3FC000
+
+  #define FLASH_CYCLE1	(0x0555)
+  #define FLASH_CYCLE2	(0x02aa)
+  #define FLASH_ID1		0
+  #define FLASH_ID2		1
+  #define FLASH_ID3		0x0e
+  #define FLASH_ID4		0x0F
+  #define SWAP(x)			__swab16(x)
+#endif
+
+#if defined (CONFIG_TOP860)
+  typedef unsigned short FLASH_PORT_WIDTH;
+  typedef volatile unsigned short FLASH_PORT_WIDTHV;
+  #define	FLASH_ID_MASK	0xFF
+
+  #define FPW	FLASH_PORT_WIDTH
+  #define FPWV	FLASH_PORT_WIDTHV
+
+  #define FLASH_CYCLE1	0x0555
+  #define FLASH_CYCLE2	0x02aa
+  #define FLASH_ID1		0
+  #define FLASH_ID2		1
+  #define FLASH_ID3		0x0e
+  #define FLASH_ID4		0x0F
+#endif
+
+#if defined (CONFIG_TOP5200) && !defined (CONFIG_LITE5200)
+  typedef unsigned char FLASH_PORT_WIDTH;
+  typedef volatile unsigned char FLASH_PORT_WIDTHV;
+  #define	FLASH_ID_MASK	0xFF
+
+  #define FPW	FLASH_PORT_WIDTH
+  #define FPWV	FLASH_PORT_WIDTHV
+
+  #define FLASH_CYCLE1	(0x0aaa << 1)
+  #define FLASH_CYCLE2	(0x0555 << 1)
+  #define FLASH_ID1		0
+  #define FLASH_ID2		2
+  #define FLASH_ID3		0x1c
+  #define FLASH_ID4		0x1E
+#endif
+
+#if defined (CONFIG_TOP5200) && defined (CONFIG_LITE5200)
+  typedef unsigned char FLASH_PORT_WIDTH;
+  typedef volatile unsigned char FLASH_PORT_WIDTHV;
+  #define	FLASH_ID_MASK	0xFF
+
+  #define FPW	FLASH_PORT_WIDTH
+  #define FPWV	FLASH_PORT_WIDTHV
+
+  #define FLASH_CYCLE1	0x0555
+  #define FLASH_CYCLE2	0x02aa
+  #define FLASH_ID1		0
+  #define FLASH_ID2		1
+  #define FLASH_ID3		0x0E
+  #define FLASH_ID4		0x0F
+#endif
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size(FPWV *addr, flash_info_t *info);
+static void flash_reset(flash_info_t *info);
+static int write_word(flash_info_t *info, FPWV *dest, FPW data);
+static flash_info_t *flash_get_info(ulong base);
+void inline spin_wheel (void);
+
+/*-----------------------------------------------------------------------
+ * flash_init()
+ *
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long flash_init (void)
+{
+	unsigned long size = 0;
+	int i = 0;
+    u16   mfgid, devid;
+	extern void flash_preinit(void);
+	extern void flash_afterinit(uint, ulong, ulong);
+	ulong flashbase = CFG_FLASH_BASE;
+
+#if 0
+    EVMDM355_CPLD = 0;
+    EVMDM355_FLASH_CTL555 = 0xf0;
+
+    EVMDM355_FLASH_CTL555 = 0xaa;
+    EVMDM355_FLASH_CTL2AA = 0x55;
+    EVMDM355_FLASH_CTL555 = 0x90;
+	/* The manufacturer codes are only 1 byte, so just use 1 byte.
+	 * This works for any bus width and any FLASH device width.
+	 */
+	udelay(100);
+    mgfid = *((u16*)CFG_FLASH_BASE);
+    devid = *((u16*)CFG_FLASH_BASE +1);
+
+    *((u8 *)CFG_FLASH_BASE) = 0xf0;
+
+    printf("MFGID %x \n", mfgid);
+    printf("DEVIU %x \n", devid);
+    if ((mfgid != 0x0001) || (devid != 0x227e))
+        return 1;
+#endif
+
+	/*flash_preinit();*/
+
+	/* There is only ONE FLASH device */
+	memset(&flash_info[i], 0, sizeof(flash_info_t));
+	flash_info[i].size =
+			flash_get_size((FPW *)flashbase, &flash_info[i]);
+	size += flash_info[i].size;
+
+#if CFG_MONITOR_BASE >= CFG_FLASH_BASE
+	/* monitor protection ON by default */
+	flash_protect(FLAG_PROTECT_SET,
+		      CFG_MONITOR_BASE,
+		      CFG_MONITOR_BASE+monitor_flash_len-1,
+		      flash_get_info(CFG_MONITOR_BASE));
+#endif
+
+#ifdef	CFG_ENV_IS_IN_FLASH
+	/* ENV protection ON by default */
+	flash_protect(FLAG_PROTECT_SET,
+		      CFG_ENV_ADDR,
+		      CFG_ENV_ADDR+CFG_ENV_SIZE-1,
+		      flash_get_info(CFG_ENV_ADDR));
+#endif
+
+
+	/*flash_afterinit(i, flash_info[i].start[0], flash_info[i].size);*/
+	return size ? size : 1;
+}
+
+/*-----------------------------------------------------------------------
+ */
+static void flash_reset(flash_info_t *info)
+{
+	FPWV *base = (FPWV *)(info->start[0]);
+
+	/* Put FLASH back in read mode */
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL)
+		*base = (FPW)0x00FF00FF;	/* Intel Read Mode */
+	else if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD)
+		*base = (FPW)0x00F000F0;	/* AMD Read Mode */
+}
+
+
+void flash_reset_sector(flash_info_t *info, ULONG addr)
+{  
+	// Reset Flash to be in Read Array Mode 
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL)
+		*(FPWV *)addr = (FPW)0x00FF00FF;	/* Intel Read Mode */
+	else if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD)
+		*(FPWV *)addr = (FPW)0x00F000F0;	/* AMD Read Mode */
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+static flash_info_t *flash_get_info(ulong base)
+{
+	int i;
+	flash_info_t * info;
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i ++) {
+		info = & flash_info[i];
+		if (info->size &&
+			info->start[0] <= base && base <= info->start[0] + info->size - 1)
+			break;
+	}
+
+	return i == CFG_MAX_FLASH_BANKS ? 0 : info;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+void flash_print_info (flash_info_t *info)
+{
+	int i;
+	uchar *boottype;
+	uchar *bootletter;
+	uchar *fmt;
+	uchar botbootletter[] = "B";
+	uchar topbootletter[] = "T";
+	uchar botboottype[] = "bottom boot sector";
+	uchar topboottype[] = "top boot sector";
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		printf ("missing or unknown FLASH type\n");
+		return;
+	}
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case FLASH_MAN_AMD:	printf ("MY AMD ");		break;
+#if 0
+	case FLASH_MAN_BM:	printf ("BRIGHT MICRO ");	break;
+	case FLASH_MAN_FUJ:	printf ("FUJITSU ");		break;
+	case FLASH_MAN_SST:	printf ("SST ");		break;
+	case FLASH_MAN_STM:	printf ("STM ");		break;
+#endif
+	case FLASH_MAN_INTEL:	printf ("INTEL ");		break;
+	default:		printf ("Unknown Vendor ");	break;
+	}
+
+	/* check for top or bottom boot, if it applies */
+	if (info->flash_id & FLASH_BTYPE) {
+		boottype = botboottype;
+		bootletter = botbootletter;
+	}
+	else {
+		boottype = topboottype;
+		bootletter = topbootletter;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_AM160T:
+	case FLASH_AM160B:
+		fmt = "29LV160%s (16 Mbit, %s)\n";
+		break;
+	case FLASH_AMLV640U:
+		fmt = "29LV640M (64 Mbit)\n";
+		break;
+	case FLASH_AMDLV065D:
+		fmt = "29LV065D (64 Mbit)\n";
+		break;
+	case FLASH_AMLV256U:
+		fmt = "29LV256M (256 Mbit)\n";
+		break;
+	case FLASH_28F128P30T:
+		fmt = "28F128P30T\n";
+		break;
+    case FLASH_S29GL256N:
+        fmt = "S29GL256N\n";
+        break;
+	default:
+		fmt = "Unknown Chip Type\n";
+		break;
+	}
+
+	printf (fmt, bootletter, boottype);
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+		info->size >> 20,
+		info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+
+	for (i=0; i<info->sector_count; ++i) {
+		ulong	size;
+		int		erased;
+		ulong	*flash = (unsigned long *) info->start[i];
+
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+
+		/*
+		 * Check if whole sector is erased
+		 */
+		size =
+			(i != (info->sector_count - 1)) ?
+			(info->start[i + 1] - info->start[i]) >> 2 :
+		(info->start[0] + info->size - info->start[i]) >> 2;
+
+		for (
+			flash = (unsigned long *) info->start[i], erased = 1;
+				(flash != (unsigned long *) info->start[i] + size) && erased;
+					flash++
+			)
+			erased = *flash == ~0x0UL;
+
+		printf (" %08lX %s %s",
+			info->start[i],
+			erased ? "E": " ",
+			info->protect[i] ? "(RO)" : "    ");
+	}
+
+	printf ("\n");
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+/*
+ * The following code cannot be run from FLASH!
+ */
+
+ulong flash_get_size (FPWV *addr, flash_info_t *info)
+{
+	int		i;
+    u16     mfgid, devid, id3,id4;
+    
+
+	/* Write auto select command: read Manufacturer ID */
+	/* Write auto select command sequence and test FLASH answer */
+    //EVMDM355_CPLD = 0;
+	addr[FLASH_CYCLE1] = (FPW)0x00AA00AA;	/* for AMD, Intel ignores this */
+	addr[FLASH_CYCLE2] = (FPW)0x00550055;	/* for AMD, Intel ignores this */
+	addr[FLASH_CYCLE1] = (FPW)0x00900090;	/* selects Intel or AMD */
+#if 0
+    EVMDM355_FLASH_CTL555 = 0xf0;
+
+    EVMDM355_FLASH_CTL555 = 0xaa;
+    EVMDM355_FLASH_CTL2AA = 0x55;
+    EVMDM355_FLASH_CTL555 = 0x90;
+#endif
+
+	/* The manufacturer codes are only 1 byte, so just use 1 byte.
+	 * This works for any bus width and any FLASH device width.
+	 */
+	udelay(100);
+
+	switch ( (mfgid = addr[FLASH_ID1]) & 0xff) {
+
+	case (uchar)AMD_MANUFACT:
+		printf ("MY AMD ", addr[FLASH_ID1] & 0xff);
+		info->flash_id = FLASH_MAN_AMD;
+		break;
+
+	case (uchar)INTEL_MANUFACT:
+                printf ("INTEL %x", addr[FLASH_ID1] & 0xff);
+		info->flash_id = FLASH_MAN_INTEL;
+		break;
+
+	default:
+		printf ("unknown vendor=%x ", addr[FLASH_ID1] & 0xff);
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		break;
+	}
+
+	/* Check 16 bits or 32 bits of ID so work on 32 or 16 bit bus. */
+	if (info->flash_id != FLASH_UNKNOWN) switch (devid = (FPW)addr[FLASH_ID2]) {
+
+	case (FPW)AMD_ID_LV160B:
+		info->flash_id += FLASH_AM160B;
+		info->sector_count = 35;
+		info->size = 0x00200000;
+		info->start[0] = (ulong)addr;
+		info->start[1] = (ulong)addr + 0x4000;
+		info->start[2] = (ulong)addr + 0x6000;
+		info->start[3] = (ulong)addr + 0x8000;
+		for (i = 4; i < info->sector_count; i++)
+		{
+			info->start[i] = (ulong)addr + 0x10000 * (i-3);
+		}
+		break;
+
+	case (FPW)AMD_ID_LV065D:
+		info->flash_id += FLASH_AMDLV065D;
+		info->sector_count = 128;
+		info->size = 0x00800000;
+		for (i = 0; i < info->sector_count; i++)
+		{
+			info->start[i] = (ulong)addr + 0x10000 * i;
+		}
+		break;
+
+	case (FPW)AMD_ID_MIRROR:
+		/* MIRROR BIT FLASH, read more ID bytes */
+        id3 = (FPW)addr[FLASH_ID3];
+        id4 = (FPW)addr[FLASH_ID4];
+		if ((FPW)addr[FLASH_ID3] == (FPW)AMD_ID_LV640U_2 &&
+			(FPW)addr[FLASH_ID4] == (FPW)AMD_ID_LV640U_3)
+		{
+			info->flash_id += FLASH_AMLV640U;
+			info->sector_count = 128;
+			info->size = 0x00800000;
+			for (i = 0; i < info->sector_count; i++)
+			{
+				info->start[i] = (ulong)addr + 0x10000 * i;
+			}
+			break;
+		}
+		else if ((FPW)addr[FLASH_ID3] == (FPW)AMD_ID_LV256U_2 &&
+			(FPW)addr[FLASH_ID4] == (FPW)AMD_ID_LV256U_3)
+		{
+			/* attention: only the first 16 MB will be used in u-boot */
+			info->flash_id += FLASH_AMLV256U;
+			info->sector_count = 256;
+			info->size = 0x01000000;
+			for (i = 0; i < info->sector_count; i++)
+			{
+				info->start[i] = (ulong)addr + 0x10000 * i;
+			}
+			break;
+		}
+        else
+        {
+            /* This is the default NOR flash for DM355 */
+			info->flash_id += FLASH_S29GL256N;
+			info->sector_count = 256;
+			info->size = 0x02000000;
+			for (i = 0; i < info->sector_count; i++)
+			{
+                info->start[i] = (ulong)addr + 0x20000 * i;
+			}
+			break;
+        }
+	case (FPW)INTEL_ID_28F128P30T:
+		/* Intel StrataFlash 28F128P30T */
+		info->flash_id += FLASH_28F128P30T;
+		info->sector_count = 131;
+		info->size = 0x01000000;
+		for (i = 0; i < info->sector_count; i++)
+		{
+			if (i < 127)
+				info->start[i] = (ulong)addr + 0x20000 * i;
+			else
+				info->start[i] = (ulong)addr + 0xfe0000 + 0x8000 * (i-127);
+		}
+		break;
+
+		/* fall thru to here ! */
+	default:
+		printf ("unknown AMD device=%x %x %x",
+			(FPW)addr[FLASH_ID2],
+			(FPW)addr[FLASH_ID3],
+			(FPW)addr[FLASH_ID4]);
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0x800000;
+		break;
+	}
+
+	/* Put FLASH back in read mode */
+	flash_reset(info);
+
+	return (info->size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int	flash_erase (flash_info_t *info, int s_first, int s_last)
+{
+	FPWV *addr;
+	int flag, prot, sect;
+	int intel = (info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL;
+	ulong start, now, last;
+	int rcode = 0;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		if (info->flash_id == FLASH_UNKNOWN) {
+			printf ("- missing\n");
+		} else {
+			printf ("- no sectors to erase\n");
+		}
+		return 1;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_AM160B:
+	case FLASH_AMLV640U:
+		break;
+	case FLASH_AMLV256U:
+		break;
+	case FLASH_28F128P30T:
+		break;
+    case FLASH_S29GL256N:
+        break;
+	case FLASH_UNKNOWN:
+	default:
+		printf ("Can't erase unknown flash type %08lx - aborted\n",
+			info->flash_id);
+		return 1;
+	}
+
+	prot = 0;
+	for (sect=s_first; sect<=s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n",
+			prot);
+	} else {
+		printf ("\n");
+	}
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect<=s_last && rcode == 0; sect++) {
+
+		if (info->protect[sect] != 0)	/*bmw           esteem192e     ispan         mx1fs2       RPXlite      tqm8540
+ protected, skip it */
+			continue;
+
+		printf ("Erasing sector %2d ... ", sect);
+        
+        if ( sect == s_first )
+        {
+		    addr = (FPWV *)(((info->start[sect]) & EVMDM355_CPLD_MASK) >> 14 );
+        }
+        else
+        { 
+            addr += 2;
+        }
+
+        EVMDM355_CPLD = addr; 
+
+		if (intel) {
+			*addr = (FPW)0x00600060; /* unlock block setup */
+			*addr = (FPW)0x00d000d0; /* unlock block confirm */
+			*addr = (FPW)0x00500050; /* clear status register */
+			*addr = (FPW)0x00200020; /* erase setup */
+			*addr = (FPW)0x00D000D0; /* erase confirm */
+			while((*addr & 0x80) == 0);
+			printf("done.\n");
+		}
+		else {
+			/* must be AMD style if not Intel */
+			FPWV *base;		/* first address in bank */
+
+			base = (FPWV *)(info->start[0]);
+			base[FLASH_CYCLE1] = (FPW)0x00AA00AA;	/* unlock */
+			base[FLASH_CYCLE2] = (FPW)0x00550055;	/* unlock */
+			base[FLASH_CYCLE1] = (FPW)0x00800080;	/* erase mode */
+			base[FLASH_CYCLE1] = (FPW)0x00AA00AA;	/* unlock */
+			base[FLASH_CYCLE2] = (FPW)0x00550055;	/* unlock */
+			base[0] = (FPW)0x00300030;	/* erase sector */
+			while (!(*((vHwdptr)base) & 0x80));
+			printf("done.\n");
+		}
+
+
+	}
+
+    EVMDM355_CPLD = 0; 
+	/* Put FLASH back in read mode */
+	flash_reset(info);
+
+	printf (" Erase Operation Completed.\n");
+	return rcode;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+int write_buff (flash_info_t *info, uchar *src, ulong addr, ulong cnt)
+{
+	FPW data = 0; /* 16 or 32 bit word, matches flash bus width on MPC8XX */
+	int bytes;	  /* number of bytes to program in current word		*/
+	int left;	  /* number of bytes left to program			*/
+	int res;
+	ulong cp, wp;
+	int count, i, l, rc, port_width;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		return 4;
+		}
+
+	/* get lower word aligned address */
+	wp = (addr & ~1);
+	port_width = 2;
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+		for (; i < port_width && cnt > 0; ++i) {
+			data = (data << 8) | *src++;
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < port_width; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+
+		if ((rc = write_word (info, wp, SWAP (data))) != 0) {
+			return (rc);
+		}
+		wp += port_width;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	count = 0;
+	while (cnt >= port_width) {
+		data = 0;
+		for (i = 0; i < port_width; ++i) {
+			data = (data << 8) | *src++;
+		}
+		if ((rc = write_word (info, wp, SWAP (data))) != 0) {
+			return (rc);
+		}
+		wp += port_width;
+		cnt -= port_width;
+
+		if (count++ > 0x800) {
+			spin_wheel ();
+			count = 0;
+		}
+	}
+
+	if (cnt == 0) {
+		return (0);
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < port_width && cnt > 0; ++i, ++cp) {
+		data = (data << 8) | *src++;
+		--cnt;
+	}
+	for (; i < port_width; ++i, ++cp) {
+		data = (data << 8) | (*(uchar *) cp);
+	}
+
+	return (write_word (info, wp, SWAP (data)));
+}
+
+/*-----------------------------------------------------------------------
+ * Write a word to Flash
+ * A word is 16 or 32 bits, whichever the bus width of the flash bank
+ * (not an individual chip) is.
+ *
+ * returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+static int write_word (flash_info_t *info, FPWV *plAddress, FPW ulData)
+{
+	ulong start;
+	int flag;
+	int res = 0;	/* result, assume success	*/
+	FPWV *base;		/* first address in flash bank	*/
+	volatile USHORT *psAddress;
+	volatile USHORT *address_cs;
+	USHORT tmp;
+	ULONG tmp_ptr;
+
+	// Lower WORD.
+	psAddress = (USHORT *)plAddress;
+	tmp_ptr  = (ULONG) plAddress;
+	address_cs = (USHORT *) (tmp_ptr & 0xFE000000);
+
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL)
+	{
+		*plAddress = (FPW)0x00400040;
+		*plAddress = ulData;
+		while ((*plAddress & 0x80) == 0);
+	}
+	else if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD)
+	{
+		*((vHwdptr)address_cs + 0x555) = ((Hwd)0xAA);
+		*((vHwdptr)address_cs + 0x2AA) = ((Hwd)0x55);
+		*((vHwdptr)address_cs + 0x555) = ((Hwd)0xA0);
+		*psAddress = ulData;
+		// Wait for ready.
+		while (1)
+		{
+			tmp = *psAddress; 
+			if( (tmp & 0x80)  == (ulData & 0x80)) 
+			{
+				break;
+			}
+			else
+			{
+				if(tmp & 0x20)             // Exceeded Time Limit
+			{
+				tmp = *psAddress; 
+				if( (tmp & 0x80)  == (ulData & 0x80)) 
+				{
+					break; 
+				}
+				else
+				{
+				  	flash_reset_sector(info, (ULONG) psAddress);
+			      	return 1;
+				}	
+			}
+			}
+		}
+	}
+
+	// Return to read mode
+	flash_reset_sector(info, (ULONG) psAddress);
+
+	// Verify the data.
+	if (*psAddress != ulData)
+	{
+     	return 1;
+	printf("Write of one 16-bit word failed\n");
+	}
+	return 0;
+}
+
+void inline spin_wheel (void)
+{
+	static int p = 0;
+	static char w[] = "\\/-";
+
+	printf ("\010%c", w[p]);
+	(++p == 3) ? (p = 0) : 0;
+}
+#endif
diff -Nurd u-boot-1.2.0/board/dm355_ipnc/flash_params.h u-boot-1.2.0-leopard/board/dm355_ipnc/flash_params.h
--- u-boot-1.2.0/board/dm355_ipnc/flash_params.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_ipnc/flash_params.h	2008-01-05 03:45:25.000000000 -0300
@@ -0,0 +1,319 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ *
+ */
+#ifndef _FLASH_PARAMSH_
+#define _FLASH_PARAMSH_
+//
+//Structs
+//
+typedef struct _PageInfo
+{
+    	ULONG	reserved;
+    	BYTE  	BlockReserved;
+    	BYTE  	BadBlockFlag;
+    	USHORT	reserved2;
+}PageInfo, *PPageInfo;
+
+typedef struct
+{
+	ULONG ReturnValue;
+	ULONG ReadAddress;
+	ULONG WriteAddress;
+	ULONG Size;
+} Download_Parms, *PDownload_Parms;
+
+#define NO_ERROR            0
+#define CORRECTED_ERROR     1
+#define ECC_ERROR           2
+#define UNCORRECTED_ERROR   3
+
+
+#define BIT0    0x00000001
+#define BIT1    0x00000002
+#define BIT2    0x00000004
+#define BIT3    0x00000008
+#define BIT4    0x00000010
+#define BIT5    0x00000020
+#define BIT6    0x00000040
+#define BIT7    0x00000080
+#define BIT8    0x00000100
+#define BIT9    0x00000200
+#define BIT10   0x00000400
+#define BIT11   0x00000800
+#define BIT12   0x00001000
+#define BIT13   0x00002000
+#define BIT14   0x00004000
+#define BIT15   0x00008000
+#define BIT16   0x00010000
+#define BIT17   0x00020000
+#define BIT18   0x00040000
+#define BIT19   0x00080000
+#define BIT20   0x00100000
+#define BIT21   0x00200000
+#define BIT22   0x00400000
+#define BIT23   0x00800000
+#define BIT24   0x01000000
+#define BIT25   0x02000000
+#define BIT26   0x04000000
+#define BIT27   0x08000000
+#define BIT28   0x10000000
+#define BIT29   0x20000000
+#define BIT30   0x40000000
+#define BIT31   0x80000000
+
+
+
+//  Status bit pattern
+#define STATUS_READY                0x40
+#define STATUS_ERROR                0x01
+//
+//NOR SUPPORT
+//
+// Flash ID Commands INTEL
+#define INTEL_ID_CMD       ((Hwd)0x0090)     	// INTEL ID CMD
+#define INTEL_MANF_ID      ((Hwd)0x0089)     	// INTEL Manf ID expected
+#define INTEL_DEVICE_8T    ((Hwd)0x88F1)     	// INTEL 8Mb top device code
+#define INTEL_DEVICE_8B    ((Hwd)0x88F2)     	// INTEL 8Mb bottom device code
+#define INTEL_DEVICE_16T   ((Hwd)0x88F3)     	// INTEL 16Mb top device code
+#define INTEL_DEVICE_16B   ((Hwd)0x88F4)     	// INTEL 16Mb bottom device code
+#define INTELS_J3_DEVICE_32   ((Hwd)0x0016)     // INTEL Strata J3 32Mb device code
+#define INTELS_J3_DEVICE_64   ((Hwd)0x0017)     // INTEL Strata J3 64Mb device code
+#define INTELS_J3_DEVICE_128  ((Hwd)0x0018)     // INTEL Strata J3 128Mb device code
+#define INTELS_K3_DEVICE_64   ((Hwd)0x8801)     // INTEL Strata K3 64Mb device code
+#define INTELS_K3_DEVICE_128  ((Hwd)0x8802)    	// INTEL Strata K3 128Mb device code
+#define INTELS_K3_DEVICE_256  ((Hwd)0x8803)     // INTEL Strata K3 256Mb device code
+#define INTELS_W18_DEVICE_128T  ((Hwd)0x8876)   // INTEL Wirless Flash Top 128 Mb device code
+#define INTELS_W18_DEVICE_128B  ((Hwd)0x8867)   // INTEL Wirless Flash Bottom 128 Mb device code
+#define INTELS_L18_DEVICE_128T  ((Hwd)0x880C)   // INTEL Wirless Flash Top 128 Mb device code
+#define INTELS_L18_DEVICE_128B  ((Hwd)0x880F)   // INTEL Wirless Flash Bottom 128 Mb device code
+#define INTELS_L18_DEVICE_256T  ((Hwd)0x880D)   // INTEL Wirless Flash Top 256 Mb device code
+#define INTELS_L18_DEVICE_256B  ((Hwd)0x8810)  	// INTEL Wirless Flash Bottom 256 Mb device code
+#define INTELS_K18_DEVICE_256B  ((Hwd)0x8807)  	// INTEL Wirless Flash Bottom 256 Mb device code
+#define AMD1_DEVICE_ID     ((Hwd)0x2253)   // AMD29DL323CB
+#define AMD2_DEVICE_ID     ((Hwd)0x2249)   // AMD29LV160D
+#define AMD3_DEVICE_ID1    ((Hwd)0x2212)   // AMD29LV256M
+#define AMD3_DEVICE_ID2    ((Hwd)0x2201)   // AMD29LV256M
+// Flash ID Commands FUJITSU (Programs like AMD)
+#define FUJITSU_MANF_ID    ((Hwd)0x04)        // Fujitsu Manf ID expected
+#define FUJITSU1_DEVICE_ID     ((Hwd)0x2253)  // MBM29DL323BD
+//Micron Programs Like Intel or Micron
+#define MICRON_MANF_ID      ((Hwd)0x002C)     	// MICRON Manf ID expected
+#define MICRON_MT28F_DEVICE_128T ((Hwd)0x4492)	// MICRON Flash device Bottom 128 Mb
+//Samsung Programs like AMD
+#define SAMSUNG_MANF_ID      	((Hwd)0x00EC)     	//SAMSUNG Manf ID expected
+#define SAMSUNG_K8S2815E_128T  	((Hwd) 0x22F8)  	//SAMSUNG NOR Flash device TOP 128 Mb
+// Flash Erase Commands AMD and FUJITSU
+// Flash ID Commands AMD
+#define AMD_ID_CMD0        ((Hwd)0xAA)     // AMD ID CMD 0
+#define AMD_CMD0_ADDR       0x555          // AMD CMD0 Offset
+#define AMD_ID_CMD1        ((Hwd)0x55)     // AMD ID CMD 1
+#define AMD_CMD1_ADDR	    0x2AA          // AMD CMD1 Offset
+#define AMD_ID_CMD2        ((Hwd)0x90)     // AMD ID CMD 2
+#define AMD_CMD2_ADDR	    0x555          // AMD CMD2 Offset
+#define AMD_MANF_ID        ((Hwd)0x01)     // AMD Manf ID expected
+#define AMD_DEVICE_ID_MULTI   ((Hwd)0x227E)// Indicates Multi-Address Device ID
+#define AMD_DEVICE_ID_OFFSET 0x1
+#define AMD_DEVICE_ID_OFFSET1 0x0E         // First Addr for Multi-Address ID
+#define AMD_DEVICE_ID_OFFSET2 0x0F         // Second Addr for Multi-Address ID
+#define AMD_DEVICE_RESET   ((Hwd)0x00F0)   // AMD Device Reset Command
+#define AMD_ERASE_CMD0    ((Hwd)0xAA)
+#define AMD_ERASE_CMD1    ((Hwd)0x55)
+#define AMD_ERASE_CMD2    ((Hwd)0x80)
+#define AMD_ERASE_CMD3    ((Hwd)0xAA)     	// AMD29LV017B Erase CMD 3
+#define AMD_ERASE_CMD4    ((Hwd)0x55)     	// AMD29LV017B Erase CMD 4
+#define AMD_ERASE_CMD5    ((Hwd)0x10)     	// AMD29LV017B Erase CMD 5
+#define AMD_ERASE_DONE    ((Hwd)0xFFFF)     // AMD29LV017B Erase Done
+#define AMD_ERASE_BLK_CMD0	((Hwd)0xAA)
+#define AMD_ERASE_BLK_CMD1	((Hwd)0x55)
+#define AMD_ERASE_BLK_CMD2	((Hwd)0x80)
+#define AMD_ERASE_BLK_CMD3	((Hwd)0xAA)
+#define AMD_ERASE_BLK_CMD4	((Hwd)0x55)
+#define AMD_ERASE_BLK_CMD5	((Hwd)0x30)
+#define AMD_PROG_CMD0    ((Hwd)0xAA)
+#define AMD_PROG_CMD1    ((Hwd)0x55)
+#define AMD_PROG_CMD2    ((Hwd)0xA0)
+#define AMD2_ERASE_CMD0    ((Hwd)0x00AA)     // AMD29DL800B Erase CMD 0
+#define AMD2_ERASE_CMD1    ((Hwd)0x0055)     // AMD29DL800B Erase CMD 1
+#define AMD2_ERASE_CMD2    ((Hwd)0x0080)     // AMD29DL800B Erase CMD 2
+#define AMD2_ERASE_CMD3    ((Hwd)0x00AA)     // AMD29DL800B Erase CMD 3
+#define AMD2_ERASE_CMD4    ((Hwd)0x0055)     // AMD29DL800B Erase CMD 4
+#define AMD2_ERASE_CMD5    ((Hwd)0x0030)     // AMD29DL800B Erase CMD 5
+#define AMD2_ERASE_DONE    ((Hwd)0x00FF)     // AMD29DL800B Erase Done
+#define AMD_WRT_BUF_LOAD_CMD0           ((Hwd)0xAA)
+#define AMD_WRT_BUF_LOAD_CMD1           ((Hwd)0x55)
+#define AMD_WRT_BUF_LOAD_CMD2           ((Hwd)0x25)
+#define AMD_WRT_BUF_CONF_CMD0           ((Hwd)0x29)
+#define AMD_WRT_BUF_ABORT_RESET_CMD0    ((Hwd)0xAA)
+#define AMD_WRT_BUF_ABORT_RESET_CMD1    ((Hwd)0x55)
+#define AMD_WRT_BUF_ABORT_RESET_CMD2    ((Hwd)0xF0)
+// Flash Erase Commands INTEL
+#define INTEL_ERASE_CMD0   ((Hwd)0x0020)     // INTEL Erase CMD 0
+#define INTEL_ERASE_CMD1   ((Hwd)0x00D0)     // INTEL Erase CMD 1
+#define INTEL_ERASE_DONE   ((Hwd)0x0080)     // INTEL Erase Done
+#define INTEL_READ_MODE    ((Hwd)0x00FF)     // INTEL Read Array Mode
+#define STRATA_READ        0x4
+#define STRATA_WRITE       0x8
+// Flash Block Information
+// Intel Burst devices:
+//   2MB each (8 8KB [param] and 31 64KB [main] blocks each) for 8MB total
+#define NUM_INTEL_BURST_BLOCKS 8
+#define PARAM_SET0  0
+#define MAIN_SET0   1
+#define PARAM_SET1  2
+#define MAIN_SET1   3
+#define PARAM_SET2  4
+#define MAIN_SET2   5
+#define PARAM_SET3  6
+#define MAIN_SET3   7
+// Intel Strata devices:
+//   4MB each (32 128KB blocks each) for 8MB total
+//   8MB each (64 128KB blocks each) for 16MB total
+//  16MB each (128 128KB blocks each) for 32MB total
+#define NUM_INTEL_STRATA_BLOCKS 8
+#define BLOCK_SET0  0
+#define BLOCK_SET1  1
+#define BLOCK_SET2  2
+#define BLOCK_SET3  3
+#define BLOCK_SET4  4
+#define BLOCK_SET5  5
+#define BLOCK_SET6  6
+#define BLOCK_SET7  7
+// For AMD Flash
+#define NUM_AMD_SECTORS 8  // Only using the first 8 8-KB sections (64 KB Total)
+#define AMD_ADDRESS_CS_MASK		0xFE000000	//--AMD-- Set-up as 0xFE000000 per Jon Hunter (Ti)
+// Flash Types
+enum NORFlashType {
+	FLASH_NOT_FOUND,
+	FLASH_UNSUPPORTED,
+	FLASH_AMD_LV017_2MB,             	// (AMD AM29LV017B-80RFC/RE)
+	FLASH_AMD_DL800_1MB_BOTTOM,		  	// (AMD AM29DL800BB-70EC)
+	FLASH_AMD_DL800_1MB_TOP,			// (AMD AM29DL800BT-70EC)
+	FLASH_AMD_DL323_4MB_BOTTOM,		  	// (AMD AM29DL323CB-70EC)
+	FLASH_AMD_DL323_4MB_TOP,			// (AMD AM29DL323BT-70EC)
+	FLASH_AMD_LV160_2MB_BOTTOM,
+	FLASH_AMD_LV160_2MB_TOP,
+	FLASH_AMD_LV256M_32MB,             	// (AMD AM29LV256MH/L)
+	FLASH_INTEL_BURST_8MB_BOTTOM,	   	// (Intel DT28F80F3B-95)
+	FLASH_INTEL_BURST_8MB_TOP,		   	// (Intel DT28F80F3T-95)
+	FLASH_INTEL_BURST_16MB_BOTTOM,	   	// (Intel DT28F160F3B-95)
+	FLASH_INTEL_BURST_16MB_TOP,		   	// (Intel DT28F160F3T-95)
+	FLASH_INTEL_STRATA_J3_4MB,		   	// (Intel DT28F320J3A)
+	FLASH_INTEL_STRATA_J3_8MB,		   	// (Intel DT28F640J3A)
+	FLASH_INTEL_STRATA_J3_16MB,		   	// (Intel DT28F128J3A)
+	FLASH_FUJITSU_DL323_4MB_BOTTOM,    	// (Fujitsu DL323 Bottom
+	FLASH_INTEL_STRATA_K3_8MB,		   	// (Intel 28F64K3C115)
+	FLASH_INTEL_STRATA_K3_16MB,        	// (Intel 28F128K3C115)
+	FLASH_INTEL_STRATA_K3_32MB,        	// (Intel 28F256K3C115)
+	FLASH_INTEL_W18_16MB_TOP,    		// (Intel 28F128W18T) }
+	FLASH_INTEL_W18_16MB_BOTTOM,  		// (Intel 28F128W18B) }
+	FLASH_INTEL_L18_16MB_TOP,    		// (Intel 28F128L18T) }
+	FLASH_INTEL_L18_16MB_BOTTOM,  		// (Intel 28F128L18B) }
+	FLASH_INTEL_L18_32MB_TOP,    		// (Intel 28F256L18T) }
+	FLASH_INTEL_L18_32MB_BOTTOM,  		// (Intel 28F256L18B) }
+	FLASH_INTEL_K18_32MB_BOTTOM,  		// (Intel 28F256K18B) }
+	FLASH_MICRON_16MB_TOP,				// (Micron MT28F160C34 )
+	FLASH_SAMSUNG_16MB_TOP				// (Samsung K8S281ETA)
+};
+////NAND SUPPORT
+//
+enum NANDFlashType {
+	NANDFLASH_NOT_FOUND,
+	NANDFLASH_SAMSUNG_32x8_Q,             	// (Samsung K9F5608Q0B)
+	NANDFLASH_SAMSUNG_32x8_U,             	// (Samsung K9F5608U0B)
+	NANDFLASH_SAMSUNG_16x16_Q,             	// (Samsung K9F5616Q0B)
+	NANDFLASH_SAMSUNG_16x16_U,             	// (Samsung K9F5616U0B)
+	NANDFLASH_SAMSUNG_16x8_U				// (Samsung K9F1G08QOM)
+};
+// Samsung Manufacture Code
+#define SAMSUNG_MANUFACT_ID	0xEC
+// Samsung Nand Flash Device ID
+#define SAMSUNG_K9F5608Q0B	0x35
+#define SAMSUNG_K9F5608U0B	0x75
+#define SAMSUNG_K9F5616Q0B	0x45
+#define SAMSUNG_K9F5616U0B	0x55
+//  MACROS for NAND Flash support
+//  Flash Chip Capability
+#define NUM_BLOCKS                  0x800       //  32 MB On-board NAND flash.
+#define PAGE_SIZE                 	512
+#define SPARE_SIZE                  16
+#define PAGES_PER_BLOCK             32
+#define PAGE_TO_BLOCK(page)     	((page) >> 5 )
+#define BLOCK_TO_PAGE(block)      	((block)  << 5 )
+#define FILE_TO_PAGE_SIZE(fs) 		((fs / PAGE_SIZE) + ((fs % PAGE_SIZE) ? 1 : 0))
+//  For flash chip that is bigger than 32 MB, we need to have 4 step address
+#ifdef NAND_SIZE_GT_32MB
+#define NEED_EXT_ADDR               1
+#else
+#define NEED_EXT_ADDR               0
+#endif
+// Nand flash block status definitions.
+#define BLOCK_STATUS_UNKNOWN	0x01
+#define BLOCK_STATUS_BAD		0x02
+#define BLOCK_STATUS_READONLY	0x04
+#define BLOCK_STATUS_RESERVED   0x08
+#define BLOCK_RESERVED			0x01
+#define BLOCK_READONLY			0x02
+#define BADBLOCKMARK            0x00
+//  NAND Flash Command. This appears to be generic across all NAND flash chips
+#define CMD_READ                0x00        //  Read
+#define CMD_READ1               0x01        //  Read1
+#define CMD_READ2               0x50        //  Read2
+#define CMD_READID              0x90        //  ReadID
+#define CMD_WRITE               0x80        //  Write phase 1
+#define CMD_WRITE2              0x10        //  Write phase 2
+#define CMD_ERASE               0x60        //  Erase phase 1
+#define CMD_ERASE2              0xd0        //  Erase phase 2
+#define CMD_STATUS              0x70        //  Status read
+#define CMD_RESET               0xff        //  Reset
+//
+//Prototpyes
+//
+// NOR Flash Dependent Function Pointers
+void (*User_Hard_Reset_Flash)(void);
+void (*User_Soft_Reset_Flash)(unsigned long addr);
+void (*User_Flash_Erase_Block)(unsigned long addr);
+void (*User_Flash_Erase_All)(unsigned long addr);
+void (*User_Flash_Write_Entry)(void);
+int (*User_Flash_Write)(unsigned long *addr, unsigned short data);
+int (*User_Flash_Optimized_Write)(unsigned long *addr, unsigned short data[], unsigned long);
+void (*User_Flash_Write_Exit)(void);
+// Flash AMD Device Dependent Routines
+void AMD_Hard_Reset_Flash(void);
+void AMD_Soft_Reset_Flash(unsigned long);
+void AMD_Flash_Erase_Block(unsigned long);
+void AMD_Flash_Erase_All(unsigned long);
+int AMD_Flash_Write(unsigned long *, unsigned short);
+int AMD_Flash_Optimized_Write(unsigned long *addr, unsigned short data[], unsigned long length);
+void AMD_Write_Buf_Abort_Reset_Flash( unsigned long plAddress );
+// Flash Intel Device Dependent Routines
+void INTEL_Hard_Reset_Flash(void);
+void INTEL_Soft_Reset_Flash(unsigned long addr);
+void INTEL_Flash_Erase_Block(unsigned long);
+int INTEL_Flash_Write(unsigned long *addr, unsigned short data);
+int INTEL_Flash_Optimized_Write(unsigned long *addr, unsigned short data[], unsigned long length);
+
+//General Functions
+void Flash_Do_Nothing(void);
+
+#endif
+
+
diff -Nurd u-boot-1.2.0/board/dm355_ipnc/lowlevel_init.S u-boot-1.2.0-leopard/board/dm355_ipnc/lowlevel_init.S
--- u-boot-1.2.0/board/dm355_ipnc/lowlevel_init.S	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_ipnc/lowlevel_init.S	2008-01-05 03:45:25.000000000 -0300
@@ -0,0 +1,766 @@
+/*
+ * Board specific setup info
+ *
+ * (C) Copyright 2003
+ * Texas Instruments, <www.ti.com>
+ * Kshitij Gupta <Kshitij@ti.com>
+ *
+ * Modified for OMAP 1610 H2 board by Nishant Kamat, Jan 2004
+ *
+ * Modified for OMAP 5912 OSK board by Rishi Bhattacharya, Apr 2004
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ * 
+ * Modified for DV-EVM board by Rishi Bhattacharya, Apr 2005
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * Modified for DV-EVM board by Swaminathan S, Nov 2005
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+#if defined(CONFIG_OMAP1610)
+#include <./configs/omap1510.h> 
+#endif
+
+_TEXT_BASE:
+	.word	TEXT_BASE	/* sdram load addr from config.mk */
+
+.global reset_cpu
+reset_cpu:
+	bl reset_processor
+
+
+.globl lowlevel_init
+lowlevel_init:
+	/*mov	pc,	lr*/
+	
+	/*------------------------------------------------------*
+	 * mask all IRQs by setting all bits in the EINT default *
+	 *------------------------------------------------------*/
+	mov	r1, #0x00000000
+	ldr	r0, =EINT_ENABLE0
+	str	r1, [r0]
+	ldr	r0, =EINT_ENABLE1
+	str	r1, [r0]
+
+	/*------------------------------------------------------*
+	 * Put the GEM in reset		    		  *
+ 	 *------------------------------------------------------*/
+
+      /* Put the GEM in reset */
+  	/* bhavinp: commented: No GEM in DM350*/	
+#if 0
+	LDR R8, PSC_GEM_FLAG_CLEAR
+	LDR R6, MDCTL_GEM
+	LDR R7, [R6]
+	AND R7, R7, R8
+	STR R7, [R6]
+
+	/* Enable the Power Domain Transition Command */
+	LDR R6, PTCMD_0
+	LDR R7, [R6]
+	ORR R7, R7, #0x2
+	STR R7, [R6]
+
+	/* Check for Transition Complete(PTSTAT) */
+checkStatClkStopGem:
+	LDR R6, PTSTAT_0
+	LDR R7, [R6]
+    	AND R7, R7, #0x2
+    	CMP R7, #0x0
+    	BNE checkStatClkStopGem
+
+	/* Check for GEM Reset Completion */
+checkGemStatClkStop:
+	LDR R6, MDSTAT_GEM
+	LDR R7, [R6]
+    	AND R7, R7, #0x100
+    	CMP R7, #0x0
+    	BNE checkGemStatClkStop
+
+	/* Do this for enabling a WDT initiated reset this is a workaround
+	   for a chip bug.  Not required under normal situations */
+	LDR R6, P1394
+	MOV R10, #0x0	
+	STR R10, [R6]
+#endif 	//bhavinp: commented: End
+	/*------------------------------------------------------*
+	 * Enable L1 & L2 Memories in Fast mode                 *
+	 *------------------------------------------------------*/
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x1
+	STR R10, [R6]
+
+	LDR R6, MMARG_BRF0
+	LDR R10, MMARG_BRF0_VAL
+	STR R10, [R6]
+
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x0
+	STR R10, [R6]
+	/*------------------------------------------------------*
+	 * DDR2 PLL Intialization			    	*
+ 	 *------------------------------------------------------*/
+	
+      /* Select the Clock Mode Depending on the Value written in the Boot Table by the run script */
+	MOV R10, #0x0
+	LDR R6, PLL2_CTL   
+	LDR R7, PLL_CLKSRC_MASK
+	LDR R8, [R6]
+	AND R8, R8, R7
+	MOV R9, R10, LSL #0x8
+	ORR R8, R8, R9
+	STR R8, [R6]
+	
+	/* Select the PLLEN source */
+	LDR R7, PLL_ENSRC_MASK
+	AND R8, R8, R7
+	STR R8, [R6]
+	
+	/* Bypass the PLL */
+	LDR R7, PLL_BYPASS_MASK
+	AND R8, R8, R7
+	STR R8, [R6]
+	
+	/* Wait for few cycles to allow PLLEN Mux switches properly to bypass Clock */
+	MOV R10, #0x20 
+WaitPPL2Loop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE WaitPPL2Loop	
+
+     /* Reset the PLL */
+    	LDR R7, PLL_RESET_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+     /* Power up the PLL */
+    	LDR R7, PLL_PWRUP_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+     /* Enable the PLL from Disable Mode */
+    	LDR R7, PLL_DISABLE_ENABLE_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+	/* Program the PLL Multiplier */
+	LDR R6, PLL2_PLLM
+	/*MOV R2, #0x13 Orig value */
+	/*MOV R2, #0xB 165MHz */
+	/*MOV R2, #0xD 189 MHz */
+	MOV R2, #0x17 /* 162 MHz */
+	STR R2, [R6]   /* R2 */
+
+	/* Program the PLL2 Divisior Value */
+	LDR R6, PLL2_DIV2
+	MOV R3, #0x1 /* Orig */
+	/*MOV R3, #0x0*/
+	STR R3, [R6]    /* R3 */
+
+	/* Program the PLL2 Divisior Value */
+	LDR R6, PLL2_DIV1
+	/*MOV R4, #0x9 Orig */
+	/*MOV R4, #0x5 165MHz */
+	/*MOV R4, #0x6 189 MHz */
+	MOV R4, #0xB /* 54 MHz */
+	STR R4, [R6]    /* R4 */
+
+      /* PLL2 DIV1 MMR */
+	LDR R8, PLL2_DIV_MASK
+	LDR R6, PLL2_DIV2
+	LDR R9, [R6]
+	AND R8, R8, R9
+	MOV R9, #0X1
+	MOV R9, R9, LSL #15
+	ORR R8, R8, R9
+	STR R8, [R6]
+
+	/* Program the GOSET bit to take new divier values */
+	LDR R6, PLL2_PLLCMD
+	LDR R7, [R6]
+	ORR R7, R7, #0x1
+	STR R7, [R6]
+
+      /* Wait for Done */
+    	LDR R6, PLL2_PLLSTAT
+doneLoop_0:    
+    	LDR R7, [R6]
+    	AND R7, R7, #0x1
+    	CMP R7, #0x0
+    	BNE doneLoop_0
+
+      /* PLL2 DIV2 MMR */
+	LDR R8, PLL2_DIV_MASK
+	LDR R6, PLL2_DIV1
+	LDR R9, [R6]
+	AND R8, R8, R9
+	MOV R9, #0X1
+	MOV R9, R9, LSL #15
+	ORR R8, R8, R9
+	STR R8, [R6]
+
+	/* Program the GOSET bit to take new divier values */
+	LDR R6, PLL2_PLLCMD
+	LDR R7, [R6]
+	ORR R7, R7, #0x1
+	STR R7, [R6]
+
+     /* Wait for Done */
+    	LDR R6, PLL2_PLLSTAT
+doneLoop:    
+    	LDR R7, [R6]
+    	AND R7, R7, #0x1
+    	CMP R7, #0x0
+    	BNE doneLoop
+    				
+	/* Wait for PLL to Reset Properly */
+	MOV R10, #0x218  
+ResetPPL2Loop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE ResetPPL2Loop
+    
+    	/* Bring PLL out of Reset */
+    	LDR R6, PLL2_CTL    	
+    	LDR R8, [R6]
+    	ORR R8, R8, #0x08
+    	STR R8, [R6]
+     	
+     /* Wait for PLL to Lock */
+	LDR R10, PLL_LOCK_COUNT    
+PLL2Lock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE PLL2Lock
+    
+     /* Enable the PLL */
+    	LDR R6, PLL2_CTL    	
+    	LDR R8, [R6]
+    	ORR R8, R8, #0x01
+    	STR R8, [R6]
+
+	/*------------------------------------------------------*
+	 * Issue Soft Reset to DDR Module		    		  *
+ 	 *------------------------------------------------------*/
+
+      /* Shut down the DDR2 LPSC Module */
+  	LDR R8, PSC_FLAG_CLEAR
+	LDR R6, MDCTL_DDR2_0
+	LDR R7, [R6]
+	AND R7, R7, R8
+	ORR R7, R7, #0x3
+	STR R7, [R6]  
+
+	/* Enable the Power Domain Transition Command */
+	LDR R6, PTCMD_0
+	LDR R7, [R6]
+	ORR R7, R7, #0x1
+	STR R7, [R6]    
+	
+	/* Check for Transition Complete(PTSTAT) */
+checkStatClkStop:	
+	LDR R6, PTSTAT_0
+	LDR R7, [R6]
+    	AND R7, R7, #0x1	
+    	CMP R7, #0x0
+    	BNE checkStatClkStop  
+    
+	/* Check for DDR2 Controller Enable Completion */
+checkDDRStatClkStop:	
+	LDR R6, MDSTAT_DDR2_0
+	LDR R7, [R6]
+    	AND R7, R7, #0x1F	
+    	CMP R7, #0x3
+    	BNE checkDDRStatClkStop  
+
+	/*------------------------------------------------------*
+	 * Program DDR2 MMRs for 162MHz Setting	    		  *
+ 	 *------------------------------------------------------*/
+	
+	/* Program PHY Control Register */
+	LDR R6, DDRCTL
+	LDR R7, DDRCTL_VAL
+	STR R7, [R6]
+
+	/* Program SDRAM Bank Config Register */
+	LDR R6, SDCFG
+	LDR R7, SDCFG_VAL
+	STR R7, [R6]
+
+	/* Program SDRAM TIM-0 Config Register */
+	LDR R6, SDTIM0
+	LDR R7, SDTIM0_VAL_162MHz
+	STR R7, [R6]		
+
+	/* Program SDRAM TIM-1 Config Register */
+	LDR R6, SDTIM1
+	LDR R7, SDTIM1_VAL_162MHz
+	STR R7, [R6]		
+
+	/* Program the SDRAM Bang Config Control Register */
+	LDR R10, MASK_VAL
+	LDR R8, SDCFG
+	LDR R9, SDCFG_VAL
+	AND R9, R9, R10
+	STR R9, [R8]
+
+	/* Program SDRAM TIM-1 Config Register */
+	LDR R6, SDREF
+	LDR R7, SDREF_VAL
+	STR R7, [R6]		
+
+        /*------------------------------------------------------*
+         * Issue Soft Reset to DDR Module                                 *
+         *------------------------------------------------------*/
+                                                                                
+        /* Issue a Dummy DDR2 read/write */
+        LDR R8, DDR2_VAL
+        LDR R7, DUMMY_VAL
+        STR R7, [R8]
+        LDR R7, [R8]
+                                                                                
+      /* Shut down the DDR2 LPSC Module */
+        LDR R8, PSC_FLAG_CLEAR
+        LDR R6, MDCTL_DDR2_0
+        LDR R7, [R6]
+        AND R7, R7, R8
+        ORR R7, R7, #0x1
+        STR R7, [R6]
+                                                                                
+        /* Enable the Power Domain Transition Command */
+        LDR R6, PTCMD_0
+        LDR R7, [R6]
+        ORR R7, R7, #0x1
+        STR R7, [R6]
+                                                                                
+        /* Check for Transition Complete(PTSTAT) */
+checkStatClkStop2:
+        LDR R6, PTSTAT_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1
+        CMP R7, #0x0
+        BNE checkStatClkStop2
+                                                                                
+        /* Check for DDR2 Controller Enable Completion */
+checkDDRStatClkStop2:
+        LDR R6, MDSTAT_DDR2_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1F
+        CMP R7, #0x1
+        BNE checkDDRStatClkStop2
+
+        /*------------------------------------------------------*
+         * Turn DDR2 Controller Clocks On                                 *
+         *------------------------------------------------------*/
+                                                                                
+     /* Enable the DDR2 LPSC Module */
+        LDR R6, MDCTL_DDR2_0
+        LDR R7, [R6]
+        ORR R7, R7, #0x3
+        STR R7, [R6]
+                                                                                
+        /* Enable the Power Domain Transition Command */
+        LDR R6, PTCMD_0
+        LDR R7, [R6]
+        ORR R7, R7, #0x1
+        STR R7, [R6]
+                                                                                
+        /* Check for Transition Complete(PTSTAT) */
+checkStatClkEn2:
+        LDR R6, PTSTAT_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1
+        CMP R7, #0x0
+        BNE checkStatClkEn2
+                                                                                
+        /* Check for DDR2 Controller Enable Completion */
+checkDDRStatClkEn2:
+        LDR R6, MDSTAT_DDR2_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1F
+        CMP R7, #0x3
+        BNE checkDDRStatClkEn2
+                                                                                
+        /*  DDR Writes and Reads */
+        LDR R6, CFGTEST
+        MOV R3, #0x1
+        STR R3, [R6]    /* R3 */
+
+	/*------------------------------------------------------*
+	 * System PLL Intialization			    		  *
+ 	 *------------------------------------------------------*/
+
+      /* Select the Clock Mode Depending on the Value written in the Boot Table by the run script */
+	MOV R2, #0x0
+	LDR R6, PLL1_CTL   
+	LDR R7, PLL_CLKSRC_MASK
+	LDR R8, [R6]
+	AND R8, R8, R7
+	MOV R9, R2, LSL #0x8
+	ORR R8, R8, R9
+	STR R8, [R6]
+	
+	/* Select the PLLEN source */
+	LDR R7, PLL_ENSRC_MASK
+	AND R8, R8, R7
+	STR R8, [R6]
+	
+	/* Bypass the PLL */
+	LDR R7, PLL_BYPASS_MASK
+	AND R8, R8, R7
+	STR R8, [R6]
+	
+	/* Wait for few cycles to allow PLLEN Mux switches properly to bypass Clock */
+	MOV R10, #0x20 
+
+WaitLoop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE WaitLoop	
+
+     /* Reset the PLL */
+    	LDR R7, PLL_RESET_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+      /* Disable the PLL */
+    	ORR R8, R8, #0x10    
+    	STR R8, [R6]
+
+      /* Power up the PLL */
+    	LDR R7, PLL_PWRUP_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+      /* Enable the PLL from Disable Mode */
+    	LDR R7, PLL_DISABLE_ENABLE_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+	/* Program the PLL Multiplier */
+	LDR R6, PLL1_PLLM
+	/*MOV R3, #0x10  As per Amit, PLL should be in normal mode i.e X by 16 */
+	/*MOV R3, #0x11  As per Ebby 486 MHz */
+	/*MOV R3, #0x14  For 567MHz */
+	MOV R3, #0x15 /* For 594MHz */
+	STR R3, [R6]      
+
+	/* Wait for PLL to Reset Properly */
+	MOV R10, #0xFF 
+
+ResetLoop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE ResetLoop
+    
+      /* Bring PLL out of Reset */
+    	LDR R6, PLL1_CTL    	
+    	ORR R8, R8, #0x08
+    	STR R8, [R6]
+     	
+      /* Wait for PLL to Lock */
+	LDR R10, PLL_LOCK_COUNT    
+
+PLL1Lock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE PLL1Lock
+    
+      /* Enable the PLL */
+    	ORR R8, R8, #0x01
+    	STR R8, [R6]
+
+	nop
+	nop	
+	nop
+	nop
+
+	/*------------------------------------------------------*
+	 * AEMIF configuration for NOR Flash (double check)     *
+	 *------------------------------------------------------*/
+	LDR R0, _PINMUX0
+	LDR R1, _DEV_SETTING
+	STR R1, [R0]
+
+ 	LDR R0, WAITCFG   
+	LDR R1, WAITCFG_VAL 
+	LDR R2, [R0]
+	ORR R2, R2, R1
+	STR R2, [R0]    
+
+	LDR R0, ACFG3
+	LDR R1, ACFG3_VAL
+	LDR R2, [R0]
+	AND R1, R2, R1
+	STR R1, [R0]
+
+	LDR R0, ACFG4
+	LDR R1, ACFG4_VAL
+	LDR R2, [R0]
+	AND R1, R2, R1
+	STR R1, [R0]
+
+	LDR R0, ACFG5
+	LDR R1, ACFG5_VAL
+	LDR R2, [R0]
+	AND R1, R2, R1
+	STR R1, [R0]     
+
+	/*--------------------------------------*
+	 * VTP manual Calibration               *
+	 *--------------------------------------*/
+	LDR R0, VTPIOCR
+	LDR R1, VTP_MMR0
+	STR R1, [R0]
+
+	LDR R0, VTPIOCR
+	LDR R1, VTP_MMR1
+	STR R1, [R0]
+	
+     /* Wait for 33 VTP CLK cycles.  VRP operates at 27 MHz */
+	LDR R10, VTP_LOCK_COUNT    
+VTPLock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE VTPLock
+
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x1
+	STR R10, [R6]
+
+	LDR R6, DDRVTPR
+	LDR R7, [R6]
+	AND R7, R7, #0x1F
+	AND R8, R7, #0x3E0
+	ORR R8, R7, R8
+	LDR R7, VTP_RECAL
+	ORR R8, R7, R8
+	LDR R7, VTP_EN
+	ORR R8, R7, R8
+	STR R8, [R0]
+
+
+     /* Wait for 33 VTP CLK cycles.  VRP operates at 27 MHz */
+	LDR R10, VTP_LOCK_COUNT    
+VTP1Lock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE VTP1Lock
+
+	LDR R1, [R0]
+	LDR R2, VTP_MASK
+	AND R2, R1, R2
+	STR R2, [R0]
+
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x0
+	STR R10, [R6]
+
+
+	/* Start MPU Timer 1 */
+/*	MOV R10, #0x1AFFFFFF
+
+WaitRam:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE WaitRam
+*/
+
+	/* back to arch calling code */
+	mov	pc,	lr
+
+	/* the literal pools origin */
+	.ltorg
+
+REG_TC_EMIFS_CONFIG:		/* 32 bits */
+	.word 0xfffecc0c
+REG_TC_EMIFS_CS0_CONFIG:	/* 32 bits */
+	.word 0xfffecc10
+REG_TC_EMIFS_CS1_CONFIG:	/* 32 bits */
+	.word 0xfffecc14
+REG_TC_EMIFS_CS2_CONFIG:	/* 32 bits */
+	.word 0xfffecc18
+REG_TC_EMIFS_CS3_CONFIG:	/* 32 bits */
+	.word 0xfffecc1c
+
+_PINMUX0:		.word 0x01C40000		/* Device Configuration Registers */
+_PINMUX1:		.word 0x01C40004		/* Device Configuration Registers */
+
+_DEV_SETTING:		.word 0x00000C1F
+
+AEMIF_BASE_ADDR:	.word 0x01E10000
+WAITCFG:         	.word 0x01E10004
+ACFG2:           	.word 0x01E10010
+ACFG3:           	.word 0x01E10014
+ACFG4:           	.word 0x01E10018
+ACFG5:           	.word 0x01E1001C
+
+WAITCFG_VAL:     	.word 0x0
+ACFG2_VAL:       	.word 0x3FFFFFFD
+ACFG3_VAL:       	.word 0x3FFFFFFD
+ACFG4_VAL:       	.word 0x3FFFFFFD
+ACFG5_VAL:       	.word 0x3FFFFFFD
+
+MDCTL_DDR2:		.word 0x01C41A34
+PTCMD:		.word 0x01C41120
+PTSTAT:		.word 0x01C41128
+MDSTAT_DDR2:	.word 0x01C41834
+
+MDCTL_TPCC:		.word	0x01C41A08
+MDSTAT_TPCC:	.word 0x01C41808
+
+MDCTL_TPTC0:	.word	0x01C41A0C
+MDSTAT_TPTC0:	.word 0x01C4180C
+
+MDCTL_TPTC1:	.word	0x01C41A10
+MDSTAT_TPTC1:	.word 0x01C41810
+
+DDR2DEBUG:		.word 0x8FFFF000
+
+/* EINT0 register */
+EINT_ENABLE0:
+	.word 0x01c48018
+
+/* EINT1 register */
+EINT_ENABLE1:
+	.word 0x01c4801C
+
+CLEAR_FLAG:				.word 0xFFFFFFFF
+EDMA_PARAM0_D_S_BIDX_VAL: 	.word 0x00010001
+PSC_FLAG_CLEAR:			.word 0xFFFFFFE0
+PSC_GEM_FLAG_CLEAR:			.word 0xFFFFFEFF
+MDCTL_TPCC_SYNC:			.word 0x01C41A08
+MDSTAT_TPCC_SYNC:			.word 0x01C41808
+
+MDCTL_TPTC0_SYNC:			.word 0x01C41A0C
+MDSTAT_TPTC0_SYNC:		.word 0x01C4180C
+
+MDCTL_TPTC1_SYNC:			.word 0x01C41A10
+MDSTAT_TPTC1_SYNC:		.word 0x01C41810
+
+PTCMD_SYNC:				.word 0x01C41120
+PTSTAT_SYNC:			.word 0x01C41128
+DATA_MAX:				.word 0x0000FFFF
+SPIN_ADDR:				.word 0x00003FFC   /* ARM PC value(B $) for the DSP Test cases */
+SPIN_OPCODE:			.word 0xEAFFFFFE
+
+/* Interrupt Clear Register */
+FIQ0_CLEAR:				.word 0x01C48000
+FIQ1_CLEAR:				.word 0x01C48004
+IRQ0_CLEAR:				.word 0x01C48008
+IRQ1_CLEAR:				.word 0x01C4800C
+
+/* DDR2 MMR & CONFIGURATION VALUES for 75 MHZ */
+DDRCTL:				.word	0x200000E4
+SDREF:				.word	0x2000000C
+SDCFG:				.word	0x20000008
+SDTIM0:				.word	0x20000010
+SDTIM1:				.word	0x20000014
+SDSTAT:				.word 0x20000004
+VTPIOCR:				.word 0x200000F0  /* VTP IO Control register */
+DDRVTPR:				.word 0x01C42030  /* DDR VPTR MMR */
+DFT_ENABLE:				.word 0x01C4004C
+VTP_MMR0:				.word 0x201F
+VTP_MMR1:				.word 0xA01F
+PCH_MASK:				.word 0x3E0
+VTP_LOCK_COUNT:				.word 0x5b0
+VTP_MASK:				.word 0xFFFFDFFF
+VTP_RECAL:				.word 0x40000
+VTP_EN:					.word 0x02000
+
+
+CFGTEST:				.word	0x80010000
+
+/* original values					
+DDRCTL_VAL:				.word	0x50006405
+SDCFG_VAL:				.word	0x00008832
+MASK_VAL:                    	.word 0x00000FFF
+SDTIM0_VAL_135MHz:		.word	0x30923A91
+SDTIM1_VAL_135MHz:		.word	0x0019c722
+SDREF_VAL:				.word 0x000005c3
+*/
+
+/* 162MHz as per GEL file for DVEVM with Micron DDR2 SDRAM */
+DDRCTL_VAL:                     .word   0x50006405
+SDCFG_VAL:                      .word   0x00178632           /* CL=3 for MT47H64M16BT-5E */
+MASK_VAL:                       .word   0xFFFF7FFF
+SDTIM0_VAL_162MHz:              .word   0x28923211
+SDTIM1_VAL_162MHz:              .word   0x0016c722
+SDREF_VAL:                      .word   0x000004F0
+
+/* GEM Power Up & LPSC Control Register */
+CHP_SHRTSW:				.word 0x01C40038
+
+PD1_CTL:				.word	0x01C41304
+EPCPR:				.word	0x01C41070
+EPCCR:				.word	0x01C41078
+MDCTL_GEM:				.word	0x01C41A9C
+MDSTAT_GEM:				.word 0x01C4189C
+MDCTL_IMCOP:			.word	0x01C41AA0
+MDSTAT_IMCOP:			.word 0x01C418A0
+
+PTCMD_0:				.word 0x01C41120
+PTSTAT_0:				.word 0x01C41128
+P1394:					.word 0x01C41a20
+
+PLL_CLKSRC_MASK: 			.word 0xFFFFFEFF  /* Mask the Clock Mode bit and it is programmble through the run script */
+PLL_ENSRC_MASK:  			.word 0xFFFFFFDF  /* Select the PLLEN source */
+PLL_BYPASS_MASK: 			.word 0xFFFFFFFE  /* Put the PLL in BYPASS, eventhough the device */
+PLL_RESET_MASK:  			.word 0xFFFFFFF7  /* Put the PLL in Reset Mode */
+PLL_PWRUP_MASK:  			.word 0xFFFFFFFD  /* PLL Power up Mask Bit  */
+PLL_DISABLE_ENABLE_MASK:	.word 0xFFFFFFEF  /* Enable the PLL from Disable */
+PLL_LOCK_COUNT:          	.word 0x2000
+
+/* PLL1-SYSTEM PLL MMRs */
+PLL1_CTL:				.word 0x01C40900 
+PLL1_PLLM:				.word 0x01C40910
+
+/* PLL2-SYSTEM PLL MMRs */
+PLL2_CTL:				.word 0x01C40D00 
+PLL2_PLLM:				.word 0x01C40D10
+PLL2_DIV2:				.word 0x01C40D1C
+PLL2_DIV1:				.word 0x01C40D18
+PLL2_PLLCMD:			.word 0x01C40D38
+PLL2_PLLSTAT:			.word 0x01C40D3C	
+PLL2_BPDIV:				.word 0x01C40D2C
+PLL2_DIV_MASK:			.word 0xFFFF7FFF
+
+
+MDCTL_DDR2_0:			.word 0x01C41A34
+MDSTAT_DDR2_0:			.word 0x01C41834
+DLLPWRUPMASK:			.word 0xFFFFFFEF
+DDR2_ADDR:			.word 0x80000000
+
+DFT_BASEADDR:			.word 0x01C42000
+MMARG_BRF0:			.word 0x01C42010     /* BRF margin mode 0     (Read / write)*/
+MMARG_G10:			.word 0x01C42018     /*GL margin mode 0      (Read / write)*/
+MMARG_BRF0_VAL:			.word 0x00444400
+DDR2_VAL:			.word 0x80000000
+DUMMY_VAL:			.word 0xA55AA55A
+
+/* command values */
+.equ CMD_SDRAM_NOP,		0x00000000
+.equ CMD_SDRAM_PRECHARGE,	0x00000001
+.equ CMD_SDRAM_AUTOREFRESH,	0x00000002
+.equ CMD_SDRAM_CKE_SET_HIGH,	0x00000007
diff -Nurd u-boot-1.2.0/board/dm355_ipnc/nand.c u-boot-1.2.0-leopard/board/dm355_ipnc/nand.c
--- u-boot-1.2.0/board/dm355_ipnc/nand.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_ipnc/nand.c	2008-05-20 03:57:42.000000000 -0300
@@ -0,0 +1,830 @@
+/*
+ * NAND driver for TI DaVinci based boards.
+ *
+ * Copyright (C) 2007 Sergey Kubushyn <ksi@koi8.net>
+ *
+ * Based on Linux DaVinci NAND driver by TI. Original copyright follows:
+ */
+
+/*
+ *
+ * linux/drivers/mtd/nand/nand_dm355.c
+ *
+ * NAND Flash Driver
+ *
+ * Copyright (C) 2006 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ *
+ *  Overview:
+ *   This is a device driver for the NAND flash device found on the
+ *   DaVinci board which utilizes the Samsung k9k2g08 part.
+ *
+ Modifications:
+ ver. 1.0: Feb 2005, Vinod/Sudhakar
+ -
+ *
+ */
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+#if !defined(CFG_NAND_LEGACY)
+
+#include <asm/arch/types.h>
+//#include "soc.h"
+#include <nand.h>
+#include <asm/arch/nand_defs.h>
+#include <asm/arch/emif_defs.h>
+
+#define NAND_Ecc_P1e            (1 << 0)
+#define NAND_Ecc_P2e            (1 << 1)
+#define NAND_Ecc_P4e            (1 << 2)
+#define NAND_Ecc_P8e            (1 << 3)
+#define NAND_Ecc_P16e           (1 << 4)
+#define NAND_Ecc_P32e           (1 << 5)
+#define NAND_Ecc_P64e           (1 << 6)
+#define NAND_Ecc_P128e          (1 << 7)
+#define NAND_Ecc_P256e          (1 << 8)
+#define NAND_Ecc_P512e          (1 << 9)
+#define NAND_Ecc_P1024e         (1 << 10)
+#define NAND_Ecc_P2048e         (1 << 11)
+
+#define NAND_Ecc_P1o            (1 << 16)
+#define NAND_Ecc_P2o            (1 << 17)
+#define NAND_Ecc_P4o            (1 << 18)
+#define NAND_Ecc_P8o            (1 << 19)
+#define NAND_Ecc_P16o           (1 << 20)
+#define NAND_Ecc_P32o           (1 << 21)
+#define NAND_Ecc_P64o           (1 << 22)
+#define NAND_Ecc_P128o          (1 << 23)
+#define NAND_Ecc_P256o          (1 << 24)
+#define NAND_Ecc_P512o          (1 << 25)
+#define NAND_Ecc_P1024o         (1 << 26)
+#define NAND_Ecc_P2048o         (1 << 27)
+
+#define TF(value)       (value ? 1 : 0)
+
+#define P2048e(a)       (TF(a & NAND_Ecc_P2048e)        << 0 )
+#define P2048o(a)       (TF(a & NAND_Ecc_P2048o)        << 1 )
+#define P1e(a)          (TF(a & NAND_Ecc_P1e)           << 2 )
+#define P1o(a)          (TF(a & NAND_Ecc_P1o)           << 3 )
+#define P2e(a)          (TF(a & NAND_Ecc_P2e)           << 4 )
+#define P2o(a)          (TF(a & NAND_Ecc_P2o)           << 5 )
+#define P4e(a)          (TF(a & NAND_Ecc_P4e)           << 6 )
+#define P4o(a)          (TF(a & NAND_Ecc_P4o)           << 7 )
+
+#define P8e(a)          (TF(a & NAND_Ecc_P8e)           << 0 )
+#define P8o(a)          (TF(a & NAND_Ecc_P8o)           << 1 )
+#define P16e(a)         (TF(a & NAND_Ecc_P16e)          << 2 )
+#define P16o(a)         (TF(a & NAND_Ecc_P16o)          << 3 )
+#define P32e(a)         (TF(a & NAND_Ecc_P32e)          << 4 )
+#define P32o(a)         (TF(a & NAND_Ecc_P32o)          << 5 )
+#define P64e(a)         (TF(a & NAND_Ecc_P64e)          << 6 )
+#define P64o(a)         (TF(a & NAND_Ecc_P64o)          << 7 )
+
+#define P128e(a)        (TF(a & NAND_Ecc_P128e)         << 0 )
+#define P128o(a)        (TF(a & NAND_Ecc_P128o)         << 1 )
+#define P256e(a)        (TF(a & NAND_Ecc_P256e)         << 2 )
+#define P256o(a)        (TF(a & NAND_Ecc_P256o)         << 3 )
+#define P512e(a)        (TF(a & NAND_Ecc_P512e)         << 4 )
+#define P512o(a)        (TF(a & NAND_Ecc_P512o)         << 5 )
+#define P1024e(a)       (TF(a & NAND_Ecc_P1024e)        << 6 )
+#define P1024o(a)       (TF(a & NAND_Ecc_P1024o)        << 7 )
+
+#define P8e_s(a)        (TF(a & NAND_Ecc_P8e)           << 0 )
+#define P8o_s(a)        (TF(a & NAND_Ecc_P8o)           << 1 )
+#define P16e_s(a)       (TF(a & NAND_Ecc_P16e)          << 2 )
+#define P16o_s(a)       (TF(a & NAND_Ecc_P16o)          << 3 )
+#define P1e_s(a)        (TF(a & NAND_Ecc_P1e)           << 4 )
+#define P1o_s(a)        (TF(a & NAND_Ecc_P1o)           << 5 )
+#define P2e_s(a)        (TF(a & NAND_Ecc_P2e)           << 6 )
+#define P2o_s(a)        (TF(a & NAND_Ecc_P2o)           << 7 )
+
+#define P4e_s(a)        (TF(a & NAND_Ecc_P4e)           << 0 )
+#define P4o_s(a)        (TF(a & NAND_Ecc_P4o)           << 1 )
+
+#define CSL_EMIF_1_REGS    0x01E10000
+
+#define NAND4BITECCLOAD		(0x01E10000 +0xBC)
+#define NAND4BITECC1        (0x01E10000 +0xC0)
+#define NAND4BITECC2        (0x01E10000 +0xC4) 
+#define NAND4BITECC3        (0x01E10000 +0xC8)
+#define NAND4BITECC4        (0x01E10000 +0xCC)
+
+#define NANDERRADD1		    (0x01E10000 +0xD0)
+#define NANDERRADD2		    (0x01E10000 +0xD4)
+#define NANDERRVAL1		    (0x01E10000 +0xD8)
+#define NANDERRVAL2		    (0x01E10000 +0xDC)
+
+/* Definitions for 4-bit hardware ECC */
+#define NAND_4BITECC_MASK		0x03FF03FF
+#define EMIF_NANDFSR_ECC_STATE_MASK  	0x00000F00
+#define ECC_STATE_NO_ERR		0x0
+#define ECC_STATE_TOO_MANY_ERRS		0x1
+#define ECC_STATE_ERR_CORR_COMP_P	0x2
+#define ECC_STATE_ERR_CORR_COMP_N	0x3
+#define ECC_MAX_CORRECTABLE_ERRORS	0x4
+extern struct nand_chip nand_dev_desc[CFG_MAX_NAND_DEVICE];
+
+static void nand_dm350evm_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+	struct		nand_chip *this = mtd->priv;
+	u_int32_t	IO_ADDR_W = (u_int32_t)this->IO_ADDR_W;
+	u_int32_t	IO_ADDR_R = (u_int32_t)this->IO_ADDR_R;
+
+	IO_ADDR_W &= ~(MASK_ALE|MASK_CLE);
+
+	switch (cmd) {
+		case NAND_CTL_SETCLE:
+			IO_ADDR_W |= MASK_CLE;
+			break;
+		case NAND_CTL_SETALE:
+			IO_ADDR_W |= MASK_ALE;
+			break;
+	}
+
+	this->IO_ADDR_W = (void *)IO_ADDR_W;
+}
+
+static int nand_dm350evm_dev_ready(struct mtd_info *mtd)
+{
+	emifregs	emif_addr = (emifregs)CSL_EMIF_1_REGS;
+
+	return(emif_addr->NANDFSR) /*& 0x1)*/;
+}
+
+static int nand_dm350evm_waitfunc(struct mtd_info *mtd, struct nand_chip *this, int state)
+{
+	while(!nand_dm350evm_dev_ready(mtd)) {;}
+	*NAND_CE0CLE = NAND_STATUS;
+	return(*NAND_CE0DATA);
+}
+
+static void nand_dm355evm_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+        emifregs    emif_addr;
+
+	    emif_addr = (emifregs)CSL_EMIF_1_REGS;
+        emif_addr->NANDFCR |= (1 << 8);
+}
+
+static u32 nand_dm355evm_readecc(struct mtd_info *mtd, u32  Reg)
+{
+        u32      l = 0;
+        emifregs    emif_addr;
+	    emif_addr = (emifregs)CSL_EMIF_1_REGS;
+
+        if (Reg == 1)
+                l = emif_addr->NANDF1ECC;
+        else if (Reg == 2)
+                l = emif_addr->NANDF2ECC;
+        else if (Reg == 3)
+                l = emif_addr->NANDF3ECC;
+        else if (Reg == 4)
+                l = emif_addr->NANDF4ECC;
+
+        return l;
+}
+
+static int nand_dm355evm_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
+				      u_char *ecc_code)
+{
+        unsigned int      l;
+        int               reg;
+        int               n;
+        struct nand_chip *this = mtd->priv;
+
+        if (this->eccmode == NAND_ECC_HW12_2048)
+                n = 4;
+        else
+                n = 1;
+
+        reg = 1;
+        while (n--) {
+                l = nand_dm355evm_readecc(mtd, reg);
+                *ecc_code++ = l;          // P128e, ..., P1e
+                *ecc_code++ = l >> 16;    // P128o, ..., P1o
+                // P2048o, P1024o, P512o, P256o, P2048e, P1024e, P512e, P256e
+                *ecc_code++ = ((l >> 8) & 0x0f) | ((l >> 20) & 0xf0);
+                reg++;
+        }
+        return 0;
+}
+
+static void nand_dm355evm_gen_true_ecc(u8 *ecc_buf)
+{
+        u32 tmp = ecc_buf[0] | (ecc_buf[1] << 16) | ((ecc_buf[2] & 0xF0) << 20) | ((ecc_buf[2] & 0x0F) << 8);
+
+        ecc_buf[0] = ~(P64o(tmp) | P64e(tmp) | P32o(tmp) | P32e(tmp) | P16o(tmp) | P16e(tmp) | P8o(tmp) | P8e(tmp) );
+        ecc_buf[1] = ~(P1024o(tmp) | P1024e(tmp) | P512o(tmp) | P512e(tmp) | P256o(tmp) | P256e(tmp) | P128o(tmp) | P128e(tmp));
+        ecc_buf[2] = ~( P4o(tmp) | P4e(tmp) | P2o(tmp) | P2e(tmp) | P1o(tmp) | P1e(tmp) | P2048o(tmp) | P2048e(tmp));
+}
+
+static int nand_dm355evm_compare_ecc(u8 *     ecc_data1,   /* read from NAND memory */
+                                    u8 *     ecc_data2,   /* read from register */
+                                    u8 *     page_data)
+{
+        u32    i;
+        u8     tmp0_bit[8], tmp1_bit[8], tmp2_bit[8];
+        u8     comp0_bit[8], comp1_bit[8], comp2_bit[8];
+        u8     ecc_bit[24];
+        u8     ecc_sum = 0;
+        u8     find_bit = 0;
+        u32    find_byte = 0;
+        int    isEccFF;
+
+        isEccFF = ((*(u32 *)ecc_data1 & 0xFFFFFF) == 0xFFFFFF);
+
+        nand_dm355evm_gen_true_ecc(ecc_data1);
+        nand_dm355evm_gen_true_ecc(ecc_data2);
+
+        for (i = 0; i <= 2; i++) {
+                *(ecc_data1 + i) = ~(*(ecc_data1 + i));
+                *(ecc_data2 + i) = ~(*(ecc_data2 + i));
+        }
+
+        for (i = 0; i < 8; i++) {
+                tmp0_bit[i]      = *ecc_data1 % 2;
+                *ecc_data1       = *ecc_data1 / 2;
+        }
+
+        for (i = 0; i < 8; i++) {
+                tmp1_bit[i]      = *(ecc_data1 + 1) % 2;
+                *(ecc_data1 + 1) = *(ecc_data1 + 1) / 2;
+        }
+
+        for (i = 0; i < 8; i++) {
+                tmp2_bit[i]      = *(ecc_data1 + 2) % 2;
+                *(ecc_data1 + 2) = *(ecc_data1 + 2) / 2;
+        }
+
+        for (i = 0; i < 8; i++) {
+                comp0_bit[i]     = *ecc_data2 % 2;
+                *ecc_data2       = *ecc_data2 / 2;
+        }
+
+        for (i = 0; i < 8; i++) {
+                comp1_bit[i]     = *(ecc_data2 + 1) % 2;
+                *(ecc_data2 + 1) = *(ecc_data2 + 1) / 2;
+        }
+
+        for (i = 0; i < 8; i++) {
+                comp2_bit[i]     = *(ecc_data2 + 2) % 2;
+                *(ecc_data2 + 2) = *(ecc_data2 + 2) / 2;
+        }
+
+        for (i = 0; i< 6; i++ )
+                ecc_bit[i] = tmp2_bit[i + 2] ^ comp2_bit[i + 2];
+
+        for (i = 0; i < 8; i++)
+                ecc_bit[i + 6] = tmp0_bit[i] ^ comp0_bit[i];
+
+        for (i = 0; i < 8; i++)
+                ecc_bit[i + 14] = tmp1_bit[i] ^ comp1_bit[i];
+
+        ecc_bit[22] = tmp2_bit[0] ^ comp2_bit[0];
+        ecc_bit[23] = tmp2_bit[1] ^ comp2_bit[1];
+
+        for (i = 0; i < 24; i++)
+                ecc_sum += ecc_bit[i];
+
+        switch (ecc_sum) {
+        case 0:
+                /* Not reached because this function is not called if
+                   ECC values are equal */
+                return 0;
+
+        case 1:
+                /* Uncorrectable error */
+                DEBUG (MTD_DEBUG_LEVEL0, "ECC UNCORRECTED_ERROR 1\n");
+                return -1;
+
+        case 12:
+                /* Correctable error */
+                find_byte = (ecc_bit[23] << 8) +
+                            (ecc_bit[21] << 7) +
+                            (ecc_bit[19] << 6) +
+                            (ecc_bit[17] << 5) +
+                            (ecc_bit[15] << 4) +
+                            (ecc_bit[13] << 3) +
+                            (ecc_bit[11] << 2) +
+                            (ecc_bit[9]  << 1) +
+                            ecc_bit[7];
+
+                find_bit = (ecc_bit[5] << 2) + (ecc_bit[3] << 1) + ecc_bit[1];
+
+                DEBUG (MTD_DEBUG_LEVEL0, "Correcting single bit ECC error at offset: %d, bit: %d\n", find_byte, find_bit);
+
+                page_data[find_byte] ^= (1 << find_bit);
+
+                return 0;
+
+        default:
+                if (isEccFF) {
+                        if (ecc_data2[0] == 0 && ecc_data2[1] == 0 && ecc_data2[2] == 0)
+                                return 0;
+                }
+                DEBUG (MTD_DEBUG_LEVEL0, "UNCORRECTED_ERROR default\n");
+                return -1;
+        }
+}
+
+static int nand_dm355evm_correct_data(struct mtd_info *mtd, u_char *dat,
+				     u_char *read_ecc, u_char *calc_ecc)
+{
+	int r = 0;
+#if 0
+	if (memcmp(read_ecc, calc_ecc, 3) != 0) {
+		u_char read_ecc_copy[3], calc_ecc_copy[3];
+		int i;
+
+		for (i = 0; i < 3; i++) {
+			read_ecc_copy[i] = read_ecc[i];
+			calc_ecc_copy[i] = calc_ecc[i];
+		}
+		r = nand_dm355_1bit_compare_ecc(read_ecc_copy, calc_ecc_copy,
+						  dat);
+	}
+#endif
+	return r;
+}
+
+/*
+ * 4-bit ECC routines
+ */
+
+/*
+ * Instead of placing the spare data at the end of the page, the 4-bit ECC
+ * hardware generator requires that the page be subdivided into 4 subpages,
+ * each with its own spare data area.  This structure defines the format of
+ * each of these subpages.
+ */
+static struct page_layout_item nand_dm355_hw10_512_layout[] = {
+	{.type = ITEM_TYPE_DATA,.length = 512},
+	{.type = ITEM_TYPE_OOB,.length = 6,},
+	{.type = ITEM_TYPE_ECC,.length = 10,},
+	{.type = 0,.length = 0,},
+};
+
+static struct nand_oobinfo nand_dm355_hw10_512_oobinfo = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 10,
+	.eccpos = {6,7,8,9,10,11,12,13,14,15,
+		   },
+	.oobfree ={0, 6},
+};
+
+static uint8_t scan_ff_pattern[] = { 0xff, 0xff };
+/*
+ * We should always have a flash-based bad block table.  However, if one isn't
+ * found then all blocks will be scanned to look for factory-marked bad blocks.
+ * We supply a null pattern so that no blocks will be detected as bad.
+ */
+static struct nand_bbt_descr nand_dm355_hw10_512_badblock_pattern = {
+  .options = 0, //NAND_BBT_SCANEMPTY | NAND_BBT_SCANALLPAGES,
+	.offs = 5,
+	.len = 1,
+	.pattern = scan_ff_pattern
+};
+
+
+/* Generic flash bbt decriptors
+*/
+static uint8_t bbt_pattern[] = {'B', 'b', 't', '0' };
+static uint8_t mirror_pattern[] = {'1', 't', 'b', 'B' };
+
+static struct nand_bbt_descr bbt_main_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs =	0,
+	.len = 4,
+	.veroffs = 5,
+	.maxblocks = 4,
+	.pattern = bbt_pattern
+};
+
+static struct nand_bbt_descr bbt_mirror_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs =	0,
+	.len = 4,
+	.veroffs = 5,
+	.maxblocks = 4,
+	.pattern = mirror_pattern
+};
+
+/*
+ * When using 4-bit ECC with a 2048-byte data + 64-byte spare page size, the
+ * oob is scattered throughout the page in 4 16-byte chunks instead of being
+ * grouped together at the end of the page.  This means that the factory
+ * bad-block markers at offsets 2048 and 2049 will be overwritten when data
+ * is written to the flash.  Thus, we cannot use the factory method to mark
+ * or detect bad blocks and must rely on a flash-based bad block table instead.
+ *
+ */
+static int nand_dm355_hw10_512_block_bad(struct mtd_info *mtd, loff_t ofs,
+					   int getchip)
+{
+	return 0;
+}
+
+static int nand_dm355_hw10_512_block_markbad(struct mtd_info *mtd, loff_t ofs)
+{
+	struct nand_chip *this = mtd->priv;
+	int block;
+
+	/* Get block number */
+	block = ((int)ofs) >> this->bbt_erase_shift;
+	if (this->bbt)
+		this->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
+
+	/* Do we have a flash based bad block table ? */
+	if (this->options & NAND_USE_FLASH_BBT)
+		return nand_update_bbt(mtd, ofs);
+
+	return 0;
+}
+
+static void nand_dm355_4bit_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	struct nand_chip *this = mtd->priv;
+    emifregs    emif_addr = (emifregs)CSL_EMIF_1_REGS;
+	u32 val;
+	
+	switch (mode) {
+	case NAND_ECC_WRITE:
+	case NAND_ECC_READ:
+		/*
+		 * Start a new ECC calculation for reading or writing 512 bytes
+		 *  of data.
+		 */
+		val = (emif_addr->NANDFCR & ~(3 << 4))
+		    | (1 << 12);
+        emif_addr->NANDFCR = val;
+		break;
+	case NAND_ECC_WRITEOOB:
+	case NAND_ECC_READOOB:
+		/*
+		 * Terminate ECC calculation by performing a dummy read of an
+		 * ECC register.  Our hardware ECC generator supports including
+		 * the OOB in the ECC calculation, but the NAND core code
+		 * doesn't really support that.  We will only calculate the ECC
+		 * on the data; errors in the non-ECC bytes in the OOB will not
+		 * be detected or corrected.
+		 */
+        val =(*(dv_reg_p) NAND4BITECC1);
+		break;
+	case NAND_ECC_WRITESYN:
+	case NAND_ECC_READSYN:
+		/*
+		 * Our ECC calculation has already been terminated, so no need
+		 * to do anything here.
+		 */
+		break;
+	default:
+		break;
+	}
+}
+
+static u32 nand_dm355_4bit_readecc(struct mtd_info *mtd, unsigned int *ecc)
+{
+  unsigned int ecc_temp[4];
+    emifregs    emif_addr = (emifregs)CSL_EMIF_1_REGS;
+
+	ecc[0] = (*(dv_reg_p) NAND4BITECC1) & NAND_4BITECC_MASK;
+	ecc[1] = (*(dv_reg_p) NAND4BITECC2) & NAND_4BITECC_MASK;
+	ecc[2] = (*(dv_reg_p) NAND4BITECC3) & NAND_4BITECC_MASK;
+	ecc[3] = (*(dv_reg_p) NAND4BITECC4) & NAND_4BITECC_MASK;
+
+	return 0;
+}
+
+static int nand_dm355_4bit_calculate_ecc(struct mtd_info *mtd,
+					   const u_char * dat,
+					   u_char * ecc_code)
+{
+	unsigned int hw_4ecc[4] = { 0, 0, 0, 0 };
+	unsigned int const1 = 0, const2 = 0;
+	unsigned char count1 = 0;
+	emifregs    emif_addr = (emifregs)CSL_EMIF_1_REGS;
+	u32 val;
+	/*
+	 * Since the NAND_HWECC_SYNDROME option is enabled, this routine is
+	 * only called just after the data and oob have been written.  The
+	 * ECC value calculated by the hardware ECC generator is available
+	 * for us to read.
+	 */
+	nand_dm355_4bit_readecc(mtd, hw_4ecc);
+
+	/*Convert 10 bit ecc value to 8 bit */
+	for (count1 = 0; count1 < 2; count1++) {
+		const2 = count1 * 5;
+		const1 = count1 * 2;
+
+		/* Take first 8 bits from val1 (count1=0) or val5 (count1=1) */
+		ecc_code[const2] = hw_4ecc[const1] & 0xFF;
+
+		/*
+		 * Take 2 bits as LSB bits from val1 (count1=0) or val5
+		 * (count1=1) and 6 bits from val2 (count1=0) or val5 (count1=1)
+		 */
+		ecc_code[const2 + 1] =
+		    ((hw_4ecc[const1] >> 8) & 0x3) | ((hw_4ecc[const1] >> 14) &
+						      0xFC);
+
+		/*
+		 * Take 4 bits from val2 (count1=0) or val5 (count1=1) and
+		 * 4 bits from val3 (count1=0) or val6 (count1=1)
+		 */
+		ecc_code[const2 + 2] =
+		    ((hw_4ecc[const1] >> 22) & 0xF) |
+		    ((hw_4ecc[const1 + 1] << 4) & 0xF0);
+
+		/*
+		 * Take 6 bits from val3(count1=0) or val6 (count1=1) and
+		 * 2 bits from val4 (count1=0) or  val7 (count1=1)
+		 */
+		ecc_code[const2 + 3] =
+		    ((hw_4ecc[const1 + 1] >> 4) & 0x3F) |
+		    ((hw_4ecc[const1 + 1] >> 10) & 0xC0);
+
+		/* Take 8 bits from val4 (count1=0) or val7 (count1=1) */
+		ecc_code[const2 + 4] = (hw_4ecc[const1 + 1] >> 18) & 0xFF;
+	}
+
+	return 0;
+}
+
+static int nand_dm355_4bit_compare_ecc(struct mtd_info *mtd, u8 * read_ecc,	/* read from NAND */
+					 u8 * page_data)
+{
+	struct nand_chip *this = mtd->priv;
+	struct nand_dm355_info *info = this->priv;
+	unsigned short ecc_10bit[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+	int i;
+	unsigned int hw_4ecc[4] = { 0, 0, 0, 0 }, iserror = 0;
+	unsigned short *pspare = NULL, *pspare1 = NULL;
+	unsigned int numErrors, errorAddress, errorValue;
+    emifregs    emif_addr = (emifregs)CSL_EMIF_1_REGS;
+	u32 val;
+	
+	/*
+	 * Check for an ECC where all bytes are 0xFF.  If this is the case, we
+	 * will assume we are looking at an erased page and we should ignore the
+	 * ECC.
+	 */
+	for (i = 0; i < 10; i++) {
+		if (read_ecc[i] != 0xFF)
+			break;
+	}
+	if (i == 10)
+		return 0;
+
+	/* Convert 8 bit in to 10 bit */
+	pspare = (unsigned short *)&read_ecc[2];
+	pspare1 = (unsigned short *)&read_ecc[0];
+	/* Take 10 bits from 0th and 1st bytes */
+	ecc_10bit[0] = (*pspare1) & 0x3FF;	/* 10 */
+	/* Take 6 bits from 1st byte and 4 bits from 2nd byte */
+	ecc_10bit[1] = (((*pspare1) >> 10) & 0x3F)
+	    | (((pspare[0]) << 6) & 0x3C0);	/* 6 + 4 */
+	/* Take 4 bits form 2nd bytes and 6 bits from 3rd bytes */
+	ecc_10bit[2] = ((pspare[0]) >> 4) & 0x3FF;	/* 10 */
+	/*Take 2 bits from 3rd byte and 8 bits from 4th byte */
+	ecc_10bit[3] = (((pspare[0]) >> 14) & 0x3)
+	    | ((((pspare[1])) << 2) & 0x3FC);	/* 2 + 8 */
+	/* Take 8 bits from 5th byte and 2 bits from 6th byte */
+	ecc_10bit[4] = ((pspare[1]) >> 8)
+	    | ((((pspare[2])) << 8) & 0x300);	/* 8 + 2 */
+	/* Take 6 bits from 6th byte and 4 bits from 7th byte */
+	ecc_10bit[5] = (pspare[2] >> 2) & 0x3FF;	/* 10 */
+	/* Take 4 bits from 7th byte and 6 bits from 8th byte */
+	ecc_10bit[6] = (((pspare[2]) >> 12) & 0xF)
+	    | ((((pspare[3])) << 4) & 0x3F0);	/* 4 + 6 */
+	/*Take 2 bits from 8th byte and 8 bits from 9th byte */
+	ecc_10bit[7] = ((pspare[3]) >> 6) & 0x3FF;	/* 10 */
+
+	/*
+	 * Write the parity values in the NAND Flash 4-bit ECC Load register.
+	 * Write each parity value one at a time starting from 4bit_ecc_val8
+	 * to 4bit_ecc_val1.
+	 */
+	for (i = 7; i >= 0; i--)
+    {
+       *(dv_reg_p)NAND4BITECCLOAD = ecc_10bit[i];  
+    }
+
+	/*
+	 * Perform a dummy read to the EMIF Revision Code and Status register.
+	 * This is required to ensure time for syndrome calculation after
+	 * writing the ECC values in previous step.
+	 */
+	val = emif_addr->ERCSR;
+
+	/*
+	 * Read the syndrome from the NAND Flash 4-Bit ECC 1-4 registers.
+	 * A syndrome value of 0 means no bit errors. If the syndrome is
+	 * non-zero then go further otherwise return.
+	 */
+	nand_dm355_4bit_readecc(mtd, hw_4ecc);
+
+	if (hw_4ecc[0] == ECC_STATE_NO_ERR && hw_4ecc[1] == ECC_STATE_NO_ERR &&
+	    hw_4ecc[2] == ECC_STATE_NO_ERR && hw_4ecc[3] == ECC_STATE_NO_ERR){
+          return 0;
+      }
+
+
+	/*
+	 * Clear any previous address calculation by doing a dummy read of an
+	 * error address register.
+	 */
+	val = *(dv_reg_p)NANDERRADD1;
+
+	/*
+	 * Set the addr_calc_st bit(bit no 13) in the NAND Flash Control
+	 * register to 1.
+	 */
+    
+    emif_addr->NANDFCR |= (1 << 13);
+
+	/*
+	 * Wait for the corr_state field (bits 8 to 11)in the
+	 * NAND Flash Status register to be equal to 0x0, 0x1, 0x2, or 0x3.
+	 */
+    do {
+        iserror = emif_addr->NANDFSR & 0xC00;
+    } while (iserror);       
+
+	iserror = emif_addr->NANDFSR;
+	iserror &= EMIF_NANDFSR_ECC_STATE_MASK;
+	iserror = iserror >> 8;
+
+#if 0
+	do {
+		iserror = emif_addr->NANDFSR;
+		iserror &= EMIF_NANDFSR_ECC_STATE_MASK;
+		iserror = iserror >> 8;
+	} while ((ECC_STATE_NO_ERR != iserror) &&
+		 (ECC_STATE_TOO_MANY_ERRS != iserror) &&
+		 (ECC_STATE_ERR_CORR_COMP_P != iserror) &&
+		 (ECC_STATE_ERR_CORR_COMP_N != iserror));
+#endif
+	/*
+	 * ECC_STATE_TOO_MANY_ERRS (0x1) means errors cannot be
+	 * corrected (five or more errors).  The number of errors
+	 * calculated (err_num field) differs from the number of errors
+	 * searched.  ECC_STATE_ERR_CORR_COMP_P (0x2) means error
+	 * correction complete (errors on bit 8 or 9).
+	 * ECC_STATE_ERR_CORR_COMP_N (0x3) means error correction
+	 * complete (error exists).
+	 */
+
+	if (iserror == ECC_STATE_NO_ERR)
+		return 0;
+	else if (iserror == ECC_STATE_TOO_MANY_ERRS)
+    {
+        printf("too many erros to be corrected!\n");
+		return -1;
+    }
+
+#if 1
+	numErrors = ((emif_addr->NANDFSR >> 16) & 0x3) + 1;
+//  printf("numErrors =%d\n",numErrors);
+  if(numErrors==4)
+    return numErrors;
+	/* Read the error address, error value and correct */
+	for (i = 0; i < numErrors; i++) {
+		if (i > 1) {
+			errorAddress =
+			    ((*(dv_reg_p)(NANDERRADD2) >>
+			      (16 * (i & 1))) & 0x3FF);
+			errorAddress = ((512 + 7) - errorAddress);
+			errorValue =
+			    ((*(dv_reg_p)(NANDERRVAL2) >>
+			      (16 * (i & 1))) & 0xFF);
+		} else {
+			errorAddress =
+			    ((*(dv_reg_p)(NANDERRADD1) >>
+			      (16 * (i & 1))) & 0x3FF);
+			errorAddress = ((512 + 7) - errorAddress);
+			errorValue =
+			    ((*(dv_reg_p)(NANDERRVAL1) >>
+			      (16 * (i & 1))) & 0xFF);
+		}
+		/* xor the corrupt data with error value */
+		if (errorAddress < 512)
+			page_data[errorAddress] ^= errorValue;
+	}
+#else
+	numErrors = ((emif_addr->NANDFSR >> 16) & 0x3);
+        // bit 9:0
+        errorAddress = 519 - (*(dv_reg_p)NANDERRADD1 & (0x3FF));
+        errorValue   = (*(dv_reg_p)NANDERRVAL1) & (0x3FF);
+        page_data[errorAddress] ^= (char)errorValue;
+
+        if(numErrors == 0)
+            return numErrors;
+        else {
+            // bit 25:16
+            errorAddress = 519 - ( (*(dv_reg_p)NANDERRADD1 & (0x3FF0000))>>16 );
+            errorValue   = (*(dv_reg_p)NANDERRVAL1) & (0x3FF);
+            page_data[errorAddress] ^= (char)errorValue;
+
+            if(numErrors == 1)
+                return numErrors;
+            else {
+                // bit 9:0
+                errorAddress = 519 - (*(dv_reg_p)NANDERRADD2 & (0x3FF));
+                errorValue = (*(dv_reg_p)NANDERRVAL2) & (0x3FF);
+                page_data[errorAddress] ^= (char)errorValue;
+
+                if (numErrors == 2)
+                    return numErrors;
+                else {
+                    // bit 25:16
+                    errorAddress = 519 - ( (*(dv_reg_p)NANDERRADD2 & (0x3FF0000))>>16 );
+                    errorValue = (*(dv_reg_p)NANDERRVAL2) & (0x3FF);
+                    page_data[errorAddress] ^= (char)errorValue;
+                }
+            }
+        }
+#endif
+
+	return numErrors;
+}
+
+static int nand_dm355_4bit_correct_data(struct mtd_info *mtd, u_char * dat,
+					  u_char * read_ecc, u_char * calc_ecc)
+{
+	int r = 0;
+
+	/*
+	 * dat points to 512 bytes of data.  read_ecc points to the start of the
+	 * oob area for this subpage, so the ecc values start at offset 6.
+	 * The calc_ecc pointer is not needed since our caclulated ECC is
+	 * already latched in the hardware ECC generator.
+	 */
+#if 1
+	r = nand_dm355_4bit_compare_ecc(mtd, read_ecc + 6, dat);
+#endif
+
+	return r;
+}
+int board_nand_init(struct nand_chip *nand)
+{
+#if 0
+	nand->IO_ADDR_R   = (void  __iomem *)NAND_CE0DATA;
+	nand->IO_ADDR_W   = (void  __iomem *)NAND_CE0DATA;
+#endif
+	nand->chip_delay  = 0;
+	nand->options     = NAND_USE_FLASH_BBT /*| NAND_BBT_LASTBLOCK*/;
+//	nand->eccmode     = NAND_ECC_SOFT;
+#if 0 
+	nand->eccmode     = NAND_ECC_HW3_512;
+	nand->calculate_ecc =  nand_dm355evm_calculate_ecc;
+	nand->correct_data	 = nand_dm355evm_correct_data;
+	nand->enable_hwecc	 = nand_dm355evm_enable_hwecc;
+#else
+	nand->eccmode     = NAND_ECC_HW10_512;
+	nand->options     = NAND_USE_FLASH_BBT | NAND_HWECC_SYNDROME;
+    nand->autooob = &nand_dm355_hw10_512_oobinfo;
+	nand->layout = nand_dm355_hw10_512_layout;
+	nand->calculate_ecc = nand_dm355_4bit_calculate_ecc;
+	nand->correct_data = nand_dm355_4bit_correct_data;
+	nand->enable_hwecc = nand_dm355_4bit_enable_hwecc;
+	//nand->block_bad = nand_dm355_hw10_512_block_bad;
+	nand->block_markbad = nand_dm355_hw10_512_block_markbad;
+	nand->badblock_pattern =  &nand_dm355_hw10_512_badblock_pattern;
+	nand->bbt_td =&bbt_main_descr;
+	nand->bbt_md = &bbt_mirror_descr;
+    
+#endif
+	/* Set address of hardware control function */
+	nand->hwcontrol = nand_dm350evm_hwcontrol;
+
+	//nand->dev_ready = nand_dm350evm_dev_ready;
+	//nand->waitfunc = nand_dm350evm_waitfunc;
+
+	return 0;
+}
+
+#else
+#error "U-Boot legacy NAND support not available for DaVinci chips"
+#endif
+#endif	/* CFG_USE_NAND */
diff -Nurd u-boot-1.2.0/board/dm355_ipnc/timer.c u-boot-1.2.0-leopard/board/dm355_ipnc/timer.c
--- u-boot-1.2.0/board/dm355_ipnc/timer.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_ipnc/timer.c	2008-01-05 03:45:25.000000000 -0300
@@ -0,0 +1,72 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ Modifications:
+ ver. 1.0: Oct 2005, Swaminathan S
+ *
+ */
+
+#include "timer.h"
+
+/* Use Timer 3&4 (Timer 2) */
+#define TIMER_BASE_ADDR	0x01C21400
+
+dm350_timer_reg    *dm350_timer = (dm350_timer_reg *) TIMER_BASE_ADDR;
+
+/* Timer Initialize */
+void inittimer(void)
+{
+        /* disable Timer 1 & 2 timers */
+        dm350_timer->tcr = 0;
+
+        /* Set timers to unchained dual 32 bit timers, Unreset timer34 */
+        dm350_timer->tgcr = 0x0;
+        dm350_timer->tgcr = 0x6;
+
+        /* Program the timer12 counter register - set the prd12 for right count */
+        dm350_timer->tim34 = 0;
+
+        /* The timer is programmed to expire after 0xFFFFFFFF ticks */
+        dm350_timer->prd34 = 0xFFFFFFFF;
+
+        /* Enable timer34 */
+        dm350_timer->tcr = (0x80 << 16); /* Timer34 continously enabled, Timer12 disabled */
+}
+
+/************************************************************
+********************** Reset Processor **********************
+************************************************************/
+#define WDT_BASE_ADDR          0x01C21C00
+
+
+void reset_processor(void)
+{
+        dm350_timer_reg *dm350_wdt = (dm350_timer_reg *) WDT_BASE_ADDR;
+        dm350_wdt->tgcr   = 0x00000008;
+        dm350_wdt->tgcr  |= 0x00000003;
+        dm350_wdt->tim12  = 0x00000000;
+        dm350_wdt->tim34  = 0x00000000;
+        dm350_wdt->prd12  = 0x00000000;
+        dm350_wdt->prd34  = 0x00000000;
+        dm350_wdt->tcr   |= 0x00000040;
+        dm350_wdt->wdtcr |= 0x00004000;
+        dm350_wdt->wdtcr  = 0xA5C64000;
+        dm350_wdt->wdtcr  = 0xDA7E4000;
+}
diff -Nurd u-boot-1.2.0/board/dm355_ipnc/timer.h u-boot-1.2.0-leopard/board/dm355_ipnc/timer.h
--- u-boot-1.2.0/board/dm355_ipnc/timer.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_ipnc/timer.h	2008-01-05 03:45:25.000000000 -0300
@@ -0,0 +1,51 @@
+/*
+ *
+ *  Copyright (C) 2004 Texas Instruments.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ * Modifications:
+ * ver. 1.0: Oct 2005, Swaminathan S
+ *
+ */
+#ifndef __TIMER_H__
+#define __TIMER_H__
+
+typedef volatile struct dm350_timer_reg_t
+{
+    unsigned int pid12;         /* 0x0 */
+    unsigned int emumgt_clksped;/* 0x4 */
+    unsigned int gpint_en;      /* 0x8 */
+    unsigned int gpdir_dat;     /* 0xC */
+    unsigned int tim12;         /* 0x10 */
+    unsigned int tim34;         /* 0x14 */
+    unsigned int prd12;         /* 0x18 */
+    unsigned int prd34;         /* 0x1C */
+    unsigned int tcr;           /* 0x20 */
+    unsigned int tgcr;          /* 0x24 */
+    unsigned int wdtcr;         /* 0x28 */
+    unsigned int tlgc;          /* 0x2C */
+    unsigned int tlmr;          /* 0x30 */
+} dm350_timer_reg;
+
+#endif  /* __TIMER_H__ */
+
diff -Nurd u-boot-1.2.0/board/dm355_ipnc/types.h u-boot-1.2.0-leopard/board/dm355_ipnc/types.h
--- u-boot-1.2.0/board/dm355_ipnc/types.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_ipnc/types.h	2008-01-05 03:45:25.000000000 -0300
@@ -0,0 +1,46 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ *
+ */
+#ifndef _TYPESH_
+#define _TYPESH_
+
+typedef unsigned long 	ULONG;
+typedef unsigned short 	USHORT;
+typedef unsigned long   BOOL;
+typedef unsigned int	WORD;
+typedef char            CHAR;
+typedef unsigned char   BYTE, *LPBYTE, UCHAR, *PUCHAR, PBYTE;
+
+#define FALSE           0
+#define TRUE            1
+
+#define NULL			0
+
+typedef unsigned short int Hwd;
+typedef volatile unsigned short int vHwd;
+typedef unsigned short int *  Hwdptr;
+typedef volatile unsigned short int * vHwdptr;
+//typedef volatile unsigned int * vHwdptr;
+
+
+#endif
+
diff -Nurd u-boot-1.2.0/board/dm355_ipnc/u-boot.lds u-boot-1.2.0-leopard/board/dm355_ipnc/u-boot.lds
--- u-boot-1.2.0/board/dm355_ipnc/u-boot.lds	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_ipnc/u-boot.lds	2008-01-31 04:18:33.000000000 -0300
@@ -0,0 +1,52 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+	. = ALIGN(4);
+	.text	:
+	{
+	  cpu/arm926ejs/start.o	(.text)
+	  *(.text)
+	}
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+	. = ALIGN(4);
+	.data : { *(.data) }
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -Nurd u-boot-1.2.0/board/dm355_leopard/Makefile u-boot-1.2.0-leopard/board/dm355_leopard/Makefile
--- u-boot-1.2.0/board/dm355_leopard/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_leopard/Makefile	2009-03-10 02:17:43.000000000 -0300
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= dm355_leopard.o flash.o nand.o timer.o 
+SOBJS	:= lowlevel_init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $^
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff -Nurd u-boot-1.2.0/board/dm355_leopard/config.mk u-boot-1.2.0-leopard/board/dm355_leopard/config.mk
--- u-boot-1.2.0/board/dm355_leopard/config.mk	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_leopard/config.mk	2009-03-01 04:24:26.000000000 -0300
@@ -0,0 +1,25 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+# David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+#
+# (C) Copyright 2003
+# Texas Instruments, <www.ti.com>
+# Swaminathan <swami.iyer@ti.com>
+#
+# Davinci EVM board (ARM925EJS) cpu
+# see http://www.ti.com/ for more information on Texas Instruments
+#
+# Davinci EVM has 1 bank of 256 MB DDR RAM 
+# Physical Address:
+# 8000'0000 to 9000'0000
+#
+# Linux-Kernel is expected to be at 8000'8000, entry 8000'8000
+# (mem base + reserved)
+#
+# we load ourself to 8100 '0000
+# 
+#
+
+#Provide a atleast 16MB spacing between us and the Linux Kernel image
+TEXT_BASE = 0x81080000
diff -Nurd u-boot-1.2.0/board/dm355_leopard/dm355_leopard.c u-boot-1.2.0-leopard/board/dm355_leopard/dm355_leopard.c
--- u-boot-1.2.0/board/dm355_leopard/dm355_leopard.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_leopard/dm355_leopard.c	2009-03-10 02:19:53.000000000 -0300
@@ -0,0 +1,671 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ Modifications:
+ ver. 1.0: Oct 2005, Swaminathan S
+ *
+ */
+#include <common.h>
+#include <i2c.h>
+#include <asm/io.h>
+
+#define inw(a) __raw_readw(a)
+#define outw(a,v) __raw_writew(a,v)
+
+
+#define PLL1_PLLM    *(volatile unsigned int *)0x01c40910
+#define PLL2_PLLM    *(volatile unsigned int *)0x01c40D10
+#define PLL2_DIV2    *(volatile unsigned char *)0x01c40D1C
+#define PLL2_PREDIV  *(volatile unsigned int *)0x01C40D14
+#define PLL1_PLLDIV3 *(volatile unsigned int *)0x01C40920
+#define PLL1_POSTDIV *(volatile unsigned int *)0x01C40928
+#define PLL1_PLLDIV4 *(volatile unsigned int *)0x01C40960
+#define SYSTEM_MISC  *(volatile unsigned int *)0x01C40038
+#define MACH_DM355_LEOPARD	2138
+
+#define W_SETUP       	0x1	    //0~f         
+#define W_STROBE        0x3	    //0~3f
+#define W_HOLD        	0x1	    //0~7
+#define R_SETUP       	0x1	    //0~f         
+#define R_STROBE      	0x3	    //0~3f
+#define R_HOLD        	0x1     //0~7
+
+#define TA            			3     //0~3
+#define A_SIZE        			1     //1:16 bit 0:8bit
+#define DM9000_TIMING  		W_SETUP<<26 | W_STROBE<<20 | W_HOLD <<17 | R_SETUP<<13 | R_STROBE<<7 | R_HOLD <<4 | TA<<2 | A_SIZE
+
+
+
+/* GIO register */
+#define	GIO_BINTEN		              0x01C67008		/* GPIO Interrupt Per-Bank Enable Register */
+#define GIO_DIR01			       0x01C67010		
+#define GIO_OUT_DATA01			0x01C67014		
+#define GIO_SET_DATA01			0x01C67018		
+#define GIO_CLR_DATA01			0x01C6701C		
+#define	GIO_SET_RIS_TRIG01	0x01C67024		    
+#define	GIO_SET_FAL_TRIG01	0x01C6702c		
+#define	GIO_A2CR		              0x01e10014
+
+#define GIO_DIR23			       0x01C67038		
+#define GIO_OUT_DATA23			0x01C6703c		
+#define GIO_SET_DATA23			0x01C67040		
+#define GIO_CLR_DATA23			0x01C67044		
+
+#define GIO_DIR45			       (0x01C67060)		
+#define GIO_OUT_DATA45			(0x01C67064)		
+#define GIO_SET_DATA45			(0x01C67068)		
+#define GIO_CLR_DATA45			(0x01C6706C)
+
+#define GIO_DIR06			      (0x01C67088)		
+#define GIO_OUT_DATA06			(0x01C6708C)		
+#define GIO_SET_DATA06			(0x01C67090)		
+#define GIO_CLR_DATA06			(0x01C67094)
+
+void davinci_psc_all_enable(void);
+short MSP430_getReg( short reg, unsigned short *regval );
+unsigned int UARTSendInt(unsigned int value);
+
+/*******************************************
+ Routine: delay
+ Description:  Delay function
+*******************************************/
+static inline void delay (unsigned long loops)
+{
+__asm__ volatile ("1:\n"
+		     "subs %0, %1, #1\n"
+		     "bne 1b":"=r" (loops):"0" (loops));
+}
+
+/*******************************************
+ Routine: board_init
+ Description:  Board Initialization routine
+*******************************************/
+int board_init (void)
+{
+    	  DECLARE_GLOBAL_DATA_PTR;
+        int i;
+        /* arch number of DaVinci DVDP-Board */
+        gd->bd->bi_arch_number = MACH_DM355_LEOPARD;
+
+      	/* adress of boot parameters */
+       	gd->bd->bi_boot_params = LINUX_BOOT_PARAM_ADDR;
+#if 1	
+#define PINMUX3	    0x01C4000C
+		*(volatile unsigned int *)PINMUX3 &= 0XF8FFFFFF; // GIO9 & 10 are IO
+		
+ 	      /* Interrupt set GIO9	*/
+	      *((volatile unsigned int *) GIO_BINTEN) |=0x01; //bank 0	
+	      /* set GIO9input  */
+	       *((volatile unsigned int *) GIO_DIR01) |=(1<<9);	 
+	      /* Both edge tigger GIO9 */
+	       *((volatile unsigned int *) GIO_SET_RIS_TRIG01) |=(1<<9);          	
+
+		  	/* set GIO5 output, imager reset  */
+		//printf("pull down gio5\n");
+		*((volatile unsigned int *) GIO_DIR01) &= ~(1<<5);	
+		*((volatile unsigned int *) GIO_SET_DATA01) &= ~(1<<5); // output Low
+	
+			/* set GIO10 output  */
+	//		printf("pull up gio10\n");
+	       *((volatile unsigned int *) GIO_DIR01) &= ~(1<<10);	
+		   *((volatile unsigned int *) GIO_SET_DATA01) |= (1<<10); // output Hi
+
+
+	      	/* set GIO32 output	*/
+	      *((volatile unsigned int *) GIO_DIR23) &= ~(1<<0);  
+	      *((volatile unsigned int *) GIO_SET_DATA23) |= (1<<0); // output Hi
+	      	/* set GIO102 output	*/	   
+#define PINMUX0     0x01C40000
+        /* Enable UART1 MUX Lines */
+        *(volatile unsigned int *)PINMUX0 &= ~3;	
+        *((volatile unsigned int *) GIO_DIR06) &= ~(1<<6);     
+	      *((volatile unsigned int *) GIO_SET_DATA06) |= (1<<6); // output Hi 
+
+	      /* CE01:External Memory setting */
+       	/* PLL1 404MHZ	EMIF 101MHZ  unit 10 ns   */ 
+      
+	    /*  *((volatile unsigned int *) GIO_A2CR) =  DM9000_TIMING ; */	 						
+#endif
+        /* Configure MUX settings */
+
+      /* Power on required peripherals 
+    	davinci_psc_all_enable(); */
+#if 0
+      	/* this speeds up your boot a quite a bit.  However to make it
+ 	 *  work, you need make sure your kernel startup flush bug is fixed.
+	 *  ... rkw ...
+	 */
+	icache_enable ();
+
+#endif
+      	inittimer ();
+
+      	return 0;
+}
+
+/* PSC Domains */
+
+#define LPSC_VPSSMSTR       0       // VPSS Master LPSC
+#define LPSC_VPSSSLV        1       // VPSS Slave LPSC
+#define LPSC_TPCC           2       // TPCC LPSC
+#define LPSC_TPTC0          3       // TPTC0 LPSC
+#define LPSC_TPTC1          4       // TPTC1 LPSC
+#define PAL_SYS_CLK_MODULE_SPI1 6 /**<SPI1 LPSC Module No*/
+#define PAL_SYS_CLK_MODULE_MMCSD1 7 /**<MMCSD1 LPSC Module No*/
+#define LPSC_USB            9       // USB LPSC
+#define PAL_SYS_CLK_MODULE_PWM3 10  /**<PWM3 LPSC Module No*/
+#define PAL_SYS_CLK_MODULE_SPI2 11  /**<SPI2 LPSC Module No*/
+#define PAL_SYS_CLK_MODULE_RTO 12   /**<TIMER2 LPSC Module No*/
+#define LPSC_DDR_EMIF       13      // DDR_EMIF LPSC
+#define LPSC_AEMIF          14      // AEMIF LPSC
+#define LPSC_MMC_SD         15      // MMC_SD LPSC
+#define LPSC_MEMSTICK       16      // MEMSTICK LPSC
+#define PAL_SYS_CLK_MODULE_ASP 17   /**<AEMIF LPSC Module No*/
+#define LPSC_I2C            18      // I2C LPSC
+#define LPSC_UART0          19      // UART0 LPSC
+#define LPSC_UART1          20      // UART1 LPSC
+#define LPSC_UART2          21      // UART2 LPSC
+#define LPSC_SPI            22      // SPI LPSC
+#define LPSC_PWM0           23      // PWM0 LPSC
+#define LPSC_PWM1           24      // PWM1 LPSC
+#define LPSC_PWM2           25      // PWM2 LPSC
+#define LPSC_GPIO           26      // GPIO LPSC
+#define LPSC_TIMER0         27      // TIMER0 LPSC
+#define LPSC_TIMER1         28      // TIMER1 LPSC
+#define LPSC_TIMER2         29      // TIMER2 LPSC
+#define LPSC_SYSTEM_SUBSYS  30      // SYSTEM SUBSYSTEM LPSC
+#define LPSC_ARM            31      // ARM LPSC
+#define PAL_SYS_CLK_MODULE_VPSS_DAC 40  /**<VPSS DAC LPSC Module No*/
+
+#define EPCPR               *( unsigned int* )( 0x01C41070 )
+#define PTCMD               *( unsigned int* )( 0x01C41120 )
+#define PTSTAT              *( unsigned int* )( 0x01C41128 )
+#define PDSTAT              *( unsigned int* )( 0x01C41200 )
+#define PDSTAT1             *( unsigned int* )( 0x01C41204 )
+#define PDCTL               *( unsigned int* )( 0x01C41300 )
+#define PDCTL1              *( unsigned int* )( 0x01C41304 )
+#define VBPR                *( unsigned int* )( 0x20000020 )
+
+/**************************************
+ Routine: board_setup_psc_on
+ Description:  Enable a PSC domain
+**************************************/
+void board_setup_psc_on( unsigned int domain, unsigned int id )
+{
+        volatile unsigned int* mdstat = ( unsigned int* )( 0x01C41800 + 4 * id );
+	      volatile unsigned int* mdctl  = ( unsigned int* )( 0x01C41A00 + 4 * id );
+
+	      *mdctl |= 0x00000003; // Set PowerDomain to turn on
+
+    	  if ( ( PDSTAT & 0x00000001 ) == 0 )
+    	  {
+                PDCTL1 |= 0x1;
+        	      PTCMD = ( 1 << domain );
+        	      while ( ( ( ( EPCPR >> domain ) & 1 ) == 0 ) );
+
+        	      PDCTL1 |= 0x100 ;
+        	      while( ! ( ( ( PTSTAT >> domain ) & 1 ) == 0 ) );
+    	  }
+    	  else
+    	  {
+        	      PTCMD = ( 1<<domain );
+        	      while( ! ( ( ( PTSTAT >> domain ) & 1 ) == 0 ) );
+    	  }
+
+    	  while( ! ( ( *mdstat & 0x0000001F ) == 0x3 ) );
+}
+
+/**************************************
+ Routine: davinci_psc_all_enable
+ Description:  Enable all PSC domains
+**************************************/
+void davinci_psc_all_enable(void)
+{
+#define PSC_ADDR            0x01C41000
+#define PTCMD               (PSC_ADDR+0x120)
+#define PTSTAT              (PSC_ADDR+0x128)
+
+        unsigned int alwaysOnPdNum = 0, dspPdNum = 1, i;
+
+    	  /* This function turns on all clocks in the ALWAYSON and DSP Power
+	       * Domains.  Note this function assumes that the Power Domains are
+	       * already on.
+	       */
+#if 0
+    	  /* Write ENABLE (0x3) to all 41 MDCTL[i].NEXT bit fields. */
+    	  for( i = 0; i < 41; i++){
+                *(volatile unsigned int*) (PSC_ADDR+0xA00+4*i) =
+				        *(volatile unsigned int*) (PSC_ADDR+0xA00+4*i) | 0x3;
+    	  }
+
+    	  /* For special workaround:  Set MDCTL[i].EMURSTIE to 0x1 for all of the
+	       * following Modules.  VPSSSLV, EMAC, EMACCTRL, MDIO, USB, ATA, VLYNQ,
+         * HPI, DDREMIF, AEMIF, MMCSD, MEMSTICK, ASP, GPIO, IMCOP.
+         */
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*1) = *(unsigned int*) (PSC_ADDR+0xA00+4*1) | 0x203;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*5) = *(unsigned int*) (PSC_ADDR+0xA00+4*5) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*6) = *(unsigned int*) (PSC_ADDR+0xA00+4*6) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*7) = *(unsigned int*) (PSC_ADDR+0xA00+4*7) | 0x203;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*9) = *(unsigned int*) (PSC_ADDR+0xA00+4*9) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*10) = *(unsigned int*) (PSC_ADDR+0xA00+4*10) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*11) = *(unsigned int*) (PSC_ADDR+0xA00+4*11) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*12) = *(unsigned int*) (PSC_ADDR+0xA00+4*12) | 0x203;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*13) = *(unsigned int*) (PSC_ADDR+0xA00+4*13) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*14) = *(unsigned int*) (PSC_ADDR+0xA00+4*14) | 0x203;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*15) = *(unsigned int*) (PSC_ADDR+0xA00+4*15) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*16) = *(unsigned int*) (PSC_ADDR+0xA00+4*16) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*17) = *(unsigned int*) (PSC_ADDR+0xA00+4*17) | 0x203;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*19) = *(unsigned int*) (PSC_ADDR+0xA00+4*19) | 0x203;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*26) = *(unsigned int*) (PSC_ADDR+0xA00+4*26) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*40) = *(unsigned int*) (PSC_ADDR+0xA00+4*40) | 0x203;*/
+#endif
+
+        /* For special workaround:  Clear MDCTL[i].EMURSTIE to 0x0 for all of the following Modules.
+         *  VPSSSLV, EMAC, EMACCTRL, MDIO, USB, ATA, VLYNQ,
+         *  HPI, DDREMIF, AEMIF, MMCSD, MEMSTICK, ASP, GPIO, IMCOP.
+         */
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*1) = *(unsigned int*) (PSC_ADDR+0xA00+4*1) & 0x003;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*5) = *(unsigned int*) (PSC_ADDR+0xA00+4*5) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*6) = *(unsigned int*) (PSC_ADDR+0xA00+4*6) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*7) = *(unsigned int*) (PSC_ADDR+0xA00+4*7) | 0x003;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*9) = *(unsigned int*) (PSC_ADDR+0xA00+4*9) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*10) = *(unsigned int*) (PSC_ADDR+0xA00+4*10) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*11) = *(unsigned int*) (PSC_ADDR+0xA00+4*11) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*12) = *(unsigned int*) (PSC_ADDR+0xA00+4*12) & 0x003;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*13) = *(unsigned int*) (PSC_ADDR+0xA00+4*13) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*14) = *(unsigned int*) (PSC_ADDR+0xA00+4*14) | 0x003;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*15) = *(unsigned int*) (PSC_ADDR+0xA00+4*15) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*16) = *(unsigned int*) (PSC_ADDR+0xA00+4*16) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*17) = *(unsigned int*) (PSC_ADDR+0xA00+4*17) & 0x003;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*19) = ((*(unsigned int*) (PSC_ADDR+0xA00+4*19))&0xFFFFFFF8) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*20) = ((*(unsigned int*) (PSC_ADDR+0xA00+4*20))&0xFFFFFFF8) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*21) = ((*(unsigned int*) (PSC_ADDR+0xA00+4*21))&0xFFFFFFF8) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*18) = *(unsigned int*) (PSC_ADDR+0xA00+4*18) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*28) = *(unsigned int*) (PSC_ADDR+0xA00+4*28) | 0x003;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*26) = *(unsigned int*) (PSC_ADDR+0xA00+4*26) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*40) = *(unsigned int*) (PSC_ADDR+0xA00+4*40) & 0x003;*/
+
+    	  /* Set PTCMD.GO0 to 0x1 to initiate the state transtion for Modules in
+	       * the ALWAYSON Power Domain
+	       */
+    	  *(volatile unsigned int*) PTCMD = (1<<alwaysOnPdNum);
+
+
+    	  /* Wait for PTSTAT.GOSTAT0 to clear to 0x0 */
+    	  while(! (((*(volatile unsigned int*) PTSTAT >> alwaysOnPdNum) & 0x00000001) == 0));
+
+	/* Wait for PTSTAT.GOSTAT0 to clear to 0x0 */
+          while(! ((*(unsigned int*) (PSC_ADDR+0x800+4*19)& 0x0000001F ) == 0x3));
+	/* Wait for PTSTAT.GOSTAT0 to clear to 0x0 */
+          while(! ((*(unsigned int*) (PSC_ADDR+0x800+4*20)& 0x0000001F ) == 0x3));
+	/* Wait for PTSTAT.GOSTAT0 to clear to 0x0 */
+          while(! ((*(unsigned int*) (PSC_ADDR+0x800+4*21)& 0x0000001F ) == 0x3));
+        /* Bringup UART out of reset here since NS16650 code that we are using from uBoot
+         * will not do it
+         */
+
+#define UART0PWREMU_MGMT     0x01c20030
+        *(volatile unsigned int*) UART0PWREMU_MGMT |= 0x00008001;
+
+
+#define UART1PWREMU_MGMT     0x01c20430
+        *(volatile unsigned int*) UART1PWREMU_MGMT |= 0x00008001;
+
+#define UART2PWREMU_MGMT     0x01e06030
+        *(volatile unsigned int*) UART2PWREMU_MGMT |= 0x00008001;
+
+#define PINMUX3     0x01C4000C
+        /* Enable UART1 MUX Lines */
+        *(volatile unsigned int *)PINMUX3 |= 0x00600000;
+	
+				/* Enable UART2 MUX Lines */
+        *(volatile unsigned int *)PINMUX3 |= 0x0000AA00;
+
+	/* Set the Bus Priority Register to appropriate value */
+	VBPR = 0x20;
+}
+
+/******************************
+ Routine: misc_init_r
+ Description:  Misc. init
+******************************/
+int misc_init_r (void)
+{
+	char temp[20], *env=0;
+	char rtcdata[10] = { 4, 1, 0, 0, 0, 0, 0, 0, 0, 0};
+    int clk = 0;
+    unsigned short regval=0 ;
+
+    clk = ((PLL2_PLLM + 1) * 24) / ((PLL2_PREDIV & 0x1F) + 1); 
+
+    printf ("ARM Clock :- %dMHz\n", ( ( ((PLL1_PLLM+1)*24 )/(2*(7+1)*((SYSTEM_MISC & 0x2)?2:1 )))) );
+    printf ("DDR Clock :- %dMHz\n", (clk/2));
+
+	/* set GIO5 output, imager reset  */
+	//printf("pull up gio5\n");
+	*((volatile unsigned int *) GIO_SET_DATA01) |= (1<<5); // output High
+		   
+    return (0);
+}
+
+/******************************
+ Routine: dram_init
+ Description:  Memory Info
+******************************/
+int dram_init (void)
+{
+        DECLARE_GLOBAL_DATA_PTR;
+
+	      gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	      gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+        return 0;
+}
+
+
+typedef int     Bool;
+#define TRUE        ((Bool) 1)
+#define FALSE       ((Bool) 0)
+
+
+typedef int             Int;
+typedef unsigned int    Uns;    /* deprecated type */
+typedef char            Char;
+typedef char *          String;
+typedef void *          Ptr;
+
+/* unsigned quantities */
+typedef unsigned int    Uint32;
+typedef unsigned short  Uint16;
+typedef unsigned char   Uint8;
+
+/* signed quantities */
+typedef int             Int32;
+typedef short           Int16;
+typedef char            Int8;
+
+/* volatile unsigned quantities */
+typedef volatile unsigned int       VUint32;
+typedef volatile unsigned short     VUint16;
+typedef volatile unsigned char      VUint8;
+
+/* volatile signed quantities */
+typedef volatile int                VInt32;
+typedef volatile short              VInt16;
+typedef volatile char               VInt8;
+
+typedef struct _uart_regs
+{
+    VUint32 RBR;
+    VUint32 IER;
+    VUint32 IIR;
+    VUint32 LCR;
+    VUint32 MCR;
+    VUint32 LSR;
+    VUint32 MSR;
+    VUint32 SCR;
+    VUint8 DLL;
+    VUint8 RSVDO[3];
+    VUint8 DLH;
+    VUint8 RSVD1[3];
+    VUint32 PID1;
+    VUint32 PID2;
+    VUint32 PWREMU_MGNT;
+} uartRegs;
+
+#define THR RBR
+#define FCR IIR
+
+#define UART0 ((uartRegs*) 0x01C20000)
+#define UART1 ((uartRegs*) 0x01C20400)
+
+#define MAXSTRLEN 256
+#define E_PASS    0x00000000u
+#define E_FAIL    0x00000001u
+#define E_TIMEOUT 0x00000002u
+
+
+
+// Send specified number of bytes
+
+Int32 GetStringLen(Uint8* seq)
+{
+    Int32 i = 0;
+    while ((seq[i] != 0) && (i<MAXSTRLEN)){ i++;}
+    if (i == MAXSTRLEN)
+        return -1;
+    else
+        return i;
+}
+
+Uint32 UARTSendData(Uint8* seq, Bool includeNull)
+{
+    Uint32 status = 0;
+    Int32 i,numBytes;
+    Uint32 timerStatus = 0x1000000;
+
+    numBytes = includeNull?(GetStringLen(seq)+1):(GetStringLen(seq));
+
+    for(i=0;i<numBytes;i++) {
+        /* Enable Timer one time */
+        //TIMER0Start();
+        do{
+            status = (UART0->LSR)&(0x60);
+            //timerStatus = TIMER0Status();
+            timerStatus--;
+        } while (!status && timerStatus);
+
+        if(timerStatus == 0)
+            return E_TIMEOUT;
+
+        // Send byte
+        (UART0->THR) = seq[i];
+    }
+    return E_PASS;
+}
+
+Uint32 UARTSendInt(Uint32 value)
+{
+    char seq[9];
+    Uint32 i,shift,temp;
+
+    for( i = 0; i < 8; i++)
+    {
+        shift = ((7-i)*4);
+        temp = ((value>>shift) & (0x0000000F));
+        if (temp > 9)
+        {
+            temp = temp + 7;
+        }
+        seq[i] = temp + 48;
+        seq[i] = temp + 48;
+    }
+    seq[8] = 0;
+    return UARTSendData(seq, FALSE);
+}
+
+#define I2C_BASE                0x01C21000
+#define	I2C_OA			(I2C_BASE + 0x00)
+#define I2C_IE                  (I2C_BASE + 0x04)
+#define I2C_STAT                (I2C_BASE + 0x08)
+#define I2C_SCLL                (I2C_BASE + 0x0c)
+#define I2C_SCLH                (I2C_BASE + 0x10)
+#define I2C_CNT                 (I2C_BASE + 0x14)
+#define I2C_DRR                 (I2C_BASE + 0x18)
+#define I2C_SA                  (I2C_BASE + 0x1c)
+#define I2C_DXR                 (I2C_BASE + 0x20)
+#define I2C_CON                 (I2C_BASE + 0x24)
+#define I2C_IV                  (I2C_BASE + 0x28)
+#define I2C_PSC                 (I2C_BASE + 0x30)
+
+#define I2C_CON_EN      (1 << 5)       /* I2C module enable */
+#define I2C_CON_STB     (1 << 4)       /* Start byte mode (master mode only) */
+#define I2C_CON_MST     (1 << 10)      /* Master/slave mode */
+#define I2C_CON_TRX     (1 << 9)       /* Transmitter/receiver mode (master mode only) */
+#define I2C_CON_XA      (1 << 8)       /* Expand address */
+#define I2C_CON_STP     (1 << 11)      /* Stop condition (master mode only) */
+#define I2C_CON_STT     (1 << 13)      /* Start condition (master mode only) */
+
+#define I2C_STAT_BB     (1 << 12)       /* Bus busy */
+#define I2C_STAT_ROVR   (1 << 11)       /* Receive overrun */
+#define I2C_STAT_XUDF   (1 << 10)       /* Transmit underflow */
+#define I2C_STAT_AAS    (1 << 9)        /* Address as slave */
+#define I2C_STAT_SCD    (1 << 5)        /* Stop condition detect */
+#define I2C_STAT_XRDY   (1 << 4)        /* Transmit data ready */
+#define I2C_STAT_RRDY   (1 << 3)        /* Receive data ready */
+#define I2C_STAT_ARDY   (1 << 2)        /* Register access ready */
+#define I2C_STAT_NACK   (1 << 1)        /* No acknowledgment interrupt enable */
+#define I2C_STAT_AL     (1 << 0)        /* Arbitration lost interrupt enable */
+
+static Int16 I2C_init(void );
+static Int16 I2C_close(void );
+static Int16 I2C_reset( void);
+static Int16 I2C_write( Uint16 i2c_addr, Uint8* data, Uint16 len );
+static Int16 I2C_read( Uint16 i2c_addr, Uint8* data, Uint16 len );
+Int32 i2c_timeout = 0x10000;
+
+Int16 MSP430_getReg( Int16 reg, Uint16 *regval )
+{
+    volatile Int16 retcode;
+    Uint8 msg[2];
+
+    I2C_reset();
+    udelay(10000);
+    /* Send Msg */
+    msg[0] = (Uint8)(reg & 0xff);
+    if ( retcode = I2C_write( 0x25, msg, 1) )
+    {
+        return retcode;
+    }
+
+    if ( retcode = I2C_read(  0x25, msg, 1 ) )
+    {
+        return retcode;
+    }
+
+    *regval = msg[0];
+
+    /* Wait 1 msec */
+    udelay( 1000 );
+
+    return 0;
+}
+
+static Int16 I2C_init( )
+{
+    outw(0, I2C_CON);                // Reset I2C
+    outw(26,I2C_PSC);               // Config prescaler for 27MHz
+    outw(20,I2C_SCLL);              // Config clk LOW for 20kHz
+    outw(20,I2C_SCLH);               // Config clk HIGH for 20kHz
+    outw(inw(I2C_CON) | I2C_CON_EN,I2C_CON);        // Release I2C from reset
+    return 0;
+}
+
+/* ------------------------------------------------------------------------ *
+ *                                                                          *
+ *  _I2C_close( )                                                           *
+ *                                                                          *
+ * ------------------------------------------------------------------------ */
+static Int16 I2C_close( )
+{
+        outw(0,I2C_CON);                      // Reset I2C
+        return 0;
+}
+
+/* ------------------------------------------------------------------------ *
+ *                                                                          *
+ *  _I2C_reset( )                                                           *
+ *                                                                          *
+ * ------------------------------------------------------------------------ */
+static Int16 I2C_reset( )
+{
+    I2C_close( );
+    I2C_init( );
+    return 0;
+}
+
+static Int16 I2C_write( Uint16 i2c_addr, Uint8* data, Uint16 len )
+{
+    Int32 timeout, i, status;
+
+        outw(len, I2C_CNT);                    // Set length
+        outw(i2c_addr, I2C_SA);               // Set I2C slave address
+        outw(0x2000               // Set for Master Write
+             | 0x0200
+             | 0x0400
+             | I2C_CON_EN
+             | 0x4000, I2C_CON );
+
+        udelay( 10 );                        // Short delay
+
+        for ( i = 0 ; i < len ; i++ )
+        {
+            outw( data[i],I2C_DXR);;            // Write
+
+            timeout = i2c_timeout;
+            do
+            {
+                if ( timeout-- < 0  )
+                {
+                    I2C_reset( );
+                    return -1;
+                }
+            } while ( ( inw(I2C_STAT) & I2C_STAT_XRDY ) == 0 );// Wait for Tx Ready
+        }
+
+        outw( inw(I2C_CON) | 0x0800, I2C_CON);             // Generate STOP
+
+        return 0;
+
+}
+static Int16 I2C_read( Uint16 i2c_addr, Uint8* data, Uint16 len )
+{
+    Int32 timeout, i, status;
+
+    outw( len, I2C_CNT);                    // Set length
+    outw( i2c_addr, I2C_SA);               // Set I2C slave address
+    outw( 0x2000               // Set for Master Read
+          | 0x0400
+          | I2C_CON_EN
+          | 0x4000,I2C_CON);
+
+    udelay( 10 );                        // Short delay
+
+    for ( i = 0 ; i < len ; i++ )
+    {
+        timeout = i2c_timeout;
+
+        /* Wait for Rx Ready */
+        do
+        {
+            if ( timeout-- < 0 )
+            {
+                I2C_reset( );
+                return -1;
+            }
+        } while ( ( inw(I2C_STAT) & I2C_STAT_RRDY ) == 0 );// Wait for Rx Ready
+
+        data[i] = inw(I2C_DRR);            // Read
+    }
+
+      //I2C_ICMDR |= ICMDR_STP;             // Generate STOP
+    return 0;
+}
+
diff -Nurd u-boot-1.2.0/board/dm355_leopard/flash.c u-boot-1.2.0-leopard/board/dm355_leopard/flash.c
--- u-boot-1.2.0/board/dm355_leopard/flash.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_leopard/flash.c	2009-03-01 04:27:24.000000000 -0300
@@ -0,0 +1,758 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2003
+ * Reinhard Meyer, EMK Elektronik GmbH, r.meyer@emk-elektronik.de
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */	
+
+#include <common.h>
+#include <linux/byteorder/swab.h>
+#include "types.h"
+
+#if !defined(CFG_NO_FLASH)
+flash_info_t	flash_info[CFG_MAX_FLASH_BANKS]; /* info for FLASH chips */
+
+#if define (CFG_DM355_BASSET)
+  typedef unsigned short FLASH_PORT_WIDTH;
+  typedef volatile unsigned short FLASH_PORT_WIDTHV;
+  #define	FLASH_ID_MASK	0xFF
+
+  #define FPW	FLASH_PORT_WIDTH
+  #define FPWV	FLASH_PORT_WIDTHV
+
+  #define EVMDM355_FLASH_CTL555        *(u16*)( CFG_FLASH_BASE + (0x555 << 1))
+  #define EVMDM355_FLASH_CTL2AA        *(u16*)( CFG_FLASH_BASE + (0x2aa << 1))
+  #define EVMDM355_CPLD                *(u16*)( CFG_FLASH_BASE + (0x1c000 << 0) )
+  #define EVMDM355_CPLD_MASK           0x3FC000
+
+  #define FLASH_CYCLE1	(0x0555)
+  #define FLASH_CYCLE2	(0x02aa)
+  #define FLASH_ID1		0
+  #define FLASH_ID2		1
+  #define FLASH_ID3		0x0e
+  #define FLASH_ID4		0x0F
+  #define SWAP(x)			__swab16(x)
+#endif
+
+#if defined (CONFIG_TOP860)
+  typedef unsigned short FLASH_PORT_WIDTH;
+  typedef volatile unsigned short FLASH_PORT_WIDTHV;
+  #define	FLASH_ID_MASK	0xFF
+
+  #define FPW	FLASH_PORT_WIDTH
+  #define FPWV	FLASH_PORT_WIDTHV
+
+  #define FLASH_CYCLE1	0x0555
+  #define FLASH_CYCLE2	0x02aa
+  #define FLASH_ID1		0
+  #define FLASH_ID2		1
+  #define FLASH_ID3		0x0e
+  #define FLASH_ID4		0x0F
+#endif
+
+#if defined (CONFIG_TOP5200) && !defined (CONFIG_LITE5200)
+  typedef unsigned char FLASH_PORT_WIDTH;
+  typedef volatile unsigned char FLASH_PORT_WIDTHV;
+  #define	FLASH_ID_MASK	0xFF
+
+  #define FPW	FLASH_PORT_WIDTH
+  #define FPWV	FLASH_PORT_WIDTHV
+
+  #define FLASH_CYCLE1	(0x0aaa << 1)
+  #define FLASH_CYCLE2	(0x0555 << 1)
+  #define FLASH_ID1		0
+  #define FLASH_ID2		2
+  #define FLASH_ID3		0x1c
+  #define FLASH_ID4		0x1E
+#endif
+
+#if defined (CONFIG_TOP5200) && defined (CONFIG_LITE5200)
+  typedef unsigned char FLASH_PORT_WIDTH;
+  typedef volatile unsigned char FLASH_PORT_WIDTHV;
+  #define	FLASH_ID_MASK	0xFF
+
+  #define FPW	FLASH_PORT_WIDTH
+  #define FPWV	FLASH_PORT_WIDTHV
+
+  #define FLASH_CYCLE1	0x0555
+  #define FLASH_CYCLE2	0x02aa
+  #define FLASH_ID1		0
+  #define FLASH_ID2		1
+  #define FLASH_ID3		0x0E
+  #define FLASH_ID4		0x0F
+#endif
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size(FPWV *addr, flash_info_t *info);
+static void flash_reset(flash_info_t *info);
+static int write_word(flash_info_t *info, FPWV *dest, FPW data);
+static flash_info_t *flash_get_info(ulong base);
+void inline spin_wheel (void);
+
+/*-----------------------------------------------------------------------
+ * flash_init()
+ *
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long flash_init (void)
+{
+	unsigned long size = 0;
+	int i = 0;
+    u16   mfgid, devid;
+	extern void flash_preinit(void);
+	extern void flash_afterinit(uint, ulong, ulong);
+	ulong flashbase = CFG_FLASH_BASE;
+
+#if 0
+    EVMDM355_CPLD = 0;
+    EVMDM355_FLASH_CTL555 = 0xf0;
+
+    EVMDM355_FLASH_CTL555 = 0xaa;
+    EVMDM355_FLASH_CTL2AA = 0x55;
+    EVMDM355_FLASH_CTL555 = 0x90;
+	/* The manufacturer codes are only 1 byte, so just use 1 byte.
+	 * This works for any bus width and any FLASH device width.
+	 */
+	udelay(100);
+    mgfid = *((u16*)CFG_FLASH_BASE);
+    devid = *((u16*)CFG_FLASH_BASE +1);
+
+    *((u8 *)CFG_FLASH_BASE) = 0xf0;
+
+    printf("MFGID %x \n", mfgid);
+    printf("DEVIU %x \n", devid);
+    if ((mfgid != 0x0001) || (devid != 0x227e))
+        return 1;
+#endif
+
+	/*flash_preinit();*/
+
+	/* There is only ONE FLASH device */
+	memset(&flash_info[i], 0, sizeof(flash_info_t));
+	flash_info[i].size =
+			flash_get_size((FPW *)flashbase, &flash_info[i]);
+	size += flash_info[i].size;
+
+#if CFG_MONITOR_BASE >= CFG_FLASH_BASE
+	/* monitor protection ON by default */
+	flash_protect(FLAG_PROTECT_SET,
+		      CFG_MONITOR_BASE,
+		      CFG_MONITOR_BASE+monitor_flash_len-1,
+		      flash_get_info(CFG_MONITOR_BASE));
+#endif
+
+#ifdef	CFG_ENV_IS_IN_FLASH
+	/* ENV protection ON by default */
+	flash_protect(FLAG_PROTECT_SET,
+		      CFG_ENV_ADDR,
+		      CFG_ENV_ADDR+CFG_ENV_SIZE-1,
+		      flash_get_info(CFG_ENV_ADDR));
+#endif
+
+
+	/*flash_afterinit(i, flash_info[i].start[0], flash_info[i].size);*/
+	return size ? size : 1;
+}
+
+/*-----------------------------------------------------------------------
+ */
+static void flash_reset(flash_info_t *info)
+{
+	FPWV *base = (FPWV *)(info->start[0]);
+
+	/* Put FLASH back in read mode */
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL)
+		*base = (FPW)0x00FF00FF;	/* Intel Read Mode */
+	else if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD)
+		*base = (FPW)0x00F000F0;	/* AMD Read Mode */
+}
+
+
+void flash_reset_sector(flash_info_t *info, ULONG addr)
+{  
+	// Reset Flash to be in Read Array Mode 
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL)
+		*(FPWV *)addr = (FPW)0x00FF00FF;	/* Intel Read Mode */
+	else if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD)
+		*(FPWV *)addr = (FPW)0x00F000F0;	/* AMD Read Mode */
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+static flash_info_t *flash_get_info(ulong base)
+{
+	int i;
+	flash_info_t * info;
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i ++) {
+		info = & flash_info[i];
+		if (info->size &&
+			info->start[0] <= base && base <= info->start[0] + info->size - 1)
+			break;
+	}
+
+	return i == CFG_MAX_FLASH_BANKS ? 0 : info;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+void flash_print_info (flash_info_t *info)
+{
+	int i;
+	uchar *boottype;
+	uchar *bootletter;
+	uchar *fmt;
+	uchar botbootletter[] = "B";
+	uchar topbootletter[] = "T";
+	uchar botboottype[] = "bottom boot sector";
+	uchar topboottype[] = "top boot sector";
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		printf ("missing or unknown FLASH type\n");
+		return;
+	}
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case FLASH_MAN_AMD:	printf ("MY AMD ");		break;
+#if 0
+	case FLASH_MAN_BM:	printf ("BRIGHT MICRO ");	break;
+	case FLASH_MAN_FUJ:	printf ("FUJITSU ");		break;
+	case FLASH_MAN_SST:	printf ("SST ");		break;
+	case FLASH_MAN_STM:	printf ("STM ");		break;
+#endif
+	case FLASH_MAN_INTEL:	printf ("INTEL ");		break;
+	default:		printf ("Unknown Vendor ");	break;
+	}
+
+	/* check for top or bottom boot, if it applies */
+	if (info->flash_id & FLASH_BTYPE) {
+		boottype = botboottype;
+		bootletter = botbootletter;
+	}
+	else {
+		boottype = topboottype;
+		bootletter = topbootletter;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_AM160T:
+	case FLASH_AM160B:
+		fmt = "29LV160%s (16 Mbit, %s)\n";
+		break;
+	case FLASH_AMLV640U:
+		fmt = "29LV640M (64 Mbit)\n";
+		break;
+	case FLASH_AMDLV065D:
+		fmt = "29LV065D (64 Mbit)\n";
+		break;
+	case FLASH_AMLV256U:
+		fmt = "29LV256M (256 Mbit)\n";
+		break;
+	case FLASH_28F128P30T:
+		fmt = "28F128P30T\n";
+		break;
+    case FLASH_S29GL256N:
+        fmt = "S29GL256N\n";
+        break;
+	default:
+		fmt = "Unknown Chip Type\n";
+		break;
+	}
+
+	printf (fmt, bootletter, boottype);
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+		info->size >> 20,
+		info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+
+	for (i=0; i<info->sector_count; ++i) {
+		ulong	size;
+		int		erased;
+		ulong	*flash = (unsigned long *) info->start[i];
+
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+
+		/*
+		 * Check if whole sector is erased
+		 */
+		size =
+			(i != (info->sector_count - 1)) ?
+			(info->start[i + 1] - info->start[i]) >> 2 :
+		(info->start[0] + info->size - info->start[i]) >> 2;
+
+		for (
+			flash = (unsigned long *) info->start[i], erased = 1;
+				(flash != (unsigned long *) info->start[i] + size) && erased;
+					flash++
+			)
+			erased = *flash == ~0x0UL;
+
+		printf (" %08lX %s %s",
+			info->start[i],
+			erased ? "E": " ",
+			info->protect[i] ? "(RO)" : "    ");
+	}
+
+	printf ("\n");
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+/*
+ * The following code cannot be run from FLASH!
+ */
+
+ulong flash_get_size (FPWV *addr, flash_info_t *info)
+{
+	int		i;
+    u16     mfgid, devid, id3,id4;
+    
+
+	/* Write auto select command: read Manufacturer ID */
+	/* Write auto select command sequence and test FLASH answer */
+    //EVMDM355_CPLD = 0;
+	addr[FLASH_CYCLE1] = (FPW)0x00AA00AA;	/* for AMD, Intel ignores this */
+	addr[FLASH_CYCLE2] = (FPW)0x00550055;	/* for AMD, Intel ignores this */
+	addr[FLASH_CYCLE1] = (FPW)0x00900090;	/* selects Intel or AMD */
+#if 0
+    EVMDM355_FLASH_CTL555 = 0xf0;
+
+    EVMDM355_FLASH_CTL555 = 0xaa;
+    EVMDM355_FLASH_CTL2AA = 0x55;
+    EVMDM355_FLASH_CTL555 = 0x90;
+#endif
+
+	/* The manufacturer codes are only 1 byte, so just use 1 byte.
+	 * This works for any bus width and any FLASH device width.
+	 */
+	udelay(100);
+
+	switch ( (mfgid = addr[FLASH_ID1]) & 0xff) {
+
+	case (uchar)AMD_MANUFACT:
+		printf ("MY AMD ", addr[FLASH_ID1] & 0xff);
+		info->flash_id = FLASH_MAN_AMD;
+		break;
+
+	case (uchar)INTEL_MANUFACT:
+                printf ("INTEL %x", addr[FLASH_ID1] & 0xff);
+		info->flash_id = FLASH_MAN_INTEL;
+		break;
+
+	default:
+		printf ("unknown vendor=%x ", addr[FLASH_ID1] & 0xff);
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		break;
+	}
+
+	/* Check 16 bits or 32 bits of ID so work on 32 or 16 bit bus. */
+	if (info->flash_id != FLASH_UNKNOWN) switch (devid = (FPW)addr[FLASH_ID2]) {
+
+	case (FPW)AMD_ID_LV160B:
+		info->flash_id += FLASH_AM160B;
+		info->sector_count = 35;
+		info->size = 0x00200000;
+		info->start[0] = (ulong)addr;
+		info->start[1] = (ulong)addr + 0x4000;
+		info->start[2] = (ulong)addr + 0x6000;
+		info->start[3] = (ulong)addr + 0x8000;
+		for (i = 4; i < info->sector_count; i++)
+		{
+			info->start[i] = (ulong)addr + 0x10000 * (i-3);
+		}
+		break;
+
+	case (FPW)AMD_ID_LV065D:
+		info->flash_id += FLASH_AMDLV065D;
+		info->sector_count = 128;
+		info->size = 0x00800000;
+		for (i = 0; i < info->sector_count; i++)
+		{
+			info->start[i] = (ulong)addr + 0x10000 * i;
+		}
+		break;
+
+	case (FPW)AMD_ID_MIRROR:
+		/* MIRROR BIT FLASH, read more ID bytes */
+        id3 = (FPW)addr[FLASH_ID3];
+        id4 = (FPW)addr[FLASH_ID4];
+		if ((FPW)addr[FLASH_ID3] == (FPW)AMD_ID_LV640U_2 &&
+			(FPW)addr[FLASH_ID4] == (FPW)AMD_ID_LV640U_3)
+		{
+			info->flash_id += FLASH_AMLV640U;
+			info->sector_count = 128;
+			info->size = 0x00800000;
+			for (i = 0; i < info->sector_count; i++)
+			{
+				info->start[i] = (ulong)addr + 0x10000 * i;
+			}
+			break;
+		}
+		else if ((FPW)addr[FLASH_ID3] == (FPW)AMD_ID_LV256U_2 &&
+			(FPW)addr[FLASH_ID4] == (FPW)AMD_ID_LV256U_3)
+		{
+			/* attention: only the first 16 MB will be used in u-boot */
+			info->flash_id += FLASH_AMLV256U;
+			info->sector_count = 256;
+			info->size = 0x01000000;
+			for (i = 0; i < info->sector_count; i++)
+			{
+				info->start[i] = (ulong)addr + 0x10000 * i;
+			}
+			break;
+		}
+        else
+        {
+            /* This is the default NOR flash for DM355 */
+			info->flash_id += FLASH_S29GL256N;
+			info->sector_count = 256;
+			info->size = 0x02000000;
+			for (i = 0; i < info->sector_count; i++)
+			{
+                info->start[i] = (ulong)addr + 0x20000 * i;
+			}
+			break;
+        }
+	case (FPW)INTEL_ID_28F128P30T:
+		/* Intel StrataFlash 28F128P30T */
+		info->flash_id += FLASH_28F128P30T;
+		info->sector_count = 131;
+		info->size = 0x01000000;
+		for (i = 0; i < info->sector_count; i++)
+		{
+			if (i < 127)
+				info->start[i] = (ulong)addr + 0x20000 * i;
+			else
+				info->start[i] = (ulong)addr + 0xfe0000 + 0x8000 * (i-127);
+		}
+		break;
+
+		/* fall thru to here ! */
+	default:
+		printf ("unknown AMD device=%x %x %x",
+			(FPW)addr[FLASH_ID2],
+			(FPW)addr[FLASH_ID3],
+			(FPW)addr[FLASH_ID4]);
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0x800000;
+		break;
+	}
+
+	/* Put FLASH back in read mode */
+	flash_reset(info);
+
+	return (info->size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int	flash_erase (flash_info_t *info, int s_first, int s_last)
+{
+	FPWV *addr;
+	int flag, prot, sect;
+	int intel = (info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL;
+	ulong start, now, last;
+	int rcode = 0;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		if (info->flash_id == FLASH_UNKNOWN) {
+			printf ("- missing\n");
+		} else {
+			printf ("- no sectors to erase\n");
+		}
+		return 1;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_AM160B:
+	case FLASH_AMLV640U:
+		break;
+	case FLASH_AMLV256U:
+		break;
+	case FLASH_28F128P30T:
+		break;
+    case FLASH_S29GL256N:
+        break;
+	case FLASH_UNKNOWN:
+	default:
+		printf ("Can't erase unknown flash type %08lx - aborted\n",
+			info->flash_id);
+		return 1;
+	}
+
+	prot = 0;
+	for (sect=s_first; sect<=s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n",
+			prot);
+	} else {
+		printf ("\n");
+	}
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect<=s_last && rcode == 0; sect++) {
+
+		if (info->protect[sect] != 0)	/*bmw           esteem192e     ispan         mx1fs2       RPXlite      tqm8540
+ protected, skip it */
+			continue;
+
+		printf ("Erasing sector %2d ... ", sect);
+        
+        if ( sect == s_first )
+        {
+		    addr = (FPWV *)(((info->start[sect]) & EVMDM355_CPLD_MASK) >> 14 );
+        }
+        else
+        { 
+            addr += 2;
+        }
+
+        EVMDM355_CPLD = addr; 
+
+		if (intel) {
+			*addr = (FPW)0x00600060; /* unlock block setup */
+			*addr = (FPW)0x00d000d0; /* unlock block confirm */
+			*addr = (FPW)0x00500050; /* clear status register */
+			*addr = (FPW)0x00200020; /* erase setup */
+			*addr = (FPW)0x00D000D0; /* erase confirm */
+			while((*addr & 0x80) == 0);
+			printf("done.\n");
+		}
+		else {
+			/* must be AMD style if not Intel */
+			FPWV *base;		/* first address in bank */
+
+			base = (FPWV *)(info->start[0]);
+			base[FLASH_CYCLE1] = (FPW)0x00AA00AA;	/* unlock */
+			base[FLASH_CYCLE2] = (FPW)0x00550055;	/* unlock */
+			base[FLASH_CYCLE1] = (FPW)0x00800080;	/* erase mode */
+			base[FLASH_CYCLE1] = (FPW)0x00AA00AA;	/* unlock */
+			base[FLASH_CYCLE2] = (FPW)0x00550055;	/* unlock */
+			base[0] = (FPW)0x00300030;	/* erase sector */
+			while (!(*((vHwdptr)base) & 0x80));
+			printf("done.\n");
+		}
+
+
+	}
+
+    EVMDM355_CPLD = 0; 
+	/* Put FLASH back in read mode */
+	flash_reset(info);
+
+	printf (" Erase Operation Completed.\n");
+	return rcode;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+int write_buff (flash_info_t *info, uchar *src, ulong addr, ulong cnt)
+{
+	FPW data = 0; /* 16 or 32 bit word, matches flash bus width on MPC8XX */
+	int bytes;	  /* number of bytes to program in current word		*/
+	int left;	  /* number of bytes left to program			*/
+	int res;
+	ulong cp, wp;
+	int count, i, l, rc, port_width;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		return 4;
+		}
+
+	/* get lower word aligned address */
+	wp = (addr & ~1);
+	port_width = 2;
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+		for (; i < port_width && cnt > 0; ++i) {
+			data = (data << 8) | *src++;
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < port_width; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+
+		if ((rc = write_word (info, wp, SWAP (data))) != 0) {
+			return (rc);
+		}
+		wp += port_width;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	count = 0;
+	while (cnt >= port_width) {
+		data = 0;
+		for (i = 0; i < port_width; ++i) {
+			data = (data << 8) | *src++;
+		}
+		if ((rc = write_word (info, wp, SWAP (data))) != 0) {
+			return (rc);
+		}
+		wp += port_width;
+		cnt -= port_width;
+
+		if (count++ > 0x800) {
+			spin_wheel ();
+			count = 0;
+		}
+	}
+
+	if (cnt == 0) {
+		return (0);
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < port_width && cnt > 0; ++i, ++cp) {
+		data = (data << 8) | *src++;
+		--cnt;
+	}
+	for (; i < port_width; ++i, ++cp) {
+		data = (data << 8) | (*(uchar *) cp);
+	}
+
+	return (write_word (info, wp, SWAP (data)));
+}
+
+/*-----------------------------------------------------------------------
+ * Write a word to Flash
+ * A word is 16 or 32 bits, whichever the bus width of the flash bank
+ * (not an individual chip) is.
+ *
+ * returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+static int write_word (flash_info_t *info, FPWV *plAddress, FPW ulData)
+{
+	ulong start;
+	int flag;
+	int res = 0;	/* result, assume success	*/
+	FPWV *base;		/* first address in flash bank	*/
+	volatile USHORT *psAddress;
+	volatile USHORT *address_cs;
+	USHORT tmp;
+	ULONG tmp_ptr;
+
+	// Lower WORD.
+	psAddress = (USHORT *)plAddress;
+	tmp_ptr  = (ULONG) plAddress;
+	address_cs = (USHORT *) (tmp_ptr & 0xFE000000);
+
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL)
+	{
+		*plAddress = (FPW)0x00400040;
+		*plAddress = ulData;
+		while ((*plAddress & 0x80) == 0);
+	}
+	else if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD)
+	{
+		*((vHwdptr)address_cs + 0x555) = ((Hwd)0xAA);
+		*((vHwdptr)address_cs + 0x2AA) = ((Hwd)0x55);
+		*((vHwdptr)address_cs + 0x555) = ((Hwd)0xA0);
+		*psAddress = ulData;
+		// Wait for ready.
+		while (1)
+		{
+			tmp = *psAddress; 
+			if( (tmp & 0x80)  == (ulData & 0x80)) 
+			{
+				break;
+			}
+			else
+			{
+				if(tmp & 0x20)             // Exceeded Time Limit
+			{
+				tmp = *psAddress; 
+				if( (tmp & 0x80)  == (ulData & 0x80)) 
+				{
+					break; 
+				}
+				else
+				{
+				  	flash_reset_sector(info, (ULONG) psAddress);
+			      	return 1;
+				}	
+			}
+			}
+		}
+	}
+
+	// Return to read mode
+	flash_reset_sector(info, (ULONG) psAddress);
+
+	// Verify the data.
+	if (*psAddress != ulData)
+	{
+     	return 1;
+	printf("Write of one 16-bit word failed\n");
+	}
+	return 0;
+}
+
+void inline spin_wheel (void)
+{
+	static int p = 0;
+	static char w[] = "\\/-";
+
+	printf ("\010%c", w[p]);
+	(++p == 3) ? (p = 0) : 0;
+}
+#endif
diff -Nurd u-boot-1.2.0/board/dm355_leopard/flash_params.h u-boot-1.2.0-leopard/board/dm355_leopard/flash_params.h
--- u-boot-1.2.0/board/dm355_leopard/flash_params.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_leopard/flash_params.h	2009-03-01 04:24:26.000000000 -0300
@@ -0,0 +1,319 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ *
+ */
+#ifndef _FLASH_PARAMSH_
+#define _FLASH_PARAMSH_
+//
+//Structs
+//
+typedef struct _PageInfo
+{
+    	ULONG	reserved;
+    	BYTE  	BlockReserved;
+    	BYTE  	BadBlockFlag;
+    	USHORT	reserved2;
+}PageInfo, *PPageInfo;
+
+typedef struct
+{
+	ULONG ReturnValue;
+	ULONG ReadAddress;
+	ULONG WriteAddress;
+	ULONG Size;
+} Download_Parms, *PDownload_Parms;
+
+#define NO_ERROR            0
+#define CORRECTED_ERROR     1
+#define ECC_ERROR           2
+#define UNCORRECTED_ERROR   3
+
+
+#define BIT0    0x00000001
+#define BIT1    0x00000002
+#define BIT2    0x00000004
+#define BIT3    0x00000008
+#define BIT4    0x00000010
+#define BIT5    0x00000020
+#define BIT6    0x00000040
+#define BIT7    0x00000080
+#define BIT8    0x00000100
+#define BIT9    0x00000200
+#define BIT10   0x00000400
+#define BIT11   0x00000800
+#define BIT12   0x00001000
+#define BIT13   0x00002000
+#define BIT14   0x00004000
+#define BIT15   0x00008000
+#define BIT16   0x00010000
+#define BIT17   0x00020000
+#define BIT18   0x00040000
+#define BIT19   0x00080000
+#define BIT20   0x00100000
+#define BIT21   0x00200000
+#define BIT22   0x00400000
+#define BIT23   0x00800000
+#define BIT24   0x01000000
+#define BIT25   0x02000000
+#define BIT26   0x04000000
+#define BIT27   0x08000000
+#define BIT28   0x10000000
+#define BIT29   0x20000000
+#define BIT30   0x40000000
+#define BIT31   0x80000000
+
+
+
+//  Status bit pattern
+#define STATUS_READY                0x40
+#define STATUS_ERROR                0x01
+//
+//NOR SUPPORT
+//
+// Flash ID Commands INTEL
+#define INTEL_ID_CMD       ((Hwd)0x0090)     	// INTEL ID CMD
+#define INTEL_MANF_ID      ((Hwd)0x0089)     	// INTEL Manf ID expected
+#define INTEL_DEVICE_8T    ((Hwd)0x88F1)     	// INTEL 8Mb top device code
+#define INTEL_DEVICE_8B    ((Hwd)0x88F2)     	// INTEL 8Mb bottom device code
+#define INTEL_DEVICE_16T   ((Hwd)0x88F3)     	// INTEL 16Mb top device code
+#define INTEL_DEVICE_16B   ((Hwd)0x88F4)     	// INTEL 16Mb bottom device code
+#define INTELS_J3_DEVICE_32   ((Hwd)0x0016)     // INTEL Strata J3 32Mb device code
+#define INTELS_J3_DEVICE_64   ((Hwd)0x0017)     // INTEL Strata J3 64Mb device code
+#define INTELS_J3_DEVICE_128  ((Hwd)0x0018)     // INTEL Strata J3 128Mb device code
+#define INTELS_K3_DEVICE_64   ((Hwd)0x8801)     // INTEL Strata K3 64Mb device code
+#define INTELS_K3_DEVICE_128  ((Hwd)0x8802)    	// INTEL Strata K3 128Mb device code
+#define INTELS_K3_DEVICE_256  ((Hwd)0x8803)     // INTEL Strata K3 256Mb device code
+#define INTELS_W18_DEVICE_128T  ((Hwd)0x8876)   // INTEL Wirless Flash Top 128 Mb device code
+#define INTELS_W18_DEVICE_128B  ((Hwd)0x8867)   // INTEL Wirless Flash Bottom 128 Mb device code
+#define INTELS_L18_DEVICE_128T  ((Hwd)0x880C)   // INTEL Wirless Flash Top 128 Mb device code
+#define INTELS_L18_DEVICE_128B  ((Hwd)0x880F)   // INTEL Wirless Flash Bottom 128 Mb device code
+#define INTELS_L18_DEVICE_256T  ((Hwd)0x880D)   // INTEL Wirless Flash Top 256 Mb device code
+#define INTELS_L18_DEVICE_256B  ((Hwd)0x8810)  	// INTEL Wirless Flash Bottom 256 Mb device code
+#define INTELS_K18_DEVICE_256B  ((Hwd)0x8807)  	// INTEL Wirless Flash Bottom 256 Mb device code
+#define AMD1_DEVICE_ID     ((Hwd)0x2253)   // AMD29DL323CB
+#define AMD2_DEVICE_ID     ((Hwd)0x2249)   // AMD29LV160D
+#define AMD3_DEVICE_ID1    ((Hwd)0x2212)   // AMD29LV256M
+#define AMD3_DEVICE_ID2    ((Hwd)0x2201)   // AMD29LV256M
+// Flash ID Commands FUJITSU (Programs like AMD)
+#define FUJITSU_MANF_ID    ((Hwd)0x04)        // Fujitsu Manf ID expected
+#define FUJITSU1_DEVICE_ID     ((Hwd)0x2253)  // MBM29DL323BD
+//Micron Programs Like Intel or Micron
+#define MICRON_MANF_ID      ((Hwd)0x002C)     	// MICRON Manf ID expected
+#define MICRON_MT28F_DEVICE_128T ((Hwd)0x4492)	// MICRON Flash device Bottom 128 Mb
+//Samsung Programs like AMD
+#define SAMSUNG_MANF_ID      	((Hwd)0x00EC)     	//SAMSUNG Manf ID expected
+#define SAMSUNG_K8S2815E_128T  	((Hwd) 0x22F8)  	//SAMSUNG NOR Flash device TOP 128 Mb
+// Flash Erase Commands AMD and FUJITSU
+// Flash ID Commands AMD
+#define AMD_ID_CMD0        ((Hwd)0xAA)     // AMD ID CMD 0
+#define AMD_CMD0_ADDR       0x555          // AMD CMD0 Offset
+#define AMD_ID_CMD1        ((Hwd)0x55)     // AMD ID CMD 1
+#define AMD_CMD1_ADDR	    0x2AA          // AMD CMD1 Offset
+#define AMD_ID_CMD2        ((Hwd)0x90)     // AMD ID CMD 2
+#define AMD_CMD2_ADDR	    0x555          // AMD CMD2 Offset
+#define AMD_MANF_ID        ((Hwd)0x01)     // AMD Manf ID expected
+#define AMD_DEVICE_ID_MULTI   ((Hwd)0x227E)// Indicates Multi-Address Device ID
+#define AMD_DEVICE_ID_OFFSET 0x1
+#define AMD_DEVICE_ID_OFFSET1 0x0E         // First Addr for Multi-Address ID
+#define AMD_DEVICE_ID_OFFSET2 0x0F         // Second Addr for Multi-Address ID
+#define AMD_DEVICE_RESET   ((Hwd)0x00F0)   // AMD Device Reset Command
+#define AMD_ERASE_CMD0    ((Hwd)0xAA)
+#define AMD_ERASE_CMD1    ((Hwd)0x55)
+#define AMD_ERASE_CMD2    ((Hwd)0x80)
+#define AMD_ERASE_CMD3    ((Hwd)0xAA)     	// AMD29LV017B Erase CMD 3
+#define AMD_ERASE_CMD4    ((Hwd)0x55)     	// AMD29LV017B Erase CMD 4
+#define AMD_ERASE_CMD5    ((Hwd)0x10)     	// AMD29LV017B Erase CMD 5
+#define AMD_ERASE_DONE    ((Hwd)0xFFFF)     // AMD29LV017B Erase Done
+#define AMD_ERASE_BLK_CMD0	((Hwd)0xAA)
+#define AMD_ERASE_BLK_CMD1	((Hwd)0x55)
+#define AMD_ERASE_BLK_CMD2	((Hwd)0x80)
+#define AMD_ERASE_BLK_CMD3	((Hwd)0xAA)
+#define AMD_ERASE_BLK_CMD4	((Hwd)0x55)
+#define AMD_ERASE_BLK_CMD5	((Hwd)0x30)
+#define AMD_PROG_CMD0    ((Hwd)0xAA)
+#define AMD_PROG_CMD1    ((Hwd)0x55)
+#define AMD_PROG_CMD2    ((Hwd)0xA0)
+#define AMD2_ERASE_CMD0    ((Hwd)0x00AA)     // AMD29DL800B Erase CMD 0
+#define AMD2_ERASE_CMD1    ((Hwd)0x0055)     // AMD29DL800B Erase CMD 1
+#define AMD2_ERASE_CMD2    ((Hwd)0x0080)     // AMD29DL800B Erase CMD 2
+#define AMD2_ERASE_CMD3    ((Hwd)0x00AA)     // AMD29DL800B Erase CMD 3
+#define AMD2_ERASE_CMD4    ((Hwd)0x0055)     // AMD29DL800B Erase CMD 4
+#define AMD2_ERASE_CMD5    ((Hwd)0x0030)     // AMD29DL800B Erase CMD 5
+#define AMD2_ERASE_DONE    ((Hwd)0x00FF)     // AMD29DL800B Erase Done
+#define AMD_WRT_BUF_LOAD_CMD0           ((Hwd)0xAA)
+#define AMD_WRT_BUF_LOAD_CMD1           ((Hwd)0x55)
+#define AMD_WRT_BUF_LOAD_CMD2           ((Hwd)0x25)
+#define AMD_WRT_BUF_CONF_CMD0           ((Hwd)0x29)
+#define AMD_WRT_BUF_ABORT_RESET_CMD0    ((Hwd)0xAA)
+#define AMD_WRT_BUF_ABORT_RESET_CMD1    ((Hwd)0x55)
+#define AMD_WRT_BUF_ABORT_RESET_CMD2    ((Hwd)0xF0)
+// Flash Erase Commands INTEL
+#define INTEL_ERASE_CMD0   ((Hwd)0x0020)     // INTEL Erase CMD 0
+#define INTEL_ERASE_CMD1   ((Hwd)0x00D0)     // INTEL Erase CMD 1
+#define INTEL_ERASE_DONE   ((Hwd)0x0080)     // INTEL Erase Done
+#define INTEL_READ_MODE    ((Hwd)0x00FF)     // INTEL Read Array Mode
+#define STRATA_READ        0x4
+#define STRATA_WRITE       0x8
+// Flash Block Information
+// Intel Burst devices:
+//   2MB each (8 8KB [param] and 31 64KB [main] blocks each) for 8MB total
+#define NUM_INTEL_BURST_BLOCKS 8
+#define PARAM_SET0  0
+#define MAIN_SET0   1
+#define PARAM_SET1  2
+#define MAIN_SET1   3
+#define PARAM_SET2  4
+#define MAIN_SET2   5
+#define PARAM_SET3  6
+#define MAIN_SET3   7
+// Intel Strata devices:
+//   4MB each (32 128KB blocks each) for 8MB total
+//   8MB each (64 128KB blocks each) for 16MB total
+//  16MB each (128 128KB blocks each) for 32MB total
+#define NUM_INTEL_STRATA_BLOCKS 8
+#define BLOCK_SET0  0
+#define BLOCK_SET1  1
+#define BLOCK_SET2  2
+#define BLOCK_SET3  3
+#define BLOCK_SET4  4
+#define BLOCK_SET5  5
+#define BLOCK_SET6  6
+#define BLOCK_SET7  7
+// For AMD Flash
+#define NUM_AMD_SECTORS 8  // Only using the first 8 8-KB sections (64 KB Total)
+#define AMD_ADDRESS_CS_MASK		0xFE000000	//--AMD-- Set-up as 0xFE000000 per Jon Hunter (Ti)
+// Flash Types
+enum NORFlashType {
+	FLASH_NOT_FOUND,
+	FLASH_UNSUPPORTED,
+	FLASH_AMD_LV017_2MB,             	// (AMD AM29LV017B-80RFC/RE)
+	FLASH_AMD_DL800_1MB_BOTTOM,		  	// (AMD AM29DL800BB-70EC)
+	FLASH_AMD_DL800_1MB_TOP,			// (AMD AM29DL800BT-70EC)
+	FLASH_AMD_DL323_4MB_BOTTOM,		  	// (AMD AM29DL323CB-70EC)
+	FLASH_AMD_DL323_4MB_TOP,			// (AMD AM29DL323BT-70EC)
+	FLASH_AMD_LV160_2MB_BOTTOM,
+	FLASH_AMD_LV160_2MB_TOP,
+	FLASH_AMD_LV256M_32MB,             	// (AMD AM29LV256MH/L)
+	FLASH_INTEL_BURST_8MB_BOTTOM,	   	// (Intel DT28F80F3B-95)
+	FLASH_INTEL_BURST_8MB_TOP,		   	// (Intel DT28F80F3T-95)
+	FLASH_INTEL_BURST_16MB_BOTTOM,	   	// (Intel DT28F160F3B-95)
+	FLASH_INTEL_BURST_16MB_TOP,		   	// (Intel DT28F160F3T-95)
+	FLASH_INTEL_STRATA_J3_4MB,		   	// (Intel DT28F320J3A)
+	FLASH_INTEL_STRATA_J3_8MB,		   	// (Intel DT28F640J3A)
+	FLASH_INTEL_STRATA_J3_16MB,		   	// (Intel DT28F128J3A)
+	FLASH_FUJITSU_DL323_4MB_BOTTOM,    	// (Fujitsu DL323 Bottom
+	FLASH_INTEL_STRATA_K3_8MB,		   	// (Intel 28F64K3C115)
+	FLASH_INTEL_STRATA_K3_16MB,        	// (Intel 28F128K3C115)
+	FLASH_INTEL_STRATA_K3_32MB,        	// (Intel 28F256K3C115)
+	FLASH_INTEL_W18_16MB_TOP,    		// (Intel 28F128W18T) }
+	FLASH_INTEL_W18_16MB_BOTTOM,  		// (Intel 28F128W18B) }
+	FLASH_INTEL_L18_16MB_TOP,    		// (Intel 28F128L18T) }
+	FLASH_INTEL_L18_16MB_BOTTOM,  		// (Intel 28F128L18B) }
+	FLASH_INTEL_L18_32MB_TOP,    		// (Intel 28F256L18T) }
+	FLASH_INTEL_L18_32MB_BOTTOM,  		// (Intel 28F256L18B) }
+	FLASH_INTEL_K18_32MB_BOTTOM,  		// (Intel 28F256K18B) }
+	FLASH_MICRON_16MB_TOP,				// (Micron MT28F160C34 )
+	FLASH_SAMSUNG_16MB_TOP				// (Samsung K8S281ETA)
+};
+////NAND SUPPORT
+//
+enum NANDFlashType {
+	NANDFLASH_NOT_FOUND,
+	NANDFLASH_SAMSUNG_32x8_Q,             	// (Samsung K9F5608Q0B)
+	NANDFLASH_SAMSUNG_32x8_U,             	// (Samsung K9F5608U0B)
+	NANDFLASH_SAMSUNG_16x16_Q,             	// (Samsung K9F5616Q0B)
+	NANDFLASH_SAMSUNG_16x16_U,             	// (Samsung K9F5616U0B)
+	NANDFLASH_SAMSUNG_16x8_U				// (Samsung K9F1G08QOM)
+};
+// Samsung Manufacture Code
+#define SAMSUNG_MANUFACT_ID	0xEC
+// Samsung Nand Flash Device ID
+#define SAMSUNG_K9F5608Q0B	0x35
+#define SAMSUNG_K9F5608U0B	0x75
+#define SAMSUNG_K9F5616Q0B	0x45
+#define SAMSUNG_K9F5616U0B	0x55
+//  MACROS for NAND Flash support
+//  Flash Chip Capability
+#define NUM_BLOCKS                  0x800       //  32 MB On-board NAND flash.
+#define PAGE_SIZE                 	512
+#define SPARE_SIZE                  16
+#define PAGES_PER_BLOCK             32
+#define PAGE_TO_BLOCK(page)     	((page) >> 5 )
+#define BLOCK_TO_PAGE(block)      	((block)  << 5 )
+#define FILE_TO_PAGE_SIZE(fs) 		((fs / PAGE_SIZE) + ((fs % PAGE_SIZE) ? 1 : 0))
+//  For flash chip that is bigger than 32 MB, we need to have 4 step address
+#ifdef NAND_SIZE_GT_32MB
+#define NEED_EXT_ADDR               1
+#else
+#define NEED_EXT_ADDR               0
+#endif
+// Nand flash block status definitions.
+#define BLOCK_STATUS_UNKNOWN	0x01
+#define BLOCK_STATUS_BAD		0x02
+#define BLOCK_STATUS_READONLY	0x04
+#define BLOCK_STATUS_RESERVED   0x08
+#define BLOCK_RESERVED			0x01
+#define BLOCK_READONLY			0x02
+#define BADBLOCKMARK            0x00
+//  NAND Flash Command. This appears to be generic across all NAND flash chips
+#define CMD_READ                0x00        //  Read
+#define CMD_READ1               0x01        //  Read1
+#define CMD_READ2               0x50        //  Read2
+#define CMD_READID              0x90        //  ReadID
+#define CMD_WRITE               0x80        //  Write phase 1
+#define CMD_WRITE2              0x10        //  Write phase 2
+#define CMD_ERASE               0x60        //  Erase phase 1
+#define CMD_ERASE2              0xd0        //  Erase phase 2
+#define CMD_STATUS              0x70        //  Status read
+#define CMD_RESET               0xff        //  Reset
+//
+//Prototpyes
+//
+// NOR Flash Dependent Function Pointers
+void (*User_Hard_Reset_Flash)(void);
+void (*User_Soft_Reset_Flash)(unsigned long addr);
+void (*User_Flash_Erase_Block)(unsigned long addr);
+void (*User_Flash_Erase_All)(unsigned long addr);
+void (*User_Flash_Write_Entry)(void);
+int (*User_Flash_Write)(unsigned long *addr, unsigned short data);
+int (*User_Flash_Optimized_Write)(unsigned long *addr, unsigned short data[], unsigned long);
+void (*User_Flash_Write_Exit)(void);
+// Flash AMD Device Dependent Routines
+void AMD_Hard_Reset_Flash(void);
+void AMD_Soft_Reset_Flash(unsigned long);
+void AMD_Flash_Erase_Block(unsigned long);
+void AMD_Flash_Erase_All(unsigned long);
+int AMD_Flash_Write(unsigned long *, unsigned short);
+int AMD_Flash_Optimized_Write(unsigned long *addr, unsigned short data[], unsigned long length);
+void AMD_Write_Buf_Abort_Reset_Flash( unsigned long plAddress );
+// Flash Intel Device Dependent Routines
+void INTEL_Hard_Reset_Flash(void);
+void INTEL_Soft_Reset_Flash(unsigned long addr);
+void INTEL_Flash_Erase_Block(unsigned long);
+int INTEL_Flash_Write(unsigned long *addr, unsigned short data);
+int INTEL_Flash_Optimized_Write(unsigned long *addr, unsigned short data[], unsigned long length);
+
+//General Functions
+void Flash_Do_Nothing(void);
+
+#endif
+
+
diff -Nurd u-boot-1.2.0/board/dm355_leopard/lowlevel_init.S u-boot-1.2.0-leopard/board/dm355_leopard/lowlevel_init.S
--- u-boot-1.2.0/board/dm355_leopard/lowlevel_init.S	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_leopard/lowlevel_init.S	2009-03-01 04:24:26.000000000 -0300
@@ -0,0 +1,766 @@
+/*
+ * Board specific setup info
+ *
+ * (C) Copyright 2003
+ * Texas Instruments, <www.ti.com>
+ * Kshitij Gupta <Kshitij@ti.com>
+ *
+ * Modified for OMAP 1610 H2 board by Nishant Kamat, Jan 2004
+ *
+ * Modified for OMAP 5912 OSK board by Rishi Bhattacharya, Apr 2004
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ * 
+ * Modified for DV-EVM board by Rishi Bhattacharya, Apr 2005
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * Modified for DV-EVM board by Swaminathan S, Nov 2005
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+#if defined(CONFIG_OMAP1610)
+#include <./configs/omap1510.h> 
+#endif
+
+_TEXT_BASE:
+	.word	TEXT_BASE	/* sdram load addr from config.mk */
+
+.global reset_cpu
+reset_cpu:
+	bl reset_processor
+
+
+.globl lowlevel_init
+lowlevel_init:
+	/*mov	pc,	lr*/
+	
+	/*------------------------------------------------------*
+	 * mask all IRQs by setting all bits in the EINT default *
+	 *------------------------------------------------------*/
+	mov	r1, #0x00000000
+	ldr	r0, =EINT_ENABLE0
+	str	r1, [r0]
+	ldr	r0, =EINT_ENABLE1
+	str	r1, [r0]
+
+	/*------------------------------------------------------*
+	 * Put the GEM in reset		    		  *
+ 	 *------------------------------------------------------*/
+
+      /* Put the GEM in reset */
+  	/* bhavinp: commented: No GEM in DM350*/	
+#if 0
+	LDR R8, PSC_GEM_FLAG_CLEAR
+	LDR R6, MDCTL_GEM
+	LDR R7, [R6]
+	AND R7, R7, R8
+	STR R7, [R6]
+
+	/* Enable the Power Domain Transition Command */
+	LDR R6, PTCMD_0
+	LDR R7, [R6]
+	ORR R7, R7, #0x2
+	STR R7, [R6]
+
+	/* Check for Transition Complete(PTSTAT) */
+checkStatClkStopGem:
+	LDR R6, PTSTAT_0
+	LDR R7, [R6]
+    	AND R7, R7, #0x2
+    	CMP R7, #0x0
+    	BNE checkStatClkStopGem
+
+	/* Check for GEM Reset Completion */
+checkGemStatClkStop:
+	LDR R6, MDSTAT_GEM
+	LDR R7, [R6]
+    	AND R7, R7, #0x100
+    	CMP R7, #0x0
+    	BNE checkGemStatClkStop
+
+	/* Do this for enabling a WDT initiated reset this is a workaround
+	   for a chip bug.  Not required under normal situations */
+	LDR R6, P1394
+	MOV R10, #0x0	
+	STR R10, [R6]
+#endif 	//bhavinp: commented: End
+	/*------------------------------------------------------*
+	 * Enable L1 & L2 Memories in Fast mode                 *
+	 *------------------------------------------------------*/
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x1
+	STR R10, [R6]
+
+	LDR R6, MMARG_BRF0
+	LDR R10, MMARG_BRF0_VAL
+	STR R10, [R6]
+
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x0
+	STR R10, [R6]
+	/*------------------------------------------------------*
+	 * DDR2 PLL Intialization			    	*
+ 	 *------------------------------------------------------*/
+	
+      /* Select the Clock Mode Depending on the Value written in the Boot Table by the run script */
+	MOV R10, #0x0
+	LDR R6, PLL2_CTL   
+	LDR R7, PLL_CLKSRC_MASK
+	LDR R8, [R6]
+	AND R8, R8, R7
+	MOV R9, R10, LSL #0x8
+	ORR R8, R8, R9
+	STR R8, [R6]
+	
+	/* Select the PLLEN source */
+	LDR R7, PLL_ENSRC_MASK
+	AND R8, R8, R7
+	STR R8, [R6]
+	
+	/* Bypass the PLL */
+	LDR R7, PLL_BYPASS_MASK
+	AND R8, R8, R7
+	STR R8, [R6]
+	
+	/* Wait for few cycles to allow PLLEN Mux switches properly to bypass Clock */
+	MOV R10, #0x20 
+WaitPPL2Loop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE WaitPPL2Loop	
+
+     /* Reset the PLL */
+    	LDR R7, PLL_RESET_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+     /* Power up the PLL */
+    	LDR R7, PLL_PWRUP_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+     /* Enable the PLL from Disable Mode */
+    	LDR R7, PLL_DISABLE_ENABLE_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+	/* Program the PLL Multiplier */
+	LDR R6, PLL2_PLLM
+	/*MOV R2, #0x13 Orig value */
+	/*MOV R2, #0xB 165MHz */
+	/*MOV R2, #0xD 189 MHz */
+	MOV R2, #0x17 /* 162 MHz */
+	STR R2, [R6]   /* R2 */
+
+	/* Program the PLL2 Divisior Value */
+	LDR R6, PLL2_DIV2
+	MOV R3, #0x1 /* Orig */
+	/*MOV R3, #0x0*/
+	STR R3, [R6]    /* R3 */
+
+	/* Program the PLL2 Divisior Value */
+	LDR R6, PLL2_DIV1
+	/*MOV R4, #0x9 Orig */
+	/*MOV R4, #0x5 165MHz */
+	/*MOV R4, #0x6 189 MHz */
+	MOV R4, #0xB /* 54 MHz */
+	STR R4, [R6]    /* R4 */
+
+      /* PLL2 DIV1 MMR */
+	LDR R8, PLL2_DIV_MASK
+	LDR R6, PLL2_DIV2
+	LDR R9, [R6]
+	AND R8, R8, R9
+	MOV R9, #0X1
+	MOV R9, R9, LSL #15
+	ORR R8, R8, R9
+	STR R8, [R6]
+
+	/* Program the GOSET bit to take new divier values */
+	LDR R6, PLL2_PLLCMD
+	LDR R7, [R6]
+	ORR R7, R7, #0x1
+	STR R7, [R6]
+
+      /* Wait for Done */
+    	LDR R6, PLL2_PLLSTAT
+doneLoop_0:    
+    	LDR R7, [R6]
+    	AND R7, R7, #0x1
+    	CMP R7, #0x0
+    	BNE doneLoop_0
+
+      /* PLL2 DIV2 MMR */
+	LDR R8, PLL2_DIV_MASK
+	LDR R6, PLL2_DIV1
+	LDR R9, [R6]
+	AND R8, R8, R9
+	MOV R9, #0X1
+	MOV R9, R9, LSL #15
+	ORR R8, R8, R9
+	STR R8, [R6]
+
+	/* Program the GOSET bit to take new divier values */
+	LDR R6, PLL2_PLLCMD
+	LDR R7, [R6]
+	ORR R7, R7, #0x1
+	STR R7, [R6]
+
+     /* Wait for Done */
+    	LDR R6, PLL2_PLLSTAT
+doneLoop:    
+    	LDR R7, [R6]
+    	AND R7, R7, #0x1
+    	CMP R7, #0x0
+    	BNE doneLoop
+    				
+	/* Wait for PLL to Reset Properly */
+	MOV R10, #0x218  
+ResetPPL2Loop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE ResetPPL2Loop
+    
+    	/* Bring PLL out of Reset */
+    	LDR R6, PLL2_CTL    	
+    	LDR R8, [R6]
+    	ORR R8, R8, #0x08
+    	STR R8, [R6]
+     	
+     /* Wait for PLL to Lock */
+	LDR R10, PLL_LOCK_COUNT    
+PLL2Lock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE PLL2Lock
+    
+     /* Enable the PLL */
+    	LDR R6, PLL2_CTL    	
+    	LDR R8, [R6]
+    	ORR R8, R8, #0x01
+    	STR R8, [R6]
+
+	/*------------------------------------------------------*
+	 * Issue Soft Reset to DDR Module		    		  *
+ 	 *------------------------------------------------------*/
+
+      /* Shut down the DDR2 LPSC Module */
+  	LDR R8, PSC_FLAG_CLEAR
+	LDR R6, MDCTL_DDR2_0
+	LDR R7, [R6]
+	AND R7, R7, R8
+	ORR R7, R7, #0x3
+	STR R7, [R6]  
+
+	/* Enable the Power Domain Transition Command */
+	LDR R6, PTCMD_0
+	LDR R7, [R6]
+	ORR R7, R7, #0x1
+	STR R7, [R6]    
+	
+	/* Check for Transition Complete(PTSTAT) */
+checkStatClkStop:	
+	LDR R6, PTSTAT_0
+	LDR R7, [R6]
+    	AND R7, R7, #0x1	
+    	CMP R7, #0x0
+    	BNE checkStatClkStop  
+    
+	/* Check for DDR2 Controller Enable Completion */
+checkDDRStatClkStop:	
+	LDR R6, MDSTAT_DDR2_0
+	LDR R7, [R6]
+    	AND R7, R7, #0x1F	
+    	CMP R7, #0x3
+    	BNE checkDDRStatClkStop  
+
+	/*------------------------------------------------------*
+	 * Program DDR2 MMRs for 162MHz Setting	    		  *
+ 	 *------------------------------------------------------*/
+	
+	/* Program PHY Control Register */
+	LDR R6, DDRCTL
+	LDR R7, DDRCTL_VAL
+	STR R7, [R6]
+
+	/* Program SDRAM Bank Config Register */
+	LDR R6, SDCFG
+	LDR R7, SDCFG_VAL
+	STR R7, [R6]
+
+	/* Program SDRAM TIM-0 Config Register */
+	LDR R6, SDTIM0
+	LDR R7, SDTIM0_VAL_162MHz
+	STR R7, [R6]		
+
+	/* Program SDRAM TIM-1 Config Register */
+	LDR R6, SDTIM1
+	LDR R7, SDTIM1_VAL_162MHz
+	STR R7, [R6]		
+
+	/* Program the SDRAM Bang Config Control Register */
+	LDR R10, MASK_VAL
+	LDR R8, SDCFG
+	LDR R9, SDCFG_VAL
+	AND R9, R9, R10
+	STR R9, [R8]
+
+	/* Program SDRAM TIM-1 Config Register */
+	LDR R6, SDREF
+	LDR R7, SDREF_VAL
+	STR R7, [R6]		
+
+        /*------------------------------------------------------*
+         * Issue Soft Reset to DDR Module                                 *
+         *------------------------------------------------------*/
+                                                                                
+        /* Issue a Dummy DDR2 read/write */
+        LDR R8, DDR2_VAL
+        LDR R7, DUMMY_VAL
+        STR R7, [R8]
+        LDR R7, [R8]
+                                                                                
+      /* Shut down the DDR2 LPSC Module */
+        LDR R8, PSC_FLAG_CLEAR
+        LDR R6, MDCTL_DDR2_0
+        LDR R7, [R6]
+        AND R7, R7, R8
+        ORR R7, R7, #0x1
+        STR R7, [R6]
+                                                                                
+        /* Enable the Power Domain Transition Command */
+        LDR R6, PTCMD_0
+        LDR R7, [R6]
+        ORR R7, R7, #0x1
+        STR R7, [R6]
+                                                                                
+        /* Check for Transition Complete(PTSTAT) */
+checkStatClkStop2:
+        LDR R6, PTSTAT_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1
+        CMP R7, #0x0
+        BNE checkStatClkStop2
+                                                                                
+        /* Check for DDR2 Controller Enable Completion */
+checkDDRStatClkStop2:
+        LDR R6, MDSTAT_DDR2_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1F
+        CMP R7, #0x1
+        BNE checkDDRStatClkStop2
+
+        /*------------------------------------------------------*
+         * Turn DDR2 Controller Clocks On                                 *
+         *------------------------------------------------------*/
+                                                                                
+     /* Enable the DDR2 LPSC Module */
+        LDR R6, MDCTL_DDR2_0
+        LDR R7, [R6]
+        ORR R7, R7, #0x3
+        STR R7, [R6]
+                                                                                
+        /* Enable the Power Domain Transition Command */
+        LDR R6, PTCMD_0
+        LDR R7, [R6]
+        ORR R7, R7, #0x1
+        STR R7, [R6]
+                                                                                
+        /* Check for Transition Complete(PTSTAT) */
+checkStatClkEn2:
+        LDR R6, PTSTAT_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1
+        CMP R7, #0x0
+        BNE checkStatClkEn2
+                                                                                
+        /* Check for DDR2 Controller Enable Completion */
+checkDDRStatClkEn2:
+        LDR R6, MDSTAT_DDR2_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1F
+        CMP R7, #0x3
+        BNE checkDDRStatClkEn2
+                                                                                
+        /*  DDR Writes and Reads */
+        LDR R6, CFGTEST
+        MOV R3, #0x1
+        STR R3, [R6]    /* R3 */
+
+	/*------------------------------------------------------*
+	 * System PLL Intialization			    		  *
+ 	 *------------------------------------------------------*/
+
+      /* Select the Clock Mode Depending on the Value written in the Boot Table by the run script */
+	MOV R2, #0x0
+	LDR R6, PLL1_CTL   
+	LDR R7, PLL_CLKSRC_MASK
+	LDR R8, [R6]
+	AND R8, R8, R7
+	MOV R9, R2, LSL #0x8
+	ORR R8, R8, R9
+	STR R8, [R6]
+	
+	/* Select the PLLEN source */
+	LDR R7, PLL_ENSRC_MASK
+	AND R8, R8, R7
+	STR R8, [R6]
+	
+	/* Bypass the PLL */
+	LDR R7, PLL_BYPASS_MASK
+	AND R8, R8, R7
+	STR R8, [R6]
+	
+	/* Wait for few cycles to allow PLLEN Mux switches properly to bypass Clock */
+	MOV R10, #0x20 
+
+WaitLoop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE WaitLoop	
+
+     /* Reset the PLL */
+    	LDR R7, PLL_RESET_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+      /* Disable the PLL */
+    	ORR R8, R8, #0x10    
+    	STR R8, [R6]
+
+      /* Power up the PLL */
+    	LDR R7, PLL_PWRUP_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+      /* Enable the PLL from Disable Mode */
+    	LDR R7, PLL_DISABLE_ENABLE_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+	/* Program the PLL Multiplier */
+	LDR R6, PLL1_PLLM
+	/*MOV R3, #0x10  As per Amit, PLL should be in normal mode i.e X by 16 */
+	/*MOV R3, #0x11  As per Ebby 486 MHz */
+	/*MOV R3, #0x14  For 567MHz */
+	MOV R3, #0x15 /* For 594MHz */
+	STR R3, [R6]      
+
+	/* Wait for PLL to Reset Properly */
+	MOV R10, #0xFF 
+
+ResetLoop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE ResetLoop
+    
+      /* Bring PLL out of Reset */
+    	LDR R6, PLL1_CTL    	
+    	ORR R8, R8, #0x08
+    	STR R8, [R6]
+     	
+      /* Wait for PLL to Lock */
+	LDR R10, PLL_LOCK_COUNT    
+
+PLL1Lock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE PLL1Lock
+    
+      /* Enable the PLL */
+    	ORR R8, R8, #0x01
+    	STR R8, [R6]
+
+	nop
+	nop	
+	nop
+	nop
+
+	/*------------------------------------------------------*
+	 * AEMIF configuration for NOR Flash (double check)     *
+	 *------------------------------------------------------*/
+	LDR R0, _PINMUX0
+	LDR R1, _DEV_SETTING
+	STR R1, [R0]
+
+ 	LDR R0, WAITCFG   
+	LDR R1, WAITCFG_VAL 
+	LDR R2, [R0]
+	ORR R2, R2, R1
+	STR R2, [R0]    
+
+	LDR R0, ACFG3
+	LDR R1, ACFG3_VAL
+	LDR R2, [R0]
+	AND R1, R2, R1
+	STR R1, [R0]
+
+	LDR R0, ACFG4
+	LDR R1, ACFG4_VAL
+	LDR R2, [R0]
+	AND R1, R2, R1
+	STR R1, [R0]
+
+	LDR R0, ACFG5
+	LDR R1, ACFG5_VAL
+	LDR R2, [R0]
+	AND R1, R2, R1
+	STR R1, [R0]     
+
+	/*--------------------------------------*
+	 * VTP manual Calibration               *
+	 *--------------------------------------*/
+	LDR R0, VTPIOCR
+	LDR R1, VTP_MMR0
+	STR R1, [R0]
+
+	LDR R0, VTPIOCR
+	LDR R1, VTP_MMR1
+	STR R1, [R0]
+	
+     /* Wait for 33 VTP CLK cycles.  VRP operates at 27 MHz */
+	LDR R10, VTP_LOCK_COUNT    
+VTPLock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE VTPLock
+
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x1
+	STR R10, [R6]
+
+	LDR R6, DDRVTPR
+	LDR R7, [R6]
+	AND R7, R7, #0x1F
+	AND R8, R7, #0x3E0
+	ORR R8, R7, R8
+	LDR R7, VTP_RECAL
+	ORR R8, R7, R8
+	LDR R7, VTP_EN
+	ORR R8, R7, R8
+	STR R8, [R0]
+
+
+     /* Wait for 33 VTP CLK cycles.  VRP operates at 27 MHz */
+	LDR R10, VTP_LOCK_COUNT    
+VTP1Lock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE VTP1Lock
+
+	LDR R1, [R0]
+	LDR R2, VTP_MASK
+	AND R2, R1, R2
+	STR R2, [R0]
+
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x0
+	STR R10, [R6]
+
+
+	/* Start MPU Timer 1 */
+/*	MOV R10, #0x1AFFFFFF
+
+WaitRam:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE WaitRam
+*/
+
+	/* back to arch calling code */
+	mov	pc,	lr
+
+	/* the literal pools origin */
+	.ltorg
+
+REG_TC_EMIFS_CONFIG:		/* 32 bits */
+	.word 0xfffecc0c
+REG_TC_EMIFS_CS0_CONFIG:	/* 32 bits */
+	.word 0xfffecc10
+REG_TC_EMIFS_CS1_CONFIG:	/* 32 bits */
+	.word 0xfffecc14
+REG_TC_EMIFS_CS2_CONFIG:	/* 32 bits */
+	.word 0xfffecc18
+REG_TC_EMIFS_CS3_CONFIG:	/* 32 bits */
+	.word 0xfffecc1c
+
+_PINMUX0:		.word 0x01C40000		/* Device Configuration Registers */
+_PINMUX1:		.word 0x01C40004		/* Device Configuration Registers */
+
+_DEV_SETTING:		.word 0x00000C1F
+
+AEMIF_BASE_ADDR:	.word 0x01E10000
+WAITCFG:         	.word 0x01E10004
+ACFG2:           	.word 0x01E10010
+ACFG3:           	.word 0x01E10014
+ACFG4:           	.word 0x01E10018
+ACFG5:           	.word 0x01E1001C
+
+WAITCFG_VAL:     	.word 0x0
+ACFG2_VAL:       	.word 0x3FFFFFFD
+ACFG3_VAL:       	.word 0x3FFFFFFD
+ACFG4_VAL:       	.word 0x3FFFFFFD
+ACFG5_VAL:       	.word 0x3FFFFFFD
+
+MDCTL_DDR2:		.word 0x01C41A34
+PTCMD:		.word 0x01C41120
+PTSTAT:		.word 0x01C41128
+MDSTAT_DDR2:	.word 0x01C41834
+
+MDCTL_TPCC:		.word	0x01C41A08
+MDSTAT_TPCC:	.word 0x01C41808
+
+MDCTL_TPTC0:	.word	0x01C41A0C
+MDSTAT_TPTC0:	.word 0x01C4180C
+
+MDCTL_TPTC1:	.word	0x01C41A10
+MDSTAT_TPTC1:	.word 0x01C41810
+
+DDR2DEBUG:		.word 0x8FFFF000
+
+/* EINT0 register */
+EINT_ENABLE0:
+	.word 0x01c48018
+
+/* EINT1 register */
+EINT_ENABLE1:
+	.word 0x01c4801C
+
+CLEAR_FLAG:				.word 0xFFFFFFFF
+EDMA_PARAM0_D_S_BIDX_VAL: 	.word 0x00010001
+PSC_FLAG_CLEAR:			.word 0xFFFFFFE0
+PSC_GEM_FLAG_CLEAR:			.word 0xFFFFFEFF
+MDCTL_TPCC_SYNC:			.word 0x01C41A08
+MDSTAT_TPCC_SYNC:			.word 0x01C41808
+
+MDCTL_TPTC0_SYNC:			.word 0x01C41A0C
+MDSTAT_TPTC0_SYNC:		.word 0x01C4180C
+
+MDCTL_TPTC1_SYNC:			.word 0x01C41A10
+MDSTAT_TPTC1_SYNC:		.word 0x01C41810
+
+PTCMD_SYNC:				.word 0x01C41120
+PTSTAT_SYNC:			.word 0x01C41128
+DATA_MAX:				.word 0x0000FFFF
+SPIN_ADDR:				.word 0x00003FFC   /* ARM PC value(B $) for the DSP Test cases */
+SPIN_OPCODE:			.word 0xEAFFFFFE
+
+/* Interrupt Clear Register */
+FIQ0_CLEAR:				.word 0x01C48000
+FIQ1_CLEAR:				.word 0x01C48004
+IRQ0_CLEAR:				.word 0x01C48008
+IRQ1_CLEAR:				.word 0x01C4800C
+
+/* DDR2 MMR & CONFIGURATION VALUES for 75 MHZ */
+DDRCTL:				.word	0x200000E4
+SDREF:				.word	0x2000000C
+SDCFG:				.word	0x20000008
+SDTIM0:				.word	0x20000010
+SDTIM1:				.word	0x20000014
+SDSTAT:				.word 0x20000004
+VTPIOCR:				.word 0x200000F0  /* VTP IO Control register */
+DDRVTPR:				.word 0x01C42030  /* DDR VPTR MMR */
+DFT_ENABLE:				.word 0x01C4004C
+VTP_MMR0:				.word 0x201F
+VTP_MMR1:				.word 0xA01F
+PCH_MASK:				.word 0x3E0
+VTP_LOCK_COUNT:				.word 0x5b0
+VTP_MASK:				.word 0xFFFFDFFF
+VTP_RECAL:				.word 0x40000
+VTP_EN:					.word 0x02000
+
+
+CFGTEST:				.word	0x80010000
+
+/* original values					
+DDRCTL_VAL:				.word	0x50006405
+SDCFG_VAL:				.word	0x00008832
+MASK_VAL:                    	.word 0x00000FFF
+SDTIM0_VAL_135MHz:		.word	0x30923A91
+SDTIM1_VAL_135MHz:		.word	0x0019c722
+SDREF_VAL:				.word 0x000005c3
+*/
+
+/* 162MHz as per GEL file for DVEVM with Micron DDR2 SDRAM */
+DDRCTL_VAL:                     .word   0x50006405
+SDCFG_VAL:                      .word   0x00178632           /* CL=3 for MT47H64M16BT-5E */
+MASK_VAL:                       .word   0xFFFF7FFF
+SDTIM0_VAL_162MHz:              .word   0x28923211
+SDTIM1_VAL_162MHz:              .word   0x0016c722
+SDREF_VAL:                      .word   0x000004F0
+
+/* GEM Power Up & LPSC Control Register */
+CHP_SHRTSW:				.word 0x01C40038
+
+PD1_CTL:				.word	0x01C41304
+EPCPR:				.word	0x01C41070
+EPCCR:				.word	0x01C41078
+MDCTL_GEM:				.word	0x01C41A9C
+MDSTAT_GEM:				.word 0x01C4189C
+MDCTL_IMCOP:			.word	0x01C41AA0
+MDSTAT_IMCOP:			.word 0x01C418A0
+
+PTCMD_0:				.word 0x01C41120
+PTSTAT_0:				.word 0x01C41128
+P1394:					.word 0x01C41a20
+
+PLL_CLKSRC_MASK: 			.word 0xFFFFFEFF  /* Mask the Clock Mode bit and it is programmble through the run script */
+PLL_ENSRC_MASK:  			.word 0xFFFFFFDF  /* Select the PLLEN source */
+PLL_BYPASS_MASK: 			.word 0xFFFFFFFE  /* Put the PLL in BYPASS, eventhough the device */
+PLL_RESET_MASK:  			.word 0xFFFFFFF7  /* Put the PLL in Reset Mode */
+PLL_PWRUP_MASK:  			.word 0xFFFFFFFD  /* PLL Power up Mask Bit  */
+PLL_DISABLE_ENABLE_MASK:	.word 0xFFFFFFEF  /* Enable the PLL from Disable */
+PLL_LOCK_COUNT:          	.word 0x2000
+
+/* PLL1-SYSTEM PLL MMRs */
+PLL1_CTL:				.word 0x01C40900 
+PLL1_PLLM:				.word 0x01C40910
+
+/* PLL2-SYSTEM PLL MMRs */
+PLL2_CTL:				.word 0x01C40D00 
+PLL2_PLLM:				.word 0x01C40D10
+PLL2_DIV2:				.word 0x01C40D1C
+PLL2_DIV1:				.word 0x01C40D18
+PLL2_PLLCMD:			.word 0x01C40D38
+PLL2_PLLSTAT:			.word 0x01C40D3C	
+PLL2_BPDIV:				.word 0x01C40D2C
+PLL2_DIV_MASK:			.word 0xFFFF7FFF
+
+
+MDCTL_DDR2_0:			.word 0x01C41A34
+MDSTAT_DDR2_0:			.word 0x01C41834
+DLLPWRUPMASK:			.word 0xFFFFFFEF
+DDR2_ADDR:			.word 0x80000000
+
+DFT_BASEADDR:			.word 0x01C42000
+MMARG_BRF0:			.word 0x01C42010     /* BRF margin mode 0     (Read / write)*/
+MMARG_G10:			.word 0x01C42018     /*GL margin mode 0      (Read / write)*/
+MMARG_BRF0_VAL:			.word 0x00444400
+DDR2_VAL:			.word 0x80000000
+DUMMY_VAL:			.word 0xA55AA55A
+
+/* command values */
+.equ CMD_SDRAM_NOP,		0x00000000
+.equ CMD_SDRAM_PRECHARGE,	0x00000001
+.equ CMD_SDRAM_AUTOREFRESH,	0x00000002
+.equ CMD_SDRAM_CKE_SET_HIGH,	0x00000007
diff -Nurd u-boot-1.2.0/board/dm355_leopard/nand.c u-boot-1.2.0-leopard/board/dm355_leopard/nand.c
--- u-boot-1.2.0/board/dm355_leopard/nand.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_leopard/nand.c	2009-03-01 04:24:26.000000000 -0300
@@ -0,0 +1,830 @@
+/*
+ * NAND driver for TI DaVinci based boards.
+ *
+ * Copyright (C) 2007 Sergey Kubushyn <ksi@koi8.net>
+ *
+ * Based on Linux DaVinci NAND driver by TI. Original copyright follows:
+ */
+
+/*
+ *
+ * linux/drivers/mtd/nand/nand_dm355.c
+ *
+ * NAND Flash Driver
+ *
+ * Copyright (C) 2006 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ *
+ *  Overview:
+ *   This is a device driver for the NAND flash device found on the
+ *   DaVinci board which utilizes the Samsung k9k2g08 part.
+ *
+ Modifications:
+ ver. 1.0: Feb 2005, Vinod/Sudhakar
+ -
+ *
+ */
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+#if !defined(CFG_NAND_LEGACY)
+
+#include <asm/arch/types.h>
+//#include "soc.h"
+#include <nand.h>
+#include <asm/arch/nand_defs.h>
+#include <asm/arch/emif_defs.h>
+
+#define NAND_Ecc_P1e            (1 << 0)
+#define NAND_Ecc_P2e            (1 << 1)
+#define NAND_Ecc_P4e            (1 << 2)
+#define NAND_Ecc_P8e            (1 << 3)
+#define NAND_Ecc_P16e           (1 << 4)
+#define NAND_Ecc_P32e           (1 << 5)
+#define NAND_Ecc_P64e           (1 << 6)
+#define NAND_Ecc_P128e          (1 << 7)
+#define NAND_Ecc_P256e          (1 << 8)
+#define NAND_Ecc_P512e          (1 << 9)
+#define NAND_Ecc_P1024e         (1 << 10)
+#define NAND_Ecc_P2048e         (1 << 11)
+
+#define NAND_Ecc_P1o            (1 << 16)
+#define NAND_Ecc_P2o            (1 << 17)
+#define NAND_Ecc_P4o            (1 << 18)
+#define NAND_Ecc_P8o            (1 << 19)
+#define NAND_Ecc_P16o           (1 << 20)
+#define NAND_Ecc_P32o           (1 << 21)
+#define NAND_Ecc_P64o           (1 << 22)
+#define NAND_Ecc_P128o          (1 << 23)
+#define NAND_Ecc_P256o          (1 << 24)
+#define NAND_Ecc_P512o          (1 << 25)
+#define NAND_Ecc_P1024o         (1 << 26)
+#define NAND_Ecc_P2048o         (1 << 27)
+
+#define TF(value)       (value ? 1 : 0)
+
+#define P2048e(a)       (TF(a & NAND_Ecc_P2048e)        << 0 )
+#define P2048o(a)       (TF(a & NAND_Ecc_P2048o)        << 1 )
+#define P1e(a)          (TF(a & NAND_Ecc_P1e)           << 2 )
+#define P1o(a)          (TF(a & NAND_Ecc_P1o)           << 3 )
+#define P2e(a)          (TF(a & NAND_Ecc_P2e)           << 4 )
+#define P2o(a)          (TF(a & NAND_Ecc_P2o)           << 5 )
+#define P4e(a)          (TF(a & NAND_Ecc_P4e)           << 6 )
+#define P4o(a)          (TF(a & NAND_Ecc_P4o)           << 7 )
+
+#define P8e(a)          (TF(a & NAND_Ecc_P8e)           << 0 )
+#define P8o(a)          (TF(a & NAND_Ecc_P8o)           << 1 )
+#define P16e(a)         (TF(a & NAND_Ecc_P16e)          << 2 )
+#define P16o(a)         (TF(a & NAND_Ecc_P16o)          << 3 )
+#define P32e(a)         (TF(a & NAND_Ecc_P32e)          << 4 )
+#define P32o(a)         (TF(a & NAND_Ecc_P32o)          << 5 )
+#define P64e(a)         (TF(a & NAND_Ecc_P64e)          << 6 )
+#define P64o(a)         (TF(a & NAND_Ecc_P64o)          << 7 )
+
+#define P128e(a)        (TF(a & NAND_Ecc_P128e)         << 0 )
+#define P128o(a)        (TF(a & NAND_Ecc_P128o)         << 1 )
+#define P256e(a)        (TF(a & NAND_Ecc_P256e)         << 2 )
+#define P256o(a)        (TF(a & NAND_Ecc_P256o)         << 3 )
+#define P512e(a)        (TF(a & NAND_Ecc_P512e)         << 4 )
+#define P512o(a)        (TF(a & NAND_Ecc_P512o)         << 5 )
+#define P1024e(a)       (TF(a & NAND_Ecc_P1024e)        << 6 )
+#define P1024o(a)       (TF(a & NAND_Ecc_P1024o)        << 7 )
+
+#define P8e_s(a)        (TF(a & NAND_Ecc_P8e)           << 0 )
+#define P8o_s(a)        (TF(a & NAND_Ecc_P8o)           << 1 )
+#define P16e_s(a)       (TF(a & NAND_Ecc_P16e)          << 2 )
+#define P16o_s(a)       (TF(a & NAND_Ecc_P16o)          << 3 )
+#define P1e_s(a)        (TF(a & NAND_Ecc_P1e)           << 4 )
+#define P1o_s(a)        (TF(a & NAND_Ecc_P1o)           << 5 )
+#define P2e_s(a)        (TF(a & NAND_Ecc_P2e)           << 6 )
+#define P2o_s(a)        (TF(a & NAND_Ecc_P2o)           << 7 )
+
+#define P4e_s(a)        (TF(a & NAND_Ecc_P4e)           << 0 )
+#define P4o_s(a)        (TF(a & NAND_Ecc_P4o)           << 1 )
+
+#define CSL_EMIF_1_REGS    0x01E10000
+
+#define NAND4BITECCLOAD		(0x01E10000 +0xBC)
+#define NAND4BITECC1        (0x01E10000 +0xC0)
+#define NAND4BITECC2        (0x01E10000 +0xC4) 
+#define NAND4BITECC3        (0x01E10000 +0xC8)
+#define NAND4BITECC4        (0x01E10000 +0xCC)
+
+#define NANDERRADD1		    (0x01E10000 +0xD0)
+#define NANDERRADD2		    (0x01E10000 +0xD4)
+#define NANDERRVAL1		    (0x01E10000 +0xD8)
+#define NANDERRVAL2		    (0x01E10000 +0xDC)
+
+/* Definitions for 4-bit hardware ECC */
+#define NAND_4BITECC_MASK		0x03FF03FF
+#define EMIF_NANDFSR_ECC_STATE_MASK  	0x00000F00
+#define ECC_STATE_NO_ERR		0x0
+#define ECC_STATE_TOO_MANY_ERRS		0x1
+#define ECC_STATE_ERR_CORR_COMP_P	0x2
+#define ECC_STATE_ERR_CORR_COMP_N	0x3
+#define ECC_MAX_CORRECTABLE_ERRORS	0x4
+extern struct nand_chip nand_dev_desc[CFG_MAX_NAND_DEVICE];
+
+static void nand_dm350evm_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+	struct		nand_chip *this = mtd->priv;
+	u_int32_t	IO_ADDR_W = (u_int32_t)this->IO_ADDR_W;
+	u_int32_t	IO_ADDR_R = (u_int32_t)this->IO_ADDR_R;
+
+	IO_ADDR_W &= ~(MASK_ALE|MASK_CLE);
+
+	switch (cmd) {
+		case NAND_CTL_SETCLE:
+			IO_ADDR_W |= MASK_CLE;
+			break;
+		case NAND_CTL_SETALE:
+			IO_ADDR_W |= MASK_ALE;
+			break;
+	}
+
+	this->IO_ADDR_W = (void *)IO_ADDR_W;
+}
+
+static int nand_dm350evm_dev_ready(struct mtd_info *mtd)
+{
+	emifregs	emif_addr = (emifregs)CSL_EMIF_1_REGS;
+
+	return(emif_addr->NANDFSR) /*& 0x1)*/;
+}
+
+static int nand_dm350evm_waitfunc(struct mtd_info *mtd, struct nand_chip *this, int state)
+{
+	while(!nand_dm350evm_dev_ready(mtd)) {;}
+	*NAND_CE0CLE = NAND_STATUS;
+	return(*NAND_CE0DATA);
+}
+
+static void nand_dm355evm_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+        emifregs    emif_addr;
+
+	    emif_addr = (emifregs)CSL_EMIF_1_REGS;
+        emif_addr->NANDFCR |= (1 << 8);
+}
+
+static u32 nand_dm355evm_readecc(struct mtd_info *mtd, u32  Reg)
+{
+        u32      l = 0;
+        emifregs    emif_addr;
+	    emif_addr = (emifregs)CSL_EMIF_1_REGS;
+
+        if (Reg == 1)
+                l = emif_addr->NANDF1ECC;
+        else if (Reg == 2)
+                l = emif_addr->NANDF2ECC;
+        else if (Reg == 3)
+                l = emif_addr->NANDF3ECC;
+        else if (Reg == 4)
+                l = emif_addr->NANDF4ECC;
+
+        return l;
+}
+
+static int nand_dm355evm_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
+				      u_char *ecc_code)
+{
+        unsigned int      l;
+        int               reg;
+        int               n;
+        struct nand_chip *this = mtd->priv;
+
+        if (this->eccmode == NAND_ECC_HW12_2048)
+                n = 4;
+        else
+                n = 1;
+
+        reg = 1;
+        while (n--) {
+                l = nand_dm355evm_readecc(mtd, reg);
+                *ecc_code++ = l;          // P128e, ..., P1e
+                *ecc_code++ = l >> 16;    // P128o, ..., P1o
+                // P2048o, P1024o, P512o, P256o, P2048e, P1024e, P512e, P256e
+                *ecc_code++ = ((l >> 8) & 0x0f) | ((l >> 20) & 0xf0);
+                reg++;
+        }
+        return 0;
+}
+
+static void nand_dm355evm_gen_true_ecc(u8 *ecc_buf)
+{
+        u32 tmp = ecc_buf[0] | (ecc_buf[1] << 16) | ((ecc_buf[2] & 0xF0) << 20) | ((ecc_buf[2] & 0x0F) << 8);
+
+        ecc_buf[0] = ~(P64o(tmp) | P64e(tmp) | P32o(tmp) | P32e(tmp) | P16o(tmp) | P16e(tmp) | P8o(tmp) | P8e(tmp) );
+        ecc_buf[1] = ~(P1024o(tmp) | P1024e(tmp) | P512o(tmp) | P512e(tmp) | P256o(tmp) | P256e(tmp) | P128o(tmp) | P128e(tmp));
+        ecc_buf[2] = ~( P4o(tmp) | P4e(tmp) | P2o(tmp) | P2e(tmp) | P1o(tmp) | P1e(tmp) | P2048o(tmp) | P2048e(tmp));
+}
+
+static int nand_dm355evm_compare_ecc(u8 *     ecc_data1,   /* read from NAND memory */
+                                    u8 *     ecc_data2,   /* read from register */
+                                    u8 *     page_data)
+{
+        u32    i;
+        u8     tmp0_bit[8], tmp1_bit[8], tmp2_bit[8];
+        u8     comp0_bit[8], comp1_bit[8], comp2_bit[8];
+        u8     ecc_bit[24];
+        u8     ecc_sum = 0;
+        u8     find_bit = 0;
+        u32    find_byte = 0;
+        int    isEccFF;
+
+        isEccFF = ((*(u32 *)ecc_data1 & 0xFFFFFF) == 0xFFFFFF);
+
+        nand_dm355evm_gen_true_ecc(ecc_data1);
+        nand_dm355evm_gen_true_ecc(ecc_data2);
+
+        for (i = 0; i <= 2; i++) {
+                *(ecc_data1 + i) = ~(*(ecc_data1 + i));
+                *(ecc_data2 + i) = ~(*(ecc_data2 + i));
+        }
+
+        for (i = 0; i < 8; i++) {
+                tmp0_bit[i]      = *ecc_data1 % 2;
+                *ecc_data1       = *ecc_data1 / 2;
+        }
+
+        for (i = 0; i < 8; i++) {
+                tmp1_bit[i]      = *(ecc_data1 + 1) % 2;
+                *(ecc_data1 + 1) = *(ecc_data1 + 1) / 2;
+        }
+
+        for (i = 0; i < 8; i++) {
+                tmp2_bit[i]      = *(ecc_data1 + 2) % 2;
+                *(ecc_data1 + 2) = *(ecc_data1 + 2) / 2;
+        }
+
+        for (i = 0; i < 8; i++) {
+                comp0_bit[i]     = *ecc_data2 % 2;
+                *ecc_data2       = *ecc_data2 / 2;
+        }
+
+        for (i = 0; i < 8; i++) {
+                comp1_bit[i]     = *(ecc_data2 + 1) % 2;
+                *(ecc_data2 + 1) = *(ecc_data2 + 1) / 2;
+        }
+
+        for (i = 0; i < 8; i++) {
+                comp2_bit[i]     = *(ecc_data2 + 2) % 2;
+                *(ecc_data2 + 2) = *(ecc_data2 + 2) / 2;
+        }
+
+        for (i = 0; i< 6; i++ )
+                ecc_bit[i] = tmp2_bit[i + 2] ^ comp2_bit[i + 2];
+
+        for (i = 0; i < 8; i++)
+                ecc_bit[i + 6] = tmp0_bit[i] ^ comp0_bit[i];
+
+        for (i = 0; i < 8; i++)
+                ecc_bit[i + 14] = tmp1_bit[i] ^ comp1_bit[i];
+
+        ecc_bit[22] = tmp2_bit[0] ^ comp2_bit[0];
+        ecc_bit[23] = tmp2_bit[1] ^ comp2_bit[1];
+
+        for (i = 0; i < 24; i++)
+                ecc_sum += ecc_bit[i];
+
+        switch (ecc_sum) {
+        case 0:
+                /* Not reached because this function is not called if
+                   ECC values are equal */
+                return 0;
+
+        case 1:
+                /* Uncorrectable error */
+                DEBUG (MTD_DEBUG_LEVEL0, "ECC UNCORRECTED_ERROR 1\n");
+                return -1;
+
+        case 12:
+                /* Correctable error */
+                find_byte = (ecc_bit[23] << 8) +
+                            (ecc_bit[21] << 7) +
+                            (ecc_bit[19] << 6) +
+                            (ecc_bit[17] << 5) +
+                            (ecc_bit[15] << 4) +
+                            (ecc_bit[13] << 3) +
+                            (ecc_bit[11] << 2) +
+                            (ecc_bit[9]  << 1) +
+                            ecc_bit[7];
+
+                find_bit = (ecc_bit[5] << 2) + (ecc_bit[3] << 1) + ecc_bit[1];
+
+                DEBUG (MTD_DEBUG_LEVEL0, "Correcting single bit ECC error at offset: %d, bit: %d\n", find_byte, find_bit);
+
+                page_data[find_byte] ^= (1 << find_bit);
+
+                return 0;
+
+        default:
+                if (isEccFF) {
+                        if (ecc_data2[0] == 0 && ecc_data2[1] == 0 && ecc_data2[2] == 0)
+                                return 0;
+                }
+                DEBUG (MTD_DEBUG_LEVEL0, "UNCORRECTED_ERROR default\n");
+                return -1;
+        }
+}
+
+static int nand_dm355evm_correct_data(struct mtd_info *mtd, u_char *dat,
+				     u_char *read_ecc, u_char *calc_ecc)
+{
+	int r = 0;
+#if 0
+	if (memcmp(read_ecc, calc_ecc, 3) != 0) {
+		u_char read_ecc_copy[3], calc_ecc_copy[3];
+		int i;
+
+		for (i = 0; i < 3; i++) {
+			read_ecc_copy[i] = read_ecc[i];
+			calc_ecc_copy[i] = calc_ecc[i];
+		}
+		r = nand_dm355_1bit_compare_ecc(read_ecc_copy, calc_ecc_copy,
+						  dat);
+	}
+#endif
+	return r;
+}
+
+/*
+ * 4-bit ECC routines
+ */
+
+/*
+ * Instead of placing the spare data at the end of the page, the 4-bit ECC
+ * hardware generator requires that the page be subdivided into 4 subpages,
+ * each with its own spare data area.  This structure defines the format of
+ * each of these subpages.
+ */
+static struct page_layout_item nand_dm355_hw10_512_layout[] = {
+	{.type = ITEM_TYPE_DATA,.length = 512},
+	{.type = ITEM_TYPE_OOB,.length = 6,},
+	{.type = ITEM_TYPE_ECC,.length = 10,},
+	{.type = 0,.length = 0,},
+};
+
+static struct nand_oobinfo nand_dm355_hw10_512_oobinfo = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 10,
+	.eccpos = {6,7,8,9,10,11,12,13,14,15,
+		   },
+	.oobfree ={0, 6},
+};
+
+static uint8_t scan_ff_pattern[] = { 0xff, 0xff };
+/*
+ * We should always have a flash-based bad block table.  However, if one isn't
+ * found then all blocks will be scanned to look for factory-marked bad blocks.
+ * We supply a null pattern so that no blocks will be detected as bad.
+ */
+static struct nand_bbt_descr nand_dm355_hw10_512_badblock_pattern = {
+  .options = 0, //NAND_BBT_SCANEMPTY | NAND_BBT_SCANALLPAGES,
+	.offs = 5,
+	.len = 1,
+	.pattern = scan_ff_pattern
+};
+
+
+/* Generic flash bbt decriptors
+*/
+static uint8_t bbt_pattern[] = {'B', 'b', 't', '0' };
+static uint8_t mirror_pattern[] = {'1', 't', 'b', 'B' };
+
+static struct nand_bbt_descr bbt_main_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs =	0,
+	.len = 4,
+	.veroffs = 5,
+	.maxblocks = 4,
+	.pattern = bbt_pattern
+};
+
+static struct nand_bbt_descr bbt_mirror_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs =	0,
+	.len = 4,
+	.veroffs = 5,
+	.maxblocks = 4,
+	.pattern = mirror_pattern
+};
+
+/*
+ * When using 4-bit ECC with a 2048-byte data + 64-byte spare page size, the
+ * oob is scattered throughout the page in 4 16-byte chunks instead of being
+ * grouped together at the end of the page.  This means that the factory
+ * bad-block markers at offsets 2048 and 2049 will be overwritten when data
+ * is written to the flash.  Thus, we cannot use the factory method to mark
+ * or detect bad blocks and must rely on a flash-based bad block table instead.
+ *
+ */
+static int nand_dm355_hw10_512_block_bad(struct mtd_info *mtd, loff_t ofs,
+					   int getchip)
+{
+	return 0;
+}
+
+static int nand_dm355_hw10_512_block_markbad(struct mtd_info *mtd, loff_t ofs)
+{
+	struct nand_chip *this = mtd->priv;
+	int block;
+
+	/* Get block number */
+	block = ((int)ofs) >> this->bbt_erase_shift;
+	if (this->bbt)
+		this->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
+
+	/* Do we have a flash based bad block table ? */
+	if (this->options & NAND_USE_FLASH_BBT)
+		return nand_update_bbt(mtd, ofs);
+
+	return 0;
+}
+
+static void nand_dm355_4bit_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	struct nand_chip *this = mtd->priv;
+    emifregs    emif_addr = (emifregs)CSL_EMIF_1_REGS;
+	u32 val;
+	
+	switch (mode) {
+	case NAND_ECC_WRITE:
+	case NAND_ECC_READ:
+		/*
+		 * Start a new ECC calculation for reading or writing 512 bytes
+		 *  of data.
+		 */
+		val = (emif_addr->NANDFCR & ~(3 << 4))
+		    | (1 << 12);
+        emif_addr->NANDFCR = val;
+		break;
+	case NAND_ECC_WRITEOOB:
+	case NAND_ECC_READOOB:
+		/*
+		 * Terminate ECC calculation by performing a dummy read of an
+		 * ECC register.  Our hardware ECC generator supports including
+		 * the OOB in the ECC calculation, but the NAND core code
+		 * doesn't really support that.  We will only calculate the ECC
+		 * on the data; errors in the non-ECC bytes in the OOB will not
+		 * be detected or corrected.
+		 */
+        val =(*(dv_reg_p) NAND4BITECC1);
+		break;
+	case NAND_ECC_WRITESYN:
+	case NAND_ECC_READSYN:
+		/*
+		 * Our ECC calculation has already been terminated, so no need
+		 * to do anything here.
+		 */
+		break;
+	default:
+		break;
+	}
+}
+
+static u32 nand_dm355_4bit_readecc(struct mtd_info *mtd, unsigned int *ecc)
+{
+  unsigned int ecc_temp[4];
+    emifregs    emif_addr = (emifregs)CSL_EMIF_1_REGS;
+
+	ecc[0] = (*(dv_reg_p) NAND4BITECC1) & NAND_4BITECC_MASK;
+	ecc[1] = (*(dv_reg_p) NAND4BITECC2) & NAND_4BITECC_MASK;
+	ecc[2] = (*(dv_reg_p) NAND4BITECC3) & NAND_4BITECC_MASK;
+	ecc[3] = (*(dv_reg_p) NAND4BITECC4) & NAND_4BITECC_MASK;
+
+	return 0;
+}
+
+static int nand_dm355_4bit_calculate_ecc(struct mtd_info *mtd,
+					   const u_char * dat,
+					   u_char * ecc_code)
+{
+	unsigned int hw_4ecc[4] = { 0, 0, 0, 0 };
+	unsigned int const1 = 0, const2 = 0;
+	unsigned char count1 = 0;
+	emifregs    emif_addr = (emifregs)CSL_EMIF_1_REGS;
+	u32 val;
+	/*
+	 * Since the NAND_HWECC_SYNDROME option is enabled, this routine is
+	 * only called just after the data and oob have been written.  The
+	 * ECC value calculated by the hardware ECC generator is available
+	 * for us to read.
+	 */
+	nand_dm355_4bit_readecc(mtd, hw_4ecc);
+
+	/*Convert 10 bit ecc value to 8 bit */
+	for (count1 = 0; count1 < 2; count1++) {
+		const2 = count1 * 5;
+		const1 = count1 * 2;
+
+		/* Take first 8 bits from val1 (count1=0) or val5 (count1=1) */
+		ecc_code[const2] = hw_4ecc[const1] & 0xFF;
+
+		/*
+		 * Take 2 bits as LSB bits from val1 (count1=0) or val5
+		 * (count1=1) and 6 bits from val2 (count1=0) or val5 (count1=1)
+		 */
+		ecc_code[const2 + 1] =
+		    ((hw_4ecc[const1] >> 8) & 0x3) | ((hw_4ecc[const1] >> 14) &
+						      0xFC);
+
+		/*
+		 * Take 4 bits from val2 (count1=0) or val5 (count1=1) and
+		 * 4 bits from val3 (count1=0) or val6 (count1=1)
+		 */
+		ecc_code[const2 + 2] =
+		    ((hw_4ecc[const1] >> 22) & 0xF) |
+		    ((hw_4ecc[const1 + 1] << 4) & 0xF0);
+
+		/*
+		 * Take 6 bits from val3(count1=0) or val6 (count1=1) and
+		 * 2 bits from val4 (count1=0) or  val7 (count1=1)
+		 */
+		ecc_code[const2 + 3] =
+		    ((hw_4ecc[const1 + 1] >> 4) & 0x3F) |
+		    ((hw_4ecc[const1 + 1] >> 10) & 0xC0);
+
+		/* Take 8 bits from val4 (count1=0) or val7 (count1=1) */
+		ecc_code[const2 + 4] = (hw_4ecc[const1 + 1] >> 18) & 0xFF;
+	}
+
+	return 0;
+}
+
+static int nand_dm355_4bit_compare_ecc(struct mtd_info *mtd, u8 * read_ecc,	/* read from NAND */
+					 u8 * page_data)
+{
+	struct nand_chip *this = mtd->priv;
+	struct nand_dm355_info *info = this->priv;
+	unsigned short ecc_10bit[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+	int i;
+	unsigned int hw_4ecc[4] = { 0, 0, 0, 0 }, iserror = 0;
+	unsigned short *pspare = NULL, *pspare1 = NULL;
+	unsigned int numErrors, errorAddress, errorValue;
+    emifregs    emif_addr = (emifregs)CSL_EMIF_1_REGS;
+	u32 val;
+	
+	/*
+	 * Check for an ECC where all bytes are 0xFF.  If this is the case, we
+	 * will assume we are looking at an erased page and we should ignore the
+	 * ECC.
+	 */
+	for (i = 0; i < 10; i++) {
+		if (read_ecc[i] != 0xFF)
+			break;
+	}
+	if (i == 10)
+		return 0;
+
+	/* Convert 8 bit in to 10 bit */
+	pspare = (unsigned short *)&read_ecc[2];
+	pspare1 = (unsigned short *)&read_ecc[0];
+	/* Take 10 bits from 0th and 1st bytes */
+	ecc_10bit[0] = (*pspare1) & 0x3FF;	/* 10 */
+	/* Take 6 bits from 1st byte and 4 bits from 2nd byte */
+	ecc_10bit[1] = (((*pspare1) >> 10) & 0x3F)
+	    | (((pspare[0]) << 6) & 0x3C0);	/* 6 + 4 */
+	/* Take 4 bits form 2nd bytes and 6 bits from 3rd bytes */
+	ecc_10bit[2] = ((pspare[0]) >> 4) & 0x3FF;	/* 10 */
+	/*Take 2 bits from 3rd byte and 8 bits from 4th byte */
+	ecc_10bit[3] = (((pspare[0]) >> 14) & 0x3)
+	    | ((((pspare[1])) << 2) & 0x3FC);	/* 2 + 8 */
+	/* Take 8 bits from 5th byte and 2 bits from 6th byte */
+	ecc_10bit[4] = ((pspare[1]) >> 8)
+	    | ((((pspare[2])) << 8) & 0x300);	/* 8 + 2 */
+	/* Take 6 bits from 6th byte and 4 bits from 7th byte */
+	ecc_10bit[5] = (pspare[2] >> 2) & 0x3FF;	/* 10 */
+	/* Take 4 bits from 7th byte and 6 bits from 8th byte */
+	ecc_10bit[6] = (((pspare[2]) >> 12) & 0xF)
+	    | ((((pspare[3])) << 4) & 0x3F0);	/* 4 + 6 */
+	/*Take 2 bits from 8th byte and 8 bits from 9th byte */
+	ecc_10bit[7] = ((pspare[3]) >> 6) & 0x3FF;	/* 10 */
+
+	/*
+	 * Write the parity values in the NAND Flash 4-bit ECC Load register.
+	 * Write each parity value one at a time starting from 4bit_ecc_val8
+	 * to 4bit_ecc_val1.
+	 */
+	for (i = 7; i >= 0; i--)
+    {
+       *(dv_reg_p)NAND4BITECCLOAD = ecc_10bit[i];  
+    }
+
+	/*
+	 * Perform a dummy read to the EMIF Revision Code and Status register.
+	 * This is required to ensure time for syndrome calculation after
+	 * writing the ECC values in previous step.
+	 */
+	val = emif_addr->ERCSR;
+
+	/*
+	 * Read the syndrome from the NAND Flash 4-Bit ECC 1-4 registers.
+	 * A syndrome value of 0 means no bit errors. If the syndrome is
+	 * non-zero then go further otherwise return.
+	 */
+	nand_dm355_4bit_readecc(mtd, hw_4ecc);
+
+	if (hw_4ecc[0] == ECC_STATE_NO_ERR && hw_4ecc[1] == ECC_STATE_NO_ERR &&
+	    hw_4ecc[2] == ECC_STATE_NO_ERR && hw_4ecc[3] == ECC_STATE_NO_ERR){
+          return 0;
+      }
+
+
+	/*
+	 * Clear any previous address calculation by doing a dummy read of an
+	 * error address register.
+	 */
+	val = *(dv_reg_p)NANDERRADD1;
+
+	/*
+	 * Set the addr_calc_st bit(bit no 13) in the NAND Flash Control
+	 * register to 1.
+	 */
+    
+    emif_addr->NANDFCR |= (1 << 13);
+
+	/*
+	 * Wait for the corr_state field (bits 8 to 11)in the
+	 * NAND Flash Status register to be equal to 0x0, 0x1, 0x2, or 0x3.
+	 */
+    do {
+        iserror = emif_addr->NANDFSR & 0xC00;
+    } while (iserror);       
+
+	iserror = emif_addr->NANDFSR;
+	iserror &= EMIF_NANDFSR_ECC_STATE_MASK;
+	iserror = iserror >> 8;
+
+#if 0
+	do {
+		iserror = emif_addr->NANDFSR;
+		iserror &= EMIF_NANDFSR_ECC_STATE_MASK;
+		iserror = iserror >> 8;
+	} while ((ECC_STATE_NO_ERR != iserror) &&
+		 (ECC_STATE_TOO_MANY_ERRS != iserror) &&
+		 (ECC_STATE_ERR_CORR_COMP_P != iserror) &&
+		 (ECC_STATE_ERR_CORR_COMP_N != iserror));
+#endif
+	/*
+	 * ECC_STATE_TOO_MANY_ERRS (0x1) means errors cannot be
+	 * corrected (five or more errors).  The number of errors
+	 * calculated (err_num field) differs from the number of errors
+	 * searched.  ECC_STATE_ERR_CORR_COMP_P (0x2) means error
+	 * correction complete (errors on bit 8 or 9).
+	 * ECC_STATE_ERR_CORR_COMP_N (0x3) means error correction
+	 * complete (error exists).
+	 */
+
+	if (iserror == ECC_STATE_NO_ERR)
+		return 0;
+	else if (iserror == ECC_STATE_TOO_MANY_ERRS)
+    {
+        printf("too many erros to be corrected!\n");
+		return -1;
+    }
+
+#if 1
+	numErrors = ((emif_addr->NANDFSR >> 16) & 0x3) + 1;
+//  printf("numErrors =%d\n",numErrors);
+  if(numErrors==4)
+    return numErrors;
+	/* Read the error address, error value and correct */
+	for (i = 0; i < numErrors; i++) {
+		if (i > 1) {
+			errorAddress =
+			    ((*(dv_reg_p)(NANDERRADD2) >>
+			      (16 * (i & 1))) & 0x3FF);
+			errorAddress = ((512 + 7) - errorAddress);
+			errorValue =
+			    ((*(dv_reg_p)(NANDERRVAL2) >>
+			      (16 * (i & 1))) & 0xFF);
+		} else {
+			errorAddress =
+			    ((*(dv_reg_p)(NANDERRADD1) >>
+			      (16 * (i & 1))) & 0x3FF);
+			errorAddress = ((512 + 7) - errorAddress);
+			errorValue =
+			    ((*(dv_reg_p)(NANDERRVAL1) >>
+			      (16 * (i & 1))) & 0xFF);
+		}
+		/* xor the corrupt data with error value */
+		if (errorAddress < 512)
+			page_data[errorAddress] ^= errorValue;
+	}
+#else
+	numErrors = ((emif_addr->NANDFSR >> 16) & 0x3);
+        // bit 9:0
+        errorAddress = 519 - (*(dv_reg_p)NANDERRADD1 & (0x3FF));
+        errorValue   = (*(dv_reg_p)NANDERRVAL1) & (0x3FF);
+        page_data[errorAddress] ^= (char)errorValue;
+
+        if(numErrors == 0)
+            return numErrors;
+        else {
+            // bit 25:16
+            errorAddress = 519 - ( (*(dv_reg_p)NANDERRADD1 & (0x3FF0000))>>16 );
+            errorValue   = (*(dv_reg_p)NANDERRVAL1) & (0x3FF);
+            page_data[errorAddress] ^= (char)errorValue;
+
+            if(numErrors == 1)
+                return numErrors;
+            else {
+                // bit 9:0
+                errorAddress = 519 - (*(dv_reg_p)NANDERRADD2 & (0x3FF));
+                errorValue = (*(dv_reg_p)NANDERRVAL2) & (0x3FF);
+                page_data[errorAddress] ^= (char)errorValue;
+
+                if (numErrors == 2)
+                    return numErrors;
+                else {
+                    // bit 25:16
+                    errorAddress = 519 - ( (*(dv_reg_p)NANDERRADD2 & (0x3FF0000))>>16 );
+                    errorValue = (*(dv_reg_p)NANDERRVAL2) & (0x3FF);
+                    page_data[errorAddress] ^= (char)errorValue;
+                }
+            }
+        }
+#endif
+
+	return numErrors;
+}
+
+static int nand_dm355_4bit_correct_data(struct mtd_info *mtd, u_char * dat,
+					  u_char * read_ecc, u_char * calc_ecc)
+{
+	int r = 0;
+
+	/*
+	 * dat points to 512 bytes of data.  read_ecc points to the start of the
+	 * oob area for this subpage, so the ecc values start at offset 6.
+	 * The calc_ecc pointer is not needed since our caclulated ECC is
+	 * already latched in the hardware ECC generator.
+	 */
+#if 1
+	r = nand_dm355_4bit_compare_ecc(mtd, read_ecc + 6, dat);
+#endif
+
+	return r;
+}
+int board_nand_init(struct nand_chip *nand)
+{
+#if 0
+	nand->IO_ADDR_R   = (void  __iomem *)NAND_CE0DATA;
+	nand->IO_ADDR_W   = (void  __iomem *)NAND_CE0DATA;
+#endif
+	nand->chip_delay  = 0;
+	nand->options     = NAND_USE_FLASH_BBT /*| NAND_BBT_LASTBLOCK*/;
+//	nand->eccmode     = NAND_ECC_SOFT;
+#if 0 
+	nand->eccmode     = NAND_ECC_HW3_512;
+	nand->calculate_ecc =  nand_dm355evm_calculate_ecc;
+	nand->correct_data	 = nand_dm355evm_correct_data;
+	nand->enable_hwecc	 = nand_dm355evm_enable_hwecc;
+#else
+	nand->eccmode     = NAND_ECC_HW10_512;
+	nand->options     = NAND_USE_FLASH_BBT | NAND_HWECC_SYNDROME;
+    nand->autooob = &nand_dm355_hw10_512_oobinfo;
+	nand->layout = nand_dm355_hw10_512_layout;
+	nand->calculate_ecc = nand_dm355_4bit_calculate_ecc;
+	nand->correct_data = nand_dm355_4bit_correct_data;
+	nand->enable_hwecc = nand_dm355_4bit_enable_hwecc;
+	//nand->block_bad = nand_dm355_hw10_512_block_bad;
+	nand->block_markbad = nand_dm355_hw10_512_block_markbad;
+	nand->badblock_pattern =  &nand_dm355_hw10_512_badblock_pattern;
+	nand->bbt_td =&bbt_main_descr;
+	nand->bbt_md = &bbt_mirror_descr;
+    
+#endif
+	/* Set address of hardware control function */
+	nand->hwcontrol = nand_dm350evm_hwcontrol;
+
+	//nand->dev_ready = nand_dm350evm_dev_ready;
+	//nand->waitfunc = nand_dm350evm_waitfunc;
+
+	return 0;
+}
+
+#else
+#error "U-Boot legacy NAND support not available for DaVinci chips"
+#endif
+#endif	/* CFG_USE_NAND */
diff -Nurd u-boot-1.2.0/board/dm355_leopard/timer.c u-boot-1.2.0-leopard/board/dm355_leopard/timer.c
--- u-boot-1.2.0/board/dm355_leopard/timer.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_leopard/timer.c	2009-03-01 04:24:26.000000000 -0300
@@ -0,0 +1,72 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ Modifications:
+ ver. 1.0: Oct 2005, Swaminathan S
+ *
+ */
+
+#include "timer.h"
+
+/* Use Timer 3&4 (Timer 2) */
+#define TIMER_BASE_ADDR	0x01C21400
+
+dm350_timer_reg    *dm350_timer = (dm350_timer_reg *) TIMER_BASE_ADDR;
+
+/* Timer Initialize */
+void inittimer(void)
+{
+        /* disable Timer 1 & 2 timers */
+        dm350_timer->tcr = 0;
+
+        /* Set timers to unchained dual 32 bit timers, Unreset timer34 */
+        dm350_timer->tgcr = 0x0;
+        dm350_timer->tgcr = 0x6;
+
+        /* Program the timer12 counter register - set the prd12 for right count */
+        dm350_timer->tim34 = 0;
+
+        /* The timer is programmed to expire after 0xFFFFFFFF ticks */
+        dm350_timer->prd34 = 0xFFFFFFFF;
+
+        /* Enable timer34 */
+        dm350_timer->tcr = (0x80 << 16); /* Timer34 continously enabled, Timer12 disabled */
+}
+
+/************************************************************
+********************** Reset Processor **********************
+************************************************************/
+#define WDT_BASE_ADDR          0x01C21C00
+
+
+void reset_processor(void)
+{
+        dm350_timer_reg *dm350_wdt = (dm350_timer_reg *) WDT_BASE_ADDR;
+        dm350_wdt->tgcr   = 0x00000008;
+        dm350_wdt->tgcr  |= 0x00000003;
+        dm350_wdt->tim12  = 0x00000000;
+        dm350_wdt->tim34  = 0x00000000;
+        dm350_wdt->prd12  = 0x00000000;
+        dm350_wdt->prd34  = 0x00000000;
+        dm350_wdt->tcr   |= 0x00000040;
+        dm350_wdt->wdtcr |= 0x00004000;
+        dm350_wdt->wdtcr  = 0xA5C64000;
+        dm350_wdt->wdtcr  = 0xDA7E4000;
+}
diff -Nurd u-boot-1.2.0/board/dm355_leopard/timer.h u-boot-1.2.0-leopard/board/dm355_leopard/timer.h
--- u-boot-1.2.0/board/dm355_leopard/timer.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_leopard/timer.h	2009-03-01 04:24:26.000000000 -0300
@@ -0,0 +1,51 @@
+/*
+ *
+ *  Copyright (C) 2004 Texas Instruments.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ * Modifications:
+ * ver. 1.0: Oct 2005, Swaminathan S
+ *
+ */
+#ifndef __TIMER_H__
+#define __TIMER_H__
+
+typedef volatile struct dm350_timer_reg_t
+{
+    unsigned int pid12;         /* 0x0 */
+    unsigned int emumgt_clksped;/* 0x4 */
+    unsigned int gpint_en;      /* 0x8 */
+    unsigned int gpdir_dat;     /* 0xC */
+    unsigned int tim12;         /* 0x10 */
+    unsigned int tim34;         /* 0x14 */
+    unsigned int prd12;         /* 0x18 */
+    unsigned int prd34;         /* 0x1C */
+    unsigned int tcr;           /* 0x20 */
+    unsigned int tgcr;          /* 0x24 */
+    unsigned int wdtcr;         /* 0x28 */
+    unsigned int tlgc;          /* 0x2C */
+    unsigned int tlmr;          /* 0x30 */
+} dm350_timer_reg;
+
+#endif  /* __TIMER_H__ */
+
diff -Nurd u-boot-1.2.0/board/dm355_leopard/types.h u-boot-1.2.0-leopard/board/dm355_leopard/types.h
--- u-boot-1.2.0/board/dm355_leopard/types.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_leopard/types.h	2009-03-01 04:24:26.000000000 -0300
@@ -0,0 +1,46 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ *
+ */
+#ifndef _TYPESH_
+#define _TYPESH_
+
+typedef unsigned long 	ULONG;
+typedef unsigned short 	USHORT;
+typedef unsigned long   BOOL;
+typedef unsigned int	WORD;
+typedef char            CHAR;
+typedef unsigned char   BYTE, *LPBYTE, UCHAR, *PUCHAR, PBYTE;
+
+#define FALSE           0
+#define TRUE            1
+
+#define NULL			0
+
+typedef unsigned short int Hwd;
+typedef volatile unsigned short int vHwd;
+typedef unsigned short int *  Hwdptr;
+typedef volatile unsigned short int * vHwdptr;
+//typedef volatile unsigned int * vHwdptr;
+
+
+#endif
+
diff -Nurd u-boot-1.2.0/board/dm355_leopard/u-boot.lds u-boot-1.2.0-leopard/board/dm355_leopard/u-boot.lds
--- u-boot-1.2.0/board/dm355_leopard/u-boot.lds	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm355_leopard/u-boot.lds	2009-03-01 04:24:26.000000000 -0300
@@ -0,0 +1,52 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+	. = ALIGN(4);
+	.text	:
+	{
+	  cpu/arm926ejs/start.o	(.text)
+	  *(.text)
+	}
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+	. = ALIGN(4);
+	.data : { *(.data) }
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -Nurd u-boot-1.2.0/board/dm700/Makefile u-boot-1.2.0-leopard/board/dm700/Makefile
--- u-boot-1.2.0/board/dm700/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm700/Makefile	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= davinci_hd.o flash.o nand.o timer.o dm646x_emac.o
+SOBJS	:= lowlevel_init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $^
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff -Nurd u-boot-1.2.0/board/dm700/config.mk u-boot-1.2.0-leopard/board/dm700/config.mk
--- u-boot-1.2.0/board/dm700/config.mk	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm700/config.mk	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,26 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+# David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+#
+# (C) Copyright 2003
+# Texas Instruments, <www.ti.com>
+#
+# Davinci_HD EVM board (ARM925EJS) cpu
+# see http://www.ti.com/ for more information on Texas Instruments
+#
+# Davinci_HD EVM base board provides 1 bank of 64M x 32 bit words (256 MB)
+# DDR2 SDRAM (Has support up to 512 MB)
+# Physical Address:
+# 0x8000'0000 to 0x9000'0000
+#
+# Linux-Kernel is expected to be at 0x8000'8000, entry 0x8000'8000
+# (mem base + reserved)
+#
+# we load ourself to 0x8100'0000
+#
+#
+# Provide atleast 16MB spacing between us and the Linux Kernel image
+
+TEXT_BASE = 0x81080000
+BOARD_LIBS = drivers/nand/libnand.a
diff -Nurd u-boot-1.2.0/board/dm700/davinci_hd.c u-boot-1.2.0-leopard/board/dm700/davinci_hd.c
--- u-boot-1.2.0/board/dm700/davinci_hd.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm700/davinci_hd.c	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,203 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ Modifications:
+ ver. 1.0: Mar 2007, Suresh Rajashekara (Based on the file davinci.c by
+ *                                       Swaminathan S)
+ *
+ */
+
+#include <common.h>
+#include <i2c.h>
+
+#define PLL0_PLLM   *(volatile unsigned int *)0x01C40910
+#define PLL1_PLLM   *(volatile unsigned int *)0x01C40D10
+#define PLL1_DIV1   *(volatile unsigned char *)0x01C40D18
+
+void davinci_hd_psc_enable(void);
+
+/*******************************************
+ Routine: delay
+ Description:  Delay function
+*******************************************/
+static inline void delay (unsigned long loops)
+{
+    __asm__ volatile ("1:\n"
+		      "subs %0, %1, #1\n"
+		      "bne 1b":"=r" (loops):"0" (loops));
+}
+
+/*******************************************
+ Routine: board_init
+ Description:  Board Initialization routine
+*******************************************/
+int board_init (void)
+{
+    DECLARE_GLOBAL_DATA_PTR;
+
+	/* Arch Number. __Need to register__ */
+    gd->bd->bi_arch_number = 1500;
+	/* 1500 is a random number chosen at the time of development. We have
+	   not yet registered ourselves with the ARM development community. Once
+	   thats done, please change the number to the one supplied by the ARM
+	   development community and replace it with a macro.*/
+
+      	/* Adress of boot parameters */
+    gd->bd->bi_boot_params = LINUX_BOOT_PARAM_ADDR;
+
+	/* Configure MUX settings ? */
+
+	/* Power on required peripherals */
+    davinci_hd_psc_enable();
+
+    inittimer ();
+
+    return 0;
+}
+
+#define PTCMD               *( volatile unsigned int* )( 0x01C41120 )
+#define PTSTAT              *( volatile unsigned int* )( 0x01C41128 )
+#define PDSTAT              *( volatile unsigned int* )( 0x01C41200 )
+#define PDCTL               *( volatile unsigned int* )( 0x01C41300 )
+
+/* PSC Registers */
+#define PSC_ADDR            0x01C41000
+
+#define PTCMD               ( PSC_ADDR + 0x120 ) /* Power domain transition
+						  * commmand register */
+#define PTSTAT              ( PSC_ADDR + 0x128 ) /* Power domain transition status
+						  * register */
+
+/**************************************
+ Routine: davinci_hd_psc_enable
+ Description:  Enable PSC domains
+**************************************/
+void davinci_hd_psc_enable ( void )
+{
+    unsigned int alwaysOnPdNum = 0, dspPdNum = 1, i;
+    int waiting;
+    unsigned int state;
+
+	/* Note this function assumes that the Power Domains are already on */
+
+    *(volatile unsigned int*) (PSC_ADDR+0xA00+4*14) = *(unsigned int*) (PSC_ADDR+0xA00+4*14) | 0x003; /* EMAC */
+    *(volatile unsigned int*) (PSC_ADDR+0xA00+4*20) = *(unsigned int*) (PSC_ADDR+0xA00+4*20) | 0x003; /* DDR2 */
+    *(volatile unsigned int*) (PSC_ADDR+0xA00+4*21) = *(unsigned int*) (PSC_ADDR+0xA00+4*21) | 0x003; /* EMIFA */
+    *(volatile unsigned int*) (PSC_ADDR+0xA00+4*26) = *(unsigned int*) (PSC_ADDR+0xA00+4*26) | 0x003; /* UART0 */
+    *(volatile unsigned int*) (PSC_ADDR+0xA00+4*31) = *(unsigned int*) (PSC_ADDR+0xA00+4*31) | 0x003; /* I2C */
+    *(volatile unsigned int*) (PSC_ADDR+0xA00+4*35) = *(unsigned int*) (PSC_ADDR+0xA00+4*34) | 0x003; /* TIMER0 */
+    *(volatile unsigned int*) (PSC_ADDR+0xA00+4*35) = *(unsigned int*) (PSC_ADDR+0xA00+4*35) | 0x003; /* TIMER1 */
+
+	/* Set PTCMD.GO to 0x1 to initiate the state transtion for Modules in
+	 * the ALWAYSON Power Domain */
+    *(volatile unsigned int*) PTCMD = (1<<alwaysOnPdNum);
+
+	/* Wait for PTSTAT.GOSTAT0 to clear to 0x0 */
+    while(! (((*(volatile unsigned int*) PTSTAT >> alwaysOnPdNum) & 0x00000001) == 0));
+
+	/* Enable GIO3.3V cells used for EMAC (???) */
+#define VDD3P3V_PWDN        0x01c40048
+    *(volatile unsigned int*) VDD3P3V_PWDN = 0;
+
+#define PINMUX0     0x01C40000
+#define PINMUX1     0x01C40004
+
+	/* Select UART function on UART0 */
+    *(volatile unsigned int *)PINMUX0 &= ~(0x0000003f << 18);
+    *(volatile unsigned int *)PINMUX1 &= ~(0x00000003);
+
+	/* Enable AEMIF pins */
+    *(volatile unsigned int*) PINMUX0 &= ~(0x00000007);
+}
+
+/******************************
+ Routine: misc_init_r
+ Description:  Misc. init
+******************************/
+int misc_init_r (void)
+{
+    char temp[20];
+    char rtcdata[10] = { 2, 1, 0, 0, 0, 0, 0, 0, 0, 0};
+    char emac_read_addr [10] = { 0x7f, 0 }, i= 0;
+    int clk = 0;
+
+    clk = ((PLL1_PLLM + 1) * 27) / (PLL1_DIV1 + 1);
+
+    printf ("ARM Clock :- %dMHz\n", ((((PLL0_PLLM + 1) * 27 ) / 2)) );
+    printf ("DDR Clock :- %dMHz\n", (clk/2));
+
+    i2c_write (0x50, 0x00, 1, emac_read_addr, 2); /* ?? */
+    i2c_read (0x50, 0x00, 1, emac_read_addr, 6);
+    temp[0] = (emac_read_addr[0] & 0xF0) >> 4;
+    temp[1] = (emac_read_addr[0] & 0x0F);
+    temp[2] = ':';
+    temp[3] = (emac_read_addr[1] & 0xF0) >> 4;
+    temp[4] = (emac_read_addr[1] & 0x0F);
+    temp[5] = ':';
+    temp[6] = (emac_read_addr[2] & 0xF0) >> 4;
+    temp[7] = (emac_read_addr[2] & 0x0F);
+    temp[8] = ':';
+    temp[9] = (emac_read_addr[3] & 0xF0) >> 4;
+    temp[10]= (emac_read_addr[3] & 0x0F);
+    temp[11]= ':';
+    temp[12]= (emac_read_addr[4] & 0xF0) >> 4;
+    temp[13]= (emac_read_addr[4] & 0x0F);
+    temp[14]= ':';
+    temp[15]= (emac_read_addr[5] & 0xF0) >> 4;
+    temp[16]= (emac_read_addr[5] & 0x0F);
+                                                                               
+    for (i = 0; i < 17; i++)
+    {
+        if (temp[i] == ':')
+	    continue;
+        else if (temp[i] >= 0 && temp[i] <= 9)
+	    temp[i] = temp[i] + 48;
+        else
+	    temp[i] = temp[i] + 87;
+    }
+                   
+    temp [17] = 0;                                                            
+    if ((emac_read_addr [0] != 0xFF) ||
+	(emac_read_addr [1] != 0xFF) ||	
+	(emac_read_addr [2] != 0xFF) ||	
+	(emac_read_addr [3] != 0xFF) ||	
+	(emac_read_addr [4] != 0xFF) ||	
+	(emac_read_addr [5] != 0xFF))
+    { 
+	setenv ("ethaddr", temp);
+    }
+
+    return (0);
+}
+
+/******************************
+ Routine: dram_init
+ Description:  Memory Info
+******************************/
+int dram_init (void)
+{
+    DECLARE_GLOBAL_DATA_PTR;
+
+    gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+    gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+    return 0;
+}
+
diff -Nurd u-boot-1.2.0/board/dm700/dm646x_emac.c u-boot-1.2.0-leopard/board/dm700/dm646x_emac.c
--- u-boot-1.2.0/board/dm700/dm646x_emac.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm700/dm646x_emac.c	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,506 @@
+/*
+ * dm644x_emac.c
+ *
+ * TI DaVinci (DM644X) EMAC peripheral driver source for DV-EVM
+ *
+ * Copyright (C) 2005 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ 
+ * Modifications:
+ * ver. 1.0: Sep 2005, Anant Gole - Created EMAC version for uBoot.
+ * ver  1.1: Nov 2005, Anant Gole - Extended the RX logic for multiple descriptors
+ *
+ */
+ 
+#include <common.h>
+#include <command.h>
+#include <net.h>
+#include "dm646x_emac.h"
+
+#ifdef CONFIG_DRIVER_TI_EMAC
+
+#if (CONFIG_COMMANDS & CFG_CMD_NET)
+
+unsigned int emac_dbg = 0;
+#define debug_emac(fmt,args...)	if (emac_dbg) printf (fmt ,##args)
+
+/* EMAC internal functions - called when eth_xxx functions are invoked by the kernel */
+static int emac_hw_init (void);
+static int emac_open (void);
+static int emac_close (void);
+static int emac_send_packet (volatile void *packet, int length);
+static int emac_rcv_packet (void);
+
+/* The driver can be entered at any of the following entry points */
+extern int eth_init (bd_t * bd);
+extern void eth_halt (void);
+extern int eth_rx (void);
+extern int eth_send (volatile void *packet, int length);
+
+int eth_hw_init (void)
+{
+    return emac_hw_init();
+}
+
+int eth_init (bd_t * bd)
+{
+    return emac_open ();
+}
+
+void eth_halt ()
+{
+    emac_close ();
+}
+
+int eth_send (volatile void *packet, int length)
+{
+    return emac_send_packet (packet, length);
+}
+
+int eth_rx ()
+{
+    return emac_rcv_packet ();
+}
+
+
+static char emac_mac_addr[] = { 0x00, 0x00, 0x5b, 0xee, 0xde, 0xad };
+
+/*
+ * This function must be called before emac_open() if you want to override
+ * the default mac address.
+ */
+
+void emac_set_mac_addr (const char *addr)
+{
+    int i;
+
+    for (i = 0; i < sizeof (emac_mac_addr); i++) {
+        emac_mac_addr[i] = addr[i];
+    }
+}
+
+/***************************
+ * EMAC Global variables
+ ***************************/ 
+ 
+/* EMAC Addresses */
+static volatile emac_regs* adap_emac = (emac_regs *) EMAC_BASE_ADDR;
+static volatile ewrap_regs* adap_ewrap = (ewrap_regs *) EMAC_WRAPPER_BASE_ADDR;
+static volatile mdio_regs* adap_mdio = (mdio_regs *) EMAC_MDIO_BASE_ADDR;
+
+/* EMAC descriptors */
+static volatile emac_desc *emac_rx_desc = (emac_desc *) (EMAC_WRAPPER_RAM_ADDR + EMAC_RX_DESC_BASE);
+static volatile emac_desc *emac_tx_desc = (emac_desc *) (EMAC_WRAPPER_RAM_ADDR + EMAC_TX_DESC_BASE);
+static volatile emac_desc *emac_rx_active_head = 0;
+static volatile emac_desc *emac_rx_active_tail = 0;
+static int emac_rx_queue_active = 0;
+
+/* EMAC link status */
+static int emac_link_status = 0; /* 0 = link down, 1 = link up */
+
+/* Receive packet buffers */
+static unsigned char emac_rx_buffers[EMAC_MAX_RX_BUFFERS * (EMAC_MAX_ETHERNET_PKT_SIZE + EMAC_PKT_ALIGN)];
+
+/* This function initializes the emac hardware */
+static int emac_hw_init (void)
+{
+    /* Enabling power and reset from outside the module is required */
+    return (0);
+}
+
+/* Read a PHY register via MDIO inteface */
+static int mdio_read(int phy_addr, int reg_num)
+{
+    adap_mdio->USERACCESS0 = MDIO_USERACCESS0_GO | MDIO_USERACCESS0_WRITE_READ | 
+                             ((reg_num & 0x1F) << 21) | 
+                             ((phy_addr & 0x1F) << 16);
+
+    /* Wait for command to complete */ 
+    while ((adap_mdio->USERACCESS0 & MDIO_USERACCESS0_GO) != 0);    
+
+    return (adap_mdio->USERACCESS0 & 0xFFFF);
+}
+
+/* Write to a PHY register via MDIO inteface */
+void mdio_write(int phy_addr, int reg_num, unsigned int data)
+{
+    /* Wait for User access register to be ready */
+    while ((adap_mdio->USERACCESS0 & MDIO_USERACCESS0_GO) != 0);    
+    
+    adap_mdio->USERACCESS0 = MDIO_USERACCESS0_GO | MDIO_USERACCESS0_WRITE_WRITE | 
+                             ((reg_num & 0x1F) << 21) | 
+                             ((phy_addr & 0x1F) << 16) |
+                             (data & 0xFFFF);
+}
+
+
+/* Get PHY link state - this function accepts a PHY mask for the caller to
+ * find out if any of the passed PHY addresses is connected
+ */
+int mdio_get_link_state(unsigned int phy_mask)
+{
+    unsigned int act_phy, phy_addr = 0, link_state = 0;
+    unsigned int config;
+
+    act_phy =  (adap_mdio->ALIVE & phy_mask);
+    
+    if (act_phy) 
+    {            
+        /* find the phy number */
+        while(act_phy) 
+        {
+            while(!(act_phy & 0x1)) 
+            {
+                phy_addr++; 
+                act_phy >>= 1;
+            }
+            /* Read the status register from PHY */
+            link_state = ((mdio_read(phy_addr, MII_STATUS_REG) & 0x4) >> 2);
+            if(link_state == 1) 
+            { 
+                /* The link can break off anytime, hence adding the fix for boosting the PHY signal
+                 * strength here so that everytime the link is found, this can be done and ensured
+                 * that we dont miss it
+                 */
+                 config = mdio_read(phy_addr, MII_DIGITAL_CONFIG_REG);
+                 config |= 0x800;
+                 mdio_write(phy_addr, MII_DIGITAL_CONFIG_REG, config);
+                 /* Read back to verify */
+                 config = mdio_read(phy_addr, MII_DIGITAL_CONFIG_REG);
+                 
+                break;
+            } 
+            else 
+            {
+                /* If no link, go to next phy. */                    
+                act_phy >>= 1;
+                phy_addr++;  
+            }
+        }
+    }
+    return link_state;    
+}
+
+/*
+ * The kernel calls this function when someone wants to use the device,
+ * typically 'ifconfig ethX up'.
+ */
+static int emac_open (void)
+{
+    volatile unsigned int *addr;
+    unsigned int clkdiv, cnt;
+    volatile emac_desc *rx_desc;
+    
+    debug_emac("+ emac_open\n");
+            
+    /* Reset EMAC module and disable interrupts in wrapper */
+    adap_emac->SOFTRESET = 1;
+    while (adap_emac->SOFTRESET != 0);
+    /* after soft reset of wrapper blocks, all Interrupt enables are off
+     * off by default */
+    adap_ewrap->SOFTRST = 1;
+    while (adap_ewrap->SOFTRST != 0);
+	
+    #if 0
+    /* check why this is required */
+    for (cnt=0; cnt < 5; cnt++) {
+        clkdiv = adap_ewrap->INTCTRL;
+    }
+    #endif
+    
+    rx_desc = emac_rx_desc;
+
+    adap_emac->TXCONTROL = 0x1;
+    adap_emac->RXCONTROL = 0x1;
+        
+    /* Init multicast Hash to 0 (disable any multicast receive) */
+    adap_emac->MACHASH1 = 0;
+    adap_emac->MACHASH2 = 0;
+    
+    /* Set MAC Address ,Using channel 0 only - other channels are disabled */
+    adap_emac->MACINDEX = 0;
+    adap_emac->MACADDRHI = (emac_mac_addr[3] << 24) | (emac_mac_addr[2] << 16) |
+                            (emac_mac_addr[1] << 8)  | (emac_mac_addr[0]);
+    /* wew are using CFIG3, set control bits before writing MACADDR_LO */		   
+    adap_emac->MACADDRLO = ((emac_mac_addr[5] << 8) | emac_mac_addr[4] | (0<<16)|(1<<19) |(1<<20));
+    
+    #if 0
+    /* Set source MAC address - REQUIRED */
+    adap_emac->MACSRCADDRHI = (emac_mac_addr[3] << 24) | (emac_mac_addr[2] << 16) |
+                              (emac_mac_addr[1] << 8)  | (emac_mac_addr[0]);
+    adap_emac->MACSRCADDRLO = ((emac_mac_addr[4] << 8) | emac_mac_addr[5]);
+    #endif
+    
+    /* Set DMA 8 TX / 8 RX Head pointers to 0 */
+    addr = &adap_emac->TX0HDP;
+    for( cnt=0; cnt<16; cnt++ )
+        *addr++ = 0;
+    addr = &adap_emac->RX0HDP;
+    for( cnt=0; cnt<16; cnt++ )
+        *addr++ = 0;
+
+    /* Clear Statistics (do this before setting MacControl register) */
+    addr = &adap_emac->RXGOODFRAMES;
+    for( cnt=0; cnt < EMAC_NUM_STATS; cnt++ )
+        *addr++ = 0;
+
+    /* No multicast addressing */
+    adap_emac->MACHASH1 = 0 ;
+    adap_emac->MACHASH2 = 0 ;
+    
+    /* Create RX queue and set receive process in place */
+    emac_rx_active_head = emac_rx_desc;
+    for (cnt=0; cnt < EMAC_MAX_RX_BUFFERS; cnt++)
+    {
+        rx_desc->next = (unsigned int) (rx_desc + 1);
+        rx_desc->buffer = &emac_rx_buffers[cnt * (EMAC_MAX_ETHERNET_PKT_SIZE + EMAC_PKT_ALIGN)];
+        rx_desc->buff_off_len = EMAC_MAX_ETHERNET_PKT_SIZE;
+        rx_desc->pkt_flag_len = EMAC_CPPI_OWNERSHIP_BIT;
+        ++rx_desc;
+    }
+    
+    /* Set the last descriptor's "next" parameter to 0 to end the RX desc list */
+    --rx_desc;
+    rx_desc->next = 0;
+    emac_rx_active_tail = rx_desc;
+    emac_rx_queue_active = 1;
+    
+    /* Enable TX/RX */
+    adap_emac->RXMAXLEN = EMAC_MAX_ETHERNET_PKT_SIZE;
+    adap_emac->RXBUFFEROFFSET = 0;
+    
+    /* No fancy configs - Use this for promiscous for debug - EMAC_RXMBPENABLE_RXCAFEN_ENABLE */
+    adap_emac->RXMBPENABLE = EMAC_RXMBPENABLE_RXBROADEN ;
+
+    /* Enable ch 0 only */
+    adap_emac->RXUNICASTSET = 0x1; 
+    
+    /* Enable MII interface and Full duplex mode */
+    /* This is the only register used in the code, which has changed in
+       Davinci-HD. That change (only a bit) might not affect the working here at
+       the bootloader level. If something is not working as expected, then look
+       here first. - Suresh */
+    adap_emac->MACCONTROL = (EMAC_MACCONTROL_MIIEN_ENABLE | EMAC_MACCONTROL_FULLDUPLEX_ENABLE); 
+    
+    /* Init MDIO & get link state */
+    clkdiv = (EMAC_MDIO_BUS_FREQ / EMAC_MDIO_CLOCK_FREQ) - 1;
+    adap_mdio->CONTROL = ((clkdiv & 0xFF) | MDIO_CONTROL_ENABLE | MDIO_CONTROL_FAULT);  
+    emac_link_status = mdio_get_link_state(EMAC_MDIO_PHY_MASK);
+    
+    /* Start receive process */
+    adap_emac->RX0HDP = (unsigned int) emac_rx_desc;
+    
+    debug_emac("- emac_open\n");
+
+    return (1);
+}
+
+/* EMAC Channel Teardown */
+void emac_ch_teardown(int ch)
+{
+    volatile unsigned int dly = 0xFF;
+    volatile unsigned int cnt;
+    
+    debug_emac("+ emac_ch_teardown\n");
+    
+    if (ch == EMAC_CH_TX)
+    {
+        /* Init TX channel teardown */
+        adap_emac->TXTEARDOWN = 1;
+        for( cnt = 0; cnt != 0xFFFFFFFC; cnt = adap_emac->TX0CP){
+            /* Wait here for Tx teardown completion interrupt to occur 
+             * Note: A task delay can be called here to pend rather than 
+             * occupying CPU cycles - anyway it has been found that teardown 
+             * takes very few cpu cycles and does not affect functionality */
+            --dly;
+            udelay(1);
+            if (dly == 0) break;
+        }
+        adap_emac->TX0CP = cnt;
+        adap_emac->TX0HDP = 0;
+    }
+    else
+    {
+        /* Init RX channel teardown */
+        adap_emac->RXTEARDOWN = 1;
+        for( cnt = 0; cnt != 0xFFFFFFFC; cnt = adap_emac->RX0CP){
+            /* Wait here for Tx teardown completion interrupt to occur 
+             * Note: A task delay can be called here to pend rather than 
+             * occupying CPU cycles - anyway it has been found that teardown 
+             * takes very few cpu cycles and does not affect functionality */
+            --dly;
+            udelay(1);
+            if (dly == 0) break;
+        }
+        adap_emac->RX0CP = cnt;
+        adap_emac->RX0HDP = 0;
+    }
+    
+    debug_emac("- emac_ch_teardown\n");
+}
+
+/*
+ * This is called by the kernel in response to 'ifconfig ethX down'.  It
+ * is responsible for cleaning up everything that the open routine
+ * does, and maybe putting the card into a powerdown state.
+ */
+static int emac_close (void)
+{
+    debug_emac("+ emac_close\n");
+    
+    emac_ch_teardown(EMAC_CH_TX); /* TX Channel teardown */
+    emac_ch_teardown(EMAC_CH_RX); /* RX Channel teardown */
+
+    /* Reset EMAC module and disable interrupts in wrapper */
+    adap_emac->SOFTRESET = 1;
+    /* HD change, put wrapper in reset */
+    adap_ewrap->SOFTRST = 1;
+    
+    debug_emac("- emac_close\n");
+    return (1);
+}
+
+static int tx_send_loop = 0;
+
+/*
+ * This function sends a single packet on the network and returns
+ * positive number (number of bytes transmitted) or negative for error
+ */
+static int emac_send_packet (volatile void *packet, int length)
+{
+    int ret_status = -1;
+    tx_send_loop = 0;
+    
+    /* Return error if no link */
+    emac_link_status = mdio_get_link_state(EMAC_MDIO_PHY_MASK);
+    if (emac_link_status == 0)
+    {
+        printf("WARN: emac_send_packet: No link\n");
+        return (ret_status);
+    }
+    
+    /* Check packet size and if < EMAC_MIN_ETHERNET_PKT_SIZE, pad it up */
+    if (length < EMAC_MIN_ETHERNET_PKT_SIZE)
+    {
+      length = EMAC_MIN_ETHERNET_PKT_SIZE;
+    }
+
+    /* Populate the TX descriptor */
+    emac_tx_desc->next         = 0;
+    emac_tx_desc->buffer       = (unsigned char *)packet;
+    emac_tx_desc->buff_off_len = (length & 0xFFFF);
+    emac_tx_desc->pkt_flag_len = ((length & 0xFFFF) | 
+                                  EMAC_CPPI_SOP_BIT | 
+                                  EMAC_CPPI_OWNERSHIP_BIT | 
+                                  EMAC_CPPI_EOP_BIT);
+    /* Send the packet */
+    adap_emac->TX0HDP = (unsigned int) emac_tx_desc;
+    
+    /* Wait for packet to complete or link down */
+    while (1)
+    {
+        emac_link_status = mdio_get_link_state(EMAC_MDIO_PHY_MASK);
+        if (emac_link_status == 0)
+        {
+            emac_ch_teardown(EMAC_CH_TX);
+            return (ret_status);
+        }
+        if (adap_emac->TXINTSTATRAW & 0x1)
+        {
+            ret_status = length;
+            break;
+        }
+        ++tx_send_loop;
+    }
+
+    return (ret_status);
+    
+}
+
+/*
+ * This function handles receipt of a packet from the network
+ */
+static int emac_rcv_packet (void)
+{
+    volatile emac_desc *rx_curr_desc;
+    volatile emac_desc *curr_desc;
+    volatile emac_desc *tail_desc;
+    unsigned int status, ret= -1;
+    
+    rx_curr_desc = emac_rx_active_head;
+    status = rx_curr_desc->pkt_flag_len;
+    if ((rx_curr_desc) && ((status & EMAC_CPPI_OWNERSHIP_BIT) == 0))
+    {
+        if (status & EMAC_CPPI_RX_ERROR_FRAME) {
+            /* Error in packet - discard it and requeue desc */
+		    printf("WARN: emac_rcv_pkt: Error in packet\n");
+        }
+        else {
+            NetReceive(rx_curr_desc->buffer, (rx_curr_desc->buff_off_len & 0xFFFF));
+		    ret = rx_curr_desc->buff_off_len & 0xFFFF;
+        }
+
+        /* Ack received packet descriptor */
+        adap_emac->RX0CP = (unsigned int) rx_curr_desc;
+        curr_desc = rx_curr_desc;
+        emac_rx_active_head = rx_curr_desc->next;
+        
+        if (status & EMAC_CPPI_EOQ_BIT) {
+            if (emac_rx_active_head) {
+                adap_emac->RX0HDP = (unsigned int) emac_rx_active_head;
+            } else {
+                emac_rx_queue_active = 0;
+                printf("INFO:emac_rcv_packet: RX Queue not active\n");
+            }
+        }
+        
+        /* Recycle RX descriptor */        
+        rx_curr_desc->buff_off_len = EMAC_MAX_ETHERNET_PKT_SIZE;
+        rx_curr_desc->pkt_flag_len = EMAC_CPPI_OWNERSHIP_BIT;
+        rx_curr_desc->next = 0;
+
+        if (emac_rx_active_head == 0) {
+            printf("INFO: emac_rcv_pkt: active queue head = 0\n");
+            emac_rx_active_head = curr_desc;
+            emac_rx_active_tail = curr_desc;
+            if (emac_rx_queue_active != 0) {
+                adap_emac->RX0HDP = (unsigned int) emac_rx_active_head;
+                printf("INFO: emac_rcv_pkt: active queue head = 0, HDP fired\n");
+                emac_rx_queue_active = 1;
+            }
+        } else {
+
+            tail_desc = emac_rx_active_tail;
+            emac_rx_active_tail = curr_desc;
+            tail_desc->next = curr_desc;
+            status = tail_desc->pkt_flag_len;
+            if (status & EMAC_CPPI_EOQ_BIT) {
+                adap_emac->RX0HDP = (unsigned int) curr_desc;
+                status &= ~EMAC_CPPI_EOQ_BIT;
+                tail_desc->pkt_flag_len = status;
+            }
+        }   
+	    return ret;
+    }
+    return (0);
+}
+
+#endif /* CONFIG_COMMANDS & CFG_CMD_NET */
+
+#endif /* CONFIG_DRIVER_TI_EMAC */
diff -Nurd u-boot-1.2.0/board/dm700/dm646x_emac.h u-boot-1.2.0-leopard/board/dm700/dm646x_emac.h
--- u-boot-1.2.0/board/dm700/dm646x_emac.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm700/dm646x_emac.h	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,321 @@
+/*
+ * dm644x_emac.h
+ *
+ * TI DaVinci (DM644X) EMAC peripheral driver header for DV-EVM
+ *
+ * Copyright (C) 2005 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ 
+ * Modifications:
+ * ver. 1.0: Sep 2005, TI PSP Team - Created EMAC version for uBoot.
+ *
+ */
+ 
+#ifndef _DM644X_EMAC_H_
+#define _DM644X_EMAC_H_
+
+/***********************************************
+ ********** Configurable items *****************
+ ***********************************************/
+ 
+/* Addresses of EMAC module in DaVinci */
+#define EMAC_BASE_ADDR             (0x01C80000)
+#define EMAC_WRAPPER_BASE_ADDR     (0x01C81000)
+#define EMAC_WRAPPER_RAM_ADDR      (0x01C82000)
+#define EMAC_MDIO_BASE_ADDR        (0x01C84000)
+
+/* MDIO module input frequency */
+#define EMAC_MDIO_BUS_FREQ          76500000    /* PLL/6 - 76.5 MHz */
+/* MDIO clock output frequency */
+#define EMAC_MDIO_CLOCK_FREQ        2200000     /* 2.2 MHz */
+
+/* PHY mask - set only those phy number bits where phy is/can be connected */
+#define EMAC_MDIO_PHY_MASK          0xFFFFFFFF
+
+/* Ethernet Min/Max packet size */
+#define EMAC_MIN_ETHERNET_PKT_SIZE  60
+#define EMAC_MAX_ETHERNET_PKT_SIZE  1518
+#define EMAC_PKT_ALIGN              18  /* 1518 + 18 = 1536 (packet aligned on 32 byte boundry) */
+
+/* Number of RX packet buffers
+ * NOTE: Only 1 buffer supported as of now 
+ */
+#define EMAC_MAX_RX_BUFFERS         10
+
+/***********************************************
+ ******** Internally used macros ***************
+ ***********************************************/
+
+#define EMAC_CH_TX                  1 
+#define EMAC_CH_RX                  0
+
+/* Each descriptor occupies 4, lets start RX desc's at 0 and 
+ * reserve space for 64 descriptors max
+ */
+#define EMAC_RX_DESC_BASE           0x0
+#define EMAC_TX_DESC_BASE           0x1000
+
+/* EMAC Teardown value */
+#define EMAC_TEARDOWN_VALUE         0xFFFFFFFC
+
+/* MII Status Register */
+#define MII_STATUS_REG              1
+
+/* Intel LXT971 Digtal Config Register */
+#define MII_DIGITAL_CONFIG_REG      26
+
+/* Number of statistics registers */
+#define EMAC_NUM_STATS              36
+
+/* EMAC Descriptor */
+typedef volatile struct _emac_desc 
+{
+  unsigned int      next;           /* Pointer to next descriptor in chain */
+  unsigned char     *buffer;        /* Pointer to data buffer              */
+  unsigned int      buff_off_len;   /* Buffer Offset(MSW) and Length(LSW)  */
+  unsigned int      pkt_flag_len;   /* Packet Flags(MSW) and Length(LSW)   */
+} emac_desc;
+
+/* CPPI bit positions */
+#define EMAC_CPPI_SOP_BIT               (0x80000000)  /*(1 << 31)*/
+#define EMAC_CPPI_EOP_BIT               (0x40000000)  /*(1 << 30*/
+#define EMAC_CPPI_OWNERSHIP_BIT         (0x20000000)  /*(1 << 29)*/
+#define EMAC_CPPI_EOQ_BIT               (0x10000000)  /*(1 << 28)*/
+#define EMAC_CPPI_TEARDOWN_COMPLETE_BIT (0x08000000)  /*(1 << 27)*/
+#define EMAC_CPPI_PASS_CRC_BIT          (0x04000000)  /*(1 << 26)*/
+
+#define EMAC_CPPI_RX_ERROR_FRAME        (0x03FC0000)
+
+#define EMAC_MACCONTROL_MIIEN_ENABLE        (0x20)
+#define EMAC_MACCONTROL_FULLDUPLEX_ENABLE   (0x1)
+
+#define EMAC_RXMBPENABLE_RXCAFEN_ENABLE     (0x200000)
+#define EMAC_RXMBPENABLE_RXBROADEN          (0x2000)
+
+
+#define MDIO_CONTROL_ENABLE             (0x40000000)
+#define MDIO_CONTROL_FAULT              (0x80000)
+#define MDIO_USERACCESS0_GO             (0x80000000)
+#define MDIO_USERACCESS0_WRITE_READ     (0x0)
+#define MDIO_USERACCESS0_WRITE_WRITE    (0x40000000)
+
+
+
+/* EMAC Register overlay */
+
+/* Ethernet MAC control register overlay structure */
+typedef volatile struct  {
+    unsigned int TXIDVER;
+    unsigned int TXCONTROL;
+    unsigned int TXTEARDOWN;
+    unsigned char RSVD0[4];
+    unsigned int RXIDVER;
+    unsigned int RXCONTROL;
+    unsigned int RXTEARDOWN;
+    unsigned char RSVD1[100];
+    unsigned int TXINTSTATRAW;
+    unsigned int TXINTSTATMASKED;
+    unsigned int TXINTMASKSET;
+    unsigned int TXINTMASKCLEAR;
+    unsigned int MACINVECTOR;
+    unsigned char RSVD2[12];
+    unsigned int RXINTSTATRAW;
+    unsigned int RXINTSTATMASKED;
+    unsigned int RXINTMASKSET;
+    unsigned int RXINTMASKCLEAR;
+    unsigned int MACINTSTATRAW;
+    unsigned int MACINTSTATMASKED;
+    unsigned int MACINTMASKSET;
+    unsigned int MACINTMASKCLEAR;
+    unsigned char RSVD3[64];
+    unsigned int RXMBPENABLE;
+    unsigned int RXUNICASTSET;
+    unsigned int RXUNICASTCLEAR;
+    unsigned int RXMAXLEN;
+    unsigned int RXBUFFEROFFSET;
+    unsigned int RXFILTERLOWTHRESH;
+    unsigned char RSVD4[8];
+    unsigned int RX0FLOWTHRESH;
+    unsigned int RX1FLOWTHRESH;
+    unsigned int RX2FLOWTHRESH;
+    unsigned int RX3FLOWTHRESH;
+    unsigned int RX4FLOWTHRESH;
+    unsigned int RX5FLOWTHRESH;
+    unsigned int RX6FLOWTHRESH;
+    unsigned int RX7FLOWTHRESH;
+    unsigned int RX0FREEBUFFER;
+    unsigned int RX1FREEBUFFER;
+    unsigned int RX2FREEBUFFER;
+    unsigned int RX3FREEBUFFER;
+    unsigned int RX4FREEBUFFER;
+    unsigned int RX5FREEBUFFER;
+    unsigned int RX6FREEBUFFER;
+    unsigned int RX7FREEBUFFER;
+    unsigned int MACCONTROL;
+    unsigned int MACSTATUS;
+    unsigned int EMCONTROL;
+    unsigned int FIFOCONTROL;
+    unsigned int MACCONFIG;
+    unsigned int SOFTRESET;
+    unsigned char RSVD5[88];
+    unsigned int MACSRCADDRLO;
+    unsigned int MACSRCADDRHI;
+    unsigned int MACHASH1;
+    unsigned int MACHASH2;
+    unsigned int BOFFTEST;
+    unsigned int TPACETEST;
+    unsigned int RXPAUSE;
+    unsigned int TXPAUSE;
+    unsigned char RSVD6[16];
+    unsigned int RXGOODFRAMES;	/* EMAC Statistics Registers - Start */
+    unsigned int RXBCASTFRAMES;
+    unsigned int RXMCASTFRAMES;
+    unsigned int RXPAUSEFRAMES;
+    unsigned int RXCRCERRORS;
+    unsigned int RXALIGNCODEERRORS;
+    unsigned int RXOVERSIZED;
+    unsigned int RXJABBER;
+    unsigned int RXUNDERSIZED;
+    unsigned int RXFRAGMENTS;
+    unsigned int RXFILTERED;
+    unsigned int RXQOSFILTERED;
+    unsigned int RXOCTETS;
+    unsigned int TXGOODFRAMES;
+    unsigned int TXBCASTFRAMES;
+    unsigned int TXMCASTFRAMES;
+    unsigned int TXPAUSEFRAMES;
+    unsigned int TXDEFERRED;
+    unsigned int TXCOLLISION;
+    unsigned int TXSINGLECOLL;
+    unsigned int TXMULTICOLL;
+    unsigned int TXEXCESSIVECOLL;
+    unsigned int TXLATECOLL;
+    unsigned int TXUNDERRUN;
+    unsigned int TXCARRIERSENSE;
+    unsigned int TXOCTETS;
+    unsigned int FRAME64;
+    unsigned int FRAME65T127;
+    unsigned int FRAME128T255;
+    unsigned int FRAME256T511;
+    unsigned int FRAME512T1023;
+    unsigned int FRAME1024TUP;
+    unsigned int NETOCTETS;
+    unsigned int RXSOFOVERRUNS;
+    unsigned int RXMOFOVERRUNS;
+    unsigned int RXDMAOVERRUNS;	/* EMAC Statistics register - End */
+    unsigned char RSVD7[624];
+    unsigned int MACADDRLO;
+    unsigned int MACADDRHI;
+    unsigned int MACINDEX;
+    unsigned char RSVD8[244];
+    unsigned int TX0HDP;
+    unsigned int TX1HDP;
+    unsigned int TX2HDP;
+    unsigned int TX3HDP;
+    unsigned int TX4HDP;
+    unsigned int TX5HDP;
+    unsigned int TX6HDP;
+    unsigned int TX7HDP;
+    unsigned int RX0HDP;
+    unsigned int RX1HDP;
+    unsigned int RX2HDP;
+    unsigned int RX3HDP;
+    unsigned int RX4HDP;
+    unsigned int RX5HDP;
+    unsigned int RX6HDP;
+    unsigned int RX7HDP;
+    unsigned int TX0CP;
+    unsigned int TX1CP;
+    unsigned int TX2CP;
+    unsigned int TX3CP;
+    unsigned int TX4CP;
+    unsigned int TX5CP;
+    unsigned int TX6CP;
+    unsigned int TX7CP;
+    unsigned int RX0CP;
+    unsigned int RX1CP;
+    unsigned int RX2CP;
+    unsigned int RX3CP;
+    unsigned int RX4CP;
+    unsigned int RX5CP;
+    unsigned int RX6CP;
+    unsigned int RX7CP;
+} emac_regs;
+
+/* EMAC Wrapper (control module) Register Overlay */
+typedef volatile struct  {
+    volatile unsigned int IDVER;
+    volatile unsigned int SOFTRST;
+    volatile unsigned int EMCTRL;
+    volatile unsigned int INTCTRL;
+    volatile unsigned int C0_RXTHRESHEN;
+    volatile unsigned int C0_RXINTEN;
+    volatile unsigned int C0_TXINTEN;
+    volatile unsigned int C0_MISCEN;
+    volatile unsigned int C1_RXTHRESHEN;
+    volatile unsigned int C1_RXINTEN;
+    volatile unsigned int C1_TXINTEN;
+    volatile unsigned int C1_MISCEN;
+    volatile unsigned int C2_RXTHRESHEN;
+    volatile unsigned int C2_RXINTEN;
+    volatile unsigned int C2_TXINTEN;
+    volatile unsigned int C2_MISCEN;
+    volatile unsigned int C0_RXTHRESHSTAT;
+    volatile unsigned int C0_RXINTSTAT;
+    volatile unsigned int C0_TXINTSTAT;
+    volatile unsigned int C0_MISCSTAT;
+    volatile unsigned int C1_RXTHRESHSTAT;
+    volatile unsigned int C1_RXINTSTAT;
+    volatile unsigned int C1_TXINTSTAT;
+    volatile unsigned int C1_MISCSTAT;
+    volatile unsigned int C2_RXTHRESHSTAT;
+    volatile unsigned int C2_RXINTSTAT;
+    volatile unsigned int C2_TXINTSTAT;
+    volatile unsigned int C2_MISCSTAT;
+    volatile unsigned int C0_RXIMAX;
+    volatile unsigned int C0_TXIMAX;
+    volatile unsigned int C1_RXIMAX;
+    volatile unsigned int C1_TXIMAX;
+    volatile unsigned int C2_RXIMAX;
+    volatile unsigned int C2_TXIMAX;
+} ewrap_regs;
+
+
+/* EMAC MDIO Register Overlay */
+typedef volatile struct  {
+    volatile unsigned int VERSION;
+    volatile unsigned int CONTROL;
+    volatile unsigned int ALIVE;
+    volatile unsigned int LINK;
+    volatile unsigned int LINKINTRAW;
+    volatile unsigned int LINKINTMASKED;
+    volatile unsigned char RSVD0[8];
+    volatile unsigned int USERINTRAW;
+    volatile unsigned int USERINTMASKED;
+    volatile unsigned int USERINTMASKSET;
+    volatile unsigned int USERINTMASKCLEAR;
+    volatile unsigned char RSVD1[80];
+    volatile unsigned int USERACCESS0;
+    volatile unsigned int USERPHYSEL0;
+    volatile unsigned int USERACCESS1;
+    volatile unsigned int USERPHYSEL1;
+} mdio_regs;
+
+
+#endif  /* _DM644X_EMAC_H_ */
diff -Nurd u-boot-1.2.0/board/dm700/flash.c u-boot-1.2.0-leopard/board/dm700/flash.c
--- u-boot-1.2.0/board/dm700/flash.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm700/flash.c	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,686 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2003
+ * Reinhard Meyer, EMK Elektronik GmbH, r.meyer@emk-elektronik.de
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */	
+
+#include <common.h>
+#include <linux/byteorder/swab.h>
+#include "types.h"
+
+flash_info_t	flash_info[CFG_MAX_FLASH_BANKS]; /* info for FLASH chips */
+
+#if defined (CFG_DAVINCI_HD)
+  typedef unsigned short FLASH_PORT_WIDTH;
+  typedef volatile unsigned short FLASH_PORT_WIDTHV;
+  #define	FLASH_ID_MASK	0xFF
+
+  #define FPW	FLASH_PORT_WIDTH
+  #define FPWV	FLASH_PORT_WIDTHV
+
+  #define FLASH_CYCLE1	0x0555
+  #define FLASH_CYCLE2	0x02aa
+  #define FLASH_ID1		0
+  #define FLASH_ID2		1
+  #define FLASH_ID3		0x0e
+  #define FLASH_ID4		0x0F
+  #define SWAP(x)			__swab16(x)
+#endif
+
+#if defined (CONFIG_TOP860)
+  typedef unsigned short FLASH_PORT_WIDTH;
+  typedef volatile unsigned short FLASH_PORT_WIDTHV;
+  #define	FLASH_ID_MASK	0xFF
+
+  #define FPW	FLASH_PORT_WIDTH
+  #define FPWV	FLASH_PORT_WIDTHV
+
+  #define FLASH_CYCLE1	0x0555
+  #define FLASH_CYCLE2	0x02aa
+  #define FLASH_ID1		0
+  #define FLASH_ID2		1
+  #define FLASH_ID3		0x0e
+  #define FLASH_ID4		0x0F
+#endif
+
+#if defined (CONFIG_TOP5200) && !defined (CONFIG_LITE5200)
+  typedef unsigned char FLASH_PORT_WIDTH;
+  typedef volatile unsigned char FLASH_PORT_WIDTHV;
+  #define	FLASH_ID_MASK	0xFF
+
+  #define FPW	FLASH_PORT_WIDTH
+  #define FPWV	FLASH_PORT_WIDTHV
+
+  #define FLASH_CYCLE1	0x0aaa
+  #define FLASH_CYCLE2	0x0555
+  #define FLASH_ID1		0
+  #define FLASH_ID2		2
+  #define FLASH_ID3		0x1c
+  #define FLASH_ID4		0x1E
+#endif
+
+#if defined (CONFIG_TOP5200) && defined (CONFIG_LITE5200)
+  typedef unsigned char FLASH_PORT_WIDTH;
+  typedef volatile unsigned char FLASH_PORT_WIDTHV;
+  #define	FLASH_ID_MASK	0xFF
+
+  #define FPW	FLASH_PORT_WIDTH
+  #define FPWV	FLASH_PORT_WIDTHV
+
+  #define FLASH_CYCLE1	0x0555
+  #define FLASH_CYCLE2	0x02aa
+  #define FLASH_ID1		0
+  #define FLASH_ID2		1
+  #define FLASH_ID3		0x0E
+  #define FLASH_ID4		0x0F
+#endif
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size(FPWV *addr, flash_info_t *info);
+static void flash_reset(flash_info_t *info);
+static int write_word(flash_info_t *info, FPWV *dest, FPW data);
+static flash_info_t *flash_get_info(ulong base);
+void inline spin_wheel (void);
+
+/*-----------------------------------------------------------------------
+ * flash_init()
+ *
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long flash_init (void)
+{
+	unsigned long size = 0;
+	int i = 0;
+	extern void flash_preinit(void);
+	extern void flash_afterinit(uint, ulong, ulong);
+	ulong flashbase = CFG_FLASH_BASE;
+
+	/*flash_preinit();*/
+
+	/* There is only ONE FLASH device */
+	memset(&flash_info[i], 0, sizeof(flash_info_t));
+	flash_info[i].size =
+			flash_get_size((FPW *)flashbase, &flash_info[i]);
+	size += flash_info[i].size;
+
+#if CFG_MONITOR_BASE >= CFG_FLASH_BASE
+	/* monitor protection ON by default */
+	flash_protect(FLAG_PROTECT_SET,
+		      CFG_MONITOR_BASE,
+		      CFG_MONITOR_BASE+monitor_flash_len-1,
+		      flash_get_info(CFG_MONITOR_BASE));
+#endif
+
+#ifdef	CFG_ENV_IS_IN_FLASH
+	/* ENV protection ON by default */
+	flash_protect(FLAG_PROTECT_SET,
+		      CFG_ENV_ADDR,
+		      CFG_ENV_ADDR+CFG_ENV_SIZE-1,
+		      flash_get_info(CFG_ENV_ADDR));
+#endif
+
+
+	/*flash_afterinit(i, flash_info[i].start[0], flash_info[i].size);*/
+	return size ? size : 1;
+}
+
+/*-----------------------------------------------------------------------
+ */
+static void flash_reset(flash_info_t *info)
+{
+	FPWV *base = (FPWV *)(info->start[0]);
+
+	/* Put FLASH back in read mode */
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL)
+		*base = (FPW)0x00FF00FF;	/* Intel Read Mode */
+	else if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD)
+		*base = (FPW)0x00F000F0;	/* AMD Read Mode */
+}
+
+
+void flash_reset_sector(flash_info_t *info, ULONG addr)
+{  
+	// Reset Flash to be in Read Array Mode 
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL)
+		*(FPWV *)addr = (FPW)0x00FF00FF;	/* Intel Read Mode */
+	else if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD)
+		*(FPWV *)addr = (FPW)0x00F000F0;	/* AMD Read Mode */
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+static flash_info_t *flash_get_info(ulong base)
+{
+	int i;
+	flash_info_t * info;
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i ++) {
+		info = & flash_info[i];
+		if (info->size &&
+			info->start[0] <= base && base <= info->start[0] + info->size - 1)
+			break;
+	}
+
+	return i == CFG_MAX_FLASH_BANKS ? 0 : info;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+void flash_print_info (flash_info_t *info)
+{
+	int i;
+	uchar *boottype;
+	uchar *bootletter;
+	uchar *fmt;
+	uchar botbootletter[] = "B";
+	uchar topbootletter[] = "T";
+	uchar botboottype[] = "bottom boot sector";
+	uchar topboottype[] = "top boot sector";
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		printf ("missing or unknown FLASH type\n");
+		return;
+	}
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case FLASH_MAN_AMD:	printf ("MY AMD ");		break;
+#if 0
+	case FLASH_MAN_BM:	printf ("BRIGHT MICRO ");	break;
+	case FLASH_MAN_FUJ:	printf ("FUJITSU ");		break;
+	case FLASH_MAN_SST:	printf ("SST ");		break;
+	case FLASH_MAN_STM:	printf ("STM ");		break;
+#endif
+	case FLASH_MAN_INTEL:	printf ("INTEL ");		break;
+	default:		printf ("Unknown Vendor ");	break;
+	}
+
+	/* check for top or bottom boot, if it applies */
+	if (info->flash_id & FLASH_BTYPE) {
+		boottype = botboottype;
+		bootletter = botbootletter;
+	}
+	else {
+		boottype = topboottype;
+		bootletter = topbootletter;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_AM160T:
+	case FLASH_AM160B:
+		fmt = "29LV160%s (16 Mbit, %s)\n";
+		break;
+	case FLASH_AMLV640U:
+		fmt = "29LV640M (64 Mbit)\n";
+		break;
+	case FLASH_AMDLV065D:
+		fmt = "29LV065D (64 Mbit)\n";
+		break;
+	case FLASH_AMLV256U:
+		fmt = "29LV256M (256 Mbit)\n";
+		break;
+	case FLASH_28F128P30T:
+		fmt = "28F128P30T\n";
+		break;
+	default:
+		fmt = "Unknown Chip Type\n";
+		break;
+	}
+
+	printf (fmt, bootletter, boottype);
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+		info->size >> 20,
+		info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+
+	for (i=0; i<info->sector_count; ++i) {
+		ulong	size;
+		int		erased;
+		ulong	*flash = (unsigned long *) info->start[i];
+
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+
+		/*
+		 * Check if whole sector is erased
+		 */
+		size =
+			(i != (info->sector_count - 1)) ?
+			(info->start[i + 1] - info->start[i]) >> 2 :
+		(info->start[0] + info->size - info->start[i]) >> 2;
+
+		for (
+			flash = (unsigned long *) info->start[i], erased = 1;
+				(flash != (unsigned long *) info->start[i] + size) && erased;
+					flash++
+			)
+			erased = *flash == ~0x0UL;
+
+		printf (" %08lX %s %s",
+			info->start[i],
+			erased ? "E": " ",
+			info->protect[i] ? "(RO)" : "    ");
+	}
+
+	printf ("\n");
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+/*
+ * The following code cannot be run from FLASH!
+ */
+
+ulong flash_get_size (FPWV *addr, flash_info_t *info)
+{
+	int		i;
+
+	/* Write auto select command: read Manufacturer ID */
+	/* Write auto select command sequence and test FLASH answer */
+	addr[FLASH_CYCLE1] = (FPW)0x00AA00AA;	/* for AMD, Intel ignores this */
+	addr[FLASH_CYCLE2] = (FPW)0x00550055;	/* for AMD, Intel ignores this */
+	addr[FLASH_CYCLE1] = (FPW)0x00900090;	/* selects Intel or AMD */
+
+	/* The manufacturer codes are only 1 byte, so just use 1 byte.
+	 * This works for any bus width and any FLASH device width.
+	 */
+	udelay(100);
+	switch (addr[FLASH_ID1] & 0xff) {
+
+	case (uchar)AMD_MANUFACT:
+		printf ("MY AMD ", addr[FLASH_ID1] & 0xff);
+		info->flash_id = FLASH_MAN_AMD;
+		break;
+
+	case (uchar)INTEL_MANUFACT:
+                printf ("INTEL ", addr[FLASH_ID1] & 0xff);
+		info->flash_id = FLASH_MAN_INTEL;
+		break;
+
+	default:
+		printf ("unknown vendor=%x ", addr[FLASH_ID1] & 0xff);
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		break;
+	}
+
+	/* Check 16 bits or 32 bits of ID so work on 32 or 16 bit bus. */
+	if (info->flash_id != FLASH_UNKNOWN) switch ((FPW)addr[FLASH_ID2]) {
+
+	case (FPW)AMD_ID_LV160B:
+		info->flash_id += FLASH_AM160B;
+		info->sector_count = 35;
+		info->size = 0x00200000;
+		info->start[0] = (ulong)addr;
+		info->start[1] = (ulong)addr + 0x4000;
+		info->start[2] = (ulong)addr + 0x6000;
+		info->start[3] = (ulong)addr + 0x8000;
+		for (i = 4; i < info->sector_count; i++)
+		{
+			info->start[i] = (ulong)addr + 0x10000 * (i-3);
+		}
+		break;
+
+	case (FPW)AMD_ID_LV065D:
+		info->flash_id += FLASH_AMDLV065D;
+		info->sector_count = 128;
+		info->size = 0x00800000;
+		for (i = 0; i < info->sector_count; i++)
+		{
+			info->start[i] = (ulong)addr + 0x10000 * i;
+		}
+		break;
+
+	case (FPW)AMD_ID_MIRROR:
+		/* MIRROR BIT FLASH, read more ID bytes */
+		if ((FPW)addr[FLASH_ID3] == (FPW)AMD_ID_LV640U_2 &&
+			(FPW)addr[FLASH_ID4] == (FPW)AMD_ID_LV640U_3)
+		{
+			info->flash_id += FLASH_AMLV640U;
+			info->sector_count = 128;
+			info->size = 0x00800000;
+			for (i = 0; i < info->sector_count; i++)
+			{
+				info->start[i] = (ulong)addr + 0x10000 * i;
+			}
+			break;
+		}
+		if ((FPW)addr[FLASH_ID3] == (FPW)AMD_ID_LV256U_2 &&
+			(FPW)addr[FLASH_ID4] == (FPW)AMD_ID_LV256U_3)
+		{
+			/* attention: only the first 16 MB will be used in u-boot */
+			info->flash_id += FLASH_AMLV256U;
+			info->sector_count = 256;
+			info->size = 0x01000000;
+			for (i = 0; i < info->sector_count; i++)
+			{
+				info->start[i] = (ulong)addr + 0x10000 * i;
+			}
+			break;
+		}
+	case (FPW)INTEL_ID_28F128P30T:
+		/* Intel StrataFlash 28F128P30T */
+		info->flash_id += FLASH_28F128P30T;
+		info->sector_count = 131;
+		info->size = 0x01000000;
+		for (i = 0; i < info->sector_count; i++)
+		{
+			if (i < 127)
+				info->start[i] = (ulong)addr + 0x20000 * i;
+			else
+				info->start[i] = (ulong)addr + 0xfe0000 + 0x8000 * (i-127);
+		}
+		break;
+
+		/* fall thru to here ! */
+	default:
+		printf ("unknown AMD device=%x %x %x",
+			(FPW)addr[FLASH_ID2],
+			(FPW)addr[FLASH_ID3],
+			(FPW)addr[FLASH_ID4]);
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0x800000;
+		break;
+	}
+
+	/* Put FLASH back in read mode */
+	flash_reset(info);
+
+	return (info->size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int	flash_erase (flash_info_t *info, int s_first, int s_last)
+{
+	FPWV *addr;
+	int flag, prot, sect;
+	int intel = (info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL;
+	ulong start, now, last;
+	int rcode = 0;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		if (info->flash_id == FLASH_UNKNOWN) {
+			printf ("- missing\n");
+		} else {
+			printf ("- no sectors to erase\n");
+		}
+		return 1;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_AM160B:
+	case FLASH_AMLV640U:
+		break;
+	case FLASH_AMLV256U:
+		break;
+	case FLASH_28F128P30T:
+		break;
+	case FLASH_UNKNOWN:
+	default:
+		printf ("Can't erase unknown flash type %08lx - aborted\n",
+			info->flash_id);
+		return 1;
+	}
+
+	prot = 0;
+	for (sect=s_first; sect<=s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n",
+			prot);
+	} else {
+		printf ("\n");
+	}
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect<=s_last && rcode == 0; sect++) {
+
+		if (info->protect[sect] != 0)	/*bmw           esteem192e     ispan         mx1fs2       RPXlite      tqm8540
+ protected, skip it */
+			continue;
+
+		printf ("Erasing sector %2d ... ", sect);
+		addr = (FPWV *)(info->start[sect]);
+
+		if (intel) {
+			*addr = (FPW)0x00600060; /* unlock block setup */
+			*addr = (FPW)0x00d000d0; /* unlock block confirm */
+			*addr = (FPW)0x00500050; /* clear status register */
+			*addr = (FPW)0x00200020; /* erase setup */
+			*addr = (FPW)0x00D000D0; /* erase confirm */
+			while((*addr & 0x80) == 0);
+			printf("done.\n");
+		}
+		else {
+			/* must be AMD style if not Intel */
+			FPWV *base;		/* first address in bank */
+
+			base = (FPWV *)(info->start[0]);
+			base[FLASH_CYCLE1] = (FPW)0x00AA00AA;	/* unlock */
+			base[FLASH_CYCLE2] = (FPW)0x00550055;	/* unlock */
+			base[FLASH_CYCLE1] = (FPW)0x00800080;	/* erase mode */
+			base[FLASH_CYCLE1] = (FPW)0x00AA00AA;	/* unlock */
+			base[FLASH_CYCLE2] = (FPW)0x00550055;	/* unlock */
+			*addr = (FPW)0x00300030;	/* erase sector */
+			while (*((vHwdptr)addr) != 0xffff);
+			printf("done.\n");
+		}
+
+	}
+
+	/* Put FLASH back in read mode */
+	flash_reset(info);
+
+	printf (" Erase Operation Completed.\n");
+	return rcode;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+int write_buff (flash_info_t *info, uchar *src, ulong addr, ulong cnt)
+{
+	FPW data = 0; /* 16 or 32 bit word, matches flash bus width on MPC8XX */
+	int bytes;	  /* number of bytes to program in current word		*/
+	int left;	  /* number of bytes left to program			*/
+	int res;
+	ulong cp, wp;
+	int count, i, l, rc, port_width;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		return 4;
+		}
+
+	/* get lower word aligned address */
+	wp = (addr & ~1);
+	port_width = 2;
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+		for (; i < port_width && cnt > 0; ++i) {
+			data = (data << 8) | *src++;
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < port_width; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+
+		if ((rc = write_word (info, wp, SWAP (data))) != 0) {
+			return (rc);
+		}
+		wp += port_width;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	count = 0;
+	while (cnt >= port_width) {
+		data = 0;
+		for (i = 0; i < port_width; ++i) {
+			data = (data << 8) | *src++;
+		}
+		if ((rc = write_word (info, wp, SWAP (data))) != 0) {
+			return (rc);
+		}
+		wp += port_width;
+		cnt -= port_width;
+
+		if (count++ > 0x800) {
+			spin_wheel ();
+			count = 0;
+		}
+	}
+
+	if (cnt == 0) {
+		return (0);
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < port_width && cnt > 0; ++i, ++cp) {
+		data = (data << 8) | *src++;
+		--cnt;
+	}
+	for (; i < port_width; ++i, ++cp) {
+		data = (data << 8) | (*(uchar *) cp);
+	}
+
+	return (write_word (info, wp, SWAP (data)));
+}
+
+/*-----------------------------------------------------------------------
+ * Write a word to Flash
+ * A word is 16 or 32 bits, whichever the bus width of the flash bank
+ * (not an individual chip) is.
+ *
+ * returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+static int write_word (flash_info_t *info, FPWV *plAddress, FPW ulData)
+{
+	ulong start;
+	int flag;
+	int res = 0;	/* result, assume success	*/
+	FPWV *base;		/* first address in flash bank	*/
+	volatile USHORT *psAddress;
+	volatile USHORT *address_cs;
+	USHORT tmp;
+	ULONG tmp_ptr;
+
+	// Lower WORD.
+	psAddress = (USHORT *)plAddress;
+	tmp_ptr  = (ULONG) plAddress;
+	address_cs = (USHORT *) (tmp_ptr & 0xFE000000);
+
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL)
+	{
+		*plAddress = (FPW)0x00400040;
+		*plAddress = ulData;
+		while ((*plAddress & 0x80) == 0);
+	}
+	else if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD)
+	{
+		*((vHwdptr)address_cs + 0x555) = ((Hwd)0xAA);
+		*((vHwdptr)address_cs + 0x2AA) = ((Hwd)0x55);
+		*((vHwdptr)address_cs + 0x555) = ((Hwd)0xA0);
+		*psAddress = ulData;
+		// Wait for ready.
+		while (1)
+		{
+			tmp = *psAddress; 
+			if( (tmp & 0x80)  == (ulData & 0x80)) 
+			{
+				break;
+			}
+			else
+			{
+				if(tmp & 0x20)             // Exceeded Time Limit
+			{
+				tmp = *psAddress; 
+				if( (tmp & 0x80)  == (ulData & 0x80)) 
+				{
+					break; 
+				}
+				else
+				{
+				  	flash_reset_sector(info, (ULONG) psAddress);
+			      	return 1;
+				}	
+			}
+			}
+		}
+	}
+
+	// Return to read mode
+	flash_reset_sector(info, (ULONG) psAddress);
+
+	// Verify the data.
+	if (*psAddress != ulData)
+	{
+     	return 1;
+	printf("Write of one 16-bit word failed\n");
+	}
+	return 0;
+}
+
+void inline spin_wheel (void)
+{
+	static int p = 0;
+	static char w[] = "\\/-";
+
+	printf ("\010%c", w[p]);
+	(++p == 3) ? (p = 0) : 0;
+}
diff -Nurd u-boot-1.2.0/board/dm700/flash_params.h u-boot-1.2.0-leopard/board/dm700/flash_params.h
--- u-boot-1.2.0/board/dm700/flash_params.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm700/flash_params.h	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,319 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ *
+ */
+#ifndef _FLASH_PARAMSH_
+#define _FLASH_PARAMSH_
+//
+//Structs
+//
+typedef struct _PageInfo
+{
+    	ULONG	reserved;
+    	BYTE  	BlockReserved;
+    	BYTE  	BadBlockFlag;
+    	USHORT	reserved2;
+}PageInfo, *PPageInfo;
+
+typedef struct
+{
+	ULONG ReturnValue;
+	ULONG ReadAddress;
+	ULONG WriteAddress;
+	ULONG Size;
+} Download_Parms, *PDownload_Parms;
+
+#define NO_ERROR            0
+#define CORRECTED_ERROR     1
+#define ECC_ERROR           2
+#define UNCORRECTED_ERROR   3
+
+
+#define BIT0    0x00000001
+#define BIT1    0x00000002
+#define BIT2    0x00000004
+#define BIT3    0x00000008
+#define BIT4    0x00000010
+#define BIT5    0x00000020
+#define BIT6    0x00000040
+#define BIT7    0x00000080
+#define BIT8    0x00000100
+#define BIT9    0x00000200
+#define BIT10   0x00000400
+#define BIT11   0x00000800
+#define BIT12   0x00001000
+#define BIT13   0x00002000
+#define BIT14   0x00004000
+#define BIT15   0x00008000
+#define BIT16   0x00010000
+#define BIT17   0x00020000
+#define BIT18   0x00040000
+#define BIT19   0x00080000
+#define BIT20   0x00100000
+#define BIT21   0x00200000
+#define BIT22   0x00400000
+#define BIT23   0x00800000
+#define BIT24   0x01000000
+#define BIT25   0x02000000
+#define BIT26   0x04000000
+#define BIT27   0x08000000
+#define BIT28   0x10000000
+#define BIT29   0x20000000
+#define BIT30   0x40000000
+#define BIT31   0x80000000
+
+
+
+//  Status bit pattern
+#define STATUS_READY                0x40
+#define STATUS_ERROR                0x01
+//
+//NOR SUPPORT
+//
+// Flash ID Commands INTEL
+#define INTEL_ID_CMD       ((Hwd)0x0090)     	// INTEL ID CMD
+#define INTEL_MANF_ID      ((Hwd)0x0089)     	// INTEL Manf ID expected
+#define INTEL_DEVICE_8T    ((Hwd)0x88F1)     	// INTEL 8Mb top device code
+#define INTEL_DEVICE_8B    ((Hwd)0x88F2)     	// INTEL 8Mb bottom device code
+#define INTEL_DEVICE_16T   ((Hwd)0x88F3)     	// INTEL 16Mb top device code
+#define INTEL_DEVICE_16B   ((Hwd)0x88F4)     	// INTEL 16Mb bottom device code
+#define INTELS_J3_DEVICE_32   ((Hwd)0x0016)     // INTEL Strata J3 32Mb device code
+#define INTELS_J3_DEVICE_64   ((Hwd)0x0017)     // INTEL Strata J3 64Mb device code
+#define INTELS_J3_DEVICE_128  ((Hwd)0x0018)     // INTEL Strata J3 128Mb device code
+#define INTELS_K3_DEVICE_64   ((Hwd)0x8801)     // INTEL Strata K3 64Mb device code
+#define INTELS_K3_DEVICE_128  ((Hwd)0x8802)    	// INTEL Strata K3 128Mb device code
+#define INTELS_K3_DEVICE_256  ((Hwd)0x8803)     // INTEL Strata K3 256Mb device code
+#define INTELS_W18_DEVICE_128T  ((Hwd)0x8876)   // INTEL Wirless Flash Top 128 Mb device code
+#define INTELS_W18_DEVICE_128B  ((Hwd)0x8867)   // INTEL Wirless Flash Bottom 128 Mb device code
+#define INTELS_L18_DEVICE_128T  ((Hwd)0x880C)   // INTEL Wirless Flash Top 128 Mb device code
+#define INTELS_L18_DEVICE_128B  ((Hwd)0x880F)   // INTEL Wirless Flash Bottom 128 Mb device code
+#define INTELS_L18_DEVICE_256T  ((Hwd)0x880D)   // INTEL Wirless Flash Top 256 Mb device code
+#define INTELS_L18_DEVICE_256B  ((Hwd)0x8810)  	// INTEL Wirless Flash Bottom 256 Mb device code
+#define INTELS_K18_DEVICE_256B  ((Hwd)0x8807)  	// INTEL Wirless Flash Bottom 256 Mb device code
+#define AMD1_DEVICE_ID     ((Hwd)0x2253)   // AMD29DL323CB
+#define AMD2_DEVICE_ID     ((Hwd)0x2249)   // AMD29LV160D
+#define AMD3_DEVICE_ID1    ((Hwd)0x2212)   // AMD29LV256M
+#define AMD3_DEVICE_ID2    ((Hwd)0x2201)   // AMD29LV256M
+// Flash ID Commands FUJITSU (Programs like AMD)
+#define FUJITSU_MANF_ID    ((Hwd)0x04)        // Fujitsu Manf ID expected
+#define FUJITSU1_DEVICE_ID     ((Hwd)0x2253)  // MBM29DL323BD
+//Micron Programs Like Intel or Micron
+#define MICRON_MANF_ID      ((Hwd)0x002C)     	// MICRON Manf ID expected
+#define MICRON_MT28F_DEVICE_128T ((Hwd)0x4492)	// MICRON Flash device Bottom 128 Mb
+//Samsung Programs like AMD
+#define SAMSUNG_MANF_ID      	((Hwd)0x00EC)     	//SAMSUNG Manf ID expected
+#define SAMSUNG_K8S2815E_128T  	((Hwd) 0x22F8)  	//SAMSUNG NOR Flash device TOP 128 Mb
+// Flash Erase Commands AMD and FUJITSU
+// Flash ID Commands AMD
+#define AMD_ID_CMD0        ((Hwd)0xAA)     // AMD ID CMD 0
+#define AMD_CMD0_ADDR       0x555          // AMD CMD0 Offset
+#define AMD_ID_CMD1        ((Hwd)0x55)     // AMD ID CMD 1
+#define AMD_CMD1_ADDR	    0x2AA          // AMD CMD1 Offset
+#define AMD_ID_CMD2        ((Hwd)0x90)     // AMD ID CMD 2
+#define AMD_CMD2_ADDR	    0x555          // AMD CMD2 Offset
+#define AMD_MANF_ID        ((Hwd)0x01)     // AMD Manf ID expected
+#define AMD_DEVICE_ID_MULTI   ((Hwd)0x227E)// Indicates Multi-Address Device ID
+#define AMD_DEVICE_ID_OFFSET 0x1
+#define AMD_DEVICE_ID_OFFSET1 0x0E         // First Addr for Multi-Address ID
+#define AMD_DEVICE_ID_OFFSET2 0x0F         // Second Addr for Multi-Address ID
+#define AMD_DEVICE_RESET   ((Hwd)0x00F0)   // AMD Device Reset Command
+#define AMD_ERASE_CMD0    ((Hwd)0xAA)
+#define AMD_ERASE_CMD1    ((Hwd)0x55)
+#define AMD_ERASE_CMD2    ((Hwd)0x80)
+#define AMD_ERASE_CMD3    ((Hwd)0xAA)     	// AMD29LV017B Erase CMD 3
+#define AMD_ERASE_CMD4    ((Hwd)0x55)     	// AMD29LV017B Erase CMD 4
+#define AMD_ERASE_CMD5    ((Hwd)0x10)     	// AMD29LV017B Erase CMD 5
+#define AMD_ERASE_DONE    ((Hwd)0xFFFF)     // AMD29LV017B Erase Done
+#define AMD_ERASE_BLK_CMD0	((Hwd)0xAA)
+#define AMD_ERASE_BLK_CMD1	((Hwd)0x55)
+#define AMD_ERASE_BLK_CMD2	((Hwd)0x80)
+#define AMD_ERASE_BLK_CMD3	((Hwd)0xAA)
+#define AMD_ERASE_BLK_CMD4	((Hwd)0x55)
+#define AMD_ERASE_BLK_CMD5	((Hwd)0x30)
+#define AMD_PROG_CMD0    ((Hwd)0xAA)
+#define AMD_PROG_CMD1    ((Hwd)0x55)
+#define AMD_PROG_CMD2    ((Hwd)0xA0)
+#define AMD2_ERASE_CMD0    ((Hwd)0x00AA)     // AMD29DL800B Erase CMD 0
+#define AMD2_ERASE_CMD1    ((Hwd)0x0055)     // AMD29DL800B Erase CMD 1
+#define AMD2_ERASE_CMD2    ((Hwd)0x0080)     // AMD29DL800B Erase CMD 2
+#define AMD2_ERASE_CMD3    ((Hwd)0x00AA)     // AMD29DL800B Erase CMD 3
+#define AMD2_ERASE_CMD4    ((Hwd)0x0055)     // AMD29DL800B Erase CMD 4
+#define AMD2_ERASE_CMD5    ((Hwd)0x0030)     // AMD29DL800B Erase CMD 5
+#define AMD2_ERASE_DONE    ((Hwd)0x00FF)     // AMD29DL800B Erase Done
+#define AMD_WRT_BUF_LOAD_CMD0           ((Hwd)0xAA)
+#define AMD_WRT_BUF_LOAD_CMD1           ((Hwd)0x55)
+#define AMD_WRT_BUF_LOAD_CMD2           ((Hwd)0x25)
+#define AMD_WRT_BUF_CONF_CMD0           ((Hwd)0x29)
+#define AMD_WRT_BUF_ABORT_RESET_CMD0    ((Hwd)0xAA)
+#define AMD_WRT_BUF_ABORT_RESET_CMD1    ((Hwd)0x55)
+#define AMD_WRT_BUF_ABORT_RESET_CMD2    ((Hwd)0xF0)
+// Flash Erase Commands INTEL
+#define INTEL_ERASE_CMD0   ((Hwd)0x0020)     // INTEL Erase CMD 0
+#define INTEL_ERASE_CMD1   ((Hwd)0x00D0)     // INTEL Erase CMD 1
+#define INTEL_ERASE_DONE   ((Hwd)0x0080)     // INTEL Erase Done
+#define INTEL_READ_MODE    ((Hwd)0x00FF)     // INTEL Read Array Mode
+#define STRATA_READ        0x4
+#define STRATA_WRITE       0x8
+// Flash Block Information
+// Intel Burst devices:
+//   2MB each (8 8KB [param] and 31 64KB [main] blocks each) for 8MB total
+#define NUM_INTEL_BURST_BLOCKS 8
+#define PARAM_SET0  0
+#define MAIN_SET0   1
+#define PARAM_SET1  2
+#define MAIN_SET1   3
+#define PARAM_SET2  4
+#define MAIN_SET2   5
+#define PARAM_SET3  6
+#define MAIN_SET3   7
+// Intel Strata devices:
+//   4MB each (32 128KB blocks each) for 8MB total
+//   8MB each (64 128KB blocks each) for 16MB total
+//  16MB each (128 128KB blocks each) for 32MB total
+#define NUM_INTEL_STRATA_BLOCKS 8
+#define BLOCK_SET0  0
+#define BLOCK_SET1  1
+#define BLOCK_SET2  2
+#define BLOCK_SET3  3
+#define BLOCK_SET4  4
+#define BLOCK_SET5  5
+#define BLOCK_SET6  6
+#define BLOCK_SET7  7
+// For AMD Flash
+#define NUM_AMD_SECTORS 8  // Only using the first 8 8-KB sections (64 KB Total)
+#define AMD_ADDRESS_CS_MASK		0xFE000000	//--AMD-- Set-up as 0xFE000000 per Jon Hunter (Ti)
+// Flash Types
+enum NORFlashType {
+	FLASH_NOT_FOUND,
+	FLASH_UNSUPPORTED,
+	FLASH_AMD_LV017_2MB,             	// (AMD AM29LV017B-80RFC/RE)
+	FLASH_AMD_DL800_1MB_BOTTOM,		  	// (AMD AM29DL800BB-70EC)
+	FLASH_AMD_DL800_1MB_TOP,			// (AMD AM29DL800BT-70EC)
+	FLASH_AMD_DL323_4MB_BOTTOM,		  	// (AMD AM29DL323CB-70EC)
+	FLASH_AMD_DL323_4MB_TOP,			// (AMD AM29DL323BT-70EC)
+	FLASH_AMD_LV160_2MB_BOTTOM,
+	FLASH_AMD_LV160_2MB_TOP,
+	FLASH_AMD_LV256M_32MB,             	// (AMD AM29LV256MH/L)
+	FLASH_INTEL_BURST_8MB_BOTTOM,	   	// (Intel DT28F80F3B-95)
+	FLASH_INTEL_BURST_8MB_TOP,		   	// (Intel DT28F80F3T-95)
+	FLASH_INTEL_BURST_16MB_BOTTOM,	   	// (Intel DT28F160F3B-95)
+	FLASH_INTEL_BURST_16MB_TOP,		   	// (Intel DT28F160F3T-95)
+	FLASH_INTEL_STRATA_J3_4MB,		   	// (Intel DT28F320J3A)
+	FLASH_INTEL_STRATA_J3_8MB,		   	// (Intel DT28F640J3A)
+	FLASH_INTEL_STRATA_J3_16MB,		   	// (Intel DT28F128J3A)
+	FLASH_FUJITSU_DL323_4MB_BOTTOM,    	// (Fujitsu DL323 Bottom
+	FLASH_INTEL_STRATA_K3_8MB,		   	// (Intel 28F64K3C115)
+	FLASH_INTEL_STRATA_K3_16MB,        	// (Intel 28F128K3C115)
+	FLASH_INTEL_STRATA_K3_32MB,        	// (Intel 28F256K3C115)
+	FLASH_INTEL_W18_16MB_TOP,    		// (Intel 28F128W18T) }
+	FLASH_INTEL_W18_16MB_BOTTOM,  		// (Intel 28F128W18B) }
+	FLASH_INTEL_L18_16MB_TOP,    		// (Intel 28F128L18T) }
+	FLASH_INTEL_L18_16MB_BOTTOM,  		// (Intel 28F128L18B) }
+	FLASH_INTEL_L18_32MB_TOP,    		// (Intel 28F256L18T) }
+	FLASH_INTEL_L18_32MB_BOTTOM,  		// (Intel 28F256L18B) }
+	FLASH_INTEL_K18_32MB_BOTTOM,  		// (Intel 28F256K18B) }
+	FLASH_MICRON_16MB_TOP,				// (Micron MT28F160C34 )
+	FLASH_SAMSUNG_16MB_TOP				// (Samsung K8S281ETA)
+};
+////NAND SUPPORT
+//
+enum NANDFlashType {
+	NANDFLASH_NOT_FOUND,
+	NANDFLASH_SAMSUNG_32x8_Q,             	// (Samsung K9F5608Q0B)
+	NANDFLASH_SAMSUNG_32x8_U,             	// (Samsung K9F5608U0B)
+	NANDFLASH_SAMSUNG_16x16_Q,             	// (Samsung K9F5616Q0B)
+	NANDFLASH_SAMSUNG_16x16_U,             	// (Samsung K9F5616U0B)
+	NANDFLASH_SAMSUNG_16x8_U				// (Samsung K9F1G08QOM)
+};
+// Samsung Manufacture Code
+#define SAMSUNG_MANUFACT_ID	0xEC
+// Samsung Nand Flash Device ID
+#define SAMSUNG_K9F5608Q0B	0x35
+#define SAMSUNG_K9F5608U0B	0x75
+#define SAMSUNG_K9F5616Q0B	0x45
+#define SAMSUNG_K9F5616U0B	0x55
+//  MACROS for NAND Flash support
+//  Flash Chip Capability
+#define NUM_BLOCKS                  0x800       //  32 MB On-board NAND flash.
+#define PAGE_SIZE                 	512
+#define SPARE_SIZE                  16
+#define PAGES_PER_BLOCK             32
+#define PAGE_TO_BLOCK(page)     	((page) >> 5 )
+#define BLOCK_TO_PAGE(block)      	((block)  << 5 )
+#define FILE_TO_PAGE_SIZE(fs) 		((fs / PAGE_SIZE) + ((fs % PAGE_SIZE) ? 1 : 0))
+//  For flash chip that is bigger than 32 MB, we need to have 4 step address
+#ifdef NAND_SIZE_GT_32MB
+#define NEED_EXT_ADDR               1
+#else
+#define NEED_EXT_ADDR               0
+#endif
+// Nand flash block status definitions.
+#define BLOCK_STATUS_UNKNOWN	0x01
+#define BLOCK_STATUS_BAD		0x02
+#define BLOCK_STATUS_READONLY	0x04
+#define BLOCK_STATUS_RESERVED   0x08
+#define BLOCK_RESERVED			0x01
+#define BLOCK_READONLY			0x02
+#define BADBLOCKMARK            0x00
+//  NAND Flash Command. This appears to be generic across all NAND flash chips
+#define CMD_READ                0x00        //  Read
+#define CMD_READ1               0x01        //  Read1
+#define CMD_READ2               0x50        //  Read2
+#define CMD_READID              0x90        //  ReadID
+#define CMD_WRITE               0x80        //  Write phase 1
+#define CMD_WRITE2              0x10        //  Write phase 2
+#define CMD_ERASE               0x60        //  Erase phase 1
+#define CMD_ERASE2              0xd0        //  Erase phase 2
+#define CMD_STATUS              0x70        //  Status read
+#define CMD_RESET               0xff        //  Reset
+//
+//Prototpyes
+//
+// NOR Flash Dependent Function Pointers
+void (*User_Hard_Reset_Flash)(void);
+void (*User_Soft_Reset_Flash)(unsigned long addr);
+void (*User_Flash_Erase_Block)(unsigned long addr);
+void (*User_Flash_Erase_All)(unsigned long addr);
+void (*User_Flash_Write_Entry)(void);
+int (*User_Flash_Write)(unsigned long *addr, unsigned short data);
+int (*User_Flash_Optimized_Write)(unsigned long *addr, unsigned short data[], unsigned long);
+void (*User_Flash_Write_Exit)(void);
+// Flash AMD Device Dependent Routines
+void AMD_Hard_Reset_Flash(void);
+void AMD_Soft_Reset_Flash(unsigned long);
+void AMD_Flash_Erase_Block(unsigned long);
+void AMD_Flash_Erase_All(unsigned long);
+int AMD_Flash_Write(unsigned long *, unsigned short);
+int AMD_Flash_Optimized_Write(unsigned long *addr, unsigned short data[], unsigned long length);
+void AMD_Write_Buf_Abort_Reset_Flash( unsigned long plAddress );
+// Flash Intel Device Dependent Routines
+void INTEL_Hard_Reset_Flash(void);
+void INTEL_Soft_Reset_Flash(unsigned long addr);
+void INTEL_Flash_Erase_Block(unsigned long);
+int INTEL_Flash_Write(unsigned long *addr, unsigned short data);
+int INTEL_Flash_Optimized_Write(unsigned long *addr, unsigned short data[], unsigned long length);
+
+//General Functions
+void Flash_Do_Nothing(void);
+
+#endif
+
+
diff -Nurd u-boot-1.2.0/board/dm700/lowlevel_init.S u-boot-1.2.0-leopard/board/dm700/lowlevel_init.S
--- u-boot-1.2.0/board/dm700/lowlevel_init.S	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm700/lowlevel_init.S	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,725 @@
+/*
+ * Board specific setup info for DavinciHD
+ *
+ * (C) Copyright 2003
+ * Texas Instruments, <www.ti.com>
+ * Kshitij Gupta <Kshitij@ti.com>
+ *
+ * Modified for OMAP 1610 H2 board by Nishant Kamat, Jan 2004
+ *
+ * Modified for OMAP 5912 OSK board by Rishi Bhattacharya, Apr 2004
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ * 
+ * Modified for DV-EVM board by Rishi Bhattacharya, Apr 2005
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * Modified for DV-EVM board by Swaminathan S, Nov 2005
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *	
+ * Modified for Davinci-HD EVM board by Suresh Rajashekara, Mar 2007
+ * See file CREDITS for a list of people who contributed to this project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+_TEXT_BASE:
+	.word	TEXT_BASE	/* SDRAM load address from config.mk */
+
+.global reset_cpu
+	
+reset_cpu:
+	bl reset_processor
+
+.globl lowlevel_init
+
+lowlevel_init:
+/* Go back if we are running from RAM or NAND. */
+/*	MOV pc,	lr */
+
+/* Disable all the interrupts
+   Interrupt occurance is still reflected in the appropriate FIQn and IRQn bit
+   regardless of EINT values.*/
+	MOV	r1, #0x00000000
+	LDR	r0, =EINT_ENABLE0 /* Interrupt enable register 0 */
+	STR	r1, [r0]
+	LDR	r0, =EINT_ENABLE1 /* Interrupt enable register 1 */
+	STR	r1, [r0]
+
+/* Put the GEM (DSP) in reset. */
+ 	LDR R8, PSC_GEM_FLAG_CLEAR
+	LDR R6, MDCTL_GEM	/* Module control register MDCTL1 (C64x+CPU)*/
+	LDR R7, [R6]
+	AND R7, R7, R8
+	STR R7, [R6]
+
+/* Enable the power domain transition command.
+   Cause the power domain state and module domain state to transition.*/
+	LDR R6, PTCMD_0 	/* Power domain transition command register */
+	LDR R7, [R6]
+	ORR R7, R7, #0x2
+	STR R7, [R6]
+
+checkStatClkStopGem:
+/* Check for transition completion (PTSTAT)
+   When all the state machines on the domanis are done the PTSTAT goes back to 0 */
+	LDR R6, PTSTAT_0	/* Power domain transition status register */
+	LDR R7, [R6]
+    	AND R7, R7, #0x2
+    	CMP R7, #0x0
+    	BNE checkStatClkStopGem
+
+checkGemStatClkStop:
+/* Check for GEM (DSP) reset completion */
+	LDR R6, MDSTAT_GEM	/* Module status register MDSTAT1 (C64x+CPU) */
+	LDR R7, [R6]
+    	AND R7, R7, #0x100
+    	CMP R7, #0x0
+    	BNE checkGemStatClkStop
+
+/* Do this for enabling a WDT initiated reset this is a workaround
+   for a chip bug.  Not required under normal situations */
+/* may be not required for DavinciHD as the comment says its a chip bug */
+/*	LDR R6, P1394
+	MOV R10, #0x0	
+	STR R10, [R6] */
+
+/*
+The code below is for a temporary speed path setting to put L1 & L2 in fast mode. 
+This work around is not needed for Si 2.0 but for now I suggest you ask the customer
+ to leave that code there. Register 0x01c42010 is an internal register.
+-- Loc
+*/
+
+/* Enable L1 & L2 memories in fast mode */
+/*	LDR R6, DFT_ENABLE
+	MOV R10, #0x1
+	STR R10, [R6]
+
+	LDR R6, MMARG_BRF0	
+	LDR R10, MMARG_BRF0_VAL
+	STR R10, [R6]
+
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x0		
+	STR R10, [R6]
+*/
+	
+
+/*  DDR2 PLL Initialization */
+/* -------------------------*/	
+	
+/* Select the clock mode depending on the value written in the boot table
+   by the run script. */
+	MOV R10, #0x0
+	LDR R6, PLL1_CTL   	/* PLL controller 1 operations control register */
+	LDR R7, PLL_CLKSRC_MASK
+	LDR R8, [R6]
+	AND R8, R8, R7		/* Reference clock selction = oscin_pi */
+	MOV R9, R10, LSL #0x8
+	ORR R8, R8, R9		
+	STR R8, [R6]
+
+/* Select the PLLEN source */
+	LDR R7, PLL_ENSRC_MASK
+	AND R8, R8, R7		/* PLLEN mux control source = pllen_pi */
+	STR R8, [R6]
+
+/* Bypass the PLL */
+	LDR R7, PLL_BYPASS_MASK
+	AND R8, R8, R7		/* Bypass mode. PreDiv, PLL, and PostDiv are
+				   bypassed. SYSCLK divided down directly from
+				   input reference clock refclk */
+	STR R8, [R6]
+	
+/* Wait for 4 cycles (?) of the slowest of the clocks CLKIN/OSCIN, pll_clkout, to make
+  sure the PLLEN mux switches properly to the bypass mode */
+	MOV R10, #0x20 
+WaitPPL2Loop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE WaitPPL2Loop	
+
+/* Reset the PLL */
+    	LDR R7, PLL_RESET_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+/* Power Up the PLL */
+    	LDR R7, PLL_PWRUP_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+/* PLL disable released. (PLL Enabled) */
+    	LDR R7, PLL_DISABLE_ENABLE_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+/* Program the PLL multiplier */
+	LDR R6, PLL1_PLLM	/* PLL1 multiplier control register */
+	MOV R2, #0x15 		/* 297MHz is the Max Frequency. Setting the
+		 		   multiplier as 22 and will set the divider as 2*/
+	STR R2, [R6]   		/* 27MHz * 22 =  594MHz */
+
+/* Program the PLL divisior value. */
+	LDR R6, PLL1_DIV1
+	MOV R4, #0x1 		/* 594/2 = 297MHz */
+	STR R4, [R6]    
+
+/* Enable the Divider */
+	LDR R8, PLL1_DIV_MASK
+	LDR R6, PLL1_DIV1
+	LDR R9, [R6]
+	AND R8, R8, R9
+	MOV R9, #0X1
+	MOV R9, R9, LSL #15
+	ORR R8, R8, R9
+	STR R8, [R6]
+
+/* Program the GOSET bit to take new divider values */
+	LDR R6, PLL1_PLLCMD	/* PLL Controller 1 command register */
+	LDR R7, [R6]
+	ORR R7, R7, #0x1
+	STR R7, [R6]
+
+/*  Wait for done */
+    	LDR R6, PLL1_PLLSTAT	/* PLL Controller 1 status register */
+doneLoop_0:    
+    	LDR R7, [R6]
+    	AND R7, R7, #0x1
+    	CMP R7, #0x0
+    	BNE doneLoop_0
+
+/* Wait for PLL to reset properly */
+	MOV R10, #0x218  
+ResetPPL2Loop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE ResetPPL2Loop
+
+/* Bring PLL out of reset */
+    	LDR R6, PLL1_CTL    	/* PLL controller 1 operations control register	*/
+    	LDR R8, [R6]
+    	ORR R8, R8, #0x08
+    	STR R8, [R6]
+     	
+/* Wait for PLL to lock */
+	LDR R10, PLL_LOCK_COUNT    
+PLL1Lock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE PLL1Lock
+
+/*  Enable the PLL */
+    	LDR R6, PLL1_CTL	/* PLL controller 1 operations control register */
+    	LDR R8, [R6]
+    	ORR R8, R8, #0x01
+    	STR R8, [R6]
+
+/* Issue soft reset to the DDR module */
+/* ---------------------------------- */	
+
+/*  Shutdown the DDR2 LPSC module. */
+  	LDR R8, PSC_FLAG_CLEAR
+	LDR R6, MDCTL_DDR2_0	/* MDCTL20, module control register for DDR2 EMIF */
+	LDR R7, [R6]
+	AND R7, R7, R8
+	ORR R7, R7, #0x3	/* Enable */
+	STR R7, [R6]  
+
+/* Enable the power domain transition command */
+	LDR R6, PTCMD_0
+	LDR R7, [R6]
+	ORR R7, R7, #0x1
+	STR R7, [R6]    
+
+/*  Check for transition completion (PTSTAT) */
+checkStatClkStop:	
+	LDR R6, PTSTAT_0
+	LDR R7, [R6]
+    	AND R7, R7, #0x1	
+    	CMP R7, #0x0
+    	BNE checkStatClkStop  
+
+/* Check for DDR2 controller enable completion. */
+checkDDRStatClkStop:	
+	LDR R6, MDSTAT_DDR2_0	/* MDSTAT20, Module status register for DDR2 EMIF */
+	LDR R7, [R6]
+    	AND R7, R7, #0x1F	
+    	CMP R7, #0x3
+    	BNE checkDDRStatClkStop  
+
+
+/* Program the DDR2 MMRs for 297MHz setting. */
+/* ----------------------------------------- */	
+
+/* Program the PHY control register */
+	LDR R6, DDRCTL
+	LDR R7, DDRCTL_VAL
+	STR R7, [R6]
+
+/* Program SDRAM bank config register */
+	LDR R6, SDCFG
+	LDR R7, SDCFG_VAL	/* For Davinci-HD 300MHz DDR-SDRAM */
+	STR R7, [R6]
+
+/* Program SDRAM timing control register */
+/* ------------------------------------- */	
+/* Program SDRAM TIM-0 config register */
+	LDR R6, SDTIM0
+	LDR R7, SDTIM0_VAL_297MHz
+	STR R7, [R6]		
+
+/* Program SDRAM TIM-1 config register */
+	LDR R6, SDTIM1
+	LDR R7, SDTIM1_VAL_297MHz
+	STR R7, [R6]		
+
+/* Program the SDRAM bank config register */
+	LDR R10, MASK_VAL
+	LDR R8, SDCFG
+	LDR R9, SDCFG_VAL
+	AND R9, R9, R10
+	STR R9, [R8]
+
+/* Program SDRAM refresh control register */
+/* CHECK: The PLL is configured to be at 297(SDREF_VAL = 2320.3125). Change
+   anyone of these. */
+	LDR R6, SDREF
+	LDR R7, SDREF_VAL	/* 7.8125 * 300 = 2343.75 => 2343 */
+	STR R7, [R6]
+	
+/* Issue a dummy DDR2 read/write */
+        LDR R8, DDR2_VAL
+        LDR R7, DUMMY_VAL
+        STR R7, [R8]
+        LDR R7, [R8]
+
+/* Shutdown the DDR LPSC module(??) */
+        LDR R8, PSC_FLAG_CLEAR
+        LDR R6, MDCTL_DDR2_0	/* MDCTL20, module control register for DDR2 EMIF */
+        LDR R7, [R6]
+        AND R7, R7, R8
+        ORR R7, R7, #0x1	/* SyncRst (Not Enable) */
+        STR R7, [R6]
+
+/* Enable the power domain transition command */
+        LDR R6, PTCMD_0
+        LDR R7, [R6]
+        ORR R7, R7, #0x1
+        STR R7, [R6]
+
+/* Check for transition complete (PTSTAT) */
+checkStatClkStop2:
+        LDR R6, PTSTAT_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1
+        CMP R7, #0x0
+        BNE checkStatClkStop2
+                                                                                
+/* Check for DDR2 controller enable completion */
+checkDDRStatClkStop2:
+        LDR R6, MDSTAT_DDR2_0	/* MDSTAT20, module status register for DDR2 EMIF */
+        LDR R7, [R6]
+        AND R7, R7, #0x1F
+        CMP R7, #0x1
+        BNE checkDDRStatClkStop2
+
+/* Turn DDR2 controller clocks on(??) */
+/* ----------------------------------- */	
+
+/* Enable the DDR2 LPSC module */
+        LDR R6, MDCTL_DDR2_0
+        LDR R7, [R6]
+        ORR R7, R7, #0x3
+        STR R7, [R6]
+
+/* Enable the power domain transition command. */
+        LDR R6, PTCMD_0
+        LDR R7, [R6]
+        ORR R7, R7, #0x1
+        STR R7, [R6]
+
+/* Check for transition completion (PTSTST) */
+checkStatClkEn2:
+        LDR R6, PTSTAT_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1
+        CMP R7, #0x0
+        BNE checkStatClkEn2
+
+/* Check for DDR controller enable completion. */
+checkDDRStatClkEn2:
+        LDR R6, MDSTAT_DDR2_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1F
+        CMP R7, #0x3
+        BNE checkDDRStatClkEn2
+
+/* DDR writes and reads (??) */
+        LDR R6, CFGTEST
+        MOV R3, #0x1
+        STR R3, [R6]   
+
+/* System PLL Initialization */
+/* ------------------------- */	
+
+/* Select the clock mode depending on the value written in the boot table by the
+   run script. */
+	MOV R2, #0x0
+	LDR R6, PLL0_CTL   	/* PLL controller 0 operations control register */
+	LDR R7, PLL_CLKSRC_MASK
+	LDR R8, [R6]
+	AND R8, R8, R7		/* Reference clock selction = oscin_pi */
+	MOV R9, R2, LSL #0x8
+	ORR R8, R8, R9
+	STR R8, [R6]
+
+/* Select the PLLEN source */
+	LDR R7, PLL_ENSRC_MASK
+	AND R8, R8, R7		/* PLLEN mux control source = pllen_pi */
+	STR R8, [R6]
+
+/* Bypass the PLL */
+	LDR R7, PLL_BYPASS_MASK
+	AND R8, R8, R7		/* Bypass mode. PreDiv, PLL, and PostDiv are
+				   bypassed. SYSCLK divided down directly from
+				   input reference clock refclk */
+	Str R8, [R6]		
+	
+/* Wait for 4 cycles (?) of the slowest of the clocks CLKIN/OSCIN, pll_clkout, to
+   make sure the PLLEN mux switches properly to the bypass mode */
+	MOV R10, #0x20 
+WaitLoop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE WaitLoop	
+
+/* Reset the PLL */
+    	LDR R7, PLL_RESET_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+/* Disable the PLL */
+    	ORR R8, R8, #0x10    
+    	STR R8, [R6]
+
+/* Power up the PLL */
+    	LDR R7, PLL_PWRUP_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+/* PLL disable released. (PLL Enabled) */
+    	LDR R7, PLL_DISABLE_ENABLE_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+/* Program the PLL multiplier */
+	LDR R6, PLL0_PLLM
+	MOV R3, #0x15 		/*  594 MHz(??) */
+	STR R3, [R6]      
+
+/* Wait for PLL to reset properly. */
+	MOV R10, #0xFF 
+ResetLoop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE ResetLoop
+
+/* Bring the PLL out of reset. */
+    	LDR R6, PLL0_CTL    	
+    	ORR R8, R8, #0x08
+    	STR R8, [R6]
+
+/* Wait for PLL to lock. */
+	LDR R10, PLL_LOCK_COUNT    
+PLL0Lock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE PLL0Lock
+
+/* Enable the PLL */
+    	ORR R8, R8, #0x01
+    	STR R8, [R6]
+
+	NOP
+	NOP	
+	NOP
+	NOP
+
+/* AEMIF configuration */
+/* ------------------- */
+/* AEMIF init is done for 16-bit interface. */
+	LDR R0, _PINMUX0	/* Pin muxing control register 0 */
+	LDR R1, _DEV_SETTING
+	STR R1, [R0]
+
+ 	LDR R0, WAITCFG   	/* Async wait cycle configuration register */
+	LDR R1, WAITCFG_VAL 
+	LDR R2, [R0]
+	ORR R2, R2, R1
+	STR R2, [R0]    
+
+	LDR R0, ACFG2		/* Async config register 2 */
+	LDR R1, ACFG2_VAL
+	STR R1, [R0]
+
+	LDR R0, ACFG3		/* Async config register 3 */
+	LDR R1, ACFG3_VAL
+	STR R1, [R0]
+
+	LDR R0, ACFG4		/* Async config register 4 */
+	LDR R1, ACFG4_VAL
+	STR R1, [R0]
+
+	LDR R0, ACFG5		/* Async config register 5 */
+	LDR R1, ACFG5_VAL
+	STR R1, [R0]     
+
+/* VTP Manual Calibration (??) */
+/* --------------------------- */
+	LDR R0, VTPIOCR
+	LDR R1, VTP_MMR0
+	STR R1, [R0]
+
+	LDR R0, VTPIOCR
+	LDR R1, VTP_MMR1
+	STR R1, [R0]
+
+/* Wait for 33 VTP clock cycles. VRP operates at 27 MHz */
+	LDR R10, VTP_LOCK_COUNT    
+VTPLock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE VTPLock
+
+	LDR R6, DFT_ENABLE	/* (??) */
+	MOV R10, #0x1
+	STR R10, [R6]
+
+	LDR R6, DDRVTPR
+	LDR R7, [R6]
+	AND R7, R7, #0x1F
+	AND R8, R7, #0x3E0
+	ORR R8, R7, R8
+	LDR R7, VTP_RECAL
+	ORR R8, R7, R8
+	LDR R7, VTP_EN
+	ORR R8, R7, R8
+	STR R8, [R0]
+
+/* Wait for 33 VTP clock cycles. VRP operates at 27 MHz */
+	LDR R10, VTP_LOCK_COUNT    
+VTP1Lock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE VTP1Lock
+
+	LDR R1, [R0]
+	LDR R2, VTP_MASK
+	AND R2, R1, R2
+	STR R2, [R0]
+
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x0
+	STR R10, [R6]
+
+/* Back to the arch calling code. */
+	MOV pc,	lr
+
+/* The literal pools origin */
+	.ltorg
+
+REG_TC_EMIFS_CONFIG:		/* 32 bits */
+	.word 0xfffecc0c
+REG_TC_EMIFS_CS0_CONFIG:	/* 32 bits */
+	.word 0xfffecc10
+REG_TC_EMIFS_CS1_CONFIG:	/* 32 bits */
+	.word 0xfffecc14
+REG_TC_EMIFS_CS2_CONFIG:	/* 32 bits */
+	.word 0xfffecc18
+REG_TC_EMIFS_CS3_CONFIG:	/* 32 bits */
+	.word 0xfffecc1c
+
+_PINMUX0:		.word 0x01C40000 /* Pin multiplexing control 0 */
+_PINMUX1:		.word 0x01C40004 /* Pin multiplexing control 1 */
+
+_DEV_SETTING:		.word 0x00000000 /* AEMIF Enabled (PCIEN=HPIEN=ATAEN=0) */
+
+AEMIF_BASE_ADDR:	.word 0x20008000
+WAITCFG:         	.word 0x20008004
+ACFG2:           	.word 0x20008010
+ACFG3:           	.word 0x20008014
+ACFG4:           	.word 0x20008018
+ACFG5:           	.word 0x2000801C
+
+WAITCFG_VAL:     	.word 0x0
+ACFG2_VAL:       	.word 0x1
+ACFG3_VAL:       	.word 0x1
+ACFG4_VAL:       	.word 0x1
+ACFG5_VAL:       	.word 0x1
+
+MDCTL_DDR2:		.word 0x01C41A34
+PTCMD:		.word 0x01C41120 /* Power domain transition command register */
+PTSTAT:		.word 0x01C41128 /* Power domain transition status register */
+MDSTAT_DDR2:	.word 0x01C41834
+
+MDCTL_TPCC:		.word	0x01C41A08
+MDSTAT_TPCC:	.word 0x01C41808
+
+MDCTL_TPTC0:	.word	0x01C41A0C
+MDSTAT_TPTC0:	.word 0x01C4180C
+
+MDCTL_TPTC1:	.word	0x01C41A10
+MDSTAT_TPTC1:	.word 0x01C41810
+
+DDR2DEBUG:		.word 0x8FFFF000
+
+/* EINT0 register */
+EINT_ENABLE0:
+	.word 0x01c48018
+
+/* EINT1 register */
+EINT_ENABLE1:
+	.word 0x01c4801C
+
+CLEAR_FLAG:				.word 0xFFFFFFFF
+EDMA_PARAM0_D_S_BIDX_VAL: 	.word 0x00010001
+PSC_FLAG_CLEAR:			.word 0xFFFFFFE0
+PSC_GEM_FLAG_CLEAR:			.word 0xFFFFFEFF
+MDCTL_TPCC_SYNC:			.word 0x01C41A08
+MDSTAT_TPCC_SYNC:			.word 0x01C41808
+
+MDCTL_TPTC0_SYNC:			.word 0x01C41A0C
+MDSTAT_TPTC0_SYNC:		.word 0x01C4180C
+
+MDCTL_TPTC1_SYNC:			.word 0x01C41A10
+MDSTAT_TPTC1_SYNC:		.word 0x01C41810
+
+PTCMD_SYNC:				.word 0x01C41120
+PTSTAT_SYNC:			.word 0x01C41128
+DATA_MAX:				.word 0x0000FFFF
+SPIN_ADDR:				.word 0x00003FFC   /* ARM PC value(B $) for the DSP Test cases */
+SPIN_OPCODE:			.word 0xEAFFFFFE
+
+/* Interrupt Clear Register */
+FIQ0_CLEAR:				.word 0x01C48000
+FIQ1_CLEAR:				.word 0x01C48004
+IRQ0_CLEAR:				.word 0x01C48008
+IRQ1_CLEAR:				.word 0x01C4800C
+
+/* DDR2 MMR & CONFIGURATION VALUES for 75 MHZ */
+DDRCTL:				.word	0x200000E4
+SDREF:				.word	0x2000000C
+SDCFG:				.word	0x20000008
+SDTIM0:				.word	0x20000010
+SDTIM1:				.word	0x20000014
+SDSTAT:				.word 0x20000004
+VTPIOCR:				.word 0x200000F0 /*VTP IO Control Register*/
+DDRVTPR:				.word 0x01C42030  /* DDR VPTR MMR */
+DFT_ENABLE:				.word 0x01C4004C
+VTP_MMR0:				.word 0x201F
+VTP_MMR1:				.word 0xA01F
+PCH_MASK:				.word 0x3E0
+VTP_LOCK_COUNT:				.word 0x5b0
+VTP_MASK:				.word 0xFFFFDFFF
+VTP_RECAL:				.word 0x40000
+VTP_EN:					.word 0x02000
+
+
+CFGTEST:				.word	0x80010000
+
+/* 162MHz as per GEL file for DVEVM with Micron DDR2 SDRAM */
+
+/*
+<SNIP>
+If you shift 0x140190 by 6 bits it becomes the u-boot write value of 0x5006405.
+</SNIP>
+But as per DS its 0x50006404	
+*/
+	
+DDRCTL_VAL:                     .word   0x50006404 /* ?? Originally 0x50006405 */
+SDREF_VAL:                      .word   0x00000927
+SDCFG_VAL:                      .word   0x00008832           /* CL=3 for MT47H64M16BT-5E */
+MASK_VAL:                       .word   0xFFFF7FFF
+SDTIM0_VAL_297MHz:              .word   0x4D243232
+SDTIM1_VAL_297MHz:              .word   0x0B29C742
+
+
+/* GEM Power Up & LPSC Control Register */
+CHP_SHRTSW:				.word 0x01C40038
+
+PD1_CTL:				.word	0x01C41304
+EPCPR:				.word	0x01C41070
+EPCCR:				.word	0x01C41078
+
+MDCTL_GEM:				.word	0x01C41A04 /* MDCTL1 (C64x+CPU)*/
+/* Davinci MDCTL_GEM - 0x01C41A9C*/
+MDSTAT_GEM:				.word 0x01C41804  /* MDSTAT1 (C64x+CPU)*/
+/* Davinvi MDSTAT_GEM - 0x1C4189C*/
+
+MDCTL_IMCOP:			.word	0x01C41AA0
+MDSTAT_IMCOP:			.word 0x01C418A0
+
+PTCMD_0:				.word 0x01C41120
+PTSTAT_0:				.word 0x01C41128
+P1394:					.word 0x01C41a20
+
+PLL_CLKSRC_MASK: 			.word 0xFFFFFEFF  /* Mask the Clock Mode bit and it is programmble through the run script */
+PLL_ENSRC_MASK:  			.word 0xFFFFFFDF  /* Select the PLLEN source */
+PLL_BYPASS_MASK: 			.word 0xFFFFFFFE  /* Put the PLL in BYPASS, eventhough the device */
+PLL_RESET_MASK:  			.word 0xFFFFFFF7  /* Put the PLL in Reset Mode */
+PLL_PWRUP_MASK:  			.word 0xFFFFFFFD  /* PLL Power up Mask Bit  */
+PLL_DISABLE_ENABLE_MASK:	.word 0xFFFFFFEF  /* Enable the PLL from Disable */
+PLL_LOCK_COUNT:          	.word 0x2000
+
+/* PLL0-SYSTEM PLL MMRs */
+PLL0_CTL:				.word 0x01C40900 
+PLL0_PLLM:				.word 0x01C40910
+
+/* PLL1-SYSTEM PLL MMRs */
+PLL1_CTL:				.word 0x01C40D00 
+PLL1_PLLM:				.word 0x01C40D10
+PLL1_DIV2:				.word 0x01C40D1C
+PLL1_DIV1:				.word 0x01C40D18
+PLL1_PLLCMD:			.word 0x01C40D38
+PLL1_PLLSTAT:			.word 0x01C40D3C	
+PLL1_BPDIV:				.word 0x01C40D2C
+PLL1_DIV_MASK:			.word 0xFFFF7FFF
+
+
+MDCTL_DDR2_0:			.word 0x01C41A50
+MDSTAT_DDR2_0:			.word 0x01C41850
+DLLPWRUPMASK:			.word 0xFFFFFFEF
+DDR2_ADDR:			.word 0x80000000
+
+DFT_BASEADDR:			.word 0x01C42000
+MMARG_BRF0:			.word 0x01C42010     /* BRF margin mode 0     (Read / write)*/
+MMARG_G10:			.word 0x01C42018     /*GL margin mode 0      (Read / write)*/
+MMARG_BRF0_VAL:			.word 0x00444400
+DDR2_VAL:			.word 0x80000000
+DUMMY_VAL:			.word 0xA55AA55A
+
+/* command values */
+.equ CMD_SDRAM_NOP,		0x00000000
+.equ CMD_SDRAM_PRECHARGE,	0x00000001
+.equ CMD_SDRAM_AUTOREFRESH,	0x00000002
+.equ CMD_SDRAM_CKE_SET_HIGH,	0x00000007
diff -Nurd u-boot-1.2.0/board/dm700/nand.c u-boot-1.2.0-leopard/board/dm700/nand.c
--- u-boot-1.2.0/board/dm700/nand.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm700/nand.c	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,111 @@
+/*
+ * NAND driver for TI DaVinci based boards.
+ *
+ * Copyright (C) 2007 Sergey Kubushyn <ksi@koi8.net>
+ *
+ * Based on Linux DaVinci NAND driver by TI. Original copyright follows:
+ */
+
+/*
+ *
+ * linux/drivers/mtd/nand/nand_davinci.c
+ *
+ * NAND Flash Driver
+ *
+ * Copyright (C) 2006 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ *
+ *  Overview:
+ *   This is a device driver for the NAND flash device found on the
+ *   DaVinci board which utilizes the Samsung k9k2g08 part.
+ *
+ Modifications:
+ ver. 1.0: Feb 2005, Vinod/Sudhakar
+ -
+ *
+ */
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+#if !defined(CFG_NAND_LEGACY)
+
+#include "soc.h"
+#include <nand.h>
+#include <asm/arch/nand_defs.h>
+#include <asm/arch/emif_defs.h>
+
+extern struct nand_chip nand_dev_desc[CFG_MAX_NAND_DEVICE];
+
+static void nand_davinci_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+	struct		nand_chip *this = mtd->priv;
+	u_int32_t	IO_ADDR_W = (u_int32_t)this->IO_ADDR_W;
+
+	IO_ADDR_W &= ~(MASK_ALE|MASK_CLE);
+
+	switch (cmd) {
+		case NAND_CTL_SETCLE:
+			IO_ADDR_W |= MASK_CLE;
+			break;
+		case NAND_CTL_SETALE:
+			IO_ADDR_W |= MASK_ALE;
+			break;
+	}
+
+	this->IO_ADDR_W = (void *)IO_ADDR_W;
+}
+
+static int nand_davinci_dev_ready(struct mtd_info *mtd)
+{
+	emifregs	emif_addr;
+
+	emif_addr = (emifregs)CSL_EMIF_1_REGS;
+
+	return(emif_addr->NANDFSR & 0x1);
+}
+
+static int nand_davinci_waitfunc(struct mtd_info *mtd, struct nand_chip *this, int state)
+{
+	while(!nand_davinci_dev_ready(mtd)) {;}
+	*NAND_CE0CLE = NAND_STATUS;
+	return(*NAND_CE0DATA);
+}
+
+int board_nand_init(struct nand_chip *nand)
+{
+	nand->IO_ADDR_R   = (void  __iomem *)NAND_CE0DATA;
+	nand->IO_ADDR_W   = (void  __iomem *)NAND_CE0DATA;
+	nand->chip_delay  = 0;
+	nand->options     = 0;
+	nand->eccmode     = NAND_ECC_SOFT;
+
+	/* Set address of hardware control function */
+	nand->hwcontrol = nand_davinci_hwcontrol;
+
+	nand->dev_ready = nand_davinci_dev_ready;
+	nand->waitfunc = nand_davinci_waitfunc;
+
+	return 0;
+}
+
+#else
+#error "U-Boot legacy NAND support not available for DaVinci chips"
+#endif
+#endif	/* CFG_USE_NAND */
diff -Nurd u-boot-1.2.0/board/dm700/soc.h u-boot-1.2.0-leopard/board/dm700/soc.h
--- u-boot-1.2.0/board/dm700/soc.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm700/soc.h	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,349 @@
+/*
+ *
+ *  Copyright (C) 2004 Texas Instruments.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ * Modifications:
+ * ver. 1.0: Oct 2005, Swaminathan S
+ *
+ */
+
+#ifndef _SOC_H
+#define _SOC_H
+
+#include <asm/arch/types.h>
+
+#define CSL_IDEF_INLINE static inline
+/*****************************************************************************\
+* Peripheral Instance counts
+\*****************************************************************************/
+
+#define CSL_UART_CNT                 3
+#define CSL_I2C_CNT                  1
+#define CSL_TMR_CNT                  4
+#define CSL_WDT_CNT                  1
+#define CSL_PWM_CNT                  2 /* ?? */
+#define CSL_PLLC_CNT                 2
+#define CSL_PWR_SLEEP_CTRL_CNT       1
+#define CSL_SYS_DFT_CNT              1
+#define CSL_INTC_CNT                 1
+#define CSL_IEEE1394_CNT             1 /* ?? */
+#define CSL_USBOTG_CNT               1
+#define CSL_ATA_CNT                  1
+#define CSL_SPI_CNT                  1
+#define CSL_GPIO_CNT                 1
+#define CSL_UHPI_CNT                 1
+#define CSL_VPSS_REGS_CNT            1 /* ?? */
+#define CSL_EMAC_CTRL_CNT            1
+#define CSL_EMAC_WRAP_CNT            1
+#define CSL_EMAC_RAM_CNT             1
+#define CSL_MDIO_CNT                 1
+#define CSL_EMIF_CNT                 1
+#define CSL_NAND_CNT                 1
+#define CSL_MCASP_CNT                2 /* ?? */
+//#define CSL_MMCSD_CNT                1 /* ?? */
+#define CSL_MS_CNT                   1 /* ?? */
+#define CSL_DDR_CNT                  1
+#define CSL_VLYNQ_CNT                1
+#define CSL_PMX_CNT                  1 /* ?? */
+
+/*****************************************************************************\
+* Peripheral Instance enumeration
+\*****************************************************************************/
+
+/** @brief Peripheral Instance for UART  */
+#define CSL_UART_1                          (0) /** Instance 1 of UART   */
+
+/** @brief Peripheral Instance for UART  */
+#define CSL_UART_2                          (1) /** Instance 2 of UART   */
+
+/** @brief Peripheral Instance for UART  */
+#define CSL_UART_3                          (2) /** Instance 3 of UART   */
+
+/** @brief Peripheral Instance for I2C   */
+#define CSL_I2C                             (0) /** Instance 1 of I2C    */
+
+/** @brief Peripheral Instance for Tmr0  */
+#define CSL_TMR_1                           (0) /** Instance 1 of Tmr    */
+
+/** @brief Peripheral Instance for Tmr1  */
+#define CSL_TMR_2                           (1) /** Instance 2 of Tmr    */
+
+/** @brief Peripheral Instance for Tmr2  */
+#define CSL_TMR_3                           (2) /** Instance 3 of Tmr    */
+
+/** @brief Peripheral Instance for Tmr3  */
+#define CSL_TMR_4                           (3) /** Instance 4 of Tmr    */
+
+/** @brief Peripheral Instance for WDT   */
+#define CSL_WDT                             (0) /** Instance of WDT      */
+
+/** @brief Peripheral Instance for PWM   */
+#define CSL_PWM_1                           (0) /** Instance 1 of PWM    */
+
+/** @brief Peripheral Instance for PWM   */
+#define CSL_PWM_2                           (1) /** Instance 2 of PWM    */
+
+/** @brief Peripheral Instance for PWM   */
+//#define CSL_PWM_3                           (2) /** Instance 3 of PWM    */
+/* ?? */
+
+/** @brief Peripheral Instance for PLLC  */
+#define CSL_PLLC_1                          (0) /** Instance 1 of PLLC   */
+
+/** @brief Peripheral Instance for PLLC  */
+#define CSL_PLLC_2                          (1) /** Instance 2 of PLLC   */
+
+/** @brief Peripheral Instance for CSL_PWR_SLEEP_CTRL  */
+#define CSL_PWR_SLEEP_CTRL                  (0) /** Instance 1 of PWR_SLEEP_CTRL    */
+
+/** @brief Peripheral Instance for SYS_DFT  */
+#define CSL_SYS_DFT                         (0) /** Instance 1 of SYS_DFT*/
+
+/** @brief Peripheral Instance for INTC   */
+#define CSL_INTC                            (0) /** Instance 1 of INTC   */
+
+/** @brief Peripheral Instance for IEEE 1394  */
+#define CSL_IEEE1394                       (0) /** Instance 1 of IEEE 1394
+						* */
+/* ?? */
+
+/** @brief Peripheral Instance for USBOTG  */
+#define CSL_USBOTG                          (0) /** Instance 1 of USBOTG */
+
+/** @brief Peripheral Instance for ATA   */
+#define CSL_ATA_PRIMARY                     (0) /** Instance 1 of ATA    */
+
+/** @brief Peripheral Instance for ATA   */
+#define CSL_ATA_SECONDARY                   (1) /** Instance 2 of ATA    */
+
+/** @brief Peripheral Instance for SPI   */
+#define CSL_SPI                             (0) /** Instance 1 of SPI    */
+
+/** @brief Peripheral Instance for GPIO  */
+#define CSL_GPIO                            (0) /** Instance 1 of GPIO   */
+
+/** @brief Peripheral Instance for UHPI  */
+#define CSL_UHPI                            (0) /** Instance 1 of UHPI   */
+
+/** @brief Peripheral Instance for VPSS_REGS  */
+#define CSL_VPSS_REGS                       (0) /** Instance 1 of VPSS_REGS     */
+/* ?? */
+
+/** @brief Peripheral Instance for EMAC_CTRL  */
+#define CSL_EMAC_CTRL                       (0) /** Instance 1 of EMAC_CTRL     */
+
+/** @brief Peripheral Instance for EMAC_WRAP  */
+#define CSL_EMAC_WRAP                       (0) /** Instance 1 of EMAC_WRAP     */
+
+/** @brief Peripheral Instance for EMAC_RAM  */
+#define CSL_EMAC_RAM                        (0) /** Instance 1 of EMAC_RAM      */
+
+/** @brief Peripheral Instance for MDIO  */
+#define CSL_MDIO                            (0) /** Instance 1 of MDIO   */
+
+/** @brief Peripheral Instance for EMIF  */
+#define CSL_EMIF                            (0) /** Instance 1 of EMIF   */
+
+/** @brief Peripheral Instance for NAND  */
+#define CSL_NAND                            (0) /** Instance 1 of NAND   */
+
+/** @brief Peripheral Instance for MCASP */
+#define CSL_MCASP_1                           (0) /** Instance 1 of MCASP  */
+/* ?? */
+
+/** @brief Peripheral Instance for MCASP */
+#define CSL_MCASP_2                           (1) /** Instance 2 of MCASP  */
+/* ?? */
+
+/** @brief Peripheral Instance for MMCSD */
+//#define CSL_MMCSD                           (0) /** Instance 1 of MMCSD  */
+/* ?? */
+
+/** @brief Peripheral Instance for MS    */
+#define CSL_MS                              (0) /** Instance 1 of MS     */
+/* ?? */
+
+/** @brief Peripheral Instance for DDR    */
+#define CSL_DDR                             (0) /** Instance 1 of DDR    */
+
+/** @brief Peripheral Instance for VLYNQ */
+#define CSL_VLYNQ                           (0) /** Instance 1 of VLYNQ  */
+
+/** @brief Peripheral Instance for PMX */
+#define CSL_PMX                             (0) /** Instance 1 of PMX    */
+/* ?? */
+/*****************************************************************************\
+* Peripheral Base Address
+\*****************************************************************************/
+
+#define CSL_UART_1_REGS                  (0x01C20000)
+#define CSL_UART_2_REGS                  (0x01C20400)
+#define CSL_UART_3_REGS                  (0x01C20800)
+#define CSL_I2C_1_REGS                   (0x01C21000)
+#define CSL_TMR_1_REGS                   (0x01C21400)
+#define CSL_TMR_2_REGS                   (0x01C21400)
+#define CSL_TMR_3_REGS                   (0x01C21800)
+#define CSL_TMR_4_REGS                   (0x01C21800)
+#define CSL_WDT_1_REGS                   (0x01C21C00)
+#define CSL_PWM_1_REGS                   (0x01C22000)
+#define CSL_PWM_2_REGS                   (0x01C22400)
+//#define CSL_PWM_3_REGS                   (0x01C22800)
+#define CSL_PLLC_1_REGS                  (0x01C40800)
+#define CSL_PLLC_2_REGS                  (0x01C40C00)
+#define CSL_PWR_SLEEP_CTRL_1_REGS        (0x01C41000)
+#define CSL_SYS_DFT_1_REGS               (0x01C42000)
+#define CSL_INTC1_REGS                   (0x01C48000)
+#define CSL_IEEE1394_1_REGS              (0x01C60000) /* ?? */
+#define CSL_USBOTG_1_REGS                (0x01C64000)
+#define CSL_ATA_1_REGS                   (0x01C66000)
+#define CSL_SPI_1_REGS                   (0x01C66800)
+#define CSL_GPIO_1_REGS                  (0x01C67000)
+#define CSL_UHPI_1_REGS                  (0x01C67800)
+#define CSL_VPSS_REGS_1_REGS             (0x01C70000) /* ?? */
+#define CSL_EMAC_CTRL_1_REGS             (0x01C80000)
+#define CSL_EMAC_WRAP_1_REGS             (0x01C81000)
+#define CSL_EMAC_RAM_1_REGS              (0x01C82000)
+#define CSL_MDIO_1_REGS                  (0x01C84000)
+#define CSL_EMIF_1_REGS                  (0x20008000) 
+#define CSL_NAND_1_REGS                  (0x20008000) 
+#define CSL_MCASP_1_REGS                 (0x01D10000) /* ?? */
+#define CSL_MCASP_2_REGS                 (0x01D11800)
+#define CSL_DDR_1_REGS                   (0x20000000)
+#define CSL_VLYNQ_1_REGS                 (0x20010000)
+
+/* Added for EDMA  */
+/** @brief Base address of Channel controller  memory mapped registers */
+#define CSL_EDMACC_1_REGS                 (0x01C00000u)
+#define CSL_EDMA_1                         0
+
+
+/*****************************************************************************\
+* Interrupt/Exception Counts
+\*****************************************************************************/
+
+#define _CSL_INTC_EVENTID__INTC0CNT     (8)      /* ARM exception count     */
+#define _CSL_INTC_EVENTID__INTC1CNT     (64)     /* Level-1 Interrupt count */
+
+/**
+ * @brief   Count of the number of interrupt-events
+ */
+#define CSL_INTC_EVENTID_CNT        \
+    (_CSL_INTC_EVENTID__INTC0CNT + _CSL_INTC_EVENTID__INTC1CNT)
+
+/*****************************************************************************\
+* Interrupt Event IDs
+\*****************************************************************************/
+
+#define   _CSL_INTC_EVENTID__SPURIOUS         (0)
+#define   _CSL_INTC_EVENTID__INTC1START       (0)
+
+#define   CSL_INTC_EVENTID_VD0           (_CSL_INTC_EVENTID__INTC1START + 0)  /**< VPSS - CCDC  ??  */
+#define   CSL_INTC_EVENTID_VD1           (_CSL_INTC_EVENTID__INTC1START + 1)  /**< VPSS - CCDC  ??  */
+#define   CSL_INTC_EVENTID_VD2           (_CSL_INTC_EVENTID__INTC1START + 2)  /**< VPSS - CCDC  ??  */
+#define   CSL_INTC_EVENTID_HIST          (_CSL_INTC_EVENTID__INTC1START + 3)  /**< VPSS - Histogram */
+/* ?? */
+#define   CSL_INTC_EVENTID_H3A           (_CSL_INTC_EVENTID__INTC1START + 4)  /**< VPSS - AE/AWB/AF */
+/* ?? */
+#define   CSL_INTC_EVENTID_PRVU          (_CSL_INTC_EVENTID__INTC1START + 5)  /**< VPSS - Previewer */
+/* ?? */
+#define   CSL_INTC_EVENTID_RSZ           (_CSL_INTC_EVENTID__INTC1START + 6)  /**< VPSS - Resizer   */
+/* ?? */
+#define   CSL_INTC_EVENTID_VFOC          (_CSL_INTC_EVENTID__INTC1START + 7)  /**< VPSS - Focus     */
+/* ?? */
+#define   CSL_INTC_EVENTID_VENC          (_CSL_INTC_EVENTID__INTC1START + 8)  /**< VPSS - VPBE      */
+/* ?? */
+#define   CSL_INTC_EVENTID_ASQ           (_CSL_INTC_EVENTID__INTC1START + 9)  /**< IMCOP - Sqr      */
+#define   CSL_INTC_EVENTID_IMX           (_CSL_INTC_EVENTID__INTC1START + 10) /**< IMCOP - iMX      */
+#define   CSL_INTC_EVENTID_VLCD          (_CSL_INTC_EVENTID__INTC1START + 11) /**< IMCOP - VLCD     */
+#define   CSL_INTC_EVENTID_USBC          (_CSL_INTC_EVENTID__INTC1START + 12) /**< USB OTG Collector*/
+#define   CSL_INTC_EVENTID_EMAC          (_CSL_INTC_EVENTID__INTC1START + 13) /**< CPGMAC Wrapper   */
+#define   CSL_INTC_EVENTID_1394          (_CSL_INTC_EVENTID__INTC1START + 14) /**< IEEE1394    ??   */
+#define   CSL_INTC_EVENTID_1394WK        (_CSL_INTC_EVENTID__INTC1START + 15) /**< IEEE1394    ??   */
+#define   CSL_INTC_EVENTID_CC0           (_CSL_INTC_EVENTID__INTC1START + 16) /**< 3PCC Region 0    */
+#define   CSL_INTC_EVENTID_CCERR         (_CSL_INTC_EVENTID__INTC1START + 17) /**< 3PCC Error       */
+#define   CSL_INTC_EVENTID_TCERR0        (_CSL_INTC_EVENTID__INTC1START + 18) /**< 3PTC0 Error      */
+#define   CSL_INTC_EVENTID_TCERR1        (_CSL_INTC_EVENTID__INTC1START + 19) /**< 3PTC1 Error      */
+#define   CSL_INTC_EVENTID_PSCINT        (_CSL_INTC_EVENTID__INTC1START + 20) /**< PSC - ALLINT     */
+#define   CSL_INTC_EVENTID_RSVD21        (_CSL_INTC_EVENTID__INTC1START + 21) /**< Reserved         */
+#define   CSL_INTC_EVENTID_ATA           (_CSL_INTC_EVENTID__INTC1START + 22) /**< ATA/IDE          */
+#define   CSL_INTC_EVENTID_HPIINT        (_CSL_INTC_EVENTID__INTC1START + 23) /**< UHPI             */
+#define   CSL_INTC_EVENTID_MBX           (_CSL_INTC_EVENTID__INTC1START + 24) /**< McASP ??         */
+#define   CSL_INTC_EVENTID_MBR           (_CSL_INTC_EVENTID__INTC1START + 25) /**< McASP ??         */
+//#define   CSL_INTC_EVENTID_MMCSD         (_CSL_INTC_EVENTID__INTC1START + 26) /**< MMC/SD  ??       */
+//#define   CSL_INTC_EVENTID_SDIO          (_CSL_INTC_EVENTID__INTC1START + 27) /**< MMC/SD  ??       */
+#define   CSL_INTC_EVENTID_MS            (_CSL_INTC_EVENTID__INTC1START + 28) /**< Memory Stick  ?? */
+#define   CSL_INTC_EVENTID_DDR           (_CSL_INTC_EVENTID__INTC1START + 29) /**< DDR EMIF         */
+#define   CSL_INTC_EVENTID_EMIF          (_CSL_INTC_EVENTID__INTC1START + 30) /**< Async EMIF       */
+#define   CSL_INTC_EVENTID_VLQ           (_CSL_INTC_EVENTID__INTC1START + 31) /**< VLYNQ            */
+#define   CSL_INTC_EVENTID_TIMER0INT12   (_CSL_INTC_EVENTID__INTC1START + 32) /**< Timer 0 - TINT12 */
+#define   CSL_INTC_EVENTID_TIMER0INT34   (_CSL_INTC_EVENTID__INTC1START + 33) /**< Timer 0 - TINT34 */
+#define   CSL_INTC_EVENTID_TIMER1INT12   (_CSL_INTC_EVENTID__INTC1START + 34) /**< Timer 1 - TINT12 */
+#define   CSL_INTC_EVENTID_TIMER1INT34   (_CSL_INTC_EVENTID__INTC1START + 35) /**< Timer 2 - TINT34 */
+#define   CSL_INTC_EVENTID_PWM0          (_CSL_INTC_EVENTID__INTC1START + 36) /**< PWM0             */
+#define   CSL_INTC_EVENTID_PWM1          (_CSL_INTC_EVENTID__INTC1START + 37) /**< PWM1             */
+//#define   CSL_INTC_EVENTID_PWM2          (_CSL_INTC_EVENTID__INTC1START + 38) /**< PWM2    ??     */
+#define   CSL_INTC_EVENTID_I2C           (_CSL_INTC_EVENTID__INTC1START + 39) /**< I2C              */
+#define   CSL_INTC_EVENTID_UART0         (_CSL_INTC_EVENTID__INTC1START + 40) /**< UART0            */
+#define   CSL_INTC_EVENTID_UART1         (_CSL_INTC_EVENTID__INTC1START + 41) /**< UART1            */
+#define   CSL_INTC_EVENTID_UART2         (_CSL_INTC_EVENTID__INTC1START + 42) /**< UART2            */
+#define   CSL_INTC_EVENTID_SPI0          (_CSL_INTC_EVENTID__INTC1START + 43) /**< SPI              */
+#define   CSL_INTC_EVENTID_SPI1          (_CSL_INTC_EVENTID__INTC1START + 44) /**< SPI              */
+#define   CSL_INTC_EVENTID_WDT           (_CSL_INTC_EVENTID__INTC1START + 45) /**< Timer 3 - TINT12 */
+#define   CSL_INTC_EVENTID_DSP0          (_CSL_INTC_EVENTID__INTC1START + 46) /**< DSP Controller   */
+#define   CSL_INTC_EVENTID_DSP1          (_CSL_INTC_EVENTID__INTC1START + 47) /**< DSP Controller   */
+#define   CSL_INTC_EVENTID_GPIO0         (_CSL_INTC_EVENTID__INTC1START + 48) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIO1         (_CSL_INTC_EVENTID__INTC1START + 49) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIO2         (_CSL_INTC_EVENTID__INTC1START + 50) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIO3         (_CSL_INTC_EVENTID__INTC1START + 51) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIO4         (_CSL_INTC_EVENTID__INTC1START + 52) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIO5         (_CSL_INTC_EVENTID__INTC1START + 53) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIO6         (_CSL_INTC_EVENTID__INTC1START + 54) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIO7         (_CSL_INTC_EVENTID__INTC1START + 55) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIOBNK0      (_CSL_INTC_EVENTID__INTC1START + 56) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIOBNK1      (_CSL_INTC_EVENTID__INTC1START + 57) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIOBNK2      (_CSL_INTC_EVENTID__INTC1START + 58) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIOBNK3      (_CSL_INTC_EVENTID__INTC1START + 59) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIOBNK4      (_CSL_INTC_EVENTID__INTC1START + 60) /**< GPIO             */
+#define   CSL_INTC_EVENTID_COMMTX        (_CSL_INTC_EVENTID__INTC1START + 61) /**< ARMSS            */
+#define   CSL_INTC_EVENTID_COMMRX        (_CSL_INTC_EVENTID__INTC1START + 62) /**< ARMSS            */
+#define   CSL_INTC_EVENTID_EMU           (_CSL_INTC_EVENTID__INTC1START + 63) /**< E2ICE            */
+
+#define   _CSL_INTC_EVENTID__INTC1END    (_CSL_INTC_EVENTID__INTC1START + _CSL_INTC_EVENTID__INTC1CNT - 1)
+
+
+#define    _CSL_INTC_EVENTID__INTC0START (_CSL_INTC_EVENTID__INTC1END + 1)
+
+#define    CSL_INTC_EVENTID_RESET        (_CSL_INTC_EVENTID__INTC0START + 0)  /**< the RESET exception vector   */
+#define    CSL_INTC_EVENTID_UNDEF        (_CSL_INTC_EVENTID__INTC0START + 1)  /**< the UNDEF exception vector   */
+#define    CSL_INTC_EVENTID_SWI          (_CSL_INTC_EVENTID__INTC0START + 2)  /**< the SWI exception vector     */
+#define    CSL_INTC_EVENTID_PREABT       (_CSL_INTC_EVENTID__INTC0START + 3)  /**< the PREABT exception vector  */
+#define    CSL_INTC_EVENTID_DATABT       (_CSL_INTC_EVENTID__INTC0START + 4)  /**< the DATABT exception vector  */
+#define    CSL_INTC_EVENTID_IRQ          (_CSL_INTC_EVENTID__INTC0START + 6)  /**< the IRQ exception vector     */
+#define    CSL_INTC_EVENTID_FIQ          (_CSL_INTC_EVENTID__INTC0START + 7)  /**< the FIQ exception vector     */
+
+#define    _CSL_INTC_EVENTID__INTC0END   (_CSL_INTC_EVENTID__INTC0START + _CSL_INTC_EVENTID__INTC0CNT - 1)
+
+#define    CSL_INTC_EVENTID_INVALID      (-1)                                 /**< Invalid Event-ID */
+
+#endif
diff -Nurd u-boot-1.2.0/board/dm700/timer.c u-boot-1.2.0-leopard/board/dm700/timer.c
--- u-boot-1.2.0/board/dm700/timer.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm700/timer.c	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,73 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ Modifications:
+ ver. 1.0: Oct 2005, Swaminathan S
+ *
+ */
+
+#include "soc.h"
+#include "timer.h"
+
+/* Use Timer 3&4 (Timer 2) */
+#define TIMER_BASE_ADDR	CSL_TMR_1_REGS
+
+davinci_timer_reg    *davinci_timer = (davinci_timer_reg *) TIMER_BASE_ADDR;
+
+/* Timer Initialize */
+void inittimer(void)
+{
+        /* disable Timer 1 & 2 timers */
+        davinci_timer->tcr = 0;
+
+        /* Set timers to unchained dual 32 bit timers, Unreset timer34 */
+        davinci_timer->tgcr = 0x0;
+        davinci_timer->tgcr = 0x6;
+
+        /* Program the timer12 counter register - set the prd12 for right count */
+        davinci_timer->tim34 = 0;
+
+        /* The timer is programmed to expire after 0xFFFFFFFF ticks */
+        davinci_timer->prd34 = 0xFFFFFFFF;
+
+        /* Enable timer34 */
+        davinci_timer->tcr = (0x80 << 16); /* Timer34 continously enabled, Timer12 disabled */
+}
+
+/************************************************************
+********************** Reset Processor **********************
+************************************************************/
+#define WDT_BASE_ADDR          CSL_WDT_1_REGS
+
+
+void reset_processor(void)
+{
+        davinci_timer_reg *davinci_wdt = (davinci_timer_reg *) WDT_BASE_ADDR;
+        davinci_wdt->tgcr   = 0x00000008;
+        davinci_wdt->tgcr  |= 0x00000003;
+        davinci_wdt->tim12  = 0x00000000;
+        davinci_wdt->tim34  = 0x00000000;
+        davinci_wdt->prd12  = 0x00000000;
+        davinci_wdt->prd34  = 0x00000000;
+        davinci_wdt->tcr   |= 0x00000040;
+        davinci_wdt->wdtcr |= 0x00004000;
+        davinci_wdt->wdtcr  = 0xA5C64000;
+        davinci_wdt->wdtcr  = 0xDA7E4000;
+}
diff -Nurd u-boot-1.2.0/board/dm700/timer.h u-boot-1.2.0-leopard/board/dm700/timer.h
--- u-boot-1.2.0/board/dm700/timer.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm700/timer.h	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,51 @@
+/*
+ *
+ *  Copyright (C) 2004 Texas Instruments.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ * Modifications:
+ * ver. 1.0: Oct 2005, Swaminathan S
+ *
+ */
+#ifndef __TIMER_H__
+#define __TIMER_H__
+
+typedef volatile struct davinci_timer_reg_t
+{
+    unsigned int pid12;         /* 0x0 */
+    unsigned int emumgt_clksped;/* 0x4 */
+    unsigned int gpint_en;      /* 0x8 */
+    unsigned int gpdir_dat;     /* 0xC */
+    unsigned int tim12;         /* 0x10 */
+    unsigned int tim34;         /* 0x14 */
+    unsigned int prd12;         /* 0x18 */
+    unsigned int prd34;         /* 0x1C */
+    unsigned int tcr;           /* 0x20 */
+    unsigned int tgcr;          /* 0x24 */
+    unsigned int wdtcr;         /* 0x28 */
+    unsigned int tlgc;          /* 0x2C */
+    unsigned int tlmr;          /* 0x30 */
+} davinci_timer_reg;
+
+#endif  /* __TIMER_H__ */
+
diff -Nurd u-boot-1.2.0/board/dm700/types.h u-boot-1.2.0-leopard/board/dm700/types.h
--- u-boot-1.2.0/board/dm700/types.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm700/types.h	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,46 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ *
+ */
+#ifndef _TYPESH_
+#define _TYPESH_
+
+typedef unsigned long 	ULONG;
+typedef unsigned short 	USHORT;
+typedef unsigned long   BOOL;
+typedef unsigned int	WORD;
+typedef char            CHAR;
+typedef unsigned char   BYTE, *LPBYTE, UCHAR, *PUCHAR, PBYTE;
+
+#define FALSE           0
+#define TRUE            1
+
+#define NULL			0
+
+typedef unsigned short int Hwd;
+typedef volatile unsigned short int vHwd;
+typedef unsigned short int *  Hwdptr;
+typedef volatile unsigned short int * vHwdptr;
+//typedef volatile unsigned int * vHwdptr;
+
+
+#endif
+
diff -Nurd u-boot-1.2.0/board/dm700/u-boot.lds u-boot-1.2.0-leopard/board/dm700/u-boot.lds
--- u-boot-1.2.0/board/dm700/u-boot.lds	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/board/dm700/u-boot.lds	2007-12-04 07:50:28.000000000 -0300
@@ -0,0 +1,52 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+	. = ALIGN(4);
+	.text	:
+	{
+	  cpu/arm926ejs/start.o	(.text)
+	  *(.text)
+	}
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+	. = ALIGN(4);
+	.data : { *(.data) }
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -Nurd u-boot-1.2.0/common/cmd_nand.c u-boot-1.2.0-leopard/common/cmd_nand.c
--- u-boot-1.2.0/common/cmd_nand.c	2007-01-06 20:13:11.000000000 -0300
+++ u-boot-1.2.0-leopard/common/cmd_nand.c	2007-12-04 07:50:35.000000000 -0300
@@ -290,6 +290,17 @@
 				return -1;
 			}
 		}
+        else if ( argc ==2 )
+        {
+            puts("Really erase all the blocks in this NAND flash? <y/N>\n");
+			if (getc() == 'y' && getc() == '\r') 
+                ; 
+            else{
+              puts("erase aborted!\n");
+              return -1;
+            }
+        }
+        
 		ret = nand_erase_opts(nand, &opts);
 		printf("%s\n", ret ? "ERROR" : "OK");
 
diff -Nurd u-boot-1.2.0/common/env_nand.c u-boot-1.2.0-leopard/common/env_nand.c
--- u-boot-1.2.0/common/env_nand.c	2007-01-06 20:13:11.000000000 -0300
+++ u-boot-1.2.0-leopard/common/env_nand.c	2007-12-04 07:50:36.000000000 -0300
@@ -192,6 +192,7 @@
 	int ret = 0;
 
 	puts ("Erasing Nand...");
+#if !defined(CFG_ENV_BLOCK)
 	if (nand_erase(&nand_info[0], CFG_ENV_OFFSET, CFG_ENV_SIZE))
 		return 1;
 
@@ -200,7 +201,16 @@
 	ret = nand_write(&nand_info[0], CFG_ENV_OFFSET, &total, (u_char*)env_ptr);
 	if (ret || total != CFG_ENV_SIZE)
 		return 1;
+#else
+	if (nand_erase(&nand_info[0], CFG_ENV_BLOCK*nand_info[0].erasesize, nand_info[0].erasesize))
+		return 1;
 
+	puts ("Writing to Nand... ");
+	total = CFG_ENV_SIZE;
+	ret = nand_write(&nand_info[0], CFG_ENV_BLOCK*nand_info[0].erasesize, &total, (u_char*)env_ptr);
+	if (ret || total != CFG_ENV_SIZE)
+		return 1;
+#endif
 	puts ("done\n");
 	return ret;
 }
@@ -272,7 +282,11 @@
 	int ret;
 
 	total = CFG_ENV_SIZE;
+#if !defined(CFG_ENV_BLOCK)
 	ret = nand_read(&nand_info[0], CFG_ENV_OFFSET, &total, (u_char*)env_ptr);
+#else
+	ret = nand_read(&nand_info[0], CFG_ENV_BLOCK*nand_info[0].erasesize, &total, (u_char*)env_ptr);
+#endif
   	if (ret || total != CFG_ENV_SIZE)
 		return use_default();
 
diff -Nurd u-boot-1.2.0/cpu/arm926ejs/config.mk u-boot-1.2.0-leopard/cpu/arm926ejs/config.mk
--- u-boot-1.2.0/cpu/arm926ejs/config.mk	2007-01-06 20:13:11.000000000 -0300
+++ u-boot-1.2.0-leopard/cpu/arm926ejs/config.mk	2007-12-04 07:50:36.000000000 -0300
@@ -24,11 +24,11 @@
 PLATFORM_RELFLAGS += -fno-strict-aliasing  -fno-common -ffixed-r8 \
 	-msoft-float
 
-PLATFORM_CPPFLAGS += -march=armv4
+#PLATFORM_CPPFLAGS += -march=armv4
 # =========================================================================
 #
 # Supply options according to compiler version
 #
 # =========================================================================
-PLATFORM_CPPFLAGS +=$(call cc-option,-mapcs-32,-mabi=apcs-gnu)
+PLATFORM_CPPFLAGS +=$(call cc-option,-mapcs-32)
 PLATFORM_RELFLAGS +=$(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,))
diff -Nurd u-boot-1.2.0/cpu/arm926ejs/interrupts.c u-boot-1.2.0-leopard/cpu/arm926ejs/interrupts.c
--- u-boot-1.2.0/cpu/arm926ejs/interrupts.c	2007-01-06 20:13:11.000000000 -0300
+++ u-boot-1.2.0-leopard/cpu/arm926ejs/interrupts.c	2007-12-04 07:50:36.000000000 -0300
@@ -39,6 +39,16 @@
 #include <arm926ejs.h>
 #include <asm/proc-armv/ptrace.h>
 
+#define TIMER_LOAD_VAL 0xffffffff
+
+/* macro to read the 32 bit timer */
+#ifdef CONFIG_OMAP
+#define READ_TIMER (*(volatile ulong *)(CFG_TIMERBASE+8))
+#endif
+#ifdef CONFIG_VERSATILE
+#define READ_TIMER (*(volatile ulong *)(CFG_TIMERBASE+4))
+#endif
+
 #ifdef CONFIG_USE_IRQ
 /* enable IRQ interrupts */
 void enable_interrupts (void)
@@ -178,14 +188,146 @@
 
 #else
 
+static ulong timestamp;
+static ulong lastdec;
+
 /* nothing really to do with interrupts, just starts up a counter. */
 int interrupt_init (void)
 {
-	extern void timer_init(void);
+#ifdef CONFIG_OMAP
+	int32_t val;
 
-  	timer_init();
+	/* Start the decrementer ticking down from 0xffffffff */
+	*((int32_t *) (CFG_TIMERBASE + LOAD_TIM)) = TIMER_LOAD_VAL;
+	val = MPUTIM_ST | MPUTIM_AR | MPUTIM_CLOCK_ENABLE | (CFG_PVT << MPUTIM_PTV_BIT);
+	*((int32_t *) (CFG_TIMERBASE + CNTL_TIMER)) = val;
+#endif	/* CONFIG_OMAP */
 
-	return 0;
+#ifdef CONFIG_VERSATILE
+	*(volatile ulong *)(CFG_TIMERBASE + 0) = CFG_TIMER_RELOAD;	/* TimerLoad */
+	*(volatile ulong *)(CFG_TIMERBASE + 4) = CFG_TIMER_RELOAD;	/* TimerValue */
+	*(volatile ulong *)(CFG_TIMERBASE + 8) = 0x8C;
+#endif	/* CONFIG_VERSATILE */
+
+	/* init the timestamp and lastdec value */
+	reset_timer_masked();
+
+	return (0);
+}
+
+/*
+ * timer without interrupts
+ */
+
+void reset_timer (void)
+{
+	reset_timer_masked ();
+}
+
+ulong get_timer (ulong base)
+{
+	return get_timer_masked () - base;
+}
+
+void set_timer (ulong t)
+{
+	timestamp = t;
+}
+
+/* delay x useconds AND perserve advance timstamp value */
+void udelay (unsigned long usec)
+{
+	ulong tmo, tmp;
+
+	if(usec >= 1000){		/* if "big" number, spread normalization to seconds */
+		tmo = usec / 1000;	/* start to normalize for usec to ticks per sec */
+		tmo *= CFG_HZ;		/* find number of "ticks" to wait to achieve target */
+		tmo /= 1000;		/* finish normalize. */
+	}else{				/* else small number, don't kill it prior to HZ multiply */
+		tmo = usec * CFG_HZ;
+		tmo /= (1000*1000);
+	}
+
+	tmp = get_timer (0);		/* get current timestamp */
+	if( (tmo + tmp + 1) < tmp )	/* if setting this fordward will roll time stamp */
+		reset_timer_masked ();	/* reset "advancing" timestamp to 0, set lastdec value */
+	else
+		tmo += tmp;		/* else, set advancing stamp wake up time */
+
+	while (get_timer_masked () < tmo)/* loop till event */
+		/*NOP*/;
+}
+
+void reset_timer_masked (void)
+{
+	/* reset time */
+	lastdec = READ_TIMER;  /* capure current decrementer value time */
+	timestamp = 0;	       /* start "advancing" time stamp from 0 */
+}
+
+ulong get_timer_masked (void)
+{
+	ulong now = READ_TIMER;		/* current tick value */
+
+	if (lastdec >= now) {		/* normal mode (non roll) */
+		/* normal mode */
+		timestamp += lastdec - now; /* move stamp fordward with absoulte diff ticks */
+	} else {			/* we have overflow of the count down timer */
+		/* nts = ts + ld + (TLV - now)
+		 * ts=old stamp, ld=time that passed before passing through -1
+		 * (TLV-now) amount of time after passing though -1
+		 * nts = new "advancing time stamp"...it could also roll and cause problems.
+		 */
+		timestamp += lastdec + TIMER_LOAD_VAL - now;
+	}
+	lastdec = now;
+
+	return timestamp;
+}
+
+/* waits specified delay value and resets timestamp */
+void udelay_masked (unsigned long usec)
+{
+	ulong tmo;
+	ulong endtime;
+	signed long diff;
+
+	if (usec >= 1000) {		/* if "big" number, spread normalization to seconds */
+		tmo = usec / 1000;	/* start to normalize for usec to ticks per sec */
+		tmo *= CFG_HZ;		/* find number of "ticks" to wait to achieve target */
+		tmo /= 1000;		/* finish normalize. */
+	} else {			/* else small number, don't kill it prior to HZ multiply */
+		tmo = usec * CFG_HZ;
+		tmo /= (1000*1000);
+	}
+
+	endtime = get_timer_masked () + tmo;
+
+	do {
+		ulong now = get_timer_masked ();
+		diff = endtime - now;
+	} while (diff >= 0);
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On ARM it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return get_timer(0);
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On ARM it returns the number of timer ticks per second.
+ */
+ulong get_tbclk (void)
+{
+	ulong tbclk;
+
+	tbclk = CFG_HZ;
+	return tbclk;
 }
 
 #endif /* CONFIG_INTEGRATOR */
diff -Nurd u-boot-1.2.0/cpu/arm926ejs/interrupts.c.orig u-boot-1.2.0-leopard/cpu/arm926ejs/interrupts.c.orig
--- u-boot-1.2.0/cpu/arm926ejs/interrupts.c.orig	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/cpu/arm926ejs/interrupts.c.orig	2007-12-04 07:50:36.000000000 -0300
@@ -0,0 +1,191 @@
+/*
+ * (C) Copyright 2003
+ * Texas Instruments <www.ti.com>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * (C) Copyright 2002-2004
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * (C) Copyright 2004
+ * Philippe Robin, ARM Ltd. <philippe.robin@arm.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <arm926ejs.h>
+#include <asm/proc-armv/ptrace.h>
+
+#ifdef CONFIG_USE_IRQ
+/* enable IRQ interrupts */
+void enable_interrupts (void)
+{
+	unsigned long temp;
+	__asm__ __volatile__("mrs %0, cpsr\n"
+			     "bic %0, %0, #0x80\n"
+			     "msr cpsr_c, %0"
+			     : "=r" (temp)
+			     :
+			     : "memory");
+}
+
+
+/*
+ * disable IRQ/FIQ interrupts
+ * returns true if interrupts had been enabled before we disabled them
+ */
+int disable_interrupts (void)
+{
+	unsigned long old,temp;
+	__asm__ __volatile__("mrs %0, cpsr\n"
+			     "orr %1, %0, #0xc0\n"
+			     "msr cpsr_c, %1"
+			     : "=r" (old), "=r" (temp)
+			     :
+			     : "memory");
+	return (old & 0x80) == 0;
+}
+#else
+void enable_interrupts (void)
+{
+	return;
+}
+int disable_interrupts (void)
+{
+	return 0;
+}
+#endif
+
+
+void bad_mode (void)
+{
+	panic ("Resetting CPU ...\n");
+	reset_cpu (0);
+}
+
+void show_regs (struct pt_regs *regs)
+{
+	unsigned long flags;
+	const char *processor_modes[] = {
+	"USER_26",	"FIQ_26",	"IRQ_26",	"SVC_26",
+	"UK4_26",	"UK5_26",	"UK6_26",	"UK7_26",
+	"UK8_26",	"UK9_26",	"UK10_26",	"UK11_26",
+	"UK12_26",	"UK13_26",	"UK14_26",	"UK15_26",
+	"USER_32",	"FIQ_32",	"IRQ_32",	"SVC_32",
+	"UK4_32",	"UK5_32",	"UK6_32",	"ABT_32",
+	"UK8_32",	"UK9_32",	"UK10_32",	"UND_32",
+	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
+	};
+
+	flags = condition_codes (regs);
+
+	printf ("pc : [<%08lx>]	   lr : [<%08lx>]\n"
+		"sp : %08lx  ip : %08lx	 fp : %08lx\n",
+		instruction_pointer (regs),
+		regs->ARM_lr, regs->ARM_sp, regs->ARM_ip, regs->ARM_fp);
+	printf ("r10: %08lx  r9 : %08lx	 r8 : %08lx\n",
+		regs->ARM_r10, regs->ARM_r9, regs->ARM_r8);
+	printf ("r7 : %08lx  r6 : %08lx	 r5 : %08lx  r4 : %08lx\n",
+		regs->ARM_r7, regs->ARM_r6, regs->ARM_r5, regs->ARM_r4);
+	printf ("r3 : %08lx  r2 : %08lx	 r1 : %08lx  r0 : %08lx\n",
+		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
+	printf ("Flags: %c%c%c%c",
+		flags & CC_N_BIT ? 'N' : 'n',
+		flags & CC_Z_BIT ? 'Z' : 'z',
+		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
+	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
+		interrupts_enabled (regs) ? "on" : "off",
+		fast_interrupts_enabled (regs) ? "on" : "off",
+		processor_modes[processor_mode (regs)],
+		thumb_mode (regs) ? " (T)" : "");
+}
+
+void do_undefined_instruction (struct pt_regs *pt_regs)
+{
+	printf ("undefined instruction\n");
+	show_regs (pt_regs);
+	bad_mode ();
+}
+
+void do_software_interrupt (struct pt_regs *pt_regs)
+{
+	printf ("software interrupt\n");
+	show_regs (pt_regs);
+	bad_mode ();
+}
+
+void do_prefetch_abort (struct pt_regs *pt_regs)
+{
+	printf ("prefetch abort\n");
+	show_regs (pt_regs);
+	bad_mode ();
+}
+
+void do_data_abort (struct pt_regs *pt_regs)
+{
+	printf ("data abort\n");
+	show_regs (pt_regs);
+	bad_mode ();
+}
+
+void do_not_used (struct pt_regs *pt_regs)
+{
+	printf ("not used\n");
+	show_regs (pt_regs);
+	bad_mode ();
+}
+
+void do_fiq (struct pt_regs *pt_regs)
+{
+	printf ("fast interrupt request\n");
+	show_regs (pt_regs);
+	bad_mode ();
+}
+
+void do_irq (struct pt_regs *pt_regs)
+{
+	printf ("interrupt request\n");
+	show_regs (pt_regs);
+	bad_mode ();
+}
+
+#ifdef CONFIG_INTEGRATOR
+
+	/* Timer functionality supplied by Integrator board (AP or CP) */
+
+#else
+
+/* nothing really to do with interrupts, just starts up a counter. */
+int interrupt_init (void)
+{
+	extern void timer_init(void);
+
+  	timer_init();
+
+	return 0;
+}
+
+#endif /* CONFIG_INTEGRATOR */
diff -Nurd u-boot-1.2.0/drivers/Makefile u-boot-1.2.0-leopard/drivers/Makefile
--- u-boot-1.2.0/drivers/Makefile	2007-01-06 20:13:11.000000000 -0300
+++ u-boot-1.2.0-leopard/drivers/Makefile	2008-01-05 03:40:50.000000000 -0300
@@ -29,7 +29,7 @@
 
 COBJS	= 3c589.o 5701rls.o ali512x.o atmel_usart.o \
 	  bcm570x.o bcm570x_autoneg.o cfb_console.o cfi_flash.o \
-	  cs8900.o ct69000.o dataflash.o dc2114x.o dm9000x.o \
+	  cs8900.o ct69000.o dataflash.o dc2114x.o dm9000.o \
 	  e1000.o eepro100.o \
 	  i8042.o inca-ip_sw.o keyboard.o \
 	  lan91c96.o \
@@ -51,7 +51,7 @@
 	  ks8695eth.o \
 	  pxa_pcmcia.o mpc8xx_pcmcia.o tqm8xx_pcmcia.o	\
 	  rpx_pcmcia.o \
-	  fsl_i2c.o
+	  fsl_i2c.o davinci_i2c.o
 
 SRCS	:= $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS))
diff -Nurd u-boot-1.2.0/drivers/davinci_i2c.c u-boot-1.2.0-leopard/drivers/davinci_i2c.c
--- u-boot-1.2.0/drivers/davinci_i2c.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/drivers/davinci_i2c.c	2007-12-04 07:50:40.000000000 -0300
@@ -0,0 +1,296 @@
+/*
+ * Basic I2C functions
+ *
+ * Copyright (c) 2004 Texas Instruments
+ *
+ * This package is free software;  you can redistribute it and/or
+ * modify it under the terms of the license found in the file
+ * named COPYING that should have accompanied this file.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * Author: Jian Zhang jzhang@ti.com, Texas Instruments
+ *
+ * Copyright (c) 2003 Wolfgang Denk, wd@denx.de
+ * Rewritten to fit into the current U-Boot framework
+ *
+ * Adapted for DaVinci I2C, swami.iyer@ti.com
+ *
+ */
+
+#include <common.h>
+
+#ifdef CONFIG_DRIVER_DAVINCI_I2C
+
+#include "davinci_i2c.h"
+#include <i2c.h>
+#include <asm/io.h>
+
+#define inw(a) __raw_readw(a)
+#define outw(a,v) __raw_writew(a,v)
+
+static void wait_for_bb (void);
+static u16 wait_for_pin (void);
+void flush_fifo(void);
+
+void i2c_init (int speed, int slaveadd)
+{
+	u16 scl;
+
+	if (inw (I2C_CON) & I2C_CON_EN) {
+		outw (0, I2C_CON);
+		udelay (50000);
+	}
+
+	outw (26, I2C_PSC);
+	outw (30, I2C_SCLL);
+	outw (10, I2C_SCLH);
+	/* own address */
+	outw (slaveadd, I2C_OA);
+	outw (0, I2C_CNT);
+	/* have to enable intrrupts or DaVinci i2c module doesn't work */
+	outw (I2C_IE_SCD_IE | I2C_IE_XRDY_IE | I2C_IE_RRDY_IE | I2C_IE_ARDY_IE |
+	      I2C_IE_NACK_IE | I2C_IE_AL_IE, I2C_IE);
+	outw (I2C_CON_EN, I2C_CON);
+	udelay (1000);
+
+}
+
+static int i2c_read_byte (u8 devaddr, u8 regoffset, u8 * value)
+{
+	int i2c_error = 0;
+	u16 status;
+
+	/* wait until bus not busy */
+	wait_for_bb ();
+
+	/* one byte only */
+	outw (1, I2C_CNT);
+	/* set slave address */
+	outw (devaddr, I2C_SA);
+	/* no stop bit needed here */
+	outw (I2C_CON_EN | I2C_CON_MST | I2C_CON_STT | I2C_CON_TRX, I2C_CON);
+
+	status = wait_for_pin ();
+
+
+	if (!i2c_error) {
+		/* free bus, otherwise we can't use a combined transction */
+		outw (0, I2C_CON);
+
+		wait_for_bb ();
+		/* set slave address */
+		outw (devaddr, I2C_SA);
+		/* read one byte from slave */
+		outw (1, I2C_CNT);
+		/* need stop bit here */
+		outw (I2C_CON_EN | I2C_CON_MST | I2C_CON_STT | I2C_CON_STP,
+		      I2C_CON);
+
+		status = wait_for_pin ();
+		if (status & I2C_STAT_RRDY) {
+			*value = inw (I2C_DRR);
+			udelay (20000);
+		} else {
+			i2c_error = 1;
+		}
+
+		if (!i2c_error) {
+			outw (I2C_CON_EN, I2C_CON);
+		}
+	}
+	flush_fifo();
+	outw (0xFFFF, I2C_STAT);
+	outw (0, I2C_CNT);
+	return i2c_error;
+}
+
+static int i2c_write_byte (u8 devaddr, u8 regoffset, u8 value)
+{
+	int i2c_error = 0;
+	u16 status, stat;
+	u16 temp;
+
+	/* wait until bus not busy */
+	wait_for_bb ();
+
+	/* two bytes */
+	outw (2, I2C_CNT);
+	/* set slave address */
+	outw (devaddr, I2C_SA);
+	/* stop bit needed here */
+	outw (I2C_CON_EN | I2C_CON_MST | I2C_CON_STT | I2C_CON_TRX |
+	      I2C_CON_STP, I2C_CON);
+
+	/* wait until state change */
+	status = wait_for_pin ();
+
+	if (status & I2C_STAT_XRDY) {
+		/* send out two bytes */
+		outw (value, I2C_DXR);
+		/* must have enough delay to allow BB bit to go low */
+		udelay (50000);
+		if (inw (I2C_STAT) & I2C_STAT_NACK) {
+			i2c_error = 1;
+		}
+	} else {
+		i2c_error = 1;
+	}
+
+	if (!i2c_error) {
+		outw (I2C_CON_EN, I2C_CON);
+		do {
+			temp = inw(I2C_STAT) && I2C_STAT_SCD;
+		} while (!temp);	
+	}
+	flush_fifo();
+	outw (0xFFFF, I2C_STAT);
+	outw (0, I2C_CNT);
+	return i2c_error;
+}
+
+void flush_fifo(void)
+{	u16 stat;
+
+	/* note: if you try and read data when its not there or ready
+	 * you get a bus error
+	 */
+	while(1){
+		stat = inw(I2C_STAT);
+		if(stat == I2C_STAT_RRDY){
+			inw(I2C_DRR);
+			outw(I2C_STAT_RRDY,I2C_STAT);
+			udelay(1000);
+		}else
+			break;
+	}
+}
+
+int i2c_probe (uchar chip)
+{
+	int res = 1; /* default = fail */
+
+	if (chip == inw (I2C_OA)) {
+		return res;
+	}
+
+	/* wait until bus not busy */
+	wait_for_bb ();
+
+	/* try to read one byte */
+	outw (1, I2C_CNT);
+	/* set slave address */
+	outw (chip, I2C_SA);
+	/* stop bit needed here */
+	outw (I2C_CON_EN | I2C_CON_MST | I2C_CON_STT | I2C_CON_STP, I2C_CON);
+	/* enough delay for the NACK bit set */
+	udelay (50000);
+
+	if (!(inw (I2C_STAT) & I2C_STAT_NACK)) {
+		res = 0;      /* success case */
+		flush_fifo();
+		outw(0xFFFF, I2C_STAT);
+	} else {
+		outw(0xFFFF, I2C_STAT);	 /* failue, clear sources*/
+		outw (inw (I2C_CON) | I2C_CON_STP, I2C_CON); /* finish up xfer */
+		udelay(20000);
+		wait_for_bb ();
+	}
+	flush_fifo();
+	outw (0, I2C_CNT); /* don't allow any more data in...we don't want it.*/
+	outw(0xFFFF, I2C_STAT);
+	return res;
+}
+
+int i2c_read (uchar chip, uint addr, int alen, uchar * buffer, int len)
+{
+	int i;
+
+	if (alen > 1) {
+		printf ("I2C read: addr len %d not supported\n", alen);
+		return 1;
+	}
+
+	if (addr + len > 256) {
+		printf ("I2C read: address out of range\n");
+		return 1;
+	}
+
+	for (i = 0; i < len; i++) {
+		if (i2c_read_byte (chip, addr + i, &buffer[i])) {
+			printf ("I2C read: I/O error\n");
+			i2c_init (CFG_I2C_SPEED, CFG_I2C_SLAVE);
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+int i2c_write (uchar chip, uint addr, int alen, uchar * buffer, int len)
+{
+	int i;
+
+	if (alen > 1) {
+		printf ("I2C read: addr len %d not supported\n", alen);
+		return 1;
+	}
+
+	if (addr + len > 256) {
+		printf ("I2C read: address out of range\n");
+		return 1;
+	}
+
+	for (i = 0; i < len; i++) {
+		if (i2c_write_byte (chip, addr + i, buffer[i])) {
+			printf ("I2C write: I/O error\n");
+			i2c_init (CFG_I2C_SPEED, CFG_I2C_SLAVE);
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static void wait_for_bb (void)
+{
+	int timeout = 0;
+	u16 stat;
+
+	outw(0xFFFF, I2C_STAT);	 /* clear current interrupts...*/
+	while ((stat = inw (I2C_STAT) & I2C_STAT_BB) && timeout--) {
+		outw (stat, I2C_STAT);
+		udelay (50000);
+	}
+
+	if (timeout <= 0) {
+		/*printf ("timed out in wait_for_bb: I2C_STAT=%x\n",
+			inw (I2C_STAT));*/
+	}
+	outw(0xFFFF, I2C_STAT);	 /* clear delayed stuff*/
+}
+
+static u16 wait_for_pin (void)
+{
+	u16 status;
+	int timeout = 10;
+
+	do {
+		udelay (1000);
+		status = inw (I2C_STAT);
+	} while (  !(status &
+		   (I2C_STAT_ROVR | I2C_STAT_XUDF | I2C_STAT_XRDY |
+		    I2C_STAT_RRDY | I2C_STAT_ARDY | I2C_STAT_NACK |
+		    I2C_STAT_AL   | I2C_STAT_SCD)) && timeout--);
+
+	if (timeout <= 0) {
+		printf ("timed out in wait_for_pin: I2C_STAT=%x\n",
+			inw (I2C_STAT));
+			outw(0xFFFF, I2C_STAT);
+}
+	return status;
+}
+
+#endif /* CONFIG_DRIVER_DAVINCI_I2C */
diff -Nurd u-boot-1.2.0/drivers/davinci_i2c.h u-boot-1.2.0-leopard/drivers/davinci_i2c.h
--- u-boot-1.2.0/drivers/davinci_i2c.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/drivers/davinci_i2c.h	2007-12-04 07:50:40.000000000 -0300
@@ -0,0 +1,87 @@
+/*
+ * (C) Copyright 2004
+ * Texas Instruments, <www.ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _DAVINCI_I2C_H_
+#define _DAVINCI_I2C_H_
+
+#define I2C_BASE                0x01C21000 
+
+#define	I2C_OA			(I2C_BASE + 0x00)
+#define I2C_IE                  (I2C_BASE + 0x04)
+#define I2C_STAT                (I2C_BASE + 0x08)
+#define I2C_SCLL                (I2C_BASE + 0x0c)
+#define I2C_SCLH                (I2C_BASE + 0x10)
+#define I2C_CNT                 (I2C_BASE + 0x14)
+#define I2C_DRR                 (I2C_BASE + 0x18)
+#define I2C_SA                  (I2C_BASE + 0x1c)
+#define I2C_DXR                 (I2C_BASE + 0x20)
+#define I2C_CON                 (I2C_BASE + 0x24)
+#define I2C_IV                  (I2C_BASE + 0x28)
+#define I2C_PSC                 (I2C_BASE + 0x30)
+
+/* I2C masks */
+
+/* I2C Interrupt Enable Register (I2C_IE): */
+#define I2C_IE_SCD_IE   (1 << 5)        /* Stop condition detect interrupt enable */
+#define I2C_IE_XRDY_IE  (1 << 4)        /* Transmit data ready interrupt enable */
+#define I2C_IE_RRDY_IE  (1 << 3)        /* Receive data ready interrupt enable */
+#define I2C_IE_ARDY_IE  (1 << 2)        /* Register access ready interrupt enable */
+#define I2C_IE_NACK_IE  (1 << 1)        /* No acknowledgment interrupt enable */
+#define I2C_IE_AL_IE    (1 << 0)        /* Arbitration lost interrupt enable */
+
+/* I2C Status Register (I2C_STAT): */
+
+#define I2C_STAT_BB     (1 << 12)       /* Bus busy */
+#define I2C_STAT_ROVR   (1 << 11)       /* Receive overrun */
+#define I2C_STAT_XUDF   (1 << 10)       /* Transmit underflow */
+#define I2C_STAT_AAS    (1 << 9)        /* Address as slave */
+#define I2C_STAT_SCD    (1 << 5)        /* Stop condition detect */
+#define I2C_STAT_XRDY   (1 << 4)        /* Transmit data ready */
+#define I2C_STAT_RRDY   (1 << 3)        /* Receive data ready */
+#define I2C_STAT_ARDY   (1 << 2)        /* Register access ready */
+#define I2C_STAT_NACK   (1 << 1)        /* No acknowledgment interrupt enable */
+#define I2C_STAT_AL     (1 << 0)        /* Arbitration lost interrupt enable */
+
+
+/* I2C Interrupt Code Register (I2C_INTCODE): */
+
+#define I2C_INTCODE_MASK        7
+#define I2C_INTCODE_NONE        0
+#define I2C_INTCODE_AL          1       /* Arbitration lost */
+#define I2C_INTCODE_NAK         2       /* No acknowledgement/general call */
+#define I2C_INTCODE_ARDY        3       /* Register access ready */
+#define I2C_INTCODE_RRDY        4       /* Rcv data ready */
+#define I2C_INTCODE_XRDY        5       /* Xmit data ready */
+#define I2C_INTCODE_SCD         6       /* Stop condition detect */
+
+
+/* I2C Configuration Register (I2C_CON): */
+
+#define I2C_CON_EN      (1 << 5)       /* I2C module enable */
+#define I2C_CON_STB     (1 << 4)       /* Start byte mode (master mode only) */
+#define I2C_CON_MST     (1 << 10)      /* Master/slave mode */
+#define I2C_CON_TRX     (1 << 9)       /* Transmitter/receiver mode (master mode only) */
+#define I2C_CON_XA      (1 << 8)       /* Expand address */
+#define I2C_CON_STP     (1 << 11)      /* Stop condition (master mode only) */
+#define I2C_CON_STT     (1 << 13)      /* Start condition (master mode only) */
+
+#endif
diff -Nurd u-boot-1.2.0/drivers/dm9000.c u-boot-1.2.0-leopard/drivers/dm9000.c
--- u-boot-1.2.0/drivers/dm9000.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/drivers/dm9000.c	2008-01-05 03:43:06.000000000 -0300
@@ -0,0 +1,370 @@
+/*
+ * 			U-BOOT DM9000A DRIVER
+ *			  www.davicom.com.tw
+ * 
+ * This program is loaded into SRAM in bootstrap mode, where it waits
+ * for commands on UART1 to read and write memory, jump to code etc.
+ * A design goal for this program is to be entirely independent of the
+ * target board.  Anything with a CL-PS7111 or EP7211 should be able to run
+ * this code in bootstrap mode.  All the board specifics can be handled on
+ * the host.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *V1.01 -load MAC address from EEPROM
+ */
+
+#include <common.h>
+#include <command.h>
+#include "dm9000.h"
+#include <net.h>
+
+#ifdef CONFIG_DRIVER_DM9000
+
+#if (CONFIG_COMMANDS & CFG_CMD_NET)
+#define DM9000_ID		0x90000A46
+#define DM9010_ID		0x90100A46
+#define DM9KS_REG05		(RXCR_Discard_LongPkt|RXCR_Discard_CRCPkt) 
+#define DM9KS_DISINTR		IMR_SRAM_antoReturn
+/*
+ * If your bus is 8-bit or 32-bit, you must modify below.
+ * Ex. your bus is 8 bit
+ *	DM9000_PPTR *(volatile u8 *)(DM9000_BASE)
+ */
+#define DM9000_BASE CONFIG_DM9000_BASE
+#define DM9000_PPTR   *(volatile u16 *)(DM9000_BASE)
+#define DM9000_PDATA  *(volatile u16 *)(DM9000_BASE + 16)
+
+#define mdelay(n)       udelay((n)*1000)
+
+static unsigned char ior(int);
+static void iow(int, u8);
+static void phy_write(int, u16);
+static void move8(unsigned char *, int, int);
+static void move16(unsigned char *, int, int);
+static void move32(unsigned char *, int, int);
+static u16 read_srom_word(int);
+static void dmfe_init_dm9000(void);
+static u32 GetDM9000ID(void);
+void DM9000_get_enetaddr (uchar *);
+static void eth_reset (void);
+void eth_halt(void);
+int eth_init(bd_t *);
+void (*MoveData)(unsigned char *, int , int);
+
+static void iow(int reg, u8 value)
+{
+	DM9000_PPTR = reg;
+	DM9000_PDATA  =  value & 0xff;
+}
+
+static unsigned char ior(int reg)
+{
+	DM9000_PPTR = reg;
+	return DM9000_PDATA & 0xff;
+}
+
+static void phy_write(int reg, u16 value)
+{
+	/* Fill the phyxcer register into REG_0C */
+	iow(DM9KS_EPAR, DM9KS_PHY | reg);
+
+	/* Fill the written data into REG_0D & REG_0E */
+	iow(DM9KS_EPDRL, (value & 0xff));
+	iow(DM9KS_EPDRH, ( (value >> 8) & 0xff));
+
+	iow(DM9KS_EPCR, EPCR_PHY_Sele|EPCR_Write);	/* Issue phyxcer write command */
+	udelay(500);			/* Wait write complete */
+	iow(DM9KS_EPCR, 0x0);	/* Clear phyxcer write command */
+}
+
+/*
+	leng: unit BYTE
+	selec 0:input(RX)	1:output(TX)
+	if selec=0, move data from FIFO to data_ptr 
+	if selec=1, move data from data_ptr to FIFO
+*/
+static void move8(unsigned char *data_ptr, int leng, int selec)
+{
+	int i;
+	if (selec)
+		for (i=0; i<leng; i++)
+			DM9000_PDATA =(data_ptr[i] & 0xff);
+	else
+		for (i=0; i<leng; i++)
+			data_ptr[i] = DM9000_PDATA;
+}	
+
+static void move16(unsigned char *data_ptr, int leng, int selec)
+{
+	int i, tmpleng;
+	tmpleng = (leng + 1) >> 1;
+	if (selec)
+		for (i=0; i<tmpleng; i++)
+			DM9000_PDATA =((u16 *)data_ptr)[i];
+	else
+		for (i=0; i<tmpleng; i++)
+			((u16 *)data_ptr)[i] = DM9000_PDATA;
+}	
+
+static void move32(unsigned char *data_ptr, int leng, int selec)
+{
+	int i, tmpleng;
+	tmpleng = (leng + 3) >> 2;
+	if (selec)
+		for (i=0; i<tmpleng; i++)
+			DM9000_PDATA = ((u32 *)data_ptr)[i];
+	else
+		for (i=0; i<tmpleng; i++)
+			((u32 *)data_ptr)[i]=DM9000_PDATA;
+}	
+
+/*
+ * Read a word data from EEPROM
+ */
+static u16 read_srom_word(int offset)
+{
+	iow(DM9KS_EPAR, offset);
+	iow(DM9KS_EPCR, 0x4);
+	udelay(200);
+	iow(DM9KS_EPCR, 0x0);
+	return (ior(DM9KS_EPDRL) + (ior(DM9KS_EPDRH) << 8) );
+}
+/* 
+ *	Initilize dm9000 board
+ */
+static void dmfe_init_dm9000(void)
+{
+	int io_mode;
+	
+	/* set the internal PHY power-on, GPIOs normal, and wait 20ms */
+	iow(DM9KS_GPR, GPR_PHYUp);
+	mdelay(20); /* wait for PHY power-on ready */
+	iow(DM9KS_GPR, GPR_PHYDown);/* Power-Down PHY */
+	mdelay(1000);	/* compatible with rtl8305s */
+	iow(DM9KS_GPR, GPR_PHYUp);	
+	mdelay(20);/* wait for PHY power-on ready */
+
+	iow(DM9KS_NCR, NCR_MAC_loopback|NCR_Reset);
+	udelay(20);/* wait 20us at least for software reset ok */
+	iow(DM9KS_NCR, NCR_MAC_loopback|NCR_Reset);
+	udelay(20);/* wait 20us at least for software reset ok */
+
+	/* I/O mode */
+	io_mode = ior(DM9KS_ISR) >> 6; /* ISR bit7:6 keeps I/O mode */
+	switch (io_mode)
+	{
+		case DM9KS_BYTE_MODE:
+			printf("DM9000 work in 8 bus width\n");
+			MoveData = move8;
+			break;
+		case DM9KS_WORD_MODE:
+			printf("DM9000 work in 16 bus width\n");
+			MoveData = move16;
+			break;
+		case DM9KS_DWORD_MODE:
+			printf("DM9000 work in 32 bus width\n");
+			MoveData = move32;
+			break;
+		default:
+			printf("DM9000 work in wrong bus width, error\n");
+			break;
+	}
+	
+	/* Set PHY */
+	phy_write(4, 0x01e1);
+	phy_write(0, 0x1200); /* N-way */
+
+	/* Program operating register */
+	iow(DM9KS_NCR, 0);
+	iow(DM9KS_TCR, 0);/* TX Polling clear */
+	iow(DM9KS_BPTR, 0x30|JPT_600us);/* Less 3kb, 600us */
+	iow(DM9KS_SMCR, 0);/* Special Mode */
+	iow(DM9KS_NSR, 0x2c);/* clear TX status */
+	iow(DM9KS_ISR, 0x0f);/* Clear interrupt status */
+	iow(DM9KS_TCR2, TCR2_LedMode1);/* Set LED mode 1 */
+#if 0
+	/* Data bus current driving/sinking capability  */
+	iow(DM9KS_PBCR, 0x60);	/* default: 8mA */
+#endif
+ 
+	iow(0x1d, 0x80);/* receive broadcast packet */
+
+	/* Activate DM9000A/DM9010 */
+	iow(DM9KS_RXCR, DM9KS_REG05 | RXCR_RxEnable);	
+	iow(DM9KS_IMR, DM9KS_DISINTR);
+}
+
+/* packet page register access functions */
+static u32 GetDM9000ID(void)
+{
+	u32	id_val;
+
+	DM9000_PPTR = DM9KS_PID_H;
+	id_val = (DM9000_PDATA & 0xff) << 8;
+	DM9000_PPTR = DM9KS_PID_L;
+	id_val+= (DM9000_PDATA & 0xff);
+	id_val = id_val << 16;
+	
+	DM9000_PPTR = DM9KS_VID_H;
+	id_val += (DM9000_PDATA & 0xff) << 8;
+	DM9000_PPTR = DM9KS_VID_L;
+	id_val += (DM9000_PDATA & 0xff);
+	
+
+	return id_val;
+}
+
+
+void DM9000_get_enetaddr (uchar * addr)
+{
+	int i;
+	u8 temp;
+	eth_reset ();	
+	printf ("MAC: ");
+        for (i = 0x10; i <= 0x15; i++) {
+                temp = ior (i);
+                *addr++ = temp;
+                printf ("%x:", temp);
+        }
+
+	return;
+}
+
+static void eth_reset (void)
+{
+	u32 ID;
+	
+	ID = GetDM9000ID();
+	if ( ID != DM9000_ID)
+	{
+		printf("not found the dm9000 ID:%x\n",ID);
+		return ;
+	}else
+		printf("found DM9000 ID:%x\n",ID);
+	eth_halt();
+	dmfe_init_dm9000();
+}
+
+void eth_halt (void)
+{
+	/* RESET devie */
+	phy_write(0x00, 0x8000);	/* PHY RESET */
+	iow(DM9KS_GPR, GPR_PHYDown); 	/* Power-Down PHY */
+	iow(DM9KS_IMR, DM9KS_DISINTR);	/* Disable all interrupt */
+	iow(DM9KS_RXCR, 0x00);		/* Disable RX */
+}
+
+int eth_init (bd_t * bd)
+{
+	u32 ID;
+	int i,j;
+	u16 * mac =(u16 *) bd->bi_enetaddr;
+
+	ID = GetDM9000ID();
+	if ( ID != DM9000_ID)
+	{
+		printf("not found the dm9000 ID:%x\n",ID);
+		return 1;
+	}
+	printf("Found DM9000 ID:%x at address %x !\n", ID,  DM9000_BASE);
+	dmfe_init_dm9000();
+#if 0
+	for (i=0; i<3; i++) /* read MAC from EEPROM */
+		mac[i]= read_srom_word(i);
+#else
+	mac[0]=0x1100;
+	mac[1]=0x3322;
+	mac[2]=0x5544;
+#endif
+	printf("[eth_init]MAC:");
+	for(i=0,j=0x10; i<6; i++,j++)
+	{	
+		
+		iow(j,bd->bi_enetaddr[i]);
+		printf("%x:",bd->bi_enetaddr[i]);
+	}
+	printf("\n");
+	return 0;
+}
+
+/* Get a data block via Ethernet */
+extern int eth_rx (void)
+{
+	unsigned short rxlen;
+	unsigned char *addr = NULL;
+	u8 RxRead;
+	rx_t rx;
+	u8 * ptr = (u8*)&rx;
+	
+
+	RxRead = ior(DM9KS_MRCMDX);
+	RxRead = ior(DM9KS_ISR);
+	RxRead = ior(DM9KS_MRCMDX) & 0xff;
+
+	if (RxRead != 1)  /* no data */ 
+		return 0;
+
+	DM9000_PPTR = DM9KS_MRCMD; /* set read ptr ++ */
+
+	/* Read packet status & length */
+	MoveData(ptr, 4, 0);
+
+	rxlen = rx.desc.length;		/* get len */
+
+	if(rx.desc.status & (RX_RuntFrame | RX_PhyErr | RX_AlignErr | RX_CRCErr))
+		printf ("[dm9ks]RX error %x\n", rx.desc.status);	
+
+	if (rxlen > PKTSIZE_ALIGN + PKTALIGN)
+		printf ("packet too big! %d %d\n", rxlen, PKTSIZE_ALIGN + PKTALIGN);
+
+	addr = (unsigned char *)NetRxPackets[0];
+	MoveData(addr, rxlen, 0);
+
+	/* Pass the packet up to the protocol layers. */
+	NetReceive (NetRxPackets[0], rxlen);
+
+	return rxlen;
+}
+
+/* Send a data block via Ethernet. */
+extern int eth_send (volatile void *packet, int length)
+{
+	volatile unsigned char *addr;
+	int	length1 = length;
+
+	DM9000_PPTR = DM9KS_MWCMD;/* data copy ready set */
+
+	/* copy data */
+	addr = packet;
+	MoveData(addr,length,1);
+
+	/* set packet length  */
+	iow(DM9KS_TXPLH, (length1 >> 8) & 0xff);  
+	iow(DM9KS_TXPLL, length1 & 0xff);
+
+	/* start transmit */
+	iow(DM9KS_TCR, TCR_TX_Request);
+
+	while (1)/* wait for tx complete */
+	{
+		if (ior(DM9KS_NSR)& (NSR_TX2END|NSR_TX1END))	
+			break;
+	}
+	return 0;
+}
+#endif	/* COMMANDS & CFG_NET */
+
+#endif	/* CONFIG_DRIVER_DM9000 */
diff -Nurd u-boot-1.2.0/drivers/dm9000.h u-boot-1.2.0-leopard/drivers/dm9000.h
--- u-boot-1.2.0/drivers/dm9000.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/drivers/dm9000.h	2008-01-05 03:43:06.000000000 -0300
@@ -0,0 +1,181 @@
+
+#define DM9KS_DWORD_MODE		1
+#define DM9KS_BYTE_MODE		2
+#define DM9KS_WORD_MODE		0
+
+#define TRUE			1
+#define FALSE			0
+
+#define DM9KS_PKT_RDY		0x01	/* Packet ready to receive */
+
+//#ifndef CONFIG_ARCH_MAINSTONE
+//#pragma pack(push, 1)
+//#endif
+
+typedef struct _RX_DESC
+{
+	u8 rxbyte;
+	u8 status;
+	u16 length;
+}RX_DESC;
+
+typedef union{
+	u8 buf[4];
+	RX_DESC desc;
+} rx_t;
+//#ifndef CONFIG_ARCH_MAINSTONE
+//#pragma pack(pop)
+//#endif
+
+enum DM9KS_PHY_mode {
+	DM9KS_10MHD   = 0, 
+	DM9KS_100MHD  = 1, 
+	DM9KS_10MFD   = 4,
+	DM9KS_100MFD  = 5, 
+	DM9KS_AUTO    = 8, 
+};
+
+enum DM9KS_MAC_reg {
+	DM9KS_NCR	=	0x00,	/* Network control Reg.*/
+  DM9KS_NSR	=	0x01,	/* Network Status Reg.*/
+  DM9KS_TCR	=	0x02,	/* TX control Reg.*/
+  DM9KS_RXCR	=	0x05,	/* RX control Reg.*/
+  DM9KS_BPTR	=	0x08,
+  DM9KS_EPCR	=	0x0b,
+  DM9KS_EPAR	=	0x0c,
+  DM9KS_EPDRL	=	0x0d,
+  DM9KS_EPDRH	=	0x0e,
+  DM9KS_GPR	=	0x1f,	/* General purpose register */
+  DM9KS_VID_L	=	0x28,
+	DM9KS_VID_H	=	0x29,
+  DM9KS_PID_L	=	0x2A,
+  DM9KS_PID_H	=	0x2B,
+  DM9KS_TCR2	=	0x2d,
+  DM9KS_SMCR	=	0x2f, 	/* Special Mode Control Reg.*/
+  DM9KS_ETXCSR	=	0x30,	/* Early Transmit control/status Reg.*/
+  DM9KS_TCCR	=	0x31,	/* Checksum cntrol Reg. */
+  DM9KS_RCSR	=	0x32,	/* Receive Checksum status Reg.*/
+  DM9KS_MRCMDX	=	0xf0,
+  DM9KS_MRCMD	=	0xf2,
+  DM9KS_MDRAL	=	0xf4,
+  DM9KS_MDRAH	=	0xf5,
+  DM9KS_MWCMD	=	0xf8,
+  DM9KS_TXPLL	=	0xfc,
+  DM9KS_TXPLH	=	0xfd,
+  DM9KS_ISR	=	0xfe,
+  DM9KS_IMR	=	0xff
+};
+
+/* TX status */
+#define TX_Jabber_timeout	(1<<7)
+#define	TX_LossCarrier		(1<<6)
+#define	TX_NoCarrier			(1<<5)
+#define	TX_LateColli			(1<<4)
+#define TX_ColliPkt				(1<<3)
+#define TX_ExcessColli		(1<<2)
+
+/* RX status */
+#define RX_RuntFrame				(1<<7)
+#define	RX_MultiFrame				(1<<6)
+#define	RX_LateColli				(1<<5)
+#define	RX_Watchdog_timeout	(1<<4)
+#define	RX_PhyErr						(1<<3)
+#define	RX_AlignErr					(1<<2)
+#define	RX_CRCErr						(1<<1)
+#define	RX_FIFO_over				1
+
+/* DM9KS_NCR */
+#define NCR_MAC_loopback	2
+#define NCR_Reset					1
+
+/* DM9KS_NSR */
+#define NSR_10M					(1<<7)
+#define NSR_Link_OK			(1<<6)
+#define NSR_TX2END			(1<<3)
+#define	NSR_TX1END			(1<<2)
+
+/* DM9KS_TCR */
+#define TCR_TX_Request	1
+
+/* DM9KS_RXCR */
+#define	RXCR_Discard_LongPkt	(1<<5)
+#define RXCR_Discard_CRCPkt		(1<<4)
+#define	RXCR_Pass_AllMulti		(1<<3)
+#define	RXCR_Pass_RuntPkt			(1<<2)
+#define	RXCR_Promiscuous			(1<<1)
+#define	RXCR_RxEnable			1
+
+/* DM9KS_BPTR */
+enum Jam_Pattern_Time{
+	JPT_5us = 0,
+	JPT_10us = 1,
+	JPT_15us = 2,
+	JPT_25us = 3,
+	JPT_50us = 4,
+	JPT_100us = 5,
+	JPT_150us = 6,
+	JPT_200us = 7,
+	JPT_250us = 8,
+	JPT_300us = 9,
+	JPT_350us = 10,
+	JPT_400us = 11,
+	JPT_450us = 12,
+	JPT_500us = 13,
+	JPT_550us = 14,
+	JPT_600us = 15
+};
+
+/* DM9KS_FCR */
+#define	FCR_TX_PausePkt		(1<<5)
+#define	FCR_FlowCtlEable	1
+
+/* DM9KS_EPCR */
+#define	EPCR_WriteEEPROM_Enable	(1<<5)
+#define	EPCR_PHY_Sele						(1<<3) /*bit 3 = 0, select EEPROM*/
+#define EPCR_Read								(1<<2)
+#define EPCR_Write							(1<<1)
+
+/* DM9KS_EPAR */
+#define DM9KS_PHY		0x40	/* PHY address 0x01 */
+
+/* DM9KS_GPR */
+#define GPR_PHYDown		1
+#define GPR_PHYUp			0
+
+/* DM9KS_TCR2 */
+#define TCR2_LedMode1		(1<<7)
+
+/* DM9KS_ETXCSR */
+#define ETXCSR_EarlyTrans	(1<<7)
+#define	Threshold_12		0
+#define	Threshold_25		1
+#define	Threshold_50		2
+#define	Threshold_75		3
+
+/* DM9KS_TCCR */
+#define TCCR_UDP_Chksum 	(1<<2)
+#define TCCR_TCP_Chksum		(1<<1)
+#define TCCR_IP_Chksum		1
+
+/* DM9KS_RCSR */
+#define UDP_Chksum_Err				(1<<7)
+#define TCP_Chksum_Err				(1<<6)
+#define IP_Chksum_Err					(1<<5)
+#define RCSR_RX_Chksum_enable	(1<<1)
+
+/* DM9KS_ISR */
+#define ISR_Link_change				(1<<5)
+#define ISR_TX_underrun				(1<<4)
+#define ISR_RX_OFcnt_overflow	(1<<3)
+#define ISR_RX_Overflow				(1<<2)
+#define ISR_TX_complete				(1<<1)
+#define ISR_RX_coming					1
+
+/* DM9KS_IMR */
+#define	IMR_SRAM_antoReturn		(1<<7)
+#define IMR_Link_change				(1<<5)
+#define IMR_TX_underrun				(1<<4)
+#define IMR_RX_OFcnt_overflow	(1<<3)
+#define IMR_RX_Overflow				(1<<2)
+#define IMR_TX_complete				(1<<1)
+#define IMR_RX_coming					1
diff -Nurd u-boot-1.2.0/drivers/dm9000x.c u-boot-1.2.0-leopard/drivers/dm9000x.c
--- u-boot-1.2.0/drivers/dm9000x.c	2007-01-06 20:13:11.000000000 -0300
+++ u-boot-1.2.0-leopard/drivers/dm9000x.c	2007-12-04 07:50:40.000000000 -0300
@@ -56,8 +56,7 @@
 #define DM9801_NOISE_FLOOR	0x08
 #define DM9802_NOISE_FLOOR	0x05
 
-/* #define CONFIG_DM9000_DEBUG */
-
+//#define CONFIG_DM9000_DEBUG
 #ifdef CONFIG_DM9000_DEBUG
 #define DM9000_DBG(fmt,args...) printf(fmt ,##args)
 #else				/*  */
@@ -124,7 +123,7 @@
 	DM9000_DBG("TSRII (0x04): %02x\n", DM9000_ior(4));
 	DM9000_DBG("RCR   (0x05): %02x\n", DM9000_ior(5));
 	DM9000_DBG("RSR   (0x06): %02x\n", DM9000_ior(6));
-	DM9000_DBG("ISR   (0xFE): %02x\n", DM9000_ior(ISR));
+	DM9000_DBG("ISR   (0xFE): %02x\n", DM9000_ior(0xFE));
 	DM9000_DBG("\n");
 }
 #endif				/*  */
@@ -141,11 +140,11 @@
 	id_val |= DM9000_ior(DM9000_PIDL) << 16;
 	id_val |= DM9000_ior(DM9000_PIDH) << 24;
 	if (id_val == DM9000_ID) {
-		printf("dm9000 i/o: 0x%x, id: 0x%x \n", CONFIG_DM9000_BASE,
+		DM9000_DBG("dm9000 i/o: 0x%x, id: 0x%x \n", CONFIG_DM9000_BASE,
 		       id_val);
 		return 0;
 	} else {
-		printf("dm9000 not found at 0x%08x id: 0x%08x\n",
+		DM9000_DBG("dm9000 not found at 0x%08x id: 0x%08x\n",
 		       CONFIG_DM9000_BASE, id_val);
 		return -1;
 	}
@@ -268,12 +267,15 @@
 	udelay(1000);		/* delay 1ms */
 }
 
+unsigned int txnum=0, rxnum=0, rxpoll=0;
 /* Initilize dm9000 board
 */
 int
 eth_init(bd_t * bd)
 {
 	int i, oft, lnk;
+  unsigned char srom[128];
+
 	DM9000_DBG("eth_init()\n");
 
 	/* RESET device */
@@ -299,22 +301,38 @@
 	DM9000_iow(DM9000_NSR, NSR_WAKEST | NSR_TX2END | NSR_TX1END);	/* clear TX status */
 	DM9000_iow(DM9000_ISR, 0x0f);	/* Clear interrupt status */
 
+	memset(srom, 0, 128);
+
 	/* Set Node address */
-	for (i = 0; i < 6; i++)
-		((u16 *) bd->bi_enetaddr)[i] = read_srom_word(i);
-	printf("MAC: %02x:%02x:%02x:%02x:%02x:%02x\n", bd->bi_enetaddr[0],
+	for (i = 0; i < 64; i++) {
+		((u16 *) srom)[i] = read_srom_word(i);
+  }
+
+	if ( bd->bi_enetaddr[0] == 0 &&
+		bd->bi_enetaddr[1] == 0 &&
+		bd->bi_enetaddr[2] == 0 &&
+		bd->bi_enetaddr[3] == 0 &&
+		bd->bi_enetaddr[4] == 0 &&
+		bd->bi_enetaddr[5] == 0 ) 
+	{ 
+		/* no 'ethaddr' defined in environment, take it from srom */
+		for (i = 0; i < 6; i++) 
+			bd->bi_enetaddr[i] = srom[i];
+	}
+
+	DM9000_DBG("MAC: %02x:%02x:%02x:%02x:%02x:%02x\n", bd->bi_enetaddr[0],
 	       bd->bi_enetaddr[1], bd->bi_enetaddr[2], bd->bi_enetaddr[3],
 	       bd->bi_enetaddr[4], bd->bi_enetaddr[5]);
 	for (i = 0, oft = 0x10; i < 6; i++, oft++)
 		DM9000_iow(oft, bd->bi_enetaddr[i]);
 	for (i = 0, oft = 0x16; i < 8; i++, oft++)
 		DM9000_iow(oft, 0xff);
-
+#if 0
 	/* read back mac, just to be sure */
 	for (i = 0, oft = 0x10; i < 6; i++, oft++)
 		DM9000_DBG("%02x:", DM9000_ior(oft));
 	DM9000_DBG("\n");
-
+#endif
 	/* Activate DM9000 */
 	DM9000_iow(DM9000_RCR, RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN);	/* RX enable */
 	DM9000_iow(DM9000_IMR, IMR_PAR);	/* Enable TX/RX interrupt mask */
@@ -323,32 +341,35 @@
 		udelay(1000);
 		i++;
 		if (i == 10000) {
-			printf("could not establish link\n");
+			DM9000_DBG("could not establish link\n");
 			return 0;
 		}
 	}
 
 	/* see what we've got */
 	lnk = phy_read(17) >> 12;
-	printf("operating at ");
+	DM9000_DBG("operating at ");
 	switch (lnk) {
 	case 1:
-		printf("10M half duplex ");
+		DM9000_DBG("10M half duplex ");
 		break;
 	case 2:
-		printf("10M full duplex ");
+		DM9000_DBG("10M full duplex ");
 		break;
 	case 4:
-		printf("100M half duplex ");
+		DM9000_DBG("100M half duplex ");
 		break;
 	case 8:
-		printf("100M full duplex ");
+		DM9000_DBG("100M full duplex ");
 		break;
 	default:
-		printf("unknown: %d ", lnk);
+		DM9000_DBG("unknown: %d ", lnk);
 		break;
 	}
-	printf("mode\n");
+	DM9000_DBG("mode\n");
+  txnum=0;
+  rxnum=0;
+  rxpoll=0;
 	return 0;
 }
 
@@ -362,12 +383,14 @@
 	char *data_ptr;
 	u32 tmplen, i;
 	int tmo;
-	DM9000_DBG("eth_send: length: %d\n", length);
-	for (i = 0; i < length; i++) {
-		if (i % 8 == 0)
-			DM9000_DBG("\nSend: 02x: ", i);
-		DM9000_DBG("%02x ", ((unsigned char *) packet)[i]);
-	} DM9000_DBG("\n");
+  if (txnum < 6) 
+    DM9000_DBG("eth_send: length: %d\n", length);
+  txnum++;
+	//for (i = 0; i < length; i++) {
+		//if (i % 8 == 0) DM9000_DBG("\nSend: 02x: ", i);
+		//DM9000_DBG("%02x ", ((unsigned char *) packet)[i]);
+	//} 
+	//DM9000_DBG("\n");
 
 	/* Move data to DM9000 TX RAM */
 	data_ptr = (char *) packet;
@@ -400,14 +423,15 @@
 	DM9000_iow(DM9000_TCR, TCR_TXREQ);	/* Cleared after TX complete */
 
 	/* wait for end of transmission */
-	tmo = get_timer(0) + 5 * CFG_HZ;
+	tmo = get_timer(0) + 20 * CFG_HZ;
 	while (DM9000_ior(DM9000_TCR) & TCR_TXREQ) {
 		if (get_timer(0) >= tmo) {
-			printf("transmission timeout\n");
+			DM9000_DBG("transmission timeout\n");
 			break;
 		}
 	}
-	DM9000_DBG("transmit done\n\n");
+	//DM9000_DBG("transmit done\n\n");
+	udelay(1000); /* delay 8ms */
 	return 0;
 }
 
@@ -425,6 +449,9 @@
 	DM9000_iow(DM9000_GPR, 0x01);	/* Power-Down PHY */
 	DM9000_iow(DM9000_IMR, 0x80);	/* Disable all interrupt */
 	DM9000_iow(DM9000_RCR, 0x00);	/* Disable RX */
+  txnum=0;
+  rxnum=0;
+  rxpoll=0;
 }
 
 /*
@@ -443,17 +470,30 @@
 	/* Check packet ready or not */
 	DM9000_ior(DM9000_MRCMDX);	/* Dummy read */
 	rxbyte = DM9000_inb(DM9000_DATA);	/* Got most updated data */
-	if (rxbyte == 0)
+	if (rxbyte == 0) {
+#if 1
+    rxpoll++;
+    if (((rxpoll % 1000)==0)) {
+      DM9000_ior(DM9000_RSR);	
+      RxStatus = DM9000_inb(DM9000_DATA);
+      DM9000_DBG("P: %04x ", RxStatus);
+    }
+#else
+    udelay(800);
+#endif
 		return 0;
-
+  }
+  rxpoll =0;
 	/* Status check: this byte must be 0 or 1 */
 	if (rxbyte > 1) {
 		DM9000_iow(DM9000_RCR, 0x00);	/* Stop Device */
 		DM9000_iow(DM9000_ISR, 0x80);	/* Stop INT request */
-		DM9000_DBG("rx status check: %d\n", rxbyte);
+		//DM9000_DBG("rx status check: %d\n", rxbyte);
 	}
-	DM9000_DBG("receiving packet\n");
-
+	//DM9000_DBG("receiving packet\n");
+  if ( rxnum <10 )
+    DM9000_DBG("R");
+  rxnum++;
 	/* A packet ready now  & Get status/length */
 	DM9000_outb(DM9000_MRCMD, DM9000_IO);
 
@@ -473,7 +513,7 @@
 	RxLen = tmpdata >> 16;
 
 #endif				/*  */
-	DM9000_DBG("rx status: 0x%04x rx len: %d\n", RxStatus, RxLen);
+	//DM9000_DBG("rx status: 0x%04x rx len: %d\n", RxStatus, RxLen);
 
 	/* Move data from DM9000 */
 	/* Read received packet from RX SRAM */
@@ -497,22 +537,22 @@
 	if ((RxStatus & 0xbf00) || (RxLen < 0x40)
 	    || (RxLen > DM9000_PKT_MAX)) {
 		if (RxStatus & 0x100) {
-			printf("rx fifo error\n");
+			DM9000_DBG("rx fifo error\n");
 		}
 		if (RxStatus & 0x200) {
-			printf("rx crc error\n");
+			DM9000_DBG("rx crc error\n");
 		}
 		if (RxStatus & 0x8000) {
-			printf("rx length error\n");
+			DM9000_DBG("rx length error\n");
 		}
 		if (RxLen > DM9000_PKT_MAX) {
-			printf("rx length too big\n");
+			DM9000_DBG("rx length too big\n");
 			dm9000_reset();
 		}
 	} else {
 
 		/* Pass to upper layer */
-		DM9000_DBG("passing packet to upper layer\n");
+		// DM9000_DBG("passing packet to upper layer\n");
 		NetReceive(NetRxPackets[0], RxLen);
 		return RxLen;
 	}
@@ -527,7 +567,7 @@
 {
 	DM9000_iow(DM9000_EPAR, offset);
 	DM9000_iow(DM9000_EPCR, 0x4);
-	udelay(200);
+	udelay(800);
 	DM9000_iow(DM9000_EPCR, 0x0);
 	return (DM9000_ior(DM9000_EPDRL) + (DM9000_ior(DM9000_EPDRH) << 8));
 }
@@ -568,7 +608,7 @@
 	val = (DM9000_ior(DM9000_EPDRH) << 8) | DM9000_ior(DM9000_EPDRL);
 
 	/* The read data keeps on REG_0D & REG_0E */
-	DM9000_DBG("phy_read(%d): %d\n", reg, val);
+	//DM9000_DBG("phy_read(%d): %d\n", reg, val);
 	return val;
 }
 
@@ -588,6 +628,6 @@
 	DM9000_iow(DM9000_EPCR, 0xa);	/* Issue phyxcer write command */
 	udelay(500);		/* Wait write complete */
 	DM9000_iow(DM9000_EPCR, 0x0);	/* Clear phyxcer write command */
-	DM9000_DBG("phy_write(reg:%d, value:%d)\n", reg, value);
+	//DM9000_DBG("phy_write(reg:%d, value:%d)\n", reg, value);
 }
-#endif				/* CONFIG_DRIVER_DM9000 */
+#endif /* CONFIG_DRIVER_DM9000 */
diff -Nurd u-boot-1.2.0/drivers/nand/nand_base.c u-boot-1.2.0-leopard/drivers/nand/nand_base.c
--- u-boot-1.2.0/drivers/nand/nand_base.c	2007-01-06 20:13:11.000000000 -0300
+++ u-boot-1.2.0-leopard/drivers/nand/nand_base.c	2008-05-20 03:57:42.000000000 -0300
@@ -5,14 +5,14 @@
  *   This is the generic MTD driver for NAND flash devices. It should be
  *   capable of working with almost all NAND chips currently available.
  *   Basic support for AG-AND chips is provided.
- *
+ *   
  *	Additional technical information is available on
  *	http://www.linux-mtd.infradead.org/tech/nand.html
- *
+ *	
  *  Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
  * 		  2002 Thomas Gleixner (tglx@linutronix.de)
  *
- *  02-08-2004  tglx: support for strange chips, which cannot auto increment
+ *  02-08-2004  tglx: support for strange chips, which cannot auto increment 
  *		pages on read / read_oob
  *
  *  03-17-2004  tglx: Check ready before auto increment check. Simon Bayes
@@ -21,16 +21,38 @@
  *		Make reads over block boundaries work too
  *
  *  04-14-2004	tglx: first working version for 2k page size chips
- *
+ *  
  *  05-19-2004  tglx: Basic support for Renesas AG-AND chips
  *
  *  09-24-2004  tglx: add support for hardware controllers (e.g. ECC) shared
  *		among multiple independend devices. Suggestions and initial patch
  *		from Ben Dooks <ben-mtd@fluff.org>
  *
- * Credits:
- *	David Woodhouse for adding multichip support
+ *  12-05-2004	dmarlin: add workaround for Renesas AG-AND chips "disturb" issue.
+ *		Basically, any block not rewritten may lose data when surrounding blocks
+ *		are rewritten many times.  JFFS2 ensures this doesn't happen for blocks 
+ *		it uses, but the Bad Block Table(s) may not be rewritten.  To ensure they
+ *		do not lose data, force them to be rewritten when some of the surrounding
+ *		blocks are erased.  Rather than tracking a specific nearby block (which 
+ *		could itself go bad), use a page address 'mask' to select several blocks 
+ *		in the same area, and rewrite the BBT when any of them are erased.
+ *
+ *  01-03-2005	dmarlin: added support for the device recovery command sequence for Renesas 
+ *		AG-AND chips.  If there was a sudden loss of power during an erase operation,
+ * 		a "device recovery" operation must be performed when power is restored
+ * 		to ensure correct operation.
+ *
+ *  01-20-2005	dmarlin: added support for optional hardware specific callback routine to 
+ *		perform extra error status checks on erase and write failures.  This required
+ *		adding a wrapper function for nand_read_ecc.
  *
+ * 08-20-2005	vwool: suspend/resume added
+ *
+ * 11-01-2005:  vwool: NAND page layouts introduces for HW ECC handling
+ *
+ * Credits:
+ *	David Woodhouse for adding multichip support  
+ *	
  *	Aleph One Ltd. and Toby Churchill Ltd. for supporting the
  *	rework for 2K page size chips
  *
@@ -41,7 +63,7 @@
  *	The AG-AND chips have nice features for speed improvement,
  *	which are not supported yet. Read / program 4 pages in one go.
  *
- * $Id: nand_base.c,v 1.126 2004/12/13 11:22:25 lavinen Exp $
+ * $Id: nand_base.c,v 1.145 2005/05/31 20:32:53 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -50,6 +72,8 @@
  */
 
 /* XXX U-BOOT XXX */
+#define DEBUG(fmt,args...)	printf (fmt ,##args)
+
 #if 0
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -107,23 +131,15 @@
 	.useecc = MTD_NANDECC_AUTOPLACE,
 	.eccbytes = 24,
 	.eccpos = {
-		40, 41, 42, 43, 44, 45, 46, 47,
-		48, 49, 50, 51, 52, 53, 54, 55,
+		40, 41, 42, 43, 44, 45, 46, 47, 
+		48, 49, 50, 51, 52, 53, 54, 55, 
 		56, 57, 58, 59, 60, 61, 62, 63},
 	.oobfree = { {2, 38} }
 };
 
-/* This is used for padding purposes in nand_write_oob */
-static u_char ffchars[] = {
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-};
+/* This is used for padding purposes in nand_write_oob/nand_write_oob_hwecc */
+#define FFCHARS_SIZE		2048
+static u_char ffchars[FFCHARS_SIZE];
 
 /*
  * NAND low-level MTD interface functions
@@ -154,19 +170,19 @@
 static int nand_write_page (struct mtd_info *mtd, struct nand_chip *this, int page, u_char *oob_buf,
 		struct nand_oobinfo *oobsel, int mode);
 #ifdef CONFIG_MTD_NAND_VERIFY_WRITE
-static int nand_verify_pages (struct mtd_info *mtd, struct nand_chip *this, int page, int numpages,
+static int nand_verify_pages (struct mtd_info *mtd, struct nand_chip *this, int page, int numpages, 
 	u_char *oob_buf, struct nand_oobinfo *oobsel, int chipnr, int oobmode);
 #else
 #define nand_verify_pages(...) (0)
 #endif
-
-static void nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state);
+		
+static int nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state);
 
 /**
  * nand_release_device - [GENERIC] release chip
  * @mtd:	MTD device structure
- *
- * Deselect, release chip lock and wake up anyone waiting on the device
+ * 
+ * Deselect, release chip lock and wake up anyone waiting on the device 
  */
 /* XXX U-BOOT XXX */
 #if 0
@@ -176,11 +192,20 @@
 
 	/* De-select the NAND device */
 	this->select_chip(mtd, -1);
-	/* Do we have a hardware controller ? */
+
 	if (this->controller) {
+		/* Release the controller and the chip */
 		spin_lock(&this->controller->lock);
 		this->controller->active = NULL;
+		this->state = FL_READY;
+		wake_up(&this->controller->wq);
 		spin_unlock(&this->controller->lock);
+	} else {
+		/* Release the chip */
+		spin_lock(&this->chip_lock);
+		this->state = FL_READY;
+		wake_up(&this->wq);
+		spin_unlock(&this->chip_lock);
 	}
 	/* Release the chip */
 	spin_lock (&this->chip_lock);
@@ -225,7 +250,7 @@
  * nand_read_byte16 - [DEFAULT] read one byte endianess aware from the chip
  * @mtd:	MTD device structure
  *
- * Default read function for 16bit buswith with
+ * Default read function for 16bit buswith with 
  * endianess conversion
  */
 static u_char nand_read_byte16(struct mtd_info *mtd)
@@ -252,7 +277,7 @@
  * nand_read_word - [DEFAULT] read one word from the chip
  * @mtd:	MTD device structure
  *
- * Default read function for 16bit buswith without
+ * Default read function for 16bit buswith without 
  * endianess conversion
  */
 static u16 nand_read_word(struct mtd_info *mtd)
@@ -266,7 +291,7 @@
  * @mtd:	MTD device structure
  * @word:	data word to write
  *
- * Default write function for 16bit buswith without
+ * Default write function for 16bit buswith without 
  * endianess conversion
  */
 static void nand_write_word(struct mtd_info *mtd, u16 word)
@@ -287,7 +312,7 @@
 	struct nand_chip *this = mtd->priv;
 	switch(chip) {
 	case -1:
-		this->hwcontrol(mtd, NAND_CTL_CLRNCE);
+		this->hwcontrol(mtd, NAND_CTL_CLRNCE);	
 		break;
 	case 0:
 		this->hwcontrol(mtd, NAND_CTL_SETNCE);
@@ -316,7 +341,7 @@
 }
 
 /**
- * nand_read_buf - [DEFAULT] read chip data into buffer
+ * nand_read_buf - [DEFAULT] read chip data into buffer 
  * @mtd:	MTD device structure
  * @buf:	buffer to store date
  * @len:	number of bytes to read
@@ -333,7 +358,7 @@
 }
 
 /**
- * nand_verify_buf - [DEFAULT] Verify chip data against buffer
+ * nand_verify_buf - [DEFAULT] Verify chip data against buffer 
  * @mtd:	MTD device structure
  * @buf:	buffer containing the data to compare
  * @len:	number of bytes to compare
@@ -366,14 +391,14 @@
 	struct nand_chip *this = mtd->priv;
 	u16 *p = (u16 *) buf;
 	len >>= 1;
-
+	
 	for (i=0; i<len; i++)
 		writew(p[i], this->IO_ADDR_W);
-
+		
 }
 
 /**
- * nand_read_buf16 - [DEFAULT] read chip data into buffer
+ * nand_read_buf16 - [DEFAULT] read chip data into buffer 
  * @mtd:	MTD device structure
  * @buf:	buffer to store date
  * @len:	number of bytes to read
@@ -392,7 +417,7 @@
 }
 
 /**
- * nand_verify_buf16 - [DEFAULT] Verify chip data against buffer
+ * nand_verify_buf16 - [DEFAULT] Verify chip data against buffer 
  * @mtd:	MTD device structure
  * @buf:	buffer containing the data to compare
  * @len:	number of bytes to compare
@@ -419,14 +444,14 @@
  * @ofs:	offset from device start
  * @getchip:	0, if the chip is already selected
  *
- * Check, if the block is bad.
+ * Check, if the block is bad. 
  */
 static int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
 {
 	int page, chipnr, res = 0;
 	struct nand_chip *this = mtd->priv;
 	u16 bad;
-
+	
 	if (getchip) {
 		page = (int)(ofs >> this->page_shift);
 		chipnr = (int)(ofs >> this->chip_shift);
@@ -436,26 +461,27 @@
 
 		/* Select the NAND device */
 		this->select_chip(mtd, chipnr);
-	} else
-		page = (int) ofs;
+	} else 
+		page = (int) ofs;	
 
 	if (this->options & NAND_BUSWIDTH_16) {
 		this->cmdfunc (mtd, NAND_CMD_READOOB, this->badblockpos & 0xFE, page & this->pagemask);
 		bad = cpu_to_le16(this->read_word(mtd));
 		if (this->badblockpos & 0x1)
-			bad >>= 1;
+			bad >>= 8;
 		if ((bad & 0xFF) != 0xff)
 			res = 1;
 	} else {
+	  printk (KERN_WARNING "nand_block_bad badblockpos=%d\n",this->badblockpos);
 		this->cmdfunc (mtd, NAND_CMD_READOOB, this->badblockpos, page & this->pagemask);
 		if (this->read_byte(mtd) != 0xff)
 			res = 1;
 	}
-
+		
 	if (getchip) {
 		/* Deselect and wake up anyone waiting on the device */
 		nand_release_device(mtd);
-	}
+	}	
 
 	return res;
 }
@@ -474,33 +500,34 @@
 	u_char buf[2] = {0, 0};
 	size_t	retlen;
 	int block;
-
+	
 	/* Get block number */
 	block = ((int) ofs) >> this->bbt_erase_shift;
-	this->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
+	if (this->bbt)
+		this->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
 
 	/* Do we have a flash based bad block table ? */
 	if (this->options & NAND_USE_FLASH_BBT)
 		return nand_update_bbt (mtd, ofs);
-
+		
 	/* We write two bytes, so we dont have to mess with 16 bit access */
 	ofs += mtd->oobsize + (this->badblockpos & ~0x01);
 	return nand_write_oob (mtd, ofs , 2, &retlen, buf);
 }
 
-/**
+/** 
  * nand_check_wp - [GENERIC] check if the chip is write protected
  * @mtd:	MTD device structure
- * Check, if the device is write protected
+ * Check, if the device is write protected 
  *
- * The function expects, that the device is already selected
+ * The function expects, that the device is already selected 
  */
 static int nand_check_wp (struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
 	/* Check the WP bit */
 	this->cmdfunc (mtd, NAND_CMD_STATUS, -1, -1);
-	return (this->read_byte(mtd) & 0x80) ? 0 : 1;
+	return (this->read_byte(mtd) & NAND_STATUS_WP) ? 0 : 1; 
 }
 
 /**
@@ -516,10 +543,10 @@
 static int nand_block_checkbad (struct mtd_info *mtd, loff_t ofs, int getchip, int allowbbt)
 {
 	struct nand_chip *this = mtd->priv;
-
+	
 	if (!this->bbt)
 		return this->block_bad(mtd, ofs, getchip);
-
+	
 	/* Return info from the table */
 	return nand_isbad_bbt (mtd, ofs, allowbbt);
 }
@@ -584,13 +611,13 @@
 		/* Latch in address */
 		this->hwcontrol(mtd, NAND_CTL_CLRALE);
 	}
-
-	/*
-	 * program and erase have their own busy handlers
+	
+	/* 
+	 * program and erase have their own busy handlers 
 	 * status and sequential in needs no delay
 	*/
 	switch (command) {
-
+			
 	case NAND_CMD_PAGEPROG:
 	case NAND_CMD_ERASE1:
 	case NAND_CMD_ERASE2:
@@ -599,27 +626,26 @@
 		return;
 
 	case NAND_CMD_RESET:
-		if (this->dev_ready)
+		if (this->dev_ready)	
 			break;
 		udelay(this->chip_delay);
 		this->hwcontrol(mtd, NAND_CTL_SETCLE);
 		this->write_byte(mtd, NAND_CMD_STATUS);
 		this->hwcontrol(mtd, NAND_CTL_CLRCLE);
-		while ( !(this->read_byte(mtd) & 0x40));
+		while ( !(this->read_byte(mtd) & NAND_STATUS_READY));
 		return;
 
-	/* This applies to read commands */
+	/* This applies to read commands */	
 	default:
-		/*
+		/* 
 		 * If we don't have access to the busy pin, we apply the given
 		 * command delay
 		*/
 		if (!this->dev_ready) {
 			udelay (this->chip_delay);
 			return;
-		}
+		}	
 	}
-
 	/* Apply this short delay always to ensure that we do wait tWB in
 	 * any case on any machine. */
 	ndelay (100);
@@ -648,12 +674,12 @@
 		column += mtd->oobblock;
 		command = NAND_CMD_READ0;
 	}
-
-
+	
+		
 	/* Begin command latch cycle */
 	this->hwcontrol(mtd, NAND_CTL_SETCLE);
 	/* Write out the command to the device. */
-	this->write_byte(mtd, command);
+	this->write_byte(mtd, (command & 0xff));
 	/* End command latch cycle */
 	this->hwcontrol(mtd, NAND_CTL_CLRCLE);
 
@@ -667,7 +693,7 @@
 				column >>= 1;
 			this->write_byte(mtd, column & 0xff);
 			this->write_byte(mtd, column >> 8);
-		}
+		}	
 		if (page_addr != -1) {
 			this->write_byte(mtd, (unsigned char) (page_addr & 0xff));
 			this->write_byte(mtd, (unsigned char) ((page_addr >> 8) & 0xff));
@@ -678,30 +704,41 @@
 		/* Latch in address */
 		this->hwcontrol(mtd, NAND_CTL_CLRALE);
 	}
-
-	/*
-	 * program and erase have their own busy handlers
-	 * status and sequential in needs no delay
-	*/
+	
+	/* 
+	 * program and erase have their own busy handlers 
+	 * status, sequential in, and deplete1 need no delay
+	 */
 	switch (command) {
-
+			
 	case NAND_CMD_CACHEDPROG:
 	case NAND_CMD_PAGEPROG:
 	case NAND_CMD_ERASE1:
 	case NAND_CMD_ERASE2:
 	case NAND_CMD_SEQIN:
 	case NAND_CMD_STATUS:
+	case NAND_CMD_DEPLETE1:
 		return;
 
+	/* 
+	 * read error status commands require only a short delay
+	 */
+	case NAND_CMD_STATUS_ERROR:
+	case NAND_CMD_STATUS_ERROR0:
+	case NAND_CMD_STATUS_ERROR1:
+	case NAND_CMD_STATUS_ERROR2:
+	case NAND_CMD_STATUS_ERROR3:
+		udelay(this->chip_delay);
+		return;
 
 	case NAND_CMD_RESET:
-		if (this->dev_ready)
+		if (this->dev_ready)	
 			break;
 		udelay(this->chip_delay);
 		this->hwcontrol(mtd, NAND_CTL_SETCLE);
 		this->write_byte(mtd, NAND_CMD_STATUS);
 		this->hwcontrol(mtd, NAND_CTL_CLRCLE);
-		while ( !(this->read_byte(mtd) & 0x40));
+		while ( !(this->read_byte(mtd) & NAND_STATUS_READY));
 		return;
 
 	case NAND_CMD_READ0:
@@ -712,23 +749,23 @@
 		/* End command latch cycle */
 		this->hwcontrol(mtd, NAND_CTL_CLRCLE);
 		/* Fall through into ready check */
-
-	/* This applies to read commands */
+		
+	/* This applies to read commands */	
 	default:
-		/*
+		/* 
 		 * If we don't have access to the busy pin, we apply the given
 		 * command delay
 		*/
 		if (!this->dev_ready) {
 			udelay (this->chip_delay);
 			return;
-		}
+		}	
 	}
 
 	/* Apply this short delay always to ensure that we do wait tWB in
 	 * any case on any machine. */
 	ndelay (100);
-	/* wait until command is processed */
+
 	while (!this->dev_ready(mtd));
 }
 
@@ -736,7 +773,7 @@
  * nand_get_device - [GENERIC] Get chip for selected access
  * @this:	the nand chip descriptor
  * @mtd:	MTD device structure
- * @new_state:	the state which is requested
+ * @new_state:	the state which is requested 
  *
  * Get the device and lock it for exclusive access
  */
@@ -744,41 +781,42 @@
 #if 0
 static void nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state)
 {
-	struct nand_chip *active = this;
-
+	struct nand_chip *active;
+	spinlock_t *lock;
+	wait_queue_head_t *wq;
 	DECLARE_WAITQUEUE (wait, current);
 
-	/*
-	 * Grab the lock and see if the device is available
-	*/
+	lock = (this->controller) ? &this->controller->lock : &this->chip_lock;
+	wq = (this->controller) ? &this->controller->wq : &this->wq;
 retry:
+	active = this;
+	spin_lock(lock);
+
 	/* Hardware controller shared among independend devices */
 	if (this->controller) {
-		spin_lock (&this->controller->lock);
 		if (this->controller->active)
 			active = this->controller->active;
 		else
 			this->controller->active = this;
-		spin_unlock (&this->controller->lock);
 	}
-
-	if (active == this) {
-		spin_lock (&this->chip_lock);
-		if (this->state == FL_READY) {
-			this->state = new_state;
-			spin_unlock (&this->chip_lock);
-			return;
-		}
+	if (active == this && this->state == FL_READY) {
+		this->state = new_state;
+		spin_unlock(lock);
+		return 0;
 	}
-	set_current_state (TASK_UNINTERRUPTIBLE);
-	add_wait_queue (&active->wq, &wait);
-	spin_unlock (&active->chip_lock);
-	schedule ();
-	remove_wait_queue (&active->wq, &wait);
+	if (new_state == FL_PM_SUSPENDED) {
+		spin_unlock(lock);
+		return (this->state == FL_PM_SUSPENDED) ? 0 : -EAGAIN;
+	}
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	add_wait_queue(wq, &wait);
+	spin_unlock(lock);
+	schedule();
+	remove_wait_queue(wq, &wait);
 	goto retry;
 }
 #else
-static void nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state) {}
+static int nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state) {}
 #endif
 
 /**
@@ -788,7 +826,7 @@
  * @state:	state to select the max. timeout value
  *
  * Wait for command done. This applies to erase and program only
- * Erase can take up to 400ms and program up to 20ms according to
+ * Erase can take up to 400ms and program up to 20ms according to 
  * general NAND and SmartMedia specs
  *
 */
@@ -796,9 +834,10 @@
 #if 0
 static int nand_wait(struct mtd_info *mtd, struct nand_chip *this, int state)
 {
+
 	unsigned long	timeo = jiffies;
 	int	status;
-
+	
 	if (state == FL_ERASING)
 		 timeo += (HZ * 400) / 1000;
 	else
@@ -810,27 +849,25 @@
 
 	if ((state == FL_ERASING) && (this->options & NAND_IS_AND))
 		this->cmdfunc (mtd, NAND_CMD_STATUS_MULTI, -1, -1);
-	else
+	else	
 		this->cmdfunc (mtd, NAND_CMD_STATUS, -1, -1);
 
-	while (time_before(jiffies, timeo)) {
+	while (time_before(jiffies, timeo)) {		
 		/* Check, if we were interrupted */
 		if (this->state != state)
 			return 0;
 
 		if (this->dev_ready) {
 			if (this->dev_ready(mtd))
-				break;
+				break;	
 		} else {
 			if (this->read_byte(mtd) & NAND_STATUS_READY)
 				break;
 		}
-		yield ();
+		cond_resched();
 	}
 	status = (int) this->read_byte(mtd);
 	return status;
-
-	return 0;
 }
 #else
 static int nand_wait(struct mtd_info *mtd, struct nand_chip *this, int state)
@@ -887,19 +924,19 @@
  *
  * Cached programming is not supported yet.
  */
-static int nand_write_page (struct mtd_info *mtd, struct nand_chip *this, int page,
+static int nand_write_page (struct mtd_info *mtd, struct nand_chip *this, int page, 
 	u_char *oob_buf,  struct nand_oobinfo *oobsel, int cached)
 {
-	int 	i, status;
-	u_char	ecc_code[32];
+	int 	i, oobidx, status;
+	u_char	ecc_code[40];
 	int	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
-	uint  	*oob_config = oobsel->eccpos;
+	int  	*oob_config = oobsel->eccpos;
 	int	datidx = 0, eccidx = 0, eccsteps = this->eccsteps;
 	int	eccbytes = 0;
-
+	
 	/* FIXME: Enable cached programming */
 	cached = 0;
-
+	
 	/* Send command to begin auto page programming */
 	this->cmdfunc (mtd, NAND_CMD_SEQIN, 0x00, page);
 
@@ -908,9 +945,44 @@
 	/* No ecc, write all */
 	case NAND_ECC_NONE:
 		printk (KERN_WARNING "Writing data without ECC to NAND-FLASH is not recommended\n");
-		this->write_buf(mtd, this->data_poi, mtd->oobblock);
-		break;
+		if (!this->layout) {
+			this->write_buf(mtd, this->data_poi, mtd->oobblock);
+			this->write_buf(mtd, oob_buf, mtd->oobsize);
+			break;
+		}
 
+		/*
+		 * Since we have a page layout, we must observe the layout to
+		 * position data and oob correctly even though we aren't
+		 * calculating ECC.
+		 */
+		for (oobidx = 0; eccsteps; eccsteps--) {
+			int j = 0;
+			for (; this->layout[j].length; j++) {
+				int len = this->layout[j].length;
+				int oidx = oobidx;
+				switch (this->layout[j].type) {
+				case ITEM_TYPE_DATA:
+					this->write_buf(mtd, &this->data_poi[datidx], this->layout[j].length);
+					datidx += len;
+					break;
+				case ITEM_TYPE_ECC:
+				case ITEM_TYPE_OOB:
+					if (this->options & NAND_BUSWIDTH_16) {
+						if (oidx & 1) {
+							oidx--;
+							len++;
+						}
+						if (len & 1)
+							len--;
+					}
+					this->write_buf(mtd, &oob_buf[oidx], len);
+					oobidx += len;
+					break;
+				}
+			}
+		}
+		break;
 	/* Software ecc 3/256, write all */
 	case NAND_ECC_SOFT:
 		for (; eccsteps; eccsteps--) {
@@ -920,49 +992,106 @@
 			datidx += this->eccsize;
 		}
 		this->write_buf(mtd, this->data_poi, mtd->oobblock);
+		this->write_buf(mtd, oob_buf, mtd->oobsize);
 		break;
 	default:
 		eccbytes = this->eccbytes;
-		for (; eccsteps; eccsteps--) {
-			/* enable hardware ecc logic for write */
-			this->enable_hwecc(mtd, NAND_ECC_WRITE);
-			this->write_buf(mtd, &this->data_poi[datidx], this->eccsize);
-			this->calculate_ecc(mtd, &this->data_poi[datidx], ecc_code);
-			for (i = 0; i < eccbytes; i++, eccidx++)
-				oob_buf[oob_config[eccidx]] = ecc_code[i];
-			/* If the hardware ecc provides syndromes then
-			 * the ecc code must be written immidiately after
-			 * the data bytes (words) */
+
+		if (! this->layout) {
+			for (; eccsteps; eccsteps--) {
+				/* enable hardware ecc logic for write */
+				this->enable_hwecc(mtd, NAND_ECC_WRITE);
+				this->write_buf(mtd, &this->data_poi[datidx], this->eccsize);
+				this->calculate_ecc(mtd, &this->data_poi[datidx], ecc_code);
+				for (i = 0; i < eccbytes; i++, eccidx++)
+					oob_buf[oob_config[eccidx]] = ecc_code[i];
+				/* If the hardware ecc provides syndromes then
+				 * the ecc code must be written immidiately after
+				 * the data bytes (words) */
+				if (this->options & NAND_HWECC_SYNDROME)
+					this->write_buf(mtd, ecc_code, eccbytes);
+				datidx += this->eccsize;
+			}
+
 			if (this->options & NAND_HWECC_SYNDROME)
-				this->write_buf(mtd, ecc_code, eccbytes);
-			datidx += this->eccsize;
+				this->write_buf(mtd, &oob_buf[oobsel->eccbytes], mtd->oobsize -
+						oobsel->eccbytes);
+			else
+				this->write_buf(mtd, oob_buf, mtd->oobsize);
+
+
+			break;
+		}
+
+		for (oobidx = 0; eccsteps; eccsteps--) {
+			int j = 0, last_datidx = datidx, last_oobidx;
+			for (; this->layout[j].length; j++) {
+				int len = this->layout[j].length;
+				int oidx = oobidx;
+				switch (this->layout[j].type) {
+				case ITEM_TYPE_DATA:
+					this->enable_hwecc(mtd, NAND_ECC_WRITE);
+					this->write_buf(mtd, &this->data_poi[datidx], this->layout[j].length);
+					datidx += len;
+					break;
+				case ITEM_TYPE_ECC:
+					this->enable_hwecc(mtd, NAND_ECC_WRITESYN);
+					this->calculate_ecc(mtd, &this->data_poi[last_datidx], &ecc_code[eccidx]);
+					for (last_oobidx = oobidx; oobidx < last_oobidx + len; oobidx++, eccidx++)
+						oob_buf[oobidx] = ecc_code[eccidx];
+					if (this->options & NAND_BUSWIDTH_16) {
+						if (oidx & 1) {
+							oidx--;
+							len++;
+						}
+						if (len & 1)
+							len--;
+					}
+					this->write_buf(mtd, &oob_buf[oidx], len);
+					break;
+				case ITEM_TYPE_OOB:
+					this->enable_hwecc(mtd, NAND_ECC_WRITEOOB);
+					if (this->options & NAND_BUSWIDTH_16) {
+						if (oidx & 1) {
+							oidx--;
+							len++;
+						}
+						if (len & 1)
+							len--;
+					}
+					this->write_buf(mtd, &oob_buf[oidx], len);
+					oobidx += len;
+					break;
+				}
+			}
+					
 		}
 		break;
 	}
-
-	/* Write out OOB data */
-	if (this->options & NAND_HWECC_SYNDROME)
-		this->write_buf(mtd, &oob_buf[oobsel->eccbytes], mtd->oobsize - oobsel->eccbytes);
-	else
-		this->write_buf(mtd, oob_buf, mtd->oobsize);
-
+										
 	/* Send command to actually program the data */
 	this->cmdfunc (mtd, cached ? NAND_CMD_CACHEDPROG : NAND_CMD_PAGEPROG, -1, -1);
 
 	if (!cached) {
 		/* call wait ready function */
 		status = this->waitfunc (mtd, this, FL_WRITING);
+
+		/* See if operation failed and additional status checks are available */
+		if ((status & NAND_STATUS_FAIL) && (this->errstat)) {
+			status = this->errstat(mtd, this, FL_WRITING, status, page);
+		}
+
 		/* See if device thinks it succeeded */
-		if (status & 0x01) {
+		if (status & NAND_STATUS_FAIL) {
 			DEBUG (MTD_DEBUG_LEVEL0, "%s: " "Failed write, page 0x%08x, ", __FUNCTION__, page);
 			return -EIO;
 		}
 	} else {
 		/* FIXME: Implement cached programming ! */
 		/* wait until cache is ready*/
-		/* status = this->waitfunc (mtd, this, FL_CACHEDRPG); */
+		// status = this->waitfunc (mtd, this, FL_CACHEDRPG);
 	}
-	return 0;
+	return 0;	
 }
 
 #ifdef CONFIG_MTD_NAND_VERIFY_WRITE
@@ -978,19 +1107,19 @@
  * @oobmode:	1 = full buffer verify, 0 = ecc only
  *
  * The NAND device assumes that it is always writing to a cleanly erased page.
- * Hence, it performs its internal write verification only on bits that
+ * Hence, it performs its internal write verification only on bits that 
  * transitioned from 1 to 0. The device does NOT verify the whole page on a
- * byte by byte basis. It is possible that the page was not completely erased
- * or the page is becoming unusable due to wear. The read with ECC would catch
- * the error later when the ECC page check fails, but we would rather catch
+ * byte by byte basis. It is possible that the page was not completely erased 
+ * or the page is becoming unusable due to wear. The read with ECC would catch 
+ * the error later when the ECC page check fails, but we would rather catch 
  * it early in the page write stage. Better to write no data than invalid data.
  */
-static int nand_verify_pages (struct mtd_info *mtd, struct nand_chip *this, int page, int numpages,
+static int nand_verify_pages (struct mtd_info *mtd, struct nand_chip *this, int page, int numpages, 
 	u_char *oob_buf, struct nand_oobinfo *oobsel, int chipnr, int oobmode)
 {
 	int 	i, j, datidx = 0, oobofs = 0, res = -EIO;
 	int	eccsteps = this->eccsteps;
-	int	hweccbytes;
+	int	hweccbytes; 
 	u_char 	oobdata[64];
 
 	hweccbytes = (this->options & NAND_HWECC_SYNDROME) ? (oobsel->eccbytes / eccsteps) : 0;
@@ -1030,7 +1159,7 @@
 
 			if (oobsel->useecc != MTD_NANDECC_OFF && !hweccbytes) {
 				int ecccnt = oobsel->eccbytes;
-
+		
 				for (i = 0; i < ecccnt; i++) {
 					int idx = oobsel->eccpos[i];
 					if (oobdata[idx] != oob_buf[oobofs + idx] ) {
@@ -1040,20 +1169,20 @@
 						goto out;
 					}
 				}
-			}
+			}	
 		}
 		oobofs += mtd->oobsize - hweccbytes * eccsteps;
 		page++;
 		numpages--;
 
-		/* Apply delay or wait for ready/busy pin
+		/* Apply delay or wait for ready/busy pin 
 		 * Do this before the AUTOINCR check, so no problems
 		 * arise if a chip which does auto increment
 		 * is marked as NOAUTOINCR by the board driver.
 		 * Do this also before returning, so the chip is
 		 * ready for the next command.
 		*/
-		if (!this->dev_ready)
+		if (!this->dev_ready) 
 			udelay (this->chip_delay);
 		else
 			while (!this->dev_ready(mtd));
@@ -1061,40 +1190,41 @@
 		/* All done, return happy */
 		if (!numpages)
 			return 0;
-
-
-		/* Check, if the chip supports auto page increment */
+		
+			
+		/* Check, if the chip supports auto page increment */ 
 		if (!NAND_CANAUTOINCR(this))
 			this->cmdfunc (mtd, NAND_CMD_READ0, 0x00, page);
 	}
-	/*
+	/* 
 	 * Terminate the read command. We come here in case of an error
 	 * So we must issue a reset command.
 	 */
-out:
+out:	 
 	this->cmdfunc (mtd, NAND_CMD_RESET, -1, -1);
 	return res;
 }
 #endif
 
 /**
- * nand_read - [MTD Interface] MTD compability function for nand_read_ecc
+ * nand_read - [MTD Interface] MTD compability function for nand_do_read_ecc
  * @mtd:	MTD device structure
  * @from:	offset to read from
  * @len:	number of bytes to read
  * @retlen:	pointer to variable to store the number of read bytes
  * @buf:	the databuffer to put data
  *
- * This function simply calls nand_read_ecc with oob buffer and oobsel = NULL
-*/
+ * This function simply calls nand_do_read_ecc with oob buffer and oobsel = NULL
+ * and flags = 0xff
+ */
 static int nand_read (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
 {
-	return nand_read_ecc (mtd, from, len, retlen, buf, NULL, NULL);
+	return nand_do_read_ecc (mtd, from, len, retlen, buf, NULL, &mtd->oobinfo, 0xff);
 }
 
 
 /**
- * nand_read_ecc - [MTD Interface] Read data with ECC
+ * nand_read_ecc - [MTD Interface] MTD compability function for nand_do_read_ecc
  * @mtd:	MTD device structure
  * @from:	offset to read from
  * @len:	number of bytes to read
@@ -1103,20 +1233,47 @@
  * @oob_buf:	filesystem supplied oob data buffer
  * @oobsel:	oob selection structure
  *
- * NAND read with ECC
+ * This function simply calls nand_do_read_ecc with flags = 0xff
  */
 static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
 			  size_t * retlen, u_char * buf, u_char * oob_buf, struct nand_oobinfo *oobsel)
 {
+	/* use userspace supplied oobinfo, if zero */
+	if (oobsel == NULL)
+		oobsel = &mtd->oobinfo;
+	return nand_do_read_ecc(mtd, from, len, retlen, buf, oob_buf, oobsel, 0xff);
+}
+
+
+/**
+ * nand_do_read_ecc - [MTD Interface] Read data with ECC
+ * @mtd:	MTD device structure
+ * @from:	offset to read from
+ * @len:	number of bytes to read
+ * @retlen:	pointer to variable to store the number of read bytes
+ * @buf:	the databuffer to put data
+ * @oob_buf:	filesystem supplied oob data buffer (can be NULL)
+ * @oobsel:	oob selection structure
+ * @flags:	flag to indicate if nand_get_device/nand_release_device should be preformed
+ *		and how many corrected error bits are acceptable:
+ *		  bits 0..7 - number of tolerable errors
+ *		  bit  8    - 0 == do not get/release chip, 1 == get/release chip
+ *
+ * NAND read with ECC
+ */
+int nand_do_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+			     size_t * retlen, u_char * buf, u_char * oob_buf, 
+			     struct nand_oobinfo *oobsel, int flags)
+{
+
 	int i, j, col, realpage, page, end, ecc, chipnr, sndcmd = 1;
-	int read = 0, oob = 0, ecc_status = 0, ecc_failed = 0;
+	int read = 0, oob = 0, oobidx, ecc_status = 0, ecc_failed = 0, eccidx;
 	struct nand_chip *this = mtd->priv;
 	u_char *data_poi, *oob_data = oob_buf;
 	u_char ecc_calc[32];
 	u_char ecc_code[32];
-	int eccmode, eccsteps;
-	unsigned *oob_config;
-	int	datidx;
+        int eccmode, eccsteps;
+	int	*oob_config, datidx;
 	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
 	int	eccbytes;
 	int	compareecc = 1;
@@ -1133,16 +1290,13 @@
 	}
 
 	/* Grab the lock and see if the device is available */
-	nand_get_device (this, mtd ,FL_READING);
-
-	/* use userspace supplied oobinfo, if zero */
-	if (oobsel == NULL)
-		oobsel = &mtd->oobinfo;
+	if (flags & NAND_GET_DEVICE)
+		nand_get_device (this, mtd, FL_READING);
 
 	/* Autoplace of oob data ? Use the default placement scheme */
 	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE)
 		oobsel = this->autooob;
-
+		
 	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
 	oob_config = oobsel->eccpos;
 
@@ -1160,28 +1314,28 @@
 	end = mtd->oobblock;
 	ecc = this->eccsize;
 	eccbytes = this->eccbytes;
-
+	
 	if ((eccmode == NAND_ECC_NONE) || (this->options & NAND_HWECC_SYNDROME))
 		compareecc = 0;
 
 	oobreadlen = mtd->oobsize;
-	if (this->options & NAND_HWECC_SYNDROME)
+	if (this->options & NAND_HWECC_SYNDROME) 
 		oobreadlen -= oobsel->eccbytes;
 
 	/* Loop until all data read */
 	while (read < len) {
-
+		
 		int aligned = (!col && (len - read) >= end);
-		/*
+		/* 
 		 * If the read is not page aligned, we have to read into data buffer
 		 * due to ecc, else we read into return buffer direct
 		 */
 		if (aligned)
 			data_poi = &buf[read];
-		else
+		else 
 			data_poi = this->data_buf;
-
-		/* Check, if we have this page in the buffer
+		
+		/* Check, if we have this page in the buffer 
 		 *
 		 * FIXME: Make it work when we must provide oob data too,
 		 * check the usage of data_buf oob field
@@ -1197,7 +1351,7 @@
 		if (sndcmd) {
 			this->cmdfunc (mtd, NAND_CMD_READ0, 0x00, page);
 			sndcmd = 0;
-		}
+		}	
 
 		/* get oob area, if we have no oob buffer from fs-driver */
 		if (!oob_buf || oobsel->useecc == MTD_NANDECC_AUTOPLACE ||
@@ -1205,7 +1359,7 @@
 			oob_data = &this->data_buf[end];
 
 		eccsteps = this->eccsteps;
-
+		
 		switch (eccmode) {
 		case NAND_ECC_NONE: {	/* No ECC, Read in a page */
 /* XXX U-BOOT XXX */
@@ -1218,50 +1372,151 @@
 #else
 			puts("Reading data from NAND FLASH without ECC is not recommended\n");
 #endif
-			this->read_buf(mtd, data_poi, end);
+			if (!this->layout) {
+				this->read_buf(mtd, data_poi, end);
+				break;
+			}
+
+			/*
+			 * Since we have a page layout, we must observe the
+			 * layout to position data and oob correctly even though
+			 * we aren't calculating ECC.
+			 */
+			for (oobidx = 0, datidx = 0; eccsteps; eccsteps--) {
+				for (j = 0; this->layout[j].length; j++) {
+					int len = this->layout[j].length;
+					int oidx = oobidx;
+					switch (this->layout[j].type) {
+					case ITEM_TYPE_DATA:
+						DEBUG (MTD_DEBUG_LEVEL3, "%s: reading %d bytes of data\n", __FUNCTION__, this->layout[j].length);
+						this->read_buf(mtd, &data_poi[datidx], len);
+						datidx += this->layout[j].length;
+						break;
+					case ITEM_TYPE_ECC:
+					case ITEM_TYPE_OOB:
+						DEBUG (MTD_DEBUG_LEVEL3, "%s: reading %d oob bytes\n", __FUNCTION__, this->layout[j].length);
+						if (this->options & NAND_BUSWIDTH_16) {
+							if (oidx & 1) {
+								oidx--;
+								len++;
+							}
+							if (len & 1)
+								len--;
+						}
+						this->read_buf(mtd, &oob_data[oidx], len);
+						oobidx += this->layout[j].length;
+						break;
+					}
+				}
+			}
 			break;
 		}
-
 		case NAND_ECC_SOFT:	/* Software ECC 3/256: Read in a page + oob data */
 			this->read_buf(mtd, data_poi, end);
-			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=3, datidx += ecc)
+			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=3, datidx += ecc) 
 				this->calculate_ecc(mtd, &data_poi[datidx], &ecc_calc[i]);
-			break;
+			this->read_buf(mtd, &oob_data[mtd->oobsize - oobreadlen], oobreadlen);
+			break;	
 
 		default:
-			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=eccbytes, datidx += ecc) {
-				this->enable_hwecc(mtd, NAND_ECC_READ);
-				this->read_buf(mtd, &data_poi[datidx], ecc);
+			if (! this->layout) {
+				for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=eccbytes, datidx += ecc) {
+					this->enable_hwecc(mtd, NAND_ECC_READ);
+					this->read_buf(mtd, &data_poi[datidx], ecc);
 
-				/* HW ecc with syndrome calculation must read the
-				 * syndrome from flash immidiately after the data */
-				if (!compareecc) {
-					/* Some hw ecc generators need to know when the
-					 * syndrome is read from flash */
-					this->enable_hwecc(mtd, NAND_ECC_READSYN);
-					this->read_buf(mtd, &oob_data[i], eccbytes);
-					/* We calc error correction directly, it checks the hw
-					 * generator for an error, reads back the syndrome and
-					 * does the error correction on the fly */
-					if (this->correct_data(mtd, &data_poi[datidx], &oob_data[i], &ecc_code[i]) == -1) {
-						DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: "
-							"Failed ECC read, page 0x%08x on chip %d\n", page, chipnr);
-						ecc_failed++;
+					/* HW ecc with syndrome calculation must read the
+					 * syndrome from flash immidiately after the data */
+					if (!compareecc) {
+						/* Some hw ecc generators need to know when the
+						 * syndrome is read from flash */
+						this->enable_hwecc(mtd, NAND_ECC_READSYN);
+						this->read_buf(mtd, &oob_data[i], eccbytes);
+						/* We calc error correction directly, it checks the hw
+						 * generator for an error, reads back the syndrome and
+						 * does the error correction on the fly */
+						ecc_status = this->correct_data(mtd, &data_poi[datidx], &oob_data[i], &ecc_code[i]);
+						if ((ecc_status == -1) || (ecc_status > (flags & 0xff))) {
+							DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: " 
+							       "Failed ECC read, page 0x%08x on chip %d\n", page, chipnr);
+							ecc_failed++;
+						}
+					} else {
+						this->calculate_ecc(mtd, &data_poi[datidx], &ecc_calc[i]);
+					}	
+				}
+
+				this->read_buf(mtd, &oob_data[mtd->oobsize - oobreadlen], oobreadlen);
+
+				break;
+			}				
+
+			for (oobidx = 0, datidx = 0, eccidx = 0; eccsteps; eccsteps--) {
+				int last_datidx = datidx, last_oobidx = oobidx;
+				for (j = 0; this->layout[j].length; j++) {
+					int len = this->layout[j].length;
+					int oidx = oobidx;
+					switch (this->layout[j].type) {
+					case ITEM_TYPE_DATA:
+						DEBUG (MTD_DEBUG_LEVEL3, "%s: reading %d bytes of data\n", __FUNCTION__, this->layout[j].length);
+						this->enable_hwecc(mtd, NAND_ECC_READ);
+						this->read_buf(mtd, &data_poi[datidx], len);
+						datidx += this->layout[j].length;
+						break;
+
+					case ITEM_TYPE_ECC:
+						DEBUG (MTD_DEBUG_LEVEL3, "%s: reading %d ecc bytes\n", __FUNCTION__, this->layout[j].length);
+						/* let the particular driver decide whether to read ECC */
+						this->enable_hwecc(mtd, NAND_ECC_READSYN);
+						if (this->options & NAND_BUSWIDTH_16) {
+							if (oidx & 1) {
+								oidx--;
+								len++;
+							}
+							if (len & 1)
+								len--;
+						}
+
+						this->read_buf(mtd, &oob_data[oidx], len);
+						if (!compareecc) {
+							/* We calc error correction directly, it checks the hw
+							 * generator for an error, reads back the syndrome and
+							 * does the error correction on the fly */
+							ecc_status = this->correct_data(mtd, &data_poi[last_datidx], &oob_data[last_oobidx], &ecc_code[eccidx]);
+							if ((ecc_status == -1) || (ecc_status > (flags & 0xff))) {
+								DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: "
+									"Failed ECC read, page 0x%08x on chip %d\n", page, chipnr);
+								ecc_failed++;
+							}
+						} else
+							this->calculate_ecc(mtd, &data_poi[last_datidx], &ecc_calc[eccidx]);
+						oobidx += this->layout[j].length;
+						eccidx += this->layout[j].length;
+						break;
+					case ITEM_TYPE_OOB:
+						DEBUG (MTD_DEBUG_LEVEL3, "%s: reading %d free oob bytes\n", __FUNCTION__, this->layout[j].length);
+						this->enable_hwecc(mtd, NAND_ECC_READOOB);
+						if (this->options & NAND_BUSWIDTH_16) {
+							if (oidx & 1) {
+								oidx--;
+								len++;
+							}
+							if (len & 1)
+								len--;
+						}
+
+						this->read_buf(mtd, &oob_data[oidx], len);
+						oobidx += this->layout[j].length;
+						break;
 					}
-				} else {
-					this->calculate_ecc(mtd, &data_poi[datidx], &ecc_calc[i]);
 				}
 			}
-			break;
+			break;						
 		}
 
-		/* read oobdata */
-		this->read_buf(mtd, &oob_data[mtd->oobsize - oobreadlen], oobreadlen);
-
 		/* Skip ECC check, if not requested (ECC_NONE or HW_ECC with syndromes) */
 		if (!compareecc)
-			goto readoob;
-
+			goto readoob;	
+		
 		/* Pick the ECC bytes out of the oob data */
 		for (j = 0; j < oobsel->eccbytes; j++)
 			ecc_code[j] = oob_data[oob_config[j]];
@@ -1269,24 +1524,24 @@
 		/* correct data, if neccecary */
 		for (i = 0, j = 0, datidx = 0; i < this->eccsteps; i++, datidx += ecc) {
 			ecc_status = this->correct_data(mtd, &data_poi[datidx], &ecc_code[j], &ecc_calc[j]);
-
+			
 			/* Get next chunk of ecc bytes */
 			j += eccbytes;
-
-			/* Check, if we have a fs supplied oob-buffer,
+			
+			/* Check, if we have a fs supplied oob-buffer, 
 			 * This is the legacy mode. Used by YAFFS1
 			 * Should go away some day
 			 */
-			if (oob_buf && oobsel->useecc == MTD_NANDECC_PLACE) {
+			if (oob_buf && oobsel->useecc == MTD_NANDECC_PLACE) { 
 				int *p = (int *)(&oob_data[mtd->oobsize]);
 				p[i] = ecc_status;
 			}
-
-			if (ecc_status == -1) {
+			
+			if ((ecc_status == -1) || (ecc_status > (flags & 0xff))) {	
 				DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: " "Failed ECC read, page 0x%08x\n", page);
 				ecc_failed++;
 			}
-		}
+		}		
 
 	readoob:
 		/* check, if we have a fs supplied oob-buffer */
@@ -1296,13 +1551,12 @@
 			case MTD_NANDECC_AUTOPLACE:
 			case MTD_NANDECC_AUTOPL_USR:
 				/* Walk through the autoplace chunks */
-				for (i = 0, j = 0; j < mtd->oobavail; i++) {
+				for (i = 0; oobsel->oobfree[i][1]; i++) {
 					int from = oobsel->oobfree[i][0];
 					int num = oobsel->oobfree[i][1];
 					memcpy(&oob_buf[oob], &oob_data[from], num);
-					j+= num;
+					oob += num;
 				}
-				oob += mtd->oobavail;
 				break;
 			case MTD_NANDECC_PLACE:
 				/* YAFFS1 legacy mode */
@@ -1313,25 +1567,25 @@
 		}
 	readdata:
 		/* Partial page read, transfer data into fs buffer */
-		if (!aligned) {
+		if (!aligned) { 
 			for (j = col; j < end && read < len; j++)
 				buf[read++] = data_poi[j];
-			this->pagebuf = realpage;
-		} else
+			this->pagebuf = realpage;	
+		} else		
 			read += mtd->oobblock;
 
-		/* Apply delay or wait for ready/busy pin
+		/* Apply delay or wait for ready/busy pin 
 		 * Do this before the AUTOINCR check, so no problems
 		 * arise if a chip which does auto increment
 		 * is marked as NOAUTOINCR by the board driver.
 		*/
-		if (!this->dev_ready)
+		if (!this->dev_ready) 
 			udelay (this->chip_delay);
 		else
-			while (!this->dev_ready(mtd));
-
+            while (!this->dev_ready(mtd));
+			
 		if (read == len)
-			break;
+			break;	
 
 		/* For subsequent reads align to page boundary. */
 		col = 0;
@@ -1345,15 +1599,16 @@
 			this->select_chip(mtd, -1);
 			this->select_chip(mtd, chipnr);
 		}
-		/* Check, if the chip supports auto page increment
-		 * or if we have hit a block boundary.
-		*/
+		/* Check, if the chip supports auto page increment 
+		 * or if we have hit a block boundary. 
+		*/ 
 		if (!NAND_CANAUTOINCR(this) || !(page & blockcheck))
-			sndcmd = 1;
+			sndcmd = 1;				
 	}
 
 	/* Deselect and wake up anyone waiting on the device */
-	nand_release_device(mtd);
+	if (flags & NAND_GET_DEVICE)
+		nand_release_device(mtd);
 
 	/*
 	 * Return success, if no ECC failures, else -EBADMSG
@@ -1385,7 +1640,7 @@
 	/* Shift to get page */
 	page = (int)(from >> this->page_shift);
 	chipnr = (int)(from >> this->chip_shift);
-
+	
 	/* Mask to get column */
 	col = from & (mtd->oobsize - 1);
 
@@ -1407,7 +1662,7 @@
 
 	/* Send the read command */
 	this->cmdfunc (mtd, NAND_CMD_READOOB, col, page & this->pagemask);
-	/*
+	/* 
 	 * Read the data, if we read more than one page
 	 * oob data, let the device transfer the data !
 	 */
@@ -1417,16 +1672,16 @@
 		thislen = min_t(int, thislen, len);
 		this->read_buf(mtd, &buf[i], thislen);
 		i += thislen;
-
-		/* Apply delay or wait for ready/busy pin
+		
+		/* Apply delay or wait for ready/busy pin 
 		 * Do this before the AUTOINCR check, so no problems
 		 * arise if a chip which does auto increment
 		 * is marked as NOAUTOINCR by the board driver.
 		*/
-		if (!this->dev_ready)
+		if (!this->dev_ready) 
 			udelay (this->chip_delay);
 		else
-			while (!this->dev_ready(mtd));
+            while (!this->dev_ready(mtd));
 
 		/* Read more ? */
 		if (i < len) {
@@ -1439,13 +1694,13 @@
 				this->select_chip(mtd, -1);
 				this->select_chip(mtd, chipnr);
 			}
-
-			/* Check, if the chip supports auto page increment
-			 * or if we have hit a block boundary.
-			*/
+				
+			/* Check, if the chip supports auto page increment 
+			 * or if we have hit a block boundary. 
+			*/ 
 			if (!NAND_CANAUTOINCR(this) || !(page & blockcheck)) {
 				/* For subsequent page reads set offset to 0 */
-				this->cmdfunc (mtd, NAND_CMD_READOOB, 0x0, page & this->pagemask);
+			        this->cmdfunc (mtd, NAND_CMD_READOOB, 0x0, page & this->pagemask);
 			}
 		}
 	}
@@ -1459,6 +1714,156 @@
 }
 
 /**
+ * nand_read_oob_hwecc - [MTD Interface] NAND read out-of-band (HW ECC)
+ * @mtd:	MTD device structure
+ * @from:	offset to read from
+ * @len:	number of bytes to read
+ * @retlen:	pointer to variable to store the number of read bytes
+ * @oob_buf:	the databuffer to put data
+ *
+ * NAND read out-of-band data from the spare area
+ * W/o assumptions that are valid only for software ECC
+ */
+static int nand_read_oob_hwecc (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * oob_buf)
+{
+	int i, col, page, chipnr, nleft;
+	struct nand_chip *this = mtd->priv;
+
+	DEBUG (MTD_DEBUG_LEVEL3, "%s: from = 0x%08x, len = %i\n", __FUNCTION__,
+		(unsigned int) from, (int) len);
+
+	/* Shift to get page */
+	page = (int)(from >> this->page_shift);
+	chipnr = (int)(from >> this->chip_shift);
+
+	/* Mask to get column */
+	col = from & (mtd->oobsize - 1);
+
+	/* Initialize return length value */
+	*retlen = 0;
+
+	/* Do not allow reads past end of device */
+	if ((from + len) > mtd->size) {
+		DEBUG (MTD_DEBUG_LEVEL0, "%s: Attempt read beyond end of device\n",
+			__FUNCTION__);
+		*retlen = 0;
+		return -EINVAL;
+	}
+
+	/* Grab the lock and see if the device is available */
+	nand_get_device (this, mtd , FL_READING);
+
+	/* Select the NAND device */
+	this->select_chip(mtd, chipnr);
+
+	/*
+	 * Read the data, if we read more than one page
+	 * oob data, let the device transfer the data !
+	 */
+	i = 0;
+	nleft = len;
+	while (i < len) {
+		int ooboff, pageoff, eccsteps;
+
+		eccsteps = this->eccsteps;
+		for (ooboff = 0, pageoff = 0; eccsteps; eccsteps--) {
+			int j, first, last, thislen;
+			/*
+			 * In the following we assume that each item (data, ECC,
+			 * and OOB) in the layout has an even length such as
+			 * would be required for a 16-bit-wide NAND.  This
+			 * assumption allows us to handle 16-bit-wide chips with
+			 * no special cases versus 8-bit-wide chips.
+			 */
+			for (j = 0; this->layout[j].length; j++) {
+				thislen = this->layout[j].length;
+				/* are we done yet? */
+				if (i == len)
+					goto finished;
+				switch (this->layout[j].type) {
+				case ITEM_TYPE_DATA:
+					pageoff += thislen;
+					continue;
+				case ITEM_TYPE_ECC:
+				case ITEM_TYPE_OOB:
+					/*
+					 * Calculate the intersection of the oob
+					 * data with this layout item.
+					 */
+					first = max(ooboff, col);
+					last = min(ooboff + thislen,
+						   col + nleft);
+					if (first >= last) {
+						/* no intersection */
+						break;
+					}
+					this->cmdfunc(mtd, NAND_CMD_READ0,
+						pageoff +
+							((first - ooboff) & ~1),
+						page & this->pagemask);
+					/* handle an odd offset */
+					if (first & 1) {
+						oob_buf[i++] = cpu_to_le16(
+							this->read_word(mtd))
+							 >> 8;
+						++first;
+					}
+					if (last - first > 1) {
+						int n = ((last - first) & ~1);
+						/* read an even number of oob bytes */
+						this->read_buf(mtd, oob_buf + i, n);
+						i += n;
+						first += n;
+					}
+					/* handle an odd length */
+					if (last - first == 1) {
+						oob_buf[i++] = cpu_to_le16(
+							this->read_word(mtd))
+							 & 0xff;
+						++first;
+					}
+					break;
+				}
+				pageoff += thislen;
+				ooboff += thislen;
+			}
+		}
+
+		/*
+		 * Apply delay or wait for ready/busy pin in case the chip is
+		 * auto-incrementing to the next page.
+		 */
+		if (!this->dev_ready) 
+			udelay (this->chip_delay);
+		else
+	        while (!this->dev_ready(mtd));
+
+		/* Read more ? */
+		if (i < len) {
+			page++;
+			col = 0;
+			nleft = len - i;
+
+			/* Check, if we cross a chip boundary */
+			if (!(page & this->pagemask)) {
+				chipnr++;
+				this->select_chip(mtd, -1);
+				this->select_chip(mtd, chipnr);
+			}
+		}
+	}
+
+finished:
+	/* Deselect and wake up anyone waiting on the device */
+	nand_release_device(mtd);
+
+	/* Return happy */
+	*retlen = len;
+	return 0;
+}
+
+
+/**
  * nand_read_raw - [GENERIC] Read raw data including oob into buffer
  * @mtd:	MTD device structure
  * @buf:	temporary buffer
@@ -1488,27 +1893,61 @@
 	nand_get_device (this, mtd , FL_READING);
 
 	this->select_chip (mtd, chip);
-
+	
 	/* Add requested oob length */
 	len += ooblen;
-
+	
 	while (len) {
 		if (sndcmd)
 			this->cmdfunc (mtd, NAND_CMD_READ0, 0, page & this->pagemask);
-		sndcmd = 0;
+		sndcmd = 0;	
 
-		this->read_buf (mtd, &buf[cnt], pagesize);
+		if (!this->layout)
+			this->read_buf(mtd, &buf[cnt], pagesize);
+		else {
+			int oobidx, datidx, eccsteps, j;
+			uint8_t *datbuf, *oobbuf;
+
+			/*
+			 * Since we have a page layout, we must observe the
+			 * layout to position data and oob correctly.
+			 */
+			datbuf = &buf[cnt];
+			oobbuf = &datbuf[mtd->oobblock];
+			eccsteps = this->eccsteps;
+			for (oobidx = 0, datidx = 0; eccsteps; eccsteps--) {
+				for (j = 0; this->layout[j].length; j++) {
+					int thislen = this->layout[j].length;
+
+					switch (this->layout[j].type) {
+					case ITEM_TYPE_DATA:
+						this->read_buf(mtd,
+							       &datbuf[datidx],
+							       thislen);
+						datidx += thislen;
+						break;
+					case ITEM_TYPE_ECC:
+					case ITEM_TYPE_OOB:
+						this->read_buf(mtd,
+							       &oobbuf[oobidx],
+							       thislen);
+						oobidx += thislen;
+						break;
+					}
+				}
+			}
+		}
 
 		len -= pagesize;
 		cnt += pagesize;
 		page++;
-
-		if (!this->dev_ready)
+		
+		if (!this->dev_ready) 
 			udelay (this->chip_delay);
 		else
-			while (!this->dev_ready(mtd));
-
-		/* Check, if the chip supports auto page increment */
+	        while (!this->dev_ready(mtd));
+			
+		/* Check, if the chip supports auto page increment */ 
 		if (!NAND_CANAUTOINCR(this) || !(page & blockcheck))
 			sndcmd = 1;
 	}
@@ -1519,8 +1958,8 @@
 }
 
 
-/**
- * nand_prepare_oobbuf - [GENERIC] Prepare the out of band buffer
+/** 
+ * nand_prepare_oobbuf - [GENERIC] Prepare the out of band buffer 
  * @mtd:	MTD device structure
  * @fsbuf:	buffer given by fs driver
  * @oobsel:	out of band selection structre
@@ -1549,20 +1988,20 @@
 	int i, len, ofs;
 
 	/* Zero copy fs supplied buffer */
-	if (fsbuf && !autoplace)
+	if (fsbuf && !autoplace) 
 		return fsbuf;
 
 	/* Check, if the buffer must be filled with ff again */
-	if (this->oobdirty) {
-		memset (this->oob_buf, 0xff,
+	if (this->oobdirty) {	
+		memset (this->oob_buf, 0xff, 
 			mtd->oobsize << (this->phys_erase_shift - this->page_shift));
 		this->oobdirty = 0;
-	}
-
+	}	
+	
 	/* If we have no autoplacement or no fs buffer use the internal one */
 	if (!autoplace || !fsbuf)
 		return this->oob_buf;
-
+	
 	/* Walk through the pages and place the data */
 	this->oobdirty = 1;
 	ofs = 0;
@@ -1574,7 +2013,7 @@
 			len += num;
 			fsbuf += num;
 		}
-		ofs += mtd->oobavail;
+		ofs += mtd->oobsize;
 	}
 	return this->oob_buf;
 }
@@ -1596,7 +2035,7 @@
 {
 	return (nand_write_ecc (mtd, to, len, retlen, buf, NULL, NULL));
 }
-
+			   
 /**
  * nand_write_ecc - [MTD Interface] NAND write with ECC
  * @mtd:	MTD device structure
@@ -1629,7 +2068,7 @@
 		return -EINVAL;
 	}
 
-	/* reject writes, which are not page aligned */
+	/* reject writes, which are not page aligned */	
 	if (NOTALIGNED (to) || NOTALIGNED(len)) {
 		printk (KERN_NOTICE "nand_write_ecc: Attempt to write not page aligned data\n");
 		return -EINVAL;
@@ -1648,14 +2087,14 @@
 		goto out;
 
 	/* if oobsel is NULL, use chip defaults */
-	if (oobsel == NULL)
-		oobsel = &mtd->oobinfo;
-
+	if (oobsel == NULL) 
+		oobsel = &mtd->oobinfo;		
+		
 	/* Autoplace of oob data ? Use the default placement scheme */
 	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE) {
 		oobsel = this->autooob;
 		autoplace = 1;
-	}
+	}	
 	if (oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
 		autoplace = 1;
 
@@ -1663,9 +2102,9 @@
 	totalpages = len >> this->page_shift;
 	page = (int) (to >> this->page_shift);
 	/* Invalidate the page cache, if we write to the cached page */
-	if (page <= this->pagebuf && this->pagebuf < (page + totalpages))
+	if (page <= this->pagebuf && this->pagebuf < (page + totalpages))  
 		this->pagebuf = -1;
-
+	
 	/* Set it relative to chip */
 	page &= this->pagemask;
 	startpage = page;
@@ -1687,14 +2126,14 @@
 		if (ret) {
 			DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: write_page failed %d\n", ret);
 			goto out;
-		}
+		}	
 		/* Next oob page */
 		oob += mtd->oobsize;
 		/* Update written bytes count */
 		written += mtd->oobblock;
-		if (written == len)
+		if (written == len) 
 			goto cmp;
-
+		
 		/* Increment page address */
 		page++;
 
@@ -1705,15 +2144,14 @@
 		if (!(page & (ppblock - 1))){
 			int ofs;
 			this->data_poi = bufstart;
-			ret = nand_verify_pages (mtd, this, startpage,
+			ret = nand_verify_pages (mtd, this, startpage, 
 				page - startpage,
 				oobbuf, oobsel, chipnr, (eccbuf != NULL));
 			if (ret) {
 				DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: verify_pages failed %d\n", ret);
 				goto out;
-			}
+			}	
 			*retlen = written;
-			bufstart = (u_char*) &buf[written];
 
 			ofs = autoplace ? mtd->oobavail : mtd->oobsize;
 			if (eccbuf)
@@ -1722,10 +2160,9 @@
 			numpages = min (totalpages, ppblock);
 			page &= this->pagemask;
 			startpage = page;
-			oob = 0;
-			this->oobdirty = 1;
-			oobbuf = nand_prepare_oobbuf (mtd, eccbuf, oobsel,
+			oobbuf = nand_prepare_oobbuf (mtd, eccbuf, oobsel, 
 					autoplace, numpages);
+			oob = 0;
 			/* Check, if we cross a chip boundary */
 			if (!page) {
 				chipnr++;
@@ -1741,7 +2178,7 @@
 		oobbuf, oobsel, chipnr, (eccbuf != NULL));
 	if (!ret)
 		*retlen = written;
-	else
+	else	
 		DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: verify_pages failed %d\n", ret);
 
 out:
@@ -1801,7 +2238,7 @@
 	/* Check, if it is write protected */
 	if (nand_check_wp(mtd))
 		goto out;
-
+	
 	/* Invalidate the page cache, if we write to the cached page */
 	if (page == this->pagebuf)
 		this->pagebuf = -1;
@@ -1827,7 +2264,7 @@
 	status = this->waitfunc (mtd, this, FL_WRITING);
 
 	/* See if device thinks it succeeded */
-	if (status & 0x01) {
+	if (status & NAND_STATUS_FAIL) {
 		DEBUG (MTD_DEBUG_LEVEL0, "nand_write_oob: " "Failed write, page 0x%08x\n", page);
 		ret = -EIO;
 		goto out;
@@ -1853,8 +2290,164 @@
 	return ret;
 }
 
-/* XXX U-BOOT XXX */
-#if 0
+/**
+ * nand_write_oob_hwecc - [MTD Interface] NAND write out-of-band
+ * @mtd:	MTD device structure
+ * @to:		offset to write to
+ * @len:	number of bytes to write
+ * @retlen:	pointer to variable to store the number of written bytes
+ * @oob_buf:	the data to write
+ *
+ * NAND write out-of-band
+ * W/o assumptions that are valid only for software ECC
+ */
+static int nand_write_oob_hwecc (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * oob_buf)
+{
+	int column, page, status, ret = -EIO, chipnr, eccsteps;
+	int ooblen, oc;
+	struct nand_chip *this = mtd->priv;
+
+	DEBUG (MTD_DEBUG_LEVEL3, "%s: to = 0x%08x, len = %i\n", __FUNCTION__, (unsigned int) to, (int) len);
+
+	/* Shift to get page */
+	page = (int) (to >> this->page_shift);
+	chipnr = (int) (to >> this->chip_shift);
+
+	/* Mask to get column */
+	column = to & (mtd->oobsize - 1);
+
+	/* Initialize return length value */
+	*retlen = 0;
+
+	/* Do not allow write past end of page */
+	if ((column + len) > mtd->oobsize) {
+		DEBUG (MTD_DEBUG_LEVEL0, "%s: Attempt to write past end of page\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	/* Grab the lock and see if the device is available */
+	nand_get_device (this, mtd, FL_WRITING);
+
+	/* Select the NAND device */
+	this->select_chip(mtd, chipnr);
+
+	/* Reset the chip. Some chips (like the Toshiba TC5832DC found
+	   in one of my DiskOnChip 2000 test units) will clear the whole
+	   data page too if we don't do this. I have no clue why, but
+	   I seem to have 'fixed' it in the doc2000 driver in
+	   August 1999.  dwmw2. */
+	this->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
+
+	/* Check, if it is write protected */
+	if (nand_check_wp(mtd))
+		goto out;
+	
+	/* Invalidate the page cache, if we write to the cached page */
+	if (page == this->pagebuf)
+		this->pagebuf = -1;
+
+	/* Write out desired data */
+	this->cmdfunc (mtd, NAND_CMD_SEQIN, 0, page & this->pagemask);
+
+	eccsteps = this->eccsteps;
+
+	for (ooblen = 0, oc = 0; eccsteps; eccsteps--) {
+		int j, first, last, thislen;
+		/*
+		 * In the following we assume that each item (data, ECC,
+		 * and OOB) in the layout has an even length such as would be
+		 * required for a 16-bit-wide NAND.  This assumption allows us
+		 * to handle 16-bit-wide chips with no special cases versus
+		 * 8-bit-wide chips.
+		 */
+		for (j = 0; this->layout[j].length; j++) {
+			/* are we done yet? */
+			if ((oc == len) && !NAND_MUST_PAD(this))
+				goto finish;
+			thislen = this->layout[j].length;
+			switch (this->layout[j].type) {
+			case ITEM_TYPE_DATA:
+				this->write_buf(mtd, ffchars, thislen);
+				continue;
+			case ITEM_TYPE_ECC:
+			case ITEM_TYPE_OOB:
+				/*
+				 * Calculate the intersection of the oob data
+				 * with this layout item.
+				 */
+				first = max(ooblen, column);
+				last = min(ooblen + thislen, column + (int)len);
+				if (first >= last) {
+					/* no intersection */
+					this->write_buf(mtd, ffchars, thislen);
+					break;
+				}
+				/* pre-pad */
+				if (first > ooblen + 1) {
+					/* write an even number of FFs */
+					this->write_buf(mtd, ffchars,
+						((first - ooblen) & ~1));
+				}
+				/* handle an odd offset */
+				if (first & 1) {
+					this->write_word(mtd,
+						cpu_to_le16((oob_buf[oc++] << 8)
+							    | 0xff));
+					++first;
+				}
+				if (last - first > 1) {
+					int n = ((last - first) & ~1);
+					/* write an even number of oob bytes */
+					this->write_buf(mtd, oob_buf + oc, n);
+					oc += n;
+					first += n;
+				}
+				/* handle an odd length */
+				if (last - first == 1) {
+					this->write_word(mtd,
+						cpu_to_le16(0xff00
+							    | oob_buf[oc++]));
+					++first;
+				}
+				/* post-pad */
+				if (((last + 1) & ~1) < ooblen + thislen) {
+					this->write_buf(mtd, ffchars,
+						ooblen + thislen
+						- ((last + 1) & ~1));
+				}
+				break;
+			}
+			ooblen += thislen;
+		}
+	}
+
+finish:
+	/* Send command to program the OOB data */
+	this->cmdfunc (mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	status = this->waitfunc (mtd, this, FL_WRITING);
+
+	/* See if device thinks it succeeded */
+	if (status & NAND_STATUS_FAIL) {
+		DEBUG (MTD_DEBUG_LEVEL0, "%s: Failed write, page 0x%08x\n", __FUNCTION__, page);
+		ret = -EIO;
+		goto out;
+	}
+	/* Return happy */
+	*retlen = len;
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+#warning "Verify for OOB data in HW ECC case is NOT YET implemented"
+#endif
+	ret = 0;
+
+out:
+	/* Deselect and wake up anyone waiting on the device */
+	nand_release_device(mtd);
+
+	return ret;
+}
+
 /**
  * nand_writev - [MTD Interface] compabilty function for nand_writev_ecc
  * @mtd:	MTD device structure
@@ -1865,10 +2458,11 @@
  *
  * NAND write with kvec. This just calls the ecc function
  */
-static int nand_writev (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count,
+#if 0
+static int nand_writev (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count, 
 		loff_t to, size_t * retlen)
 {
-	return (nand_writev_ecc (mtd, vecs, count, to, retlen, NULL, NULL));
+	return (nand_writev_ecc (mtd, vecs, count, to, retlen, NULL, NULL));	
 }
 
 /**
@@ -1883,7 +2477,7 @@
  *
  * NAND write with iovec with ecc
  */
-static int nand_writev_ecc (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count,
+static int nand_writev_ecc (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count, 
 		loff_t to, size_t * retlen, u_char *eccbuf, struct nand_oobinfo *oobsel)
 {
 	int i, page, len, total_len, ret = -EIO, written = 0, chipnr;
@@ -1909,7 +2503,7 @@
 		return -EINVAL;
 	}
 
-	/* reject writes, which are not page aligned */
+	/* reject writes, which are not page aligned */	
 	if (NOTALIGNED (to) || NOTALIGNED(total_len)) {
 		printk (KERN_NOTICE "nand_write_ecc: Attempt to write not page aligned data\n");
 		return -EINVAL;
@@ -1928,21 +2522,21 @@
 		goto out;
 
 	/* if oobsel is NULL, use chip defaults */
-	if (oobsel == NULL)
-		oobsel = &mtd->oobinfo;
+	if (oobsel == NULL) 
+		oobsel = &mtd->oobinfo;		
 
 	/* Autoplace of oob data ? Use the default placement scheme */
 	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE) {
 		oobsel = this->autooob;
 		autoplace = 1;
-	}
+	}	
 	if (oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
 		autoplace = 1;
 
 	/* Setup start page */
 	page = (int) (to >> this->page_shift);
 	/* Invalidate the page cache, if we write to the cached page */
-	if (page <= this->pagebuf && this->pagebuf < ((to + total_len) >> this->page_shift))
+	if (page <= this->pagebuf && this->pagebuf < ((to + total_len) >> this->page_shift))  
 		this->pagebuf = -1;
 
 	startpage = page & this->pagemask;
@@ -1966,10 +2560,10 @@
 			oob = 0;
 			for (i = 1; i <= numpages; i++) {
 				/* Write one page. If this is the last page to write
-				 * then use the real pageprogram command, else select
+				 * then use the real pageprogram command, else select 
 				 * cached programming if supported by the chip.
 				 */
-				ret = nand_write_page (mtd, this, page & this->pagemask,
+				ret = nand_write_page (mtd, this, page & this->pagemask, 
 					&oobbuf[oob], oobsel, i != numpages);
 				if (ret)
 					goto out;
@@ -1985,12 +2579,12 @@
 				count--;
 			}
 		} else {
-			/* We must use the internal buffer, read data out of each
+			/* We must use the internal buffer, read data out of each 
 			 * tuple until we have a full page to write
 			 */
 			int cnt = 0;
 			while (cnt < mtd->oobblock) {
-				if (vecs->iov_base != NULL && vecs->iov_len)
+				if (vecs->iov_base != NULL && vecs->iov_len) 
 					this->data_buf[cnt++] = ((u_char *) vecs->iov_base)[len++];
 				/* Check, if we have to switch to the next tuple */
 				if (len >= (int) vecs->iov_len) {
@@ -1999,10 +2593,10 @@
 					count--;
 				}
 			}
-			this->pagebuf = page;
-			this->data_poi = this->data_buf;
+			this->pagebuf = page;	
+			this->data_poi = this->data_buf;	
 			bufstart = this->data_poi;
-			numpages = 1;
+			numpages = 1;		
 			oobbuf = nand_prepare_oobbuf (mtd, NULL, oobsel, autoplace, numpages);
 			ret = nand_write_page (mtd, this, page & this->pagemask,
 				oobbuf, oobsel, 0);
@@ -2015,7 +2609,7 @@
 		ret = nand_verify_pages (mtd, this, startpage, numpages, oobbuf, oobsel, chipnr, 0);
 		if (ret)
 			goto out;
-
+			
 		written += mtd->oobblock * numpages;
 		/* All done ? */
 		if (!count)
@@ -2084,7 +2678,8 @@
 {
 	return nand_erase_nand (mtd, instr, 0);
 }
-
+ 
+#define BBT_PAGE_MASK	0xffffff3f
 /**
  * nand_erase_intern - [NAND Interface] erase block(s)
  * @mtd:	MTD device structure
@@ -2097,6 +2692,10 @@
 {
 	int page, len, status, pages_per_block, ret, chipnr;
 	struct nand_chip *this = mtd->priv;
+	int rewrite_bbt[NAND_MAX_CHIPS]={0};	/* flags to indicate the page, if bbt needs to be rewritten. */
+	unsigned int bbt_masked_page;		/* bbt mask to compare to page being erased. */
+						/* It is used to see if the current page is in the same */
+						/*   256 block group and the same bank as the bbt. */
 
 	DEBUG (MTD_DEBUG_LEVEL3,
 	       "nand_erase: start = 0x%08x, len = %i\n", (unsigned int) instr->addr, (unsigned int) instr->len);
@@ -2142,37 +2741,56 @@
 		goto erase_exit;
 	}
 
+	/* if BBT requires refresh, set the BBT page mask to see if the BBT should be rewritten */
+	if (this->options & BBT_AUTO_REFRESH) {
+		bbt_masked_page = this->bbt_td->pages[chipnr] & BBT_PAGE_MASK;
+	} else {
+		bbt_masked_page = 0xffffffff;	/* should not match anything */
+	}
+
 	/* Loop through the pages */
 	len = instr->len;
 
 	instr->state = MTD_ERASING;
 
 	while (len) {
-#ifndef NAND_ALLOW_ERASE_ALL
 		/* Check if we have a bad block, we do not erase bad blocks ! */
 		if (nand_block_checkbad(mtd, ((loff_t) page) << this->page_shift, 0, allowbbt)) {
 			printk (KERN_WARNING "nand_erase: attempt to erase a bad block at page 0x%08x\n", page);
 			instr->state = MTD_ERASE_FAILED;
 			goto erase_exit;
 		}
-#endif
-		/* Invalidate the page cache, if we erase the block which contains
+		
+		/* Invalidate the page cache, if we erase the block which contains 
 		   the current cached page */
 		if (page <= this->pagebuf && this->pagebuf < (page + pages_per_block))
 			this->pagebuf = -1;
 
 		this->erase_cmd (mtd, page & this->pagemask);
-
+		
 		status = this->waitfunc (mtd, this, FL_ERASING);
 
+		/* See if operation failed and additional status checks are available */
+		if ((status & NAND_STATUS_FAIL) && (this->errstat)) {
+			status = this->errstat(mtd, this, FL_ERASING, status, page);
+		}
+
 		/* See if block erase succeeded */
-		if (status & 0x01) {
+		if (status & NAND_STATUS_FAIL) {
 			DEBUG (MTD_DEBUG_LEVEL0, "nand_erase: " "Failed erase, page 0x%08x\n", page);
 			instr->state = MTD_ERASE_FAILED;
 			instr->fail_addr = (page << this->page_shift);
 			goto erase_exit;
 		}
 
+		/* if BBT requires refresh, set the BBT rewrite flag to the page being erased */
+		if (this->options & BBT_AUTO_REFRESH) {
+			if (((page & BBT_PAGE_MASK) == bbt_masked_page) && 
+			     (page != this->bbt_td->pages[chipnr])) {
+				rewrite_bbt[chipnr] = (page << this->page_shift);
+			}
+		}
+		
 		/* Increment page address and decrement length */
 		len -= (1 << this->phys_erase_shift);
 		page += pages_per_block;
@@ -2182,6 +2800,13 @@
 			chipnr++;
 			this->select_chip(mtd, -1);
 			this->select_chip(mtd, chipnr);
+
+			/* if BBT requires refresh and BBT-PERCHIP, 
+			 *   set the BBT page mask to see if this BBT should be rewritten */
+			if ((this->options & BBT_AUTO_REFRESH) && (this->bbt_td->options & NAND_BBT_PERCHIP)) {
+				bbt_masked_page = this->bbt_td->pages[chipnr] & BBT_PAGE_MASK;
+			}
+
 		}
 	}
 	instr->state = MTD_ERASE_DONE;
@@ -2196,6 +2821,18 @@
 	/* Deselect and wake up anyone waiting on the device */
 	nand_release_device(mtd);
 
+	/* if BBT requires refresh and erase was successful, rewrite any selected bad block tables */
+	if ((this->options & BBT_AUTO_REFRESH) && (!ret)) {
+		for (chipnr = 0; chipnr < this->numchips; chipnr++) {
+			if (rewrite_bbt[chipnr]) {
+				/* update the BBT for chip */
+				DEBUG (MTD_DEBUG_LEVEL0, "nand_erase_nand: nand_update_bbt (%d:0x%0x 0x%0x)\n", 
+					chipnr, rewrite_bbt[chipnr], this->bbt_td->pages[chipnr]);
+				nand_update_bbt (mtd, rewrite_bbt[chipnr]);
+			}
+		}
+	}
+
 	/* Return more or less happy */
 	return ret;
 }
@@ -2227,9 +2864,9 @@
 static int nand_block_isbad (struct mtd_info *mtd, loff_t ofs)
 {
 	/* Check for invalid offset */
-	if (ofs > mtd->size)
+	if (ofs > mtd->size) 
 		return -EINVAL;
-
+	
 	return nand_block_checkbad (mtd, ofs, 1, 0);
 }
 
@@ -2243,12 +2880,12 @@
 	struct nand_chip *this = mtd->priv;
 	int ret;
 
-	if ((ret = nand_block_isbad(mtd, ofs))) {
-		/* If it was bad already, return success and do nothing. */
+        if ((ret = nand_block_isbad(mtd, ofs))) {
+        	/* If it was bad already, return success and do nothing. */
 		if (ret > 0)
 			return 0;
-		return ret;
-	}
+        	return ret;
+        }
 
 	return this->block_markbad(mtd, ofs);
 }
@@ -2267,9 +2904,9 @@
  */
 int nand_scan (struct mtd_info *mtd, int maxchips)
 {
-	int i, j, nand_maf_id, nand_dev_id, busw;
+	int i, nand_maf_id, nand_dev_id, busw, maf_id;
 	struct nand_chip *this = mtd->priv;
-
+	
 	/* Get buswidth to select the correct functions*/
 	busw = this->options & NAND_BUSWIDTH_16;
 
@@ -2308,9 +2945,13 @@
 	if (!this->scan_bbt)
 		this->scan_bbt = nand_default_bbt;
 
+	/* 'ff' the ffchars */
+	memset(ffchars, 0xff, FFCHARS_SIZE);
+
 	/* Select the device */
 	this->select_chip(mtd, 0);
 
+	this->cmdfunc (mtd, NAND_CMD_RESET, -1, -1);
 	/* Send the command for reading device ID */
 	this->cmdfunc (mtd, NAND_CMD_READID, 0x00, -1);
 
@@ -2320,13 +2961,13 @@
 
 	/* Print and store flash device information */
 	for (i = 0; nand_flash_ids[i].name != NULL; i++) {
-
-		if (nand_dev_id != nand_flash_ids[i].id)
+				
+		if (nand_dev_id != nand_flash_ids[i].id) 
 			continue;
 
 		if (!mtd->name) mtd->name = nand_flash_ids[i].name;
 		this->chipsize = nand_flash_ids[i].chipsize << 20;
-
+		
 		/* New devices have all the information in additional id bytes */
 		if (!nand_flash_ids[i].pagesize) {
 			int extid;
@@ -2338,14 +2979,14 @@
 			mtd->oobblock = 1024 << (extid & 0x3);
 			extid >>= 2;
 			/* Calc oobsize */
-			mtd->oobsize = (8 << (extid & 0x01)) * (mtd->oobblock / 512);
+			mtd->oobsize = (8 << (extid & 0x03)) * (mtd->oobblock / 512);
 			extid >>= 2;
 			/* Calc blocksize. Blocksize is multiples of 64KiB */
 			mtd->erasesize = (64 * 1024)  << (extid & 0x03);
 			extid >>= 2;
 			/* Get buswidth information */
 			busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;
-
+		
 		} else {
 			/* Old devices have this data hardcoded in the
 			 * device id table */
@@ -2355,27 +2996,33 @@
 			busw = nand_flash_ids[i].options & NAND_BUSWIDTH_16;
 		}
 
+		/* Try to identify manufacturer */
+		for (maf_id = 0; nand_manuf_ids[maf_id].id != 0x0; maf_id++) {
+			if (nand_manuf_ids[maf_id].id == nand_maf_id)
+				break;
+		}
+
 		/* Check, if buswidth is correct. Hardware drivers should set
 		 * this correct ! */
 		if (busw != (this->options & NAND_BUSWIDTH_16)) {
 			printk (KERN_INFO "NAND device: Manufacturer ID:"
-				" 0x%02x, Chip ID: 0x%02x (%s %s)\n", nand_maf_id, nand_dev_id,
-				nand_manuf_ids[i].name , mtd->name);
-			printk (KERN_WARNING
+				" 0x%02x, Chip ID: 0x%02x (%s %s)\n", nand_maf_id, nand_dev_id, 
+				nand_manuf_ids[maf_id].name , mtd->name);		
+			printk (KERN_WARNING 
 				"NAND bus width %d instead %d bit\n",
 					(this->options & NAND_BUSWIDTH_16) ? 16 : 8,
 					busw ? 16 : 8);
 			this->select_chip(mtd, -1);
-			return 1;
+			return 1;	
 		}
-
-		/* Calculate the address shift from the page size */
+		
+		/* Calculate the address shift from the page size */	
 		this->page_shift = ffs(mtd->oobblock) - 1;
 		this->bbt_erase_shift = this->phys_erase_shift = ffs(mtd->erasesize) - 1;
 		this->chip_shift = ffs(this->chipsize) - 1;
 
 		/* Set the bad block position */
-		this->badblockpos = mtd->oobblock > 512 ?
+		this->badblockpos = mtd->oobblock > 512 ? 
 			NAND_LARGE_BADBLOCK_POS : NAND_SMALL_BADBLOCK_POS;
 
 		/* Get chip options, preserve non chip based options */
@@ -2385,10 +3032,10 @@
 		this->options |= NAND_NO_AUTOINCR;
 		/* Check if this is a not a samsung device. Do not clear the options
 		 * for chips which are not having an extended id.
-		 */
+		 */	
 		if (nand_maf_id != NAND_MFR_SAMSUNG && !nand_flash_ids[i].pagesize)
 			this->options &= ~NAND_SAMSUNG_LP_OPTIONS;
-
+		
 		/* Check for AND chips with 4 page planes */
 		if (this->options & NAND_4PAGE_ARRAY)
 			this->erase_cmd = multi_erase_cmd;
@@ -2398,19 +3045,15 @@
 		/* Do not replace user supplied command function ! */
 		if (mtd->oobblock > 512 && this->cmdfunc == nand_command)
 			this->cmdfunc = nand_command_lp;
-
-		/* Try to identify manufacturer */
-		for (j = 0; nand_manuf_ids[j].id != 0x0; j++) {
-			if (nand_manuf_ids[j].id == nand_maf_id)
-				break;
-		}
+				
+		printk (KERN_INFO "NAND device: Manufacturer ID:"
+			" 0x%02x, Chip ID: 0x%02x (%s %s)\n", nand_maf_id, nand_dev_id, 
+			nand_manuf_ids[maf_id].name , nand_flash_ids[i].name);
 		break;
 	}
 
 	if (!nand_flash_ids[i].name) {
-#ifndef CFG_NAND_QUIET_TEST
 		printk (KERN_WARNING "No NAND device found!!!\n");
-#endif
 		this->select_chip(mtd, -1);
 		return 1;
 	}
@@ -2428,7 +3071,7 @@
 	}
 	if (i > 1)
 		printk(KERN_INFO "%d NAND chips detected\n", i);
-
+	
 	/* Allocate buffers, if neccecary */
 	if (!this->oob_buf) {
 		size_t len;
@@ -2440,7 +3083,7 @@
 		}
 		this->options |= NAND_OOBBUF_ALLOC;
 	}
-
+	
 	if (!this->data_buf) {
 		size_t len;
 		len = mtd->oobblock + mtd->oobsize;
@@ -2467,7 +3110,7 @@
 	if (!this->autooob) {
 		/* Select the appropriate default oob placement scheme for
 		 * placement agnostic filesystems */
-		switch (mtd->oobsize) {
+		switch (mtd->oobsize) { 
 		case 8:
 			this->autooob = &nand_oob_8;
 			break;
@@ -2480,25 +3123,22 @@
 		default:
 			printk (KERN_WARNING "No oob scheme defined for oobsize %d\n",
 				mtd->oobsize);
-/*			BUG(); */
+			BUG();
 		}
 	}
-
+	
 	/* The number of bytes available for the filesystem to place fs dependend
 	 * oob data */
-	if (this->options & NAND_BUSWIDTH_16) {
-		mtd->oobavail = mtd->oobsize - (this->autooob->eccbytes + 2);
-		if (this->autooob->eccbytes & 0x01)
-			mtd->oobavail--;
-	} else
-		mtd->oobavail = mtd->oobsize - (this->autooob->eccbytes + 1);
+	mtd->oobavail = 0;
+	for (i = 0; this->autooob->oobfree[i][1]; i++)
+		mtd->oobavail += this->autooob->oobfree[i][1];
 
-	/*
+	/* 
 	 * check ECC mode, default to software
 	 * if 3byte/512byte hardware ECC is selected and we have 256 byte pagesize
-	 * fallback to software ECC
+	 * fallback to software ECC 
 	*/
-	this->eccsize = 256;	/* set default eccsize */
+	this->eccsize = 256;	/* set default eccsize */	
 	this->eccbytes = 3;
 
 	switch (this->eccmode) {
@@ -2513,56 +3153,59 @@
 			this->eccsize = 2048;
 		break;
 
-	case NAND_ECC_HW3_512:
-	case NAND_ECC_HW6_512:
-	case NAND_ECC_HW8_512:
+	case NAND_ECC_HW3_512: 
+	case NAND_ECC_HW6_512: 
+	case NAND_ECC_HW8_512: 
+	case NAND_ECC_HW10_512:
 		if (mtd->oobblock == 256) {
 			printk (KERN_WARNING "512 byte HW ECC not possible on 256 Byte pagesize, fallback to SW ECC \n");
 			this->eccmode = NAND_ECC_SOFT;
 			this->calculate_ecc = nand_calculate_ecc;
 			this->correct_data = nand_correct_data;
-		} else
+		} else 
 			this->eccsize = 512; /* set eccsize to 512 */
 		break;
-
+			
 	case NAND_ECC_HW3_256:
 		break;
-
-	case NAND_ECC_NONE:
+		
+	case NAND_ECC_NONE: 
 		printk (KERN_WARNING "NAND_ECC_NONE selected by board driver. This is not recommended !!\n");
 		this->eccmode = NAND_ECC_NONE;
 		break;
 
-	case NAND_ECC_SOFT:
+	case NAND_ECC_SOFT:	
 		this->calculate_ecc = nand_calculate_ecc;
 		this->correct_data = nand_correct_data;
 		break;
 
 	default:
 		printk (KERN_WARNING "Invalid NAND_ECC_MODE %d\n", this->eccmode);
-/*		BUG(); */
-	}
+		BUG();	
+	}	
 
-	/* Check hardware ecc function availability and adjust number of ecc bytes per
+	/* Check hardware ecc function availability and adjust number of ecc bytes per 
 	 * calculation step
 	*/
 	switch (this->eccmode) {
 	case NAND_ECC_HW12_2048:
-		this->eccbytes += 4;
-	case NAND_ECC_HW8_512:
 		this->eccbytes += 2;
-	case NAND_ECC_HW6_512:
+	case NAND_ECC_HW10_512:
+		this->eccbytes += 2;
+	case NAND_ECC_HW8_512: 
+		this->eccbytes += 2;
+	case NAND_ECC_HW6_512: 
 		this->eccbytes += 3;
-	case NAND_ECC_HW3_512:
+	case NAND_ECC_HW3_512: 
 	case NAND_ECC_HW3_256:
 		if (this->calculate_ecc && this->correct_data && this->enable_hwecc)
 			break;
 		printk (KERN_WARNING "No ECC functions supplied, Hardware ECC not possible\n");
-/*		BUG();	*/
+		BUG();	
 	}
-
+		
 	mtd->eccsize = this->eccsize;
-
+	
 	/* Set the number of read / write steps for one page to ensure ECC generation */
 	switch (this->eccmode) {
 	case NAND_ECC_HW12_2048:
@@ -2571,17 +3214,20 @@
 	case NAND_ECC_HW3_512:
 	case NAND_ECC_HW6_512:
 	case NAND_ECC_HW8_512:
+	case NAND_ECC_HW10_512:
 		this->eccsteps = mtd->oobblock / 512;
 		break;
 	case NAND_ECC_HW3_256:
-	case NAND_ECC_SOFT:
+	case NAND_ECC_SOFT:	
 		this->eccsteps = mtd->oobblock / 256;
 		break;
-
-	case NAND_ECC_NONE:
+		
+	case NAND_ECC_NONE: 
 		this->eccsteps = 1;
 		break;
 	}
+	
+	mtd->eccsize = this->eccsize;
 
 /* XXX U-BOOT XXX */
 #if 0
@@ -2608,9 +3254,15 @@
 	mtd->write = nand_write;
 	mtd->read_ecc = nand_read_ecc;
 	mtd->write_ecc = nand_write_ecc;
-	mtd->read_oob = nand_read_oob;
-	mtd->write_oob = nand_write_oob;
-/* XXX U-BOOT XXX */
+
+	if ((this->eccmode != NAND_ECC_NONE && this->eccmode != NAND_ECC_SOFT)
+	    && this->layout) {
+		mtd->read_oob = nand_read_oob_hwecc;
+		mtd->write_oob = nand_write_oob_hwecc;
+	} else {
+		mtd->read_oob = nand_read_oob;
+		mtd->write_oob = nand_write_oob;
+	}
 #if 0
 	mtd->readv = NULL;
 	mtd->writev = nand_writev;
@@ -2633,14 +3285,18 @@
 #if 0
 	mtd->owner = THIS_MODULE;
 #endif
+	/* Check, if we should skip the bad block table scan */
+	if (this->options & NAND_SKIP_BBTSCAN)
+		return 0;
+
 	/* Build bad block table */
 	return this->scan_bbt (mtd);
 }
 
 /**
- * nand_release - [NAND Interface] Free resources held by the NAND device
+ * nand_release - [NAND Interface] Free resources held by the NAND device 
  * @mtd:	MTD device structure
- */
+*/
 void nand_release (struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
diff -Nurd u-boot-1.2.0/drivers/nand/nand_bbt.c u-boot-1.2.0-leopard/drivers/nand/nand_bbt.c
--- u-boot-1.2.0/drivers/nand/nand_bbt.c	2007-01-06 20:13:11.000000000 -0300
+++ u-boot-1.2.0-leopard/drivers/nand/nand_bbt.c	2008-05-20 03:57:42.000000000 -0300
@@ -394,7 +394,7 @@
 {
 	/* Search the primary table */
 	search_bbt (mtd, buf, td);
-
+  
 	/* Search the mirror table */
 	if (md)
 		search_bbt (mtd, buf, md);
@@ -564,7 +564,9 @@
 			return res;
 		}
 
+        udelay(100000);
 		res = mtd->write_ecc (mtd, to, len, &retlen, buf, &buf[len], &oobinfo);
+
 		if (res < 0) {
 			printk (KERN_WARNING "nand_bbt: Error while writing bad block table %d\n", res);
 			return res;
@@ -622,6 +624,7 @@
 	else
 		chips = 1;
 
+  
 	for (i = 0; i < chips; i++) {
 		writeops = 0;
 		rd = NULL;
@@ -812,7 +815,7 @@
 	len = (1 << this->bbt_erase_shift);
 	len += (len >> this->page_shift) * mtd->oobsize;
 	buf = kmalloc (len, GFP_KERNEL);
-	if (!buf) {
+	if(!buf) {
 		printk (KERN_ERR "nand_bbt: Out of memory\n");
 		kfree (this->bbt);
 		this->bbt = NULL;
@@ -929,7 +932,7 @@
 };
 
 static struct nand_bbt_descr largepage_flashbased = {
-	.options = NAND_BBT_SCANEMPTY | NAND_BBT_SCANALLPAGES,
+	.options = 0, /* NAND_BBT_SCANEMPTY | NAND_BBT_SCANALLPAGES,*/
 	.offs = 0,
 	.len = 2,
 	.pattern = scan_ff_pattern
@@ -952,9 +955,9 @@
 static struct nand_bbt_descr bbt_main_descr = {
 	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
 		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
-	.offs =	8,
+	.offs =	2,
 	.len = 4,
-	.veroffs = 12,
+	.veroffs = 16,
 	.maxblocks = 4,
 	.pattern = bbt_pattern
 };
@@ -962,9 +965,9 @@
 static struct nand_bbt_descr bbt_mirror_descr = {
 	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
 		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
-	.offs =	8,
+	.offs =	2,
 	.len = 4,
-	.veroffs = 12,
+	.veroffs = 16,
 	.maxblocks = 4,
 	.pattern = mirror_pattern
 };
diff -Nurd u-boot-1.2.0/drivers/nand/nand_ids.c u-boot-1.2.0-leopard/drivers/nand/nand_ids.c
--- u-boot-1.2.0/drivers/nand/nand_ids.c	2007-01-06 20:13:11.000000000 -0300
+++ u-boot-1.2.0-leopard/drivers/nand/nand_ids.c	2007-12-04 07:50:41.000000000 -0300
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 2002 Thomas Gleixner (tglx@linutronix.de)
   *
- * $Id: nand_ids.c,v 1.10 2004/05/26 13:40:12 gleixner Exp $
+ * $Id: nand_ids.c,v 1.13 2005/05/27 08:31:34 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -19,14 +19,14 @@
 
 /*
 *	Chip ID list
-*
+*	
 *	Name. ID code, pagesize, chipsize in MegaByte, eraseblock size,
 *	options
-*
+* 
 * 	Pagesize; 0, 256, 512
 *	0 	get this information from the extended chip ID
 +	256	256 Byte page size
-*	512	512 Byte page size
+*	512	512 Byte page size	
 */
 struct nand_flash_dev nand_flash_ids[] = {
 	{"NAND 1MiB 5V 8-bit", 		0x6e, 256, 1, 0x1000, 0},
@@ -39,39 +39,48 @@
 	{"NAND 4MiB 3,3V 8-bit", 	0xe3, 512, 4, 0x2000, 0},
 	{"NAND 4MiB 3,3V 8-bit", 	0xe5, 512, 4, 0x2000, 0},
 	{"NAND 8MiB 3,3V 8-bit", 	0xd6, 512, 8, 0x2000, 0},
-
+	
 	{"NAND 8MiB 1,8V 8-bit", 	0x39, 512, 8, 0x2000, 0},
 	{"NAND 8MiB 3,3V 8-bit", 	0xe6, 512, 8, 0x2000, 0},
 	{"NAND 8MiB 1,8V 16-bit", 	0x49, 512, 8, 0x2000, NAND_BUSWIDTH_16},
 	{"NAND 8MiB 3,3V 16-bit", 	0x59, 512, 8, 0x2000, NAND_BUSWIDTH_16},
-
+	
 	{"NAND 16MiB 1,8V 8-bit", 	0x33, 512, 16, 0x4000, 0},
 	{"NAND 16MiB 3,3V 8-bit", 	0x73, 512, 16, 0x4000, 0},
 	{"NAND 16MiB 1,8V 16-bit", 	0x43, 512, 16, 0x4000, NAND_BUSWIDTH_16},
 	{"NAND 16MiB 3,3V 16-bit", 	0x53, 512, 16, 0x4000, NAND_BUSWIDTH_16},
-
+	
 	{"NAND 32MiB 1,8V 8-bit", 	0x35, 512, 32, 0x4000, 0},
 	{"NAND 32MiB 3,3V 8-bit", 	0x75, 512, 32, 0x4000, 0},
 	{"NAND 32MiB 1,8V 16-bit", 	0x45, 512, 32, 0x4000, NAND_BUSWIDTH_16},
 	{"NAND 32MiB 3,3V 16-bit", 	0x55, 512, 32, 0x4000, NAND_BUSWIDTH_16},
-
+	
 	{"NAND 64MiB 1,8V 8-bit", 	0x36, 512, 64, 0x4000, 0},
 	{"NAND 64MiB 3,3V 8-bit", 	0x76, 512, 64, 0x4000, 0},
 	{"NAND 64MiB 1,8V 16-bit", 	0x46, 512, 64, 0x4000, NAND_BUSWIDTH_16},
 	{"NAND 64MiB 3,3V 16-bit", 	0x56, 512, 64, 0x4000, NAND_BUSWIDTH_16},
-
+	
 	{"NAND 128MiB 1,8V 8-bit", 	0x78, 512, 128, 0x4000, 0},
+	{"NAND 128MiB 1,8V 8-bit", 	0x39, 512, 128, 0x4000, 0},
 	{"NAND 128MiB 3,3V 8-bit", 	0x79, 512, 128, 0x4000, 0},
 	{"NAND 128MiB 1,8V 16-bit", 	0x72, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 128MiB 1,8V 16-bit", 	0x49, 512, 128, 0x4000, NAND_BUSWIDTH_16},
 	{"NAND 128MiB 3,3V 16-bit", 	0x74, 512, 128, 0x4000, NAND_BUSWIDTH_16},
-
+	{"NAND 128MiB 3,3V 16-bit", 	0x59, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+	
 	{"NAND 256MiB 3,3V 8-bit", 	0x71, 512, 256, 0x4000, 0},
 
-	{"NAND 512MiB 3,3V 8-bit", 	0xDC, 512, 512, 0x4000, 0},
+	/*{"NAND 512MiB 3,3V 8-bit", 	0xDC, 512, 512, 0x4000, 0},*/
 
 	/* These are the new chips with large page size. The pagesize
 	* and the erasesize is determined from the extended id bytes
 	*/
+	/*512 Megabit */
+	{"NAND 64MiB 1,8V 8-bit", 	0xA2, 0,  64, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
+	{"NAND 64MiB 3,3V 8-bit", 	0xF2, 0,  64, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
+	{"NAND 64MiB 1,8V 16-bit", 	0xB2, 0,  64, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
+	{"NAND 64MiB 3,3V 16-bit", 	0xC2, 0,  64, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
+	
 	/* 1 Gigabit */
 	{"NAND 128MiB 1,8V 8-bit", 	0xA1, 0, 128, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
 	{"NAND 128MiB 3,3V 8-bit", 	0xF1, 0, 128, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
@@ -83,13 +92,14 @@
 	{"NAND 256MiB 3,3V 8-bit", 	0xDA, 0, 256, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
 	{"NAND 256MiB 1,8V 16-bit", 	0xBA, 0, 256, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
 	{"NAND 256MiB 3,3V 16-bit", 	0xCA, 0, 256, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
-
+	
 	/* 4 Gigabit */
 	{"NAND 512MiB 1,8V 8-bit", 	0xAC, 0, 512, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
+	//{"NAND 512MiB 3,3V 8-bit", 	0xDC, 0, 512, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_IS_AND | NAND_NO_AUTOINCR},
 	{"NAND 512MiB 3,3V 8-bit", 	0xDC, 0, 512, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
 	{"NAND 512MiB 1,8V 16-bit", 	0xBC, 0, 512, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
 	{"NAND 512MiB 3,3V 16-bit", 	0xCC, 0, 512, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
-
+	
 	/* 8 Gigabit */
 	{"NAND 1GiB 1,8V 8-bit", 	0xA3, 0, 1024, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
 	{"NAND 1GiB 3,3V 8-bit", 	0xD3, 0, 1024, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
@@ -102,13 +112,13 @@
 	{"NAND 2GiB 1,8V 16-bit", 	0xB5, 0, 2048, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
 	{"NAND 2GiB 3,3V 16-bit", 	0xC5, 0, 2048, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
 
-	/* Renesas AND 1 Gigabit. Those chips do not support extended id and have a strange page/block layout !
+	/* Renesas AND 1 Gigabit. Those chips do not support extended id and have a strange page/block layout ! 
 	 * The chosen minimum erasesize is 4 * 2 * 2048 = 16384 Byte, as those chips have an array of 4 page planes
 	 * 1 block = 2 pages, but due to plane arrangement the blocks 0-3 consists of page 0 + 4,1 + 5, 2 + 6, 3 + 7
 	 * Anyway JFFS2 would increase the eraseblock size so we chose a combined one which can be erased in one go
-	 * There are more speed improvements for reads and writes possible, but not implemented now
+	 * There are more speed improvements for reads and writes possible, but not implemented now 
 	 */
-	{"AND 128MiB 3,3V 8-bit",	0x01, 2048, 128, 0x4000, NAND_IS_AND | NAND_NO_AUTOINCR | NAND_4PAGE_ARRAY},
+	{"AND 128MiB 3,3V 8-bit",	0x01, 2048, 128, 0x4000, NAND_IS_AND | NAND_NO_AUTOINCR | NAND_4PAGE_ARRAY | BBT_AUTO_REFRESH},
 
 	{NULL,}
 };
@@ -123,6 +133,8 @@
 	{NAND_MFR_NATIONAL, "National"},
 	{NAND_MFR_RENESAS, "Renesas"},
 	{NAND_MFR_STMICRO, "ST Micro"},
+        {NAND_MFR_HYNIX, "Hynix"},
+	{NAND_MFR_MICRON, "Micron"},
 	{0x0, "Unknown"}
 };
 #endif
diff -Nurd u-boot-1.2.0/drivers/nand/nand_util.c u-boot-1.2.0-leopard/drivers/nand/nand_util.c
--- u-boot-1.2.0/drivers/nand/nand_util.c	2007-01-06 20:13:11.000000000 -0300
+++ u-boot-1.2.0-leopard/drivers/nand/nand_util.c	2007-12-04 07:50:41.000000000 -0300
@@ -160,7 +160,7 @@
 
 		if (!opts->scrub && bbtest) {
 			int ret = meminfo->block_isbad(meminfo, erase.addr);
-			if (ret > 0) {
+			if (ret > 0 ) {
 				if (!opts->quiet)
 					printf("\rSkipping bad block at  "
 					       "0x%08x                   "
@@ -175,7 +175,6 @@
 				return -1;
 			}
 		}
-
 		result = meminfo->erase(meminfo, &erase);
 		if (result != 0) {
 			printf("\n%s: MTD Erase failure: %d\n",
Binary files u-boot-1.2.0/examples/hello_world.bin and u-boot-1.2.0-leopard/examples/hello_world.bin differ
diff -Nurd u-boot-1.2.0/examples/hello_world.srec u-boot-1.2.0-leopard/examples/hello_world.srec
--- u-boot-1.2.0/examples/hello_world.srec	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/examples/hello_world.srec	2009-03-10 02:21:25.000000000 -0300
@@ -0,0 +1,36 @@
+S013000068656C6C6F5F776F726C642E7372656376
+S3150C10000070402DE90050A0E10100A0E10160A0E1D3
+S3150C1000104C0000EB0310A0E37C009FE5300000EBD6
+S3150C100020250000EB0010A0E170009FE52C0000EB02
+S3150C1000306C009FE52A0000EB68009FE50510A0E117
+S3150C1000400040A0E3260000EB050054E1080000CAAE
+S3150C100050043196E7000053E34C209FE50410A0E111
+S3150C1000600320A01144009FE5014084E21C0000EB24
+S3150C100070F4FFFFEA38009FE5190000EB120000EBC5
+S3150C100080000050E3FCFFFF0A0D0000EB24009FE577
+S3150C100090130000EB0000A0E37080BDE87401100C97
+S3150C1000A09401100CB401100CC401100CD001100CDE
+S3150C1000B0D801100CEC01100C0802100C20C098E59D
+S3150C1000C000F09CE520C098E504F09CE520C098E56E
+S3150C1000D008F09CE520C098E50CF09CE520C098E54E
+S3150C1000E010F09CE520C098E514F09CE520C098E52E
+S3150C1000F018F09CE520C098E51CF09CE520C098E50E
+S3150C10010020F09CE520C098E524F09CE520C098E5ED
+S3150C10011028F09CE520C098E52CF09CE520C098E5CD
+S3150C10012030F09CE520C098E534F09CE520C098E5AD
+S3150C10013038F09CE520C098E53CF09CE520C098E58D
+S3150C10014040F09CE51EFF2FE11C209FE51C109FE53F
+S3150C100150010052E11EFF2F210030A0E3043082E48F
+S3150C100160010052E1FBFFFF3A1EFF2FE10C82100C2F
+S3090C1001700C82100CBF
+S3150C1001744578616D706C6520657870656374732051
+S3150C1001844142492076657273696F6E2025640A00A4
+S3150C10019441637475616C20552D426F6F7420414206
+S3150C1001A4492076657273696F6E2025640A00000007
+S3150C1001B448656C6C6F20576F726C640A00000000F3
+S3150C1001C461726763203D2025640A00003C4E554C31
+S3150C1001D44C3E0000617267765B25645D203D2022DF
+S3150C1001E42573220A0000000048697420616E792078
+S3150C1001F46B657920746F2065786974202E2E2E20E9
+S30C0C100204000000000A0A00BD
+S7050C100000DE
diff -Nurd u-boot-1.2.0/include/asm/arch/emif_defs.h u-boot-1.2.0-leopard/include/asm/arch/emif_defs.h
--- u-boot-1.2.0/include/asm/arch/emif_defs.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch/emif_defs.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) Sergey Kubushyn <ksi@koi8.net>, 2007.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _EMIF_DEFS_H_
+#define _EMIF_DEFS_H_
+
+typedef struct {
+	dv_reg		ERCSR;
+	dv_reg		AWCCR;
+	dv_reg		SDBCR;
+	dv_reg		SDRCR;
+	dv_reg		AB1CR;
+	dv_reg		AB2CR;
+	dv_reg		AB3CR;
+	dv_reg		AB4CR;
+	dv_reg		SDTIMR;
+	dv_reg		DDRSR;
+	dv_reg		DDRPHYCR;
+	dv_reg		DDRPHYSR;
+	dv_reg		TOTAR;
+	dv_reg		TOTACTR;
+	dv_reg		DDRPHYID_REV;
+	dv_reg		SDSRETR;
+	dv_reg		EIRR;
+	dv_reg		EIMR;
+	dv_reg		EIMSR;
+	dv_reg		EIMCR;
+	dv_reg		IOCTRLR;
+	dv_reg		IOSTATR;
+	u_int8_t	RSVD0[8];
+	dv_reg		NANDFCR;
+	dv_reg		NANDFSR;
+	u_int8_t	RSVD1[8];
+	dv_reg		NANDF1ECC;
+	dv_reg		NANDF2ECC;
+	dv_reg		NANDF3ECC;
+	dv_reg		NANDF4ECC;
+} emif_registers;
+
+typedef emif_registers	*emifregs;
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch/nand_defs.h u-boot-1.2.0-leopard/include/asm/arch/nand_defs.h
--- u-boot-1.2.0/include/asm/arch/nand_defs.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch/nand_defs.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) Sergey Kubushyn <ksi@koi8.net>, 2007.
+ *
+ * Parts shamelesly stolen from Linux Kernel source tree.
+ *
+ * ------------------------------------------------------------
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _NAND_DEFS_H_
+#define _NAND_DEFS_H_
+
+#define	MASK_CLE	0x10
+//#define	MASK_ALE	0x0a
+#define	MASK_ALE	0x08
+
+#define NAND_CE0CLE	((volatile u_int8_t *)(CFG_NAND_BASE + 0x10))
+//#define NAND_CE0ALE	((volatile u_int8_t *)(CFG_NAND_BASE + 0x0a))
+#define NAND_CE0ALE	((volatile u_int8_t *)(CFG_NAND_BASE + 0x08))
+#define NAND_CE0DATA	((volatile u_int8_t *)CFG_NAND_BASE)
+
+typedef struct  {
+	u_int32_t	NRCSR;
+	u_int32_t	AWCCR;
+	u_int8_t	RSVD0[8];
+	u_int32_t	AB1CR;
+	u_int32_t	AB2CR;
+	u_int32_t	AB3CR;
+	u_int32_t	AB4CR;
+	u_int8_t	RSVD1[32];
+	u_int32_t	NIRR;
+	u_int32_t	NIMR;
+	u_int32_t	NIMSR;
+	u_int32_t	NIMCR;
+	u_int8_t	RSVD2[16];
+	u_int32_t	NANDFCR;
+	u_int32_t	NANDFSR;
+	u_int8_t	RSVD3[8];
+	u_int32_t	NANDF1ECC;
+	u_int32_t	NANDF2ECC;
+	u_int32_t	NANDF3ECC;
+	u_int32_t	NANDF4ECC;
+	u_int8_t	RSVD4[4];
+	u_int32_t	IODFTECR;
+	u_int32_t	IODFTGCR;
+	u_int8_t	RSVD5[4];
+	u_int32_t	IODFTMRLR;
+	u_int32_t	IODFTMRMR;
+	u_int32_t	IODFTMRMSBR;
+	u_int8_t	RSVD6[20];
+	u_int32_t	MODRNR;
+	u_int8_t	RSVD7[76];
+	u_int32_t	CE0DATA;
+	u_int32_t	CE0ALE;
+	u_int32_t	CE0CLE;
+	u_int8_t	RSVD8[4];
+	u_int32_t	CE1DATA;
+	u_int32_t	CE1ALE;
+	u_int32_t	CE1CLE;
+	u_int8_t	RSVD9[4];
+	u_int32_t	CE2DATA;
+	u_int32_t	CE2ALE;
+	u_int32_t	CE2CLE;
+	u_int8_t	RSVD10[4];
+	u_int32_t	CE3DATA;
+	u_int32_t	CE3ALE;
+	u_int32_t	CE3CLE;
+} nand_registers;
+
+typedef volatile nand_registers	*nandregs;
+
+#define NAND_READ_START		0x00
+#define NAND_READ_END		0x30
+#define NAND_STATUS		0x70
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch/sizes.h u-boot-1.2.0-leopard/include/asm/arch/sizes.h
--- u-boot-1.2.0/include/asm/arch/sizes.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch/sizes.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,51 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA0 2111-1307
+ * USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *		   from .s file by awk -f s2h.awk
+ */
+/*  Size defintions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h			1
+
+/* handy sizes */
+#define SZ_1K		0x00000400
+#define SZ_4K		0x00001000
+#define SZ_8K		0x00002000
+#define SZ_16K		0x00004000
+#define SZ_64K		0x00010000
+#define SZ_128K	0x00020000
+#define SZ_256K	0x00040000
+#define SZ_512K	0x00080000
+
+#define SZ_1M		0x00100000
+#define SZ_2M		0x00200000
+#define SZ_4M		0x00400000
+#define SZ_8M		0x00800000
+#define SZ_16M		0x01000000
+#define SZ_32M		0x02000000
+#define SZ_64M		0x04000000
+#define SZ_128M	0x08000000
+#define SZ_256M	0x10000000
+#define SZ_512M	0x20000000
+
+#define SZ_1G		0x40000000
+#define SZ_2G		0x80000000
+
+#endif	/* __sizes_h */
diff -Nurd u-boot-1.2.0/include/asm/arch/types.h u-boot-1.2.0-leopard/include/asm/arch/types.h
--- u-boot-1.2.0/include/asm/arch/types.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch/types.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) Sergey Kubushyn <ksi@koi8.net>, 2007.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _ASM_ARCH_TYPES_H_
+#define _ASM_ARCH_TYPES_H_
+
+#define	REG(addr)	(*(volatile unsigned int *)(addr))
+#define REG_P(addr)	((volatile unsigned int *)(addr))
+
+typedef volatile unsigned int	dv_reg;
+typedef volatile unsigned int *	dv_reg_p;
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch-arm1136/bits.h u-boot-1.2.0-leopard/include/asm/arch-arm1136/bits.h
--- u-boot-1.2.0/include/asm/arch-arm1136/bits.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm1136/bits.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,48 @@
+/* bits.h
+ * Copyright (c) 2004 Texas Instruments
+ *
+ * This package is free software;  you can redistribute it and/or
+ * modify it under the terms of the license found in the file
+ * named COPYING that should have accompanied this file.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+#ifndef __bits_h
+#define __bits_h 1
+
+#define BIT0  (1<<0)
+#define BIT1  (1<<1)
+#define BIT2  (1<<2)
+#define BIT3  (1<<3)
+#define BIT4  (1<<4)
+#define BIT5  (1<<5)
+#define BIT6  (1<<6)
+#define BIT7  (1<<7)
+#define BIT8  (1<<8)
+#define BIT9  (1<<9)
+#define BIT10 (1<<10)
+#define BIT11 (1<<11)
+#define BIT12 (1<<12)
+#define BIT13 (1<<13)
+#define BIT14 (1<<14)
+#define BIT15 (1<<15)
+#define BIT16 (1<<16)
+#define BIT17 (1<<17)
+#define BIT18 (1<<18)
+#define BIT19 (1<<19)
+#define BIT20 (1<<20)
+#define BIT21 (1<<21)
+#define BIT22 (1<<22)
+#define BIT23 (1<<23)
+#define BIT24 (1<<24)
+#define BIT25 (1<<25)
+#define BIT26 (1<<26)
+#define BIT27 (1<<27)
+#define BIT28 (1<<28)
+#define BIT29 (1<<29)
+#define BIT30 (1<<30)
+#define BIT31 (1<<31)
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch-arm1136/clocks.h u-boot-1.2.0-leopard/include/asm/arch-arm1136/clocks.h
--- u-boot-1.2.0/include/asm/arch-arm1136/clocks.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm1136/clocks.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,112 @@
+/*
+ * (C) Copyright 2004
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+  */
+#ifndef _OMAP24XX_CLOCKS_H_
+#define _OMAP24XX_CLOCKS_H_
+
+#define COMMIT_DIVIDERS  0x1
+
+#define MODE_BYPASS_FAST 0x2
+#define APLL_LOCK        0xc
+#ifdef CONFIG_APTIX
+#define DPLL_LOCK        0x1   /* stay in bypass mode */
+#else
+#define DPLL_LOCK        0x3   /* DPLL lock */
+#endif
+
+/****************************************************************************;
+; PRCM Scheme II
+;
+; Enable clocks and DPLL for:
+;  DPLL=300, 	DPLLout=600   	M=1,N=50   CM_CLKSEL1_PLL[21:8]  12/2*50
+;  Core=600  	(core domain)   DPLLx2     CM_CLKSEL2_PLL[1:0]
+;  MPUF=300   	(mpu domain)    2          CM_CLKSEL_MPU[4:0]
+;  DSPF=200    (dsp domain)    3          CM_CLKSEL_DSP[4:0]
+;  DSPI=100                    6          CM_CLKSEL_DSP[6:5]
+;  DSP_S          bypass	               CM_CLKSEL_DSP[7]
+;  IVAF=200    (dsp domain)    3          CM_CLKSEL_DSP[12:8]
+;  IVAF=100        auto
+;  IVAI            auto
+;  IVA_MPU         auto
+;  IVA_S          bypass                  CM_CLKSEL_DSP[13]
+;  GFXF=50      (gfx domain)	12         CM_CLKSEL_FGX[2:0]
+;  SSI_SSRF=200                 3         CM_CLKSEL1_CORE[24:20]
+;  SSI_SSTF=100     auto
+;  L3=100Mhz (sdram)            6         CM_CLKSEL1_CORE[4:0]
+;  L4=100Mhz                    6
+;  C_L4_USB=50                 12         CM_CLKSEL1_CORE[6:5]
+***************************************************************************/
+#define II_DPLL_OUT_X2   0x2    /* x2 core out */
+#define II_MPU_DIV       0x2    /* mpu = core/2 */
+#define II_DSP_DIV       0x343  /* dsp & iva divider */
+#define II_GFX_DIV       0x2
+#define II_BUS_DIV       0x04601026
+#define II_DPLL_300      0x01832100
+
+/****************************************************************************;
+; PRCM Scheme III
+;
+; Enable clocks and DPLL for:
+;  DPLL=266, 	DPLLout=532   	M=5+1,N=133 CM_CLKSEL1_PLL[21:8]  12/6*133=266
+;  Core=532  	(core domain)   DPLLx2      CM_CLKSEL2_PLL[1:0]
+;  MPUF=266   	(mpu domain)    /2          CM_CLKSEL_MPU[4:0]
+;  DSPF=177.3     (dsp domain)  /3          CM_CLKSEL_DSP[4:0]
+;  DSPI=88.67                   /6          CM_CLKSEL_DSP[6:5]
+;  DSP_S         ACTIVATED	            CM_CLKSEL_DSP[7]
+;  IVAF=88.67    (dsp domain)   /3          CM_CLKSEL_DSP[12:8]
+;  IVAF=88.67        auto
+;  IVAI            auto
+;  IVA_MPU         auto
+;  IVA_S         ACTIVATED                  CM_CLKSEL_DSP[13]
+;  GFXF=66.5      (gfx domain)	/8          CM_CLKSEL_FGX[2:0]:
+;  SSI_SSRF=177.3               /3          CM_CLKSEL1_CORE[24:20]
+;  SSI_SSTF=88.67     auto
+;  L3=133Mhz (sdram)            /4          CM_CLKSEL1_CORE[4:0]
+;  L4=66.5Mhz                   /8
+;  C_L4_USB=33.25               /16         CM_CLKSEL1_CORE[6:5]
+***************************************************************************/
+#define III_DPLL_OUT_X2   0x2    /* x2 core out */
+#define III_MPU_DIV       0x2    /* mpu = core/2 */
+#define III_DSP_DIV       0x23C3 /* dsp & iva divider sych enabled*/
+#define III_GFX_DIV       0x2
+#define III_BUS_DIV       0x08301044
+#define III_DPLL_266      0x01885500
+
+/* set defaults for boot up */
+#ifdef PRCM_CONFIG_II
+# define DPLL_OUT         II_DPLL_OUT_X2
+# define MPU_DIV          II_MPU_DIV
+# define DSP_DIV          II_DSP_DIV
+# define GFX_DIV          II_GFX_DIV
+# define BUS_DIV          II_BUS_DIV
+# define DPLL_VAL         II_DPLL_300
+#elif PRCM_CONFIG_III
+# define DPLL_OUT         III_DPLL_OUT_X2
+# define MPU_DIV          III_MPU_DIV
+# define DSP_DIV          III_DSP_DIV
+# define GFX_DIV          III_GFX_DIV
+# define BUS_DIV          III_BUS_DIV
+# define DPLL_VAL         III_DPLL_266
+#endif
+
+/* lock delay time out */
+#define LDELAY           12000000
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch-arm1136/i2c.h u-boot-1.2.0-leopard/include/asm/arch-arm1136/i2c.h
--- u-boot-1.2.0/include/asm/arch-arm1136/i2c.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm1136/i2c.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,107 @@
+/*
+ * (C) Copyright 2004
+ * Texas Instruments, <www.ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _OMAP24XX_I2C_H_
+#define _OMAP24XX_I2C_H_
+
+#define I2C_BASE                0x48070000
+#define I2C_BASE2               0x48072000 /* nothing hooked up on h4 */
+
+#define I2C_REV                 (I2C_BASE + 0x00)
+#define I2C_IE                  (I2C_BASE + 0x04)
+#define I2C_STAT                (I2C_BASE + 0x08)
+#define I2C_IV                  (I2C_BASE + 0x0c)
+#define I2C_BUF                 (I2C_BASE + 0x14)
+#define I2C_CNT                 (I2C_BASE + 0x18)
+#define I2C_DATA                (I2C_BASE + 0x1c)
+#define I2C_SYSC                (I2C_BASE + 0x20)
+#define I2C_CON                 (I2C_BASE + 0x24)
+#define I2C_OA                  (I2C_BASE + 0x28)
+#define I2C_SA                  (I2C_BASE + 0x2c)
+#define I2C_PSC                 (I2C_BASE + 0x30)
+#define I2C_SCLL                (I2C_BASE + 0x34)
+#define I2C_SCLH                (I2C_BASE + 0x38)
+#define I2C_SYSTEST             (I2C_BASE + 0x3c)
+
+/* I2C masks */
+
+/* I2C Interrupt Enable Register (I2C_IE): */
+#define I2C_IE_GC_IE    (1 << 5)
+#define I2C_IE_XRDY_IE  (1 << 4)        /* Transmit data ready interrupt enable */
+#define I2C_IE_RRDY_IE  (1 << 3)        /* Receive data ready interrupt enable */
+#define I2C_IE_ARDY_IE  (1 << 2)        /* Register access ready interrupt enable */
+#define I2C_IE_NACK_IE  (1 << 1)        /* No acknowledgment interrupt enable */
+#define I2C_IE_AL_IE    (1 << 0)        /* Arbitration lost interrupt enable */
+
+/* I2C Status Register (I2C_STAT): */
+
+#define I2C_STAT_SBD    (1 << 15)       /* Single byte data */
+#define I2C_STAT_BB     (1 << 12)       /* Bus busy */
+#define I2C_STAT_ROVR   (1 << 11)       /* Receive overrun */
+#define I2C_STAT_XUDF   (1 << 10)       /* Transmit underflow */
+#define I2C_STAT_AAS    (1 << 9)        /* Address as slave */
+#define I2C_STAT_GC     (1 << 5)
+#define I2C_STAT_XRDY   (1 << 4)        /* Transmit data ready */
+#define I2C_STAT_RRDY   (1 << 3)        /* Receive data ready */
+#define I2C_STAT_ARDY   (1 << 2)        /* Register access ready */
+#define I2C_STAT_NACK   (1 << 1)        /* No acknowledgment interrupt enable */
+#define I2C_STAT_AL     (1 << 0)        /* Arbitration lost interrupt enable */
+
+
+/* I2C Interrupt Code Register (I2C_INTCODE): */
+
+#define I2C_INTCODE_MASK        7
+#define I2C_INTCODE_NONE        0
+#define I2C_INTCODE_AL          1       /* Arbitration lost */
+#define I2C_INTCODE_NAK         2       /* No acknowledgement/general call */
+#define I2C_INTCODE_ARDY        3       /* Register access ready */
+#define I2C_INTCODE_RRDY        4       /* Rcv data ready */
+#define I2C_INTCODE_XRDY        5       /* Xmit data ready */
+
+/* I2C Buffer Configuration Register (I2C_BUF): */
+
+#define I2C_BUF_RDMA_EN         (1 << 15)       /* Receive DMA channel enable */
+#define I2C_BUF_XDMA_EN         (1 << 7)        /* Transmit DMA channel enable */
+
+/* I2C Configuration Register (I2C_CON): */
+
+#define I2C_CON_EN      (1 << 15)       /* I2C module enable */
+#define I2C_CON_BE      (1 << 14)       /* Big endian mode */
+#define I2C_CON_STB     (1 << 11)       /* Start byte mode (master mode only) */
+#define I2C_CON_MST     (1 << 10)       /* Master/slave mode */
+#define I2C_CON_TRX     (1 << 9)        /* Transmitter/receiver mode (master mode only) */
+#define I2C_CON_XA      (1 << 8)        /* Expand address */
+#define I2C_CON_STP     (1 << 1)        /* Stop condition (master mode only) */
+#define I2C_CON_STT     (1 << 0)        /* Start condition (master mode only) */
+
+/* I2C System Test Register (I2C_SYSTEST): */
+
+#define I2C_SYSTEST_ST_EN       (1 << 15)       /* System test enable */
+#define I2C_SYSTEST_FREE        (1 << 14)       /* Free running mode (on breakpoint) */
+#define I2C_SYSTEST_TMODE_MASK  (3 << 12)       /* Test mode select */
+#define I2C_SYSTEST_TMODE_SHIFT (12)            /* Test mode select */
+#define I2C_SYSTEST_SCL_I       (1 << 3)        /* SCL line sense input value */
+#define I2C_SYSTEST_SCL_O       (1 << 2)        /* SCL line drive output value */
+#define I2C_SYSTEST_SDA_I       (1 << 1)        /* SDA line sense input value */
+#define I2C_SYSTEST_SDA_O       (1 << 0)        /* SDA line drive output value */
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch-arm1136/mem.h u-boot-1.2.0-leopard/include/asm/arch-arm1136/mem.h
--- u-boot-1.2.0/include/asm/arch-arm1136/mem.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm1136/mem.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,156 @@
+/*
+ * (C) Copyright 2004
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _OMAP24XX_MEM_H_
+#define _OMAP24XX_MEM_H_
+
+#define SDRC_CS0_OSET	 0x0
+#define SDRC_CS1_OSET	 0x30  /* mirror CS1 regs appear offset 0x30 from CS0 */
+
+#ifndef __ASSEMBLY__
+/* struct's for holding data tables for current boards, they are getting used
+   early in init when NO global access are there */
+struct sdrc_data_s {
+	u32    sdrc_sharing;
+	u32    sdrc_mdcfg_0_ddr;
+	u32    sdrc_mdcfg_0_sdr;
+	u32    sdrc_actim_ctrla_0;
+	u32    sdrc_actim_ctrlb_0;
+	u32    sdrc_rfr_ctrl;
+	u32    sdrc_mr_0_ddr;
+	u32    sdrc_mr_0_sdr;
+	u32    sdrc_dllab_ctrl;
+} /*__attribute__ ((packed))*/;
+typedef struct sdrc_data_s sdrc_data_t;
+
+typedef enum {
+	STACKED		= 0,
+	IP_DDR		= 1,
+	COMBO_DDR	= 2,
+	IP_SDR		= 3,
+} mem_t;
+
+#endif
+
+/* Slower full frequency range default timings for x32 operation*/
+#define H4_2420_SDRC_SHARING		0x00000100
+#define H4_2420_SDRC_MDCFG_0_SDR	0x00D04010 /* discrete sdr module */
+#define H4_2420_SDRC_MR_0_SDR		0x00000031
+#define H4_2420_SDRC_MDCFG_0_DDR	0x01702011 /* descrite ddr module */
+#define H4_2420_COMBO_MDCFG_0_DDR	0x00801011 /* combo module */
+#define H4_2420_SDRC_MR_0_DDR		0x00000032
+
+#define H4_2422_SDRC_SHARING		0x00004b00
+#define H4_2422_SDRC_MDCFG_0_DDR	0x00801011 /* stacked ddr on 2422 */
+#define H4_2422_SDRC_MR_0_DDR		0x00000032
+
+/* ES1 work around timings */
+#define H4_242x_SDRC_ACTIM_CTRLA_0_ES1	0x9bead909  /* 165Mhz for use with 100/133 */
+#define H4_242x_SDRC_ACTIM_CTRLB_0_ES1	0x00000020
+#define H4_242x_SDRC_RFR_CTRL_ES1	    0x00002401	/* use over refresh for ES1 */
+
+/* optimized timings good for current shipping parts */
+#define H4_242X_SDRC_ACTIM_CTRLA_0_100MHz  0x5A59B485
+#define H4_242X_SDRC_ACTIM_CTRLB_0_100MHz  0x0000000e
+#define H4_242X_SDRC_ACTIM_CTRLA_0_133MHz  0x8BA6E6C8 /* temp warn 0 settings */
+#define H4_242X_SDRC_ACTIM_CTRLB_0_133MHz  0x00000010 /* temp warn 0 settings */
+#define H4_242X_SDRC_RFR_CTRL_100MHz	   0x0002da01
+#define H4_242X_SDRC_RFR_CTRL_133MHz	   0x0003de01
+#define H4_242x_SDRC_DLLAB_CTRL_100MHz	   0x0000980E /* 72deg, allow DPLLout*1 to work (combo)*/
+#define H4_242x_SDRC_DLLAB_CTRL_133MHz	   0x0000690E /* 72deg, for ES2 */
+
+#ifdef PRCM_CONFIG_II
+# define H4_2420_SDRC_ACTIM_CTRLA_0	H4_242X_SDRC_ACTIM_CTRLA_0_100MHz
+# define H4_2420_SDRC_ACTIM_CTRLB_0	H4_242X_SDRC_ACTIM_CTRLB_0_100MHz
+# define H4_2420_SDRC_RFR_CTRL		H4_242X_SDRC_RFR_CTRL_100MHz
+# define H4_2420_SDRC_DLLAB_CTRL    H4_242x_SDRC_DLLAB_CTRL_100MHz
+# define H4_2422_SDRC_ACTIM_CTRLA_0	H4_242X_SDRC_ACTIM_CTRLA_0_100MHz
+# define H4_2422_SDRC_ACTIM_CTRLB_0	H4_242X_SDRC_ACTIM_CTRLB_0_100MHz
+# define H4_2422_SDRC_RFR_CTRL		H4_242X_SDRC_RFR_CTRL_100MHz
+# define H4_2422_SDRC_DLLAB_CTRL    H4_242x_SDRC_DLLAB_CTRL_100MHz
+#elif PRCM_CONFIG_III
+# define H4_2420_SDRC_ACTIM_CTRLA_0	H4_242X_SDRC_ACTIM_CTRLA_0_133MHz
+# define H4_2420_SDRC_ACTIM_CTRLB_0	H4_242X_SDRC_ACTIM_CTRLB_0_133MHz
+# define H4_2420_SDRC_RFR_CTRL		H4_242X_SDRC_RFR_CTRL_133MHz
+# define H4_2420_SDRC_DLLAB_CTRL    H4_242x_SDRC_DLLAB_CTRL_133MHz
+# define H4_2422_SDRC_ACTIM_CTRLA_0	H4_242X_SDRC_ACTIM_CTRLA_0_100MHz
+# define H4_2422_SDRC_ACTIM_CTRLB_0	H4_242X_SDRC_ACTIM_CTRLB_0_100MHz
+# define H4_2422_SDRC_RFR_CTRL		H4_242X_SDRC_RFR_CTRL_100MHz
+# define H4_2422_SDRC_DLLAB_CTRL    H4_242x_SDRC_DLLAB_CTRL_100MHz
+#endif
+
+
+/* GPMC settings */
+#ifdef PRCM_CONFIG_II	     /* L3 at 100MHz */
+# ifdef CFG_NAND_BOOT
+#  define H4_24XX_GPMC_CONFIG1_0   0x0
+#  define H4_24XX_GPMC_CONFIG2_0   0x00141400
+#  define H4_24XX_GPMC_CONFIG3_0   0x00141400
+#  define H4_24XX_GPMC_CONFIG4_0   0x0F010F01
+#  define H4_24XX_GPMC_CONFIG5_0   0x010C1414
+#  define H4_24XX_GPMC_CONFIG6_0   0x00000A80
+# else	/* else NOR */
+#  define H4_24XX_GPMC_CONFIG1_0   0x3
+#  define H4_24XX_GPMC_CONFIG2_0   0x000f0f01
+#  define H4_24XX_GPMC_CONFIG3_0   0x00050502
+#  define H4_24XX_GPMC_CONFIG4_0   0x0C060C06
+#  define H4_24XX_GPMC_CONFIG5_0   0x01131F1F
+# endif /* endif CFG_NAND_BOOT */
+# define H4_24XX_GPMC_CONFIG7_0	  (0x00000C40|(H4_CS0_BASE >> 24))
+# define H4_24XX_GPMC_CONFIG1_1	  0x00011000
+# define H4_24XX_GPMC_CONFIG2_1	  0x001F1F00
+# define H4_24XX_GPMC_CONFIG3_1	  0x00080802
+# define H4_24XX_GPMC_CONFIG4_1	  0x1C091C09
+# define H4_24XX_GPMC_CONFIG5_1	  0x031A1F1F
+# define H4_24XX_GPMC_CONFIG6_1	  0x000003C2
+# define H4_24XX_GPMC_CONFIG7_1	  (0x00000F40|(H4_CS1_BASE >> 24))
+#endif /* endif PRCM_CONFIG_II */
+
+#ifdef PRCM_CONFIG_III	/* L3 at 133MHz */
+# ifdef CFG_NAND_BOOT
+#  define H4_24XX_GPMC_CONFIG1_0   0x0
+#  define H4_24XX_GPMC_CONFIG2_0   0x00141400
+#  define H4_24XX_GPMC_CONFIG3_0   0x00141400
+#  define H4_24XX_GPMC_CONFIG4_0   0x0F010F01
+#  define H4_24XX_GPMC_CONFIG5_0   0x010C1414
+#  define H4_24XX_GPMC_CONFIG6_0   0x00000A80
+# else	/* NOR boot */
+#  define H4_24XX_GPMC_CONFIG1_0   0x3
+#  define H4_24XX_GPMC_CONFIG2_0   0x00151501
+#  define H4_24XX_GPMC_CONFIG3_0   0x00060602
+#  define H4_24XX_GPMC_CONFIG4_0   0x10081008
+#  define H4_24XX_GPMC_CONFIG5_0   0x01131F1F
+#  define H4_24XX_GPMC_CONFIG6_0   0x000004c4
+# endif /* endif CFG_NAND_BOOT */
+# define H4_24XX_GPMC_CONFIG7_0	  (0x00000C40|(H4_CS0_BASE >> 24))
+# define H4_24XX_GPMC_CONFIG1_1	  0x00011000
+# define H4_24XX_GPMC_CONFIG2_1	  0x001f1f01
+# define H4_24XX_GPMC_CONFIG3_1	  0x00080803
+# define H4_24XX_GPMC_CONFIG4_1	  0x1C091C09
+# define H4_24XX_GPMC_CONFIG5_1	  0x041f1F1F
+# define H4_24XX_GPMC_CONFIG6_1	  0x000004C4
+# define H4_24XX_GPMC_CONFIG7_1	  (0x00000F40|(H4_CS1_BASE >> 24))
+#endif /* endif CFG_PRCM_III */
+
+#endif /* endif _OMAP24XX_MEM_H_ */
diff -Nurd u-boot-1.2.0/include/asm/arch-arm1136/mux.h u-boot-1.2.0-leopard/include/asm/arch-arm1136/mux.h
--- u-boot-1.2.0/include/asm/arch-arm1136/mux.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm1136/mux.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,158 @@
+/*
+ * (C) Copyright 2004
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _OMAP2420_MUX_H_
+#define _OMAP2420_MUX_H_
+
+#ifndef __ASSEMBLY__
+typedef  unsigned char uint8;
+typedef  unsigned int uint32;
+
+void muxSetupSDRC(void);
+void muxSetupGPMC(void);
+void muxSetupUsb0(void);
+void muxSetupUart3(void);
+void muxSetupI2C1(void);
+void muxSetupUART1(void);
+void muxSetupLCD(void);
+void muxSetupCamera(void);
+void muxSetupMMCSD(void) ;
+void muxSetupTouchScreen(void) ;
+void muxSetupHDQ(void);
+#endif
+
+#define USB_OTG_CTRL			        ((volatile uint32 *)0x4805E30C)
+
+/* Pin Muxing registers used for HDQ (Smart battery) */
+#define CONTROL_PADCONF_HDQ_SIO         ((volatile unsigned char *)0x48000115)
+
+/* Pin Muxing registers used for GPMC */
+#define CONTROL_PADCONF_GPMC_D2_BYTE0	((volatile unsigned char *)0x48000088)
+#define CONTROL_PADCONF_GPMC_D2_BYTE1	((volatile unsigned char *)0x48000089)
+#define CONTROL_PADCONF_GPMC_D2_BYTE2	((volatile unsigned char *)0x4800008A)
+#define CONTROL_PADCONF_GPMC_D2_BYTE3	((volatile unsigned char *)0x4800008B)
+
+#define CONTROL_PADCONF_GPMC_NCS0_BYTE0	((volatile unsigned char *)0x4800008C)
+#define CONTROL_PADCONF_GPMC_NCS0_BYTE1	((volatile unsigned char *)0x4800008D)
+#define CONTROL_PADCONF_GPMC_NCS0_BYTE2	((volatile unsigned char *)0x4800008E)
+#define CONTROL_PADCONF_GPMC_NCS0_BYTE3	((volatile unsigned char *)0x4800008F)
+
+/* Pin Muxing registers used for SDRC */
+#define CONTROL_PADCONF_SDRC_NCS0_BYTE0 ((volatile unsigned char *)0x480000A0)
+#define CONTROL_PADCONF_SDRC_NCS0_BYTE1 ((volatile unsigned char *)0x480000A1)
+#define CONTROL_PADCONF_SDRC_NCS0_BYTE2 ((volatile unsigned char *)0x480000A2)
+#define CONTROL_PADCONF_SDRC_NCS0_BYTE3 ((volatile unsigned char *)0x480000A3)
+
+#define CONTROL_PADCONF_SDRC_A14_BYTE0	((volatile unsigned char *)0x48000030)
+#define CONTROL_PADCONF_SDRC_A14_BYTE1	((volatile unsigned char *)0x48000031)
+#define CONTROL_PADCONF_SDRC_A14_BYTE2	((volatile unsigned char *)0x48000032)
+#define CONTROL_PADCONF_SDRC_A14_BYTE3	((volatile unsigned char *)0x48000033)
+
+/* Pin Muxing registers used for Touch Screen (SPI) */
+#define CONTROL_PADCONF_SPI1_CLK        ((volatile unsigned char *)0x480000FF)
+#define CONTROL_PADCONF_SPI1_SIMO       ((volatile unsigned char *)0x48000100)
+#define CONTROL_PADCONF_SPI1_SOMI       ((volatile unsigned char *)0x48000101)
+#define CONTROL_PADCONF_SPI1_NCS0       ((volatile unsigned char *)0x48000102)
+
+#define CONTROL_PADCONF_MCBSP1_FSR      ((volatile unsigned char *)0x4800010B)
+
+/* Pin Muxing registers used for MMCSD */
+#define CONTROL_PADCONF_MMC_CLKI        ((volatile unsigned char *)0x480000FE)
+#define CONTROL_PADCONF_MMC_CLKO        ((volatile unsigned char *)0x480000F3)
+#define CONTROL_PADCONF_MMC_CMD         ((volatile unsigned char *)0x480000F4)
+#define CONTROL_PADCONF_MMC_DAT0        ((volatile unsigned char *)0x480000F5)
+#define CONTROL_PADCONF_MMC_DAT1        ((volatile unsigned char *)0x480000F6)
+#define CONTROL_PADCONF_MMC_DAT2        ((volatile unsigned char *)0x480000F7)
+#define CONTROL_PADCONF_MMC_DAT3        ((volatile unsigned char *)0x480000F8)
+#define CONTROL_PADCONF_MMC_DAT_DIR0    ((volatile unsigned char *)0x480000F9)
+#define CONTROL_PADCONF_MMC_DAT_DIR1    ((volatile unsigned char *)0x480000FA)
+#define CONTROL_PADCONF_MMC_DAT_DIR2    ((volatile unsigned char *)0x480000FB)
+#define CONTROL_PADCONF_MMC_DAT_DIR3    ((volatile unsigned char *)0x480000FC)
+#define CONTROL_PADCONF_MMC_CMD_DIR     ((volatile unsigned char *)0x480000FD)
+
+#define CONTROL_PADCONF_SDRC_A14        ((volatile unsigned char *)0x48000030)
+#define CONTROL_PADCONF_SDRC_A13        ((volatile unsigned char *)0x48000031)
+
+/* Pin Muxing registers used for CAMERA */
+#define CONTROL_PADCONF_SYS_NRESWARM    ((volatile unsigned char *)0x4800012B)
+
+#define CONTROL_PADCONF_CAM_XCLK        ((volatile unsigned char *)0x480000DC)
+#define CONTROL_PADCONF_CAM_LCLK        ((volatile unsigned char *)0x480000DB)
+#define CONTROL_PADCONF_CAM_VS          ((volatile unsigned char *)0x480000DA)
+#define CONTROL_PADCONF_CAM_HS          ((volatile unsigned char *)0x480000D9)
+#define CONTROL_PADCONF_CAM_D0          ((volatile unsigned char *)0x480000D8)
+#define CONTROL_PADCONF_CAM_D1          ((volatile unsigned char *)0x480000D7)
+#define CONTROL_PADCONF_CAM_D2          ((volatile unsigned char *)0x480000D6)
+#define CONTROL_PADCONF_CAM_D3          ((volatile unsigned char *)0x480000D5)
+#define CONTROL_PADCONF_CAM_D4          ((volatile unsigned char *)0x480000D4)
+#define CONTROL_PADCONF_CAM_D5          ((volatile unsigned char *)0x480000D3)
+#define CONTROL_PADCONF_CAM_D6          ((volatile unsigned char *)0x480000D2)
+#define CONTROL_PADCONF_CAM_D7          ((volatile unsigned char *)0x480000D1)
+#define CONTROL_PADCONF_CAM_D8          ((volatile unsigned char *)0x480000D0)
+#define CONTROL_PADCONF_CAM_D9          ((volatile unsigned char *)0x480000CF)
+
+/* Pin Muxing registers used for LCD */
+#define CONTROL_PADCONF_DSS_D0          ((volatile unsigned char *)0x480000B3)
+#define CONTROL_PADCONF_DSS_D1          ((volatile unsigned char *)0x480000B4)
+#define CONTROL_PADCONF_DSS_D2          ((volatile unsigned char *)0x480000B5)
+#define CONTROL_PADCONF_DSS_D3          ((volatile unsigned char *)0x480000B6)
+#define CONTROL_PADCONF_DSS_D4          ((volatile unsigned char *)0x480000B7)
+#define CONTROL_PADCONF_DSS_D5          ((volatile unsigned char *)0x480000B8)
+#define CONTROL_PADCONF_DSS_D6          ((volatile unsigned char *)0x480000B9)
+#define CONTROL_PADCONF_DSS_D7          ((volatile unsigned char *)0x480000BA)
+#define CONTROL_PADCONF_DSS_D8          ((volatile unsigned char *)0x480000BB)
+#define CONTROL_PADCONF_DSS_D9          ((volatile unsigned char *)0x480000BC)
+#define CONTROL_PADCONF_DSS_D10         ((volatile unsigned char *)0x480000BD)
+#define CONTROL_PADCONF_DSS_D11         ((volatile unsigned char *)0x480000BE)
+#define CONTROL_PADCONF_DSS_D12         ((volatile unsigned char *)0x480000BF)
+#define CONTROL_PADCONF_DSS_D13         ((volatile unsigned char *)0x480000C0)
+#define CONTROL_PADCONF_DSS_D14         ((volatile unsigned char *)0x480000C1)
+#define CONTROL_PADCONF_DSS_D15         ((volatile unsigned char *)0x480000C2)
+#define CONTROL_PADCONF_DSS_D16         ((volatile unsigned char *)0x480000C3)
+#define CONTROL_PADCONF_DSS_D17         ((volatile unsigned char *)0x480000C4)
+#define CONTROL_PADCONF_DSS_PCLK        ((volatile unsigned char *)0x480000CB)
+#define CONTROL_PADCONF_DSS_VSYNC       ((volatile unsigned char *)0x480000CC)
+#define CONTROL_PADCONF_DSS_HSYNC       ((volatile unsigned char *)0x480000CD)
+#define CONTROL_PADCONF_DSS_ACBIAS      ((volatile unsigned char *)0x480000CE)
+
+/* Pin Muxing registers used for UART1 */
+#define CONTROL_PADCONF_UART1_CTS       ((volatile unsigned char *)0x480000C5)
+#define CONTROL_PADCONF_UART1_RTS       ((volatile unsigned char *)0x480000C6)
+#define CONTROL_PADCONF_UART1_TX        ((volatile unsigned char *)0x480000C7)
+#define CONTROL_PADCONF_UART1_RX        ((volatile unsigned char *)0x480000C8)
+
+/* Pin Muxing registers used for I2C1 */
+#define CONTROL_PADCONF_I2C1_SCL        ((volatile unsigned char *)0x48000111)
+#define CONTROL_PADCONF_I2C1_SDA        ((volatile unsigned char *)0x48000112)
+
+/* Pin Muxing registres used for USB0. */
+#define CONTROL_PADCONF_USB0_PUEN		((volatile uint8 *)0x4800011D)
+#define CONTROL_PADCONF_USB0_VP			((volatile uint8 *)0x4800011E)
+#define CONTROL_PADCONF_USB0_VM			((volatile uint8 *)0x4800011F)
+#define CONTROL_PADCONF_USB0_RCV		((volatile uint8 *)0x48000120)
+#define CONTROL_PADCONF_USB0_TXEN		((volatile uint8 *)0x48000121)
+#define CONTROL_PADCONF_USB0_SE0		((volatile uint8 *)0x48000122)
+#define CONTROL_PADCONF_USB0_DAT		((volatile uint8 *)0x48000123)
+
+/* Pin Muxing registers used for UART3/IRDA */
+#define CONTROL_PADCONF_UART3_TX_IRTX	((volatile uint8 *)0x48000118)
+#define CONTROL_PADCONF_UART3_RX_IRRX	((volatile uint8 *)0x48000119)
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch-arm1136/omap2420.h u-boot-1.2.0-leopard/include/asm/arch-arm1136/omap2420.h
--- u-boot-1.2.0/include/asm/arch-arm1136/omap2420.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm1136/omap2420.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,221 @@
+/*
+ * (C) Copyright 2004
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _OMAP2420_SYS_H_
+#define _OMAP2420_SYS_H_
+
+#include <asm/arch/sizes.h>
+
+/*
+ * 2420 specific Section
+ */
+
+/* L3 Firewall */
+#define A_REQINFOPERM0        0x68005048
+#define A_READPERM0           0x68005050
+#define A_WRITEPERM0          0x68005058
+/* #define GP_DEVICE	(BIT8|BIT9)  FIXME -- commented out to make compile -- FIXME */
+
+/* L3 Firewall */
+#define A_REQINFOPERM0        0x68005048
+#define A_READPERM0           0x68005050
+#define A_WRITEPERM0          0x68005058
+
+/* CONTROL */
+#define OMAP2420_CTRL_BASE    (0x48000000)
+#define CONTROL_STATUS        (OMAP2420_CTRL_BASE + 0x2F8)
+
+/* device type */
+#define TST_DEVICE	0x0
+#define EMU_DEVICE	0x1
+#define HS_DEVICE	0x2
+#define GP_DEVICE	0x3
+
+/* TAP information */
+#define OMAP2420_TAP_BASE     (0x48014000)
+#define TAP_IDCODE_REG        (OMAP2420_TAP_BASE+0x204)
+#define PRODUCTION_ID         (OMAP2420_TAP_BASE+0x208)
+
+/* GPMC */
+#define OMAP2420_GPMC_BASE    (0x6800A000)
+#define GPMC_SYSCONFIG        (OMAP2420_GPMC_BASE+0x10)
+#define GPMC_IRQENABLE        (OMAP2420_GPMC_BASE+0x1C)
+#define GPMC_TIMEOUT_CONTROL  (OMAP2420_GPMC_BASE+0x40)
+#define GPMC_CONFIG           (OMAP2420_GPMC_BASE+0x50)
+#define GPMC_CONFIG1_0        (OMAP2420_GPMC_BASE+0x60)
+#define GPMC_CONFIG2_0        (OMAP2420_GPMC_BASE+0x64)
+#define GPMC_CONFIG3_0        (OMAP2420_GPMC_BASE+0x68)
+#define GPMC_CONFIG4_0        (OMAP2420_GPMC_BASE+0x6C)
+#define GPMC_CONFIG5_0        (OMAP2420_GPMC_BASE+0x70)
+#define GPMC_CONFIG6_0        (OMAP2420_GPMC_BASE+0x74)
+#define GPMC_CONFIG7_0	      (OMAP2420_GPMC_BASE+0x78)
+#define GPMC_CONFIG1_1        (OMAP2420_GPMC_BASE+0x90)
+#define GPMC_CONFIG2_1        (OMAP2420_GPMC_BASE+0x94)
+#define GPMC_CONFIG3_1        (OMAP2420_GPMC_BASE+0x98)
+#define GPMC_CONFIG4_1        (OMAP2420_GPMC_BASE+0x9C)
+#define GPMC_CONFIG5_1        (OMAP2420_GPMC_BASE+0xA0)
+#define GPMC_CONFIG6_1        (OMAP2420_GPMC_BASE+0xA4)
+#define GPMC_CONFIG7_1	      (OMAP2420_GPMC_BASE+0xA8)
+
+/* SMS */
+#define OMAP2420_SMS_BASE 0x68008000
+#define SMS_SYSCONFIG     (OMAP2420_SMS_BASE+0x10)
+#define SMS_CLASS_ARB0    (OMAP2420_SMS_BASE+0xD0)
+# define BURSTCOMPLETE_GROUP7    BIT31
+
+/* SDRC */
+#define OMAP2420_SDRC_BASE 0x68009000
+#define SDRC_SYSCONFIG     (OMAP2420_SDRC_BASE+0x10)
+#define SDRC_STATUS        (OMAP2420_SDRC_BASE+0x14)
+#define SDRC_CS_CFG        (OMAP2420_SDRC_BASE+0x40)
+#define SDRC_SHARING       (OMAP2420_SDRC_BASE+0x44)
+#define SDRC_DLLA_CTRL     (OMAP2420_SDRC_BASE+0x60)
+#define SDRC_DLLB_CTRL     (OMAP2420_SDRC_BASE+0x68)
+#define SDRC_POWER         (OMAP2420_SDRC_BASE+0x70)
+#define SDRC_MCFG_0        (OMAP2420_SDRC_BASE+0x80)
+#define SDRC_MR_0          (OMAP2420_SDRC_BASE+0x84)
+#define SDRC_ACTIM_CTRLA_0 (OMAP2420_SDRC_BASE+0x9C)
+#define SDRC_ACTIM_CTRLB_0 (OMAP2420_SDRC_BASE+0xA0)
+#define SDRC_ACTIM_CTRLA_1 (OMAP2420_SDRC_BASE+0xC4)
+#define SDRC_ACTIM_CTRLB_1 (OMAP2420_SDRC_BASE+0xC8)
+#define SDRC_RFR_CTRL      (OMAP2420_SDRC_BASE+0xA4)
+#define SDRC_MANUAL_0      (OMAP2420_SDRC_BASE+0xA8)
+#define OMAP2420_SDRC_CS0  0x80000000
+#define OMAP2420_SDRC_CS1  0xA0000000
+#define CMD_NOP            0x0
+#define CMD_PRECHARGE      0x1
+#define CMD_AUTOREFRESH    0x2
+#define CMD_ENTR_PWRDOWN   0x3
+#define CMD_EXIT_PWRDOWN   0x4
+#define CMD_ENTR_SRFRSH    0x5
+#define CMD_CKE_HIGH       0x6
+#define CMD_CKE_LOW        0x7
+#define SOFTRESET          BIT1
+#define SMART_IDLE         (0x2 << 3)
+#define REF_ON_IDLE        (0x1 << 6)
+
+
+/* UART */
+#define OMAP2420_UART1	      0x4806A000
+#define OMAP2420_UART2	      0x4806C000
+#define OMAP2420_UART3        0x4806E000
+
+/* General Purpose Timers */
+#define OMAP2420_GPT1         0x48028000
+#define OMAP2420_GPT2         0x4802A000
+#define OMAP2420_GPT3         0x48078000
+#define OMAP2420_GPT4         0x4807A000
+#define OMAP2420_GPT5         0x4807C000
+#define OMAP2420_GPT6         0x4807E000
+#define OMAP2420_GPT7         0x48080000
+#define OMAP2420_GPT8         0x48082000
+#define OMAP2420_GPT9         0x48084000
+#define OMAP2420_GPT10        0x48086000
+#define OMAP2420_GPT11        0x48088000
+#define OMAP2420_GPT12        0x4808A000
+
+/* timer regs offsets (32 bit regs) */
+#define TIDR       0x0      /* r */
+#define TIOCP_CFG  0x10     /* rw */
+#define TISTAT     0x14     /* r */
+#define TISR       0x18     /* rw */
+#define TIER       0x1C     /* rw */
+#define TWER       0x20     /* rw */
+#define TCLR       0x24     /* rw */
+#define TCRR       0x28     /* rw */
+#define TLDR       0x2C     /* rw */
+#define TTGR       0x30     /* rw */
+#define TWPS       0x34     /* r */
+#define TMAR       0x38     /* rw */
+#define TCAR1      0x3c     /* r */
+#define TSICR      0x40     /* rw */
+#define TCAR2      0x44     /* r */
+
+/* WatchDog Timers (1 secure, 3 GP) */
+#define WD1_BASE              0x48020000
+#define WD2_BASE              0x48022000
+#define WD3_BASE              0x48024000
+#define WD4_BASE              0x48026000
+#define WWPS       0x34     /* r */
+#define WSPR       0x48     /* rw */
+#define WD_UNLOCK1 0xAAAA
+#define WD_UNLOCK2 0x5555
+
+/* PRCM */
+#define OMAP2420_CM_BASE 0x48008000
+#define PRCM_CLKCFG_CTRL (OMAP2420_CM_BASE+0x080)
+#define CM_CLKSEL_MPU    (OMAP2420_CM_BASE+0x140)
+#define CM_FCLKEN1_CORE  (OMAP2420_CM_BASE+0x200)
+#define CM_FCLKEN2_CORE  (OMAP2420_CM_BASE+0x204)
+#define CM_ICLKEN1_CORE  (OMAP2420_CM_BASE+0x210)
+#define CM_ICLKEN2_CORE  (OMAP2420_CM_BASE+0x214)
+#define CM_CLKSEL1_CORE  (OMAP2420_CM_BASE+0x240)
+#define CM_CLKSEL_WKUP   (OMAP2420_CM_BASE+0x440)
+#define CM_CLKSEL2_CORE  (OMAP2420_CM_BASE+0x244)
+#define CM_CLKSEL_GFX    (OMAP2420_CM_BASE+0x340)
+#define PM_RSTCTRL_WKUP  (OMAP2420_CM_BASE+0x450)
+#define CM_CLKEN_PLL     (OMAP2420_CM_BASE+0x500)
+#define CM_IDLEST_CKGEN  (OMAP2420_CM_BASE+0x520)
+#define CM_CLKSEL1_PLL   (OMAP2420_CM_BASE+0x540)
+#define CM_CLKSEL2_PLL   (OMAP2420_CM_BASE+0x544)
+#define CM_CLKSEL_DSP    (OMAP2420_CM_BASE+0x840)
+
+/*
+ * H4 specific Section
+ */
+
+/*
+ *  The 2420's chip selects are programmable.  The mask ROM
+ *  does configure CS0 to 0x08000000 before dispatch.  So, if
+ *  you want your code to live below that address, you have to
+ *  be prepared to jump though hoops, to reset the base address.
+ */
+#if defined(CONFIG_OMAP2420H4)
+/* GPMC */
+#ifdef CONFIG_VIRTIO_A        /* Pre version B */
+# define H4_CS0_BASE           0x08000000  /* flash (64 Meg aligned) */
+# define H4_CS1_BASE           0x04000000  /* debug board */
+# define H4_CS2_BASE           0x0A000000  /* wifi board */
+#else
+# define H4_CS0_BASE           0x04000000  /* flash (64 Meg aligned) */
+# define H4_CS1_BASE           0x08000000  /* debug board */
+# define H4_CS2_BASE           0x0A000000  /* wifi board */
+#endif
+
+/* base address for indirect vectors (internal boot mode) */
+#define SRAM_OFFSET0          0x40000000
+#define SRAM_OFFSET1          0x00200000
+#define SRAM_OFFSET2          0x0000F800
+#define SRAM_VECT_CODE       (SRAM_OFFSET0|SRAM_OFFSET1|SRAM_OFFSET2)
+
+#define LOW_LEVEL_SRAM_STACK  0x4020FFFC
+
+#define PERIFERAL_PORT_BASE   0x480FE003
+
+/* FPGA on Debug board.*/
+#define ETH_CONTROL_REG       (H4_CS1_BASE+0x30b)
+#define LAN_RESET_REGISTER    (H4_CS1_BASE+0x1c)
+#endif  /* endif CONFIG_2420H4 */
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch-arm1136/sizes.h u-boot-1.2.0-leopard/include/asm/arch-arm1136/sizes.h
--- u-boot-1.2.0/include/asm/arch-arm1136/sizes.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm1136/sizes.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,49 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
+ */
+/*  Size defintions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h			1
+
+/* handy sizes */
+#define SZ_1K				0x00000400
+#define SZ_4K				0x00001000
+#define SZ_8K				0x00002000
+#define SZ_16K				0x00004000
+#define SZ_32K				0x00008000
+#define SZ_64K				0x00010000
+#define SZ_128K				0x00020000
+#define SZ_256K				0x00040000
+#define SZ_512K				0x00080000
+
+#define SZ_1M				0x00100000
+#define SZ_2M				0x00200000
+#define SZ_4M				0x00400000
+#define SZ_8M				0x00800000
+#define SZ_16M				0x01000000
+#define SZ_31M				0x01F00000
+#define SZ_32M				0x02000000
+#define SZ_64M				0x04000000
+#define SZ_128M				0x08000000
+#define SZ_256M				0x10000000
+#define SZ_512M				0x20000000
+
+#define SZ_1G				0x40000000
+#define SZ_2G				0x80000000
+
+#endif	/* __sizes_h */
diff -Nurd u-boot-1.2.0/include/asm/arch-arm1136/sys_info.h u-boot-1.2.0-leopard/include/asm/arch-arm1136/sys_info.h
--- u-boot-1.2.0/include/asm/arch-arm1136/sys_info.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm1136/sys_info.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,82 @@
+/*
+ * (C) Copyright 2004
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _OMAP24XX_SYS_INFO_H_
+#define _OMAP24XX_SYS_INFO_H_
+
+typedef struct  h4_system_data {
+	/* base board info */
+	u32 base_b_rev;		/* rev from base board i2c */
+	/* cpu board info */
+	u32 cpu_b_rev;		/* rev from cpu board i2c */
+	u32 cpu_b_mux;		/* mux type on daughter board */
+	u32 cpu_b_ddr_type;	/* mem type */
+	u32 cpu_b_ddr_speed;	/* ddr speed rating */
+	u32 cpu_b_switches;	/* boot ctrl switch settings */
+	/* cpu info */
+	u32 cpu_type;		/* type of cpu; 2420, 2422, 2430,...*/
+	u32 cpu_rev;		/* rev of given cpu; ES1, ES2,...*/
+} h4_sys_data;
+
+#define XDR_POP           5      /* package on package part */
+#define SDR_DISCRETE      4      /* 128M memory SDR module*/
+#define DDR_STACKED       3      /* stacked part on 2422 */
+#define DDR_COMBO         2      /* combo part on cpu daughter card (menalaeus) */
+#define DDR_DISCRETE      1      /* 2x16 parts on daughter card */
+
+#define DDR_100           100    /* type found on most mem d-boards */
+#define DDR_111           111    /* some combo parts */
+#define DDR_133           133    /* most combo, some mem d-boards */
+#define DDR_165           165    /* future parts */
+
+#define CPU_2420          0x2420
+#define CPU_2422          0x2422 /* 2420 + 64M stacked */
+#define CPU_2423          0x2423 /* 2420 + 96M stacked */
+
+#define CPU_2422_ES1      1
+#define CPU_2422_ES2      2
+#define CPU_2420_ES1      1
+#define CPU_2420_ES2      2
+#define CPU_2420_2422_ES1 1
+
+#define CPU_2420_CHIPID   0x0B5D9000
+#define CPU_24XX_ID_MASK  0x0FFFF000
+#define CPU_242X_REV_MASK 0xF0000000
+#define CPU_242X_PID_MASK 0x000F0000
+
+#define BOARD_H4_MENELAUS 1
+#define BOARD_H4_SDP      2
+
+#define GPMC_MUXED        1
+#define GPMC_NONMUXED     0
+
+#define TYPE_NAND         0x800   /* bit pos for nand in gpmc reg */
+#define TYPE_NOR          0x000
+
+#define WIDTH_8BIT        0x0000
+#define WIDTH_16BIT       0x1000  /* bit pos for 16 bit in gpmc */
+
+#define I2C_MENELAUS 0x72	/* i2c id for companion chip */
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch-arm1136/sys_proto.h u-boot-1.2.0-leopard/include/asm/arch-arm1136/sys_proto.h
--- u-boot-1.2.0/include/asm/arch-arm1136/sys_proto.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm1136/sys_proto.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,54 @@
+/*
+ * (C) Copyright 2004
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+  */
+#ifndef _OMAP24XX_SYS_PROTO_H_
+#define _OMAP24XX_SYS_PROTO_H_
+
+void prcm_init(void);
+void memif_init(void);
+void sdrc_init(void);
+void do_sdrc_init(u32,u32);
+void gpmc_init(void);
+
+void ether_init(void);
+void watchdog_init(void);
+void set_muxconf_regs(void);
+void peripheral_enable(void);
+
+u32 get_cpu_type(void);
+u32 get_cpu_rev(void);
+u32 get_mem_type(void);
+u32 get_sysboot_value(void);
+u32 get_gpmc0_base(void);
+u32 is_gpmc_muxed(void);
+u32 get_gpmc0_type(void);
+u32 get_gpmc0_width(void);
+u32 wait_on_value(u32 read_bit_mask, u32 match_value, u32 read_addr, u32 bound);
+u32 get_board_type(void);
+void display_board_info(u32);
+void update_mux(u32,u32);
+u32 get_sdr_cs_size(u32 offset);
+
+u32 running_in_sdram(void);
+u32 running_in_sram(void);
+u32 running_in_flash(void);
+u32 running_from_internal_boot(void);
+u32 get_device_type(void);
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch-arm720t/hardware.h u-boot-1.2.0-leopard/include/asm/arch-arm720t/hardware.h
--- u-boot-1.2.0/include/asm/arch-arm720t/hardware.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm720t/hardware.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,43 @@
+#ifndef __ARM7_HW_H
+#define __ARM7_HW_H
+
+/*
+ * Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ * Curt Brune <curt@cucy.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#if defined(CONFIG_S3C4510B)
+#include <asm-arm/arch-arm720t/s3c4510b.h>
+#elif defined(CONFIG_NETARM)
+#include <asm-arm/arch-arm720t/netarm_registers.h>
+#elif defined(CONFIG_IMPA7)
+/* include IMPA7 specific hardware file if there was one */
+#elif defined(CONFIG_EP7312)
+/* include EP7312 specific hardware file if there was one */
+#elif defined(CONFIG_ARMADILLO)
+/* include armadillo specific hardware file if there was one */
+#elif defined(CONFIG_INTEGRATOR) && defined(CONFIG_ARCH_INTEGRATOR)
+/* include IntegratorCP/CM720T specific hardware file if there was one */
+#else
+#error No hardware file defined for this configuration
+#endif
+
+#endif /* __ARM7_HW_H */
diff -Nurd u-boot-1.2.0/include/asm/arch-arm720t/netarm_dma_module.h u-boot-1.2.0-leopard/include/asm/arch-arm720t/netarm_dma_module.h
--- u-boot-1.2.0/include/asm/arch-arm720t/netarm_dma_module.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm720t/netarm_dma_module.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,182 @@
+/* * include/asm-armnommu/arch-netarm/netarm_dma_module.h
+ *
+ * Copyright (C) 2000 NETsilicon, Inc.
+ * Copyright (C) 2000 WireSpeed Communications Corporation
+ *
+ * This software is copyrighted by WireSpeed. LICENSEE agrees that
+ * it will not delete this copyright notice, trademarks or protective
+ * notices from any copy made by LICENSEE.
+ *
+ * This software is provided "AS-IS" and any express or implied
+ * warranties or conditions, including but not limited to any
+ * implied warranties of merchantability and fitness for a particular
+ * purpose regarding this software. In no event shall WireSpeed
+ * be liable for any indirect, consequential, or incidental damages,
+ * loss of profits or revenue, loss of use or data, or interruption
+ * of business, whether the alleged damages are labeled in contract,
+ * tort, or indemnity.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * author(s) : Joe deBlaquiere
+ *             David Smith
+ */
+
+#ifndef __NETARM_DMA_MODULE_REGISTERS_H
+#define __NETARM_DMA_MODULE_REGISTERS_H
+
+/* GEN unit register offsets */
+
+#define	NETARM_DMA_MODULE_BASE		(0xFF900000)
+
+#define get_dma_reg_addr(c) ((volatile unsigned int *)(NETARM_DMA_MODULE_BASE + (c)))
+
+#define	NETARM_DMA1A_BFR_DESCRPTOR_PTR	(0x00)
+#define	NETARM_DMA1A_CONTROL		(0x10)
+#define	NETARM_DMA1A_STATUS		(0x14)
+#define	NETARM_DMA1B_BFR_DESCRPTOR_PTR	(0x20)
+#define	NETARM_DMA1B_CONTROL		(0x30)
+#define	NETARM_DMA1B_STATUS		(0x34)
+#define	NETARM_DMA1C_BFR_DESCRPTOR_PTR	(0x40)
+#define	NETARM_DMA1C_CONTROL		(0x50)
+#define	NETARM_DMA1C_STATUS		(0x54)
+#define	NETARM_DMA1D_BFR_DESCRPTOR_PTR	(0x60)
+#define	NETARM_DMA1D_CONTROL		(0x70)
+#define	NETARM_DMA1D_STATUS		(0x74)
+
+#define	NETARM_DMA2_BFR_DESCRPTOR_PTR	(0x80)
+#define	NETARM_DMA2_CONTROL		(0x90)
+#define	NETARM_DMA2_STATUS		(0x94)
+
+#define	NETARM_DMA3_BFR_DESCRPTOR_PTR	(0xA0)
+#define	NETARM_DMA3_CONTROL		(0xB0)
+#define	NETARM_DMA3_STATUS		(0xB4)
+
+#define	NETARM_DMA4_BFR_DESCRPTOR_PTR	(0xC0)
+#define	NETARM_DMA4_CONTROL		(0xD0)
+#define	NETARM_DMA4_STATUS		(0xD4)
+
+#define	NETARM_DMA5_BFR_DESCRPTOR_PTR	(0xE0)
+#define	NETARM_DMA5_CONTROL		(0xF0)
+#define	NETARM_DMA5_STATUS		(0xF4)
+
+#define	NETARM_DMA6_BFR_DESCRPTOR_PTR	(0x100)
+#define	NETARM_DMA6_CONTROL		(0x110)
+#define	NETARM_DMA6_STATUS		(0x114)
+
+#define	NETARM_DMA7_BFR_DESCRPTOR_PTR	(0x120)
+#define	NETARM_DMA7_CONTROL		(0x130)
+#define	NETARM_DMA7_STATUS		(0x134)
+
+#define	NETARM_DMA8_BFR_DESCRPTOR_PTR	(0x140)
+#define	NETARM_DMA8_CONTROL		(0x150)
+#define	NETARM_DMA8_STATUS		(0x154)
+
+#define	NETARM_DMA9_BFR_DESCRPTOR_PTR	(0x160)
+#define	NETARM_DMA9_CONTROL		(0x170)
+#define	NETARM_DMA9_STATUS		(0x174)
+
+#define	NETARM_DMA10_BFR_DESCRPTOR_PTR	(0x180)
+#define	NETARM_DMA10_CONTROL		(0x190)
+#define	NETARM_DMA10_STATUS		(0x194)
+
+/* select bitfield defintions */
+
+/* DMA Control Register ( 0xFF90_0XX0 ) */
+
+#define NETARM_DMA_CTL_ENABLE		(0x80000000)
+
+#define NETARM_DMA_CTL_ABORT		(0x40000000)
+
+#define NETARM_DMA_CTL_BUS_100_PERCENT	(0x00000000)
+#define NETARM_DMA_CTL_BUS_75_PERCENT	(0x10000000)
+#define NETARM_DMA_CTL_BUS_50_PERCENT	(0x20000000)
+#define NETARM_DMA_CTL_BUS_25_PERCENT	(0x30000000)
+
+#define NETARM_DMA_CTL_BUS_MASK		(0x30000000)
+
+#define NETARM_DMA_CTL_MODE_FB_TO_MEM	(0x00000000)
+#define NETARM_DMA_CTL_MODE_FB_FROM_MEM	(0x04000000)
+#define NETARM_DMA_CTL_MODE_MEM_TO_MEM	(0x08000000)
+
+#define NETARM_DMA_CTL_BURST_NONE	(0x00000000)
+#define NETARM_DMA_CTL_BURST_8_BYTE	(0x01000000)
+#define NETARM_DMA_CTL_BURST_16_BYTE	(0x02000000)
+
+#define NETARM_DMA_CTL_BURST_MASK	(0x03000000)
+
+#define NETARM_DMA_CTL_SRC_INCREMENT	(0x00200000)
+
+#define NETARM_DMA_CTL_DST_INCREMENT	(0x00100000)
+
+/* these apply only to ext xfers on DMA 3 or 4 */
+
+#define NETARM_DMA_CTL_CH_3_4_REQ_EXT	(0x00800000)
+
+#define NETARM_DMA_CTL_CH_3_4_DATA_32	(0x00000000)
+#define NETARM_DMA_CTL_CH_3_4_DATA_16	(0x00010000)
+#define NETARM_DMA_CTL_CH_3_4_DATA_8	(0x00020000)
+
+#define NETARM_DMA_CTL_STATE(X)	((X) & 0xFC00)
+#define NETARM_DMA_CTL_INDEX(X)	((X) & 0x03FF)
+
+/* DMA Status Register ( 0xFF90_0XX4 ) */
+
+#define NETARM_DMA_STAT_NC_INTPEN	(0x80000000)
+#define NETARM_DMA_STAT_EC_INTPEN	(0x40000000)
+#define NETARM_DMA_STAT_NR_INTPEN	(0x20000000)
+#define NETARM_DMA_STAT_CA_INTPEN	(0x10000000)
+#define NETARM_DMA_STAT_INTPEN_MASK	(0xF0000000)
+
+#define NETARM_DMA_STAT_NC_INT_EN	(0x00800000)
+#define NETARM_DMA_STAT_EC_INT_EN	(0x00400000)
+#define NETARM_DMA_STAT_NR_INT_EN	(0x00200000)
+#define NETARM_DMA_STAT_CA_INT_EN	(0x00100000)
+#define NETARM_DMA_STAT_INT_EN_MASK	(0x00F00000)
+
+#define NETARM_DMA_STAT_WRAP		(0x00080000)
+#define NETARM_DMA_STAT_IDONE		(0x00040000)
+#define NETARM_DMA_STAT_LAST		(0x00020000)
+#define NETARM_DMA_STAT_FULL		(0x00010000)
+
+#define	NETARM_DMA_STAT_BUFLEN(X)	((X) & 0x7FFF)
+
+/* DMA Buffer Descriptor Word 0 bitfields. */
+
+#define NETARM_DMA_BD0_WRAP		(0x80000000)
+#define NETARM_DMA_BD0_IDONE		(0x40000000)
+#define NETARM_DMA_BD0_LAST		(0x20000000)
+#define NETARM_DMA_BD0_BUFPTR_MASK	(0x1FFFFFFF)
+
+/* DMA Buffer Descriptor Word 1 bitfields. */
+
+#define NETARM_DMA_BD1_STATUS_MASK	(0xFFFF0000)
+#define NETARM_DMA_BD1_FULL		(0x00008000)
+#define NETARM_DMA_BD1_BUFLEN_MASK	(0x00007FFF)
+
+#ifndef	__ASSEMBLER__
+
+typedef	struct __NETARM_DMA_Buff_Desc_FlyBy
+{
+	unsigned int word0;
+	unsigned int word1;
+} NETARM_DMA_Buff_Desc_FlyBy, *pNETARM_DMA_Buff_Desc_FlyBy ;
+
+typedef	struct __NETARM_DMA_Buff_Desc_M_to_M
+{
+	unsigned int word0;
+	unsigned int word1;
+	unsigned int word2;
+	unsigned int word3;
+} NETARM_DMA_Buff_Desc_M_to_M, *pNETARM_DMA_Buff_Desc_M_to_M ;
+
+#endif
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch-arm720t/netarm_eni_module.h u-boot-1.2.0-leopard/include/asm/arch-arm720t/netarm_eni_module.h
--- u-boot-1.2.0/include/asm/arch-arm720t/netarm_eni_module.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm720t/netarm_eni_module.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,121 @@
+/*
+ * include/asm-armnommu/arch-netarm/netarm_eni_module.h
+ *
+ * Copyright (C) 2000 NETsilicon, Inc.
+ * Copyright (C) 2000 WireSpeed Communications Corporation
+ *
+ * This software is copyrighted by WireSpeed. LICENSEE agrees that
+ * it will not delete this copyright notice, trademarks or protective
+ * notices from any copy made by LICENSEE.
+ *
+ * This software is provided "AS-IS" and any express or implied
+ * warranties or conditions, including but not limited to any
+ * implied warranties of merchantability and fitness for a particular
+ * purpose regarding this software. In no event shall WireSpeed
+ * be liable for any indirect, consequential, or incidental damages,
+ * loss of profits or revenue, loss of use or data, or interruption
+ * of business, whether the alleged damages are labeled in contract,
+ * tort, or indemnity.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * author(s) : David Smith
+ */
+
+#ifndef __NETARM_ENI_MODULE_REGISTERS_H
+#define __NETARM_ENI_MODULE_REGISTERS_H
+
+/* ENI unit register offsets */
+
+/* #ifdef CONFIG_ARCH_NETARM */
+#define	NETARM_ENI_MODULE_BASE		(0xFFA00000)
+/* #endif / * CONFIG_ARCH_NETARM */
+
+#define get_eni_reg_addr(c) ((volatile unsigned int *)(NETARM_ENI_MODULE_BASE + (c)))
+#define get_eni_ctl_reg_addr(minor) \
+	(get_eni_reg_addr(NETARM_ENI_1284_PORT1_CONTROL) + (minor))
+
+#define	NETARM_ENI_GENERAL_CONTROL	(0x00)
+#define	NETARM_ENI_STATUS_CONTROL	(0x04)
+#define	NETARM_ENI_FIFO_MODE_DATA	(0x08)
+
+#define	NETARM_ENI_1284_PORT1_CONTROL	(0x10)
+#define	NETARM_ENI_1284_PORT2_CONTROL	(0x14)
+#define	NETARM_ENI_1284_PORT3_CONTROL	(0x18)
+#define	NETARM_ENI_1284_PORT4_CONTROL	(0x1c)
+
+#define	NETARM_ENI_1284_CHANNEL1_DATA	(0x20)
+#define	NETARM_ENI_1284_CHANNEL2_DATA	(0x24)
+#define	NETARM_ENI_1284_CHANNEL3_DATA	(0x28)
+#define	NETARM_ENI_1284_CHANNEL4_DATA	(0x2c)
+
+#define	NETARM_ENI_ENI_CONTROL		(0x30)
+#define	NETARM_ENI_ENI_PULSED_INTR	(0x34)
+#define	NETARM_ENI_ENI_SHARED_RAM_ADDR	(0x38)
+#define	NETARM_ENI_ENI_SHARED		(0x3c)
+
+/* select bitfield defintions */
+
+/* General Control Register (0xFFA0_0000) */
+
+#define NETARM_ENI_GCR_ENIMODE_IEEE1284	(0x00000001)
+#define NETARM_ENI_GCR_ENIMODE_SHRAM16	(0x00000004)
+#define NETARM_ENI_GCR_ENIMODE_SHRAM8	(0x00000005)
+#define NETARM_ENI_GCR_ENIMODE_FIFO16	(0x00000006)
+#define NETARM_ENI_GCR_ENIMODE_FIFO8	(0x00000007)
+
+#define NETARM_ENI_GCR_ENIMODE_MASK	(0x00000007)
+
+/* IEEE 1284 Port Control Registers 1-4 (0xFFA0_0010, 0xFFA0_0014,
+   0xFFA0_0018, 0xFFA0_001c) */
+
+#define NETARM_ENI_1284PC_PORT_ENABLE	(0x80000000)
+#define NETARM_ENI_1284PC_DMA_ENABLE	(0x40000000)
+#define NETARM_ENI_1284PC_OBE_INT_EN	(0x20000000)
+#define NETARM_ENI_1284PC_ACK_INT_EN	(0x10000000)
+#define NETARM_ENI_1284PC_ECP_MODE	(0x08000000)
+#define NETARM_ENI_1284PC_LOOPBACK_MODE	(0x04000000)
+
+#define NETARM_ENI_1284PC_STROBE_TIME0	(0x00000000) /* 0.5 uS */
+#define NETARM_ENI_1284PC_STROBE_TIME1	(0x01000000) /* 1.0 uS */
+#define NETARM_ENI_1284PC_STROBE_TIME2	(0x02000000) /* 5.0 uS */
+#define NETARM_ENI_1284PC_STROBE_TIME3	(0x03000000) /* 10.0 uS */
+#define NETARM_ENI_1284PC_STROBE_MASK	(0x03000000)
+
+#define NETARM_ENI_1284PC_MAN_STROBE_EN	(0x00800000)
+#define NETARM_ENI_1284PC_FAST_MODE	(0x00400000)
+#define NETARM_ENI_1284PC_BIDIR_MODE	(0x00200000)
+
+#define NETARM_ENI_1284PC_MAN_STROBE	(0x00080000)
+#define NETARM_ENI_1284PC_AUTO_FEED	(0x00040000)
+#define NETARM_ENI_1284PC_INIT		(0x00020000)
+#define NETARM_ENI_1284PC_HSELECT	(0x00010000)
+#define NETARM_ENI_1284PC_FE_INT_EN	(0x00008000)
+#define NETARM_ENI_1284PC_EPP_MODE	(0x00004000)
+#define NETARM_ENI_1284PC_IBR_INT_EN	(0x00002000)
+#define NETARM_ENI_1284PC_IBR		(0x00001000)
+
+#define NETARM_ENI_1284PC_RXFDB_1BYTE	(0x00000400)
+#define NETARM_ENI_1284PC_RXFDB_2BYTE	(0x00000800)
+#define NETARM_ENI_1284PC_RXFDB_3BYTE	(0x00000c00)
+#define NETARM_ENI_1284PC_RXFDB_4BYTE	(0x00000000)
+
+#define NETARM_ENI_1284PC_RBCC		(0x00000200)
+#define NETARM_ENI_1284PC_RBCT		(0x00000100)
+#define NETARM_ENI_1284PC_ACK		(0x00000080)
+#define NETARM_ENI_1284PC_FIFO_E	(0x00000040)
+#define NETARM_ENI_1284PC_OBE		(0x00000020)
+#define NETARM_ENI_1284PC_ACK_INT	(0x00000010)
+#define NETARM_ENI_1284PC_BUSY		(0x00000008)
+#define NETARM_ENI_1284PC_PE		(0x00000004)
+#define NETARM_ENI_1284PC_PSELECT	(0x00000002)
+#define NETARM_ENI_1284PC_FAULT		(0x00000001)
+
+#endif /* __NETARM_ENI_MODULE_REGISTERS_H */
diff -Nurd u-boot-1.2.0/include/asm/arch-arm720t/netarm_eth_module.h u-boot-1.2.0-leopard/include/asm/arch-arm720t/netarm_eth_module.h
--- u-boot-1.2.0/include/asm/arch-arm720t/netarm_eth_module.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm720t/netarm_eth_module.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,160 @@
+/*
+ * include/asm-armnommu/arch-netarm/netarm_eth_module.h
+ *
+ * Copyright (C) 2000 NETsilicon, Inc.
+ * Copyright (C) 2000 WireSpeed Communications Corporation
+ *
+ * This software is copyrighted by WireSpeed. LICENSEE agrees that
+ * it will not delete this copyright notice, trademarks or protective
+ * notices from any copy made by LICENSEE.
+ *
+ * This software is provided "AS-IS" and any express or implied
+ * warranties or conditions, including but not limited to any
+ * implied warranties of merchantability and fitness for a particular
+ * purpose regarding this software. In no event shall WireSpeed
+ * be liable for any indirect, consequential, or incidental damages,
+ * loss of profits or revenue, loss of use or data, or interruption
+ * of business, whether the alleged damages are labeled in contract,
+ * tort, or indemnity.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * author(s) : Jackie Smith Cashion
+ *             David Smith
+ */
+
+#ifndef __NETARM_ETH_MODULE_REGISTERS_H
+#define __NETARM_ETH_MODULE_REGISTERS_H
+
+/* ETH unit register offsets */
+
+#define	NETARM_ETH_MODULE_BASE		(0xFF800000)
+
+#define get_eth_reg_addr(c) ((volatile unsigned int *)(NETARM_ETH_MODULE_BASE + (c)))
+
+#define NETARM_ETH_GEN_CTRL		(0x000) /* Ethernet Gen Control Reg */
+#define NETARM_ETH_GEN_STAT		(0x004) /* Ethernet Gen Status Reg */
+#define NETARM_ETH_FIFO_DAT1            (0x008) /* Fifo Data Reg 1 */
+#define NETARM_ETH_FIFO_DAT2            (0x00C) /* Fifo Data Reg 2 */
+#define NETARM_ETH_TX_STAT              (0x010) /* Transmit Status Reg */
+#define NETARM_ETH_RX_STAT              (0x014) /* Receive Status Reg */
+
+#define NETARM_ETH_MAC_CFG		(0x400) /* MAC Configuration Reg */
+#define NETARM_ETH_PCS_CFG		(0x408) /* PCS Configuration Reg */
+#define NETARM_ETH_STL_CFG		(0x410) /* STL Configuration Reg */
+#define NETARM_ETH_B2B_IPG_GAP_TMR	(0x440) /* Back-to-back IPG
+						   Gap Timer Reg */
+#define NETARM_ETH_NB2B_IPG_GAP_TMR	(0x444) /* Non Back-to-back
+						   IPG Gap Timer Reg */
+#define NETARM_ETH_MII_CMD		(0x540) /* MII (PHY) Command Reg */
+#define NETARM_ETH_MII_ADDR		(0x544) /* MII Address Reg */
+#define NETARM_ETH_MII_WRITE		(0x548) /* MII Write Data Reg */
+#define NETARM_ETH_MII_READ		(0x54C) /* MII Read Data Reg */
+#define NETARM_ETH_MII_IND		(0x550) /* MII Indicators Reg */
+#define NETARM_ETH_MIB_CRCEC		(0x580) /* (MIB) CRC Error Counter */
+#define NETARM_ETH_MIB_AEC		(0x584) /* Alignment Error Counter */
+#define NETARM_ETH_MIB_CEC		(0x588) /* Code Error Counter */
+#define NETARM_ETH_MIB_LFC		(0x58C) /* Long Frame Counter */
+#define NETARM_ETH_MIB_SFC		(0x590) /* Short Frame Counter */
+#define NETARM_ETH_MIB_LCC		(0x594) /* Late Collision Counter */
+#define NETARM_ETH_MIB_EDC		(0x598) /* Excessive Deferral
+						   Counter */
+#define NETARM_ETH_MIB_MCC		(0x59C) /* Maximum Collision Counter */
+#define NETARM_ETH_SAL_FILTER		(0x5C0) /* SAL Station Address
+						   Filter Reg */
+#define NETARM_ETH_SAL_STATION_ADDR_1	(0x5C4) /* SAL Station Address
+						   Reg */
+#define NETARM_ETH_SAL_STATION_ADDR_2	(0x5C8)
+#define NETARM_ETH_SAL_STATION_ADDR_3	(0x5CC)
+#define NETARM_ETH_SAL_HASH_TBL_1	(0x5D0) /* SAL Multicast Hash Table*/
+#define NETARM_ETH_SAL_HASH_TBL_2	(0x5D4)
+#define NETARM_ETH_SAL_HASH_TBL_3	(0x5D8)
+#define NETARM_ETH_SAL_HASH_TBL_4	(0x5DC)
+
+/* select bitfield defintions */
+
+/* Ethernet General Control Register (0xFF80_0000) */
+
+#define NETARM_ETH_GCR_ERX		(0x80000000) /* Enable Receive FIFO */
+#define NETARM_ETH_GCR_ERXDMA		(0x40000000) /* Enable Receive DMA */
+#define NETARM_ETH_GCR_ETX		(0x00800000) /* Enable Transmit FIFO */
+#define NETARM_ETH_GCR_ETXDMA		(0x00400000) /* Enable Transmit DMA */
+#define NETARM_ETH_GCR_ETXWM_50		(0x00100000) /* Transmit FIFO Water
+							Mark.  Start transmit
+							when FIFO is 50%
+							full. */
+#define NETARM_ETH_GCR_PNA		(0x00000400) /* pSOS pNA Buffer
+							Descriptor Format */
+
+/* Ethernet General Status Register (0xFF80_0004) */
+
+#define NETARM_ETH_GST_RXFDB            (0x30000000)
+#define NETARM_ETH_GST_RXREGR		(0x08000000) /* Receive Register
+							Ready */
+#define NETARM_ETH_GST_RXFIFOH		(0x04000000)
+#define NETARM_ETH_GST_RXBR		(0x02000000)
+#define NETARM_ETH_GST_RXSKIP		(0x01000000)
+
+#define NETARM_ETH_GST_TXBC             (0x00020000)
+
+
+/* Ethernet Transmit Status Register (0xFF80_0010) */
+
+#define NETARM_ETH_TXSTAT_TXOK          (0x00008000)
+
+
+/* Ethernet Receive Status Register (0xFF80_0014) */
+
+#define NETARM_ETH_RXSTAT_SIZE          (0xFFFF0000)
+#define NETARM_ETH_RXSTAT_RXOK          (0x00002000)
+
+
+/* PCS Configuration Register (0xFF80_0408) */
+
+#define NETARM_ETH_PCSC_NOCFR		(0x1) /* Disable Ciphering */
+#define NETARM_ETH_PCSC_ENJAB		(0x2) /* Enable Jabber Protection */
+#define NETARM_ETH_PCSC_CLKS_25M	(0x0) /* 25 MHz Clock Speed Select */
+#define NETARM_ETH_PCSC_CLKS_33M	(0x4) /* 33 MHz Clock Speed Select */
+
+/* STL Configuration Register (0xFF80_0410) */
+
+#define NETARM_ETH_STLC_RXEN		(0x2) /* Enable Packet Receiver */
+#define NETARM_ETH_STLC_AUTOZ		(0x4) /* Auto Zero Statistics */
+
+/* MAC Configuration Register (0xFF80_0400) */
+
+#define NETARM_ETH_MACC_HUGEN		(0x1) /* Enable Unlimited Transmit
+						 Frame Sizes */
+#define NETARM_ETH_MACC_PADEN		(0x4) /* Automatic Pad Fill Frames
+						 to 64 Bytes */
+#define NETARM_ETH_MACC_CRCEN		(0x8) /* Append CRC to Transmit
+						 Frames */
+
+/* MII (PHY) Command Register (0xFF80_0540) */
+
+#define NETARM_ETH_MIIC_RSTAT		(0x1) /* Single Scan for Read Data */
+
+/* MII Indicators Register (0xFF80_0550) */
+
+#define NETARM_ETH_MIII_BUSY		(0x1) /* MII I/F Busy with
+						 Read/Write */
+
+/* SAL Station Address Filter Register (0xFF80_05C0) */
+
+#define NETARM_ETH_SALF_PRO		(0x8) /* Enable Promiscuous Mode */
+#define NETARM_ETH_SALF_PRM		(0x4) /* Accept All Multicast
+						 Packets */
+#define NETARM_ETH_SALF_PRA		(0x2) /* Accept Mulitcast Packets
+						 using Hash Table */
+#define NETARM_ETH_SALF_BROAD		(0x1) /* Accept All Broadcast
+						 Packets */
+
+
+#endif /* __NETARM_GEN_MODULE_REGISTERS_H */
diff -Nurd u-boot-1.2.0/include/asm/arch-arm720t/netarm_gen_module.h u-boot-1.2.0-leopard/include/asm/arch-arm720t/netarm_gen_module.h
--- u-boot-1.2.0/include/asm/arch-arm720t/netarm_gen_module.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm720t/netarm_gen_module.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,186 @@
+/*
+ * include/asm-armnommu/arch-netarm/netarm_gen_module.h
+ *
+ * Copyright (C) 2005
+ * Art Shipkowski, Videon Central, Inc., <art@videon-central.com>
+ *
+ * Copyright (C) 2000, 2001 NETsilicon, Inc.
+ * Copyright (C) 2000, 2001 Red Hat, Inc.
+ *
+ * This software is copyrighted by Red Hat. LICENSEE agrees that
+ * it will not delete this copyright notice, trademarks or protective
+ * notices from any copy made by LICENSEE.
+ *
+ * This software is provided "AS-IS" and any express or implied
+ * warranties or conditions, including but not limited to any
+ * implied warranties of merchantability and fitness for a particular
+ * purpose regarding this software. In no event shall Red Hat
+ * be liable for any indirect, consequential, or incidental damages,
+ * loss of profits or revenue, loss of use or data, or interruption
+ * of business, whether the alleged damages are labeled in contract,
+ * tort, or indemnity.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * author(s) : Joe deBlaquiere
+ *
+ * Modified to support NS7520 by Art Shipkowski.
+ */
+
+#ifndef __NETARM_GEN_MODULE_REGISTERS_H
+#define __NETARM_GEN_MODULE_REGISTERS_H
+
+/* GEN unit register offsets */
+
+#define NETARM_GEN_MODULE_BASE		(0xFFB00000)
+
+#define get_gen_reg_addr(c) ((volatile unsigned int *)(NETARM_GEN_MODULE_BASE + (c)))
+
+#define NETARM_GEN_SYSTEM_CONTROL	(0x00)
+#define NETARM_GEN_STATUS_CONTROL	(0x04)
+#define NETARM_GEN_PLL_CONTROL		(0x08)
+#define NETARM_GEN_SOFTWARE_SERVICE	(0x0c)
+
+#define NETARM_GEN_TIMER1_CONTROL	(0x10)
+#define NETARM_GEN_TIMER1_STATUS	(0x14)
+#define NETARM_GEN_TIMER2_CONTROL	(0x18)
+#define NETARM_GEN_TIMER2_STATUS	(0x1c)
+
+#define NETARM_GEN_PORTA		(0x20)
+#ifndef CONFIG_NETARM_NS7520
+#define NETARM_GEN_PORTB		(0x24)
+#endif
+#define NETARM_GEN_PORTC		(0x28)
+
+#define NETARM_GEN_INTR_ENABLE		(0x30)
+#define NETARM_GEN_INTR_ENABLE_SET	(0x34)
+#define NETARM_GEN_INTR_ENABLE_CLR	(0x38)
+#define NETARM_GEN_INTR_STATUS_EN	(0x34)
+#define NETARM_GEN_INTR_STATUS_RAW	(0x38)
+
+#define NETARM_GEN_CACHE_CONTROL1	(0x40)
+#define NETARM_GEN_CACHE_CONTROL2	(0x44)
+
+/* select bitfield definitions */
+
+/* System Control Register ( 0xFFB0_0000 ) */
+
+#define NETARM_GEN_SYS_CFG_LENDIAN	(0x80000000)
+#define NETARM_GEN_SYS_CFG_BENDIAN	(0x00000000)
+
+#define NETARM_GEN_SYS_CFG_BUSQRTR	(0x00000000)
+#define NETARM_GEN_SYS_CFG_BUSHALF	(0x20000000)
+#define NETARM_GEN_SYS_CFG_BUSFULL	(0x40000000)
+
+#define NETARM_GEN_SYS_CFG_BCLK_DISABLE (0x10000000)
+
+#define NETARM_GEN_SYS_CFG_WDOG_EN	(0x01000000)
+#define NETARM_GEN_SYS_CFG_WDOG_IRQ	(0x00000000)
+#define NETARM_GEN_SYS_CFG_WDOG_FIQ	(0x00400000)
+#define NETARM_GEN_SYS_CFG_WDOG_RST	(0x00800000)
+#define NETARM_GEN_SYS_CFG_WDOG_24	(0x00000000)
+#define NETARM_GEN_SYS_CFG_WDOG_26	(0x00100000)
+#define NETARM_GEN_SYS_CFG_WDOG_28	(0x00200000)
+#define NETARM_GEN_SYS_CFG_WDOG_29	(0x00300000)
+
+#define NETARM_GEN_SYS_CFG_BUSMON_EN	(0x00040000)
+#define NETARM_GEN_SYS_CFG_BUSMON_128	(0x00000000)
+#define NETARM_GEN_SYS_CFG_BUSMON_64	(0x00010000)
+#define NETARM_GEN_SYS_CFG_BUSMON_32	(0x00020000)
+#define NETARM_GEN_SYS_CFG_BUSMON_16	(0x00030000)
+
+#define NETARM_GEN_SYS_CFG_USER_EN	(0x00008000)
+#define NETARM_GEN_SYS_CFG_BUSER_EN	(0x00004000)
+
+#define NETARM_GEN_SYS_CFG_BUSARB_INT	(0x00002000)
+#define NETARM_GEN_SYS_CFG_BUSARB_EXT	(0x00000000)
+
+#define NETARM_GEN_SYS_CFG_DMATST	(0x00001000)
+
+#define NETARM_GEN_SYS_CFG_TEALAST	(0x00000800)
+
+#define NETARM_GEN_SYS_CFG_ALIGN_ABORT	(0x00000400)
+
+#define NETARM_GEN_SYS_CFG_CACHE_EN	(0x00000200)
+
+#define NETARM_GEN_SYS_CFG_WRI_BUF_EN	(0x00000100)
+
+#define NETARM_GEN_SYS_CFG_CACHE_INIT	(0x00000080)
+
+/* PLL Control Register ( 0xFFB0_0008 ) */
+
+#define NETARM_GEN_PLL_CTL_PLLCNT_MASK	(0x0F000000)
+
+#define NETARM_GEN_PLL_CTL_PLLCNT(x)	(((x)<<24) & \
+					 NETARM_GEN_PLL_CTL_PLLCNT_MASK)
+
+/* Defaults for POLTST and ICP Fields in PLL CTL */
+#define NETARM_GEN_PLL_CTL_OUTDIV(x)	(x)
+#define NETARM_GEN_PLL_CTL_INDIV(x)	((x)<<6)
+#define NETARM_GEN_PLL_CTL_POLTST_DEF	(0x00000E00)
+#define NETARM_GEN_PLL_CTL_ICP_DEF	(0x0000003C)
+
+
+/* Software Service Register ( 0xFFB0_000C ) */
+
+#define NETARM_GEN_SW_SVC_RESETA	(0x123)
+#define NETARM_GEN_SW_SVC_RESETB	(0x321)
+
+/* PORT C Register ( 0xFFB0_0028 ) */
+
+#ifndef CONFIG_NETARM_NS7520
+#define NETARM_GEN_PORT_MODE(x)		(((x)<<24) + (0xFF00))
+#define NETARM_GEN_PORT_DIR(x)		(((x)<<16) + (0xFF00))
+#else
+#define NETARM_GEN_PORT_MODE(x)		((x)<<24)
+#define NETARM_GEN_PORT_DIR(x)		((x)<<16)
+#define NETARM_GEN_PORT_CSF(x)		((x)<<8)
+#endif
+
+/* Timer Registers ( 0xFFB0_0010 0xFFB0_0018 ) */
+
+#define NETARM_GEN_TCTL_ENABLE		(0x80000000)
+#define NETARM_GEN_TCTL_INT_ENABLE	(0x40000000)
+
+#define NETARM_GEN_TCTL_USE_IRQ		(0x00000000)
+#define NETARM_GEN_TCTL_USE_FIQ		(0x20000000)
+
+#define NETARM_GEN_TCTL_USE_PRESCALE	(0x10000000)
+#define NETARM_GEN_TCTL_INIT_COUNT(x)	((x) & 0x1FF)
+
+#define NETARM_GEN_TSTAT_INTPEN		(0x40000000)
+#if ~defined(CONFIG_NETARM_NS7520)
+#define NETARM_GEN_TSTAT_CTC_MASK	(0x000001FF)
+#else
+#define NETARM_GEN_TSTAT_CTC_MASK	(0x0FFFFFFF)
+#endif
+
+/* prescale to msecs conversion */
+
+#if !defined(CONFIG_NETARM_PLL_BYPASS)
+#define NETARM_GEN_TIMER_MSEC_P(x)	( ( ( 20480 ) * ( 0x1FF - ( (x) &	    \
+					    NETARM_GEN_TSTAT_CTC_MASK ) +   \
+					    1 ) ) / (NETARM_XTAL_FREQ/1000) )
+
+#define NETARM_GEN_TIMER_SET_HZ(x)	( ( ((NETARM_XTAL_FREQ/(20480*(x)))-1) & \
+					  NETARM_GEN_TSTAT_CTC_MASK ) | \
+					  NETARM_GEN_TCTL_USE_PRESCALE )
+
+#else
+#define NETARM_GEN_TIMER_MSEC_P(x)	( ( ( 4096 ) * ( 0x1FF - ( (x) &    \
+					    NETARM_GEN_TSTAT_CTC_MASK ) +   \
+					    1 ) ) / (NETARM_XTAL_FREQ/1000) )
+
+#define NETARM_GEN_TIMER_SET_HZ(x)	( ( ((NETARM_XTAL_FREQ/(4096*(x)))-1) & \
+					  NETARM_GEN_TSTAT_CTC_MASK ) | \
+					  NETARM_GEN_TCTL_USE_PRESCALE )
+#endif
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch-arm720t/netarm_mem_module.h u-boot-1.2.0-leopard/include/asm/arch-arm720t/netarm_mem_module.h
--- u-boot-1.2.0/include/asm/arch-arm720t/netarm_mem_module.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm720t/netarm_mem_module.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,184 @@
+/*
+ * include/asm-armnommu/arch-netarm/netarm_mem_module.h
+ *
+ * Copyright (C) 2005
+ * Art Shipkowski, Videon Central, Inc., <art@videon-central.com>
+ *
+ * Copyright (C) 2000, 2001 NETsilicon, Inc.
+ * Copyright (C) 2000, 2001 Red Hat, Inc.
+ *
+ * This software is copyrighted by Red Hat. LICENSEE agrees that
+ * it will not delete this copyright notice, trademarks or protective
+ * notices from any copy made by LICENSEE.
+ *
+ * This software is provided "AS-IS" and any express or implied
+ * warranties or conditions, including but not limited to any
+ * implied warranties of merchantability and fitness for a particular
+ * purpose regarding this software. In no event shall Red Hat
+ * be liable for any indirect, consequential, or incidental damages,
+ * loss of profits or revenue, loss of use or data, or interruption
+ * of business, whether the alleged damages are labeled in contract,
+ * tort, or indemnity.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * author(s) : Joe deBlaquiere
+ *
+ * Modified to support NS7520 by Art Shipkowski.
+ */
+
+#ifndef __NETARM_MEM_MODULE_REGISTERS_H
+#define __NETARM_MEM_MODULE_REGISTERS_H
+
+/* GEN unit register offsets */
+
+#define	NETARM_MEM_MODULE_BASE		(0xFFC00000)
+
+#define	NETARM_MEM_MODULE_CONFIG	(0x00)
+#define	NETARM_MEM_CS0_BASE_ADDR	(0x10)
+#define	NETARM_MEM_CS0_OPTIONS		(0x14)
+#define	NETARM_MEM_CS1_BASE_ADDR	(0x20)
+#define	NETARM_MEM_CS1_OPTIONS		(0x24)
+#define	NETARM_MEM_CS2_BASE_ADDR	(0x30)
+#define	NETARM_MEM_CS2_OPTIONS		(0x34)
+#define	NETARM_MEM_CS3_BASE_ADDR	(0x40)
+#define	NETARM_MEM_CS3_OPTIONS		(0x44)
+#define	NETARM_MEM_CS4_BASE_ADDR	(0x50)
+#define	NETARM_MEM_CS4_OPTIONS		(0x54)
+
+/* select bitfield defintions */
+
+/* Module Configuration Register ( 0xFFC0_0000 ) */
+
+#define NETARM_MEM_CFG_REFR_COUNT_MASK	(0xFF000000)
+#define NETARM_MEM_CFG_REFRESH_EN	(0x00800000)
+
+#define NETARM_MEM_CFG_REFR_CYCLE_8CLKS	(0x00000000)
+#define NETARM_MEM_CFG_REFR_CYCLE_6CLKS	(0x00200000)
+#define NETARM_MEM_CFG_REFR_CYCLE_5CLKS	(0x00400000)
+#define NETARM_MEM_CFG_REFR_CYCLE_4CLKS	(0x00600000)
+
+#define NETARM_MEM_CFG_PORTC_AMUX	(0x00100000)
+
+#define NETARM_MEM_CFG_A27_ADDR		(0x00080000)
+#define NETARM_MEM_CFG_A27_CS0OE	(0x00000000)
+
+#define NETARM_MEM_CFG_A26_ADDR		(0x00040000)
+#define NETARM_MEM_CFG_A26_CS0WE	(0x00000000)
+
+#define NETARM_MEM_CFG_A25_ADDR		(0x00020000)
+#define NETARM_MEM_CFG_A25_BLAST	(0x00000000)
+
+#define NETARM_MEM_CFG_PORTC_AMUX2	(0x00010000)
+
+
+/* range on this period is about 1 to 275 usec (with 18.432MHz clock)   */
+/* the expression will round down, so make sure to reverse it to verify */
+/* it is what you want. period = [( count + 1 ) * 20] / Fcrystal        */
+/* (note: Fxtal = Fcrystal/5, see HWRefGuide sections 8.2.5 and 11.3.2) */
+
+#define	NETARM_MEM_REFR_PERIOD_USEC(p)	(NETARM_MEM_CFG_REFR_COUNT_MASK & \
+					 (((((NETARM_XTAL_FREQ/(1000))*p)/(20000) \
+					    ) - (1) ) << (24)))
+
+#if 0
+/* range on this period is about 1 to 275 usec (with 18.432MHz clock) */
+/* the expression will round down, so make sure to reverse it toverify */
+/* it is what you want. period = [( count + 1 ) * 4] / Fxtal          */
+
+#define	NETARM_MEM_REFR_PERIOD_USEC(p)	(NETARM_MEM_CFG_REFR_COUNT_MASK & \
+					 (((((NETARM_XTAL_FREQ/(1000))*p)/(4000) \
+					    ) - (1) ) << (24)))
+#endif
+
+/* Base Address Registers (0xFFC0_00X0) */
+
+#define NETARM_MEM_BAR_BASE_MASK	(0xFFFFF000)
+
+/* macro to define base */
+
+#define NETARM_MEM_BAR_BASE(x)		((x) & NETARM_MEM_BAR_BASE_MASK)
+
+#define NETARM_MEM_BAR_DRAM_FP		(0x00000000)
+#define NETARM_MEM_BAR_DRAM_EDO		(0x00000100)
+#define NETARM_MEM_BAR_DRAM_SYNC	(0x00000200)
+
+#define NETARM_MEM_BAR_DRAM_MUX_INT	(0x00000000)
+#define NETARM_MEM_BAR_DRAM_MUX_EXT	(0x00000080)
+
+#define NETARM_MEM_BAR_DRAM_MUX_BAL	(0x00000000)
+#define NETARM_MEM_BAR_DRAM_MUX_UNBAL	(0x00000020)
+
+#define NETARM_MEM_BAR_1BCLK_IDLE	(0x00000010)
+
+#define NETARM_MEM_BAR_DRAM_SEL		(0x00000008)
+
+#define NETARM_MEM_BAR_BURST_EN		(0x00000004)
+
+#define NETARM_MEM_BAR_WRT_PROT		(0x00000002)
+
+#define NETARM_MEM_BAR_VALID		(0x00000001)
+
+/* Option Registers (0xFFC0_00X4) */
+
+/* macro to define which bits of the base are significant */
+
+#define NETARM_MEM_OPT_BASE_USE(x)	((x) & NETARM_MEM_BAR_BASE_MASK)
+
+#define NETARM_MEM_OPT_WAIT_MASK	(0x00000F00)
+
+#define	NETARM_MEM_OPT_WAIT_STATES(x)	(((x) << 8 ) & NETARM_MEM_OPT_WAIT_MASK )
+
+#define NETARM_MEM_OPT_BCYC_1		(0x00000000)
+#define NETARM_MEM_OPT_BCYC_2		(0x00000040)
+#define NETARM_MEM_OPT_BCYC_3		(0x00000080)
+#define NETARM_MEM_OPT_BCYC_4		(0x000000C0)
+
+#define NETARM_MEM_OPT_BSIZE_2		(0x00000000)
+#define NETARM_MEM_OPT_BSIZE_4		(0x00000010)
+#define NETARM_MEM_OPT_BSIZE_8		(0x00000020)
+#define NETARM_MEM_OPT_BSIZE_16		(0x00000030)
+
+#define NETARM_MEM_OPT_32BIT		(0x00000000)
+#define NETARM_MEM_OPT_16BIT		(0x00000004)
+#define NETARM_MEM_OPT_8BIT		(0x00000008)
+#define NETARM_MEM_OPT_32BIT_EXT_ACK	(0x0000000C)
+
+#define NETARM_MEM_OPT_BUS_SIZE_MASK	(0x0000000C)
+
+#define NETARM_MEM_OPT_READ_ASYNC	(0x00000000)
+#define NETARM_MEM_OPT_READ_SYNC	(0x00000002)
+
+#define NETARM_MEM_OPT_WRITE_ASYNC	(0x00000000)
+#define NETARM_MEM_OPT_WRITE_SYNC	(0x00000001)
+
+#ifdef CONFIG_NETARM_NS7520
+/* The NS7520 has a second options register for each chip select */
+#define	NETARM_MEM_CS0_OPTIONS_B  (0x18)
+#define	NETARM_MEM_CS1_OPTIONS_B  (0x28)
+#define	NETARM_MEM_CS2_OPTIONS_B  (0x38)
+#define	NETARM_MEM_CS3_OPTIONS_B  (0x48)
+#define	NETARM_MEM_CS4_OPTIONS_B  (0x58)
+
+/* Option B Registers (0xFFC0_00x8) */
+#define NETARM_MEM_OPTB_SYNC_1_STAGE	(0x00000001)
+#define NETARM_MEM_OPTB_SYNC_2_STAGE	(0x00000002)
+#define NETARM_MEM_OPTB_BCYC_PLUS0   	(0x00000000)
+#define NETARM_MEM_OPTB_BCYC_PLUS4   	(0x00000004)
+#define NETARM_MEM_OPTB_BCYC_PLUS8   	(0x00000008)
+#define NETARM_MEM_OPTB_BCYC_PLUS12  	(0x0000000C)
+
+#define NETARM_MEM_OPTB_WAIT_PLUS0   	(0x00000000)
+#define NETARM_MEM_OPTB_WAIT_PLUS16   	(0x00000010)
+#define NETARM_MEM_OPTB_WAIT_PLUS32   	(0x00000020)
+#define NETARM_MEM_OPTB_WAIT_PLUS48   	(0x00000030)
+#endif
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch-arm720t/netarm_registers.h u-boot-1.2.0-leopard/include/asm/arch-arm720t/netarm_registers.h
--- u-boot-1.2.0/include/asm/arch-arm720t/netarm_registers.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm720t/netarm_registers.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,96 @@
+/*
+ * linux/include/asm-arm/arch-netarm/netarm_registers.h
+ *
+ * Copyright (C) 2005
+ * Art Shipkowski, Videon Central, Inc., <art@videon-central.com>
+ *
+ * Copyright (C) 2000, 2001 NETsilicon, Inc.
+ * Copyright (C) 2000, 2001 WireSpeed Communications Corporation
+ *
+ * This software is copyrighted by WireSpeed. LICENSEE agrees that
+ * it will not delete this copyright notice, trademarks or protective
+ * notices from any copy made by LICENSEE.
+ *
+ * This software is provided "AS-IS" and any express or implied
+ * warranties or conditions, including but not limited to any
+ * implied warranties of merchantability and fitness for a particular
+ * purpose regarding this software. In no event shall WireSpeed
+ * be liable for any indirect, consequential, or incidental damages,
+ * loss of profits or revenue, loss of use or data, or interruption
+ * of business, whether the alleged damages are labeled in contract,
+ * tort, or indemnity.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * author(s) : Joe deBlaquiere
+ *
+ * Modified to support NS7520 by Art Shipkowski.
+ */
+
+#ifndef __NET_ARM_REGISTERS_H
+#define __NET_ARM_REGISTERS_H
+
+#include <config.h>
+
+/* fundamental constants : */
+/* the input crystal/clock frequency ( in Hz ) */
+#define	NETARM_XTAL_FREQ_25MHz		(18432000)
+#define	NETARM_XTAL_FREQ_33MHz		(23698000)
+#define	NETARM_XTAL_FREQ_48MHz		(48000000)
+#define	NETARM_XTAL_FREQ_55MHz		(55000000)
+#define NETARM_XTAL_FREQ_EMLIN1		(20000000)
+
+/* the frequency of SYS_CLK */
+#if defined(CONFIG_NETARM_EMLIN)
+
+/* EMLIN board:  33 MHz (exp.) */
+#define	NETARM_PLL_COUNT_VAL		6
+#define NETARM_XTAL_FREQ		NETARM_XTAL_FREQ_25MHz
+
+#elif defined(CONFIG_NETARM_NET40_REV2)
+
+/* NET+40 Rev2 boards:  33 MHz (with NETARM_XTAL_FREQ_25MHz) */
+#define	NETARM_PLL_COUNT_VAL		6
+#define	NETARM_XTAL_FREQ		NETARM_XTAL_FREQ_25MHz
+
+#elif defined(CONFIG_NETARM_NET40_REV4)
+
+/* NET+40 Rev4 boards with EDO must clock slower: 25 MHz (with
+   NETARM_XTAL_FREQ_25MHz) 4 */
+#define	NETARM_PLL_COUNT_VAL		4
+#define	NETARM_XTAL_FREQ		NETARM_XTAL_FREQ_25MHz
+
+#elif defined(CONFIG_NETARM_NET50)
+
+/* NET+50 boards:  40 MHz (with NETARM_XTAL_FREQ_25MHz) */
+#define NETARM_PLL_COUNT_VAL		8
+#define	NETARM_XTAL_FREQ		NETARM_XTAL_FREQ_25MHz
+
+#else	/* CONFIG_NETARM_NS7520 */
+
+#define	NETARM_PLL_COUNT_VAL		0
+
+#if defined(CONFIG_BOARD_UNC20)
+#define	NETARM_XTAL_FREQ		NETARM_XTAL_FREQ_48MHz
+#else
+#define	NETARM_XTAL_FREQ		NETARM_XTAL_FREQ_55MHz
+#endif
+
+#endif
+
+/* #include "arm_registers.h" */
+#include <asm/arch/netarm_gen_module.h>
+#include <asm/arch/netarm_mem_module.h>
+#include <asm/arch/netarm_ser_module.h>
+#include <asm/arch/netarm_eni_module.h>
+#include <asm/arch/netarm_dma_module.h>
+#include <asm/arch/netarm_eth_module.h>
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch-arm720t/netarm_ser_module.h u-boot-1.2.0-leopard/include/asm/arch-arm720t/netarm_ser_module.h
--- u-boot-1.2.0/include/asm/arch-arm720t/netarm_ser_module.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm720t/netarm_ser_module.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,347 @@
+/*
+ * linux/include/asm-arm/arch-netarm/netarm_ser_module.h
+ *
+ * Copyright (C) 2000 NETsilicon, Inc.
+ * Copyright (C) 2000 Red Hat, Inc.
+ *
+ * This software is copyrighted by Red Hat. LICENSEE agrees that
+ * it will not delete this copyright notice, trademarks or protective
+ * notices from any copy made by LICENSEE.
+ *
+ * This software is provided "AS-IS" and any express or implied
+ * warranties or conditions, including but not limited to any
+ * implied warranties of merchantability and fitness for a particular
+ * purpose regarding this software. In no event shall Red Hat
+ * be liable for any indirect, consequential, or incidental damages,
+ * loss of profits or revenue, loss of use or data, or interruption
+ * of business, whether the alleged damages are labeled in contract,
+ * tort, or indemnity.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * author(s) : Joe deBlaquiere
+ *             Clark Williams
+ */
+
+#ifndef __NETARM_SER_MODULE_REGISTERS_H
+#define __NETARM_SER_MODULE_REGISTERS_H
+
+#ifndef	__ASSEMBLER__
+
+/* (--sub)#include "types.h" */
+
+/* serial channel control structure */
+typedef struct {
+  u32	ctrl_a;
+  u32	ctrl_b;
+  u32	status_a;
+  u32	bitrate;
+  u32	fifo;
+  u32	rx_buf_timer;
+  u32	rx_char_timer;
+  u32	rx_match;
+  u32	rx_match_mask;
+  u32	ctrl_c;
+  u32	status_b;
+  u32	status_c;
+  u32	fifo_last;
+  u32	unused[3];
+} netarm_serial_channel_t;
+
+#endif
+
+/* SER unit register offsets */
+
+/* #ifdef CONFIG_ARCH_NETARM */
+#define	NETARM_SER_MODULE_BASE		(0xFFD00000)
+/* #else */
+/* extern serial_channel_t netarm_dummy_registers[]; */
+/* #define NETARM_SER_MODULE_BASE		(netarm_dummy_registers) */
+/* #ifndef NETARM_XTAL_FREQ */
+/* #define NETARM_XTAL_FREQ                18432000 */
+/* #endif */
+/* #endif */
+
+/* calculate the sysclk value from the pll setting */
+#define	NETARM_PLLED_SYSCLK_FREQ	(( NETARM_XTAL_FREQ / 5 ) * \
+					 ( NETARM_PLL_COUNT_VAL + 3 ))
+
+#define get_serial_channel(c) (&(((netarm_serial_channel_t *)NETARM_SER_MODULE_BASE)[c]))
+
+#define	NETARM_SER_CH1_CTRL_A		(0x00)
+#define	NETARM_SER_CH1_CTRL_B		(0x04)
+#define	NETARM_SER_CH1_STATUS_A		(0x08)
+#define	NETARM_SER_CH1_BITRATE		(0x0C)
+#define	NETARM_SER_CH1_FIFO		(0x10)
+#define	NETARM_SER_CH1_RX_BUF_TMR	(0x14)
+#define	NETARM_SER_CH1_RX_CHAR_TMR	(0x18)
+#define	NETARM_SER_CH1_RX_MATCH		(0x1c)
+#define	NETARM_SER_CH1_RX_MATCH_MASK	(0x20)
+#define	NETARM_SER_CH1_CTRL_C		(0x24)
+#define	NETARM_SER_CH1_STATUS_B		(0x28)
+#define	NETARM_SER_CH1_STATUS_C		(0x2c)
+#define	NETARM_SER_CH1_FIFO_LAST	(0x30)
+
+#define	NETARM_SER_CH2_CTRL_A		(0x40)
+#define	NETARM_SER_CH2_CTRL_B		(0x44)
+#define	NETARM_SER_CH2_STATUS_A		(0x48)
+#define	NETARM_SER_CH2_BITRATE		(0x4C)
+#define	NETARM_SER_CH2_FIFO		(0x50)
+#define	NETARM_SER_CH2_RX_BUF_TMR	(0x54)
+#define	NETARM_SER_CH2_RX_CHAR_TMR	(0x58)
+#define	NETARM_SER_CH2_RX_MATCH		(0x5c)
+#define	NETARM_SER_CH2_RX_MATCH_MASK	(0x60)
+#define	NETARM_SER_CH2_CTRL_C		(0x64)
+#define	NETARM_SER_CH2_STATUS_B		(0x68)
+#define	NETARM_SER_CH2_STATUS_C		(0x6c)
+#define	NETARM_SER_CH2_FIFO_LAST	(0x70)
+
+/* select bitfield defintions */
+
+/* Control Register A */
+
+#define	NETARM_SER_CTLA_ENABLE		(0x80000000)
+#define	NETARM_SER_CTLA_BRK		(0x40000000)
+
+#define	NETARM_SER_CTLA_STICKP		(0x20000000)
+
+#define	NETARM_SER_CTLA_P_EVEN		(0x18000000)
+#define	NETARM_SER_CTLA_P_ODD		(0x08000000)
+#define	NETARM_SER_CTLA_P_NONE		(0x00000000)
+
+/* if you read the errata, you will find that the STOP bits don't work right */
+#define	NETARM_SER_CTLA_2STOP		(0x00000000)
+#define	NETARM_SER_CTLA_3STOP		(0x04000000)
+
+#define	NETARM_SER_CTLA_5BITS		(0x00000000)
+#define	NETARM_SER_CTLA_6BITS		(0x01000000)
+#define	NETARM_SER_CTLA_7BITS		(0x02000000)
+#define	NETARM_SER_CTLA_8BITS		(0x03000000)
+
+#define	NETARM_SER_CTLA_CTSTX		(0x00800000)
+#define	NETARM_SER_CTLA_RTSRX		(0x00400000)
+
+#define	NETARM_SER_CTLA_LOOP_REM	(0x00200000)
+#define	NETARM_SER_CTLA_LOOP_LOC	(0x00100000)
+
+#define	NETARM_SER_CTLA_GPIO2		(0x00080000)
+#define	NETARM_SER_CTLA_GPIO1		(0x00040000)
+
+#define	NETARM_SER_CTLA_DTR_EN		(0x00020000)
+#define	NETARM_SER_CTLA_RTS_EN		(0x00010000)
+
+#define	NETARM_SER_CTLA_IE_RX_BRK	(0x00008000)
+#define	NETARM_SER_CTLA_IE_RX_FRMERR	(0x00004000)
+#define	NETARM_SER_CTLA_IE_RX_PARERR	(0x00002000)
+#define	NETARM_SER_CTLA_IE_RX_OVERRUN	(0x00001000)
+#define	NETARM_SER_CTLA_IE_RX_RDY	(0x00000800)
+#define	NETARM_SER_CTLA_IE_RX_HALF	(0x00000400)
+#define	NETARM_SER_CTLA_IE_RX_FULL	(0x00000200)
+#define	NETARM_SER_CTLA_IE_RX_DMAEN	(0x00000100)
+#define	NETARM_SER_CTLA_IE_RX_DCD	(0x00000080)
+#define	NETARM_SER_CTLA_IE_RX_RI	(0x00000040)
+#define	NETARM_SER_CTLA_IE_RX_DSR	(0x00000020)
+
+#define NETARM_SER_CTLA_IE_RX_ALL	(NETARM_SER_CTLA_IE_RX_BRK \
+					|NETARM_SER_CTLA_IE_RX_FRMERR \
+					|NETARM_SER_CTLA_IE_RX_PARERR \
+					|NETARM_SER_CTLA_IE_RX_OVERRUN \
+					|NETARM_SER_CTLA_IE_RX_RDY \
+					|NETARM_SER_CTLA_IE_RX_HALF \
+					|NETARM_SER_CTLA_IE_RX_FULL \
+					|NETARM_SER_CTLA_IE_RX_DMAEN \
+					|NETARM_SER_CTLA_IE_RX_DCD \
+					|NETARM_SER_CTLA_IE_RX_RI \
+					|NETARM_SER_CTLA_IE_RX_DSR)
+
+#define	NETARM_SER_CTLA_IE_TX_CTS	(0x00000010)
+#define	NETARM_SER_CTLA_IE_TX_EMPTY	(0x00000008)
+#define	NETARM_SER_CTLA_IE_TX_HALF	(0x00000004)
+#define	NETARM_SER_CTLA_IE_TX_FULL	(0x00000002)
+#define	NETARM_SER_CTLA_IE_TX_DMAEN	(0x00000001)
+
+#define NETARM_SER_CTLA_IE_TX_ALL	(NETARM_SER_CTLA_IE_TX_CTS \
+					|NETARM_SER_CTLA_IE_TX_EMPTY \
+					|NETARM_SER_CTLA_IE_TX_HALF \
+					|NETARM_SER_CTLA_IE_TX_FULL \
+					|NETARM_SER_CTLA_IE_TX_DMAEN)
+
+/* Control Register B */
+
+#define	NETARM_SER_CTLB_MATCH1_EN	(0x80000000)
+#define	NETARM_SER_CTLB_MATCH2_EN	(0x40000000)
+#define	NETARM_SER_CTLB_MATCH3_EN	(0x20000000)
+#define	NETARM_SER_CTLB_MATCH4_EN	(0x10000000)
+
+#define	NETARM_SER_CTLB_RBGT_EN		(0x08000000)
+#define	NETARM_SER_CTLB_RCGT_EN		(0x04000000)
+
+#define	NETARM_SER_CTLB_UART_MODE	(0x00000000)
+#define	NETARM_SER_CTLB_HDLC_MODE	(0x00100000)
+#define	NETARM_SER_CTLB_SPI_MAS_MODE	(0x00200000)
+#define	NETARM_SER_CTLB_SPI_SLV_MODE	(0x00300000)
+
+#define	NETARM_SER_CTLB_REV_BIT_ORDER	(0x00080000)
+
+#define	NETARM_SER_CTLB_MAM1		(0x00040000)
+#define	NETARM_SER_CTLB_MAM2		(0x00020000)
+
+/* Status Register A */
+
+#define	NETARM_SER_STATA_MATCH1		(0x80000000)
+#define	NETARM_SER_STATA_MATCH2		(0x40000000)
+#define	NETARM_SER_STATA_MATCH3		(0x20000000)
+#define	NETARM_SER_STATA_MATCH4		(0x10000000)
+
+#define	NETARM_SER_STATA_BGAP		(0x80000000)
+#define	NETARM_SER_STATA_CGAP		(0x40000000)
+
+#define	NETARM_SER_STATA_RX_1B		(0x00100000)
+#define	NETARM_SER_STATA_RX_2B		(0x00200000)
+#define	NETARM_SER_STATA_RX_3B		(0x00300000)
+#define	NETARM_SER_STATA_RX_4B		(0x00000000)
+
+/* downshifted values */
+
+#define	NETARM_SER_STATA_RXFDB_1BYTES	(0x001)
+#define	NETARM_SER_STATA_RXFDB_2BYTES	(0x002)
+#define	NETARM_SER_STATA_RXFDB_3BYTES	(0x003)
+#define	NETARM_SER_STATA_RXFDB_4BYTES	(0x000)
+
+#define	NETARM_SER_STATA_RXFDB_MASK	(0x00300000)
+#define	NETARM_SER_STATA_RXFDB(x)	(((x) & NETARM_SER_STATA_RXFDB_MASK) \
+					 >> 20)
+
+#define	NETARM_SER_STATA_DCD		(0x00080000)
+#define	NETARM_SER_STATA_RI		(0x00040000)
+#define	NETARM_SER_STATA_DSR		(0x00020000)
+#define	NETARM_SER_STATA_CTS		(0x00010000)
+
+#define	NETARM_SER_STATA_RX_BRK		(0x00008000)
+#define	NETARM_SER_STATA_RX_FRMERR	(0x00004000)
+#define	NETARM_SER_STATA_RX_PARERR	(0x00002000)
+#define	NETARM_SER_STATA_RX_OVERRUN	(0x00001000)
+#define	NETARM_SER_STATA_RX_RDY		(0x00000800)
+#define	NETARM_SER_STATA_RX_HALF	(0x00000400)
+#define	NETARM_SER_STATA_RX_CLOSED	(0x00000200)
+#define	NETARM_SER_STATA_RX_FULL	(0x00000100)
+#define	NETARM_SER_STATA_RX_DCD		(0x00000080)
+#define	NETARM_SER_STATA_RX_RI		(0x00000040)
+#define	NETARM_SER_STATA_RX_DSR		(0x00000020)
+
+#define	NETARM_SER_STATA_TX_CTS		(0x00000010)
+#define	NETARM_SER_STATA_TX_RDY		(0x00000008)
+#define	NETARM_SER_STATA_TX_HALF	(0x00000004)
+#define	NETARM_SER_STATA_TX_FULL	(0x00000002)
+#define	NETARM_SER_STATA_TX_DMAEN	(0x00000001)
+
+/* you have to clear all receive signals to get the fifo to move forward */
+#define NETARM_SER_STATA_CLR_ALL	(NETARM_SER_STATA_RX_BRK | \
+					 NETARM_SER_STATA_RX_FRMERR | \
+					 NETARM_SER_STATA_RX_PARERR | \
+					 NETARM_SER_STATA_RX_OVERRUN | \
+					 NETARM_SER_STATA_RX_HALF | \
+					 NETARM_SER_STATA_RX_CLOSED | \
+					 NETARM_SER_STATA_RX_FULL | \
+					 NETARM_SER_STATA_RX_DCD | \
+					 NETARM_SER_STATA_RX_RI | \
+					 NETARM_SER_STATA_RX_DSR | \
+					 NETARM_SER_STATA_TX_CTS )
+
+/* Bit Rate Registers */
+
+#define	NETARM_SER_BR_EN		(0x80000000)
+#define	NETARM_SER_BR_TMODE		(0x40000000)
+
+#define	NETARM_SER_BR_RX_CLK_INT	(0x00000000)
+#define	NETARM_SER_BR_RX_CLK_EXT	(0x20000000)
+#define	NETARM_SER_BR_TX_CLK_INT	(0x00000000)
+#define	NETARM_SER_BR_TX_CLK_EXT	(0x10000000)
+
+#define	NETARM_SER_BR_RX_CLK_DRV	(0x08000000)
+#define	NETARM_SER_BR_TX_CLK_DRV	(0x04000000)
+
+#define	NETARM_SER_BR_CLK_EXT_5		(0x00000000)
+#define	NETARM_SER_BR_CLK_SYSTEM	(0x01000000)
+#define	NETARM_SER_BR_CLK_OUT1A		(0x02000000)
+#define	NETARM_SER_BR_CLK_OUT2A		(0x03000000)
+
+#define	NETARM_SER_BR_TX_CLK_INV	(0x00800000)
+#define	NETARM_SER_BR_RX_CLK_INV	(0x00400000)
+
+/* complete settings assuming system clock input is 18MHz */
+
+#define	NETARM_SER_BR_MASK		(0x000007FF)
+
+/* bit rate determined from equation Fbr = Fxtal / [ 10 * ( N + 1 ) ] */
+/* from section 7.5.4 of HW Ref Guide */
+
+/* #ifdef CONFIG_NETARM_PLL_BYPASS */
+#define	NETARM_SER_BR_X16(x)	( NETARM_SER_BR_EN | 			\
+				  NETARM_SER_BR_RX_CLK_INT | 		\
+				  NETARM_SER_BR_TX_CLK_INT | 		\
+				  NETARM_SER_BR_CLK_EXT_5 | 		\
+				  ( ( ( ( NETARM_XTAL_FREQ / 		\
+				          ( x * 10 ) ) - 1 ) /	16 ) & 	\
+				    NETARM_SER_BR_MASK ) )
+/*
+#else
+#define	NETARM_SER_BR_X16(x)	( NETARM_SER_BR_EN | 			\
+				  NETARM_SER_BR_RX_CLK_INT | 		\
+				  NETARM_SER_BR_TX_CLK_INT | 		\
+				  NETARM_SER_BR_CLK_SYSTEM | 		\
+				  ( ( ( ( NETARM_PLLED_SYSCLK_FREQ / 		\
+				          ( x * 2 ) ) - 1 ) /	16 ) & 	\
+				    NETARM_SER_BR_MASK ) )
+#endif
+*/
+
+/* Receive Buffer Gap Timer */
+
+#define	NETARM_SER_RX_GAP_TIMER_EN	(0x80000000)
+#define	NETARM_SER_RX_GAP_MASK		(0x00003FFF)
+
+/* rx gap is a function of bit rate x */
+
+/* #ifdef CONFIG_NETARM_PLL_BYPASS */
+#define	NETARM_SER_RXGAP(x)	( NETARM_SER_RX_GAP_TIMER_EN |		\
+				  ( ( ( ( 10 * NETARM_XTAL_FREQ ) /	\
+				        ( x * 5 * 512 ) ) - 1 ) & 	\
+			              NETARM_SER_RX_GAP_MASK ) )
+/*
+#else
+#define	NETARM_SER_RXGAP(x)	( NETARM_SER_RX_GAP_TIMER_EN |			\
+				  ( ( ( ( 2 * NETARM_PLLED_SYSCLK_FREQ ) /	\
+				        ( x * 512 ) ) - 1 ) & 			\
+			              NETARM_SER_RX_GAP_MASK ) )
+#endif
+*/
+
+#if 0
+#define	NETARM_SER_RXGAP(x)	( NETARM_SER_RX_GAP_TIMER_EN |		\
+				  ( ( ( ( 2 * NETARM_PLLED_SYSCLK_FREQ ) /	\
+				        ( x * 5 * 512 ) ) - 1 ) & 	\
+			              NETARM_SER_RX_GAP_MASK ) )
+#define	NETARM_SER_RXGAP(x)	( NETARM_SER_RX_GAP_TIMER_EN |		\
+				  ( ( ( ( 10 * NETARM_XTAL_FREQ ) /	\
+				        ( x * 512 ) ) - 1 ) & 	\
+			              NETARM_SER_RX_GAP_MASK ) )
+#endif
+
+#define MIN_BAUD_RATE        600
+#define MAX_BAUD_RATE     115200
+
+/* the default BAUD rate for the BOOTLOADER, there is a separate */
+/* setting in the serial driver <arch/armnommu/drivers/char/serial-netarm.h> */
+#define DEFAULT_BAUD_RATE 9600
+#define NETARM_SER_FIFO_SIZE 32
+#define MIN_GAP 0
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch-arm720t/s3c4510b.h u-boot-1.2.0-leopard/include/asm/arch-arm720t/s3c4510b.h
--- u-boot-1.2.0/include/asm/arch-arm720t/s3c4510b.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm720t/s3c4510b.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,272 @@
+#ifndef __HW_S3C4510_H
+#define __HW_S3C4510_H
+
+/*
+ * Copyright (c) 2004	Cucy Systems (http://www.cucy.com)
+ * Curt Brune <curt@cucy.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Description:   Samsung S3C4510B register layout
+ */
+
+/*------------------------------------------------------------------------
+ *	  ASIC Address Definition
+ *----------------------------------------------------------------------*/
+
+/* L1 8KB on chip SRAM base address */
+#define SRAM_BASE       (0x03fe0000)
+
+/* Special Register Start Address After System Reset */
+#define REG_BASE	(0x03ff0000)
+#define SPSTR      	(REG_BASE)
+
+/* *********************** */
+/* System Manager Register */
+/* *********************** */
+#define REG_SYSCFG	(REG_BASE+0x0000)
+
+#define REG_CLKCON      (REG_BASE+0x3000)
+#define REG_EXTACON0	(REG_BASE+0x3008)
+#define REG_EXTACON1	(REG_BASE+0x300c)
+#define REG_EXTDBWTH	(REG_BASE+0x3010)
+#define REG_ROMCON0	(REG_BASE+0x3014)
+#define REG_ROMCON1	(REG_BASE+0x3018)
+#define REG_ROMCON2	(REG_BASE+0x301c)
+#define REG_ROMCON3	(REG_BASE+0x3020)
+#define REG_ROMCON4	(REG_BASE+0x3024)
+#define REG_ROMCON5	(REG_BASE+0x3028)
+#define REG_DRAMCON0	(REG_BASE+0x302c)
+#define REG_DRAMCON1	(REG_BASE+0x3030)
+#define REG_DRAMCON2	(REG_BASE+0x3034)
+#define REG_DRAMCON3	(REG_BASE+0x3038)
+#define REG_REFEXTCON	(REG_BASE+0x303c)
+
+/* *********************** */
+/* Ethernet BDMA Register  */
+/* *********************** */
+#define REG_BDMATXCON	(REG_BASE+0x9000)
+#define REG_BDMARXCON	(REG_BASE+0x9004)
+#define REG_BDMATXPTR	(REG_BASE+0x9008)
+#define REG_BDMARXPTR	(REG_BASE+0x900c)
+#define REG_BDMARXLSZ	(REG_BASE+0x9010)
+#define REG_BDMASTAT	(REG_BASE+0x9014)
+
+/* Content Address Memory */
+#define REG_CAM_BASE	(REG_BASE+0x9100)
+
+#define REG_BDMATXBUF	(REG_BASE+0x9200)
+#define REG_BDMARXBUF	(REG_BASE+0x9800)
+
+/* *********************** */
+/* Ethernet MAC Register   */
+/* *********************** */
+#define REG_MACCON	(REG_BASE+0xa000)
+#define REG_CAMCON	(REG_BASE+0xa004)
+#define REG_MACTXCON	(REG_BASE+0xa008)
+#define REG_MACTXSTAT	(REG_BASE+0xa00c)
+#define REG_MACRXCON	(REG_BASE+0xa010)
+#define REG_MACRXSTAT	(REG_BASE+0xa014)
+#define REG_STADATA	(REG_BASE+0xa018)
+#define REG_STACON	(REG_BASE+0xa01c)
+#define REG_CAMEN	(REG_BASE+0xa028)
+#define REG_EMISSCNT	(REG_BASE+0xa03c)
+#define REG_EPZCNT	(REG_BASE+0xa040)
+#define REG_ERMPZCNT	(REG_BASE+0xa044)
+#define REG_ETXSTAT	(REG_BASE+0x9040)
+#define REG_MACRXDESTR	(REG_BASE+0xa064)
+#define REG_MACRXSTATEM	(REG_BASE+0xa090)
+#define REG_MACRXFIFO	(REG_BASE+0xa200)
+
+/********************/
+/* I2C Bus Register */
+/********************/
+#define REG_I2C_CON	(REG_BASE+0xf000)
+#define REG_I2C_BUF	(REG_BASE+0xf004)
+#define REG_I2C_PS	(REG_BASE+0xf008)
+#define REG_I2C_COUNT 	(REG_BASE+0xf00c)
+
+/********************/
+/*    GDMA 0        */
+/********************/
+#define REG_GDMACON0	(REG_BASE+0xb000)
+#define REG_GDMA0_RUN_ENABLE (REG_BASE+0xb020)
+#define REG_GDMASRC0	(REG_BASE+0xb004)
+#define REG_GDMADST0	(REG_BASE+0xb008)
+#define REG_GDMACNT0	(REG_BASE+0xb00c)
+
+/********************/
+/*    GDMA 1        */
+/********************/
+#define REG_GDMACON1	(REG_BASE+0xc000)
+#define REG_GDMA1_RUN_ENABLE (REG_BASE+0xc020)
+#define REG_GDMASRC1	(REG_BASE+0xc004)
+#define REG_GDMADST1	(REG_BASE+0xc008)
+#define REG_GDMACNT1	(REG_BASE+0xc00c)
+
+/********************/
+/*      UART 0      */
+/********************/
+#define UART0_BASE       (REG_BASE+0xd000)
+#define REG_UART0_LCON   (REG_BASE+0xd000)
+#define REG_UART0_CTRL   (REG_BASE+0xd004)
+#define REG_UART0_STAT   (REG_BASE+0xd008)
+#define REG_UART0_TXB    (REG_BASE+0xd00c)
+#define REG_UART0_RXB    (REG_BASE+0xd010)
+#define REG_UART0_BAUD_DIV    (REG_BASE+0xd014)
+#define REG_UART0_BAUD_CNT    (REG_BASE+0xd018)
+#define REG_UART0_BAUD_CLK    (REG_BASE+0xd01C)
+
+/********************/
+/*     UART 1       */
+/********************/
+#define UART1_BASE       (REG_BASE+0xe000)
+#define REG_UART1_LCON   (REG_BASE+0xe000)
+#define REG_UART1_CTRL   (REG_BASE+0xe004)
+#define REG_UART1_STAT   (REG_BASE+0xe008)
+#define REG_UART1_TXB    (REG_BASE+0xe00c)
+#define REG_UART1_RXB    (REG_BASE+0xe010)
+#define REG_UART1_BAUD_DIV    (REG_BASE+0xe014)
+#define REG_UART1_BAUD_CNT    (REG_BASE+0xe018)
+#define REG_UART1_BAUD_CLK    (REG_BASE+0xe01C)
+
+/********************/
+/*  Timer Register  */
+/********************/
+#define REG_TMOD  	(REG_BASE+0x6000)
+#define REG_TDATA0	(REG_BASE+0x6004)
+#define REG_TDATA1	(REG_BASE+0x6008)
+#define REG_TCNT0	(REG_BASE+0x600c)
+#define REG_TCNT1	(REG_BASE+0x6010)
+
+/**********************/
+/* I/O Port Interface */
+/**********************/
+#define REG_IOPMODE	(REG_BASE+0x5000)
+#define REG_IOPCON  	(REG_BASE+0x5004)
+#define REG_IOPDATA 	(REG_BASE+0x5008)
+
+/*********************************/
+/* Interrupt Controller Register */
+/*********************************/
+#define REG_INTMODE     (REG_BASE+0x4000)
+#define REG_INTPEND     (REG_BASE+0x4004)
+#define REG_INTMASK     (REG_BASE+0x4008)
+
+#define REG_INTPRI0     (REG_BASE+0x400c)
+#define REG_INTPRI1	(REG_BASE+0x4010)
+#define REG_INTPRI2	(REG_BASE+0x4014)
+#define REG_INTPRI3	(REG_BASE+0x4018)
+#define REG_INTPRI4	(REG_BASE+0x401c)
+#define REG_INTPRI5	(REG_BASE+0x4020)
+#define REG_INTOFFSET	(REG_BASE+0x4024)
+#define REG_INTPNDPRI	(REG_BASE+0x4028)
+#define REG_INTPNDTST	(REG_BASE+0x402C)
+
+/*********************************/
+/* CACHE CONTROL MASKS           */
+/*********************************/
+#define CACHE_STALL      (0x00000001)
+#define CACHE_ENABLE     (0x00000002)
+#define CACHE_WRITE_BUFF (0x00000004)
+#define CACHE_MODE       (0x00000030)
+#define CACHE_MODE_00    (0x00000000)
+#define CACHE_MODE_01    (0x00000010)
+#define CACHE_MODE_10    (0x00000020)
+
+/*********************************/
+/* CACHE RAM BASE ADDRESSES      */
+/*********************************/
+#define CACHE_SET0_RAM   (0x10000000)
+#define CACHE_SET1_RAM   (0x10800000)
+#define CACHE_TAG_RAM    (0x11000000)
+
+/*********************************/
+/* CACHE_DISABLE MASK            */
+/*********************************/
+#define CACHE_DISABLE_MASK (0x04000000)
+
+#define GET_REG(reg)       (*((volatile u32 *)(reg)))
+#define PUT_REG(reg, val)  (*((volatile u32 *)(reg)) = ((u32)(val)))
+#define SET_REG(reg, mask) (PUT_REG((reg), GET_REG((reg)) |  mask))
+#define CLR_REG(reg, mask) (PUT_REG((reg), GET_REG((reg)) & ~mask))
+#define PUT_U16(reg, val)  (*((volatile u16 *)(reg)) = ((u16)(val)))
+#define PUT__U8(reg, val)  (*((volatile u8  *)(reg)) = (( u8)((val)&0xFF)))
+#define GET__U8(reg)       (*((volatile u8  *)(reg)))
+
+#define PUT_LED(val)       (PUT_REG(REG_IOPDATA, (~val)&0xFF))
+#define GET_LED()          ((~GET_REG( REG_IOPDATA)) & 0xFF)
+#define SET_LED(val)       { u32 led = GET_LED(); led |= 1 << (val);  PUT_LED( led); }
+#define CLR_LED(val)       { u32 led = GET_LED(); led &= ~(1 << (val));  PUT_LED( led); }
+
+/***********************************/
+/* CLOCK CONSTANTS -- 50 MHz Clock */
+/***********************************/
+
+#define CLK_FREQ_MHZ       (50)
+#define t_data_us(t)       ((t)*CLK_FREQ_MHZ-1)   /* t is time tick,unit[us] */
+#define t_data_ms(t)       (t_data_us((t)*1000))  /* t is time tick,unit[ms] */
+
+/*********************************************************/
+/*	       TIMER MODE REGISTER                       */
+/*********************************************************/
+#define  TM0_RUN      0x01  /* Timer 0 enable */
+#define  TM0_TOGGLE   0x02  /* 0, interval mode */
+#define  TM0_OUT_1    0x04  /* Timer 0 Initial TOUT0 value */
+#define  TM1_RUN      0x08  /* Timer 1 enable */
+#define  TM1_TOGGLE   0x10  /* 0, interval mode */
+#define  TM1_OUT_1    0x20  /* Timer 0 Initial TOUT0 value */
+
+
+/*********************************/
+/* INTERRUPT SOURCES             */
+/*********************************/
+#define INT_EXTINT0	0
+#define INT_EXTINT1	1
+#define INT_EXTINT2	2
+#define INT_EXTINT3	3
+#define INT_UARTTX0	4
+#define INT_UARTRX0	5
+#define INT_UARTTX1	6
+#define INT_UARTRX1	7
+#define INT_GDMA0	8
+#define INT_GDMA1	9
+#define INT_TIMER0	10
+#define INT_TIMER1	11
+#define INT_HDLCTXA	12
+#define INT_HDLCRXA	13
+#define INT_HDLCTXB	14
+#define INT_HDLCRXB	15
+#define INT_BDMATX	16
+#define INT_BDMARX	17
+#define INT_MACTX	18
+#define INT_MACRX	19
+#define INT_IIC		20
+#define INT_GLOBAL	21
+#define N_IRQS         (21)
+
+#ifndef __ASSEMBLER__
+struct _irq_handler {
+	void                *m_data;
+	void (*m_func)( void *data);
+};
+
+#endif
+
+#endif /* __S3C4510_h */
diff -Nurd u-boot-1.2.0/include/asm/arch-arm925t/sizes.h u-boot-1.2.0-leopard/include/asm/arch-arm925t/sizes.h
--- u-boot-1.2.0/include/asm/arch-arm925t/sizes.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm925t/sizes.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,50 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *		   from .s file by awk -f s2h.awk
+ */
+/*  Size defintions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h			1
+
+/* handy sizes */
+#define SZ_1K				0x00000400
+#define SZ_4K				0x00001000
+#define SZ_8K				0x00002000
+#define SZ_16K				0x00004000
+#define SZ_64K				0x00010000
+#define SZ_128K				0x00020000
+#define SZ_256K				0x00040000
+#define SZ_512K				0x00080000
+
+#define SZ_1M				0x00100000
+#define SZ_2M				0x00200000
+#define SZ_4M				0x00400000
+#define SZ_8M				0x00800000
+#define SZ_16M				0x01000000
+#define SZ_32M				0x02000000
+#define SZ_64M				0x04000000
+#define SZ_128M				0x08000000
+#define SZ_256M				0x10000000
+#define SZ_512M				0x20000000
+
+#define SZ_1G				0x40000000
+#define SZ_2G				0x80000000
+
+#endif	/* __sizes_h */
diff -Nurd u-boot-1.2.0/include/asm/arch-arm926ejs/emif_defs.h u-boot-1.2.0-leopard/include/asm/arch-arm926ejs/emif_defs.h
--- u-boot-1.2.0/include/asm/arch-arm926ejs/emif_defs.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm926ejs/emif_defs.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) Sergey Kubushyn <ksi@koi8.net>, 2007.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _EMIF_DEFS_H_
+#define _EMIF_DEFS_H_
+
+typedef struct {
+	dv_reg		ERCSR;
+	dv_reg		AWCCR;
+	dv_reg		SDBCR;
+	dv_reg		SDRCR;
+	dv_reg		AB1CR;
+	dv_reg		AB2CR;
+	dv_reg		AB3CR;
+	dv_reg		AB4CR;
+	dv_reg		SDTIMR;
+	dv_reg		DDRSR;
+	dv_reg		DDRPHYCR;
+	dv_reg		DDRPHYSR;
+	dv_reg		TOTAR;
+	dv_reg		TOTACTR;
+	dv_reg		DDRPHYID_REV;
+	dv_reg		SDSRETR;
+	dv_reg		EIRR;
+	dv_reg		EIMR;
+	dv_reg		EIMSR;
+	dv_reg		EIMCR;
+	dv_reg		IOCTRLR;
+	dv_reg		IOSTATR;
+	u_int8_t	RSVD0[8];
+	dv_reg		NANDFCR;
+	dv_reg		NANDFSR;
+	u_int8_t	RSVD1[8];
+	dv_reg		NANDF1ECC;
+	dv_reg		NANDF2ECC;
+	dv_reg		NANDF3ECC;
+	dv_reg		NANDF4ECC;
+} emif_registers;
+
+typedef emif_registers	*emifregs;
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch-arm926ejs/nand_defs.h u-boot-1.2.0-leopard/include/asm/arch-arm926ejs/nand_defs.h
--- u-boot-1.2.0/include/asm/arch-arm926ejs/nand_defs.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm926ejs/nand_defs.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) Sergey Kubushyn <ksi@koi8.net>, 2007.
+ *
+ * Parts shamelesly stolen from Linux Kernel source tree.
+ *
+ * ------------------------------------------------------------
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _NAND_DEFS_H_
+#define _NAND_DEFS_H_
+
+#define	MASK_CLE	0x10
+//#define	MASK_ALE	0x0a
+#define	MASK_ALE	0x08
+
+#define NAND_CE0CLE	((volatile u_int8_t *)(CFG_NAND_BASE + 0x10))
+//#define NAND_CE0ALE	((volatile u_int8_t *)(CFG_NAND_BASE + 0x0a))
+#define NAND_CE0ALE	((volatile u_int8_t *)(CFG_NAND_BASE + 0x08))
+#define NAND_CE0DATA	((volatile u_int8_t *)CFG_NAND_BASE)
+
+typedef struct  {
+	u_int32_t	NRCSR;
+	u_int32_t	AWCCR;
+	u_int8_t	RSVD0[8];
+	u_int32_t	AB1CR;
+	u_int32_t	AB2CR;
+	u_int32_t	AB3CR;
+	u_int32_t	AB4CR;
+	u_int8_t	RSVD1[32];
+	u_int32_t	NIRR;
+	u_int32_t	NIMR;
+	u_int32_t	NIMSR;
+	u_int32_t	NIMCR;
+	u_int8_t	RSVD2[16];
+	u_int32_t	NANDFCR;
+	u_int32_t	NANDFSR;
+	u_int8_t	RSVD3[8];
+	u_int32_t	NANDF1ECC;
+	u_int32_t	NANDF2ECC;
+	u_int32_t	NANDF3ECC;
+	u_int32_t	NANDF4ECC;
+	u_int8_t	RSVD4[4];
+	u_int32_t	IODFTECR;
+	u_int32_t	IODFTGCR;
+	u_int8_t	RSVD5[4];
+	u_int32_t	IODFTMRLR;
+	u_int32_t	IODFTMRMR;
+	u_int32_t	IODFTMRMSBR;
+	u_int8_t	RSVD6[20];
+	u_int32_t	MODRNR;
+	u_int8_t	RSVD7[76];
+	u_int32_t	CE0DATA;
+	u_int32_t	CE0ALE;
+	u_int32_t	CE0CLE;
+	u_int8_t	RSVD8[4];
+	u_int32_t	CE1DATA;
+	u_int32_t	CE1ALE;
+	u_int32_t	CE1CLE;
+	u_int8_t	RSVD9[4];
+	u_int32_t	CE2DATA;
+	u_int32_t	CE2ALE;
+	u_int32_t	CE2CLE;
+	u_int8_t	RSVD10[4];
+	u_int32_t	CE3DATA;
+	u_int32_t	CE3ALE;
+	u_int32_t	CE3CLE;
+} nand_registers;
+
+typedef volatile nand_registers	*nandregs;
+
+#define NAND_READ_START		0x00
+#define NAND_READ_END		0x30
+#define NAND_STATUS		0x70
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch-arm926ejs/sizes.h u-boot-1.2.0-leopard/include/asm/arch-arm926ejs/sizes.h
--- u-boot-1.2.0/include/asm/arch-arm926ejs/sizes.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm926ejs/sizes.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,51 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA0 2111-1307
+ * USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *		   from .s file by awk -f s2h.awk
+ */
+/*  Size defintions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h			1
+
+/* handy sizes */
+#define SZ_1K		0x00000400
+#define SZ_4K		0x00001000
+#define SZ_8K		0x00002000
+#define SZ_16K		0x00004000
+#define SZ_64K		0x00010000
+#define SZ_128K	0x00020000
+#define SZ_256K	0x00040000
+#define SZ_512K	0x00080000
+
+#define SZ_1M		0x00100000
+#define SZ_2M		0x00200000
+#define SZ_4M		0x00400000
+#define SZ_8M		0x00800000
+#define SZ_16M		0x01000000
+#define SZ_32M		0x02000000
+#define SZ_64M		0x04000000
+#define SZ_128M	0x08000000
+#define SZ_256M	0x10000000
+#define SZ_512M	0x20000000
+
+#define SZ_1G		0x40000000
+#define SZ_2G		0x80000000
+
+#endif	/* __sizes_h */
diff -Nurd u-boot-1.2.0/include/asm/arch-arm926ejs/types.h u-boot-1.2.0-leopard/include/asm/arch-arm926ejs/types.h
--- u-boot-1.2.0/include/asm/arch-arm926ejs/types.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-arm926ejs/types.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) Sergey Kubushyn <ksi@koi8.net>, 2007.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _ASM_ARCH_TYPES_H_
+#define _ASM_ARCH_TYPES_H_
+
+#define	REG(addr)	(*(volatile unsigned int *)(addr))
+#define REG_P(addr)	((volatile unsigned int *)(addr))
+
+typedef volatile unsigned int	dv_reg;
+typedef volatile unsigned int *	dv_reg_p;
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch-at91rm9200/AT91RM9200.h u-boot-1.2.0-leopard/include/asm/arch-at91rm9200/AT91RM9200.h
--- u-boot-1.2.0/include/asm/arch-at91rm9200/AT91RM9200.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-at91rm9200/AT91RM9200.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,762 @@
+/*
+ * (C) Copyright 2003
+ * AT91RM9200 definitions
+ * Author : ATMEL AT91 application group
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef AT91RM9200_H
+#define AT91RM9200_H
+
+typedef volatile unsigned int AT91_REG;		/* Hardware register definition */
+
+/******************************************************************************/
+/*        SOFTWARE API DEFINITION  FOR Timer Counter Channel Interface        */
+/******************************************************************************/
+typedef struct _AT91S_TC
+{
+	AT91_REG	 TC_CCR; 	/* Channel Control Register */
+	AT91_REG	 TC_CMR; 	/* Channel Mode Register */
+	AT91_REG	 Reserved0[2]; 	/*  */
+	AT91_REG	 TC_CV; 	/* Counter Value */
+	AT91_REG	 TC_RA; 	/* Register A */
+	AT91_REG	 TC_RB; 	/* Register B */
+	AT91_REG	 TC_RC; 	/* Register C */
+	AT91_REG	 TC_SR; 	/* Status Register */
+	AT91_REG	 TC_IER; 	/* Interrupt Enable Register */
+	AT91_REG	 TC_IDR; 	/* Interrupt Disable Register */
+	AT91_REG	 TC_IMR; 	/* Interrupt Mask Register */
+} AT91S_TC, *AT91PS_TC;
+
+#define AT91C_TC_TIMER_DIV1_CLOCK	((unsigned int) 0x0 <<  0) /* (TC) MCK/2 */
+#define AT91C_TC_TIMER_DIV2_CLOCK	((unsigned int) 0x1 <<  0) /* (TC) MCK/8 */
+#define AT91C_TC_TIMER_DIV3_CLOCK	((unsigned int) 0x2 <<  0) /* (TC) MCK/32 */
+#define AT91C_TC_TIMER_DIV4_CLOCK	((unsigned int) 0x3 <<  0) /* (TC) MCK/128 */
+#define AT91C_TC_SLOW_CLOCK		((unsigned int) 0x4 <<  0) /* (TC) SLOW CLK */
+#define AT91C_TC_XC0_CLOCK		((unsigned int) 0x5 <<  0) /* (TC) XC0 */
+#define AT91C_TC_XC1_CLOCK		((unsigned int) 0x6 <<  0) /* (TC) XC1 */
+#define AT91C_TC_XC2_CLOCK		((unsigned int) 0x7 <<  0) /* (TC) XC2 */
+#define AT91C_TCB_TC0XC0S_NONE		((unsigned int) 0x1)       /* (TCB) None signal connected to XC0 */
+#define AT91C_TCB_TC1XC1S_NONE		((unsigned int) 0x1 <<  2) /* (TCB) None signal connected to XC1 */
+#define AT91C_TCB_TC2XC2S_NONE		((unsigned int) 0x1 <<  4) /* (TCB) None signal connected to XC2 */
+#define AT91C_TC_CLKDIS			((unsigned int) 0x1 <<  1) /* (TC) Counter Clock Disable Command */
+#define AT91C_TC_SWTRG			((unsigned int) 0x1 <<  2) /* (TC) Software Trigger Command */
+#define AT91C_TC_CLKEN			((unsigned int) 0x1 <<  0) /* (TC) Counter Clock Enable Command */
+
+/******************************************************************************/
+/*                  SOFTWARE API DEFINITION  FOR Usart                        */
+/******************************************************************************/
+typedef struct _AT91S_USART
+{
+	AT91_REG	 US_CR; 	/* Control Register */
+	AT91_REG	 US_MR; 	/* Mode Register */
+	AT91_REG	 US_IER; 	/* Interrupt Enable Register */
+	AT91_REG	 US_IDR; 	/* Interrupt Disable Register */
+	AT91_REG	 US_IMR; 	/* Interrupt Mask Register */
+	AT91_REG	 US_CSR; 	/* Channel Status Register */
+	AT91_REG	 US_RHR; 	/* Receiver Holding Register */
+	AT91_REG	 US_THR; 	/* Transmitter Holding Register */
+	AT91_REG	 US_BRGR; 	/* Baud Rate Generator Register */
+	AT91_REG	 US_RTOR; 	/* Receiver Time-out Register */
+	AT91_REG	 US_TTGR; 	/* Transmitter Time-guard Register */
+	AT91_REG	 Reserved0[5]; 	/*  */
+	AT91_REG	 US_FIDI; 	/* FI_DI_Ratio Register */
+	AT91_REG	 US_NER; 	/* Nb Errors Register */
+	AT91_REG	 US_XXR; 	/* XON_XOFF Register */
+	AT91_REG	 US_IF; 	/* IRDA_FILTER Register */
+	AT91_REG	 Reserved1[44];	/*  */
+	AT91_REG	 US_RPR; 	/* Receive Pointer Register */
+	AT91_REG	 US_RCR; 	/* Receive Counter Register */
+	AT91_REG	 US_TPR; 	/* Transmit Pointer Register */
+	AT91_REG	 US_TCR; 	/* Transmit Counter Register */
+	AT91_REG	 US_RNPR; 	/* Receive Next Pointer Register */
+	AT91_REG	 US_RNCR; 	/* Receive Next Counter Register */
+	AT91_REG	 US_TNPR; 	/* Transmit Next Pointer Register */
+	AT91_REG	 US_TNCR; 	/* Transmit Next Counter Register */
+	AT91_REG	 US_PTCR; 	/* PDC Transfer Control Register */
+	AT91_REG	 US_PTSR; 	/* PDC Transfer Status Register */
+} AT91S_USART, *AT91PS_USART;
+
+/******************************************************************************/
+/*          SOFTWARE API DEFINITION  FOR Clock Generator Controler            */
+/******************************************************************************/
+typedef struct _AT91S_CKGR
+{
+	AT91_REG	 CKGR_MOR; 	/* Main Oscillator Register */
+	AT91_REG	 CKGR_MCFR; 	/* Main Clock  Frequency Register */
+	AT91_REG	 CKGR_PLLAR; 	/* PLL A Register */
+	AT91_REG	 CKGR_PLLBR; 	/* PLL B Register */
+} AT91S_CKGR, *AT91PS_CKGR;
+
+/* -------- CKGR_MOR : (CKGR Offset: 0x0) Main Oscillator Register -------- */
+#define AT91C_CKGR_MOSCEN	((unsigned int) 0x1  <<  0)	/* (CKGR) Main Oscillator Enable */
+#define AT91C_CKGR_OSCTEST	((unsigned int) 0x1  <<  1)	/* (CKGR) Oscillator Test */
+#define AT91C_CKGR_OSCOUNT	((unsigned int) 0xFF <<  8)	/* (CKGR) Main Oscillator Start-up Time */
+
+/* -------- CKGR_MCFR : (CKGR Offset: 0x4) Main Clock Frequency Register -------- */
+#define AT91C_CKGR_MAINF	((unsigned int) 0xFFFF <<  0)	/* (CKGR) Main Clock Frequency */
+#define AT91C_CKGR_MAINRDY	((unsigned int) 0x1 << 16)	/* (CKGR) Main Clock Ready */
+
+/* -------- CKGR_PLLAR : (CKGR Offset: 0x8) PLL A Register -------- */
+#define AT91C_CKGR_DIVA		((unsigned int) 0xFF  <<  0)	/* (CKGR) Divider Selected */
+#define AT91C_CKGR_DIVA_0	((unsigned int) 0x0)		/* (CKGR) Divider output is 0 */
+#define AT91C_CKGR_DIVA_BYPASS	((unsigned int) 0x1)		/* (CKGR) Divider is bypassed */
+#define AT91C_CKGR_PLLACOUNT	((unsigned int) 0x3F  <<  8)	/* (CKGR) PLL A Counter */
+#define AT91C_CKGR_OUTA		((unsigned int) 0x3   << 14)	/* (CKGR) PLL A Output Frequency Range */
+#define AT91C_CKGR_OUTA_0	((unsigned int) 0x0   << 14)	/* (CKGR) Please refer to the PLLA datasheet */
+#define AT91C_CKGR_OUTA_1	((unsigned int) 0x1   << 14)	/* (CKGR) Please refer to the PLLA datasheet */
+#define AT91C_CKGR_OUTA_2	((unsigned int) 0x2   << 14)	/* (CKGR) Please refer to the PLLA datasheet */
+#define AT91C_CKGR_OUTA_3	((unsigned int) 0x3   << 14)	/* (CKGR) Please refer to the PLLA datasheet */
+#define AT91C_CKGR_MULA		((unsigned int) 0x7FF << 16)	/* (CKGR) PLL A Multiplier */
+#define AT91C_CKGR_SRCA		((unsigned int) 0x1   << 29)	/* (CKGR) PLL A Source */
+
+/* -------- CKGR_PLLBR : (CKGR Offset: 0xc) PLL B Register -------- */
+#define AT91C_CKGR_DIVB		((unsigned int) 0xFF  <<  0)	/* (CKGR) Divider Selected */
+#define AT91C_CKGR_DIVB_0	((unsigned int) 0x0)		/* (CKGR) Divider output is 0 */
+#define AT91C_CKGR_DIVB_BYPASS	((unsigned int) 0x1)		/* (CKGR) Divider is bypassed */
+#define AT91C_CKGR_PLLBCOUNT	((unsigned int) 0x3F  <<  8)	/* (CKGR) PLL B Counter */
+#define AT91C_CKGR_OUTB		((unsigned int) 0x3   << 14)	/* (CKGR) PLL B Output Frequency Range */
+#define AT91C_CKGR_OUTB_0	((unsigned int) 0x0   << 14)	/* (CKGR) Please refer to the PLLB datasheet */
+#define AT91C_CKGR_OUTB_1	((unsigned int) 0x1   << 14)	/* (CKGR) Please refer to the PLLB datasheet */
+#define AT91C_CKGR_OUTB_2	((unsigned int) 0x2   << 14)	/* (CKGR) Please refer to the PLLB datasheet */
+#define AT91C_CKGR_OUTB_3	((unsigned int) 0x3   << 14)	/* (CKGR) Please refer to the PLLB datasheet */
+#define AT91C_CKGR_MULB		((unsigned int) 0x7FF << 16)	/* (CKGR) PLL B Multiplier */
+#define AT91C_CKGR_USB_96M	((unsigned int) 0x1   << 28)	/* (CKGR) Divider for USB Ports */
+#define AT91C_CKGR_USB_PLL	((unsigned int) 0x1   << 29)	/* (CKGR) PLL Use */
+
+/******************************************************************************/
+/*        SOFTWARE API DEFINITION  FOR Parallel Input Output Controler        */
+/******************************************************************************/
+typedef struct _AT91S_PIO
+{
+	AT91_REG	 PIO_PER; 	/* PIO Enable Register */
+	AT91_REG	 PIO_PDR; 	/* PIO Disable Register */
+	AT91_REG	 PIO_PSR; 	/* PIO Status Register */
+	AT91_REG	 Reserved0[1]; 	/*  */
+	AT91_REG	 PIO_OER; 	/* Output Enable Register */
+	AT91_REG	 PIO_ODR; 	/* Output Disable Registerr */
+	AT91_REG	 PIO_OSR; 	/* Output Status Register */
+	AT91_REG	 Reserved1[1]; 	/*  */
+	AT91_REG	 PIO_IFER; 	/* Input Filter Enable Register */
+	AT91_REG	 PIO_IFDR; 	/* Input Filter Disable Register */
+	AT91_REG	 PIO_IFSR; 	/* Input Filter Status Register */
+	AT91_REG	 Reserved2[1]; 	/*  */
+	AT91_REG	 PIO_SODR; 	/* Set Output Data Register */
+	AT91_REG	 PIO_CODR; 	/* Clear Output Data Register */
+	AT91_REG	 PIO_ODSR; 	/* Output Data Status Register */
+	AT91_REG	 PIO_PDSR; 	/* Pin Data Status Register */
+	AT91_REG	 PIO_IER; 	/* Interrupt Enable Register */
+	AT91_REG	 PIO_IDR; 	/* Interrupt Disable Register */
+	AT91_REG	 PIO_IMR; 	/* Interrupt Mask Register */
+	AT91_REG	 PIO_ISR; 	/* Interrupt Status Register */
+	AT91_REG	 PIO_MDER; 	/* Multi-driver Enable Register */
+	AT91_REG	 PIO_MDDR; 	/* Multi-driver Disable Register */
+	AT91_REG	 PIO_MDSR; 	/* Multi-driver Status Register */
+	AT91_REG	 Reserved3[1]; 	/*  */
+	AT91_REG	 PIO_PPUDR; 	/* Pull-up Disable Register */
+	AT91_REG	 PIO_PPUER; 	/* Pull-up Enable Register */
+	AT91_REG	 PIO_PPUSR; 	/* Pad Pull-up Status Register */
+	AT91_REG	 Reserved4[1]; 	/*  */
+	AT91_REG	 PIO_ASR; 	/* Select A Register */
+	AT91_REG	 PIO_BSR; 	/* Select B Register */
+	AT91_REG	 PIO_ABSR; 	/* AB Select Status Register */
+	AT91_REG	 Reserved5[9]; 	/*  */
+	AT91_REG	 PIO_OWER; 	/* Output Write Enable Register */
+	AT91_REG	 PIO_OWDR; 	/* Output Write Disable Register */
+	AT91_REG	 PIO_OWSR; 	/* Output Write Status Register */
+} AT91S_PIO, *AT91PS_PIO;
+
+
+/******************************************************************************/
+/*              SOFTWARE API DEFINITION  FOR Debug Unit                       */
+/******************************************************************************/
+typedef struct _AT91S_DBGU
+{
+	AT91_REG	 DBGU_CR; 	/* Control Register */
+	AT91_REG	 DBGU_MR; 	/* Mode Register */
+	AT91_REG	 DBGU_IER; 	/* Interrupt Enable Register */
+	AT91_REG	 DBGU_IDR; 	/* Interrupt Disable Register */
+	AT91_REG	 DBGU_IMR; 	/* Interrupt Mask Register */
+	AT91_REG	 DBGU_CSR; 	/* Channel Status Register */
+	AT91_REG	 DBGU_RHR; 	/* Receiver Holding Register */
+	AT91_REG	 DBGU_THR; 	/* Transmitter Holding Register */
+	AT91_REG	 DBGU_BRGR; 	/* Baud Rate Generator Register */
+	AT91_REG	 Reserved0[7]; 	/*  */
+	AT91_REG	 DBGU_C1R; 	/* Chip ID1 Register */
+	AT91_REG	 DBGU_C2R; 	/* Chip ID2 Register */
+	AT91_REG	 DBGU_FNTR; 	/* Force NTRST Register */
+	AT91_REG	 Reserved1[45]; 	/*  */
+	AT91_REG	 DBGU_RPR; 	/* Receive Pointer Register */
+	AT91_REG	 DBGU_RCR; 	/* Receive Counter Register */
+	AT91_REG	 DBGU_TPR; 	/* Transmit Pointer Register */
+	AT91_REG	 DBGU_TCR; 	/* Transmit Counter Register */
+	AT91_REG	 DBGU_RNPR; 	/* Receive Next Pointer Register */
+	AT91_REG	 DBGU_RNCR; 	/* Receive Next Counter Register */
+	AT91_REG	 DBGU_TNPR; 	/* Transmit Next Pointer Register */
+	AT91_REG	 DBGU_TNCR; 	/* Transmit Next Counter Register */
+	AT91_REG	 DBGU_PTCR; 	/* PDC Transfer Control Register */
+	AT91_REG	 DBGU_PTSR; 	/* PDC Transfer Status Register */
+} AT91S_DBGU, *AT91PS_DBGU;
+
+/* -------- DBGU_IER : (DBGU Offset: 0x8) Debug Unit Interrupt Enable Register --------  */
+#define AT91C_US_RXRDY		((unsigned int) 0x1 <<  0) /* (DBGU) RXRDY Interrupt */
+#define AT91C_US_TXRDY		((unsigned int) 0x1 <<  1) /* (DBGU) TXRDY Interrupt */
+#define AT91C_US_ENDRX		((unsigned int) 0x1 <<  3) /* (DBGU) End of Receive Transfer Interrupt */
+#define AT91C_US_ENDTX		((unsigned int) 0x1 <<  4) /* (DBGU) End of Transmit Interrupt */
+#define AT91C_US_OVRE		((unsigned int) 0x1 <<  5) /* (DBGU) Overrun Interrupt */
+#define AT91C_US_FRAME		((unsigned int) 0x1 <<  6) /* (DBGU) Framing Error Interrupt */
+#define AT91C_US_PARE		((unsigned int) 0x1 <<  7) /* (DBGU) Parity Error Interrupt */
+#define AT91C_US_TXEMPTY	((unsigned int) 0x1 <<  9) /* (DBGU) TXEMPTY Interrupt */
+#define AT91C_US_TXBUFE		((unsigned int) 0x1 << 11) /* (DBGU) TXBUFE Interrupt */
+#define AT91C_US_RXBUFF		((unsigned int) 0x1 << 12) /* (DBGU) RXBUFF Interrupt */
+#define AT91C_US_COMM_TX	((unsigned int) 0x1 << 30) /* (DBGU) COMM_TX Interrupt */
+#define AT91C_US_COMM_RX	((unsigned int) 0x1 << 31) /* (DBGU) COMM_RX Interrupt */
+
+/* -------- DBGU_CR : (DBGU Offset: 0x0) Debug Unit Control Register --------  */
+#define AT91C_US_RSTRX		((unsigned int) 0x1 <<  2) /* (DBGU) Reset Receiver */
+#define AT91C_US_RSTTX		((unsigned int) 0x1 <<  3) /* (DBGU) Reset Transmitter */
+#define AT91C_US_RXEN		((unsigned int) 0x1 <<  4) /* (DBGU) Receiver Enable */
+#define AT91C_US_RXDIS		((unsigned int) 0x1 <<  5) /* (DBGU) Receiver Disable */
+#define AT91C_US_TXEN		((unsigned int) 0x1 <<  6) /* (DBGU) Transmitter Enable */
+#define AT91C_US_TXDIS		((unsigned int) 0x1 <<  7) /* (DBGU) Transmitter Disable */
+
+#define AT91C_US_CLKS_CLOCK	((unsigned int) 0x0 <<  4) /* (USART) Clock */
+#define AT91C_US_CHRL_8_BITS	((unsigned int) 0x3 <<  6) /* (USART) Character Length: 8 bits */
+#define AT91C_US_PAR_NONE	((unsigned int) 0x4 <<  9) /* (DBGU) No Parity */
+#define AT91C_US_NBSTOP_1_BIT	((unsigned int) 0x0 << 12) /* (USART) 1 stop bit */
+
+/******************************************************************************/
+/*      SOFTWARE API DEFINITION  FOR Static Memory Controller 2 Interface     */
+/******************************************************************************/
+typedef struct _AT91S_SMC2
+{
+	AT91_REG	 SMC2_CSR[8]; 	/* SMC2 Chip Select Register */
+} AT91S_SMC2, *AT91PS_SMC2;
+
+/* -------- SMC2_CSR : (SMC2 Offset: 0x0) SMC2 Chip Select Register --------  */
+#define AT91C_SMC2_NWS			((unsigned int) 0x7F << 0) /* (SMC2) Number of Wait States */
+#define AT91C_SMC2_WSEN			((unsigned int) 0x1 <<  7) /* (SMC2) Wait State Enable */
+#define AT91C_SMC2_TDF			((unsigned int) 0xF <<  8) /* (SMC2) Data Float Time */
+#define AT91C_SMC2_BAT			((unsigned int) 0x1 << 12) /* (SMC2) Byte Access Type */
+#define AT91C_SMC2_DBW			((unsigned int) 0x1 << 13) /* (SMC2) Data Bus Width */
+#define AT91C_SMC2_DBW_16		((unsigned int) 0x1 << 13) /* (SMC2) 16-bit. */
+#define AT91C_SMC2_DBW_8		((unsigned int) 0x2 << 13) /* (SMC2) 8-bit. */
+#define AT91C_SMC2_DRP			((unsigned int) 0x1 << 15) /* (SMC2) Data Read Protocol */
+#define AT91C_SMC2_ACSS			((unsigned int) 0x3 << 16) /* (SMC2) Address to Chip Select Setup */
+#define AT91C_SMC2_ACSS_STANDARD	((unsigned int) 0x0 << 16) /* (SMC2) Standard, asserted at the beginning of the access and deasserted at the end. */
+#define AT91C_SMC2_ACSS_1_CYCLE		((unsigned int) 0x1 << 16) /* (SMC2) One cycle less at the beginning and the end of the access. */
+#define AT91C_SMC2_ACSS_2_CYCLES	((unsigned int) 0x2 << 16) /* (SMC2) Two cycles less at the beginning and the end of the access. */
+#define AT91C_SMC2_ACSS_3_CYCLES	((unsigned int) 0x3 << 16) /* (SMC2) Three cycles less at the beginning and the end of the access. */
+#define AT91C_SMC2_RWSETUP		((unsigned int) 0x7 << 24) /* (SMC2) Read and Write Signal Setup Time */
+#define AT91C_SMC2_RWHOLD		((unsigned int) 0x7 << 29) /* (SMC2) Read and Write Signal Hold Time */
+
+/******************************************************************************/
+/*           SOFTWARE API DEFINITION  FOR Power Management Controler          */
+/******************************************************************************/
+typedef struct _AT91S_PMC
+{
+	AT91_REG	 PMC_SCER; 	/* System Clock Enable Register */
+	AT91_REG	 PMC_SCDR; 	/* System Clock Disable Register */
+	AT91_REG	 PMC_SCSR; 	/* System Clock Status Register */
+	AT91_REG	 Reserved0[1]; 	/* */
+	AT91_REG	 PMC_PCER; 	/* Peripheral Clock Enable Register */
+	AT91_REG	 PMC_PCDR; 	/* Peripheral Clock Disable Register */
+	AT91_REG	 PMC_PCSR; 	/* Peripheral Clock Status Register */
+	AT91_REG	 Reserved1[5]; 	/* */
+	AT91_REG	 PMC_MCKR; 	/* Master Clock Register */
+	AT91_REG	 Reserved2[3]; 	/* */
+	AT91_REG	 PMC_PCKR[8]; 	/* Programmable Clock Register */
+	AT91_REG	 PMC_IER; 	/* Interrupt Enable Register */
+	AT91_REG	 PMC_IDR; 	/* Interrupt Disable Register */
+	AT91_REG	 PMC_SR; 	/* Status Register */
+	AT91_REG	 PMC_IMR; 	/* Interrupt Mask Register */
+} AT91S_PMC, *AT91PS_PMC;
+
+/*------- PMC_SCER : (PMC Offset: 0x0) System Clock Enable Register --------*/
+#define AT91C_PMC_PCK		((unsigned int) 0x1 <<  0) /* (PMC) Processor Clock */
+#define AT91C_PMC_UDP		((unsigned int) 0x1 <<  1) /* (PMC) USB Device Port Clock */
+#define AT91C_PMC_MCKUDP	((unsigned int) 0x1 <<  2) /* (PMC) USB Device Port Master Clock Automatic Disable on Suspend */
+#define AT91C_PMC_UHP		((unsigned int) 0x1 <<  4) /* (PMC) USB Host Port Clock */
+#define AT91C_PMC_PCK0		((unsigned int) 0x1 <<  8) /* (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK1		((unsigned int) 0x1 <<  9) /* (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK2		((unsigned int) 0x1 << 10) /* (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK3		((unsigned int) 0x1 << 11) /* (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK4		((unsigned int) 0x1 << 12) /* (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK5		((unsigned int) 0x1 << 13) /* (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK6		((unsigned int) 0x1 << 14) /* (PMC) Programmable Clock Output */
+#define AT91C_PMC_PCK7		((unsigned int) 0x1 << 15) /* (PMC) Programmable Clock Output */
+/*-------- PMC_SCDR : (PMC Offset: 0x4) System Clock Disable Register ------*/
+/*-------- PMC_SCSR : (PMC Offset: 0x8) System Clock Status Register -------*/
+/*-------- PMC_MCKR : (PMC Offset: 0x30) Master Clock Register --------*/
+#define AT91C_PMC_CSS		((unsigned int) 0x3 <<  0) /* (PMC) Programmable Clock Selection */
+#define AT91C_PMC_CSS_SLOW_CLK	((unsigned int) 0x0)       /* (PMC) Slow Clock is selected */
+#define AT91C_PMC_CSS_MAIN_CLK	((unsigned int) 0x1)       /* (PMC) Main Clock is selected */
+#define AT91C_PMC_CSS_PLLA_CLK	((unsigned int) 0x2)       /* (PMC) Clock from PLL A is selected */
+#define AT91C_PMC_CSS_PLLB_CLK	((unsigned int) 0x3)       /* (PMC) Clock from PLL B is selected */
+#define AT91C_PMC_PRES		((unsigned int) 0x7 <<  2) /* (PMC) Programmable Clock Prescaler */
+#define AT91C_PMC_PRES_CLK	((unsigned int) 0x0 <<  2) /* (PMC) Selected clock */
+#define AT91C_PMC_PRES_CLK_2	((unsigned int) 0x1 <<  2) /* (PMC) Selected clock divided by 2 */
+#define AT91C_PMC_PRES_CLK_4	((unsigned int) 0x2 <<  2) /* (PMC) Selected clock divided by 4 */
+#define AT91C_PMC_PRES_CLK_8	((unsigned int) 0x3 <<  2) /* (PMC) Selected clock divided by 8 */
+#define AT91C_PMC_PRES_CLK_16	((unsigned int) 0x4 <<  2) /* (PMC) Selected clock divided by 16 */
+#define AT91C_PMC_PRES_CLK_32	((unsigned int) 0x5 <<  2) /* (PMC) Selected clock divided by 32 */
+#define AT91C_PMC_PRES_CLK_64	((unsigned int) 0x6 <<  2) /* (PMC) Selected clock divided by 64 */
+#define AT91C_PMC_MDIV		((unsigned int) 0x3 <<  8) /* (PMC) Master Clock Division */
+#define AT91C_PMC_MDIV_1	((unsigned int) 0x0 <<  8) /* (PMC) The master clock and the processor clock are the same */
+#define AT91C_PMC_MDIV_2	((unsigned int) 0x1 <<  8) /* (PMC) The processor clock is twice as fast as the master clock */
+#define AT91C_PMC_MDIV_3	((unsigned int) 0x2 <<  8) /* (PMC) The processor clock is three times faster than the master clock */
+#define AT91C_PMC_MDIV_4	((unsigned int) 0x3 <<  8) /* (PMC) The processor clock is four times faster than the master clock */
+/*------ PMC_PCKR : (PMC Offset: 0x40) Programmable Clock Register --------*/
+/*------ PMC_IER : (PMC Offset: 0x60) PMC Interrupt Enable Register -------*/
+#define AT91C_PMC_MOSCS		((unsigned int) 0x1 <<  0) /* (PMC) MOSC Status/Enable/Disable/Mask */
+#define AT91C_PMC_LOCKA		((unsigned int) 0x1 <<  1) /* (PMC) PLL A Status/Enable/Disable/Mask */
+#define AT91C_PMC_LOCKB		((unsigned int) 0x1 <<  2) /* (PMC) PLL B Status/Enable/Disable/Mask */
+#define AT91C_PMC_MCKRDY	((unsigned int) 0x1 <<  3) /* (PMC) MCK_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK0RDY	((unsigned int) 0x1 <<  8) /* (PMC) PCK0_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK1RDY	((unsigned int) 0x1 <<  9) /* (PMC) PCK1_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK2RDY	((unsigned int) 0x1 << 10) /* (PMC) PCK2_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK3RDY	((unsigned int) 0x1 << 11) /* (PMC) PCK3_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK4RDY	((unsigned int) 0x1 << 12) /* (PMC) PCK4_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK5RDY	((unsigned int) 0x1 << 13) /* (PMC) PCK5_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK6RDY	((unsigned int) 0x1 << 14) /* (PMC) PCK6_RDY Status/Enable/Disable/Mask */
+#define AT91C_PMC_PCK7RDY	((unsigned int) 0x1 << 15) /* (PMC) PCK7_RDY Status/Enable/Disable/Mask */
+/*---- PMC_IDR : (PMC Offset: 0x64) PMC Interrupt Disable Register --------*/
+/*-------- PMC_SR : (PMC Offset: 0x68) PMC Status Register --------*/
+/*-------- PMC_IMR : (PMC Offset: 0x6c) PMC Interrupt Mask Register --------*/
+
+/******************************************************************************/
+/*              SOFTWARE API DEFINITION  FOR Ethernet MAC                     */
+/******************************************************************************/
+typedef struct _AT91S_EMAC
+{
+	AT91_REG	 EMAC_CTL; 	/* Network Control Register */
+	AT91_REG	 EMAC_CFG; 	/* Network Configuration Register */
+	AT91_REG	 EMAC_SR; 	/* Network Status Register */
+	AT91_REG	 EMAC_TAR; 	/* Transmit Address Register */
+	AT91_REG	 EMAC_TCR; 	/* Transmit Control Register */
+	AT91_REG	 EMAC_TSR; 	/* Transmit Status Register */
+	AT91_REG	 EMAC_RBQP; 	/* Receive Buffer Queue Pointer */
+	AT91_REG	 Reserved0[1]; 	/*  */
+	AT91_REG	 EMAC_RSR; 	/* Receive Status Register */
+	AT91_REG	 EMAC_ISR; 	/* Interrupt Status Register */
+	AT91_REG	 EMAC_IER; 	/* Interrupt Enable Register */
+	AT91_REG	 EMAC_IDR; 	/* Interrupt Disable Register */
+	AT91_REG	 EMAC_IMR; 	/* Interrupt Mask Register */
+	AT91_REG	 EMAC_MAN; 	/* PHY Maintenance Register */
+	AT91_REG	 Reserved1[2]; 	/*  */
+	AT91_REG	 EMAC_FRA; 	/* Frames Transmitted OK Register */
+	AT91_REG	 EMAC_SCOL; 	/* Single Collision Frame Register */
+	AT91_REG	 EMAC_MCOL; 	/* Multiple Collision Frame Register */
+	AT91_REG	 EMAC_OK; 	/* Frames Received OK Register */
+	AT91_REG	 EMAC_SEQE; 	/* Frame Check Sequence Error Register */
+	AT91_REG	 EMAC_ALE; 	/* Alignment Error Register */
+	AT91_REG	 EMAC_DTE; 	/* Deferred Transmission Frame Register */
+	AT91_REG	 EMAC_LCOL; 	/* Late Collision Register */
+	AT91_REG	 EMAC_ECOL; 	/* Excessive Collision Register */
+	AT91_REG	 EMAC_CSE; 	/* Carrier Sense Error Register */
+	AT91_REG	 EMAC_TUE; 	/* Transmit Underrun Error Register */
+	AT91_REG	 EMAC_CDE; 	/* Code Error Register */
+	AT91_REG	 EMAC_ELR; 	/* Excessive Length Error Register */
+	AT91_REG	 EMAC_RJB; 	/* Receive Jabber Register */
+	AT91_REG	 EMAC_USF; 	/* Undersize Frame Register */
+	AT91_REG	 EMAC_SQEE; 	/* SQE Test Error Register */
+	AT91_REG	 EMAC_DRFC; 	/* Discarded RX Frame Register */
+	AT91_REG	 Reserved2[3]; 	/*  */
+	AT91_REG	 EMAC_HSH; 	/* Hash Address High[63:32] */
+	AT91_REG	 EMAC_HSL; 	/* Hash Address Low[31:0] */
+	AT91_REG	 EMAC_SA1L; 	/* Specific Address 1 Low, First 4 bytes */
+	AT91_REG	 EMAC_SA1H; 	/* Specific Address 1 High, Last 2 bytes */
+	AT91_REG	 EMAC_SA2L; 	/* Specific Address 2 Low, First 4 bytes */
+	AT91_REG	 EMAC_SA2H; 	/* Specific Address 2 High, Last 2 bytes */
+	AT91_REG	 EMAC_SA3L; 	/* Specific Address 3 Low, First 4 bytes */
+	AT91_REG	 EMAC_SA3H; 	/* Specific Address 3 High, Last 2 bytes */
+	AT91_REG	 EMAC_SA4L; 	/* Specific Address 4 Low, First 4 bytes */
+	AT91_REG	 EMAC_SA4H; 	/* Specific Address 4 High, Last 2 bytesr */
+} AT91S_EMAC, *AT91PS_EMAC;
+
+/* -------- EMAC_CTL : (EMAC Offset: 0x0)  --------  */
+#define AT91C_EMAC_LB		((unsigned int) 0x1 <<  0) /* (EMAC) Loopback. Optional. When set, loopback signal is at high level. */
+#define AT91C_EMAC_LBL		((unsigned int) 0x1 <<  1) /* (EMAC) Loopback local. */
+#define AT91C_EMAC_RE		((unsigned int) 0x1 <<  2) /* (EMAC) Receive enable. */
+#define AT91C_EMAC_TE		((unsigned int) 0x1 <<  3) /* (EMAC) Transmit enable. */
+#define AT91C_EMAC_MPE		((unsigned int) 0x1 <<  4) /* (EMAC) Management port enable. */
+#define AT91C_EMAC_CSR		((unsigned int) 0x1 <<  5) /* (EMAC) Clear statistics registers. */
+#define AT91C_EMAC_ISR		((unsigned int) 0x1 <<  6) /* (EMAC) Increment statistics registers. */
+#define AT91C_EMAC_WES		((unsigned int) 0x1 <<  7) /* (EMAC) Write enable for statistics registers. */
+#define AT91C_EMAC_BP		((unsigned int) 0x1 <<  8) /* (EMAC) Back pressure. */
+
+/* -------- EMAC_CFG : (EMAC Offset: 0x4) Network Configuration Register --------  */
+#define AT91C_EMAC_SPD		((unsigned int) 0x1 <<  0) /* (EMAC) Speed. */
+#define AT91C_EMAC_FD		((unsigned int) 0x1 <<  1) /* (EMAC) Full duplex. */
+#define AT91C_EMAC_BR		((unsigned int) 0x1 <<  2) /* (EMAC) Bit rate. */
+#define AT91C_EMAC_CAF		((unsigned int) 0x1 <<  4) /* (EMAC) Copy all frames. */
+#define AT91C_EMAC_NBC		((unsigned int) 0x1 <<  5) /* (EMAC) No broadcast. */
+#define AT91C_EMAC_MTI		((unsigned int) 0x1 <<  6) /* (EMAC) Multicast hash enable */
+#define AT91C_EMAC_UNI		((unsigned int) 0x1 <<  7) /* (EMAC) Unicast hash enable. */
+#define AT91C_EMAC_BIG		((unsigned int) 0x1 <<  8) /* (EMAC) Receive 1522 bytes. */
+#define AT91C_EMAC_EAE		((unsigned int) 0x1 <<  9) /* (EMAC) External address match enable. */
+#define AT91C_EMAC_CLK		((unsigned int) 0x3 << 10) /* (EMAC) */
+#define AT91C_EMAC_CLK_HCLK_8	((unsigned int) 0x0 << 10) /* (EMAC) HCLK divided by 8 */
+#define AT91C_EMAC_CLK_HCLK_16	((unsigned int) 0x1 << 10) /* (EMAC) HCLK divided by 16 */
+#define AT91C_EMAC_CLK_HCLK_32	((unsigned int) 0x2 << 10) /* (EMAC) HCLK divided by 32 */
+#define AT91C_EMAC_CLK_HCLK_64	((unsigned int) 0x3 << 10) /* (EMAC) HCLK divided by 64 */
+#define AT91C_EMAC_RTY		((unsigned int) 0x1 << 12) /* (EMAC) */
+#define AT91C_EMAC_RMII		((unsigned int) 0x1 << 13) /* (EMAC) */
+
+/* -------- EMAC_SR : (EMAC Offset: 0x8) Network Status Register --------  */
+#define AT91C_EMAC_MDIO		((unsigned int) 0x1 <<  1) /* (EMAC) */
+#define AT91C_EMAC_IDLE		((unsigned int) 0x1 <<  2) /* (EMAC) */
+
+/* -------- EMAC_TCR : (EMAC Offset: 0x10) Transmit Control Register -------- */
+#define AT91C_EMAC_LEN		((unsigned int) 0x7FF <<  0) /* (EMAC) */
+#define AT91C_EMAC_NCRC		((unsigned int) 0x1 << 15) /* (EMAC) */
+
+/* -------- EMAC_TSR : (EMAC Offset: 0x14) Transmit Control Register -------- */
+#define AT91C_EMAC_OVR		((unsigned int) 0x1 <<  0) /* (EMAC) */
+#define AT91C_EMAC_COL		((unsigned int) 0x1 <<  1) /* (EMAC) */
+#define AT91C_EMAC_RLE		((unsigned int) 0x1 <<  2) /* (EMAC) */
+#define AT91C_EMAC_TXIDLE	((unsigned int) 0x1 <<  3) /* (EMAC) */
+#define AT91C_EMAC_BNQ		((unsigned int) 0x1 <<  4) /* (EMAC) */
+#define AT91C_EMAC_COMP		((unsigned int) 0x1 <<  5) /* (EMAC) */
+#define AT91C_EMAC_UND		((unsigned int) 0x1 <<  6) /* (EMAC) */
+
+/* -------- EMAC_RSR : (EMAC Offset: 0x20) Receive Status Register -------- */
+#define AT91C_EMAC_BNA		((unsigned int) 0x1 <<  0) /* (EMAC) */
+#define AT91C_EMAC_REC		((unsigned int) 0x1 <<  1) /* (EMAC) */
+#define AT91C_EMAC_RSR_OVR	((unsigned int) 0x1 <<  2) /* (EMAC) */
+
+/* -------- EMAC_ISR : (EMAC Offset: 0x24) Interrupt Status Register -------- */
+#define AT91C_EMAC_DONE		((unsigned int) 0x1 <<  0) /* (EMAC) */
+#define AT91C_EMAC_RCOM		((unsigned int) 0x1 <<  1) /* (EMAC) */
+#define AT91C_EMAC_RBNA		((unsigned int) 0x1 <<  2) /* (EMAC) */
+#define AT91C_EMAC_TOVR		((unsigned int) 0x1 <<  3) /* (EMAC) */
+#define AT91C_EMAC_TUND		((unsigned int) 0x1 <<  4) /* (EMAC) */
+#define AT91C_EMAC_RTRY		((unsigned int) 0x1 <<  5) /* (EMAC) */
+#define AT91C_EMAC_TBRE		((unsigned int) 0x1 <<  6) /* (EMAC) */
+#define AT91C_EMAC_TCOM		((unsigned int) 0x1 <<  7) /* (EMAC) */
+#define AT91C_EMAC_TIDLE	((unsigned int) 0x1 <<  8) /* (EMAC) */
+#define AT91C_EMAC_LINK		((unsigned int) 0x1 <<  9) /* (EMAC) */
+#define AT91C_EMAC_ROVR		((unsigned int) 0x1 << 10) /* (EMAC) */
+#define AT91C_EMAC_HRESP	((unsigned int) 0x1 << 11) /* (EMAC) */
+
+/* -------- EMAC_IER : (EMAC Offset: 0x28) Interrupt Enable Register -------- */
+/* -------- EMAC_IDR : (EMAC Offset: 0x2c) Interrupt Disable Register -------- */
+/* -------- EMAC_IMR : (EMAC Offset: 0x30) Interrupt Mask Register -------- */
+/* -------- EMAC_MAN : (EMAC Offset: 0x34) PHY Maintenance Register -------- */
+#define AT91C_EMAC_DATA		((unsigned int) 0xFFFF <<  0) /* (EMAC) */
+#define AT91C_EMAC_CODE		((unsigned int) 0x3  << 16) /* (EMAC) */
+#define AT91C_EMAC_CODE_802_3	((unsigned int) 0x2  << 16) /* (EMAC) Write Operation */
+#define AT91C_EMAC_REGA		((unsigned int) 0x1F << 18) /* (EMAC) */
+#define AT91C_EMAC_PHYA		((unsigned int) 0x1F << 23) /* (EMAC) */
+#define AT91C_EMAC_RW		((unsigned int) 0x3  << 28) /* (EMAC) */
+#define AT91C_EMAC_RW_R		((unsigned int) 0x2  << 28) /* (EMAC) Read Operation */
+#define AT91C_EMAC_RW_W		((unsigned int) 0x1  << 28) /* (EMAC) Write Operation */
+#define AT91C_EMAC_HIGH		((unsigned int) 0x1  << 30) /* (EMAC) */
+#define AT91C_EMAC_LOW		((unsigned int) 0x1  << 31) /* (EMAC) */
+
+/******************************************************************************/
+/*           SOFTWARE API DEFINITION  FOR Serial Parallel Interface           */
+/******************************************************************************/
+typedef struct _AT91S_SPI
+{
+	AT91_REG	 SPI_CR; 	/* Control Register */
+	AT91_REG	 SPI_MR; 	/* Mode Register */
+	AT91_REG	 SPI_RDR; 	/* Receive Data Register */
+	AT91_REG	 SPI_TDR; 	/* Transmit Data Register */
+	AT91_REG	 SPI_SR; 	/* Status Register */
+	AT91_REG	 SPI_IER; 	/* Interrupt Enable Register */
+	AT91_REG	 SPI_IDR; 	/* Interrupt Disable Register */
+	AT91_REG	 SPI_IMR; 	/* Interrupt Mask Register */
+	AT91_REG	 Reserved0[4]; 	/* */
+	AT91_REG	 SPI_CSR[4]; 	/* Chip Select Register */
+	AT91_REG	 Reserved1[48]; /* */
+	AT91_REG	 SPI_RPR; 	/* Receive Pointer Register */
+	AT91_REG	 SPI_RCR; 	/* Receive Counter Register */
+	AT91_REG	 SPI_TPR; 	/* Transmit Pointer Register */
+	AT91_REG	 SPI_TCR; 	/* Transmit Counter Register */
+	AT91_REG	 SPI_RNPR; 	/* Receive Next Pointer Register */
+	AT91_REG	 SPI_RNCR; 	/* Receive Next Counter Register */
+	AT91_REG	 SPI_TNPR; 	/* Transmit Next Pointer Register */
+	AT91_REG	 SPI_TNCR; 	/* Transmit Next Counter Register */
+	AT91_REG	 SPI_PTCR; 	/* PDC Transfer Control Register */
+	AT91_REG	 SPI_PTSR; 	/* PDC Transfer Status Register */
+} AT91S_SPI, *AT91PS_SPI;
+
+/* -------- SPI_CR : (SPI Offset: 0x0) SPI Control Register -------- */
+#define AT91C_SPI_SPIEN		((unsigned int) 0x1 <<  0) /* (SPI) SPI Enable */
+#define AT91C_SPI_SPIDIS	((unsigned int) 0x1 <<  1) /* (SPI) SPI Disable */
+#define AT91C_SPI_SWRST		((unsigned int) 0x1 <<  7) /* (SPI) SPI Software reset */
+
+/* -------- SPI_MR : (SPI Offset: 0x4) SPI Mode Register -------- */
+#define AT91C_SPI_MSTR		((unsigned int) 0x1 <<  0) /* (SPI) Master/Slave Mode */
+#define AT91C_SPI_PS		((unsigned int) 0x1 <<  1) /* (SPI) Peripheral Select */
+#define AT91C_SPI_PS_FIXED	((unsigned int) 0x0 <<  1) /* (SPI) Fixed Peripheral Select */
+#define AT91C_SPI_PS_VARIABLE	((unsigned int) 0x1 <<  1) /* (SPI) Variable Peripheral Select */
+#define AT91C_SPI_PCSDEC	((unsigned int) 0x1 <<  2) /* (SPI) Chip Select Decode */
+#define AT91C_SPI_DIV32		((unsigned int) 0x1 <<  3) /* (SPI) Clock Selection */
+#define AT91C_SPI_MODFDIS	((unsigned int) 0x1 <<  4) /* (SPI) Mode Fault Detection */
+#define AT91C_SPI_LLB		((unsigned int) 0x1 <<  7) /* (SPI) Clock Selection */
+#define AT91C_SPI_PCS		((unsigned int) 0xF << 16) /* (SPI) Peripheral Chip Select */
+#define AT91C_SPI_DLYBCS	((unsigned int) 0xFF << 24) /* (SPI) Delay Between Chip Selects */
+
+/* -------- SPI_RDR : (SPI Offset: 0x8) Receive Data Register -------- */
+#define AT91C_SPI_RD		((unsigned int) 0xFFFF <<  0) /* (SPI) Receive Data */
+#define AT91C_SPI_RPCS		((unsigned int) 0xF << 16) /* (SPI) Peripheral Chip Select Status */
+
+/* -------- SPI_TDR : (SPI Offset: 0xc) Transmit Data Register -------- */
+#define AT91C_SPI_TD		((unsigned int) 0xFFFF <<  0) /* (SPI) Transmit Data */
+#define AT91C_SPI_TPCS		((unsigned int) 0xF << 16) /* (SPI) Peripheral Chip Select Status */
+
+/* -------- SPI_SR : (SPI Offset: 0x10) Status Register -------- */
+#define AT91C_SPI_RDRF		((unsigned int) 0x1 <<  0) /* (SPI) Receive Data Register Full */
+#define AT91C_SPI_TDRE		((unsigned int) 0x1 <<  1) /* (SPI) Transmit Data Register Empty */
+#define AT91C_SPI_MODF		((unsigned int) 0x1 <<  2) /* (SPI) Mode Fault Error */
+#define AT91C_SPI_OVRES		((unsigned int) 0x1 <<  3) /* (SPI) Overrun Error Status */
+#define AT91C_SPI_SPENDRX	((unsigned int) 0x1 <<  4) /* (SPI) End of Receiver Transfer */
+#define AT91C_SPI_SPENDTX	((unsigned int) 0x1 <<  5) /* (SPI) End of Receiver Transfer */
+#define AT91C_SPI_RXBUFF	((unsigned int) 0x1 <<  6) /* (SPI) RXBUFF Interrupt */
+#define AT91C_SPI_TXBUFE	((unsigned int) 0x1 <<  7) /* (SPI) TXBUFE Interrupt */
+#define AT91C_SPI_SPIENS	((unsigned int) 0x1 << 16) /* (SPI) Enable Status */
+
+/* -------- SPI_IER : (SPI Offset: 0x14) Interrupt Enable Register -------- */
+/* -------- SPI_IDR : (SPI Offset: 0x18) Interrupt Disable Register -------- */
+/* -------- SPI_IMR : (SPI Offset: 0x1c) Interrupt Mask Register -------- */
+/* -------- SPI_CSR : (SPI Offset: 0x30) Chip Select Register -------- */
+#define AT91C_SPI_CPOL		((unsigned int) 0x1  <<  0) /* (SPI) Clock Polarity */
+#define AT91C_SPI_NCPHA		((unsigned int) 0x1  <<  1) /* (SPI) Clock Phase */
+#define AT91C_SPI_BITS		((unsigned int) 0xF  <<  4) /* (SPI) Bits Per Transfer */
+#define AT91C_SPI_BITS_8	((unsigned int) 0x0  <<  4) /* (SPI) 8 Bits Per transfer */
+#define AT91C_SPI_BITS_9	((unsigned int) 0x1  <<  4) /* (SPI) 9 Bits Per transfer */
+#define AT91C_SPI_BITS_10	((unsigned int) 0x2  <<  4) /* (SPI) 10 Bits Per transfer */
+#define AT91C_SPI_BITS_11	((unsigned int) 0x3  <<  4) /* (SPI) 11 Bits Per transfer */
+#define AT91C_SPI_BITS_12	((unsigned int) 0x4  <<  4) /* (SPI) 12 Bits Per transfer */
+#define AT91C_SPI_BITS_13	((unsigned int) 0x5  <<  4) /* (SPI) 13 Bits Per transfer */
+#define AT91C_SPI_BITS_14	((unsigned int) 0x6  <<  4) /* (SPI) 14 Bits Per transfer */
+#define AT91C_SPI_BITS_15	((unsigned int) 0x7  <<  4) /* (SPI) 15 Bits Per transfer */
+#define AT91C_SPI_BITS_16	((unsigned int) 0x8  <<  4) /* (SPI) 16 Bits Per transfer */
+#define AT91C_SPI_SCBR		((unsigned int) 0xFF <<  8) /* (SPI) Serial Clock Baud Rate */
+#define AT91C_SPI_DLYBS		((unsigned int) 0xFF << 16) /* (SPI) Serial Clock Baud Rate */
+#define AT91C_SPI_DLYBCT	((unsigned int) 0xFF << 24) /* (SPI) Delay Between Consecutive Transfers */
+
+/******************************************************************************/
+/*           SOFTWARE API DEFINITION  FOR Peripheral Data Controller          */
+/******************************************************************************/
+typedef struct _AT91S_PDC
+{
+	AT91_REG	 PDC_RPR; 	/* Receive Pointer Register */
+	AT91_REG	 PDC_RCR; 	/* Receive Counter Register */
+	AT91_REG	 PDC_TPR; 	/* Transmit Pointer Register */
+	AT91_REG	 PDC_TCR; 	/* Transmit Counter Register */
+	AT91_REG	 PDC_RNPR; 	/* Receive Next Pointer Register */
+	AT91_REG	 PDC_RNCR; 	/* Receive Next Counter Register */
+	AT91_REG	 PDC_TNPR; 	/* Transmit Next Pointer Register */
+	AT91_REG	 PDC_TNCR; 	/* Transmit Next Counter Register */
+	AT91_REG	 PDC_PTCR; 	/* PDC Transfer Control Register */
+	AT91_REG	 PDC_PTSR; 	/* PDC Transfer Status Register */
+} AT91S_PDC, *AT91PS_PDC;
+
+/* -------- PDC_PTCR : (PDC Offset: 0x20) PDC Transfer Control Register -------- */
+#define AT91C_PDC_RXTEN		((unsigned int) 0x1 <<  0) /* (PDC) Receiver Transfer Enable */
+#define AT91C_PDC_RXTDIS	((unsigned int) 0x1 <<  1) /* (PDC) Receiver Transfer Disable */
+#define AT91C_PDC_TXTEN		((unsigned int) 0x1 <<  8) /* (PDC) Transmitter Transfer Enable */
+#define AT91C_PDC_TXTDIS	((unsigned int) 0x1 <<  9) /* (PDC) Transmitter Transfer Disable */
+/* -------- PDC_PTSR : (PDC Offset: 0x24) PDC Transfer Status Register --------  */
+
+/* ========== Register definition ==================================== */
+#define AT91C_SPI_CSR		((AT91_REG *)	0xFFFE0030) /* (SPI) Chip Select Register */
+#define AT91C_PMC_PCER		((AT91_REG *)	0xFFFFFC10) /* (PMC) Peripheral Clock Enable Register */
+#define AT91C_PMC_PCDR		((AT91_REG *)	0xFFFFFC14) /* (PMC) Peripheral Clock Enable Register */
+#define AT91C_PMC_SCER		((AT91_REG *)	0xFFFFFC00) /* (PMC) Peripheral Clock Enable Register */
+#define AT91C_PMC_SCDR		((AT91_REG *)	0xFFFFFC04) /* (PMC) Peripheral Clock Enable Register */
+#define AT91C_PIOA_PER		((AT91_REG *)	0xFFFFF400) /* (PIOA) PIO Enable Register */
+#define AT91C_PIOA_PDR		((AT91_REG *)	0xFFFFF404) /* (PIOA) PIO Disable Register */
+#define AT91C_PIOA_PSR		((AT91_REG *)	0xFFFFF408) /* (PIOA) PIO Status Register */
+#define AT91C_PIOA_OER		((AT91_REG *)	0xFFFFF410) /* (PIOA) PIO Output Enable Register */
+#define AT91C_PIOA_ODR		((AT91_REG *)	0xFFFFF414) /* (PIOA) PIO Output Disable Register */
+#define AT91C_PIOA_OSR		((AT91_REG *)	0xFFFFF418) /* (PIOA) PIO Output Status Register */
+#define AT91C_PIOA_IFER		((AT91_REG *)	0xFFFFF420) /* (PIOA) PIO Glitch Input Filter Enable Register */
+#define AT91C_PIOA_IFDR		((AT91_REG *)	0xFFFFF424) /* (PIOA) PIO Glitch Input Filter Disable Register */
+#define AT91C_PIOA_IFSR		((AT91_REG *)	0xFFFFF428) /* (PIOA) PIO Glitch Input Filter Status Register */
+#define AT91C_PIOA_SODR		((AT91_REG *)	0xFFFFF430) /* (PIOA) PIO Set Output Data Register */
+#define AT91C_PIOA_CODR		((AT91_REG *)	0xFFFFF434) /* (PIOA) PIO Clear Output Data Register */
+#define AT91C_PIOA_ODSR		((AT91_REG *)	0xFFFFF438) /* (PIOA) PIO Output Data Status Register */
+#define AT91C_PIOA_PDSR		((AT91_REG *)	0xFFFFF43C) /* (PIOA) PIO Pin Data Status Register */
+#define AT91C_PIOA_IER		((AT91_REG *)	0xFFFFF440) /* (PIOA) PIO Interrupt Enable Register */
+#define AT91C_PIOA_IDR		((AT91_REG *)	0xFFFFF444) /* (PIOA) PIO Interrupt Disable Register */
+#define AT91C_PIOA_IMR		((AT91_REG *)	0xFFFFF448) /* (PIOA) PIO Interrupt Mask Register */
+#define AT91C_PIOA_ISR		((AT91_REG *)	0xFFFFF44C) /* (PIOA) PIO Interrupt Status Register */
+#define AT91C_PIOA_MDER		((AT91_REG *)	0xFFFFF450) /* (PIOA) PIO Multi-drive Enable Register */
+#define AT91C_PIOA_MDDR		((AT91_REG *)	0xFFFFF454) /* (PIOA) PIO Multi-drive Disable Register */
+#define AT91C_PIOA_MDSR		((AT91_REG *)	0xFFFFF458) /* (PIOA) PIO Multi-drive Status Register */
+#define AT91C_PIOA_PUDR		((AT91_REG *)	0xFFFFF460) /* (PIOA) PIO Pull-up Disable Register */
+#define AT91C_PIOA_PUER		((AT91_REG *)	0xFFFFF464) /* (PIOA) PIO Pull-up Enable Register */
+#define AT91C_PIOA_PUSR		((AT91_REG *)	0xFFFFF468) /* (PIOA) PIO Pull-up Status Register */
+#define AT91C_PIOA_ASR		((AT91_REG *)	0xFFFFF470) /* (PIOA) PIO Peripheral A Select Register */
+#define AT91C_PIOA_BSR		((AT91_REG *)	0xFFFFF474) /* (PIOA) PIO Peripheral B Select Register */
+#define AT91C_PIOA_ABSR		((AT91_REG *)	0xFFFFF478) /* (PIOA) PIO Peripheral AB Select Register */
+#define AT91C_PIOA_OWER		((AT91_REG *)	0xFFFFF4A0) /* (PIOA) PIO Output Write Enable Register */
+#define AT91C_PIOA_OWDR		((AT91_REG *)	0xFFFFF4A4) /* (PIOA) PIO Output Write Disable Register */
+#define AT91C_PIOA_OWSR		((AT91_REG *)	0xFFFFF4A8) /* (PIOA) PIO Output Write Status Register */
+#define AT91C_PIOB_PDR		((AT91_REG *)	0xFFFFF604) /* (PIOB) PIO Disable Register */
+
+#define AT91C_PIO_PA30		((unsigned int) 1 << 30)	/* Pin Controlled by PA30 */
+#define AT91C_PIO_PC0		((unsigned int) 1 <<  0)	/* Pin Controlled by PC0 */
+#define AT91C_PC0_BFCK		((unsigned int) AT91C_PIO_PC0)	/* Burst Flash Clock */
+#define AT91C_PA30_DRXD		((unsigned int) AT91C_PIO_PA30)	/* DBGU Debug Receive Data */
+#define AT91C_PIO_PA31		((unsigned int) 1 << 31)	/* Pin Controlled by PA31 */
+#define AT91C_PA25_TWD		((unsigned int) 1 << 25)
+#define AT91C_PA26_TWCK		((unsigned int) 1 << 26)
+#define AT91C_PA31_DTXD		((unsigned int) AT91C_PIO_PA31)	/* DBGU Debug Transmit Data */
+#define AT91C_PIO_PA17		((unsigned int) 1 << 17)	/* Pin Controlled by PA17 */
+#define AT91C_PA17_TXD0		AT91C_PIO_PA17			/* USART0 Transmit Data */
+#define AT91C_PIO_PA18		((unsigned int) 1 << 18)	/* Pin Controlled by PA18 */
+#define AT91C_PA18_RXD0		AT91C_PIO_PA18			/* USART0 Receive Data */
+#define AT91C_PIO_PB20		((unsigned int) 1 << 20)	/* Pin Controlled by PB20 */
+#define AT91C_PB20_RXD1		AT91C_PIO_PB20			/* USART1 Receive Data */
+#define AT91C_PIO_PB21		((unsigned int) 1 << 21)	/* Pin Controlled by PB21 */
+#define AT91C_PB21_TXD1		AT91C_PIO_PB21			/* USART1 Transmit Data */
+
+#define AT91C_ID_SYS		((unsigned int)  1) /* System Peripheral */
+#define AT91C_ID_PIOA		((unsigned int)  2) /* PIO port A */
+#define AT91C_ID_PIOB		((unsigned int)  3) /* PIO port B */
+#define AT91C_ID_PIOC		((unsigned int)  4) /* PIO port C */
+#define AT91C_ID_USART0		((unsigned int)  6) /* USART 0 */
+#define AT91C_ID_USART1		((unsigned int)  7) /* USART 1 */
+#define AT91C_ID_TWI		((unsigned int) 12) /* Two Wire Interface */
+#define AT91C_ID_SPI		((unsigned int) 13) /* Serial Peripheral Interface */
+#define AT91C_ID_TC0		((unsigned int) 17) /* Timer Counter 0 */
+#define AT91C_ID_UHP		((unsigned int) 23) /* OHCI USB Host Port */
+#define AT91C_ID_EMAC		((unsigned int) 24) /* Ethernet MAC */
+
+#define AT91C_PIO_PC1		((unsigned int) 1 <<  1)	/* Pin Controlled by PC1 */
+#define AT91C_PC1_BFRDY_SMOE	((unsigned int) AT91C_PIO_PC1)	/*  Burst Flash Ready */
+#define AT91C_PIO_PC3		((unsigned int) 1 <<  3)	/* Pin Controlled by PC3 */
+#define AT91C_PC3_BFBAA_SMWE	((unsigned int) AT91C_PIO_PC3)	/*  Burst Flash Address Advance / SmartMedia Write Enable */
+#define AT91C_PIO_PC2		((unsigned int) 1 <<  2)	/* Pin Controlled by PC2 */
+#define AT91C_PC2_BFAVD		((unsigned int) AT91C_PIO_PC2)	/*  Burst Flash Address Valid */
+#define AT91C_PIO_PB1		((unsigned int) 1 <<  1)	/* Pin Controlled by PB1 */
+
+#define AT91C_PIO_PA23		((unsigned int) 1 << 23)	/* Pin Controlled by PA23 */
+#define AT91C_PA23_TXD2		((unsigned int) AT91C_PIO_PA23)	/* USART 2 Transmit Data */
+
+#define AT91C_PIO_PA0		((unsigned int) 1 <<  0)	/* Pin Controlled by PA0 */
+#define AT91C_PA0_MISO		((unsigned int) AT91C_PIO_PA0)	/* SPI Master In Slave */
+#define AT91C_PIO_PA1		((unsigned int) 1 <<  1)	/* Pin Controlled by PA1 */
+#define AT91C_PA1_MOSI		((unsigned int) AT91C_PIO_PA1)	/* SPI Master Out Slave */
+#define AT91C_PIO_PA2		((unsigned int) 1 <<  2)	/* Pin Controlled by PA2 */
+#define AT91C_PA2_SPCK		((unsigned int) AT91C_PIO_PA2)	/* SPI Serial Clock */
+#define AT91C_PIO_PA3		((unsigned int) 1 <<  3)	/* Pin Controlled by PA3 */
+#define AT91C_PA3_NPCS0		((unsigned int) AT91C_PIO_PA3)	/* SPI Peripheral Chip Select 0 */
+#define AT91C_PIO_PA4		((unsigned int) 1 <<  4)	/* Pin Controlled by PA4 */
+#define AT91C_PA4_NPCS1		((unsigned int) AT91C_PIO_PA4)	/* SPI Peripheral Chip Select 1 */
+#define AT91C_PIO_PA5		((unsigned int) 1 <<  5)	/* Pin Controlled by PA5 */
+#define AT91C_PA5_NPCS2		((unsigned int) AT91C_PIO_PA5)	/* SPI Peripheral Chip Select 2 */
+#define AT91C_PIO_PA6		((unsigned int) 1 <<  6)	/* Pin Controlled by PA6 */
+#define AT91C_PA6_NPCS3		((unsigned int) AT91C_PIO_PA6)	/* SPI Peripheral Chip Select 3 */
+
+#define AT91C_PIO_PA16		((unsigned int) 1 << 16)	/* Pin Controlled by PA16 */
+#define AT91C_PA16_EMDIO	((unsigned int) AT91C_PIO_PA16)	/* Ethernet MAC Management Data Input/Output */
+#define AT91C_PIO_PA15		((unsigned int) 1 << 15)	/* Pin Controlled by PA15 */
+#define AT91C_PA15_EMDC		((unsigned int) AT91C_PIO_PA15)	/* Ethernet MAC Management Data Clock */
+#define AT91C_PIO_PA14		((unsigned int) 1 << 14)	/* Pin Controlled by PA14 */
+#define AT91C_PA14_ERXER	((unsigned int) AT91C_PIO_PA14)	/* Ethernet MAC Receive Error */
+#define AT91C_PIO_PA13		((unsigned int) 1 << 13)	/* Pin Controlled by PA13 */
+#define AT91C_PA13_ERX1		((unsigned int) AT91C_PIO_PA13)	/* Ethernet MAC Receive Data 1 */
+#define AT91C_PIO_PA12		((unsigned int) 1 << 12)	/* Pin Controlled by PA12 */
+#define AT91C_PA12_ERX0		((unsigned int) AT91C_PIO_PA12)	/* Ethernet MAC Receive Data 0 */
+#define AT91C_PIO_PA11		((unsigned int) 1 << 11)	/* Pin Controlled by PA11 */
+#define AT91C_PA11_ECRS_ECRSDV	((unsigned int) AT91C_PIO_PA11)	/* Ethernet MAC Carrier Sense/Carrier Sense and Data Valid */
+#define AT91C_PIO_PA10		((unsigned int) 1 << 10)	/* Pin Controlled by PA10 */
+#define AT91C_PA10_ETX1		((unsigned int) AT91C_PIO_PA10)	/* Ethernet MAC Transmit Data 1 */
+#define AT91C_PIO_PA9		((unsigned int) 1 <<  9)	/* Pin Controlled by PA9 */
+#define AT91C_PA9_ETX0		((unsigned int) AT91C_PIO_PA9)	/* Ethernet MAC Transmit Data 0 */
+#define AT91C_PIO_PA8		((unsigned int) 1 <<  8)	/* Pin Controlled by PA8 */
+#define AT91C_PA8_ETXEN		((unsigned int) AT91C_PIO_PA8)	/* Ethernet MAC Transmit Enable */
+#define AT91C_PIO_PA7		((unsigned int) 1 <<  7)	/* Pin Controlled by PA7 */
+#define AT91C_PA7_ETXCK_EREFCK	((unsigned int) AT91C_PIO_PA7)	/* Ethernet MAC Transmit Clock/Reference Clock */
+
+#define AT91C_PIO_PB3		((unsigned int) 1 <<  3)	/* Pin Controlled by PB3 */
+#define AT91C_PIO_PB4		((unsigned int) 1 <<  4)	/* Pin Controlled by PB4 */
+#define AT91C_PIO_PB5		((unsigned int) 1 <<  5)	/* Pin Controlled by PB5 */
+#define AT91C_PIO_PB6		((unsigned int) 1 <<  6)	/* Pin Controlled by PB6 */
+#define AT91C_PIO_PB7		((unsigned int) 1 <<  7)	/* Pin Controlled by PB7 */
+#define AT91C_PIO_PB25		((unsigned int) 1 << 25)	/* Pin Controlled by PB25 */
+#define AT91C_PB25_DSR1		((unsigned int) AT91C_PIO_PB25)	/* USART 1 Data Set ready */
+#define AT91C_PB25_EF100	((unsigned int) AT91C_PIO_PB25)	/* Ethernet MAC Force 100 Mbits */
+#define AT91C_PIO_PB19		((unsigned int) 1 << 19)	/* Pin Controlled by PB19 */
+#define AT91C_PB19_DTR1		((unsigned int) AT91C_PIO_PB19)	/* USART 1 Data Terminal ready */
+#define AT91C_PB19_ERXCK	((unsigned int) AT91C_PIO_PB19)	/* Ethernet MAC Receive Clock */
+#define AT91C_PIO_PB18		((unsigned int) 1 << 18)	/* Pin Controlled by PB18 */
+#define AT91C_PB18_RI1		((unsigned int) AT91C_PIO_PB18)	/* USART 1 Ring Indicator */
+#define AT91C_PB18_ECOL		((unsigned int) AT91C_PIO_PB18)	/* Ethernet MAC Collision Detected */
+#define AT91C_PIO_PB17		((unsigned int) 1 << 17)	/* Pin Controlled by PB17 */
+#define AT91C_PB17_RF2		((unsigned int) AT91C_PIO_PB17)	/* SSC Receive Frame Sync 2 */
+#define AT91C_PB17_ERXDV	((unsigned int) AT91C_PIO_PB17)	/* Ethernet MAC Receive Data Valid */
+#define AT91C_PIO_PB16		((unsigned int) 1 << 16)	/* Pin Controlled by PB16 */
+#define AT91C_PB16_RK2		((unsigned int) AT91C_PIO_PB16)	/* SSC Receive Clock 2 */
+#define AT91C_PB16_ERX3		((unsigned int) AT91C_PIO_PB16)	/* Ethernet MAC Receive Data 3 */
+#define AT91C_PIO_PB15		((unsigned int) 1 << 15)	/* Pin Controlled by PB15 */
+#define AT91C_PB15_RD2		((unsigned int) AT91C_PIO_PB15)	/* SSC Receive Data 2 */
+#define AT91C_PB15_ERX2		((unsigned int) AT91C_PIO_PB15)	/* Ethernet MAC Receive Data 2 */
+#define AT91C_PIO_PB14		((unsigned int) 1 << 14)	/* Pin Controlled by PB14 */
+#define AT91C_PB14_TD2		((unsigned int) AT91C_PIO_PB14)	/* SSC Transmit Data 2 */
+#define AT91C_PB14_ETXER	((unsigned int) AT91C_PIO_PB14)	/* Ethernet MAC Transmikt Coding Error */
+#define AT91C_PIO_PB13		((unsigned int) 1 << 13)	/* Pin Controlled by PB13 */
+#define AT91C_PB13_TK2		((unsigned int) AT91C_PIO_PB13)	/* SSC Transmit Clock 2 */
+#define AT91C_PB13_ETX3		((unsigned int) AT91C_PIO_PB13)	/* Ethernet MAC Transmit Data 3 */
+#define AT91C_PIO_PB12		((unsigned int) 1 << 12)	/* Pin Controlled by PB12 */
+#define AT91C_PB12_TF2		((unsigned int) AT91C_PIO_PB12)	/* SSC Transmit Frame Sync 2 */
+#define AT91C_PB12_ETX2		((unsigned int) AT91C_PIO_PB12)	/* Ethernet MAC Transmit Data 2 */
+
+#define AT91C_PIOB_BSR		((AT91_REG *)	0xFFFFF674)	/* (PIOB) Select B Register */
+#define AT91C_PIOB_PDR		((AT91_REG *)	0xFFFFF604)	/* (PIOB) PIO Disable Register */
+
+#define AT91C_EBI_CS3A_SMC_SmartMedia	((unsigned int) 0x1 <<  3) /* (EBI) Chip Select 3 is assigned to the Static Memory Controller and the SmartMedia Logic is activated. */
+#define AT91C_SMC2_ACSS_STANDARD	((unsigned int) 0x0 << 16) /* (SMC2) Standard, asserted at the beginning of the access and deasserted at the end. */
+#define AT91C_SMC2_DBW_8	((unsigned int) 0x2 << 13) /* (SMC2) 8-bit. */
+#define AT91C_SMC2_WSEN		((unsigned int) 0x1 <<  7) /* (SMC2) Wait State Enable */
+#define AT91C_PIOC_ASR		((AT91_REG *)	0xFFFFF870) /* (PIOC) Select A Register */
+#define AT91C_PIOC_SODR		((AT91_REG *)	0xFFFFF830) /* (PIOC) Set Output Data Register */
+#define AT91C_PIOC_CODR		((AT91_REG *)	0xFFFFF834) /* (PIOC) Clear Output Data Register */
+#define AT91C_PIOC_PDSR		((AT91_REG *)	0xFFFFF83C) /* (PIOC) Pin Data Status Register */
+
+#define AT91C_BASE_SPI		((AT91PS_SPI)	0xFFFE0000) /* (SPI) Base Address */
+#define AT91C_BASE_EMAC		((AT91PS_EMAC)	0xFFFBC000) /* (EMAC) Base Address */
+#define AT91C_BASE_PMC		((AT91PS_PMC)	0xFFFFFC00) /* (PMC) Base Address */
+#define AT91C_BASE_TC0		((AT91PS_TC)	0xFFFA0000) /* (TC0) Base Address */
+#define AT91C_BASE_DBGU		((AT91PS_DBGU)	0xFFFFF200) /* (DBGU) Base Address */
+#define AT91C_BASE_CKGR		((AT91PS_CKGR)	0xFFFFFC20) /* (CKGR) Base Address */
+#define AT91C_BASE_PIOC		((AT91PS_PIO)	0xFFFFF800) /* (PIOC) Base Address */
+#define AT91C_BASE_PIOB		((AT91PS_PIO)	0xFFFFF600) /* (PIOB) Base Address */
+#define AT91C_BASE_PIOA		((AT91PS_PIO)	0xFFFFF400) /* (PIOA) Base Address */
+#define AT91C_EBI_CSA		((AT91_REG *)	0xFFFFFF60) /* (EBI) Chip Select Assignment Register */
+#define AT91C_BASE_SMC2		((AT91PS_SMC2)	0xFFFFFF70) /* (SMC2) Base Address */
+#define AT91C_BASE_US0		((AT91PS_USART)	0xFFFC0000) /* (US0) Base Address */
+#define AT91C_BASE_US1		((AT91PS_USART) 0xFFFC4000) /* (US1) Base Address */
+#define AT91C_TCB0_BMR		((AT91_REG *)	0xFFFA00C4) /* (TCB0) TC Block Mode Register */
+#define AT91C_TCB0_BCR		((AT91_REG *)	0xFFFA00C0) /* (TCB0) TC Block Control Register */
+#define AT91C_PIOC_PDR		((AT91_REG *)	0xFFFFF804) /* (PIOC) PIO Disable Register */
+#define AT91C_PIOC_PER		((AT91_REG *)	0xFFFFF800) /* (PIOC) PIO Enable Register */
+#define AT91C_PIOC_ODR  	((AT91_REG *)	0xFFFFF814) /* (PIOC) Output Disable Registerr */
+#define AT91C_PIOB_PER		((AT91_REG *)	0xFFFFF600) /* (PIOB) PIO Enable Register */
+#define AT91C_PIOB_ODR		((AT91_REG *)	0xFFFFF614) /* (PIOB) Output Disable Registerr */
+#define AT91C_PIOB_PDSR		((AT91_REG *)	0xFFFFF63C) /* (PIOB) Pin Data Status Register */
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch-at91rm9200/hardware.h u-boot-1.2.0-leopard/include/asm/arch-at91rm9200/hardware.h
--- u-boot-1.2.0/include/asm/arch-at91rm9200/hardware.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-at91rm9200/hardware.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,77 @@
+/*
+ * linux/include/asm-arm/arch-at91/hardware.h
+ *
+ *  Copyright (C) 2003 SAN People
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+
+#ifndef __ASSEMBLY__
+#include "AT91RM9200.h"
+#else
+#include "AT91RM9200_inc.h"
+#endif
+
+/* Virtual and Physical base address for system peripherals */
+#define AT91_SYS_BASE		0xFFFFF000 /*4K */
+
+/* Virtual and Physical base addresses of user peripherals */
+#define AT91_SPI_BASE		0xFFFE0000 /*16K */
+#define AT91_SSC2_BASE		0xFFFD8000 /*16K */
+#define AT91_SSC1_BASE		0xFFFD4000 /*16K */
+#define AT91_SSC0_BASE		0xFFFD0000 /*16K */
+#define AT91_USART3_BASE	0xFFFCC000 /*16K */
+#define AT91_USART2_BASE	0xFFFC8000 /*16K */
+#define AT91_USART1_BASE	0xFFFC4000 /*16K */
+#define AT91_USART0_BASE	0xFFFC0000 /*16K */
+#define AT91_EMAC_BASE		0xFFFBC000 /*16K */
+#define AT91_TWI_BASE		0xFFFB8000 /*16K */
+#define AT91_MCI_BASE		0xFFFB4000 /*16K */
+#define AT91_UDP_BASE		0xFFFB0000 /*16K */
+#define AT91_TCB1_BASE		0xFFFA4000 /*16K */
+#define AT91_TCB0_BASE		0xFFFA0000 /*16K */
+
+#define AT91_USB_HOST_BASE	0x00300000
+
+/*
+ * Where in virtual memory the IO devices (timers, system controllers
+ * and so on)
+ */
+#define AT91_IO_BASE		0xF0000000	/* Virt/Phys Address of IO */
+
+/* FLASH */
+#define AT91_FLASH_BASE		0x10000000	/* NCS0 */
+
+/* SDRAM */
+#define AT91_SDRAM_BASE		0x20000000	/* NCS1 */
+
+/* SmartMedia */
+#define AT91_SMARTMEDIA_BASE	0x40000000	/* NCS3 */
+
+/* Definition of interrupt priority levels */
+#define AT91C_AIC_PRIOR_0 AT91C_AIC_PRIOR_LOWEST
+#define AT91C_AIC_PRIOR_1 ((unsigned int) 0x1)
+#define AT91C_AIC_PRIOR_2 ((unsigned int) 0x2)
+#define AT91C_AIC_PRIOR_3 ((unsigned int) 0x3)
+#define AT91C_AIC_PRIOR_4 ((unsigned int) 0x4)
+#define AT91C_AIC_PRIOR_5 ((unsigned int) 0x5)
+#define AT91C_AIC_PRIOR_6 ((unsigned int) 0x6)
+#define AT91C_AIC_PRIOR_7 AT91C_AIC_PRIOR_HIGEST
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch-imx/imx-regs.h u-boot-1.2.0-leopard/include/asm/arch-imx/imx-regs.h
--- u-boot-1.2.0/include/asm/arch-imx/imx-regs.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-imx/imx-regs.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,577 @@
+#ifndef _IMX_REGS_H
+#define _IMX_REGS_H
+/* ------------------------------------------------------------------------
+ *  Motorola IMX system registers
+ * ------------------------------------------------------------------------
+ *
+ */
+
+# ifndef __ASSEMBLY__
+#  define __REG(x)	(*((volatile u32 *)(x)))
+# define __REG2(x,y)	\
+	( __builtin_constant_p(y) ? (__REG((x) + (y))) \
+			  : (*(volatile u32 *)((u32)&__REG(x) + (y))) )
+# else
+#  define __REG(x) (x)
+#  define __REG2(x,y) ((x)+(y))
+#endif
+
+#define IMX_IO_BASE		0x00200000
+
+/*
+ *  Register BASEs, based on OFFSETs
+ *
+ */
+#define IMX_AIPI1_BASE             (0x00000 + IMX_IO_BASE)
+#define IMX_WDT_BASE               (0x01000 + IMX_IO_BASE)
+#define IMX_TIM1_BASE              (0x02000 + IMX_IO_BASE)
+#define IMX_TIM2_BASE              (0x03000 + IMX_IO_BASE)
+#define IMX_RTC_BASE               (0x04000 + IMX_IO_BASE)
+#define IMX_LCDC_BASE              (0x05000 + IMX_IO_BASE)
+#define IMX_UART1_BASE             (0x06000 + IMX_IO_BASE)
+#define IMX_UART2_BASE             (0x07000 + IMX_IO_BASE)
+#define IMX_PWM_BASE               (0x08000 + IMX_IO_BASE)
+#define IMX_DMAC_BASE              (0x09000 + IMX_IO_BASE)
+#define IMX_AIPI2_BASE             (0x10000 + IMX_IO_BASE)
+#define IMX_SIM_BASE               (0x11000 + IMX_IO_BASE)
+#define IMX_USBD_BASE              (0x12000 + IMX_IO_BASE)
+#define IMX_SPI1_BASE              (0x13000 + IMX_IO_BASE)
+#define IMX_MMC_BASE               (0x14000 + IMX_IO_BASE)
+#define IMX_ASP_BASE               (0x15000 + IMX_IO_BASE)
+#define IMX_BTA_BASE               (0x16000 + IMX_IO_BASE)
+#define IMX_I2C_BASE               (0x17000 + IMX_IO_BASE)
+#define IMX_SSI_BASE               (0x18000 + IMX_IO_BASE)
+#define IMX_SPI2_BASE              (0x19000 + IMX_IO_BASE)
+#define IMX_MSHC_BASE              (0x1A000 + IMX_IO_BASE)
+#define IMX_PLL_BASE               (0x1B000 + IMX_IO_BASE)
+#define IMX_SYSCTRL_BASE           (0x1B800 + IMX_IO_BASE)
+#define IMX_GPIO_BASE              (0x1C000 + IMX_IO_BASE)
+#define IMX_EIM_BASE               (0x20000 + IMX_IO_BASE)
+#define IMX_SDRAMC_BASE            (0x21000 + IMX_IO_BASE)
+#define IMX_MMA_BASE               (0x22000 + IMX_IO_BASE)
+#define IMX_AITC_BASE              (0x23000 + IMX_IO_BASE)
+#define IMX_CSI_BASE               (0x24000 + IMX_IO_BASE)
+
+/* Watchdog Registers*/
+
+#define WCR  __REG(IMX_WDT_BASE + 0x00) /* Watchdog Control Register */
+#define WSR  __REG(IMX_WDT_BASE + 0x04) /* Watchdog Service Register */
+#define WSTR __REG(IMX_WDT_BASE + 0x08) /* Watchdog Status Register  */
+
+/* SYSCTRL Registers */
+#define SIDR   __REG(IMX_SYSCTRL_BASE + 0x4) /* Silicon ID Register		    */
+#define FMCR   __REG(IMX_SYSCTRL_BASE + 0x8) /* Function Multiplex Control Register */
+#define GPCR   __REG(IMX_SYSCTRL_BASE + 0xC) /* Function Multiplex Control Register */
+
+/* Chip Select Registers */
+#define CS0U __REG(IMX_EIM_BASE)        /* Chip Select 0 Upper Register */
+#define CS0L __REG(IMX_EIM_BASE + 0x4)  /* Chip Select 0 Lower Register */
+#define CS1U __REG(IMX_EIM_BASE + 0x8)  /* Chip Select 1 Upper Register */
+#define CS1L __REG(IMX_EIM_BASE + 0xc)  /* Chip Select 1 Lower Register */
+#define CS2U __REG(IMX_EIM_BASE + 0x10) /* Chip Select 2 Upper Register */
+#define CS2L __REG(IMX_EIM_BASE + 0x14) /* Chip Select 2 Lower Register */
+#define CS3U __REG(IMX_EIM_BASE + 0x18) /* Chip Select 3 Upper Register */
+#define CS3L __REG(IMX_EIM_BASE + 0x1c) /* Chip Select 3 Lower Register */
+#define CS4U __REG(IMX_EIM_BASE + 0x20) /* Chip Select 4 Upper Register */
+#define CS4L __REG(IMX_EIM_BASE + 0x24) /* Chip Select 4 Lower Register */
+#define CS5U __REG(IMX_EIM_BASE + 0x28) /* Chip Select 5 Upper Register */
+#define CS5L __REG(IMX_EIM_BASE + 0x2c) /* Chip Select 5 Lower Register */
+#define EIM  __REG(IMX_EIM_BASE + 0x30) /* EIM Configuration Register */
+
+/* SDRAM controller registers */
+
+#define SDCTL0 __REG(IMX_SDRAMC_BASE)        /* SDRAM 0 Control Register */
+#define SDCTL1 __REG(IMX_SDRAMC_BASE + 0x4)  /* SDRAM 1 Control Register */
+#define SDMISC __REG(IMX_SDRAMC_BASE + 0x14) /* Miscellaneous Register */
+#define SDRST  __REG(IMX_SDRAMC_BASE + 0x18) /* SDRAM Reset Register */
+
+/* PLL registers */
+#define CSCR   __REG(IMX_PLL_BASE)        /* Clock Source Control Register */
+#define MPCTL0 __REG(IMX_PLL_BASE + 0x4)  /* MCU PLL Control Register 0 */
+#define MPCTL1 __REG(IMX_PLL_BASE + 0x8)  /* MCU PLL and System Clock Register 1 */
+#define SPCTL0 __REG(IMX_PLL_BASE + 0xc)  /* System PLL Control Register 0 */
+#define SPCTL1 __REG(IMX_PLL_BASE + 0x10) /* System PLL Control Register 1 */
+#define PCDR   __REG(IMX_PLL_BASE + 0x20) /* Peripheral Clock Divider Register */
+
+#define CSCR_MPLL_RESTART (1<<21)
+
+/*
+ *  GPIO Module and I/O Multiplexer
+ *  x = 0..3 for reg_A, reg_B, reg_C, reg_D
+ */
+#define DDIR(x)    __REG2(IMX_GPIO_BASE + 0x00, ((x) & 3) << 8)
+#define OCR1(x)    __REG2(IMX_GPIO_BASE + 0x04, ((x) & 3) << 8)
+#define OCR2(x)    __REG2(IMX_GPIO_BASE + 0x08, ((x) & 3) << 8)
+#define ICONFA1(x) __REG2(IMX_GPIO_BASE + 0x0c, ((x) & 3) << 8)
+#define ICONFA2(x) __REG2(IMX_GPIO_BASE + 0x10, ((x) & 3) << 8)
+#define ICONFB1(x) __REG2(IMX_GPIO_BASE + 0x14, ((x) & 3) << 8)
+#define ICONFB2(x) __REG2(IMX_GPIO_BASE + 0x18, ((x) & 3) << 8)
+#define DR(x)      __REG2(IMX_GPIO_BASE + 0x1c, ((x) & 3) << 8)
+#define GIUS(x)    __REG2(IMX_GPIO_BASE + 0x20, ((x) & 3) << 8)
+#define SSR(x)     __REG2(IMX_GPIO_BASE + 0x24, ((x) & 3) << 8)
+#define ICR1(x)    __REG2(IMX_GPIO_BASE + 0x28, ((x) & 3) << 8)
+#define ICR2(x)    __REG2(IMX_GPIO_BASE + 0x2c, ((x) & 3) << 8)
+#define IMR(x)     __REG2(IMX_GPIO_BASE + 0x30, ((x) & 3) << 8)
+#define ISR(x)     __REG2(IMX_GPIO_BASE + 0x34, ((x) & 3) << 8)
+#define GPR(x)     __REG2(IMX_GPIO_BASE + 0x38, ((x) & 3) << 8)
+#define SWR(x)     __REG2(IMX_GPIO_BASE + 0x3c, ((x) & 3) << 8)
+#define PUEN(x)    __REG2(IMX_GPIO_BASE + 0x40, ((x) & 3) << 8)
+
+#define GPIO_PIN_MASK 0x1f
+#define GPIO_PORT_MASK (0x3 << 5)
+
+#define GPIO_PORTA (0<<5)
+#define GPIO_PORTB (1<<5)
+#define GPIO_PORTC (2<<5)
+#define GPIO_PORTD (3<<5)
+
+#define GPIO_OUT   (1<<7)
+#define GPIO_IN    (0<<7)
+#define GPIO_PUEN  (1<<8)
+
+#define GPIO_PF    (0<<9)
+#define GPIO_AF    (1<<9)
+
+#define GPIO_OCR_MASK (3<<10)
+#define GPIO_AIN   (0<<10)
+#define GPIO_BIN   (1<<10)
+#define GPIO_CIN   (2<<10)
+#define GPIO_GPIO  (3<<10)
+
+#define GPIO_AOUT  (1<<12)
+#define GPIO_BOUT  (1<<13)
+
+/* assignements for GPIO alternate/primary functions */
+
+/* FIXME: This list is not completed. The correct directions are
+ * missing on some (many) pins
+ */
+#define PA0_PF_A24           ( GPIO_PORTA | GPIO_PF | 0 )
+#define PA0_AIN_SPI2_CLK     ( GPIO_PORTA | GPIO_OUT | GPIO_AIN | 0 )
+#define PA0_AF_ETMTRACESYNC  ( GPIO_PORTA | GPIO_AF | 0 )
+#define PA1_AOUT_SPI2_RXD    ( GPIO_PORTA | GPIO_IN | GPIO_AOUT | 1 )
+#define PA1_PF_TIN           ( GPIO_PORTA | GPIO_PF | 1 )
+#define PA2_PF_PWM0          ( GPIO_PORTA | GPIO_OUT | GPIO_PF | 2 )
+#define PA3_PF_CSI_MCLK      ( GPIO_PORTA | GPIO_PF | 3 )
+#define PA4_PF_CSI_D0        ( GPIO_PORTA | GPIO_PF | 4 )
+#define PA5_PF_CSI_D1        ( GPIO_PORTA | GPIO_PF | 5 )
+#define PA6_PF_CSI_D2        ( GPIO_PORTA | GPIO_PF | 6 )
+#define PA7_PF_CSI_D3        ( GPIO_PORTA | GPIO_PF | 7 )
+#define PA8_PF_CSI_D4        ( GPIO_PORTA | GPIO_PF | 8 )
+#define PA9_PF_CSI_D5        ( GPIO_PORTA | GPIO_PF | 9 )
+#define PA10_PF_CSI_D6       ( GPIO_PORTA | GPIO_PF | 10 )
+#define PA11_PF_CSI_D7       ( GPIO_PORTA | GPIO_PF | 11 )
+#define PA12_PF_CSI_VSYNC    ( GPIO_PORTA | GPIO_PF | 12 )
+#define PA13_PF_CSI_HSYNC    ( GPIO_PORTA | GPIO_PF | 13 )
+#define PA14_PF_CSI_PIXCLK   ( GPIO_PORTA | GPIO_PF | 14 )
+#define PA15_PF_I2C_SDA      ( GPIO_PORTA | GPIO_OUT | GPIO_PF | 15 )
+#define PA16_PF_I2C_SCL      ( GPIO_PORTA | GPIO_OUT | GPIO_PF | 16 )
+#define PA17_AF_ETMTRACEPKT4 ( GPIO_PORTA | GPIO_AF | 17 )
+#define PA17_AIN_SPI2_SS     ( GPIO_PORTA | GPIO_AIN | 17 )
+#define PA18_AF_ETMTRACEPKT5 ( GPIO_PORTA | GPIO_AF | 18 )
+#define PA19_AF_ETMTRACEPKT6 ( GPIO_PORTA | GPIO_AF | 19 )
+#define PA20_AF_ETMTRACEPKT7 ( GPIO_PORTA | GPIO_AF | 20 )
+#define PA21_PF_A0           ( GPIO_PORTA | GPIO_PF | 21 )
+#define PA22_PF_CS4          ( GPIO_PORTA | GPIO_PF | 22 )
+#define PA23_PF_CS5          ( GPIO_PORTA | GPIO_PF | 23 )
+#define PA24_PF_A16          ( GPIO_PORTA | GPIO_PF | 24 )
+#define PA24_AF_ETMTRACEPKT0 ( GPIO_PORTA | GPIO_AF | 24 )
+#define PA25_PF_A17          ( GPIO_PORTA | GPIO_PF | 25 )
+#define PA25_AF_ETMTRACEPKT1 ( GPIO_PORTA | GPIO_AF | 25 )
+#define PA26_PF_A18          ( GPIO_PORTA | GPIO_PF | 26 )
+#define PA26_AF_ETMTRACEPKT2 ( GPIO_PORTA | GPIO_AF | 26 )
+#define PA27_PF_A19          ( GPIO_PORTA | GPIO_PF | 27 )
+#define PA27_AF_ETMTRACEPKT3 ( GPIO_PORTA | GPIO_AF | 27 )
+#define PA28_PF_A20          ( GPIO_PORTA | GPIO_PF | 28 )
+#define PA28_AF_ETMPIPESTAT0 ( GPIO_PORTA | GPIO_AF | 28 )
+#define PA29_PF_A21          ( GPIO_PORTA | GPIO_PF | 29 )
+#define PA29_AF_ETMPIPESTAT1 ( GPIO_PORTA | GPIO_AF | 29 )
+#define PA30_PF_A22          ( GPIO_PORTA | GPIO_PF | 30 )
+#define PA30_AF_ETMPIPESTAT2 ( GPIO_PORTA | GPIO_AF | 30 )
+#define PA31_PF_A23          ( GPIO_PORTA | GPIO_PF | 31 )
+#define PA31_AF_ETMTRACECLK  ( GPIO_PORTA | GPIO_AF | 31 )
+#define PB8_PF_SD_DAT0       ( GPIO_PORTB | GPIO_PF | GPIO_PUEN | 8 )
+#define PB8_AF_MS_PIO        ( GPIO_PORTB | GPIO_AF | 8 )
+#define PB9_PF_SD_DAT1       ( GPIO_PORTB | GPIO_PF | GPIO_PUEN  | 9 )
+#define PB9_AF_MS_PI1        ( GPIO_PORTB | GPIO_AF | 9 )
+#define PB10_PF_SD_DAT2      ( GPIO_PORTB | GPIO_PF | GPIO_PUEN  | 10 )
+#define PB10_AF_MS_SCLKI     ( GPIO_PORTB | GPIO_AF | 10 )
+#define PB11_PF_SD_DAT3      ( GPIO_PORTB | GPIO_PF | GPIO_PUEN  | 11 )
+#define PB11_AF_MS_SDIO      ( GPIO_PORTB | GPIO_AF | 11 )
+#define PB12_PF_SD_CLK       ( GPIO_PORTB | GPIO_PF | GPIO_OUT | 12 )
+#define PB12_AF_MS_SCLK0     ( GPIO_PORTB | GPIO_AF | 12 )
+#define PB13_PF_SD_CMD       ( GPIO_PORTB | GPIO_PF | GPIO_OUT | GPIO_PUEN | 13 )
+#define PB13_AF_MS_BS        ( GPIO_PORTB | GPIO_AF | 13 )
+#define PB14_AF_SSI_RXFS     ( GPIO_PORTB | GPIO_AF | 14 )
+#define PB15_AF_SSI_RXCLK    ( GPIO_PORTB | GPIO_AF | 15 )
+#define PB16_AF_SSI_RXDAT    ( GPIO_PORTB | GPIO_IN | GPIO_AF | 16 )
+#define PB17_AF_SSI_TXDAT    ( GPIO_PORTB | GPIO_OUT | GPIO_AF | 17 )
+#define PB18_AF_SSI_TXFS     ( GPIO_PORTB | GPIO_AF | 18 )
+#define PB19_AF_SSI_TXCLK    ( GPIO_PORTB | GPIO_AF | 19 )
+#define PB20_PF_USBD_AFE     ( GPIO_PORTB | GPIO_PF | 20 )
+#define PB21_PF_USBD_OE      ( GPIO_PORTB | GPIO_PF | 21 )
+#define PB22_PFUSBD_RCV      ( GPIO_PORTB | GPIO_PF | 22 )
+#define PB23_PF_USBD_SUSPND  ( GPIO_PORTB | GPIO_PF | 23 )
+#define PB24_PF_USBD_VP      ( GPIO_PORTB | GPIO_PF | 24 )
+#define PB25_PF_USBD_VM      ( GPIO_PORTB | GPIO_PF | 25 )
+#define PB26_PF_USBD_VPO     ( GPIO_PORTB | GPIO_PF | 26 )
+#define PB27_PF_USBD_VMO     ( GPIO_PORTB | GPIO_PF | 27 )
+#define PB28_PF_UART2_CTS    ( GPIO_PORTB | GPIO_OUT | GPIO_PF | 28 )
+#define PB29_PF_UART2_RTS    ( GPIO_PORTB | GPIO_IN | GPIO_PF | 29 )
+#define PB30_PF_UART2_TXD    ( GPIO_PORTB | GPIO_OUT | GPIO_PF | 30 )
+#define PB31_PF_UART2_RXD    ( GPIO_PORTB | GPIO_IN | GPIO_PF | 31 )
+#define PC3_PF_SSI_RXFS      ( GPIO_PORTC | GPIO_PF | 3 )
+#define PC4_PF_SSI_RXCLK     ( GPIO_PORTC | GPIO_PF | 4 )
+#define PC5_PF_SSI_RXDAT     ( GPIO_PORTC | GPIO_IN | GPIO_PF | 5 )
+#define PC6_PF_SSI_TXDAT     ( GPIO_PORTC | GPIO_OUT | GPIO_PF | 6 )
+#define PC7_PF_SSI_TXFS      ( GPIO_PORTC | GPIO_PF | 7 )
+#define PC8_PF_SSI_TXCLK     ( GPIO_PORTC | GPIO_PF | 8 )
+#define PC9_PF_UART1_CTS     ( GPIO_PORTC | GPIO_OUT | GPIO_PF | 9 )
+#define PC10_PF_UART1_RTS    ( GPIO_PORTC | GPIO_IN | GPIO_PF | 10 )
+#define PC11_PF_UART1_TXD    ( GPIO_PORTC | GPIO_OUT | GPIO_PF | 11 )
+#define PC12_PF_UART1_RXD    ( GPIO_PORTC | GPIO_IN | GPIO_PF | 12 )
+#define PC13_PF_SPI1_SPI_RDY ( GPIO_PORTC | GPIO_PF | 13 )
+#define PC14_PF_SPI1_SCLK    ( GPIO_PORTC | GPIO_PF | 14 )
+#define PC15_PF_SPI1_SS      ( GPIO_PORTC | GPIO_PF | 15 )
+#define PC16_PF_SPI1_MISO    ( GPIO_PORTC | GPIO_PF | 16 )
+#define PC17_PF_SPI1_MOSI    ( GPIO_PORTC | GPIO_PF | 17 )
+#define PD6_PF_LSCLK         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 6 )
+#define PD7_PF_REV           ( GPIO_PORTD | GPIO_PF | 7 )
+#define PD7_AF_UART2_DTR     ( GPIO_PORTD | GPIO_IN | GPIO_AF | 7 )
+#define PD7_AIN_SPI2_SCLK    ( GPIO_PORTD | GPIO_AIN | 7 )
+#define PD8_PF_CLS           ( GPIO_PORTD | GPIO_PF | 8 )
+#define PD8_AF_UART2_DCD     ( GPIO_PORTD | GPIO_OUT | GPIO_AF | 8 )
+#define PD8_AIN_SPI2_SS      ( GPIO_PORTD | GPIO_AIN | 8 )
+#define PD9_PF_PS            ( GPIO_PORTD | GPIO_PF | 9 )
+#define PD9_AF_UART2_RI      ( GPIO_PORTD | GPIO_OUT | GPIO_AF | 9 )
+#define PD9_AOUT_SPI2_RXD    ( GPIO_PORTD | GPIO_IN | GPIO_AOUT | 9 )
+#define PD10_PF_SPL_SPR      ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 10 )
+#define PD10_AF_UART2_DSR    ( GPIO_PORTD | GPIO_OUT | GPIO_AF | 10 )
+#define PD10_AIN_SPI2_TXD    ( GPIO_PORTD | GPIO_OUT | GPIO_AIN | 10 )
+#define PD11_PF_CONTRAST     ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 11 )
+#define PD12_PF_ACD_OE       ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 12 )
+#define PD13_PF_LP_HSYNC     ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 13 )
+#define PD14_PF_FLM_VSYNC    ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 14 )
+#define PD15_PF_LD0          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 15 )
+#define PD16_PF_LD1          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 16 )
+#define PD17_PF_LD2          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 17 )
+#define PD18_PF_LD3          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 18 )
+#define PD19_PF_LD4          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 19 )
+#define PD20_PF_LD5          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 20 )
+#define PD21_PF_LD6          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 21 )
+#define PD22_PF_LD7          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 22 )
+#define PD23_PF_LD8          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 23 )
+#define PD24_PF_LD9          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 24 )
+#define PD25_PF_LD10         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 25 )
+#define PD26_PF_LD11         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 26 )
+#define PD27_PF_LD12         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 27 )
+#define PD28_PF_LD13         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 28 )
+#define PD29_PF_LD14         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 29 )
+#define PD30_PF_LD15         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 30 )
+#define PD31_PF_TMR2OUT      ( GPIO_PORTD | GPIO_PF | 31 )
+#define PD31_BIN_SPI2_TXD    ( GPIO_PORTD | GPIO_BIN | 31 )
+
+/*
+ *  DMA Controller
+ */
+#define DCR     __REG(IMX_DMAC_BASE +0x00)	/* DMA Control Register */
+#define DISR    __REG(IMX_DMAC_BASE +0x04)	/* DMA Interrupt status Register */
+#define DIMR    __REG(IMX_DMAC_BASE +0x08)	/* DMA Interrupt mask Register */
+#define DBTOSR  __REG(IMX_DMAC_BASE +0x0c)	/* DMA Burst timeout status Register */
+#define DRTOSR  __REG(IMX_DMAC_BASE +0x10)	/* DMA Request timeout Register */
+#define DSESR   __REG(IMX_DMAC_BASE +0x14)	/* DMA Transfer Error Status Register */
+#define DBOSR   __REG(IMX_DMAC_BASE +0x18)	/* DMA Buffer overflow status Register */
+#define DBTOCR  __REG(IMX_DMAC_BASE +0x1c)	/* DMA Burst timeout control Register */
+#define WSRA    __REG(IMX_DMAC_BASE +0x40)	/* W-Size Register A */
+#define XSRA    __REG(IMX_DMAC_BASE +0x44)	/* X-Size Register A */
+#define YSRA    __REG(IMX_DMAC_BASE +0x48)	/* Y-Size Register A */
+#define WSRB    __REG(IMX_DMAC_BASE +0x4c)	/* W-Size Register B */
+#define XSRB    __REG(IMX_DMAC_BASE +0x50)	/* X-Size Register B */
+#define YSRB    __REG(IMX_DMAC_BASE +0x54)	/* Y-Size Register B */
+#define SAR(x)  __REG2( IMX_DMAC_BASE + 0x80, (x) << 6)	/* Source Address Registers */
+#define DAR(x)  __REG2( IMX_DMAC_BASE + 0x84, (x) << 6)	/* Destination Address Registers */
+#define CNTR(x) __REG2( IMX_DMAC_BASE + 0x88, (x) << 6)	/* Count Registers */
+#define CCR(x)  __REG2( IMX_DMAC_BASE + 0x8c, (x) << 6)	/*Control Registers */
+#define RSSR(x) __REG2( IMX_DMAC_BASE + 0x90, (x) << 6)	/* Request source select Registers */
+#define BLR(x)  __REG2( IMX_DMAC_BASE + 0x94, (x) << 6)	/* Burst length Registers */
+#define RTOR(x) __REG2( IMX_DMAC_BASE + 0x98, (x) << 6)	/* Request timeout Registers */
+#define BUCR(x) __REG2( IMX_DMAC_BASE + 0x98, (x) << 6)	/* Bus Utilization Registers */
+
+/* TODO: define DMA_REQ lines */
+
+#define DCR_DRST           (1<<1)
+#define DCR_DEN            (1<<0)
+#define DBTOCR_EN          (1<<15)
+#define DBTOCR_CNT(x)      ((x) & 0x7fff )
+#define CNTR_CNT(x)        ((x) & 0xffffff )
+#define CCR_DMOD_LINEAR    ( 0x0 << 12 )
+#define CCR_DMOD_2D        ( 0x1 << 12 )
+#define CCR_DMOD_FIFO      ( 0x2 << 12 )
+#define CCR_DMOD_EOBFIFO   ( 0x3 << 12 )
+#define CCR_SMOD_LINEAR    ( 0x0 << 10 )
+#define CCR_SMOD_2D        ( 0x1 << 10 )
+#define CCR_SMOD_FIFO      ( 0x2 << 10 )
+#define CCR_SMOD_EOBFIFO   ( 0x3 << 10 )
+#define CCR_MDIR_DEC       (1<<9)
+#define CCR_MSEL_B         (1<<8)
+#define CCR_DSIZ_32        ( 0x0 << 6 )
+#define CCR_DSIZ_8         ( 0x1 << 6 )
+#define CCR_DSIZ_16        ( 0x2 << 6 )
+#define CCR_SSIZ_32        ( 0x0 << 4 )
+#define CCR_SSIZ_8         ( 0x1 << 4 )
+#define CCR_SSIZ_16        ( 0x2 << 4 )
+#define CCR_REN            (1<<3)
+#define CCR_RPT            (1<<2)
+#define CCR_FRC            (1<<1)
+#define CCR_CEN            (1<<0)
+#define RTOR_EN            (1<<15)
+#define RTOR_CLK           (1<<14)
+#define RTOR_PSC           (1<<13)
+
+/*
+ * LCD Controller
+ */
+
+#define LCDC_SSA	__REG(IMX_LCDC_BASE+0x00)
+
+#define LCDC_SIZE	__REG(IMX_LCDC_BASE+0x04)
+#define SIZE_XMAX(x)	((((x) >> 4) & 0x3f) << 20)
+#define SIZE_YMAX(y)    ( (y) & 0x1ff )
+
+#define LCDC_VPW	__REG(IMX_LCDC_BASE+0x08)
+#define VPW_VPW(x)	( (x) & 0x3ff )
+
+#define LCDC_CPOS	__REG(IMX_LCDC_BASE+0x0C)
+#define CPOS_CC1        (1<<31)
+#define CPOS_CC0        (1<<30)
+#define CPOS_OP         (1<<28)
+#define CPOS_CXP(x)     (((x) & 3ff) << 16)
+#define CPOS_CYP(y)     ((y) & 0x1ff)
+
+#define LCDC_LCWHB	__REG(IMX_LCDC_BASE+0x10)
+#define LCWHB_BK_EN     (1<<31)
+#define LCWHB_CW(w)     (((w) & 0x1f) << 24)
+#define LCWHB_CH(h)     (((h) & 0x1f) << 16)
+#define LCWHB_BD(x)     ((x) & 0xff)
+
+#define LCDC_LCHCC	__REG(IMX_LCDC_BASE+0x14)
+#define LCHCC_CUR_COL_R(r) (((r) & 0x1f) << 11)
+#define LCHCC_CUR_COL_G(g) (((g) & 0x3f) << 5)
+#define LCHCC_CUR_COL_B(b) ((b) & 0x1f)
+
+#define LCDC_PCR	__REG(IMX_LCDC_BASE+0x18)
+#define PCR_TFT         (1<<31)
+#define PCR_COLOR       (1<<30)
+#define PCR_PBSIZ_1     (0<<28)
+#define PCR_PBSIZ_2     (1<<28)
+#define PCR_PBSIZ_4     (2<<28)
+#define PCR_PBSIZ_8     (3<<28)
+#define PCR_BPIX_1      (0<<25)
+#define PCR_BPIX_2      (1<<25)
+#define PCR_BPIX_4      (2<<25)
+#define PCR_BPIX_8      (3<<25)
+#define PCR_BPIX_12     (4<<25)
+#define PCR_BPIX_16     (4<<25)
+#define PCR_PIXPOL      (1<<24)
+#define PCR_FLMPOL      (1<<23)
+#define PCR_LPPOL       (1<<22)
+#define PCR_CLKPOL      (1<<21)
+#define PCR_OEPOL       (1<<20)
+#define PCR_SCLKIDLE    (1<<19)
+#define PCR_END_SEL     (1<<18)
+#define PCR_END_BYTE_SWAP (1<<17)
+#define PCR_REV_VS      (1<<16)
+#define PCR_ACD_SEL     (1<<15)
+#define PCR_ACD(x)      (((x) & 0x7f) << 8)
+#define PCR_SCLK_SEL    (1<<7)
+#define PCR_SHARP       (1<<6)
+#define PCR_PCD(x)      ((x) & 0x3f)
+
+#define LCDC_HCR	__REG(IMX_LCDC_BASE+0x1C)
+#define HCR_H_WIDTH(x)  (((x) & 0x3f) << 26)
+#define HCR_H_WAIT_1(x) (((x) & 0xff) << 8)
+#define HCR_H_WAIT_2(x) ((x) & 0xff)
+
+#define LCDC_VCR	__REG(IMX_LCDC_BASE+0x20)
+#define VCR_V_WIDTH(x)  (((x) & 0x3f) << 26)
+#define VCR_V_WAIT_1(x) (((x) & 0xff) << 8)
+#define VCR_V_WAIT_2(x) ((x) & 0xff)
+
+#define LCDC_POS	__REG(IMX_LCDC_BASE+0x24)
+#define POS_POS(x)      ((x) & 1f)
+
+#define LCDC_LSCR1	__REG(IMX_LCDC_BASE+0x28)
+#define LSCR1_GRAY1(x)  (((x) & 0xf) << 4)
+#define LSCR1_GRAY2(x)  ((x) & 0xf)
+
+#define LCDC_PWMR	__REG(IMX_LCDC_BASE+0x2C)
+#define PWMR_CLS(x)     (((x) & 0x1ff) << 16)
+#define PWMR_LDMSK      (1<<15)
+#define PWMR_SCR1       (1<<10)
+#define PWMR_SCR0       (1<<9)
+#define PWMR_CC_EN      (1<<8)
+#define PWMR_PW(x)      ((x) & 0xff)
+
+#define LCDC_DMACR	__REG(IMX_LCDC_BASE+0x30)
+#define DMACR_BURST     (1<<31)
+#define DMACR_HM(x)     (((x) & 0xf) << 16)
+#define DMACR_TM(x)     ((x) &0xf)
+
+#define LCDC_RMCR	__REG(IMX_LCDC_BASE+0x34)
+#define RMCR_LCDC_EN		(1<<1)
+#define RMCR_SELF_REF		(1<<0)
+
+#define LCDC_LCDICR	__REG(IMX_LCDC_BASE+0x38)
+#define LCDICR_INT_SYN  (1<<2)
+#define LCDICR_INT_CON  (1)
+
+#define LCDC_LCDISR	__REG(IMX_LCDC_BASE+0x40)
+#define LCDISR_UDR_ERR (1<<3)
+#define LCDISR_ERR_RES (1<<2)
+#define LCDISR_EOF     (1<<1)
+#define LCDISR_BOF     (1<<0)
+/*
+ *  UART Module
+ */
+#define URXD0(x) __REG2( IMX_UART1_BASE + 0x0, ((x) & 1) << 12)	/* Receiver Register */
+#define URTX0(x) __REG2( IMX_UART1_BASE + 0x40, ((x) & 1) << 12)	/* Transmitter Register */
+#define UCR1(x)  __REG2( IMX_UART1_BASE + 0x80, ((x) & 1) << 12)	/* Control Register 1 */
+#define UCR2(x)  __REG2( IMX_UART1_BASE + 0x84, ((x) & 1) << 12)	/* Control Register 2 */
+#define UCR3(x)  __REG2( IMX_UART1_BASE + 0x88, ((x) & 1) << 12)	/* Control Register 3 */
+#define UCR4(x)  __REG2( IMX_UART1_BASE + 0x8c, ((x) & 1) << 12)	/* Control Register 4 */
+#define UFCR(x)  __REG2( IMX_UART1_BASE + 0x90, ((x) & 1) << 12)	/* FIFO Control Register */
+#define USR1(x)  __REG2( IMX_UART1_BASE + 0x94, ((x) & 1) << 12)	/* Status Register 1 */
+#define USR2(x)  __REG2( IMX_UART1_BASE + 0x98, ((x) & 1) << 12)	/* Status Register 2 */
+#define UESC(x)  __REG2( IMX_UART1_BASE + 0x9c, ((x) & 1) << 12)	/* Escape Character Register */
+#define UTIM(x)  __REG2( IMX_UART1_BASE + 0xa0, ((x) & 1) << 12)	/* Escape Timer Register */
+#define UBIR(x)  __REG2( IMX_UART1_BASE + 0xa4, ((x) & 1) << 12)	/* BRM Incremental Register */
+#define UBMR(x)  __REG2( IMX_UART1_BASE + 0xa8, ((x) & 1) << 12)	/* BRM Modulator Register */
+#define UBRC(x)  __REG2( IMX_UART1_BASE + 0xac, ((x) & 1) << 12)	/* Baud Rate Count Register */
+#define BIPR1(x) __REG2( IMX_UART1_BASE + 0xb0, ((x) & 1) << 12)	/* Incremental Preset Register 1 */
+#define BIPR2(x) __REG2( IMX_UART1_BASE + 0xb4, ((x) & 1) << 12)	/* Incremental Preset Register 2 */
+#define BIPR3(x) __REG2( IMX_UART1_BASE + 0xb8, ((x) & 1) << 12)	/* Incremental Preset Register 3 */
+#define BIPR4(x) __REG2( IMX_UART1_BASE + 0xbc, ((x) & 1) << 12)	/* Incremental Preset Register 4 */
+#define BMPR1(x) __REG2( IMX_UART1_BASE + 0xc0, ((x) & 1) << 12)	/* BRM Modulator Register 1 */
+#define BMPR2(x) __REG2( IMX_UART1_BASE + 0xc4, ((x) & 1) << 12)	/* BRM Modulator Register 2 */
+#define BMPR3(x) __REG2( IMX_UART1_BASE + 0xc8, ((x) & 1) << 12)	/* BRM Modulator Register 3 */
+#define BMPR4(x) __REG2( IMX_UART1_BASE + 0xcc, ((x) & 1) << 12)	/* BRM Modulator Register 4 */
+#define UTS(x)   __REG2( IMX_UART1_BASE + 0xd0, ((x) & 1) << 12)	/* UART Test Register */
+
+/* UART Control Register Bit Fields.*/
+#define  URXD_CHARRDY    (1<<15)
+#define  URXD_ERR        (1<<14)
+#define  URXD_OVRRUN     (1<<13)
+#define  URXD_FRMERR     (1<<12)
+#define  URXD_BRK        (1<<11)
+#define  URXD_PRERR      (1<<10)
+#define  UCR1_ADEN       (1<<15) /* Auto dectect interrupt */
+#define  UCR1_ADBR       (1<<14) /* Auto detect baud rate */
+#define  UCR1_TRDYEN     (1<<13) /* Transmitter ready interrupt enable */
+#define  UCR1_IDEN       (1<<12) /* Idle condition interrupt */
+#define  UCR1_RRDYEN     (1<<9)	 /* Recv ready interrupt enable */
+#define  UCR1_RDMAEN     (1<<8)	 /* Recv ready DMA enable */
+#define  UCR1_IREN       (1<<7)	 /* Infrared interface enable */
+#define  UCR1_TXMPTYEN   (1<<6)	 /* Transimitter empty interrupt enable */
+#define  UCR1_RTSDEN     (1<<5)	 /* RTS delta interrupt enable */
+#define  UCR1_SNDBRK     (1<<4)	 /* Send break */
+#define  UCR1_TDMAEN     (1<<3)	 /* Transmitter ready DMA enable */
+#define  UCR1_UARTCLKEN  (1<<2)	 /* UART clock enabled */
+#define  UCR1_DOZE       (1<<1)	 /* Doze */
+#define  UCR1_UARTEN     (1<<0)	 /* UART enabled */
+#define  UCR2_ESCI     	 (1<<15) /* Escape seq interrupt enable */
+#define  UCR2_IRTS  	 (1<<14) /* Ignore RTS pin */
+#define  UCR2_CTSC  	 (1<<13) /* CTS pin control */
+#define  UCR2_CTS        (1<<12) /* Clear to send */
+#define  UCR2_ESCEN      (1<<11) /* Escape enable */
+#define  UCR2_PREN       (1<<8) /* Parity enable */
+#define  UCR2_PROE       (1<<7) /* Parity odd/even */
+#define  UCR2_STPB       (1<<6)	/* Stop */
+#define  UCR2_WS         (1<<5)	/* Word size */
+#define  UCR2_RTSEN      (1<<4)	/* Request to send interrupt enable */
+#define  UCR2_TXEN       (1<<2)	/* Transmitter enabled */
+#define  UCR2_RXEN       (1<<1)	/* Receiver enabled */
+#define  UCR2_SRST 	 (1<<0)	/* SW reset */
+#define  UCR3_DTREN 	 (1<<13) /* DTR interrupt enable */
+#define  UCR3_PARERREN   (1<<12) /* Parity enable */
+#define  UCR3_FRAERREN   (1<<11) /* Frame error interrupt enable */
+#define  UCR3_DSR        (1<<10) /* Data set ready */
+#define  UCR3_DCD        (1<<9)  /* Data carrier detect */
+#define  UCR3_RI         (1<<8)  /* Ring indicator */
+#define  UCR3_TIMEOUTEN  (1<<7)  /* Timeout interrupt enable */
+#define  UCR3_RXDSEN	 (1<<6)  /* Receive status interrupt enable */
+#define  UCR3_AIRINTEN   (1<<5)  /* Async IR wake interrupt enable */
+#define  UCR3_AWAKEN	 (1<<4)  /* Async wake interrupt enable */
+#define  UCR3_REF25 	 (1<<3)  /* Ref freq 25 MHz */
+#define  UCR3_REF30 	 (1<<2)  /* Ref Freq 30 MHz */
+#define  UCR3_INVT  	 (1<<1)  /* Inverted Infrared transmission */
+#define  UCR3_BPEN  	 (1<<0)  /* Preset registers enable */
+#define  UCR4_CTSTL_32   (32<<10) /* CTS trigger level (32 chars) */
+#define  UCR4_INVR  	 (1<<9)  /* Inverted infrared reception */
+#define  UCR4_ENIRI 	 (1<<8)  /* Serial infrared interrupt enable */
+#define  UCR4_WKEN  	 (1<<7)  /* Wake interrupt enable */
+#define  UCR4_REF16 	 (1<<6)  /* Ref freq 16 MHz */
+#define  UCR4_IRSC  	 (1<<5) /* IR special case */
+#define  UCR4_TCEN  	 (1<<3) /* Transmit complete interrupt enable */
+#define  UCR4_BKEN  	 (1<<2) /* Break condition interrupt enable */
+#define  UCR4_OREN  	 (1<<1) /* Receiver overrun interrupt enable */
+#define  UCR4_DREN  	 (1<<0) /* Recv data ready interrupt enable */
+#define  UFCR_RXTL_SHF   0      /* Receiver trigger level shift */
+#define  UFCR_RFDIV      (7<<7) /* Reference freq divider mask */
+#define  UFCR_TXTL_SHF   10     /* Transmitter trigger level shift */
+#define  USR1_PARITYERR  (1<<15) /* Parity error interrupt flag */
+#define  USR1_RTSS  	 (1<<14) /* RTS pin status */
+#define  USR1_TRDY  	 (1<<13) /* Transmitter ready interrupt/dma flag */
+#define  USR1_RTSD  	 (1<<12) /* RTS delta */
+#define  USR1_ESCF  	 (1<<11) /* Escape seq interrupt flag */
+#define  USR1_FRAMERR    (1<<10) /* Frame error interrupt flag */
+#define  USR1_RRDY       (1<<9)	/* Receiver ready interrupt/dma flag */
+#define  USR1_TIMEOUT    (1<<7)	/* Receive timeout interrupt status */
+#define  USR1_RXDS  	 (1<<6)	/* Receiver idle interrupt flag */
+#define  USR1_AIRINT	 (1<<5)	/* Async IR wake interrupt flag */
+#define  USR1_AWAKE 	 (1<<4)	/* Aysnc wake interrupt flag */
+#define  USR2_ADET  	 (1<<15) /* Auto baud rate detect complete */
+#define  USR2_TXFE  	 (1<<14) /* Transmit buffer FIFO empty */
+#define  USR2_DTRF  	 (1<<13) /* DTR edge interrupt flag */
+#define  USR2_IDLE  	 (1<<12) /* Idle condition */
+#define  USR2_IRINT 	 (1<<8)	/* Serial infrared interrupt flag */
+#define  USR2_WAKE  	 (1<<7)	/* Wake */
+#define  USR2_RTSF  	 (1<<4)	/* RTS edge interrupt flag */
+#define  USR2_TXDC  	 (1<<3)	/* Transmitter complete */
+#define  USR2_BRCD  	 (1<<2)	/* Break condition */
+#define  USR2_ORE        (1<<1)	/* Overrun error */
+#define  USR2_RDR        (1<<0)	/* Recv data ready */
+#define  UTS_FRCPERR	 (1<<13) /* Force parity error */
+#define  UTS_LOOP        (1<<12) /* Loop tx and rx */
+#define  UTS_TXEMPTY	 (1<<6)	/* TxFIFO empty */
+#define  UTS_RXEMPTY	 (1<<5)	/* RxFIFO empty */
+#define  UTS_TXFULL 	 (1<<4)	/* TxFIFO full */
+#define  UTS_RXFULL 	 (1<<3)	/* RxFIFO full */
+#define  UTS_SOFTRST	 (1<<0)	/* Software reset */
+
+/* General purpose timers registers */
+#define TCTL1   __REG(IMX_TIM1_BASE)
+#define TPRER1  __REG(IMX_TIM1_BASE + 0x4)
+#define TCMP1   __REG(IMX_TIM1_BASE + 0x8)
+#define TCR1    __REG(IMX_TIM1_BASE + 0xc)
+#define TCN1    __REG(IMX_TIM1_BASE + 0x10)
+#define TSTAT1  __REG(IMX_TIM1_BASE + 0x14)
+#define TCTL2   __REG(IMX_TIM2_BASE)
+#define TPRER2  __REG(IMX_TIM2_BASE + 0x4)
+#define TCMP2   __REG(IMX_TIM2_BASE + 0x8)
+#define TCR2    __REG(IMX_TIM2_BASE + 0xc)
+#define TCN2    __REG(IMX_TIM2_BASE + 0x10)
+#define TSTAT2  __REG(IMX_TIM2_BASE + 0x14)
+
+/* General purpose timers bitfields */
+#define TCTL_SWR       (1<<15) /* Software reset */
+#define TCTL_FRR       (1<<8)  /* Freerun / restart */
+#define TCTL_CAP       (3<<6)  /* Capture Edge */
+#define TCTL_OM        (1<<5)  /* output mode */
+#define TCTL_IRQEN     (1<<4)  /* interrupt enable */
+#define TCTL_CLKSOURCE (7<<1)  /* Clock source */
+#define TCTL_TEN       (1)     /* Timer enable */
+#define TPRER_PRES     (0xff)  /* Prescale */
+#define TSTAT_CAPT     (1<<1)  /* Capture event */
+#define TSTAT_COMP     (1)     /* Compare event */
+
+#endif				/* _IMX_REGS_H */
diff -Nurd u-boot-1.2.0/include/asm/arch-ixp/ixp425.h u-boot-1.2.0-leopard/include/asm/arch-ixp/ixp425.h
--- u-boot-1.2.0/include/asm/arch-ixp/ixp425.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-ixp/ixp425.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,543 @@
+/*
+ * include/asm-arm/arch-ixp425/ixp425.h
+ *
+ * Register definitions for IXP425
+ *
+ * Copyright (C) 2002 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef _ASM_ARM_IXP425_H_
+#define _ASM_ARM_IXP425_H_
+
+#define BIT(x)	(1<<(x))
+
+/* FIXME: Only this does work for u-boot... find out why... [RS] */
+#define UBOOT_REG_FIX 1
+#ifdef UBOOT_REG_FIX
+# undef	io_p2v
+# undef __REG
+# ifndef __ASSEMBLY__
+#  define io_p2v(PhAdd)    (PhAdd)
+#  define __REG(x)	(*((volatile u32 *)io_p2v(x)))
+#  define __REG2(x,y)	(*(volatile u32 *)((u32)&__REG(x) + (y)))
+# else
+#  define __REG(x) (x)
+# endif
+#endif /* UBOOT_REG_FIX */
+
+/*
+ *
+ * IXP425 Memory map:
+ *
+ * Phy		Phy Size	Map Size	Virt		Description
+ * =========================================================================
+ *
+ * 0x00000000	0x10000000					SDRAM 1
+ *
+ * 0x10000000	0x10000000					SDRAM 2
+ *
+ * 0x20000000	0x10000000					SDRAM 3
+ *
+ * 0x30000000	0x10000000					SDRAM 4
+ *
+ * The above four are aliases to the same memory location  (0x00000000)
+ *
+ * 0x48000000	 0x4000000					PCI Memory
+ *
+ * 0x50000000	0x10000000			Not Mapped	EXP BUS
+ *
+ * 0x6000000	0x00004000	    0x4000	0xFFFEB000	QMgr
+ *
+ * 0xC0000000	     0x100   	    0x1000	0xFFFDD000	PCI CFG
+ *
+ * 0xC4000000	     0x100          0x1000	0xFFFDE000	EXP CFG
+ *
+ * 0xC8000000	    0xC000          0xC000	0xFFFDF000	PERIPHERAL
+ *
+ * 0xCC000000	     0x100   	    0x1000	Not Mapped	SDRAM CFG
+ */
+
+/*
+ * SDRAM
+ */
+#define IXP425_SDRAM_BASE		(0x00000000)
+#define IXP425_SDRAM_BASE_ALT		(0x10000000)
+
+
+/*
+ * PCI Configuration space
+ */
+#define IXP425_PCI_CFG_BASE_PHYS	(0xC0000000)
+#define IXP425_PCI_CFG_REGION_SIZE	(0x00001000)
+
+/*
+ * Expansion BUS Configuration registers
+ */
+#define IXP425_EXP_CFG_BASE_PHYS	(0xC4000000)
+#define IXP425_EXP_CFG_REGION_SIZE	(0x00001000)
+
+/*
+ * Peripheral space
+ */
+#define IXP425_PERIPHERAL_BASE_PHYS	(0xC8000000)
+#define IXP425_PERIPHERAL_REGION_SIZE	(0x0000C000)
+
+/*
+ * SDRAM configuration registers
+ */
+#define IXP425_SDRAM_CFG_BASE_PHYS	(0xCC000000)
+
+/*
+ * Q Manager space .. not static mapped
+ */
+#define IXP425_QMGR_BASE_PHYS		(0x60000000)
+#define IXP425_QMGR_REGION_SIZE		(0x00004000)
+
+/*
+ * Expansion BUS
+ *
+ * Expansion Bus 'lives' at either base1 or base 2 depending on the value of
+ * Exp Bus config registers:
+ *
+ * Setting bit 31 of IXP425_EXP_CFG0 puts SDRAM at zero,
+ * and The expansion bus to IXP425_EXP_BUS_BASE2
+ */
+#define IXP425_EXP_BUS_BASE1_PHYS	(0x00000000)
+#define IXP425_EXP_BUS_BASE2_PHYS	(0x50000000)
+
+#define IXP425_EXP_BUS_BASE_PHYS	IXP425_EXP_BUS_BASE2_PHYS
+
+#define IXP425_EXP_BUS_REGION_SIZE	(0x08000000)
+#define IXP425_EXP_BUS_CSX_REGION_SIZE	(0x01000000)
+
+#define IXP425_EXP_BUS_CS0_BASE_PHYS	(IXP425_EXP_BUS_BASE2_PHYS + 0x00000000)
+#define IXP425_EXP_BUS_CS1_BASE_PHYS	(IXP425_EXP_BUS_BASE2_PHYS + 0x01000000)
+#define IXP425_EXP_BUS_CS2_BASE_PHYS	(IXP425_EXP_BUS_BASE2_PHYS + 0x02000000)
+#define IXP425_EXP_BUS_CS3_BASE_PHYS	(IXP425_EXP_BUS_BASE2_PHYS + 0x03000000)
+#define IXP425_EXP_BUS_CS4_BASE_PHYS	(IXP425_EXP_BUS_BASE2_PHYS + 0x04000000)
+#define IXP425_EXP_BUS_CS5_BASE_PHYS	(IXP425_EXP_BUS_BASE2_PHYS + 0x05000000)
+#define IXP425_EXP_BUS_CS6_BASE_PHYS	(IXP425_EXP_BUS_BASE2_PHYS + 0x06000000)
+#define IXP425_EXP_BUS_CS7_BASE_PHYS	(IXP425_EXP_BUS_BASE2_PHYS + 0x07000000)
+
+#define IXP425_FLASH_WRITABLE	(0x2)
+#define IXP425_FLASH_DEFAULT	(0xbcd23c40)
+#define IXP425_FLASH_WRITE	(0xbcd23c42)
+
+#define IXP425_EXP_CS0_OFFSET	0x00
+#define IXP425_EXP_CS1_OFFSET   0x04
+#define IXP425_EXP_CS2_OFFSET   0x08
+#define IXP425_EXP_CS3_OFFSET   0x0C
+#define IXP425_EXP_CS4_OFFSET   0x10
+#define IXP425_EXP_CS5_OFFSET   0x14
+#define IXP425_EXP_CS6_OFFSET   0x18
+#define IXP425_EXP_CS7_OFFSET   0x1C
+#define IXP425_EXP_CFG0_OFFSET	0x20
+#define IXP425_EXP_CFG1_OFFSET	0x24
+#define IXP425_EXP_CFG2_OFFSET	0x28
+#define IXP425_EXP_CFG3_OFFSET	0x2C
+
+/*
+ * Expansion Bus Controller registers.
+ */
+#ifndef __ASSEMBLY__
+#define IXP425_EXP_REG(x) ((volatile u32 *)(IXP425_EXP_CFG_BASE_PHYS+(x)))
+#else
+#define IXP425_EXP_REG(x) (IXP425_EXP_CFG_BASE_PHYS+(x))
+#endif
+
+#define IXP425_EXP_CS0      IXP425_EXP_REG(IXP425_EXP_CS0_OFFSET)
+#define IXP425_EXP_CS1      IXP425_EXP_REG(IXP425_EXP_CS1_OFFSET)
+#define IXP425_EXP_CS2      IXP425_EXP_REG(IXP425_EXP_CS2_OFFSET)
+#define IXP425_EXP_CS3      IXP425_EXP_REG(IXP425_EXP_CS3_OFFSET)
+#define IXP425_EXP_CS4      IXP425_EXP_REG(IXP425_EXP_CS4_OFFSET)
+#define IXP425_EXP_CS5      IXP425_EXP_REG(IXP425_EXP_CS5_OFFSET)
+#define IXP425_EXP_CS6      IXP425_EXP_REG(IXP425_EXP_CS6_OFFSET)
+#define IXP425_EXP_CS7      IXP425_EXP_REG(IXP425_EXP_CS7_OFFSET)
+
+#define IXP425_EXP_CFG0     IXP425_EXP_REG(IXP425_EXP_CFG0_OFFSET)
+#define IXP425_EXP_CFG1     IXP425_EXP_REG(IXP425_EXP_CFG1_OFFSET)
+#define IXP425_EXP_CFG2     IXP425_EXP_REG(IXP425_EXP_CFG2_OFFSET)
+#define IXP425_EXP_CFG3     IXP425_EXP_REG(IXP425_EXP_CFG3_OFFSET)
+
+/*
+ * SDRAM Controller registers.
+ */
+#define IXP425_SDR_CONFIG_OFFSET	0x00
+#define IXP425_SDR_REFRESH_OFFSET	0x04
+#define IXP425_SDR_IR_OFFSET		0x08
+
+#define IXP425_SDRAM_REG(x) 	(IXP425_SDRAM_CFG_BASE_PHYS+(x))
+
+#define IXP425_SDR_CONFIG	IXP425_SDRAM_REG(IXP425_SDR_CONFIG_OFFSET)
+#define IXP425_SDR_REFRESH     	IXP425_SDRAM_REG(IXP425_SDR_REFRESH_OFFSET)
+#define IXP425_SDR_IR     	IXP425_SDRAM_REG(IXP425_SDR_IR_OFFSET)
+
+/*
+ * UART registers
+ */
+#define IXP425_UART1	0
+#define IXP425_UART2	0x1000
+
+#define IXP425_UART_RBR_OFFSET	0x00
+#define IXP425_UART_THR_OFFSET	0x00
+#define IXP425_UART_DLL_OFFSET	0x00
+#define IXP425_UART_IER_OFFSET	0x04
+#define IXP425_UART_DLH_OFFSET	0x04
+#define IXP425_UART_IIR_OFFSET	0x08
+#define IXP425_UART_FCR_OFFSET	0x00
+#define IXP425_UART_LCR_OFFSET	0x0c
+#define IXP425_UART_MCR_OFFSET	0x10
+#define IXP425_UART_LSR_OFFSET	0x14
+#define IXP425_UART_MSR_OFFSET	0x18
+#define IXP425_UART_SPR_OFFSET	0x1c
+#define IXP425_UART_ISR_OFFSET	0x20
+
+#define IXP425_UART_CFG_BASE_PHYS	(0xc8000000)
+
+#define RBR(x)		__REG(IXP425_UART_CFG_BASE_PHYS+(x)+IXP425_UART_RBR_OFFSET)
+#define THR(x)		__REG(IXP425_UART_CFG_BASE_PHYS+(x)+IXP425_UART_THR_OFFSET)
+#define DLL(x)		__REG(IXP425_UART_CFG_BASE_PHYS+(x)+IXP425_UART_DLL_OFFSET)
+#define IER(x)		__REG(IXP425_UART_CFG_BASE_PHYS+(x)+IXP425_UART_IER_OFFSET)
+#define DLH(x)		__REG(IXP425_UART_CFG_BASE_PHYS+(x)+IXP425_UART_DLH_OFFSET)
+#define IIR(x)		__REG(IXP425_UART_CFG_BASE_PHYS+(x)+IXP425_UART_IIR_OFFSET)
+#define FCR(x)		__REG(IXP425_UART_CFG_BASE_PHYS+(x)+IXP425_UART_FCR_OFFSET)
+#define LCR(x)		__REG(IXP425_UART_CFG_BASE_PHYS+(x)+IXP425_UART_LCR_OFFSET)
+#define MCR(x)		__REG(IXP425_UART_CFG_BASE_PHYS+(x)+IXP425_UART_MCR_OFFSET)
+#define LSR(x)		__REG(IXP425_UART_CFG_BASE_PHYS+(x)+IXP425_UART_LSR_OFFSET)
+#define MSR(x)		__REG(IXP425_UART_CFG_BASE_PHYS+(x)+IXP425_UART_MSR_OFFSET)
+#define SPR(x)		__REG(IXP425_UART_CFG_BASE_PHYS+(x)+IXP425_UART_SPR_OFFSET)
+#define ISR(x)		__REG(IXP425_UART_CFG_BASE_PHYS+(x)+IXP425_UART_ISR_OFFSET)
+
+#define IER_DMAE	(1 << 7)	/* DMA Requests Enable */
+#define IER_UUE		(1 << 6)	/* UART Unit Enable */
+#define IER_NRZE	(1 << 5)	/* NRZ coding Enable */
+#define IER_RTIOE	(1 << 4)	/* Receiver Time Out Interrupt Enable */
+#define IER_MIE		(1 << 3)	/* Modem Interrupt Enable */
+#define IER_RLSE	(1 << 2)	/* Receiver Line Status Interrupt Enable */
+#define IER_TIE		(1 << 1)	/* Transmit Data request Interrupt Enable */
+#define IER_RAVIE	(1 << 0)	/* Receiver Data Available Interrupt Enable */
+
+#define IIR_FIFOES1	(1 << 7)	/* FIFO Mode Enable Status */
+#define IIR_FIFOES0	(1 << 6)	/* FIFO Mode Enable Status */
+#define IIR_TOD		(1 << 3)	/* Time Out Detected */
+#define IIR_IID2	(1 << 2)	/* Interrupt Source Encoded */
+#define IIR_IID1	(1 << 1)	/* Interrupt Source Encoded */
+#define IIR_IP		(1 << 0)	/* Interrupt Pending (active low) */
+
+#define FCR_ITL2	(1 << 7)	/* Interrupt Trigger Level */
+#define FCR_ITL1	(1 << 6)	/* Interrupt Trigger Level */
+#define FCR_RESETTF	(1 << 2)	/* Reset Transmitter FIFO */
+#define FCR_RESETRF	(1 << 1)	/* Reset Receiver FIFO */
+#define FCR_TRFIFOE	(1 << 0)	/* Transmit and Receive FIFO Enable */
+#define FCR_ITL_1	(0)
+#define FCR_ITL_8	(FCR_ITL1)
+#define FCR_ITL_16	(FCR_ITL2)
+#define FCR_ITL_32	(FCR_ITL2|FCR_ITL1)
+
+#define LCR_DLAB	(1 << 7)	/* Divisor Latch Access Bit */
+#define LCR_SB		(1 << 6)	/* Set Break */
+#define LCR_STKYP	(1 << 5)	/* Sticky Parity */
+#define LCR_EPS		(1 << 4)	/* Even Parity Select */
+#define LCR_PEN		(1 << 3)	/* Parity Enable */
+#define LCR_STB		(1 << 2)	/* Stop Bit */
+#define LCR_WLS1	(1 << 1)	/* Word Length Select */
+#define LCR_WLS0	(1 << 0)	/* Word Length Select */
+
+#define LSR_FIFOE	(1 << 7)	/* FIFO Error Status */
+#define LSR_TEMT	(1 << 6)	/* Transmitter Empty */
+#define LSR_TDRQ	(1 << 5)	/* Transmit Data Request */
+#define LSR_BI		(1 << 4)	/* Break Interrupt */
+#define LSR_FE		(1 << 3)	/* Framing Error */
+#define LSR_PE		(1 << 2)	/* Parity Error */
+#define LSR_OE		(1 << 1)	/* Overrun Error */
+#define LSR_DR		(1 << 0)	/* Data Ready */
+
+#define MCR_LOOP	(1 << 4)	*/
+#define MCR_OUT2	(1 << 3)	/* force MSR_DCD in loopback mode */
+#define MCR_OUT1	(1 << 2)	/* force MSR_RI in loopback mode */
+#define MCR_RTS		(1 << 1)	/* Request to Send */
+#define MCR_DTR		(1 << 0)	/* Data Terminal Ready */
+
+#define MSR_DCD		(1 << 7)	/* Data Carrier Detect */
+#define MSR_RI		(1 << 6)	/* Ring Indicator */
+#define MSR_DSR		(1 << 5)	/* Data Set Ready */
+#define MSR_CTS		(1 << 4)	/* Clear To Send */
+#define MSR_DDCD	(1 << 3)	/* Delta Data Carrier Detect */
+#define MSR_TERI	(1 << 2)	/* Trailing Edge Ring Indicator */
+#define MSR_DDSR	(1 << 1)	/* Delta Data Set Ready */
+#define MSR_DCTS	(1 << 0)	/* Delta Clear To Send */
+
+#define IXP425_CONSOLE_UART_BASE_PHYS IXP425_UART1_BASE_PHYS
+/*
+ * Peripheral Space Registers
+ */
+#define IXP425_UART1_BASE_PHYS	(IXP425_PERIPHERAL_BASE_PHYS + 0x0000)
+#define IXP425_UART2_BASE_PHYS	(IXP425_PERIPHERAL_BASE_PHYS + 0x1000)
+#define IXP425_PMU_BASE_PHYS	(IXP425_PERIPHERAL_BASE_PHYS + 0x2000)
+#define IXP425_INTC_BASE_PHYS	(IXP425_PERIPHERAL_BASE_PHYS + 0x3000)
+#define IXP425_GPIO_BASE_PHYS	(IXP425_PERIPHERAL_BASE_PHYS + 0x4000)
+#define IXP425_TIMER_BASE_PHYS	(IXP425_PERIPHERAL_BASE_PHYS + 0x5000)
+#define IXP425_NPEA_BASE_PHYS	(IXP425_PERIPHERAL_BASE_PHYS + 0x6000)
+#define IXP425_NPEB_BASE_PHYS	(IXP425_PERIPHERAL_BASE_PHYS + 0x7000)
+#define IXP425_NPEC_BASE_PHYS	(IXP425_PERIPHERAL_BASE_PHYS + 0x8000)
+#define IXP425_EthA_BASE_PHYS	(IXP425_PERIPHERAL_BASE_PHYS + 0x9000)
+#define IXP425_EthB_BASE_PHYS	(IXP425_PERIPHERAL_BASE_PHYS + 0xA000)
+#define IXP425_USB_BASE_PHYS	(IXP425_PERIPHERAL_BASE_PHYS + 0xB000)
+
+/*
+ * UART Register Definitions , Offsets only as there are 2 UARTS.
+ *   IXP425_UART1_BASE , IXP425_UART2_BASE.
+ */
+
+#undef  UART_NO_RX_INTERRUPT
+
+#define IXP425_UART_XTAL        14745600
+
+/*
+ * Constants to make it easy to access  Interrupt Controller registers
+ */
+#define IXP425_ICPR_OFFSET	0x00 /* Interrupt Status */
+#define IXP425_ICMR_OFFSET	0x04 /* Interrupt Enable */
+#define IXP425_ICLR_OFFSET	0x08 /* Interrupt IRQ/FIQ Select */
+#define IXP425_ICIP_OFFSET      0x0C /* IRQ Status */
+#define IXP425_ICFP_OFFSET	0x10 /* FIQ Status */
+#define IXP425_ICHR_OFFSET	0x14 /* Interrupt Priority */
+#define IXP425_ICIH_OFFSET	0x18 /* IRQ Highest Pri Int */
+#define IXP425_ICFH_OFFSET	0x1C /* FIQ Highest Pri Int */
+
+#define N_IRQS			32
+#define IXP425_TIMER_2_IRQ	11
+
+/*
+ * Interrupt Controller Register Definitions.
+ */
+#ifndef __ASSEMBLY__
+#define IXP425_INTC_REG(x) ((volatile u32 *)(IXP425_INTC_BASE_PHYS+(x)))
+#else
+#define IXP425_INTC_REG(x) (IXP425_INTC_BASE_PHYS+(x))
+#endif
+
+#define IXP425_ICPR     IXP425_INTC_REG(IXP425_ICPR_OFFSET)
+#define IXP425_ICMR     IXP425_INTC_REG(IXP425_ICMR_OFFSET)
+#define IXP425_ICLR     IXP425_INTC_REG(IXP425_ICLR_OFFSET)
+#define IXP425_ICIP     IXP425_INTC_REG(IXP425_ICIP_OFFSET)
+#define IXP425_ICFP     IXP425_INTC_REG(IXP425_ICFP_OFFSET)
+#define IXP425_ICHR     IXP425_INTC_REG(IXP425_ICHR_OFFSET)
+#define IXP425_ICIH     IXP425_INTC_REG(IXP425_ICIH_OFFSET)
+#define IXP425_ICFH     IXP425_INTC_REG(IXP425_ICFH_OFFSET)
+
+/*
+ * Constants to make it easy to access GPIO registers
+ */
+#define IXP425_GPIO_GPOUTR_OFFSET       0x00
+#define IXP425_GPIO_GPOER_OFFSET        0x04
+#define IXP425_GPIO_GPINR_OFFSET        0x08
+#define IXP425_GPIO_GPISR_OFFSET        0x0C
+#define IXP425_GPIO_GPIT1R_OFFSET	0x10
+#define IXP425_GPIO_GPIT2R_OFFSET	0x14
+#define IXP425_GPIO_GPCLKR_OFFSET	0x18
+#define IXP425_GPIO_GPDBSELR_OFFSET	0x1C
+
+/*
+ * GPIO Register Definitions.
+ * [Only perform 32bit reads/writes]
+ */
+#define IXP425_GPIO_REG(x) ((volatile u32 *)(IXP425_GPIO_BASE_PHYS+(x)))
+
+#define IXP425_GPIO_GPOUTR	IXP425_GPIO_REG(IXP425_GPIO_GPOUTR_OFFSET)
+#define IXP425_GPIO_GPOER       IXP425_GPIO_REG(IXP425_GPIO_GPOER_OFFSET)
+#define IXP425_GPIO_GPINR       IXP425_GPIO_REG(IXP425_GPIO_GPINR_OFFSET)
+#define IXP425_GPIO_GPISR       IXP425_GPIO_REG(IXP425_GPIO_GPISR_OFFSET)
+#define IXP425_GPIO_GPIT1R      IXP425_GPIO_REG(IXP425_GPIO_GPIT1R_OFFSET)
+#define IXP425_GPIO_GPIT2R      IXP425_GPIO_REG(IXP425_GPIO_GPIT2R_OFFSET)
+#define IXP425_GPIO_GPCLKR      IXP425_GPIO_REG(IXP425_GPIO_GPCLKR_OFFSET)
+#define IXP425_GPIO_GPDBSELR    IXP425_GPIO_REG(IXP425_GPIO_GPDBSELR_OFFSET)
+
+/*
+ * Macros to make it easy to access the GPIO registers
+ */
+#define GPIO_OUTPUT_ENABLE(line)	*IXP425_GPIO_GPOER &= ~(1 << (line))
+#define GPIO_OUTPUT_DISABLE(line)	*IXP425_GPIO_GPOER |= (1 << (line))
+#define GPIO_OUTPUT_SET(line)		*IXP425_GPIO_GPOUTR |= (1 << (line))
+#define GPIO_OUTPUT_CLEAR(line)		*IXP425_GPIO_GPOUTR &= ~(1 << (line))
+#define GPIO_INT_ACT_LOW_SET(line)	*IXP425_GPIO_GPIT1R = \
+		(*IXP425_GPIO_GPIT1R & ~(0x7 << (line * 3))) | (0x1 << (line * 3))
+
+/*
+ * Constants to make it easy to access Timer Control/Status registers
+ */
+#define IXP425_OSTS_OFFSET	0x00  /* Continious TimeStamp */
+#define IXP425_OST1_OFFSET	0x04  /* Timer 1 Timestamp */
+#define IXP425_OSRT1_OFFSET	0x08  /* Timer 1 Reload */
+#define IXP425_OST2_OFFSET	0x0C  /* Timer 2 Timestamp */
+#define IXP425_OSRT2_OFFSET	0x10  /* Timer 2 Reload */
+#define IXP425_OSWT_OFFSET	0x14  /* Watchdog Timer */
+#define IXP425_OSWE_OFFSET	0x18  /* Watchdog Enable */
+#define IXP425_OSWK_OFFSET	0x1C  /* Watchdog Key */
+#define IXP425_OSST_OFFSET	0x20  /* Timer Status */
+
+/*
+ * Operating System Timer Register Definitions.
+ */
+
+#ifndef __ASSEMBLY__
+#define IXP425_TIMER_REG(x) ((volatile u32 *)(IXP425_TIMER_BASE_PHYS+(x)))
+#else
+#define IXP425_TIMER_REG(x) (IXP425_TIMER_BASE_PHYS+(x))
+#endif
+
+#if 0 /* test-only: also defined in npe/include/... */
+#define IXP425_OSTS	IXP425_TIMER_REG(IXP425_OSTS_OFFSET)
+#endif
+#define IXP425_OST1	IXP425_TIMER_REG(IXP425_OST1_OFFSET)
+#define IXP425_OSRT1	IXP425_TIMER_REG(IXP425_OSRT1_OFFSET)
+#define IXP425_OST2	IXP425_TIMER_REG(IXP425_OST2_OFFSET)
+#define IXP425_OSRT2	IXP425_TIMER_REG(IXP425_OSRT2_OFFSET)
+#define IXP425_OSWT	IXP425_TIMER_REG(IXP425_OSWT_OFFSET)
+#define IXP425_OSWE	IXP425_TIMER_REG(IXP425_OSWE_OFFSET)
+#define IXP425_OSWK	IXP425_TIMER_REG(IXP425_OSWK_OFFSET)
+#define IXP425_OSST	IXP425_TIMER_REG(IXP425_OSST_OFFSET)
+
+/*
+ * Timer register values and bit definitions
+ */
+#define IXP425_OST_ENABLE              BIT(0)
+#define IXP425_OST_ONE_SHOT            BIT(1)
+/* Low order bits of reload value ignored */
+#define IXP425_OST_RELOAD_MASK         (0x3)
+#define IXP425_OST_DISABLED            (0x0)
+#define IXP425_OSST_TIMER_1_PEND       BIT(0)
+#define IXP425_OSST_TIMER_2_PEND       BIT(1)
+#define IXP425_OSST_TIMER_TS_PEND      BIT(2)
+#define IXP425_OSST_TIMER_WDOG_PEND    BIT(3)
+#define IXP425_OSST_TIMER_WARM_RESET   BIT(4)
+
+/*
+ * Constants to make it easy to access PCI Control/Status registers
+ */
+#define PCI_NP_AD_OFFSET            0x00
+#define PCI_NP_CBE_OFFSET           0x04
+#define PCI_NP_WDATA_OFFSET         0x08
+#define PCI_NP_RDATA_OFFSET         0x0c
+#define PCI_CRP_AD_CBE_OFFSET       0x10
+#define PCI_CRP_WDATA_OFFSET        0x14
+#define PCI_CRP_RDATA_OFFSET        0x18
+#define PCI_CSR_OFFSET              0x1c
+#define PCI_ISR_OFFSET              0x20
+#define PCI_INTEN_OFFSET            0x24
+#define PCI_DMACTRL_OFFSET          0x28
+#define PCI_AHBMEMBASE_OFFSET       0x2c
+#define PCI_AHBIOBASE_OFFSET        0x30
+#define PCI_PCIMEMBASE_OFFSET       0x34
+#define PCI_AHBDOORBELL_OFFSET      0x38
+#define PCI_PCIDOORBELL_OFFSET      0x3C
+#define PCI_ATPDMA0_AHBADDR_OFFSET  0x40
+#define PCI_ATPDMA0_PCIADDR_OFFSET  0x44
+#define PCI_ATPDMA0_LENADDR_OFFSET  0x48
+#define PCI_ATPDMA1_AHBADDR_OFFSET  0x4C
+#define PCI_ATPDMA1_PCIADDR_OFFSET  0x50
+#define PCI_ATPDMA1_LENADDR_OFFSET  0x54
+
+/*
+ * PCI Control/Status Registers
+ */
+#define IXP425_PCI_CSR(x) ((volatile u32 *)(IXP425_PCI_CFG_BASE_PHYS+(x)))
+
+#define PCI_NP_AD               IXP425_PCI_CSR(PCI_NP_AD_OFFSET)
+#define PCI_NP_CBE              IXP425_PCI_CSR(PCI_NP_CBE_OFFSET)
+#define PCI_NP_WDATA            IXP425_PCI_CSR(PCI_NP_WDATA_OFFSET)
+#define PCI_NP_RDATA            IXP425_PCI_CSR(PCI_NP_RDATA_OFFSET)
+#define PCI_CRP_AD_CBE          IXP425_PCI_CSR(PCI_CRP_AD_CBE_OFFSET)
+#define PCI_CRP_WDATA           IXP425_PCI_CSR(PCI_CRP_WDATA_OFFSET)
+#define PCI_CRP_RDATA           IXP425_PCI_CSR(PCI_CRP_RDATA_OFFSET)
+#define PCI_CSR                 IXP425_PCI_CSR(PCI_CSR_OFFSET)
+#define PCI_ISR                 IXP425_PCI_CSR(PCI_ISR_OFFSET)
+#define PCI_INTEN               IXP425_PCI_CSR(PCI_INTEN_OFFSET)
+#define PCI_DMACTRL             IXP425_PCI_CSR(PCI_DMACTRL_OFFSET)
+#define PCI_AHBMEMBASE          IXP425_PCI_CSR(PCI_AHBMEMBASE_OFFSET)
+#define PCI_AHBIOBASE           IXP425_PCI_CSR(PCI_AHBIOBASE_OFFSET)
+#define PCI_PCIMEMBASE          IXP425_PCI_CSR(PCI_PCIMEMBASE_OFFSET)
+#define PCI_AHBDOORBELL         IXP425_PCI_CSR(PCI_AHBDOORBELL_OFFSET)
+#define PCI_PCIDOORBELL         IXP425_PCI_CSR(PCI_PCIDOORBELL_OFFSET)
+#define PCI_ATPDMA0_AHBADDR     IXP425_PCI_CSR(PCI_ATPDMA0_AHBADDR_OFFSET)
+#define PCI_ATPDMA0_PCIADDR     IXP425_PCI_CSR(PCI_ATPDMA0_PCIADDR_OFFSET)
+#define PCI_ATPDMA0_LENADDR     IXP425_PCI_CSR(PCI_ATPDMA0_LENADDR_OFFSET)
+#define PCI_ATPDMA1_AHBADDR     IXP425_PCI_CSR(PCI_ATPDMA1_AHBADDR_OFFSET)
+#define PCI_ATPDMA1_PCIADDR     IXP425_PCI_CSR(PCI_ATPDMA1_PCIADDR_OFFSET)
+#define PCI_ATPDMA1_LENADDR     IXP425_PCI_CSR(PCI_ATPDMA1_LENADDR_OFFSET)
+
+/*
+ * PCI register values and bit definitions
+ */
+
+/* CSR bit definitions */
+#define PCI_CSR_HOST    	BIT(0)
+#define PCI_CSR_ARBEN   	BIT(1)
+#define PCI_CSR_ADS     	BIT(2)
+#define PCI_CSR_PDS     	BIT(3)
+#define PCI_CSR_ABE     	BIT(4)
+#define PCI_CSR_DBT     	BIT(5)
+#define PCI_CSR_ASE     	BIT(8)
+#define PCI_CSR_IC      	BIT(15)
+
+/* ISR (Interrupt status) Register bit definitions */
+#define PCI_ISR_PSE     	BIT(0)
+#define PCI_ISR_PFE     	BIT(1)
+#define PCI_ISR_PPE     	BIT(2)
+#define PCI_ISR_AHBE    	BIT(3)
+#define PCI_ISR_APDC    	BIT(4)
+#define PCI_ISR_PADC    	BIT(5)
+#define PCI_ISR_ADB     	BIT(6)
+#define PCI_ISR_PDB     	BIT(7)
+
+/* INTEN (Interrupt Enable) Register bit definitions */
+#define PCI_INTEN_PSE   	BIT(0)
+#define PCI_INTEN_PFE   	BIT(1)
+#define PCI_INTEN_PPE   	BIT(2)
+#define PCI_INTEN_AHBE  	BIT(3)
+#define PCI_INTEN_APDC  	BIT(4)
+#define PCI_INTEN_PADC  	BIT(5)
+#define PCI_INTEN_ADB   	BIT(6)
+#define PCI_INTEN_PDB   	BIT(7)
+
+/*
+ * Shift value for byte enable on NP cmd/byte enable register
+ */
+#define IXP425_PCI_NP_CBE_BESL		4
+
+/*
+ * PCI commands supported by NP access unit
+ */
+#define NP_CMD_IOREAD			0x2
+#define NP_CMD_IOWRITE			0x3
+#define NP_CMD_CONFIGREAD		0xa
+#define NP_CMD_CONFIGWRITE		0xb
+#define NP_CMD_MEMREAD			0x6
+#define	NP_CMD_MEMWRITE			0x7
+
+#if 0
+#ifndef __ASSEMBLY__
+extern int ixp425_pci_read(u32 addr, u32 cmd, u32* data);
+extern int ixp425_pci_write(u32 addr, u32 cmd, u32 data);
+extern void ixp425_pci_init(void *);
+#endif
+#endif
+
+/*
+ * Constants for CRP access into local config space
+ */
+#define CRP_AD_CBE_BESL         20
+#define CRP_AD_CBE_WRITE        BIT(16)
+
+/*
+ * Clock Speed Definitions.
+ */
+#define IXP425_PERIPHERAL_BUS_CLOCK (66) /* 66Mhzi APB BUS   */
+
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch-ixp/ixp425pci.h u-boot-1.2.0-leopard/include/asm/arch-ixp/ixp425pci.h
--- u-boot-1.2.0/include/asm/arch-ixp/ixp425pci.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-ixp/ixp425pci.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,312 @@
+/*
+ * IXP PCI Init
+ * (C) Copyright 2004 eslab.whut.edu.cn
+ * Yue Hu(huyue_whut@yahoo.com.cn), Ligong Xue(lgxue@hotmail.com)
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _IXP425PCI_H_
+#define _IXP425PCI_H_
+
+#define TRUE	1
+#define FALSE	0
+#define OK	0
+#define ERROR	-1
+#define BOOL	int
+
+#define IXP425_PCI_MAX_BAR_PER_FUNC  6
+#define IXP425_PCI_MAX_BAR (IXP425_PCI_MAX_BAR_PER_FUNC * \
+			    IXP425_PCI_MAX_FUNC_ON_BUS)
+
+enum PciBarId
+{
+	CSR_BAR=0,
+	IO_BAR,
+	SD_BAR,
+	NO_BAR
+};
+
+/*Base address register descriptor*/
+typedef struct
+{
+	unsigned int size;
+	unsigned int address;
+} PciBar;
+
+typedef struct
+{
+	unsigned int bus;
+	unsigned int device;
+	unsigned int func;
+	unsigned int irq;
+	BOOL error;
+	unsigned short vendor_id;
+	unsigned short device_id;
+	/*We need an extra entry in this array for dummy placeholder*/
+	PciBar bar[IXP425_PCI_MAX_BAR_PER_FUNC + 1];
+} PciDevice;
+
+/* Mask definitions*/
+#define IXP425_PCI_TOP_WORD_OF_LONG_MASK	0xffff0000
+#define IXP425_PCI_TOP_BYTE_OF_LONG_MASK	0xff000000
+#define IXP425_PCI_BOTTOM_WORD_OF_LONG_MASK	0x0000ffff
+#define IXP425_PCI_BOTTOM_TRIBYTES_OF_LONG_MASK 0x00ffffff
+#define IXP425_PCI_BOTTOM_NIBBLE_OF_LONG_MASK	0x0000000f
+#define IXP425_PCI_MAX_UINT32			0xffffffff
+
+
+#define IXP425_PCI_BAR_QUERY			0xffffffff
+
+#define IXP425_PCI_BAR_MEM_BASE 0x100000
+#define IXP425_PCI_BAR_IO_BASE	0x000000
+
+/*define the maximum number of bus segments - we support a single segment*/
+#define IXP425_PCI_MAX_BUS  1
+/*define the maximum number of cards per bus segment*/
+#define IXP425_PCI_MAX_DEV  4
+/*define the maximum number of functions per device*/
+#define IXP425_PCI_MAX_FUNC 8
+/* define the maximum number of separate functions that we can
+   potentially have on the bus*/
+#define IXP425_PCI_MAX_FUNC_ON_BUS (1+ IXP425_PCI_MAX_FUNC *	\
+				    IXP425_PCI_MAX_DEV *	\
+				    IXP425_PCI_MAX_BUS)
+/*define the maximum number of BARs per function*/
+#define IXP425_PCI_MAX_BAR_PER_FUNC  6
+#define IXP425_PCI_MAX_BAR (IXP425_PCI_MAX_BAR_PER_FUNC *	\
+			    IXP425_PCI_MAX_FUNC_ON_BUS)
+
+#define PCI_NP_CBE_BESL	 (4)
+#define PCI_NP_AD_FUNCSL (8)
+
+#define REG_WRITE(b,o,v) (*(volatile unsigned int*)((b+o))=(v))
+#define REG_READ(b,o,v)	 ((v)=(*(volatile unsigned int*)((b+o))))
+
+#define PCI_DELAY	500
+#define USEC_LOOP_COUNT 533
+#define PCI_SETTLE_USEC 200
+#define PCI_MIN_RESET_ASSERT_USEC 2000
+
+/*Register addressing definitions for PCI controller configuration
+  and status registers*/
+
+#define PCI_CSR_BASE (0xC0000000)
+/*
+#define PCI_NP_AD_OFFSET       (0x00)
+#define PCI_NP_CBE_OFFSET      (0x04)
+#define PCI_NP_WDATA_OFFSET    (0x08)
+#define PCI_NP_RDATA_OFFSET    (0x0C)
+#define PCI_CRP_OFFSET	       (0x10)
+#define PCI_CRP_WDATA_OFFSET   (0x14)
+#define PCI_CRP_RDATA_OFFSET   (0x18)
+#define PCI_CSR_OFFSET	       (0x1C)
+#define PCI_ISR_OFFSET	       (0x20)
+#define PCI_INTEN_OFFSET       (0x24)
+#define PCI_DMACTRL_OFFSET     (0x28)
+#define PCI_AHBMEMBASE_OFFSET  (0x2C)
+#define PCI_AHBIOBASE_OFFSET   (0x30)
+#define PCI_PCIMEMBASE_OFFSET  (0x34)
+#define PCI_AHBDOORBELL_OFFSET (0x38)
+#define PCI_PCIDOORBELL_OFFSET (0x3C)
+#define PCI_ATPDMA0_AHBADDR    (0x40)
+#define PCI_ATPDMA0_PCIADDR    (0x44)
+#define PCI_ATPDMA0_LENADDR    (0x48)
+#define PCI_ATPDMA1_AHBADDR    (0x4C)
+#define PCI_ATPDMA1_PCIADDR    (0x50)
+#define PCI_ATPDMA1_LENADDR    (0x54)
+#define PCI_PTADMA0_AHBADDR    (0x58)
+#define PCI_PTADMA0_PCIADDR    (0x5C)
+#define PCI_PTADMA0_LENADDR    (0x60)
+#define PCI_PTADMA1_AHBADDR    (0x64)
+#define PCI_PTADMA1_PCIADDR    (0x68)
+#define PCI_PTADMA1_LENADDR    (0x6C)
+*/
+/*Non prefetch registers bit definitions*/
+/*
+#define NP_CMD_INTACK	   (0x0)
+#define NP_CMD_SPECIAL	   (0x1)
+#define NP_CMD_IOREAD	   (0x2)
+#define NP_CMD_IOWRITE	   (0x3)
+#define NP_CMD_MEMREAD	   (0x6)
+#define NP_CMD_MEMWRITE	   (0x7)
+#define NP_CMD_CONFIGREAD  (0xa)
+#define NP_CMD_CONFIGWRITE (0xb)
+*/
+
+/*define the default setting of the AHB memory base reg*/
+#define IXP425_PCI_AHBMEMBASE_DEFAULT 0x00010203
+#define IXP425_PCI_AHBIOBASE_DEFAULT  0x0
+#define IXP425_PCI_PCIMEMBASE_DEFAULT 0x0
+
+/*define the default settings for the controller's BARs*/
+#ifdef IXP425_PCI_SIMPLE_MAPPING
+#define IXP425_PCI_BAR_0_DEFAULT 0x00000000
+#define IXP425_PCI_BAR_1_DEFAULT 0x01000000
+#define IXP425_PCI_BAR_2_DEFAULT 0x02000000
+#define IXP425_PCI_BAR_3_DEFAULT 0x03000000
+#define IXP425_PCI_BAR_4_DEFAULT 0x00000000
+#define IXP425_PCI_BAR_5_DEFAULT 0x00000000
+#else
+#define IXP425_PCI_BAR_0_DEFAULT 0x40000000
+#define IXP425_PCI_BAR_1_DEFAULT 0x41000000
+#define IXP425_PCI_BAR_2_DEFAULT 0x42000000
+#define IXP425_PCI_BAR_3_DEFAULT 0x43000000
+#define IXP425_PCI_BAR_4_DEFAULT 0x00000000
+#define IXP425_PCI_BAR_5_DEFAULT 0x00000000
+#endif
+
+/*Configuration Port register bit definitions*/
+#define PCI_CRP_WRITE BIT(16)
+
+/*ISR (Interrupt status) Register bit definitions*/
+#define PCI_ISR_PSE   BIT(0)
+#define PCI_ISR_PFE   BIT(1)
+#define PCI_ISR_PPE   BIT(2)
+#define PCI_ISR_AHBE  BIT(3)
+#define PCI_ISR_APDC  BIT(4)
+#define PCI_ISR_PADC  BIT(5)
+#define PCI_ISR_ADB   BIT(6)
+#define PCI_ISR_PDB   BIT(7)
+
+/*INTEN (Interrupt Enable) Register bit definitions*/
+#define PCI_INTEN_PSE	BIT(0)
+#define PCI_INTEN_PFE	BIT(1)
+#define PCI_INTEN_PPE	BIT(2)
+#define PCI_INTEN_AHBE	BIT(3)
+#define PCI_INTEN_APDC	BIT(4)
+#define PCI_INTEN_PADC	BIT(5)
+#define PCI_INTEN_ADB	BIT(6)
+#define PCI_INTEN_PDB	BIT(7)
+
+/*PCI configuration regs.*/
+
+#define PCI_CFG_VENDOR_ID	0x00
+#define PCI_CFG_DEVICE_ID	0x02
+#define PCI_CFG_COMMAND		0x04
+#define PCI_CFG_STATUS		0x06
+#define PCI_CFG_REVISION	0x08
+#define PCI_CFG_PROGRAMMING_IF	0x09
+#define PCI_CFG_SUBCLASS	0x0a
+#define PCI_CFG_CLASS		0x0b
+#define PCI_CFG_CACHE_LINE_SIZE 0x0c
+#define PCI_CFG_LATENCY_TIMER	0x0d
+#define PCI_CFG_HEADER_TYPE	0x0e
+#define PCI_CFG_BIST		0x0f
+#define PCI_CFG_BASE_ADDRESS_0	0x10
+#define PCI_CFG_BASE_ADDRESS_1	0x14
+#define PCI_CFG_BASE_ADDRESS_2	0x18
+#define PCI_CFG_BASE_ADDRESS_3	0x1c
+#define PCI_CFG_BASE_ADDRESS_4	0x20
+#define PCI_CFG_BASE_ADDRESS_5	0x24
+#define PCI_CFG_CIS		0x28
+#define PCI_CFG_SUB_VENDOR_ID	0x2c
+#define PCI_CFG_SUB_SYSTEM_ID	0x2e
+#define PCI_CFG_EXPANSION_ROM	0x30
+#define PCI_CFG_RESERVED_0	0x34
+#define PCI_CFG_RESERVED_1	0x38
+#define PCI_CFG_DEV_INT_LINE	0x3c
+#define PCI_CFG_DEV_INT_PIN	0x3d
+#define PCI_CFG_MIN_GRANT	0x3e
+#define PCI_CFG_MAX_LATENCY	0x3f
+#define PCI_CFG_SPECIAL_USE	0x41
+#define PCI_CFG_MODE		0x43
+
+/*Specify the initial command we send to PCI devices*/
+#define INITIAL_PCI_CMD (PCI_CMD_IO_ENABLE	   \
+			 | PCI_CMD_MEM_ENABLE	   \
+			 | PCI_CMD_MASTER_ENABLE   \
+			 | PCI_CMD_WI_ENABLE)
+
+/*define the sub vendor and subsystem to be used */
+#define IXP425_PCI_SUB_VENDOR_SYSTEM 0x00000000
+
+#define PCI_IRQ_LINES		4
+
+#define PCI_CMD_IO_ENABLE	0x0001	/* IO access enable */
+#define PCI_CMD_MEM_ENABLE	0x0002	/* memory access enable */
+#define PCI_CMD_MASTER_ENABLE	0x0004	/* bus master enable */
+#define PCI_CMD_MON_ENABLE	0x0008	/* monitor special cycles enable */
+#define PCI_CMD_WI_ENABLE	0x0010	/* write and invalidate enable */
+#define PCI_CMD_SNOOP_ENABLE	0x0020	/* palette snoop enable */
+#define PCI_CMD_PERR_ENABLE	0x0040	/* parity error enable */
+#define PCI_CMD_WC_ENABLE	0x0080	/* wait cycle enable */
+#define PCI_CMD_SERR_ENABLE	0x0100	/* system error enable */
+#define PCI_CMD_FBTB_ENABLE	0x0200	/* fast back to back enable */
+
+
+/*CSR Register bit definitions*/
+#define PCI_CSR_HOST  BIT(0)
+#define PCI_CSR_ARBEN BIT(1)
+#define PCI_CSR_ADS   BIT(2)
+#define PCI_CSR_PDS   BIT(3)
+#define PCI_CSR_ABE   BIT(4)
+#define PCI_CSR_DBT   BIT(5)
+#define PCI_CSR_ASE   BIT(8)
+#define PCI_CSR_IC    BIT(15)
+
+/*Configuration command bit definitions*/
+#define PCI_CFG_CMD_IOAE BIT(0)
+#define PCI_CFG_CMD_MAE	 BIT(1)
+#define PCI_CFG_CMD_BME	 BIT(2)
+#define PCI_CFG_CMD_MWIE BIT(4)
+#define PCI_CFG_CMD_SER	 BIT(8)
+#define PCI_CFG_CMD_FBBE BIT(9)
+#define PCI_CFG_CMD_MDPE BIT(24)
+#define PCI_CFG_CMD_STA	 BIT(27)
+#define PCI_CFG_CMD_RTA	 BIT(28)
+#define PCI_CFG_CMD_RMA	 BIT(29)
+#define PCI_CFG_CMD_SSE	 BIT(30)
+#define PCI_CFG_CMD_DPE	 BIT(31)
+
+/*DMACTRL DMA Control and status Register*/
+#define PCI_DMACTRL_APDCEN  BIT(0)
+#define PCI_DMACTRL_APDC0   BIT(4)
+#define PCI_DMACTRL_APDE0   BIT(5)
+#define PCI_DMACTRL_APDC1   BIT(6)
+#define PCI_DMACTRL_APDE1   BIT(7)
+#define PCI_DMACTRL_PADCEN  BIT(8)
+#define PCI_DMACTRL_PADC0   BIT(12)
+#define PCI_DMACTRL_PADE0   BIT(13)
+#define PCI_DMACTRL_PADC1   BIT(14)
+#define PCI_DMACTRL_PADE1   BIT(15)
+
+/* GPIO related register */
+#undef IXP425_GPIO_GPOUTR
+#undef IXP425_GPIO_GPOER
+#undef IXP425_GPIO_GPINR
+#undef IXP425_GPIO_GPISR
+#undef IXP425_GPIO_GPIT1R
+#undef IXP425_GPIO_GPIT2R
+#undef IXP425_GPIO_GPCLKR
+
+#define IXP425_GPIO_GPOUTR	0xC8004000
+#define IXP425_GPIO_GPOER	0xC8004004
+#define IXP425_GPIO_GPINR	0xC8004008
+#define IXP425_GPIO_GPISR	0xC800400C
+#define IXP425_GPIO_GPIT1R	0xC8004010
+#define IXP425_GPIO_GPIT2R	0xC8004014
+#define IXP425_GPIO_GPCLKR	0xC8004018
+
+#define READ_GPIO_REG(addr,val) \
+		(val) = *((volatile int *)(addr));
+#define WRITE_GPIO_REG(addr,val) \
+		*((volatile int *)(addr)) = (val);
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/arch-ks8695/platform.h u-boot-1.2.0-leopard/include/asm/arch-ks8695/platform.h
--- u-boot-1.2.0/include/asm/arch-ks8695/platform.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-ks8695/platform.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,306 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
+ */
+#ifndef __address_h
+#define __address_h			1
+
+#define KS8695_SDRAM_START	    0x00000000
+#define KS8695_SDRAM_SIZE	    0x01000000
+#define KS8695_MEM_SIZE		    KS8695_SDRAM_SIZE
+#define KS8695_MEM_START	    KS8695_SDRAM_START
+
+#define KS8695_PCMCIA_IO_BASE	    0x03800000
+#define KS8695_PCMCIA_IO_SIZE	    0x00040000
+
+#define KS8695_IO_BASE		    0x03FF0000
+#define KS8695_IO_SIZE		    0x00010000
+
+#define KS8695_SYSTEN_CONFIG	    0x00
+#define KS8695_SYSTEN_BUS_CLOCK	    0x04
+
+#define KS8695_FLASH_START	    0x02800000
+#define KS8695_FLASH_SIZE	    0x00400000
+
+/*i/o control registers offset difinitions*/
+#define KS8695_IO_CTRL0		    0x4000
+#define KS8695_IO_CTRL1		    0x4004
+#define KS8695_IO_CTRL2		    0x4008
+#define KS8695_IO_CTRL3		    0x400C
+
+/*memory control registers offset difinitions*/
+#define KS8695_MEM_CTRL0	    0x4010
+#define KS8695_MEM_CTRL1	    0x4014
+#define KS8695_MEM_CTRL2	    0x4018
+#define KS8695_MEM_CTRL3	    0x401C
+#define KS8695_MEM_GENERAL	    0x4020
+#define KS8695_SDRAM_CTRL0	    0x4030
+#define KS8695_SDRAM_CTRL1	    0x4034
+#define KS8695_SDRAM_GENERAL	    0x4038
+#define KS8695_SDRAM_BUFFER	    0x403C
+#define KS8695_SDRAM_REFRESH	    0x4040
+
+/*WAN control registers offset difinitions*/
+#define KS8695_WAN_DMA_TX	    0x6000
+#define KS8695_WAN_DMA_RX	    0x6004
+#define KS8695_WAN_DMA_TX_START	    0x6008
+#define KS8695_WAN_DMA_RX_START	    0x600C
+#define KS8695_WAN_TX_LIST	    0x6010
+#define KS8695_WAN_RX_LIST	    0x6014
+#define KS8695_WAN_MAC_LOW	    0x6018
+#define KS8695_WAN_MAC_HIGH	    0x601C
+#define KS8695_WAN_MAC_ELOW	    0x6080
+#define KS8695_WAN_MAC_EHIGH	    0x6084
+
+/*LAN control registers offset difinitions*/
+#define KS8695_LAN_DMA_TX	    0x8000
+#define KS8695_LAN_DMA_RX	    0x8004
+#define KS8695_LAN_DMA_TX_START	    0x8008
+#define KS8695_LAN_DMA_RX_START	    0x800C
+#define KS8695_LAN_TX_LIST	    0x8010
+#define KS8695_LAN_RX_LIST	    0x8014
+#define KS8695_LAN_MAC_LOW	    0x8018
+#define KS8695_LAN_MAC_HIGH	    0x801C
+#define KS8695_LAN_MAC_ELOW	    0X8080
+#define KS8695_LAN_MAC_EHIGH	    0X8084
+
+/*HPNA control registers offset difinitions*/
+#define KS8695_HPNA_DMA_TX	    0xA000
+#define KS8695_HPNA_DMA_RX	    0xA004
+#define KS8695_HPNA_DMA_TX_START    0xA008
+#define KS8695_HPNA_DMA_RX_START    0xA00C
+#define KS8695_HPNA_TX_LIST	    0xA010
+#define KS8695_HPNA_RX_LIST	    0xA014
+#define KS8695_HPNA_MAC_LOW	    0xA018
+#define KS8695_HPNA_MAC_HIGH	    0xA01C
+#define KS8695_HPNA_MAC_ELOW	    0xA080
+#define KS8695_HPNA_MAC_EHIGH	    0xA084
+
+/*UART control registers offset difinitions*/
+#define KS8695_UART_RX_BUFFER	    0xE000
+#define KS8695_UART_TX_HOLDING	    0xE004
+
+#define KS8695_UART_FIFO_CTRL	    0xE008
+#define KS8695_UART_FIFO_TRIG01	    0x00
+#define KS8695_UART_FIFO_TRIG04	    0x80
+#define KS8695_UART_FIFO_TXRST	    0x03
+#define KS8695_UART_FIFO_RXRST	    0x02
+#define KS8695_UART_FIFO_FEN	    0x01
+
+#define KS8695_UART_LINE_CTRL	    0xE00C
+#define KS8695_UART_LINEC_BRK	    0x40
+#define KS8695_UART_LINEC_EPS	    0x10
+#define KS8695_UART_LINEC_PEN	    0x08
+#define KS8695_UART_LINEC_STP2	    0x04
+#define KS8695_UART_LINEC_WLEN8	    0x03
+#define KS8695_UART_LINEC_WLEN7	    0x02
+#define KS8695_UART_LINEC_WLEN6	    0x01
+#define KS8695_UART_LINEC_WLEN5	    0x00
+
+#define KS8695_UART_MODEM_CTRL	    0xE010
+#define KS8695_UART_MODEMC_RTS	    0x02
+#define KS8695_UART_MODEMC_DTR	    0x01
+
+#define KS8695_UART_LINE_STATUS	    0xE014
+#define KS8695_UART_LINES_TXFE	    0x20
+#define KS8695_UART_LINES_BE	    0x10
+#define KS8695_UART_LINES_FE	    0x08
+#define KS8695_UART_LINES_PE	    0x04
+#define KS8695_UART_LINES_OE	    0x02
+#define KS8695_UART_LINES_RXFE	    0x01
+#define KS8695_UART_LINES_ANY	    (KS8695_UART_LINES_OE|KS8695_UART_LINES_BE|KS8695_UART_LINES_PE|KS8695_UART_LINES_FE)
+
+#define KS8695_UART_MODEM_STATUS    0xE018
+#define KS8695_UART_MODEM_DCD	    0x80
+#define KS8695_UART_MODEM_DSR	    0x20
+#define KS8695_UART_MODEM_CTS	    0x10
+#define KS8695_UART_MODEM_DDCD	    0x08
+#define KS8695_UART_MODEM_DDSR	    0x02
+#define KS8695_UART_MODEM_DCTS	    0x01
+#define UART8695_MODEM_ANY	    0xFF
+
+#define KS8695_UART_DIVISOR	    0xE01C
+#define KS8695_UART_STATUS	    0xE020
+
+/*Interrupt controlller registers offset difinitions*/
+#define KS8695_INT_CONTL	    0xE200
+#define KS8695_INT_ENABLE	    0xE204
+#define KS8695_INT_ENABLE_MODEM	    0x0800
+#define KS8695_INT_ENABLE_ERR	    0x0400
+#define KS8695_INT_ENABLE_RX	    0x0200
+#define KS8695_INT_ENABLE_TX	    0x0100
+
+#define KS8695_INT_STATUS	    0xE208
+#define KS8695_INT_WAN_PRIORITY	    0xE20C
+#define KS8695_INT_HPNA_PRIORITY    0xE210
+#define KS8695_INT_LAN_PRIORITY	    0xE214
+#define KS8695_INT_TIMER_PRIORITY   0xE218
+#define KS8695_INT_UART_PRIORITY    0xE21C
+#define KS8695_INT_EXT_PRIORITY	    0xE220
+#define KS8695_INT_CHAN_PRIORITY    0xE224
+#define KS8695_INT_BUSERROR_PRO	    0xE228
+#define KS8695_INT_MASK_STATUS	    0xE22C
+#define KS8695_FIQ_PEND_PRIORITY    0xE230
+#define KS8695_IRQ_PEND_PRIORITY    0xE234
+
+/*timer registers offset difinitions*/
+#define KS8695_TIMER_CTRL	    0xE400
+#define KS8695_TIMER1		    0xE404
+#define KS8695_TIMER0		    0xE408
+#define KS8695_TIMER1_PCOUNT	    0xE40C
+#define KS8695_TIMER0_PCOUNT	    0xE410
+
+/*GPIO registers offset difinitions*/
+#define KS8695_GPIO_MODE	    0xE600
+#define KS8695_GPIO_CTRL	    0xE604
+#define KS8695_GPIO_DATA	    0xE608
+
+/*SWITCH registers offset difinitions*/
+#define KS8695_SWITCH_CTRL0	    0xE800
+#define KS8695_SWITCH_CTRL1	    0xE804
+#define KS8695_SWITCH_PORT1	    0xE808
+#define KS8695_SWITCH_PORT2	    0xE80C
+#define KS8695_SWITCH_PORT3	    0xE810
+#define KS8695_SWITCH_PORT4	    0xE814
+#define KS8695_SWITCH_PORT5	    0xE818
+#define KS8695_SWITCH_AUTO0	    0xE81C
+#define KS8695_SWITCH_AUTO1	    0xE820
+#define KS8695_SWITCH_LUE_CTRL	    0xE824
+#define KS8695_SWITCH_LUE_HIGH	    0xE828
+#define KS8695_SWITCH_LUE_LOW	    0xE82C
+#define KS8695_SWITCH_ADVANCED	    0xE830
+
+#define KS8695_SWITCH_LPPM12	    0xE874
+#define KS8695_SWITCH_LPPM34	    0xE878
+
+/*host communication registers difinitions*/
+#define KS8695_DSCP_HIGH	    0xE834
+#define KS8695_DSCP_LOW		    0xE838
+#define KS8695_SWITCH_MAC_HIGH	    0xE83C
+#define KS8695_SWITCH_MAC_LOW	    0xE840
+
+/*miscellaneours registers difinitions*/
+#define KS8695_MANAGE_COUNTER	    0xE844
+#define KS8695_MANAGE_DATA	    0xE848
+#define KS8695_LAN12_POWERMAGR	    0xE84C
+#define KS8695_LAN34_POWERMAGR	    0xE850
+
+#define KS8695_DEVICE_ID	    0xEA00
+#define KS8695_REVISION_ID	    0xEA04
+
+#define KS8695_MISC_CONTROL	    0xEA08
+#define KS8695_WAN_CONTROL	    0xEA0C
+#define KS8695_WAN_POWERMAGR	    0xEA10
+#define KS8695_WAN_PHY_CONTROL	    0xEA14
+#define KS8695_WAN_PHY_STATUS	    0xEA18
+
+/* bus clock definitions*/
+#define KS8695_BUS_CLOCK_125MHZ	    0x0
+#define KS8695_BUS_CLOCK_100MHZ	    0x1
+#define KS8695_BUS_CLOCK_62MHZ	    0x2
+#define KS8695_BUS_CLOCK_50MHZ	    0x3
+#define KS8695_BUS_CLOCK_41MHZ	    0x4
+#define KS8695_BUS_CLOCK_33MHZ	    0x5
+#define KS8695_BUS_CLOCK_31MHZ	    0x6
+#define KS8695_BUS_CLOCK_25MHZ	    0x7
+
+/* -------------------------------------------------------------------------------
+ *  definations for IRQ
+ * -------------------------------------------------------------------------------*/
+
+#define KS8695_INT_EXT_INT0		       2
+#define KS8695_INT_EXT_INT1		       3
+#define KS8695_INT_EXT_INT2		       4
+#define KS8695_INT_EXT_INT3		       5
+#define KS8695_INT_TIMERINT0		       6
+#define KS8695_INT_TIMERINT1		       7
+#define KS8695_INT_UART_TX		       8
+#define KS8695_INT_UART_RX		       9
+#define KS8695_INT_UART_LINE_ERR	       10
+#define KS8695_INT_UART_MODEMS		       11
+#define KS8695_INT_LAN_STOP_RX		       12
+#define KS8695_INT_LAN_STOP_TX		       13
+#define KS8695_INT_LAN_BUF_RX_STATUS	       14
+#define KS8695_INT_LAN_BUF_TX_STATUS	       15
+#define KS8695_INT_LAN_RX_STATUS	       16
+#define KS8695_INT_LAN_TX_STATUS	       17
+#define KS8695_INT_HPAN_STOP_RX		       18
+#define KS8695_INT_HPNA_STOP_TX		       19
+#define KS8695_INT_HPNA_BUF_RX_STATUS	       20
+#define KS8695_INT_HPNA_BUF_TX_STATUS	       21
+#define KS8695_INT_HPNA_RX_STATUS	       22
+#define KS8695_INT_HPNA_TX_STATUS	       23
+#define KS8695_INT_BUS_ERROR		       24
+#define KS8695_INT_WAN_STOP_RX		       25
+#define KS8695_INT_WAN_STOP_TX		       26
+#define KS8695_INT_WAN_BUF_RX_STATUS	       27
+#define KS8695_INT_WAN_BUF_TX_STATUS	       28
+#define KS8695_INT_WAN_RX_STATUS	       29
+#define KS8695_INT_WAN_TX_STATUS	       30
+
+#define KS8695_INT_UART			       KS8695_INT_UART_TX
+
+/* -------------------------------------------------------------------------------
+ *  Interrupt bit positions
+ *
+ * -------------------------------------------------------------------------------
+ */
+
+#define KS8695_INTMASK_EXT_INT0		       ( 1 << KS8695_INT_EXT_INT0 )
+#define KS8695_INTMASK_EXT_INT1		       ( 1 << KS8695_INT_EXT_INT1 )
+#define KS8695_INTMASK_EXT_INT2		       ( 1 << KS8695_INT_EXT_INT2 )
+#define KS8695_INTMASK_EXT_INT3		       ( 1 << KS8695_INT_EXT_INT3 )
+#define KS8695_INTMASK_TIMERINT0	       ( 1 << KS8695_INT_TIMERINT0 )
+#define KS8695_INTMASK_TIMERINT1	       ( 1 << KS8695_INT_TIMERINT1 )
+#define KS8695_INTMASK_UART_TX		       ( 1 << KS8695_INT_UART_TX  )
+#define KS8695_INTMASK_UART_RX		       ( 1 << KS8695_INT_UART_RX  )
+#define KS8695_INTMASK_UART_LINE_ERR	       ( 1 << KS8695_INT_UART_LINE_ERR )
+#define KS8695_INTMASK_UART_MODEMS	       ( 1 << KS8695_INT_UART_MODEMS )
+#define KS8695_INTMASK_LAN_STOP_RX	       ( 1 << KS8695_INT_LAN_STOP_RX )
+#define KS8695_INTMASK_LAN_STOP_TX	       ( 1 << KS8695_INT_LAN_STOP_TX )
+#define KS8695_INTMASK_LAN_BUF_RX_STATUS       ( 1 << KS8695_INT_LAN_BUF_RX_STATUS )
+#define KS8695_INTMASK_LAN_BUF_TX_STATUS       ( 1 << KS8695_INT_LAN_BUF_TX_STATUS )
+#define KS8695_INTMASK_LAN_RX_STATUS	       ( 1 << KS8695_INT_LAN_RX_STATUS )
+#define KS8695_INTMASK_LAN_TX_STATUS	       ( 1 << KS8695_INT_LAN_RX_STATUS )
+#define KS8695_INTMASK_HPAN_STOP_RX	       ( 1 << KS8695_INT_HPAN_STOP_RX )
+#define KS8695_INTMASK_HPNA_STOP_TX	       ( 1 << KS8695_INT_HPNA_STOP_TX )
+#define KS8695_INTMASK_HPNA_BUF_RX_STATUS      ( 1 << KS8695_INT_HPNA_BUF_RX_STATUS )
+#define KS8695_INTMAKS_HPNA_BUF_TX_STATUS      ( 1 << KS8695_INT_HPNA_BUF_TX_STATUS
+#define KS8695_INTMASK_HPNA_RX_STATUS	       ( 1 << KS8695_INT_HPNA_RX_STATUS )
+#define KS8695_INTMASK_HPNA_TX_STATUS	       ( 1 << KS8695_INT_HPNA_TX_STATUS )
+#define KS8695_INTMASK_BUS_ERROR	       ( 1 << KS8695_INT_BUS_ERROR )
+#define KS8695_INTMASK_WAN_STOP_RX	       ( 1 << KS8695_INT_WAN_STOP_RX )
+#define KS8695_INTMASK_WAN_STOP_TX	       ( 1 << KS8695_INT_WAN_STOP_TX )
+#define KS8695_INTMASK_WAN_BUF_RX_STATUS       ( 1 << KS8695_INT_WAN_BUF_RX_STATUS )
+#define KS8695_INTMASK_WAN_BUF_TX_STATUS       ( 1 << KS8695_INT_WAN_BUF_TX_STATUS )
+#define KS8695_INTMASK_WAN_RX_STATUS	       ( 1 << KS8695_INT_WAN_RX_STATUS )
+#define KS8695_INTMASK_WAN_TX_STATUS	       ( 1 << KS8695_INT_WAN_TX_STATUS )
+
+#define KS8695_SC_VALID_INT		       0xFFFFFFFF
+#define MAXIRQNUM			       31
+
+/*
+ *  Timer definitions
+ *
+ *  Use timer 1 & 2
+ *  (both run at 25MHz).
+ *
+ */
+#define TICKS_PER_uSEC			25
+#define mSEC_1				1000
+#define mSEC_10				(mSEC_1 * 10)
+
+#endif
+
+/*	END */
diff -Nurd u-boot-1.2.0/include/asm/arch-omap/sizes.h u-boot-1.2.0-leopard/include/asm/arch-omap/sizes.h
--- u-boot-1.2.0/include/asm/arch-omap/sizes.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-omap/sizes.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,52 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/*  Size defintions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h                       1
+
+/* handy sizes */
+#define SZ_1K                           0x00000400
+#define SZ_4K                           0x00001000
+#define SZ_8K                           0x00002000
+#define SZ_16K                          0x00004000
+#define SZ_64K                          0x00010000
+#define SZ_128K                         0x00020000
+#define SZ_256K                         0x00040000
+#define SZ_512K                         0x00080000
+
+#define SZ_1M                           0x00100000
+#define SZ_2M                           0x00200000
+#define SZ_4M                           0x00400000
+#define SZ_8M                           0x00800000
+#define SZ_16M                          0x01000000
+#define SZ_32M                          0x02000000
+#define SZ_64M                          0x04000000
+#define SZ_128M                         0x08000000
+#define SZ_256M                         0x10000000
+#define SZ_512M                         0x20000000
+
+#define SZ_1G                           0x40000000
+#define SZ_2G                           0x80000000
+
+#endif
+
+/*         END */
diff -Nurd u-boot-1.2.0/include/asm/arch-pxa/bitfield.h u-boot-1.2.0-leopard/include/asm/arch-pxa/bitfield.h
--- u-boot-1.2.0/include/asm/arch-pxa/bitfield.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-pxa/bitfield.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,112 @@
+/*
+ *	FILE    	bitfield.h
+ *
+ *	Version 	1.1
+ *	Author  	Copyright (c) Marc A. Viredaz, 1998
+ *	        	DEC Western Research Laboratory, Palo Alto, CA
+ *	Date    	April 1998 (April 1997)
+ *	System  	Advanced RISC Machine (ARM)
+ *	Language	C or ARM Assembly
+ *	Purpose 	Definition of macros to operate on bit fields.
+ */
+
+
+#ifndef __BITFIELD_H
+#define __BITFIELD_H
+
+#ifndef __ASSEMBLY__
+#define UData(Data)	((unsigned long) (Data))
+#else
+#define UData(Data)	(Data)
+#endif
+
+
+/*
+ * MACRO: Fld
+ *
+ * Purpose
+ *    The macro "Fld" encodes a bit field, given its size and its shift value
+ *    with respect to bit 0.
+ *
+ * Note
+ *    A more intuitive way to encode bit fields would have been to use their
+ *    mask. However, extracting size and shift value information from a bit
+ *    field's mask is cumbersome and might break the assembler (255-character
+ *    line-size limit).
+ *
+ * Input
+ *    Size      	Size of the bit field, in number of bits.
+ *    Shft      	Shift value of the bit field with respect to bit 0.
+ *
+ * Output
+ *    Fld       	Encoded bit field.
+ */
+
+#define Fld(Size, Shft)	(((Size) << 16) + (Shft))
+
+
+/*
+ * MACROS: FSize, FShft, FMsk, FAlnMsk, F1stBit
+ *
+ * Purpose
+ *    The macros "FSize", "FShft", "FMsk", "FAlnMsk", and "F1stBit" return
+ *    the size, shift value, mask, aligned mask, and first bit of a
+ *    bit field.
+ *
+ * Input
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FSize     	Size of the bit field, in number of bits.
+ *    FShft     	Shift value of the bit field with respect to bit 0.
+ *    FMsk      	Mask for the bit field.
+ *    FAlnMsk   	Mask for the bit field, aligned on bit 0.
+ *    F1stBit   	First bit of the bit field.
+ */
+
+#define FSize(Field)	((Field) >> 16)
+#define FShft(Field)	((Field) & 0x0000FFFF)
+#define FMsk(Field)	(((UData (1) << FSize (Field)) - 1) << FShft (Field))
+#define FAlnMsk(Field)	((UData (1) << FSize (Field)) - 1)
+#define F1stBit(Field)	(UData (1) << FShft (Field))
+
+
+/*
+ * MACRO: FInsrt
+ *
+ * Purpose
+ *    The macro "FInsrt" inserts a value into a bit field by shifting the
+ *    former appropriately.
+ *
+ * Input
+ *    Value     	Bit-field value.
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FInsrt    	Bit-field value positioned appropriately.
+ */
+
+#define FInsrt(Value, Field) \
+			(UData (Value) << FShft (Field))
+
+
+/*
+ * MACRO: FExtr
+ *
+ * Purpose
+ *    The macro "FExtr" extracts the value of a bit field by masking and
+ *    shifting it appropriately.
+ *
+ * Input
+ *    Data      	Data containing the bit-field to be extracted.
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FExtr     	Bit-field value.
+ */
+
+#define FExtr(Data, Field) \
+			((UData (Data) >> FShft (Field)) & FAlnMsk (Field))
+
+
+#endif /* __BITFIELD_H */
diff -Nurd u-boot-1.2.0/include/asm/arch-pxa/hardware.h u-boot-1.2.0-leopard/include/asm/arch-pxa/hardware.h
--- u-boot-1.2.0/include/asm/arch-pxa/hardware.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-pxa/hardware.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,158 @@
+/*
+ *  linux/include/asm-arm/arch-pxa/hardware.h
+ *
+ *  Author:	Nicolas Pitre
+ *  Created:	Jun 15, 2001
+ *  Copyright:	MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Note: This file was taken from linux-2.4.19-rmk4-pxa1
+ *
+ * - 2003/01/20 implementation specifics activated
+ *   Robert Schwebel <r.schwebel@pengutronix.de>
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <linux/config.h>
+#include <asm/mach-types.h>
+
+
+/*
+ * These are statically mapped PCMCIA IO space for designs using it as a
+ * generic IO bus, typically with ISA parts, hardwired IDE interfaces, etc.
+ * The actual PCMCIA code is mapping required IO region at run time.
+ */
+#define PCMCIA_IO_0_BASE	0xf6000000
+#define PCMCIA_IO_1_BASE	0xf7000000
+
+
+/*
+ * We requires absolute addresses.
+ */
+#define PCIO_BASE		0
+
+/*
+ * Workarounds for at least 2 errata so far require this.
+ * The mapping is set in mach-pxa/generic.c.
+ */
+#define UNCACHED_PHYS_0		0xff000000
+#define UNCACHED_ADDR		UNCACHED_PHYS_0
+
+/*
+ * Intel PXA internal I/O mappings:
+ *
+ * 0x40000000 - 0x41ffffff <--> 0xf8000000 - 0xf9ffffff
+ * 0x44000000 - 0x45ffffff <--> 0xfa000000 - 0xfbffffff
+ * 0x48000000 - 0x49ffffff <--> 0xfc000000 - 0xfdffffff
+ */
+
+/* FIXME: Only this does work for u-boot... find out why... [RS] */
+#define UBOOT_REG_FIX 1
+
+#ifndef UBOOT_REG_FIX
+#ifndef __ASSEMBLY__
+
+#define io_p2v(x)	( ((x) | 0xbe000000) ^ (~((x) >> 1) & 0x06000000) )
+#define io_v2p( x )	( ((x) & 0x41ffffff) ^ ( ((x) & 0x06000000) << 1) )
+
+/*
+ * This __REG() version gives the same results as the one above,  except
+ * that we are fooling gcc somehow so it generates far better and smaller
+ * assembly code for access to contigous registers.  It's a shame that gcc
+ * doesn't guess this by itself.
+ */
+#include <asm/types.h>
+typedef struct { volatile u32 offset[4096]; } __regbase;
+# define __REGP(x)	((__regbase *)((x)&~4095))->offset[((x)&4095)>>2]
+# define __REG(x)	__REGP(io_p2v(x))
+#endif
+
+/* Let's kick gcc's ass again... */
+# define __REG2(x,y)	\
+	( __builtin_constant_p(y) ? (__REG((x) + (y))) \
+				  : (*(volatile u32 *)((u32)&__REG(x) + (y))) )
+
+# define __PREG(x)	(io_v2p((u32)&(x)))
+
+#else
+
+# define __REG(x)	io_p2v(x)
+# define __PREG(x)	io_v2p(x)
+
+# undef io_p2v
+# undef __REG
+# ifndef __ASSEMBLY__
+#  define io_p2v(PhAdd)	   (PhAdd)
+#  define __REG(x)	(*((volatile u32 *)io_p2v(x)))
+#  define __REG2(x,y)	(*(volatile u32 *)((u32)&__REG(x) + (y)))
+# else
+#  define __REG(x) (x)
+#  ifdef CONFIG_CPU_MONAHANS /* Hack to make this work with mona's pxa-regs.h */
+#   define __REG_2(x) (x)
+#   define __REG_3(x) (x)
+#  endif
+# endif
+#endif /* UBOOT_REG_FIX */
+
+#include "pxa-regs.h"
+
+#ifndef __ASSEMBLY__
+
+/*
+ * GPIO edge detection for IRQs:
+ * IRQs are generated on Falling-Edge, Rising-Edge, or both.
+ * This must be called *before* the corresponding IRQ is registered.
+ * Use this instead of directly setting GRER/GFER.
+ */
+#define GPIO_FALLING_EDGE	1
+#define GPIO_RISING_EDGE	2
+#define GPIO_BOTH_EDGES		3
+extern void set_GPIO_IRQ_edge( int gpio_nr, int edge_mask );
+
+/*
+ * Handy routine to set GPIO alternate functions
+ */
+extern void set_GPIO_mode( int gpio_mode );
+
+/*
+ * return current lclk frequency in units of 10kHz
+ */
+extern unsigned int get_lclk_frequency_10khz(void);
+
+#endif
+
+
+/*
+ * Implementation specifics
+ */
+
+#ifdef CONFIG_ARCH_LUBBOCK
+#include "lubbock.h"
+#endif
+
+#ifdef CONFIG_ARCH_PXA_IDP
+#include "idp.h"
+#endif
+
+#ifdef CONFIG_ARCH_PXA_CERF
+#include "cerf.h"
+#endif
+
+#ifdef CONFIG_ARCH_CSB226
+#include "csb226.h"
+#endif
+
+#ifdef CONFIG_ARCH_INNOKOM
+#include "innokom.h"
+#endif
+
+#ifdef CONFIG_ARCH_PLEB
+#include "pleb.h"
+#endif
+
+#endif	/* _ASM_ARCH_HARDWARE_H */
diff -Nurd u-boot-1.2.0/include/asm/arch-pxa/mmc.h u-boot-1.2.0-leopard/include/asm/arch-pxa/mmc.h
--- u-boot-1.2.0/include/asm/arch-pxa/mmc.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-pxa/mmc.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,200 @@
+/*
+ *  linux/drivers/mmc/mmc_pxa.h
+ *
+ *  Author: Vladimir Shebordaev, Igor Oblakov
+ *  Copyright:  MontaVista Software Inc.
+ *
+ *  $Id: mmc_pxa.h,v 0.3.1.6 2002/09/25 19:25:48 ted Exp ted $
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+#ifndef __MMC_PXA_P_H__
+#define __MMC_PXA_P_H__
+
+/* PXA-250 MMC controller registers */
+
+/* MMC_STRPCL */
+#define MMC_STRPCL_STOP_CLK     	(0x0001UL)
+#define MMC_STRPCL_START_CLK		(0x0002UL)
+
+/* MMC_STAT */
+#define MMC_STAT_END_CMD_RES		(0x0001UL << 13)
+#define MMC_STAT_PRG_DONE       	(0x0001UL << 12)
+#define MMC_STAT_DATA_TRAN_DONE     	(0x0001UL << 11)
+#define MMC_STAT_CLK_EN	 		(0x0001UL << 8)
+#define MMC_STAT_RECV_FIFO_FULL     	(0x0001UL << 7)
+#define MMC_STAT_XMIT_FIFO_EMPTY    	(0x0001UL << 6)
+#define MMC_STAT_RES_CRC_ERROR      	(0x0001UL << 5)
+#define MMC_STAT_SPI_READ_ERROR_TOKEN   (0x0001UL << 4)
+#define MMC_STAT_CRC_READ_ERROR     	(0x0001UL << 3)
+#define MMC_STAT_CRC_WRITE_ERROR    	(0x0001UL << 2)
+#define MMC_STAT_TIME_OUT_RESPONSE  	(0x0001UL << 1)
+#define MMC_STAT_READ_TIME_OUT      	(0x0001UL)
+
+#define MMC_STAT_ERRORS (MMC_STAT_RES_CRC_ERROR|MMC_STAT_SPI_READ_ERROR_TOKEN\
+	|MMC_STAT_CRC_READ_ERROR|MMC_STAT_TIME_OUT_RESPONSE\
+	|MMC_STAT_READ_TIME_OUT|MMC_STAT_CRC_WRITE_ERROR)
+
+/* MMC_CLKRT */
+#define MMC_CLKRT_20MHZ	 		(0x0000UL)
+#define MMC_CLKRT_10MHZ	 		(0x0001UL)
+#define MMC_CLKRT_5MHZ	  		(0x0002UL)
+#define MMC_CLKRT_2_5MHZ		(0x0003UL)
+#define MMC_CLKRT_1_25MHZ       	(0x0004UL)
+#define MMC_CLKRT_0_625MHZ      	(0x0005UL)
+#define MMC_CLKRT_0_3125MHZ     	(0x0006UL)
+
+/* MMC_SPI */
+#define MMC_SPI_DISABLE	 		(0x00UL)
+#define MMC_SPI_EN	  		(0x01UL)
+#define MMC_SPI_CS_EN	   		(0x01UL << 2)
+#define MMC_SPI_CS_ADDRESS      	(0x01UL << 3)
+#define MMC_SPI_CRC_ON	  		(0x01UL << 1)
+
+/* MMC_CMDAT */
+#define MMC_CMDAT_MMC_DMA_EN		(0x0001UL << 7)
+#define MMC_CMDAT_INIT	  		(0x0001UL << 6)
+#define MMC_CMDAT_BUSY	  		(0x0001UL << 5)
+#define MMC_CMDAT_STREAM		(0x0001UL << 4)
+#define MMC_CMDAT_BLOCK	 		(0x0000UL << 4)
+#define MMC_CMDAT_WRITE	 		(0x0001UL << 3)
+#define MMC_CMDAT_READ	  		(0x0000UL << 3)
+#define MMC_CMDAT_DATA_EN       	(0x0001UL << 2)
+#define MMC_CMDAT_R1	    		(0x0001UL)
+#define MMC_CMDAT_R2	    		(0x0002UL)
+#define MMC_CMDAT_R3	    		(0x0003UL)
+
+/* MMC_RESTO */
+#define MMC_RES_TO_MAX	  		(0x007fUL) /* [6:0] */
+
+/* MMC_RDTO */
+#define MMC_READ_TO_MAX	 		(0x0ffffUL) /* [15:0] */
+
+/* MMC_BLKLEN */
+#define MMC_BLK_LEN_MAX	 		(0x03ffUL) /* [9:0] */
+
+/* MMC_PRTBUF */
+#define MMC_PRTBUF_BUF_PART_FULL       	(0x01UL)
+#define MMC_PRTBUF_BUF_FULL		(0x00UL    )
+
+/* MMC_I_MASK */
+#define MMC_I_MASK_TXFIFO_WR_REQ	(0x01UL << 6)
+#define MMC_I_MASK_RXFIFO_RD_REQ	(0x01UL << 5)
+#define MMC_I_MASK_CLK_IS_OFF	   	(0x01UL << 4)
+#define MMC_I_MASK_STOP_CMD	 	(0x01UL << 3)
+#define MMC_I_MASK_END_CMD_RES	  	(0x01UL << 2)
+#define MMC_I_MASK_PRG_DONE	 	(0x01UL << 1)
+#define MMC_I_MASK_DATA_TRAN_DONE       (0x01UL)
+#define MMC_I_MASK_ALL	      		(0x07fUL)
+
+
+/* MMC_I_REG */
+#define MMC_I_REG_TXFIFO_WR_REQ     	(0x01UL << 6)
+#define MMC_I_REG_RXFIFO_RD_REQ     	(0x01UL << 5)
+#define MMC_I_REG_CLK_IS_OFF		(0x01UL << 4)
+#define MMC_I_REG_STOP_CMD      	(0x01UL << 3)
+#define MMC_I_REG_END_CMD_RES       	(0x01UL << 2)
+#define MMC_I_REG_PRG_DONE      	(0x01UL << 1)
+#define MMC_I_REG_DATA_TRAN_DONE    	(0x01UL)
+#define MMC_I_REG_ALL	   		(0x007fUL)
+
+/* MMC_CMD */
+#define MMC_CMD_INDEX_MAX       	(0x006fUL)  /* [5:0] */
+#define CMD(x)  (x)
+
+#define MMC_DEFAULT_RCA			1
+
+#define MMC_BLOCK_SIZE			512
+#define MMC_CMD_RESET			0
+#define MMC_CMD_SEND_OP_COND		1
+#define MMC_CMD_ALL_SEND_CID 		2
+#define MMC_CMD_SET_RCA			3
+#define MMC_CMD_SEND_CSD 		9
+#define MMC_CMD_SEND_CID 		10
+#define MMC_CMD_SEND_STATUS		13
+#define MMC_CMD_SET_BLOCKLEN		16
+#define MMC_CMD_READ_BLOCK		17
+#define MMC_CMD_RD_BLK_MULTI		18
+#define MMC_CMD_WRITE_BLOCK		24
+
+#define MMC_MAX_BLOCK_SIZE		512
+
+#define MMC_R1_IDLE_STATE		0x01
+#define MMC_R1_ERASE_STATE		0x02
+#define MMC_R1_ILLEGAL_CMD		0x04
+#define MMC_R1_COM_CRC_ERR		0x08
+#define MMC_R1_ERASE_SEQ_ERR		0x01
+#define MMC_R1_ADDR_ERR			0x02
+#define MMC_R1_PARAM_ERR		0x04
+
+#define MMC_R1B_WP_ERASE_SKIP		0x0002
+#define MMC_R1B_ERR			0x0004
+#define MMC_R1B_CC_ERR			0x0008
+#define MMC_R1B_CARD_ECC_ERR		0x0010
+#define MMC_R1B_WP_VIOLATION		0x0020
+#define MMC_R1B_ERASE_PARAM		0x0040
+#define MMC_R1B_OOR			0x0080
+#define MMC_R1B_IDLE_STATE		0x0100
+#define MMC_R1B_ERASE_RESET		0x0200
+#define MMC_R1B_ILLEGAL_CMD		0x0400
+#define MMC_R1B_COM_CRC_ERR		0x0800
+#define MMC_R1B_ERASE_SEQ_ERR		0x1000
+#define MMC_R1B_ADDR_ERR		0x2000
+#define MMC_R1B_PARAM_ERR		0x4000
+
+typedef struct mmc_cid
+{
+/* FIXME: BYTE_ORDER */
+   uchar year:4,
+   month:4;
+   uchar sn[3];
+   uchar fwrev:4,
+   hwrev:4;
+   uchar name[6];
+   uchar id[3];
+} mmc_cid_t;
+
+typedef struct mmc_csd
+{
+	uchar	ecc:2,
+		file_format:2,
+		tmp_write_protect:1,
+		perm_write_protect:1,
+		copy:1,
+		file_format_grp:1;
+	uint64_t content_prot_app:1,
+		rsvd3:4,
+		write_bl_partial:1,
+		write_bl_len:4,
+		r2w_factor:3,
+		default_ecc:2,
+		wp_grp_enable:1,
+		wp_grp_size:5,
+		erase_grp_mult:5,
+		erase_grp_size:5,
+		c_size_mult1:3,
+		vdd_w_curr_max:3,
+		vdd_w_curr_min:3,
+		vdd_r_curr_max:3,
+		vdd_r_curr_min:3,
+		c_size:12,
+		rsvd2:2,
+		dsr_imp:1,
+		read_blk_misalign:1,
+		write_blk_misalign:1,
+		read_bl_partial:1;
+
+	ushort	read_bl_len:4,
+		ccc:12;
+	uchar	tran_speed;
+	uchar	nsac;
+	uchar	taac;
+	uchar	rsvd1:2,
+  		spec_vers:4,
+		csd_structure:2;
+} mmc_csd_t;
+
+
+#endif /* __MMC_PXA_P_H__ */
diff -Nurd u-boot-1.2.0/include/asm/arch-pxa/pxa-regs.h u-boot-1.2.0-leopard/include/asm/arch-pxa/pxa-regs.h
--- u-boot-1.2.0/include/asm/arch-pxa/pxa-regs.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-pxa/pxa-regs.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,2399 @@
+/*
+ *  linux/include/asm-arm/arch-pxa/pxa-regs.h
+ *
+ *  Author:	Nicolas Pitre
+ *  Created:	Jun 15, 2001
+ *  Copyright:	MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * - 2003/01/20: Robert Schwebel <r.schwebel@pengutronix.de
+ *   Original file taken from linux-2.4.19-rmk4-pxa1. Added some definitions.
+ *   Added include for hardware.h (for __REG definition)
+ */
+#ifndef _PXA_REGS_H_
+#define _PXA_REGS_H_
+
+#include "bitfield.h"
+#include "hardware.h"
+
+/* FIXME hack so that SA-1111.h will work [cb] */
+
+#ifndef __ASSEMBLY__
+typedef unsigned short	Word16 ;
+typedef unsigned int	Word32 ;
+typedef Word32		Word ;
+typedef Word		Quad [4] ;
+typedef void		*Address ;
+typedef void		(*ExcpHndlr) (void) ;
+#endif
+
+/*
+ * PXA Chip selects
+ */
+#ifdef CONFIG_CPU_MONAHANS
+#define PXA_CS0_PHYS   0x00000000 /* for both small and large same start */
+#define PXA_CS1_PHYS   0x04000000 /* Small partition start address (64MB) */
+#define PXA_CS1_LPHYS  0x30000000 /* Large partition start address (256MB) */
+#define PXA_CS2_PHYS   0x10000000 /* (64MB) */
+#define PXA_CS3_PHYS   0x14000000 /* (64MB) */
+#define PXA_PCMCIA_PHYS        0x20000000 /* (256MB) */
+#else
+#define PXA_CS0_PHYS	0x00000000
+#define PXA_CS1_PHYS	0x04000000
+#define PXA_CS2_PHYS	0x08000000
+#define PXA_CS3_PHYS	0x0C000000
+#define PXA_CS4_PHYS	0x10000000
+#define PXA_CS5_PHYS	0x14000000
+#endif /* CONFIG_CPU_MONAHANS */
+
+/*
+ * Personal Computer Memory Card International Association (PCMCIA) sockets
+ */
+#define PCMCIAPrtSp	0x04000000	/* PCMCIA Partition Space [byte]   */
+#define PCMCIASp	(4*PCMCIAPrtSp) /* PCMCIA Space [byte]		   */
+#define PCMCIAIOSp	PCMCIAPrtSp	/* PCMCIA I/O Space [byte]	   */
+#define PCMCIAAttrSp	PCMCIAPrtSp	/* PCMCIA Attribute Space [byte]   */
+#define PCMCIAMemSp	PCMCIAPrtSp	/* PCMCIA Memory Space [byte]	   */
+
+#ifndef CONFIG_CPU_MONAHANS             /* Monahans supports only one slot */
+#define PCMCIA0Sp	PCMCIASp	/* PCMCIA 0 Space [byte]	   */
+#define PCMCIA0IOSp	PCMCIAIOSp	/* PCMCIA 0 I/O Space [byte]	   */
+#define PCMCIA0AttrSp	PCMCIAAttrSp	/* PCMCIA 0 Attribute Space [byte] */
+#define PCMCIA0MemSp	PCMCIAMemSp	/* PCMCIA 0 Memory Space [byte]	   */
+#endif
+
+#define PCMCIA1Sp	PCMCIASp	/* PCMCIA 1 Space [byte]	   */
+#define PCMCIA1IOSp	PCMCIAIOSp	/* PCMCIA 1 I/O Space [byte]	   */
+#define PCMCIA1AttrSp	PCMCIAAttrSp	/* PCMCIA 1 Attribute Space [byte] */
+#define PCMCIA1MemSp	PCMCIAMemSp	/* PCMCIA 1 Memory Space [byte]	   */
+
+#define _PCMCIA(Nb)			/* PCMCIA [0..1]		   */ \
+			(0x20000000 + (Nb)*PCMCIASp)
+#define _PCMCIAIO(Nb)	_PCMCIA (Nb)	/* PCMCIA I/O [0..1]		   */
+#define _PCMCIAAttr(Nb)			/* PCMCIA Attribute [0..1]	   */ \
+			(_PCMCIA (Nb) + 2*PCMCIAPrtSp)
+#define _PCMCIAMem(Nb)			/* PCMCIA Memory [0..1]		   */ \
+			(_PCMCIA (Nb) + 3*PCMCIAPrtSp)
+
+#define _PCMCIA0	_PCMCIA (0)	/* PCMCIA 0			   */
+#define _PCMCIA0IO	_PCMCIAIO (0)	/* PCMCIA 0 I/O			   */
+#define _PCMCIA0Attr	_PCMCIAAttr (0) /* PCMCIA 0 Attribute		   */
+#define _PCMCIA0Mem	_PCMCIAMem (0)	/* PCMCIA 0 Memory		   */
+
+#ifndef CONFIG_CPU_MONAHANS             /* Monahans supports only one slot */
+#define _PCMCIA1	_PCMCIA (1)	/* PCMCIA 1			   */
+#define _PCMCIA1IO	_PCMCIAIO (1)	/* PCMCIA 1 I/O			   */
+#define _PCMCIA1Attr	_PCMCIAAttr (1) /* PCMCIA 1 Attribute		   */
+#define _PCMCIA1Mem	_PCMCIAMem (1)	/* PCMCIA 1 Memory		   */
+#endif
+
+/*
+ * DMA Controller
+ */
+#define DCSR0		__REG(0x40000000)  /* DMA Control / Status Register for Channel 0 */
+#define DCSR1		__REG(0x40000004)  /* DMA Control / Status Register for Channel 1 */
+#define DCSR2		__REG(0x40000008)  /* DMA Control / Status Register for Channel 2 */
+#define DCSR3		__REG(0x4000000c)  /* DMA Control / Status Register for Channel 3 */
+#define DCSR4		__REG(0x40000010)  /* DMA Control / Status Register for Channel 4 */
+#define DCSR5		__REG(0x40000014)  /* DMA Control / Status Register for Channel 5 */
+#define DCSR6		__REG(0x40000018)  /* DMA Control / Status Register for Channel 6 */
+#define DCSR7		__REG(0x4000001c)  /* DMA Control / Status Register for Channel 7 */
+#define DCSR8		__REG(0x40000020)  /* DMA Control / Status Register for Channel 8 */
+#define DCSR9		__REG(0x40000024)  /* DMA Control / Status Register for Channel 9 */
+#define DCSR10		__REG(0x40000028)  /* DMA Control / Status Register for Channel 10 */
+#define DCSR11		__REG(0x4000002c)  /* DMA Control / Status Register for Channel 11 */
+#define DCSR12		__REG(0x40000030)  /* DMA Control / Status Register for Channel 12 */
+#define DCSR13		__REG(0x40000034)  /* DMA Control / Status Register for Channel 13 */
+#define DCSR14		__REG(0x40000038)  /* DMA Control / Status Register for Channel 14 */
+#define DCSR15		__REG(0x4000003c)  /* DMA Control / Status Register for Channel 15 */
+#ifdef CONFIG_CPU_MONAHANS
+#define DCSR16		__REG(0x40000040)  /* DMA Control / Status Register for Channel 16 */
+#define DCSR17		__REG(0x40000044)  /* DMA Control / Status Register for Channel 17 */
+#define DCSR18		__REG(0x40000048)  /* DMA Control / Status Register for Channel 18 */
+#define DCSR19		__REG(0x4000004c)  /* DMA Control / Status Register for Channel 19 */
+#define DCSR20		__REG(0x40000050)  /* DMA Control / Status Register for Channel 20 */
+#define DCSR21		__REG(0x40000054)  /* DMA Control / Status Register for Channel 21 */
+#define DCSR22		__REG(0x40000058)  /* DMA Control / Status Register for Channel 22 */
+#define DCSR23		__REG(0x4000005c)  /* DMA Control / Status Register for Channel 23 */
+#define DCSR24		__REG(0x40000060)  /* DMA Control / Status Register for Channel 24 */
+#define DCSR25		__REG(0x40000064)  /* DMA Control / Status Register for Channel 25 */
+#define DCSR26		__REG(0x40000068)  /* DMA Control / Status Register for Channel 26 */
+#define DCSR27		__REG(0x4000006c)  /* DMA Control / Status Register for Channel 27 */
+#define DCSR28		__REG(0x40000070)  /* DMA Control / Status Register for Channel 28 */
+#define DCSR29		__REG(0x40000074)  /* DMA Control / Status Register for Channel 29 */
+#define DCSR30		__REG(0x40000078)  /* DMA Control / Status Register for Channel 30 */
+#define DCSR31		__REG(0x4000007c)  /* DMA Control / Status Register for Channel 31 */
+#endif /* CONFIG_CPU_MONAHANS */
+
+#define DCSR(x)		__REG2(0x40000000, (x) << 2)
+
+#define DCSR_RUN	(1 << 31)	/* Run Bit (read / write) */
+#define DCSR_NODESC	(1 << 30)	/* No-Descriptor Fetch (read / write) */
+#define DCSR_STOPIRQEN	(1 << 29)	/* Stop Interrupt Enable (read / write) */
+
+#if defined(CONFIG_PXA27X) || defined (CONFIG_CPU_MONAHANS)
+#define DCSR_EORIRQEN	(1 << 28)	/* End of Receive Interrupt Enable (R/W) */
+#define DCSR_EORJMPEN	(1 << 27)	/* Jump to next descriptor on EOR */
+#define DCSR_EORSTOPEN	(1 << 26)	/* STOP on an EOR */
+#define DCSR_SETCMPST	(1 << 25)	/* Set Descriptor Compare Status */
+#define DCSR_CLRCMPST	(1 << 24)	/* Clear Descriptor Compare Status */
+#define DCSR_CMPST	(1 << 10)	/* The Descriptor Compare Status */
+#define DCSR_ENRINTR	(1 << 9)	/* The end of Receive */
+#endif
+
+#define DCSR_REQPEND	(1 << 8)	/* Request Pending (read-only) */
+#define DCSR_STOPSTATE	(1 << 3)	/* Stop State (read-only) */
+#define DCSR_ENDINTR	(1 << 2)	/* End Interrupt (read / write) */
+#define DCSR_STARTINTR	(1 << 1)	/* Start Interrupt (read / write) */
+#define DCSR_BUSERR	(1 << 0)	/* Bus Error Interrupt (read / write) */
+
+#define DINT		__REG(0x400000f0)  /* DMA Interrupt Register */
+
+#define DRCMR0		__REG(0x40000100)  /* Request to Channel Map Register for DREQ 0 */
+#define DRCMR1		__REG(0x40000104)  /* Request to Channel Map Register for DREQ 1 */
+#define DRCMR2		__REG(0x40000108)  /* Request to Channel Map Register for I2S receive Request */
+#define DRCMR3		__REG(0x4000010c)  /* Request to Channel Map Register for I2S transmit Request */
+#define DRCMR4		__REG(0x40000110)  /* Request to Channel Map Register for BTUART receive Request */
+#define DRCMR5		__REG(0x40000114)  /* Request to Channel Map Register for BTUART transmit Request. */
+#define DRCMR6		__REG(0x40000118)  /* Request to Channel Map Register for FFUART receive Request */
+#define DRCMR7		__REG(0x4000011c)  /* Request to Channel Map Register for FFUART transmit Request */
+#define DRCMR8		__REG(0x40000120)  /* Request to Channel Map Register for AC97 microphone Request */
+#define DRCMR9		__REG(0x40000124)  /* Request to Channel Map Register for AC97 modem receive Request */
+#define DRCMR10		__REG(0x40000128)  /* Request to Channel Map Register for AC97 modem transmit Request */
+#define DRCMR11		__REG(0x4000012c)  /* Request to Channel Map Register for AC97 audio receive Request */
+#define DRCMR12		__REG(0x40000130)  /* Request to Channel Map Register for AC97 audio transmit Request */
+#define DRCMR13		__REG(0x40000134)  /* Request to Channel Map Register for SSP receive Request */
+#define DRCMR14		__REG(0x40000138)  /* Request to Channel Map Register for SSP transmit Request */
+#define DRCMR15		__REG(0x4000013c)  /* Reserved */
+#define DRCMR16		__REG(0x40000140)  /* Reserved */
+#define DRCMR17		__REG(0x40000144)  /* Request to Channel Map Register for ICP receive Request */
+#define DRCMR18		__REG(0x40000148)  /* Request to Channel Map Register for ICP transmit Request */
+#define DRCMR19		__REG(0x4000014c)  /* Request to Channel Map Register for STUART receive Request */
+#define DRCMR20		__REG(0x40000150)  /* Request to Channel Map Register for STUART transmit Request */
+#define DRCMR21		__REG(0x40000154)  /* Request to Channel Map Register for MMC receive Request */
+#define DRCMR22		__REG(0x40000158)  /* Request to Channel Map Register for MMC transmit Request */
+#define DRCMR23		__REG(0x4000015c)  /* Reserved */
+#define DRCMR24		__REG(0x40000160)  /* Reserved */
+#define DRCMR25		__REG(0x40000164)  /* Request to Channel Map Register for USB endpoint 1 Request */
+#define DRCMR26		__REG(0x40000168)  /* Request to Channel Map Register for USB endpoint 2 Request */
+#define DRCMR27		__REG(0x4000016C)  /* Request to Channel Map Register for USB endpoint 3 Request */
+#define DRCMR28		__REG(0x40000170)  /* Request to Channel Map Register for USB endpoint 4 Request */
+#define DRCMR29		__REG(0x40000174)  /* Reserved */
+#define DRCMR30		__REG(0x40000178)  /* Request to Channel Map Register for USB endpoint 6 Request */
+#define DRCMR31		__REG(0x4000017C)  /* Request to Channel Map Register for USB endpoint 7 Request */
+#define DRCMR32		__REG(0x40000180)  /* Request to Channel Map Register for USB endpoint 8 Request */
+#define DRCMR33		__REG(0x40000184)  /* Request to Channel Map Register for USB endpoint 9 Request */
+#define DRCMR34		__REG(0x40000188)  /* Reserved */
+#define DRCMR35		__REG(0x4000018C)  /* Request to Channel Map Register for USB endpoint 11 Request */
+#define DRCMR36		__REG(0x40000190)  /* Request to Channel Map Register for USB endpoint 12 Request */
+#define DRCMR37		__REG(0x40000194)  /* Request to Channel Map Register for USB endpoint 13 Request */
+#define DRCMR38		__REG(0x40000198)  /* Request to Channel Map Register for USB endpoint 14 Request */
+#define DRCMR39		__REG(0x4000019C)  /* Reserved */
+
+#define DRCMR68		       __REG(0x40001110)  /* Request to Channel Map Register for Camera FIFO 0 Request */
+#define DRCMR69		       __REG(0x40001114)  /* Request to Channel Map Register for Camera FIFO 1 Request */
+#define DRCMR70		       __REG(0x40001118)  /* Request to Channel Map Register for Camera FIFO 2 Request */
+
+#define DRCMRRXSADR	DRCMR2
+#define DRCMRTXSADR	DRCMR3
+#define DRCMRRXBTRBR	DRCMR4
+#define DRCMRTXBTTHR	DRCMR5
+#define DRCMRRXFFRBR	DRCMR6
+#define DRCMRTXFFTHR	DRCMR7
+#define DRCMRRXMCDR	DRCMR8
+#define DRCMRRXMODR	DRCMR9
+#define DRCMRTXMODR	DRCMR10
+#define DRCMRRXPCDR	DRCMR11
+#define DRCMRTXPCDR	DRCMR12
+#define DRCMRRXSSDR	DRCMR13
+#define DRCMRTXSSDR	DRCMR14
+#define DRCMRRXICDR	DRCMR17
+#define DRCMRTXICDR	DRCMR18
+#define DRCMRRXSTRBR	DRCMR19
+#define DRCMRTXSTTHR	DRCMR20
+#define DRCMRRXMMC	DRCMR21
+#define DRCMRTXMMC	DRCMR22
+
+#define DRCMR_MAPVLD	(1 << 7)	/* Map Valid (read / write) */
+#define DRCMR_CHLNUM	0x0f		/* mask for Channel Number (read / write) */
+
+#define DDADR0		__REG(0x40000200)  /* DMA Descriptor Address Register Channel 0 */
+#define DSADR0		__REG(0x40000204)  /* DMA Source Address Register Channel 0 */
+#define DTADR0		__REG(0x40000208)  /* DMA Target Address Register Channel 0 */
+#define DCMD0		__REG(0x4000020c)  /* DMA Command Address Register Channel 0 */
+#define DDADR1		__REG(0x40000210)  /* DMA Descriptor Address Register Channel 1 */
+#define DSADR1		__REG(0x40000214)  /* DMA Source Address Register Channel 1 */
+#define DTADR1		__REG(0x40000218)  /* DMA Target Address Register Channel 1 */
+#define DCMD1		__REG(0x4000021c)  /* DMA Command Address Register Channel 1 */
+#define DDADR2		__REG(0x40000220)  /* DMA Descriptor Address Register Channel 2 */
+#define DSADR2		__REG(0x40000224)  /* DMA Source Address Register Channel 2 */
+#define DTADR2		__REG(0x40000228)  /* DMA Target Address Register Channel 2 */
+#define DCMD2		__REG(0x4000022c)  /* DMA Command Address Register Channel 2 */
+#define DDADR3		__REG(0x40000230)  /* DMA Descriptor Address Register Channel 3 */
+#define DSADR3		__REG(0x40000234)  /* DMA Source Address Register Channel 3 */
+#define DTADR3		__REG(0x40000238)  /* DMA Target Address Register Channel 3 */
+#define DCMD3		__REG(0x4000023c)  /* DMA Command Address Register Channel 3 */
+#define DDADR4		__REG(0x40000240)  /* DMA Descriptor Address Register Channel 4 */
+#define DSADR4		__REG(0x40000244)  /* DMA Source Address Register Channel 4 */
+#define DTADR4		__REG(0x40000248)  /* DMA Target Address Register Channel 4 */
+#define DCMD4		__REG(0x4000024c)  /* DMA Command Address Register Channel 4 */
+#define DDADR5		__REG(0x40000250)  /* DMA Descriptor Address Register Channel 5 */
+#define DSADR5		__REG(0x40000254)  /* DMA Source Address Register Channel 5 */
+#define DTADR5		__REG(0x40000258)  /* DMA Target Address Register Channel 5 */
+#define DCMD5		__REG(0x4000025c)  /* DMA Command Address Register Channel 5 */
+#define DDADR6		__REG(0x40000260)  /* DMA Descriptor Address Register Channel 6 */
+#define DSADR6		__REG(0x40000264)  /* DMA Source Address Register Channel 6 */
+#define DTADR6		__REG(0x40000268)  /* DMA Target Address Register Channel 6 */
+#define DCMD6		__REG(0x4000026c)  /* DMA Command Address Register Channel 6 */
+#define DDADR7		__REG(0x40000270)  /* DMA Descriptor Address Register Channel 7 */
+#define DSADR7		__REG(0x40000274)  /* DMA Source Address Register Channel 7 */
+#define DTADR7		__REG(0x40000278)  /* DMA Target Address Register Channel 7 */
+#define DCMD7		__REG(0x4000027c)  /* DMA Command Address Register Channel 7 */
+#define DDADR8		__REG(0x40000280)  /* DMA Descriptor Address Register Channel 8 */
+#define DSADR8		__REG(0x40000284)  /* DMA Source Address Register Channel 8 */
+#define DTADR8		__REG(0x40000288)  /* DMA Target Address Register Channel 8 */
+#define DCMD8		__REG(0x4000028c)  /* DMA Command Address Register Channel 8 */
+#define DDADR9		__REG(0x40000290)  /* DMA Descriptor Address Register Channel 9 */
+#define DSADR9		__REG(0x40000294)  /* DMA Source Address Register Channel 9 */
+#define DTADR9		__REG(0x40000298)  /* DMA Target Address Register Channel 9 */
+#define DCMD9		__REG(0x4000029c)  /* DMA Command Address Register Channel 9 */
+#define DDADR10		__REG(0x400002a0)  /* DMA Descriptor Address Register Channel 10 */
+#define DSADR10		__REG(0x400002a4)  /* DMA Source Address Register Channel 10 */
+#define DTADR10		__REG(0x400002a8)  /* DMA Target Address Register Channel 10 */
+#define DCMD10		__REG(0x400002ac)  /* DMA Command Address Register Channel 10 */
+#define DDADR11		__REG(0x400002b0)  /* DMA Descriptor Address Register Channel 11 */
+#define DSADR11		__REG(0x400002b4)  /* DMA Source Address Register Channel 11 */
+#define DTADR11		__REG(0x400002b8)  /* DMA Target Address Register Channel 11 */
+#define DCMD11		__REG(0x400002bc)  /* DMA Command Address Register Channel 11 */
+#define DDADR12		__REG(0x400002c0)  /* DMA Descriptor Address Register Channel 12 */
+#define DSADR12		__REG(0x400002c4)  /* DMA Source Address Register Channel 12 */
+#define DTADR12		__REG(0x400002c8)  /* DMA Target Address Register Channel 12 */
+#define DCMD12		__REG(0x400002cc)  /* DMA Command Address Register Channel 12 */
+#define DDADR13		__REG(0x400002d0)  /* DMA Descriptor Address Register Channel 13 */
+#define DSADR13		__REG(0x400002d4)  /* DMA Source Address Register Channel 13 */
+#define DTADR13		__REG(0x400002d8)  /* DMA Target Address Register Channel 13 */
+#define DCMD13		__REG(0x400002dc)  /* DMA Command Address Register Channel 13 */
+#define DDADR14		__REG(0x400002e0)  /* DMA Descriptor Address Register Channel 14 */
+#define DSADR14		__REG(0x400002e4)  /* DMA Source Address Register Channel 14 */
+#define DTADR14		__REG(0x400002e8)  /* DMA Target Address Register Channel 14 */
+#define DCMD14		__REG(0x400002ec)  /* DMA Command Address Register Channel 14 */
+#define DDADR15		__REG(0x400002f0)  /* DMA Descriptor Address Register Channel 15 */
+#define DSADR15		__REG(0x400002f4)  /* DMA Source Address Register Channel 15 */
+#define DTADR15		__REG(0x400002f8)  /* DMA Target Address Register Channel 15 */
+#define DCMD15		__REG(0x400002fc)  /* DMA Command Address Register Channel 15 */
+
+#define DDADR(x)	__REG2(0x40000200, (x) << 4)
+#define DSADR(x)	__REG2(0x40000204, (x) << 4)
+#define DTADR(x)	__REG2(0x40000208, (x) << 4)
+#define DCMD(x)		__REG2(0x4000020c, (x) << 4)
+
+#define DDADR_DESCADDR	0xfffffff0	/* Address of next descriptor (mask) */
+#define DDADR_STOP	(1 << 0)	/* Stop (read / write) */
+
+#define DCMD_INCSRCADDR (1 << 31)	/* Source Address Increment Setting. */
+#define DCMD_INCTRGADDR (1 << 30)	/* Target Address Increment Setting. */
+#define DCMD_FLOWSRC	(1 << 29)	/* Flow Control by the source. */
+#define DCMD_FLOWTRG	(1 << 28)	/* Flow Control by the target. */
+#define DCMD_STARTIRQEN (1 << 22)	/* Start Interrupt Enable */
+#define DCMD_ENDIRQEN	(1 << 21)	/* End Interrupt Enable */
+#define DCMD_ENDIAN	(1 << 18)	/* Device Endian-ness. */
+#define DCMD_BURST8	(1 << 16)	/* 8 byte burst */
+#define DCMD_BURST16	(2 << 16)	/* 16 byte burst */
+#define DCMD_BURST32	(3 << 16)	/* 32 byte burst */
+#define DCMD_WIDTH1	(1 << 14)	/* 1 byte width */
+#define DCMD_WIDTH2	(2 << 14)	/* 2 byte width (HalfWord) */
+#define DCMD_WIDTH4	(3 << 14)	/* 4 byte width (Word) */
+#define DCMD_LENGTH	0x01fff		/* length mask (max = 8K - 1) */
+
+/* default combinations */
+#define DCMD_RXPCDR	(DCMD_INCTRGADDR|DCMD_FLOWSRC|DCMD_BURST32|DCMD_WIDTH4)
+#define DCMD_RXMCDR	(DCMD_INCTRGADDR|DCMD_FLOWSRC|DCMD_BURST32|DCMD_WIDTH4)
+#define DCMD_TXPCDR	(DCMD_INCSRCADDR|DCMD_FLOWTRG|DCMD_BURST32|DCMD_WIDTH4)
+
+/*
+ * UARTs
+ */
+/* Full Function UART (FFUART) */
+#define FFUART		FFRBR
+#define FFRBR		__REG(0x40100000)  /* Receive Buffer Register (read only) */
+#define FFTHR		__REG(0x40100000)  /* Transmit Holding Register (write only) */
+#define FFIER		__REG(0x40100004)  /* Interrupt Enable Register (read/write) */
+#define FFIIR		__REG(0x40100008)  /* Interrupt ID Register (read only) */
+#define FFFCR		__REG(0x40100008)  /* FIFO Control Register (write only) */
+#define FFLCR		__REG(0x4010000C)  /* Line Control Register (read/write) */
+#define FFMCR		__REG(0x40100010)  /* Modem Control Register (read/write) */
+#define FFLSR		__REG(0x40100014)  /* Line Status Register (read only) */
+#define FFMSR		__REG(0x40100018)  /* Modem Status Register (read only) */
+#define FFSPR		__REG(0x4010001C)  /* Scratch Pad Register (read/write) */
+#define FFISR		__REG(0x40100020)  /* Infrared Selection Register (read/write) */
+#define FFDLL		__REG(0x40100000)  /* Divisor Latch Low Register (DLAB = 1) (read/write) */
+#define FFDLH		__REG(0x40100004)  /* Divisor Latch High Register (DLAB = 1) (read/write) */
+
+/* Bluetooth UART (BTUART) */
+#define BTUART		BTRBR
+#define BTRBR		__REG(0x40200000)  /* Receive Buffer Register (read only) */
+#define BTTHR		__REG(0x40200000)  /* Transmit Holding Register (write only) */
+#define BTIER		__REG(0x40200004)  /* Interrupt Enable Register (read/write) */
+#define BTIIR		__REG(0x40200008)  /* Interrupt ID Register (read only) */
+#define BTFCR		__REG(0x40200008)  /* FIFO Control Register (write only) */
+#define BTLCR		__REG(0x4020000C)  /* Line Control Register (read/write) */
+#define BTMCR		__REG(0x40200010)  /* Modem Control Register (read/write) */
+#define BTLSR		__REG(0x40200014)  /* Line Status Register (read only) */
+#define BTMSR		__REG(0x40200018)  /* Modem Status Register (read only) */
+#define BTSPR		__REG(0x4020001C)  /* Scratch Pad Register (read/write) */
+#define BTISR		__REG(0x40200020)  /* Infrared Selection Register (read/write) */
+#define BTDLL		__REG(0x40200000)  /* Divisor Latch Low Register (DLAB = 1) (read/write) */
+#define BTDLH		__REG(0x40200004)  /* Divisor Latch High Register (DLAB = 1) (read/write) */
+
+/* Standard UART (STUART) */
+#define STUART		STRBR
+#define STRBR		__REG(0x40700000)  /* Receive Buffer Register (read only) */
+#define STTHR		__REG(0x40700000)  /* Transmit Holding Register (write only) */
+#define STIER		__REG(0x40700004)  /* Interrupt Enable Register (read/write) */
+#define STIIR		__REG(0x40700008)  /* Interrupt ID Register (read only) */
+#define STFCR		__REG(0x40700008)  /* FIFO Control Register (write only) */
+#define STLCR		__REG(0x4070000C)  /* Line Control Register (read/write) */
+#define STMCR		__REG(0x40700010)  /* Modem Control Register (read/write) */
+#define STLSR		__REG(0x40700014)  /* Line Status Register (read only) */
+#define STMSR		__REG(0x40700018)  /* Reserved */
+#define STSPR		__REG(0x4070001C)  /* Scratch Pad Register (read/write) */
+#define STISR		__REG(0x40700020)  /* Infrared Selection Register (read/write) */
+#define STDLL		__REG(0x40700000)  /* Divisor Latch Low Register (DLAB = 1) (read/write) */
+#define STDLH		__REG(0x40700004)  /* Divisor Latch High Register (DLAB = 1) (read/write) */
+
+#define IER_DMAE	(1 << 7)	/* DMA Requests Enable */
+#define IER_UUE		(1 << 6)	/* UART Unit Enable */
+#define IER_NRZE	(1 << 5)	/* NRZ coding Enable */
+#define IER_RTIOE	(1 << 4)	/* Receiver Time Out Interrupt Enable */
+#define IER_MIE		(1 << 3)	/* Modem Interrupt Enable */
+#define IER_RLSE	(1 << 2)	/* Receiver Line Status Interrupt Enable */
+#define IER_TIE		(1 << 1)	/* Transmit Data request Interrupt Enable */
+#define IER_RAVIE	(1 << 0)	/* Receiver Data Available Interrupt Enable */
+
+#define IIR_FIFOES1	(1 << 7)	/* FIFO Mode Enable Status */
+#define IIR_FIFOES0	(1 << 6)	/* FIFO Mode Enable Status */
+#define IIR_TOD		(1 << 3)	/* Time Out Detected */
+#define IIR_IID2	(1 << 2)	/* Interrupt Source Encoded */
+#define IIR_IID1	(1 << 1)	/* Interrupt Source Encoded */
+#define IIR_IP		(1 << 0)	/* Interrupt Pending (active low) */
+
+#define FCR_ITL2	(1 << 7)	/* Interrupt Trigger Level */
+#define FCR_ITL1	(1 << 6)	/* Interrupt Trigger Level */
+#define FCR_RESETTF	(1 << 2)	/* Reset Transmitter FIFO */
+#define FCR_RESETRF	(1 << 1)	/* Reset Receiver FIFO */
+#define FCR_TRFIFOE	(1 << 0)	/* Transmit and Receive FIFO Enable */
+#define FCR_ITL_1	(0)
+#define FCR_ITL_8	(FCR_ITL1)
+#define FCR_ITL_16	(FCR_ITL2)
+#define FCR_ITL_32	(FCR_ITL2|FCR_ITL1)
+
+#define LCR_DLAB	(1 << 7)	/* Divisor Latch Access Bit */
+#define LCR_SB		(1 << 6)	/* Set Break */
+#define LCR_STKYP	(1 << 5)	/* Sticky Parity */
+#define LCR_EPS		(1 << 4)	/* Even Parity Select */
+#define LCR_PEN		(1 << 3)	/* Parity Enable */
+#define LCR_STB		(1 << 2)	/* Stop Bit */
+#define LCR_WLS1	(1 << 1)	/* Word Length Select */
+#define LCR_WLS0	(1 << 0)	/* Word Length Select */
+
+#define LSR_FIFOE	(1 << 7)	/* FIFO Error Status */
+#define LSR_TEMT	(1 << 6)	/* Transmitter Empty */
+#define LSR_TDRQ	(1 << 5)	/* Transmit Data Request */
+#define LSR_BI		(1 << 4)	/* Break Interrupt */
+#define LSR_FE		(1 << 3)	/* Framing Error */
+#define LSR_PE		(1 << 2)	/* Parity Error */
+#define LSR_OE		(1 << 1)	/* Overrun Error */
+#define LSR_DR		(1 << 0)	/* Data Ready */
+
+#define MCR_LOOP	(1 << 4)	*/
+#define MCR_OUT2	(1 << 3)	/* force MSR_DCD in loopback mode */
+#define MCR_OUT1	(1 << 2)	/* force MSR_RI in loopback mode */
+#define MCR_RTS		(1 << 1)	/* Request to Send */
+#define MCR_DTR		(1 << 0)	/* Data Terminal Ready */
+
+#define MSR_DCD		(1 << 7)	/* Data Carrier Detect */
+#define MSR_RI		(1 << 6)	/* Ring Indicator */
+#define MSR_DSR		(1 << 5)	/* Data Set Ready */
+#define MSR_CTS		(1 << 4)	/* Clear To Send */
+#define MSR_DDCD	(1 << 3)	/* Delta Data Carrier Detect */
+#define MSR_TERI	(1 << 2)	/* Trailing Edge Ring Indicator */
+#define MSR_DDSR	(1 << 1)	/* Delta Data Set Ready */
+#define MSR_DCTS	(1 << 0)	/* Delta Clear To Send */
+
+/*
+ * IrSR (Infrared Selection Register)
+ */
+#define IrSR_OFFSET 0x20
+
+#define IrSR_RXPL_NEG_IS_ZERO (1<<4)
+#define IrSR_RXPL_POS_IS_ZERO 0x0
+#define IrSR_TXPL_NEG_IS_ZERO (1<<3)
+#define IrSR_TXPL_POS_IS_ZERO 0x0
+#define IrSR_XMODE_PULSE_1_6  (1<<2)
+#define IrSR_XMODE_PULSE_3_16 0x0
+#define IrSR_RCVEIR_IR_MODE   (1<<1)
+#define IrSR_RCVEIR_UART_MODE 0x0
+#define IrSR_XMITIR_IR_MODE   (1<<0)
+#define IrSR_XMITIR_UART_MODE 0x0
+
+#define IrSR_IR_RECEIVE_ON (\
+		IrSR_RXPL_NEG_IS_ZERO | \
+		IrSR_TXPL_POS_IS_ZERO | \
+		IrSR_XMODE_PULSE_3_16 | \
+		IrSR_RCVEIR_IR_MODE   | \
+		IrSR_XMITIR_UART_MODE)
+
+#define IrSR_IR_TRANSMIT_ON (\
+		IrSR_RXPL_NEG_IS_ZERO | \
+		IrSR_TXPL_POS_IS_ZERO | \
+		IrSR_XMODE_PULSE_3_16 | \
+		IrSR_RCVEIR_UART_MODE | \
+		IrSR_XMITIR_IR_MODE)
+
+/*
+ * I2C registers
+ */
+#define IBMR		__REG(0x40301680)  /* I2C Bus Monitor Register - IBMR */
+#define IDBR		__REG(0x40301688)  /* I2C Data Buffer Register - IDBR */
+#define ICR		__REG(0x40301690)  /* I2C Control Register - ICR */
+#define ISR		__REG(0x40301698)  /* I2C Status Register - ISR */
+#define ISAR		__REG(0x403016A0)  /* I2C Slave Address Register - ISAR */
+
+#define PWRIBMR		__REG(0x40f00180)  /* Power I2C Bus Monitor Register-IBMR */
+#define PWRIDBR		__REG(0x40f00188)  /* Power I2C Data Buffer Register-IDBR */
+#define PWRICR		__REG(0x40f00190)  /* Power I2C Control Register - ICR */
+#define PWRISR		__REG(0x40f00198)  /* Power I2C Status Register - ISR */
+#define PWRISAR		__REG(0x40f001A0)  /* Power I2C Slave Address Register-ISAR */
+
+/* ----- Control register bits ---------------------------------------- */
+
+#define ICR_START	0x1		/* start bit */
+#define ICR_STOP	0x2		/* stop bit */
+#define ICR_ACKNAK	0x4		/* send ACK(0) or NAK(1) */
+#define ICR_TB		0x8		/* transfer byte bit */
+#define ICR_MA		0x10		/* master abort */
+#define ICR_SCLE	0x20		/* master clock enable, mona SCLEA */
+#define ICR_IUE		0x40		/* unit enable */
+#define ICR_GCD		0x80		/* general call disable */
+#define ICR_ITEIE	0x100		/* enable tx interrupts */
+#define ICR_IRFIE	0x200		/* enable rx interrupts, mona: DRFIE */
+#define ICR_BEIE	0x400		/* enable bus error ints */
+#define ICR_SSDIE	0x800		/* slave STOP detected int enable */
+#define ICR_ALDIE	0x1000		/* enable arbitration interrupt */
+#define ICR_SADIE	0x2000		/* slave address detected int enable */
+#define ICR_UR		0x4000		/* unit reset */
+#define ICR_FM		0x8000		/* Fast Mode */
+
+/* ----- Status register bits ----------------------------------------- */
+
+#define ISR_RWM		0x1		/* read/write mode */
+#define ISR_ACKNAK	0x2		/* ack/nak status */
+#define ISR_UB		0x4		/* unit busy */
+#define ISR_IBB		0x8		/* bus busy */
+#define ISR_SSD		0x10		/* slave stop detected */
+#define ISR_ALD		0x20		/* arbitration loss detected */
+#define ISR_ITE		0x40		/* tx buffer empty */
+#define ISR_IRF		0x80		/* rx buffer full */
+#define ISR_GCAD	0x100		/* general call address detected */
+#define ISR_SAD		0x200		/* slave address detected */
+#define ISR_BED		0x400		/* bus error no ACK/NAK */
+
+/*
+ * Serial Audio Controller
+ */
+/* FIXME the audio defines collide w/ the SA1111 defines.  I don't like these
+ * short defines because there is too much chance of namespace collision
+ */
+/*#define SACR0		__REG(0x40400000)  /  Global Control Register */
+/*#define SACR1		__REG(0x40400004)  /  Serial Audio I 2 S/MSB-Justified Control Register */
+/*#define SASR0		__REG(0x4040000C)  /  Serial Audio I 2 S/MSB-Justified Interface and FIFO Status Register */
+/*#define SAIMR		__REG(0x40400014)  /  Serial Audio Interrupt Mask Register */
+/*#define SAICR		__REG(0x40400018)  /  Serial Audio Interrupt Clear Register */
+/*#define SADIV		__REG(0x40400060)  /  Audio Clock Divider Register. */
+/*#define SADR		__REG(0x40400080)  /  Serial Audio Data Register (TX and RX FIFO access Register). */
+
+
+/*
+ * AC97 Controller registers
+ */
+#define POCR		__REG(0x40500000)  /* PCM Out Control Register */
+#define POCR_FEIE	(1 << 3)	/* FIFO Error Interrupt Enable */
+
+#define PICR		__REG(0x40500004)  /* PCM In Control Register */
+#define PICR_FEIE	(1 << 3)	/* FIFO Error Interrupt Enable */
+
+#define MCCR		__REG(0x40500008)  /* Mic In Control Register */
+#define MCCR_FEIE	(1 << 3)	/* FIFO Error Interrupt Enable */
+
+#define GCR		__REG(0x4050000C)  /* Global Control Register */
+#define GCR_CDONE_IE	(1 << 19)	/* Command Done Interrupt Enable */
+#define GCR_SDONE_IE	(1 << 18)	/* Status Done Interrupt Enable */
+#define GCR_SECRDY_IEN	(1 << 9)	/* Secondary Ready Interrupt Enable */
+#define GCR_PRIRDY_IEN	(1 << 8)	/* Primary Ready Interrupt Enable */
+#define GCR_SECRES_IEN	(1 << 5)	/* Secondary Resume Interrupt Enable */
+#define GCR_PRIRES_IEN	(1 << 4)	/* Primary Resume Interrupt Enable */
+#define GCR_ACLINK_OFF	(1 << 3)	/* AC-link Shut Off */
+#define GCR_WARM_RST	(1 << 2)	/* AC97 Warm Reset */
+#define GCR_COLD_RST	(1 << 1)	/* AC'97 Cold Reset (0 = active) */
+#define GCR_GIE		(1 << 0)	/* Codec GPI Interrupt Enable */
+
+#define POSR		__REG(0x40500010)  /* PCM Out Status Register */
+#define POSR_FIFOE	(1 << 4)	/* FIFO error */
+
+#define PISR		__REG(0x40500014)  /* PCM In Status Register */
+#define PISR_FIFOE	(1 << 4)	/* FIFO error */
+
+#define MCSR		__REG(0x40500018)  /* Mic In Status Register */
+#define MCSR_FIFOE	(1 << 4)	/* FIFO error */
+
+#define GSR		__REG(0x4050001C)  /* Global Status Register */
+#define GSR_CDONE	(1 << 19)	/* Command Done */
+#define GSR_SDONE	(1 << 18)	/* Status Done */
+#define GSR_RDCS	(1 << 15)	/* Read Completion Status */
+#define GSR_BIT3SLT12	(1 << 14)	/* Bit 3 of slot 12 */
+#define GSR_BIT2SLT12	(1 << 13)	/* Bit 2 of slot 12 */
+#define GSR_BIT1SLT12	(1 << 12)	/* Bit 1 of slot 12 */
+#define GSR_SECRES	(1 << 11)	/* Secondary Resume Interrupt */
+#define GSR_PRIRES	(1 << 10)	/* Primary Resume Interrupt */
+#define GSR_SCR		(1 << 9)	/* Secondary Codec Ready */
+#define GSR_PCR		(1 << 8)	/*  Primary Codec Ready */
+#define GSR_MINT	(1 << 7)	/* Mic In Interrupt */
+#define GSR_POINT	(1 << 6)	/* PCM Out Interrupt */
+#define GSR_PIINT	(1 << 5)	/* PCM In Interrupt */
+#define GSR_MOINT	(1 << 2)	/* Modem Out Interrupt */
+#define GSR_MIINT	(1 << 1)	/* Modem In Interrupt */
+#define GSR_GSCI	(1 << 0)	/* Codec GPI Status Change Interrupt */
+
+#define CAR		__REG(0x40500020)  /* CODEC Access Register */
+#define CAR_CAIP	(1 << 0)	/* Codec Access In Progress */
+
+#define PCDR		__REG(0x40500040)  /* PCM FIFO Data Register */
+#define MCDR		__REG(0x40500060)  /* Mic-in FIFO Data Register */
+
+#define MOCR		__REG(0x40500100)  /* Modem Out Control Register */
+#define MOCR_FEIE	(1 << 3)	/* FIFO Error */
+
+#define MICR		__REG(0x40500108)  /* Modem In Control Register */
+#define MICR_FEIE	(1 << 3)	/* FIFO Error */
+
+#define MOSR		__REG(0x40500110)  /* Modem Out Status Register */
+#define MOSR_FIFOE	(1 << 4)	/* FIFO error */
+
+#define MISR		__REG(0x40500118)  /* Modem In Status Register */
+#define MISR_FIFOE	(1 << 4)	/* FIFO error */
+
+#define MODR		__REG(0x40500140)  /* Modem FIFO Data Register */
+
+#define PAC_REG_BASE	__REG(0x40500200)  /* Primary Audio Codec */
+#define SAC_REG_BASE	__REG(0x40500300)  /* Secondary Audio Codec */
+#define PMC_REG_BASE	__REG(0x40500400)  /* Primary Modem Codec */
+#define SMC_REG_BASE	__REG(0x40500500)  /* Secondary Modem Codec */
+
+/*
+ * USB Device Controller
+ */
+#define UDC_RES1	__REG(0x40600004)  /* UDC Undocumented - Reserved1 */
+#define UDC_RES2	__REG(0x40600008)  /* UDC Undocumented - Reserved2 */
+#define UDC_RES3	__REG(0x4060000C)  /* UDC Undocumented - Reserved3 */
+
+#define UDCCR		__REG(0x40600000)  /* UDC Control Register */
+#define UDCCR_UDE	(1 << 0)	/* UDC enable */
+#define UDCCR_UDA	(1 << 1)	/* UDC active */
+#define UDCCR_RSM	(1 << 2)	/* Device resume */
+#define UDCCR_RESIR	(1 << 3)	/* Resume interrupt request */
+#define UDCCR_SUSIR	(1 << 4)	/* Suspend interrupt request */
+#define UDCCR_SRM	(1 << 5)	/* Suspend/resume interrupt mask */
+#define UDCCR_RSTIR	(1 << 6)	/* Reset interrupt request */
+#define UDCCR_REM	(1 << 7)	/* Reset interrupt mask */
+
+#define UDCCS0		__REG(0x40600010)  /* UDC Endpoint 0 Control/Status Register */
+#define UDCCS0_OPR	(1 << 0)	/* OUT packet ready */
+#define UDCCS0_IPR	(1 << 1)	/* IN packet ready */
+#define UDCCS0_FTF	(1 << 2)	/* Flush Tx FIFO */
+#define UDCCS0_DRWF	(1 << 3)	/* Device remote wakeup feature */
+#define UDCCS0_SST	(1 << 4)	/* Sent stall */
+#define UDCCS0_FST	(1 << 5)	/* Force stall */
+#define UDCCS0_RNE	(1 << 6)	/* Receive FIFO no empty */
+#define UDCCS0_SA	(1 << 7)	/* Setup active */
+
+/* Bulk IN - Endpoint 1,6,11 */
+#define UDCCS1		__REG(0x40600014)  /* UDC Endpoint 1 (IN) Control/Status Register */
+#define UDCCS6		__REG(0x40600028)  /* UDC Endpoint 6 (IN) Control/Status Register */
+#define UDCCS11		__REG(0x4060003C)  /* UDC Endpoint 11 (IN) Control/Status Register */
+
+#define UDCCS_BI_TFS	(1 << 0)	/* Transmit FIFO service */
+#define UDCCS_BI_TPC	(1 << 1)	/* Transmit packet complete */
+#define UDCCS_BI_FTF	(1 << 2)	/* Flush Tx FIFO */
+#define UDCCS_BI_TUR	(1 << 3)	/* Transmit FIFO underrun */
+#define UDCCS_BI_SST	(1 << 4)	/* Sent stall */
+#define UDCCS_BI_FST	(1 << 5)	/* Force stall */
+#define UDCCS_BI_TSP	(1 << 7)	/* Transmit short packet */
+
+/* Bulk OUT - Endpoint 2,7,12 */
+#define UDCCS2		__REG(0x40600018)  /* UDC Endpoint 2 (OUT) Control/Status Register */
+#define UDCCS7		__REG(0x4060002C)  /* UDC Endpoint 7 (OUT) Control/Status Register */
+#define UDCCS12		__REG(0x40600040)  /* UDC Endpoint 12 (OUT) Control/Status Register */
+
+#define UDCCS_BO_RFS	(1 << 0)	/* Receive FIFO service */
+#define UDCCS_BO_RPC	(1 << 1)	/* Receive packet complete */
+#define UDCCS_BO_DME	(1 << 3)	/* DMA enable */
+#define UDCCS_BO_SST	(1 << 4)	/* Sent stall */
+#define UDCCS_BO_FST	(1 << 5)	/* Force stall */
+#define UDCCS_BO_RNE	(1 << 6)	/* Receive FIFO not empty */
+#define UDCCS_BO_RSP	(1 << 7)	/* Receive short packet */
+
+/* Isochronous IN - Endpoint 3,8,13 */
+#define UDCCS3		__REG(0x4060001C)  /* UDC Endpoint 3 (IN) Control/Status Register */
+#define UDCCS8		__REG(0x40600030)  /* UDC Endpoint 8 (IN) Control/Status Register */
+#define UDCCS13		__REG(0x40600044)  /* UDC Endpoint 13 (IN) Control/Status Register */
+
+#define UDCCS_II_TFS	(1 << 0)	/* Transmit FIFO service */
+#define UDCCS_II_TPC	(1 << 1)	/* Transmit packet complete */
+#define UDCCS_II_FTF	(1 << 2)	/* Flush Tx FIFO */
+#define UDCCS_II_TUR	(1 << 3)	/* Transmit FIFO underrun */
+#define UDCCS_II_TSP	(1 << 7)	/* Transmit short packet */
+
+/* Isochronous OUT - Endpoint 4,9,14 */
+#define UDCCS4		__REG(0x40600020)  /* UDC Endpoint 4 (OUT) Control/Status Register */
+#define UDCCS9		__REG(0x40600034)  /* UDC Endpoint 9 (OUT) Control/Status Register */
+#define UDCCS14		__REG(0x40600048)  /* UDC Endpoint 14 (OUT) Control/Status Register */
+
+#define UDCCS_IO_RFS	(1 << 0)	/* Receive FIFO service */
+#define UDCCS_IO_RPC	(1 << 1)	/* Receive packet complete */
+#define UDCCS_IO_ROF	(1 << 3)	/* Receive overflow */
+#define UDCCS_IO_DME	(1 << 3)	/* DMA enable */
+#define UDCCS_IO_RNE	(1 << 6)	/* Receive FIFO not empty */
+#define UDCCS_IO_RSP	(1 << 7)	/* Receive short packet */
+
+/* Interrupt IN - Endpoint 5,10,15 */
+#define UDCCS5		__REG(0x40600024)  /* UDC Endpoint 5 (Interrupt) Control/Status Register */
+#define UDCCS10		__REG(0x40600038)  /* UDC Endpoint 10 (Interrupt) Control/Status Register */
+#define UDCCS15		__REG(0x4060004C)  /* UDC Endpoint 15 (Interrupt) Control/Status Register */
+
+#define UDCCS_INT_TFS	(1 << 0)	/* Transmit FIFO service */
+#define UDCCS_INT_TPC	(1 << 1)	/* Transmit packet complete */
+#define UDCCS_INT_FTF	(1 << 2)	/* Flush Tx FIFO */
+#define UDCCS_INT_TUR	(1 << 3)	/* Transmit FIFO underrun */
+#define UDCCS_INT_SST	(1 << 4)	/* Sent stall */
+#define UDCCS_INT_FST	(1 << 5)	/* Force stall */
+#define UDCCS_INT_TSP	(1 << 7)	/* Transmit short packet */
+
+#define UFNRH		__REG(0x40600060)  /* UDC Frame Number Register High */
+#define UFNRL		__REG(0x40600064)  /* UDC Frame Number Register Low */
+#define UBCR2		__REG(0x40600068)  /* UDC Byte Count Reg 2 */
+#define UBCR4		__REG(0x4060006c)  /* UDC Byte Count Reg 4 */
+#define UBCR7		__REG(0x40600070)  /* UDC Byte Count Reg 7 */
+#define UBCR9		__REG(0x40600074)  /* UDC Byte Count Reg 9 */
+#define UBCR12		__REG(0x40600078)  /* UDC Byte Count Reg 12 */
+#define UBCR14		__REG(0x4060007c)  /* UDC Byte Count Reg 14 */
+#define UDDR0		__REG(0x40600080)  /* UDC Endpoint 0 Data Register */
+#define UDDR1		__REG(0x40600100)  /* UDC Endpoint 1 Data Register */
+#define UDDR2		__REG(0x40600180)  /* UDC Endpoint 2 Data Register */
+#define UDDR3		__REG(0x40600200)  /* UDC Endpoint 3 Data Register */
+#define UDDR4		__REG(0x40600400)  /* UDC Endpoint 4 Data Register */
+#define UDDR5		__REG(0x406000A0)  /* UDC Endpoint 5 Data Register */
+#define UDDR6		__REG(0x40600600)  /* UDC Endpoint 6 Data Register */
+#define UDDR7		__REG(0x40600680)  /* UDC Endpoint 7 Data Register */
+#define UDDR8		__REG(0x40600700)  /* UDC Endpoint 8 Data Register */
+#define UDDR9		__REG(0x40600900)  /* UDC Endpoint 9 Data Register */
+#define UDDR10		__REG(0x406000C0)  /* UDC Endpoint 10 Data Register */
+#define UDDR11		__REG(0x40600B00)  /* UDC Endpoint 11 Data Register */
+#define UDDR12		__REG(0x40600B80)  /* UDC Endpoint 12 Data Register */
+#define UDDR13		__REG(0x40600C00)  /* UDC Endpoint 13 Data Register */
+#define UDDR14		__REG(0x40600E00)  /* UDC Endpoint 14 Data Register */
+#define UDDR15		__REG(0x406000E0)  /* UDC Endpoint 15 Data Register */
+
+#define UICR0		__REG(0x40600050)  /* UDC Interrupt Control Register 0 */
+
+#define UICR0_IM0	(1 << 0)	/* Interrupt mask ep 0 */
+#define UICR0_IM1	(1 << 1)	/* Interrupt mask ep 1 */
+#define UICR0_IM2	(1 << 2)	/* Interrupt mask ep 2 */
+#define UICR0_IM3	(1 << 3)	/* Interrupt mask ep 3 */
+#define UICR0_IM4	(1 << 4)	/* Interrupt mask ep 4 */
+#define UICR0_IM5	(1 << 5)	/* Interrupt mask ep 5 */
+#define UICR0_IM6	(1 << 6)	/* Interrupt mask ep 6 */
+#define UICR0_IM7	(1 << 7)	/* Interrupt mask ep 7 */
+
+#define UICR1		__REG(0x40600054)  /* UDC Interrupt Control Register 1 */
+
+#define UICR1_IM8	(1 << 0)	/* Interrupt mask ep 8 */
+#define UICR1_IM9	(1 << 1)	/* Interrupt mask ep 9 */
+#define UICR1_IM10	(1 << 2)	/* Interrupt mask ep 10 */
+#define UICR1_IM11	(1 << 3)	/* Interrupt mask ep 11 */
+#define UICR1_IM12	(1 << 4)	/* Interrupt mask ep 12 */
+#define UICR1_IM13	(1 << 5)	/* Interrupt mask ep 13 */
+#define UICR1_IM14	(1 << 6)	/* Interrupt mask ep 14 */
+#define UICR1_IM15	(1 << 7)	/* Interrupt mask ep 15 */
+
+#define USIR0		__REG(0x40600058)  /* UDC Status Interrupt Register 0 */
+
+#define USIR0_IR0	(1 << 0)	/* Interrup request ep 0 */
+#define USIR0_IR1	(1 << 1)	/* Interrup request ep 1 */
+#define USIR0_IR2	(1 << 2)	/* Interrup request ep 2 */
+#define USIR0_IR3	(1 << 3)	/* Interrup request ep 3 */
+#define USIR0_IR4	(1 << 4)	/* Interrup request ep 4 */
+#define USIR0_IR5	(1 << 5)	/* Interrup request ep 5 */
+#define USIR0_IR6	(1 << 6)	/* Interrup request ep 6 */
+#define USIR0_IR7	(1 << 7)	/* Interrup request ep 7 */
+
+#define USIR1		__REG(0x4060005C)  /* UDC Status Interrupt Register 1 */
+
+#define USIR1_IR8	(1 << 0)	/* Interrup request ep 8 */
+#define USIR1_IR9	(1 << 1)	/* Interrup request ep 9 */
+#define USIR1_IR10	(1 << 2)	/* Interrup request ep 10 */
+#define USIR1_IR11	(1 << 3)	/* Interrup request ep 11 */
+#define USIR1_IR12	(1 << 4)	/* Interrup request ep 12 */
+#define USIR1_IR13	(1 << 5)	/* Interrup request ep 13 */
+#define USIR1_IR14	(1 << 6)	/* Interrup request ep 14 */
+#define USIR1_IR15	(1 << 7)	/* Interrup request ep 15 */
+
+#if defined(CONFIG_PXA27X)
+/*
+ * USB Host Controller
+ */
+#define UHCREV		__REG(0x4C000000)
+#define UHCHCON		__REG(0x4C000004)
+#define UHCCOMS		__REG(0x4C000008)
+#define UHCINTS		__REG(0x4C00000C)
+#define UHCINTE		__REG(0x4C000010)
+#define UHCINTD		__REG(0x4C000014)
+#define UHCHCCA		__REG(0x4C000018)
+#define UHCPCED		__REG(0x4C00001C)
+#define UHCCHED		__REG(0x4C000020)
+#define UHCCCED		__REG(0x4C000024)
+#define UHCBHED		__REG(0x4C000028)
+#define UHCBCED		__REG(0x4C00002C)
+#define UHCDHEAD	__REG(0x4C000030)
+#define UHCFMI		__REG(0x4C000034)
+#define UHCFMR		__REG(0x4C000038)
+#define UHCFMN		__REG(0x4C00003C)
+#define UHCPERS		__REG(0x4C000040)
+#define UHCLST		__REG(0x4C000044)
+#define UHCRHDA		__REG(0x4C000048)
+#define UHCRHDB		__REG(0x4C00004C)
+#define UHCRHS		__REG(0x4C000050)
+#define UHCRHPS1	__REG(0x4C000054)
+#define UHCRHPS2	__REG(0x4C000058)
+#define UHCRHPS3	__REG(0x4C00005C)
+#define UHCSTAT		__REG(0x4C000060)
+#define UHCHR		__REG(0x4C000064)
+#define UHCHIE		__REG(0x4C000068)
+#define UHCHIT		__REG(0x4C00006C)
+
+#define UHCHR_FSBIR	(1<<0)
+#define UHCHR_FHR	(1<<1)
+#define UHCHR_CGR	(1<<2)
+#define UHCHR_SSDC	(1<<3)
+#define UHCHR_UIT	(1<<4)
+#define UHCHR_SSE	(1<<5)
+#define UHCHR_PSPL	(1<<6)
+#define UHCHR_PCPL	(1<<7)
+#define UHCHR_SSEP0	(1<<9)
+#define UHCHR_SSEP1	(1<<10)
+#define UHCHR_SSEP2	(1<<11)
+
+#define UHCHIE_UPRIE	(1<<13)
+#define UHCHIE_UPS2IE	(1<<12)
+#define UHCHIE_UPS1IE	(1<<11)
+#define UHCHIE_TAIE	(1<<10)
+#define UHCHIE_HBAIE	(1<<8)
+#define UHCHIE_RWIE	(1<<7)
+
+#endif
+
+/*
+ * Fast Infrared Communication Port
+ */
+#define ICCR0		__REG(0x40800000)  /* ICP Control Register 0 */
+#define ICCR1		__REG(0x40800004)  /* ICP Control Register 1 */
+#define ICCR2		__REG(0x40800008)  /* ICP Control Register 2 */
+#define ICDR		__REG(0x4080000c)  /* ICP Data Register */
+#define ICSR0		__REG(0x40800014)  /* ICP Status Register 0 */
+#define ICSR1		__REG(0x40800018)  /* ICP Status Register 1 */
+
+/*
+ * Real Time Clock
+ */
+#define RCNR		__REG(0x40900000)  /* RTC Count Register */
+#define RTAR		__REG(0x40900004)  /* RTC Alarm Register */
+#define RTSR		__REG(0x40900008)  /* RTC Status Register */
+#define RTTR		__REG(0x4090000C)  /* RTC Timer Trim Register */
+#define RDAR1		__REG(0x40900018)  /* Wristwatch Day Alarm Reg 1 */
+#define RDAR2		__REG(0x40900020)  /* Wristwatch Day Alarm Reg 2 */
+#define RYAR1		__REG(0x4090001C)  /* Wristwatch Year Alarm Reg 1 */
+#define RYAR2		__REG(0x40900024)  /* Wristwatch Year Alarm Reg 2 */
+#define SWAR1		__REG(0x4090002C)  /* Stopwatch Alarm Register 1 */
+#define SWAR2		__REG(0x40900030)  /* Stopwatch Alarm Register 2 */
+#define PIAR		__REG(0x40900038)  /* Periodic Interrupt Alarm Register */
+#define RDCR		__REG(0x40900010)  /* RTC Day Count Register. */
+#define RYCR		__REG(0x40900014)  /* RTC Year Count Register. */
+#define SWCR		__REG(0x40900028)  /* Stopwatch Count Register */
+#define RTCPICR		__REG(0x40900034)  /* Periodic Interrupt Counter Register */
+
+#define RTSR_PICE	(1 << 15)	/* Peridoc interrupt count enable */
+#define RTSR_PIALE	(1 << 14)	/* Peridoc interrupt Alarm enable */
+#define RTSR_PIAL	(1 << 13)	/* Peridoc  interrupt Alarm status */
+#define RTSR_HZE	(1 << 3)	/* HZ interrupt enable */
+#define RTSR_ALE	(1 << 2)	/* RTC alarm interrupt enable */
+#define RTSR_HZ		(1 << 1)	/* HZ rising-edge detected */
+#define RTSR_AL		(1 << 0)	/* RTC alarm detected */
+
+/*
+ * OS Timer & Match Registers
+ */
+#define OSMR0		__REG(0x40A00000)  /* OS Timer Match Register 0 */
+#define OSMR1		__REG(0x40A00004)  /* OS Timer Match Register 1 */
+#define OSMR2		__REG(0x40A00008)  /* OS Timer Match Register 2 */
+#define OSMR3		__REG(0x40A0000C)  /* OS Timer Match Register 3 */
+#define OSCR		__REG(0x40A00010)  /* OS Timer Counter Register */
+#define OSSR		__REG(0x40A00014)  /* OS Timer Status Register */
+#define OWER		__REG(0x40A00018)  /* OS Timer Watchdog Enable Register */
+#define OIER		__REG(0x40A0001C)  /* OS Timer Interrupt Enable Register */
+
+#ifdef CONFIG_CPU_MONAHANS
+#define OSCR4		__REG(0x40A00040)  /* OS Timer Counter Register 4 */
+#define OSCR5		__REG(0x40A00044)  /* OS Timer Counter Register 5 */
+#define OSCR6		__REG(0x40A00048)  /* OS Timer Counter Register 6 */
+#define OSCR7		__REG(0x40A0004C)  /* OS Timer Counter Register 7 */
+#define OSCR8		__REG(0x40A00050)  /* OS Timer Counter Register 8 */
+#define OSCR9		__REG(0x40A00054)  /* OS Timer Counter Register 9 */
+#define OSCR10		__REG(0x40A00058)  /* OS Timer Counter Register 10 */
+#define OSCR11		__REG(0x40A0005C)  /* OS Timer Counter Register 11 */
+
+#define OSMR4		__REG(0x40A00080)  /* OS Timer Match Register 4 */
+#define OSMR5		__REG(0x40A00084)  /* OS Timer Match Register 5 */
+#define OSMR6		__REG(0x40A00088)  /* OS Timer Match Register 6 */
+#define OSMR7		__REG(0x40A0008C)  /* OS Timer Match Register 7 */
+#define OSMR8		__REG(0x40A00090)  /* OS Timer Match Register 8 */
+#define OSMR9		__REG(0x40A00094)  /* OS Timer Match Register 9 */
+#define OSMR10		__REG(0x40A00098)  /* OS Timer Match Register 10 */
+#define OSMR11		__REG(0x40A0009C)  /* OS Timer Match Register 11 */
+
+#define OMCR4		__REG(0x40A000C0)  /* OS Match Control Register 4 */
+#define OMCR5		__REG(0x40A000C4)  /* OS Match Control Register 5 */
+#define OMCR6		__REG(0x40A000C8)  /* OS Match Control Register 6 */
+#define OMCR7		__REG(0x40A000CC)  /* OS Match Control Register 7 */
+#define OMCR8		__REG(0x40A000D0)  /* OS Match Control Register 8 */
+#define OMCR9		__REG(0x40A000D4)  /* OS Match Control Register 9 */
+#define OMCR10		__REG(0x40A000D8)  /* OS Match Control Register 10 */
+#define OMCR11		__REG(0x40A000DC)  /* OS Match Control Register 11 */
+
+#define OSCR_CLK_FREQ	 3.250		   /* MHz */
+#endif /* CONFIG_CPU_MONAHANS */
+
+#define OSSR_M4		(1 << 4)	/* Match status channel 4 */
+#define OSSR_M3		(1 << 3)	/* Match status channel 3 */
+#define OSSR_M2		(1 << 2)	/* Match status channel 2 */
+#define OSSR_M1		(1 << 1)	/* Match status channel 1 */
+#define OSSR_M0		(1 << 0)	/* Match status channel 0 */
+
+#define OWER_WME	(1 << 0)	/* Watchdog Match Enable */
+
+#define OIER_E4		(1 << 4)	/* Interrupt enable channel 4 */
+#define OIER_E3		(1 << 3)	/* Interrupt enable channel 3 */
+#define OIER_E2		(1 << 2)	/* Interrupt enable channel 2 */
+#define OIER_E1		(1 << 1)	/* Interrupt enable channel 1 */
+#define OIER_E0		(1 << 0)	/* Interrupt enable channel 0 */
+
+/*
+ * Pulse Width Modulator
+ */
+#define PWM_CTRL0	__REG(0x40B00000)  /* PWM 0 Control Register */
+#define PWM_PWDUTY0	__REG(0x40B00004)  /* PWM 0 Duty Cycle Register */
+#define PWM_PERVAL0	__REG(0x40B00008)  /* PWM 0 Period Control Register */
+
+#define PWM_CTRL1	__REG(0x40C00000)  /* PWM 1Control Register */
+#define PWM_PWDUTY1	__REG(0x40C00004)  /* PWM 1 Duty Cycle Register */
+#define PWM_PERVAL1	__REG(0x40C00008)  /* PWM 1 Period Control Register */
+
+/*
+ * Interrupt Controller
+ */
+#define ICIP		__REG(0x40D00000)  /* Interrupt Controller IRQ Pending Register */
+#define ICMR		__REG(0x40D00004)  /* Interrupt Controller Mask Register */
+#define ICLR		__REG(0x40D00008)  /* Interrupt Controller Level Register */
+#define ICFP		__REG(0x40D0000C)  /* Interrupt Controller FIQ Pending Register */
+#define ICPR		__REG(0x40D00010)  /* Interrupt Controller Pending Register */
+#define ICCR		__REG(0x40D00014)  /* Interrupt Controller Control Register */
+
+#ifdef CONFIG_CPU_MONAHANS
+#define ICHP		__REG(0x40D00018)  /* Interrupt Controller Highest Priority Register */
+/* Missing: 32 Interrupt priority registers
+ * These are the same as beneath for PXA27x: maybe can be merged if
+ * GPIO Stuff is same too.
+ */
+#define ICIP2		__REG(0x40D0009C)  /* Interrupt Controller IRQ Pending Register 2 */
+#define ICMR2		__REG(0x40D000A0)  /* Interrupt Controller Mask Register 2 */
+#define ICLR2		__REG(0x40D000A4)  /* Interrupt Controller Level Register 2 */
+#define ICFP2		__REG(0x40D000A8)  /* Interrupt Controller FIQ Pending Register 2 */
+#define ICPR2		__REG(0x40D000AC)  /* Interrupt Controller Pending Register 2 */
+/* Missing: 2 Interrupt priority registers */
+#endif /* CONFIG_CPU_MONAHANS */
+
+/*
+ * General Purpose I/O
+ */
+#define GPLR0		__REG(0x40E00000)  /* GPIO Pin-Level Register GPIO<31:0> */
+#define GPLR1		__REG(0x40E00004)  /* GPIO Pin-Level Register GPIO<63:32> */
+#define GPLR2		__REG(0x40E00008)  /* GPIO Pin-Level Register GPIO<80:64> */
+
+#define GPDR0		__REG(0x40E0000C)  /* GPIO Pin Direction Register GPIO<31:0> */
+#define GPDR1		__REG(0x40E00010)  /* GPIO Pin Direction Register GPIO<63:32> */
+#define GPDR2		__REG(0x40E00014)  /* GPIO Pin Direction Register GPIO<80:64> */
+
+#define GPSR0		__REG(0x40E00018)  /* GPIO Pin Output Set Register GPIO<31:0> */
+#define GPSR1		__REG(0x40E0001C)  /* GPIO Pin Output Set Register GPIO<63:32> */
+#define GPSR2		__REG(0x40E00020)  /* GPIO Pin Output Set Register GPIO<80:64> */
+
+#define GPCR0		__REG(0x40E00024)  /* GPIO Pin Output Clear Register GPIO<31:0> */
+#define GPCR1		__REG(0x40E00028)  /* GPIO Pin Output Clear Register GPIO <63:32> */
+#define GPCR2		__REG(0x40E0002C)  /* GPIO Pin Output Clear Register GPIO <80:64> */
+
+#define GRER0		__REG(0x40E00030)  /* GPIO Rising-Edge Detect Register GPIO<31:0> */
+#define GRER1		__REG(0x40E00034)  /* GPIO Rising-Edge Detect Register GPIO<63:32> */
+#define GRER2		__REG(0x40E00038)  /* GPIO Rising-Edge Detect Register GPIO<80:64> */
+
+#define GFER0		__REG(0x40E0003C)  /* GPIO Falling-Edge Detect Register GPIO<31:0> */
+#define GFER1		__REG(0x40E00040)  /* GPIO Falling-Edge Detect Register GPIO<63:32> */
+#define GFER2		__REG(0x40E00044)  /* GPIO Falling-Edge Detect Register GPIO<80:64> */
+
+#define GEDR0		__REG(0x40E00048)  /* GPIO Edge Detect Status Register GPIO<31:0> */
+#define GEDR1		__REG(0x40E0004C)  /* GPIO Edge Detect Status Register GPIO<63:32> */
+#define GEDR2		__REG(0x40E00050)  /* GPIO Edge Detect Status Register GPIO<80:64> */
+
+#ifdef CONFIG_CPU_MONAHANS
+#define GPLR3		__REG(0x40E00100)  /* GPIO Pin-Level Register GPIO<127:96> */
+#define GPDR3		__REG(0x40E0010C)  /* GPIO Pin Direction Register GPIO<127:96> */
+#define GPSR3		__REG(0x40E00118)  /* GPIO Pin Output Set Register GPIO<127:96> */
+#define GPCR3		__REG(0x40E00124)  /* GPIO Pin Output Clear Register GPIO<127:96> */
+#define GRER3		__REG(0x40E00130)  /* GPIO Rising-Edge Detect Register GPIO<127:96> */
+#define GFER3		__REG(0x40E0013C)  /* GPIO Falling-Edge Detect Register GPIO<127:96> */
+#define GEDR3		__REG(0x40E00148)  /* GPIO Edge Detect Status Register GPIO<127:96> */
+
+#define GSDR0		__REG(0x40E00400) /* Bit-wise Set of GPDR[31:0] */
+#define GSDR1		__REG(0x40E00404) /* Bit-wise Set of GPDR[63:32] */
+#define GSDR2		__REG(0x40E00408) /* Bit-wise Set of GPDR[95:64] */
+#define GSDR3		__REG(0x40E0040C) /* Bit-wise Set of GPDR[127:96] */
+
+#define GCDR0		__REG(0x40E00420) /* Bit-wise Clear of GPDR[31:0] */
+#define GCDR1		__REG(0x40E00424) /* Bit-wise Clear of GPDR[63:32] */
+#define GCDR2		__REG(0x40E00428) /* Bit-wise Clear of GPDR[95:64] */
+#define GCDR3		__REG(0x40E0042C) /* Bit-wise Clear of GPDR[127:96] */
+
+#define GSRER0		__REG(0x40E00440) /* Set Rising Edge Det. Enable [31:0] */
+#define GSRER1		__REG(0x40E00444) /* Set Rising Edge Det. Enable [63:32] */
+#define GSRER2		__REG(0x40E00448) /* Set Rising Edge Det. Enable [95:64] */
+#define GSRER3		__REG(0x40E0044C) /* Set Rising Edge Det. Enable [127:96] */
+
+#define GCRER0		__REG(0x40E00460) /* Clear Rising Edge Det. Enable [31:0] */
+#define GCRER1		__REG(0x40E00464) /* Clear Rising Edge Det. Enable [63:32] */
+#define GCRER2		__REG(0x40E00468) /* Clear Rising Edge Det. Enable [95:64] */
+#define GCRER3		__REG(0x40E0046C) /* Clear Rising Edge Det. Enable[127:96] */
+
+#define GSFER0		__REG(0x40E00480) /* Set Falling Edge Det. Enable [31:0] */
+#define GSFER1		__REG(0x40E00484) /* Set Falling Edge Det. Enable [63:32] */
+#define GSFER2		__REG(0x40E00488) /* Set Falling Edge Det. Enable [95:64] */
+#define GSFER3		__REG(0x40E0048C) /* Set Falling Edge Det. Enable[127:96] */
+
+#define GCFER0		__REG(0x40E004A0) /* Clr Falling Edge Det. Enable [31:0] */
+#define GCFER1		__REG(0x40E004A4) /* Clr Falling Edge Det. Enable [63:32] */
+#define GCFER2		__REG(0x40E004A8) /* Clr Falling Edge Det. Enable [95:64] */
+#define GCFER3		__REG(0x40E004AC) /* Clr Falling Edge Det. Enable[127:96] */
+
+#define GSDR(x)		__REG2(0x40E00400, ((x) & 0x60) >> 3)
+#define GCDR(x)		__REG2(0x40300420, ((x) & 0x60) >> 3)
+
+/* Multi-funktion Pin Registers, uncomplete, only:
+ *    - GPIO
+ *    - Data Flash DF_* pins defined.
+ */
+#define GPIO0		__REG(0x40e10124)
+#define GPIO1		__REG(0x40e10128)
+#define GPIO2		__REG(0x40e1012c)
+#define GPIO3		__REG(0x40e10130)
+#define GPIO4		__REG(0x40e10134)
+#define nXCVREN		__REG(0x40e10138)
+
+#define DF_CLE_NOE	__REG(0x40e10204)
+#define DF_ALE_WE1	__REG(0x40e10208)
+
+#define DF_SCLK_E	__REG(0x40e10210)
+#define nBE0		__REG(0x40e10214)
+#define nBE1		__REG(0x40e10218)
+#define DF_ALE_WE2	__REG(0x40e1021c)
+#define DF_INT_RnB	__REG(0x40e10220)
+#define DF_nCS0		__REG(0x40e10224)
+#define DF_nCS1		__REG(0x40e10228)
+#define DF_nWE		__REG(0x40e1022c)
+#define DF_nRE		__REG(0x40e10230)
+#define nLUA		__REG(0x40e10234)
+#define nLLA		__REG(0x40e10238)
+#define DF_ADDR0	__REG(0x40e1023c)
+#define DF_ADDR1	__REG(0x40e10240)
+#define DF_ADDR2	__REG(0x40e10244)
+#define DF_ADDR3	__REG(0x40e10248)
+#define DF_IO0		__REG(0x40e1024c)
+#define DF_IO8		__REG(0x40e10250)
+#define DF_IO1		__REG(0x40e10254)
+#define DF_IO9		__REG(0x40e10258)
+#define DF_IO2		__REG(0x40e1025c)
+#define DF_IO10		__REG(0x40e10260)
+#define DF_IO3		__REG(0x40e10264)
+#define DF_IO11		__REG(0x40e10268)
+#define DF_IO4		__REG(0x40e1026c)
+#define DF_IO12		__REG(0x40e10270)
+#define DF_IO5		__REG(0x40e10274)
+#define DF_IO13		__REG(0x40e10278)
+#define DF_IO6		__REG(0x40e1027c)
+#define DF_IO14		__REG(0x40e10280)
+#define DF_IO7		__REG(0x40e10284)
+#define DF_IO15		__REG(0x40e10288)
+
+#define GPIO5		__REG(0x40e1028c)
+#define GPIO6		__REG(0x40e10290)
+#define GPIO7		__REG(0x40e10294)
+#define GPIO8		__REG(0x40e10298)
+#define GPIO9		__REG(0x40e1029c)
+
+#define GPIO11		__REG(0x40e102a0)
+#define GPIO12		__REG(0x40e102a4)
+#define GPIO13		__REG(0x40e102a8)
+#define GPIO14		__REG(0x40e102ac)
+#define GPIO15		__REG(0x40e102b0)
+#define GPIO16		__REG(0x40e102b4)
+#define GPIO17		__REG(0x40e102b8)
+#define GPIO18		__REG(0x40e102bc)
+#define GPIO19		__REG(0x40e102c0)
+#define GPIO20		__REG(0x40e102c4)
+#define GPIO21		__REG(0x40e102c8)
+#define GPIO22		__REG(0x40e102cc)
+#define GPIO23		__REG(0x40e102d0)
+#define GPIO24		__REG(0x40e102d4)
+#define GPIO25		__REG(0x40e102d8)
+#define GPIO26		__REG(0x40e102dc)
+
+#define GPIO27		__REG(0x40e10400)
+#define GPIO28		__REG(0x40e10404)
+#define GPIO29		__REG(0x40e10408)
+#define GPIO30		__REG(0x40e1040c)
+#define GPIO31		__REG(0x40e10410)
+#define GPIO32		__REG(0x40e10414)
+#define GPIO33		__REG(0x40e10418)
+#define GPIO34		__REG(0x40e1041c)
+#define GPIO35		__REG(0x40e10420)
+#define GPIO36		__REG(0x40e10424)
+#define GPIO37		__REG(0x40e10428)
+#define GPIO38		__REG(0x40e1042c)
+#define GPIO39		__REG(0x40e10430)
+#define GPIO40		__REG(0x40e10434)
+#define GPIO41		__REG(0x40e10438)
+#define GPIO42		__REG(0x40e1043c)
+#define GPIO43		__REG(0x40e10440)
+#define GPIO44		__REG(0x40e10444)
+#define GPIO45		__REG(0x40e10448)
+#define GPIO46		__REG(0x40e1044c)
+#define GPIO47		__REG(0x40e10450)
+#define GPIO48		__REG(0x40e10454)
+
+#define GPIO10		__REG(0x40e10458)
+
+#define GPIO49		__REG(0x40e1045c)
+#define GPIO50		__REG(0x40e10460)
+#define GPIO51		__REG(0x40e10464)
+#define GPIO52		__REG(0x40e10468)
+#define GPIO53		__REG(0x40e1046c)
+#define GPIO54		__REG(0x40e10470)
+#define GPIO55		__REG(0x40e10474)
+#define GPIO56		__REG(0x40e10478)
+#define GPIO57		__REG(0x40e1047c)
+#define GPIO58		__REG(0x40e10480)
+#define GPIO59		__REG(0x40e10484)
+#define GPIO60		__REG(0x40e10488)
+#define GPIO61		__REG(0x40e1048c)
+#define GPIO62		__REG(0x40e10490)
+
+#define GPIO6_2		__REG(0x40e10494)
+#define GPIO7_2		__REG(0x40e10498)
+#define GPIO8_2		__REG(0x40e1049c)
+#define GPIO9_2		__REG(0x40e104a0)
+#define GPIO10_2	__REG(0x40e104a4)
+#define GPIO11_2	__REG(0x40e104a8)
+#define GPIO12_2	__REG(0x40e104ac)
+#define GPIO13_2	__REG(0x40e104b0)
+
+#define GPIO63		__REG(0x40e104b4)
+#define GPIO64		__REG(0x40e104b8)
+#define GPIO65		__REG(0x40e104bc)
+#define GPIO66		__REG(0x40e104c0)
+#define GPIO67		__REG(0x40e104c4)
+#define GPIO68		__REG(0x40e104c8)
+#define GPIO69		__REG(0x40e104cc)
+#define GPIO70		__REG(0x40e104d0)
+#define GPIO71		__REG(0x40e104d4)
+#define GPIO72		__REG(0x40e104d8)
+#define GPIO73		__REG(0x40e104dc)
+
+#define GPIO14_2	__REG(0x40e104e0)
+#define GPIO15_2	__REG(0x40e104e4)
+#define GPIO16_2	__REG(0x40e104e8)
+#define GPIO17_2	__REG(0x40e104ec)
+
+#define GPIO74		__REG(0x40e104f0)
+#define GPIO75		__REG(0x40e104f4)
+#define GPIO76		__REG(0x40e104f8)
+#define GPIO77		__REG(0x40e104fc)
+#define GPIO78		__REG(0x40e10500)
+#define GPIO79		__REG(0x40e10504)
+#define GPIO80		__REG(0x40e10508)
+#define GPIO81		__REG(0x40e1050c)
+#define GPIO82		__REG(0x40e10510)
+#define GPIO83		__REG(0x40e10514)
+#define GPIO84		__REG(0x40e10518)
+#define GPIO85		__REG(0x40e1051c)
+#define GPIO86		__REG(0x40e10520)
+#define GPIO87		__REG(0x40e10524)
+#define GPIO88		__REG(0x40e10528)
+#define GPIO89		__REG(0x40e1052c)
+#define GPIO90		__REG(0x40e10530)
+#define GPIO91		__REG(0x40e10534)
+#define GPIO92		__REG(0x40e10538)
+#define GPIO93		__REG(0x40e1053c)
+#define GPIO94		__REG(0x40e10540)
+#define GPIO95		__REG(0x40e10544)
+#define GPIO96		__REG(0x40e10548)
+#define GPIO97		__REG(0x40e1054c)
+#define GPIO98		__REG(0x40e10550)
+
+#define GPIO99		__REG(0x40e10600)
+#define GPIO100		__REG(0x40e10604)
+#define GPIO101		__REG(0x40e10608)
+#define GPIO102		__REG(0x40e1060c)
+#define GPIO103		__REG(0x40e10610)
+#define GPIO104		__REG(0x40e10614)
+#define GPIO105		__REG(0x40e10618)
+#define GPIO106		__REG(0x40e1061c)
+#define GPIO107		__REG(0x40e10620)
+#define GPIO108		__REG(0x40e10624)
+#define GPIO109		__REG(0x40e10628)
+#define GPIO110		__REG(0x40e1062c)
+#define GPIO111		__REG(0x40e10630)
+#define GPIO112		__REG(0x40e10634)
+
+#define GPIO113		__REG(0x40e10638)
+#define GPIO114		__REG(0x40e1063c)
+#define GPIO115		__REG(0x40e10640)
+#define GPIO116		__REG(0x40e10644)
+#define GPIO117		__REG(0x40e10648)
+#define GPIO118		__REG(0x40e1064c)
+#define GPIO119		__REG(0x40e10650)
+#define GPIO120		__REG(0x40e10654)
+#define GPIO121		__REG(0x40e10658)
+#define GPIO122		__REG(0x40e1065c)
+#define GPIO123		__REG(0x40e10660)
+#define GPIO124		__REG(0x40e10664)
+#define GPIO125		__REG(0x40e10668)
+#define GPIO126		__REG(0x40e1066c)
+#define GPIO127		__REG(0x40e10670)
+
+#define GPIO0_2		__REG(0x40e10674)
+#define GPIO1_2		__REG(0x40e10678)
+#define GPIO2_2		__REG(0x40e1067c)
+#define GPIO3_2		__REG(0x40e10680)
+#define GPIO4_2		__REG(0x40e10684)
+#define GPIO5_2		__REG(0x40e10688)
+
+/* MFPR Bit Definitions, see 4-10, Vol. 1 */
+#define PULL_SEL	0x8000
+#define PULLUP_EN	0x4000
+#define PULLDOWN_EN	0x2000
+
+#define DRIVE_FAST_1mA	0x0
+#define DRIVE_FAST_2mA	0x400
+#define DRIVE_FAST_3mA	0x800
+#define DRIVE_FAST_4mA	0xC00
+#define DRIVE_SLOW_6mA	0x1000
+#define DRIVE_FAST_6mA	0x1400
+#define DRIVE_SLOW_10mA	0x1800
+#define DRIVE_FAST_10mA	0x1C00
+
+#define SLEEP_SEL	0x200
+#define SLEEP_DATA	0x100
+#define SLEEP_OE_N	0x80
+#define EDGE_CLEAR	0x40
+#define EDGE_FALL_EN	0x20
+#define EDGE_RISE_EN	0x10
+
+#define AF_SEL_0	0x0	/* Alternate function 0 (reset state) */
+#define AF_SEL_1	0x1	/* Alternate function 1 */
+#define AF_SEL_2	0x2	/* Alternate function 2 */
+#define AF_SEL_3	0x3	/* Alternate function 3 */
+#define AF_SEL_4	0x4	/* Alternate function 4 */
+#define AF_SEL_5	0x5	/* Alternate function 5 */
+#define AF_SEL_6	0x6	/* Alternate function 6 */
+#define AF_SEL_7	0x7	/* Alternate function 7 */
+
+
+#else /* CONFIG_CPU_MONAHANS */
+
+#define GAFR0_L		__REG(0x40E00054)  /* GPIO Alternate Function Select Register GPIO<15:0> */
+#define GAFR0_U		__REG(0x40E00058)  /* GPIO Alternate Function Select Register GPIO<31:16> */
+#define GAFR1_L		__REG(0x40E0005C)  /* GPIO Alternate Function Select Register GPIO<47:32> */
+#define GAFR1_U		__REG(0x40E00060)  /* GPIO Alternate Function Select Register GPIO<63:48> */
+#define GAFR2_L		__REG(0x40E00064)  /* GPIO Alternate Function Select Register GPIO<79:64> */
+#define GAFR2_U		__REG(0x40E00068)  /* GPIO Alternate Function Select Register GPIO 80 */
+#endif /* CONFIG_CPU_MONAHANS */
+
+/* More handy macros.  The argument is a literal GPIO number. */
+
+#define GPIO_bit(x)	(1 << ((x) & 0x1f))
+
+#ifdef CONFIG_PXA27X
+
+/* Interrupt Controller */
+
+#define ICIP2		__REG(0x40D0009C)  /* Interrupt Controller IRQ Pending Register 2 */
+#define ICMR2		__REG(0x40D000A0)  /* Interrupt Controller Mask Register 2 */
+#define ICLR2		__REG(0x40D000A4)  /* Interrupt Controller Level Register 2 */
+#define ICFP2		__REG(0x40D000A8)  /* Interrupt Controller FIQ Pending Register 2 */
+#define ICPR2		__REG(0x40D000AC)  /* Interrupt Controller Pending Register 2 */
+
+#define _GPLR(x)	__REG2(0x40E00000, ((x) & 0x60) >> 3)
+#define _GPDR(x)	__REG2(0x40E0000C, ((x) & 0x60) >> 3)
+#define _GPSR(x)	__REG2(0x40E00018, ((x) & 0x60) >> 3)
+#define _GPCR(x)	__REG2(0x40E00024, ((x) & 0x60) >> 3)
+#define _GRER(x)	__REG2(0x40E00030, ((x) & 0x60) >> 3)
+#define _GFER(x)	__REG2(0x40E0003C, ((x) & 0x60) >> 3)
+#define _GEDR(x)	__REG2(0x40E00048, ((x) & 0x60) >> 3)
+#define _GAFR(x)	__REG2(0x40E00054, ((x) & 0x70) >> 2)
+
+#define GPLR(x)		((((x) & 0x7f) < 96) ? _GPLR(x) : GPLR3)
+#define GPDR(x)		((((x) & 0x7f) < 96) ? _GPDR(x) : GPDR3)
+#define GPSR(x)		((((x) & 0x7f) < 96) ? _GPSR(x) : GPSR3)
+#define GPCR(x)		((((x) & 0x7f) < 96) ? _GPCR(x) : GPCR3)
+#define GRER(x)		((((x) & 0x7f) < 96) ? _GRER(x) : GRER3)
+#define GFER(x)		((((x) & 0x7f) < 96) ? _GFER(x) : GFER3)
+#define GEDR(x)		((((x) & 0x7f) < 96) ? _GEDR(x) : GEDR3)
+#define GAFR(x)		((((x) & 0x7f) < 96) ? _GAFR(x) : \
+			 ((((x) & 0x7f) < 112) ? GAFR3_L : GAFR3_U))
+#else
+
+#define GPLR(x)		__REG2(0x40E00000, ((x) & 0x60) >> 3)
+#define GPDR(x)		__REG2(0x40E0000C, ((x) & 0x60) >> 3)
+#define GPSR(x)		__REG2(0x40E00018, ((x) & 0x60) >> 3)
+#define GPCR(x)		__REG2(0x40E00024, ((x) & 0x60) >> 3)
+#define GRER(x)		__REG2(0x40E00030, ((x) & 0x60) >> 3)
+#define GFER(x)		__REG2(0x40E0003C, ((x) & 0x60) >> 3)
+#define GEDR(x)		__REG2(0x40E00048, ((x) & 0x60) >> 3)
+#define GAFR(x)		__REG2(0x40E00054, ((x) & 0x70) >> 2)
+
+#endif
+
+/* GPIO alternate function assignments */
+
+#define GPIO1_RST		1	/* reset */
+#define GPIO6_MMCCLK		6	/* MMC Clock */
+#define GPIO8_48MHz		7	/* 48 MHz clock output */
+#define GPIO8_MMCCS0		8	/* MMC Chip Select 0 */
+#define GPIO9_MMCCS1		9	/* MMC Chip Select 1 */
+#define GPIO10_RTCCLK		10	/* real time clock (1 Hz) */
+#define GPIO11_3_6MHz		11	/* 3.6 MHz oscillator out */
+#define GPIO12_32KHz		12	/* 32 kHz out */
+#define GPIO13_MBGNT		13	/* memory controller grant */
+#define GPIO14_MBREQ		14	/* alternate bus master request */
+#define GPIO15_nCS_1		15	/* chip select 1 */
+#define GPIO16_PWM0		16	/* PWM0 output */
+#define GPIO17_PWM1		17	/* PWM1 output */
+#define GPIO18_RDY		18	/* Ext. Bus Ready */
+#define GPIO19_DREQ1		19	/* External DMA Request */
+#define GPIO20_DREQ0		20	/* External DMA Request */
+#define GPIO23_SCLK		23	/* SSP clock */
+#define GPIO24_SFRM		24	/* SSP Frame */
+#define GPIO25_STXD		25	/* SSP transmit */
+#define GPIO26_SRXD		26	/* SSP receive */
+#define GPIO27_SEXTCLK		27	/* SSP ext_clk */
+#define GPIO28_BITCLK		28	/* AC97/I2S bit_clk */
+#define GPIO29_SDATA_IN		29	/* AC97 Sdata_in0 / I2S Sdata_in */
+#define GPIO30_SDATA_OUT	30	/* AC97/I2S Sdata_out */
+#define GPIO31_SYNC		31	/* AC97/I2S sync */
+#define GPIO32_SDATA_IN1	32	/* AC97 Sdata_in1 */
+#define GPIO33_nCS_5		33	/* chip select 5 */
+#define GPIO34_FFRXD		34	/* FFUART receive */
+#define GPIO34_MMCCS0		34	/* MMC Chip Select 0 */
+#define GPIO35_FFCTS		35	/* FFUART Clear to send */
+#define GPIO36_FFDCD		36	/* FFUART Data carrier detect */
+#define GPIO37_FFDSR		37	/* FFUART data set ready */
+#define GPIO38_FFRI		38	/* FFUART Ring Indicator */
+#define GPIO39_MMCCS1		39	/* MMC Chip Select 1 */
+#define GPIO39_FFTXD		39	/* FFUART transmit data */
+#define GPIO40_FFDTR		40	/* FFUART data terminal Ready */
+#define GPIO41_FFRTS		41	/* FFUART request to send */
+#define GPIO42_BTRXD		42	/* BTUART receive data */
+#define GPIO43_BTTXD		43	/* BTUART transmit data */
+#define GPIO44_BTCTS		44	/* BTUART clear to send */
+#define GPIO45_BTRTS		45	/* BTUART request to send */
+#define GPIO46_ICPRXD		46	/* ICP receive data */
+#define GPIO46_STRXD		46	/* STD_UART receive data */
+#define GPIO47_ICPTXD		47	/* ICP transmit data */
+#define GPIO47_STTXD		47	/* STD_UART transmit data */
+#define GPIO48_nPOE		48	/* Output Enable for Card Space */
+#define GPIO49_nPWE		49	/* Write Enable for Card Space */
+#define GPIO50_nPIOR		50	/* I/O Read for Card Space */
+#define GPIO51_nPIOW		51	/* I/O Write for Card Space */
+#define GPIO52_nPCE_1		52	/* Card Enable for Card Space */
+#define GPIO53_nPCE_2		53	/* Card Enable for Card Space */
+#define GPIO53_MMCCLK		53	/* MMC Clock */
+#define GPIO54_MMCCLK		54	/* MMC Clock */
+#define GPIO54_pSKTSEL		54	/* Socket Select for Card Space */
+#define GPIO55_nPREG		55	/* Card Address bit 26 */
+#define GPIO56_nPWAIT		56	/* Wait signal for Card Space */
+#define GPIO57_nIOIS16		57	/* Bus Width select for I/O Card Space */
+#define GPIO58_LDD_0		58	/* LCD data pin 0 */
+#define GPIO59_LDD_1		59	/* LCD data pin 1 */
+#define GPIO60_LDD_2		60	/* LCD data pin 2 */
+#define GPIO61_LDD_3		61	/* LCD data pin 3 */
+#define GPIO62_LDD_4		62	/* LCD data pin 4 */
+#define GPIO63_LDD_5		63	/* LCD data pin 5 */
+#define GPIO64_LDD_6		64	/* LCD data pin 6 */
+#define GPIO65_LDD_7		65	/* LCD data pin 7 */
+#define GPIO66_LDD_8		66	/* LCD data pin 8 */
+#define GPIO66_MBREQ		66	/* alternate bus master req */
+#define GPIO67_LDD_9		67	/* LCD data pin 9 */
+#define GPIO67_MMCCS0		67	/* MMC Chip Select 0 */
+#define GPIO68_LDD_10		68	/* LCD data pin 10 */
+#define GPIO68_MMCCS1		68	/* MMC Chip Select 1 */
+#define GPIO69_LDD_11		69	/* LCD data pin 11 */
+#define GPIO69_MMCCLK		69	/* MMC_CLK */
+#define GPIO70_LDD_12		70	/* LCD data pin 12 */
+#define GPIO70_RTCCLK		70	/* Real Time clock (1 Hz) */
+#define GPIO71_LDD_13		71	/* LCD data pin 13 */
+#define GPIO71_3_6MHz		71	/* 3.6 MHz Oscillator clock */
+#define GPIO72_LDD_14		72	/* LCD data pin 14 */
+#define GPIO72_32kHz		72	/* 32 kHz clock */
+#define GPIO73_LDD_15		73	/* LCD data pin 15 */
+#define GPIO73_MBGNT		73	/* Memory controller grant */
+#define GPIO74_LCD_FCLK		74	/* LCD Frame clock */
+#define GPIO75_LCD_LCLK		75	/* LCD line clock */
+#define GPIO76_LCD_PCLK		76	/* LCD Pixel clock */
+#define GPIO77_LCD_ACBIAS	77	/* LCD AC Bias */
+#define GPIO78_nCS_2		78	/* chip select 2 */
+#define GPIO79_nCS_3		79	/* chip select 3 */
+#define GPIO80_nCS_4		80	/* chip select 4 */
+
+/* GPIO alternate function mode & direction */
+
+#define GPIO_IN			0x000
+#define GPIO_OUT		0x080
+#define GPIO_ALT_FN_1_IN	0x100
+#define GPIO_ALT_FN_1_OUT	0x180
+#define GPIO_ALT_FN_2_IN	0x200
+#define GPIO_ALT_FN_2_OUT	0x280
+#define GPIO_ALT_FN_3_IN	0x300
+#define GPIO_ALT_FN_3_OUT	0x380
+#define GPIO_MD_MASK_NR		0x07f
+#define GPIO_MD_MASK_DIR	0x080
+#define GPIO_MD_MASK_FN		0x300
+
+#define GPIO1_RTS_MD		( 1 | GPIO_ALT_FN_1_IN)
+#define GPIO6_MMCCLK_MD		( 6 | GPIO_ALT_FN_1_OUT)
+#define GPIO8_48MHz_MD		( 8 | GPIO_ALT_FN_1_OUT)
+#define GPIO8_MMCCS0_MD		( 8 | GPIO_ALT_FN_1_OUT)
+#define GPIO9_MMCCS1_MD		( 9 | GPIO_ALT_FN_1_OUT)
+#define GPIO10_RTCCLK_MD	(10 | GPIO_ALT_FN_1_OUT)
+#define GPIO11_3_6MHz_MD	(11 | GPIO_ALT_FN_1_OUT)
+#define GPIO12_32KHz_MD		(12 | GPIO_ALT_FN_1_OUT)
+#define GPIO13_MBGNT_MD		(13 | GPIO_ALT_FN_2_OUT)
+#define GPIO14_MBREQ_MD		(14 | GPIO_ALT_FN_1_IN)
+#define GPIO15_nCS_1_MD		(15 | GPIO_ALT_FN_2_OUT)
+#define GPIO16_PWM0_MD		(16 | GPIO_ALT_FN_2_OUT)
+#define GPIO17_PWM1_MD		(17 | GPIO_ALT_FN_2_OUT)
+#define GPIO18_RDY_MD		(18 | GPIO_ALT_FN_1_IN)
+#define GPIO19_DREQ1_MD		(19 | GPIO_ALT_FN_1_IN)
+#define GPIO20_DREQ0_MD		(20 | GPIO_ALT_FN_1_IN)
+#define GPIO23_SCLK_md		(23 | GPIO_ALT_FN_2_OUT)
+#define GPIO24_SFRM_MD		(24 | GPIO_ALT_FN_2_OUT)
+#define GPIO25_STXD_MD		(25 | GPIO_ALT_FN_2_OUT)
+#define GPIO26_SRXD_MD		(26 | GPIO_ALT_FN_1_IN)
+#define GPIO27_SEXTCLK_MD	(27 | GPIO_ALT_FN_1_IN)
+#define GPIO28_BITCLK_AC97_MD	(28 | GPIO_ALT_FN_1_IN)
+#define GPIO28_BITCLK_I2S_MD	(28 | GPIO_ALT_FN_2_IN)
+#define GPIO29_SDATA_IN_AC97_MD (29 | GPIO_ALT_FN_1_IN)
+#define GPIO29_SDATA_IN_I2S_MD	(29 | GPIO_ALT_FN_2_IN)
+#define GPIO30_SDATA_OUT_AC97_MD	(30 | GPIO_ALT_FN_2_OUT)
+#define GPIO30_SDATA_OUT_I2S_MD (30 | GPIO_ALT_FN_1_OUT)
+#define GPIO31_SYNC_AC97_MD	(31 | GPIO_ALT_FN_2_OUT)
+#define GPIO31_SYNC_I2S_MD	(31 | GPIO_ALT_FN_1_OUT)
+#define GPIO32_SDATA_IN1_AC97_MD	(32 | GPIO_ALT_FN_1_IN)
+#define GPIO33_nCS_5_MD		(33 | GPIO_ALT_FN_2_OUT)
+#define GPIO34_FFRXD_MD		(34 | GPIO_ALT_FN_1_IN)
+#define GPIO34_MMCCS0_MD	(34 | GPIO_ALT_FN_2_OUT)
+#define GPIO35_FFCTS_MD		(35 | GPIO_ALT_FN_1_IN)
+#define GPIO36_FFDCD_MD		(36 | GPIO_ALT_FN_1_IN)
+#define GPIO37_FFDSR_MD		(37 | GPIO_ALT_FN_1_IN)
+#define GPIO38_FFRI_MD		(38 | GPIO_ALT_FN_1_IN)
+#define GPIO39_MMCCS1_MD	(39 | GPIO_ALT_FN_1_OUT)
+#define GPIO39_FFTXD_MD		(39 | GPIO_ALT_FN_2_OUT)
+#define GPIO40_FFDTR_MD		(40 | GPIO_ALT_FN_2_OUT)
+#define GPIO41_FFRTS_MD		(41 | GPIO_ALT_FN_2_OUT)
+#define GPIO42_BTRXD_MD		(42 | GPIO_ALT_FN_1_IN)
+#define GPIO43_BTTXD_MD		(43 | GPIO_ALT_FN_2_OUT)
+#define GPIO44_BTCTS_MD		(44 | GPIO_ALT_FN_1_IN)
+#define GPIO45_BTRTS_MD		(45 | GPIO_ALT_FN_2_OUT)
+#define GPIO46_ICPRXD_MD	(46 | GPIO_ALT_FN_1_IN)
+#define GPIO46_STRXD_MD		(46 | GPIO_ALT_FN_2_IN)
+#define GPIO47_ICPTXD_MD	(47 | GPIO_ALT_FN_2_OUT)
+#define GPIO47_STTXD_MD		(47 | GPIO_ALT_FN_1_OUT)
+#define GPIO48_nPOE_MD		(48 | GPIO_ALT_FN_2_OUT)
+#define GPIO49_nPWE_MD		(49 | GPIO_ALT_FN_2_OUT)
+#define GPIO50_nPIOR_MD		(50 | GPIO_ALT_FN_2_OUT)
+#define GPIO51_nPIOW_MD		(51 | GPIO_ALT_FN_2_OUT)
+#define GPIO52_nPCE_1_MD	(52 | GPIO_ALT_FN_2_OUT)
+#define GPIO53_nPCE_2_MD	(53 | GPIO_ALT_FN_2_OUT)
+#define GPIO53_MMCCLK_MD	(53 | GPIO_ALT_FN_1_OUT)
+#define GPIO54_MMCCLK_MD	(54 | GPIO_ALT_FN_1_OUT)
+#define GPIO54_pSKTSEL_MD	(54 | GPIO_ALT_FN_2_OUT)
+#define GPIO55_nPREG_MD		(55 | GPIO_ALT_FN_2_OUT)
+#define GPIO56_nPWAIT_MD	(56 | GPIO_ALT_FN_1_IN)
+#define GPIO57_nIOIS16_MD	(57 | GPIO_ALT_FN_1_IN)
+#define GPIO58_LDD_0_MD		(58 | GPIO_ALT_FN_2_OUT)
+#define GPIO59_LDD_1_MD		(59 | GPIO_ALT_FN_2_OUT)
+#define GPIO60_LDD_2_MD		(60 | GPIO_ALT_FN_2_OUT)
+#define GPIO61_LDD_3_MD		(61 | GPIO_ALT_FN_2_OUT)
+#define GPIO62_LDD_4_MD		(62 | GPIO_ALT_FN_2_OUT)
+#define GPIO63_LDD_5_MD		(63 | GPIO_ALT_FN_2_OUT)
+#define GPIO64_LDD_6_MD		(64 | GPIO_ALT_FN_2_OUT)
+#define GPIO65_LDD_7_MD		(65 | GPIO_ALT_FN_2_OUT)
+#define GPIO66_LDD_8_MD		(66 | GPIO_ALT_FN_2_OUT)
+#define GPIO66_MBREQ_MD		(66 | GPIO_ALT_FN_1_IN)
+#define GPIO67_LDD_9_MD		(67 | GPIO_ALT_FN_2_OUT)
+#define GPIO67_MMCCS0_MD	(67 | GPIO_ALT_FN_1_OUT)
+#define GPIO68_LDD_10_MD	(68 | GPIO_ALT_FN_2_OUT)
+#define GPIO68_MMCCS1_MD	(68 | GPIO_ALT_FN_1_OUT)
+#define GPIO69_LDD_11_MD	(69 | GPIO_ALT_FN_2_OUT)
+#define GPIO69_MMCCLK_MD	(69 | GPIO_ALT_FN_1_OUT)
+#define GPIO70_LDD_12_MD	(70 | GPIO_ALT_FN_2_OUT)
+#define GPIO70_RTCCLK_MD	(70 | GPIO_ALT_FN_1_OUT)
+#define GPIO71_LDD_13_MD	(71 | GPIO_ALT_FN_2_OUT)
+#define GPIO71_3_6MHz_MD	(71 | GPIO_ALT_FN_1_OUT)
+#define GPIO72_LDD_14_MD	(72 | GPIO_ALT_FN_2_OUT)
+#define GPIO72_32kHz_MD		(72 | GPIO_ALT_FN_1_OUT)
+#define GPIO73_LDD_15_MD	(73 | GPIO_ALT_FN_2_OUT)
+#define GPIO73_MBGNT_MD		(73 | GPIO_ALT_FN_1_OUT)
+#define GPIO74_LCD_FCLK_MD	(74 | GPIO_ALT_FN_2_OUT)
+#define GPIO75_LCD_LCLK_MD	(75 | GPIO_ALT_FN_2_OUT)
+#define GPIO76_LCD_PCLK_MD	(76 | GPIO_ALT_FN_2_OUT)
+#define GPIO77_LCD_ACBIAS_MD	(77 | GPIO_ALT_FN_2_OUT)
+#define GPIO78_nCS_2_MD		(78 | GPIO_ALT_FN_2_OUT)
+#define GPIO79_nCS_3_MD		(79 | GPIO_ALT_FN_2_OUT)
+#define GPIO80_nCS_4_MD		(80 | GPIO_ALT_FN_2_OUT)
+
+#define GPIO117_SCL		(117 | GPIO_ALT_FN_1_OUT)
+#define GPIO118_SDA		(118 | GPIO_ALT_FN_1_OUT)
+
+/*
+ * Power Manager
+ */
+#ifdef CONFIG_CPU_MONAHANS
+
+#define ASCR		__REG(0x40F40000)  /* Application Subsystem Power Status/Control Register */
+#define ARSR		__REG(0x40F40004)  /* Application Subsystem Reset Status Register */
+#define AD3ER		__REG(0x40F40008)  /* Application Subsystem D3 state Wakeup Enable Register */
+#define AD3SR		__REG(0x40F4000C)  /* Application Subsystem D3 state Wakeup Status Register */
+#define AD2D0ER		__REG(0x40F40010)  /* Application Subsystem D2 to D0 state Wakeup Enable Register */
+#define AD2D0SR		__REG(0x40F40014)  /* Application Subsystem D2 to D0 state Wakeup Status Register */
+#define AD2D1ER		__REG(0x40F40018)  /* Application Subsystem D2 to D1 state Wakeup Enable Register */
+#define AD2D1SR		__REG(0x40F4001C)  /* Application Subsystem D2 to D1 state Wakeup Status Register */
+#define AD1D0ER		__REG(0x40F40020)  /* Application Subsystem D1 to D0 state Wakeup Enable Register */
+#define AD1D0SR		__REG(0x40F40024)  /* Application Subsystem D1 to D0 state Wakeup Status Register */
+#define ASDCNT		__REG(0x40F40028)  /* Application Subsystem SRAM Drowsy Count Register */
+#define AD3R		__REG(0x40F40030)  /* Application Subsystem D3 State Configuration Register */
+#define AD2R		__REG(0x40F40034)  /* Application Subsystem D2 State Configuration Register */
+#define AD1R		__REG(0x40F40038)  /* Application Subsystem D1 State Configuration Register */
+
+#define PMCR		__REG(0x40F50000)  /* Power Manager Control Register */
+#define PSR		__REG(0x40F50004)  /* Power Manager S2 Status Register */
+#define PSPR		__REG(0x40F50008)  /* Power Manager Scratch Pad Register */
+#define PCFR		__REG(0x40F5000C)  /* Power Manager General Configuration Register */
+#define PWER		__REG(0x40F50010)  /* Power Manager Wake-up Enable Register */
+#define PWSR		__REG(0x40F50014)  /* Power Manager Wake-up Status Register */
+#define PECR		__REG(0x40F50018)  /* Power Manager EXT_WAKEUP[1:0] Control Register */
+#define DCDCSR		__REG(0x40F50080)  /* DC-DC Controller Status Register */
+#define PVCR		__REG(0x40F50100)  /* Power Manager Voltage Change Control Register */
+#define    PCMD(x) __REG(0x40F50110 + x*4)
+#define    PCMD0   __REG(0x40F50110 + 0 * 4)
+#define    PCMD1   __REG(0x40F50110 + 1 * 4)
+#define    PCMD2   __REG(0x40F50110 + 2 * 4)
+#define    PCMD3   __REG(0x40F50110 + 3 * 4)
+#define    PCMD4   __REG(0x40F50110 + 4 * 4)
+#define    PCMD5   __REG(0x40F50110 + 5 * 4)
+#define    PCMD6   __REG(0x40F50110 + 6 * 4)
+#define    PCMD7   __REG(0x40F50110 + 7 * 4)
+#define    PCMD8   __REG(0x40F50110 + 8 * 4)
+#define    PCMD9   __REG(0x40F50110 + 9 * 4)
+#define    PCMD10  __REG(0x40F50110 + 10 * 4)
+#define    PCMD11  __REG(0x40F50110 + 11 * 4)
+#define    PCMD12  __REG(0x40F50110 + 12 * 4)
+#define    PCMD13  __REG(0x40F50110 + 13 * 4)
+#define    PCMD14  __REG(0x40F50110 + 14 * 4)
+#define    PCMD15  __REG(0x40F50110 + 15 * 4)
+#define    PCMD16  __REG(0x40F50110 + 16 * 4)
+#define    PCMD17  __REG(0x40F50110 + 17 * 4)
+#define    PCMD18  __REG(0x40F50110 + 18 * 4)
+#define    PCMD19  __REG(0x40F50110 + 19 * 4)
+#define    PCMD20  __REG(0x40F50110 + 20 * 4)
+#define    PCMD21  __REG(0x40F50110 + 21 * 4)
+#define    PCMD22  __REG(0x40F50110 + 22 * 4)
+#define    PCMD23  __REG(0x40F50110 + 23 * 4)
+#define    PCMD24  __REG(0x40F50110 + 24 * 4)
+#define    PCMD25  __REG(0x40F50110 + 25 * 4)
+#define    PCMD26  __REG(0x40F50110 + 26 * 4)
+#define    PCMD27  __REG(0x40F50110 + 27 * 4)
+#define    PCMD28  __REG(0x40F50110 + 28 * 4)
+#define    PCMD29  __REG(0x40F50110 + 29 * 4)
+#define    PCMD30  __REG(0x40F50110 + 30 * 4)
+#define    PCMD31  __REG(0x40F50110 + 31 * 4)
+
+#define    PCMD_MBC    (1<<12)
+#define    PCMD_DCE    (1<<11)
+#define    PCMD_LC     (1<<10)
+#define    PCMD_SQC    (3<<8)  /* only 00 and 01 are valid */
+
+#define PVCR_FVC                   (0x1 << 28)
+#define PVCR_VCSA                  (0x1<<14)
+#define PVCR_CommandDelay          (0xf80)
+#define PVCR_ReadPointer           (0x01f00000)
+#define PVCR_SlaveAddress          (0x7f)
+
+#else /* ifdef CONFIG_CPU_MONAHANS */
+
+#define PMCR		__REG(0x40F00000)  /* Power Manager Control Register */
+#define PSSR		__REG(0x40F00004)  /* Power Manager Sleep Status Register */
+#define PSPR		__REG(0x40F00008)  /* Power Manager Scratch Pad Register */
+#define PWER		__REG(0x40F0000C)  /* Power Manager Wake-up Enable Register */
+#define PRER		__REG(0x40F00010)  /* Power Manager GPIO Rising-Edge Detect Enable Register */
+#define PFER		__REG(0x40F00014)  /* Power Manager GPIO Falling-Edge Detect Enable Register */
+#define PEDR		__REG(0x40F00018)  /* Power Manager GPIO Edge Detect Status Register */
+#define PCFR		__REG(0x40F0001C)  /* Power Manager General Configuration Register */
+#define PGSR0		__REG(0x40F00020)  /* Power Manager GPIO Sleep State Register for GP[31-0] */
+#define PGSR1		__REG(0x40F00024)  /* Power Manager GPIO Sleep State Register for GP[63-32] */
+#define PGSR2		__REG(0x40F00028)  /* Power Manager GPIO Sleep State Register for GP[84-64] */
+#define PGSR3		__REG(0x40F0002C)  /* Power Manager GPIO Sleep State Register for GP[118-96] */
+#define RCSR		__REG(0x40F00030)  /* Reset Controller Status Register */
+
+#define	   PSLR	   __REG(0x40F00034)	/* Power Manager Sleep Config Register */
+#define	   PSTR	   __REG(0x40F00038)	/* Power Manager Standby Config Register */
+#define	   PSNR	   __REG(0x40F0003C)	/* Power Manager Sense Config Register */
+#define	   PVCR	   __REG(0x40F00040)	/* Power Manager VoltageControl Register */
+#define	   PKWR	   __REG(0x40F00050)	/* Power Manager KB Wake-up Enable Reg */
+#define	   PKSR	   __REG(0x40F00054)	/* Power Manager KB Level-Detect Register */
+#define	   PCMD(x) __REG(0x40F00080 + x*4)
+#define	   PCMD0   __REG(0x40F00080 + 0 * 4)
+#define	   PCMD1   __REG(0x40F00080 + 1 * 4)
+#define	   PCMD2   __REG(0x40F00080 + 2 * 4)
+#define	   PCMD3   __REG(0x40F00080 + 3 * 4)
+#define	   PCMD4   __REG(0x40F00080 + 4 * 4)
+#define	   PCMD5   __REG(0x40F00080 + 5 * 4)
+#define	   PCMD6   __REG(0x40F00080 + 6 * 4)
+#define	   PCMD7   __REG(0x40F00080 + 7 * 4)
+#define	   PCMD8   __REG(0x40F00080 + 8 * 4)
+#define	   PCMD9   __REG(0x40F00080 + 9 * 4)
+#define	   PCMD10  __REG(0x40F00080 + 10 * 4)
+#define	   PCMD11  __REG(0x40F00080 + 11 * 4)
+#define	   PCMD12  __REG(0x40F00080 + 12 * 4)
+#define	   PCMD13  __REG(0x40F00080 + 13 * 4)
+#define	   PCMD14  __REG(0x40F00080 + 14 * 4)
+#define	   PCMD15  __REG(0x40F00080 + 15 * 4)
+#define	   PCMD16  __REG(0x40F00080 + 16 * 4)
+#define	   PCMD17  __REG(0x40F00080 + 17 * 4)
+#define	   PCMD18  __REG(0x40F00080 + 18 * 4)
+#define	   PCMD19  __REG(0x40F00080 + 19 * 4)
+#define	   PCMD20  __REG(0x40F00080 + 20 * 4)
+#define	   PCMD21  __REG(0x40F00080 + 21 * 4)
+#define	   PCMD22  __REG(0x40F00080 + 22 * 4)
+#define	   PCMD23  __REG(0x40F00080 + 23 * 4)
+#define	   PCMD24  __REG(0x40F00080 + 24 * 4)
+#define	   PCMD25  __REG(0x40F00080 + 25 * 4)
+#define	   PCMD26  __REG(0x40F00080 + 26 * 4)
+#define	   PCMD27  __REG(0x40F00080 + 27 * 4)
+#define	   PCMD28  __REG(0x40F00080 + 28 * 4)
+#define	   PCMD29  __REG(0x40F00080 + 29 * 4)
+#define	   PCMD30  __REG(0x40F00080 + 30 * 4)
+#define	   PCMD31  __REG(0x40F00080 + 31 * 4)
+
+#define	   PCMD_MBC    (1<<12)
+#define	   PCMD_DCE    (1<<11)
+#define	   PCMD_LC     (1<<10)
+/* FIXME:  PCMD_SQC need be checked.   */
+#define	   PCMD_SQC    (3<<8)  /* currently only bit 8 is changerable, */
+				/* bit 9 should be 0 all day. */
+#define PVCR_VCSA		   (0x1<<14)
+#define PVCR_CommandDelay	   (0xf80)
+/* define MACRO for Power Manager General Configuration Register (PCFR) */
+#define PCFR_FVC		   (0x1 << 10)
+#define PCFR_PI2C_EN		   (0x1 << 6)
+
+#define PSSR_OTGPH	(1 << 6)	/* OTG Peripheral control Hold */
+#define PSSR_RDH	(1 << 5)	/* Read Disable Hold */
+#define PSSR_PH		(1 << 4)	/* Peripheral Control Hold */
+#define PSSR_VFS	(1 << 2)	/* VDD Fault Status */
+#define PSSR_BFS	(1 << 1)	/* Battery Fault Status */
+#define PSSR_SSS	(1 << 0)	/* Software Sleep Status */
+
+#define PCFR_DS		(1 << 3)	/* Deep Sleep Mode */
+#define PCFR_FS		(1 << 2)	/* Float Static Chip Selects */
+#define PCFR_FP		(1 << 1)	/* Float PCMCIA controls */
+#define PCFR_OPDE	(1 << 0)	/* 3.6864 MHz oscillator power-down enable */
+
+#define RCSR_GPR	(1 << 3)	/* GPIO Reset */
+#define RCSR_SMR	(1 << 2)	/* Sleep Mode */
+#define RCSR_WDR	(1 << 1)	/* Watchdog Reset */
+#define RCSR_HWR	(1 << 0)	/* Hardware Reset */
+
+#endif /* CONFIG_CPU_MONAHANS */
+
+/*
+ * SSP Serial Port Registers
+ */
+#define SSCR0		__REG(0x41000000)  /* SSP Control Register 0 */
+#define SSCR1		__REG(0x41000004)  /* SSP Control Register 1 */
+#define SSSR		__REG(0x41000008)  /* SSP Status Register */
+#define SSITR		__REG(0x4100000C)  /* SSP Interrupt Test Register */
+#define SSDR		__REG(0x41000010)  /* (Write / Read) SSP Data Write Register/SSP Data Read Register */
+
+/*
+ * MultiMediaCard (MMC) controller
+ */
+#define MMC_STRPCL	__REG(0x41100000)  /* Control to start and stop MMC clock */
+#define MMC_STAT	__REG(0x41100004)  /* MMC Status Register (read only) */
+#define MMC_CLKRT	__REG(0x41100008)  /* MMC clock rate */
+#define MMC_SPI		__REG(0x4110000c)  /* SPI mode control bits */
+#define MMC_CMDAT	__REG(0x41100010)  /* Command/response/data sequence control */
+#define MMC_RESTO	__REG(0x41100014)  /* Expected response time out */
+#define MMC_RDTO	__REG(0x41100018)  /* Expected data read time out */
+#define MMC_BLKLEN	__REG(0x4110001c)  /* Block length of data transaction */
+#define MMC_NOB		__REG(0x41100020)  /* Number of blocks, for block mode */
+#define MMC_PRTBUF	__REG(0x41100024)  /* Partial MMC_TXFIFO FIFO written */
+#define MMC_I_MASK	__REG(0x41100028)  /* Interrupt Mask */
+#define MMC_I_REG	__REG(0x4110002c)  /* Interrupt Register (read only) */
+#define MMC_CMD		__REG(0x41100030)  /* Index of current command */
+#define MMC_ARGH	__REG(0x41100034)  /* MSW part of the current command argument */
+#define MMC_ARGL	__REG(0x41100038)  /* LSW part of the current command argument */
+#define MMC_RES		__REG(0x4110003c)  /* Response FIFO (read only) */
+#define MMC_RXFIFO	__REG(0x41100040)  /* Receive FIFO (read only) */
+#define MMC_TXFIFO	__REG(0x41100044)  /* Transmit FIFO (write only) */
+
+/*
+ * Core Clock
+ */
+
+#if defined(CONFIG_CPU_MONAHANS)
+#define ACCR		__REG(0x41340000)  /* Application Subsystem Clock Configuration Register */
+#define ACSR		__REG(0x41340004)  /* Application Subsystem Clock Status Register */
+#define AICSR		__REG(0x41340008)  /* Application Subsystem Interrupt Control/Status Register */
+#define CKENA		__REG(0x4134000C)  /* A Clock Enable Register */
+#define CKENB		__REG(0x41340010)  /* B Clock Enable Register */
+#define AC97_DIV	__REG(0x41340014)  /* AC97 clock divisor value register */
+
+#define ACCR_SMC_MASK	0x03800000	/* Static Memory Controller Frequency Select */
+#define ACCR_SRAM_MASK	0x000c0000	/* SRAM Controller Frequency Select */
+#define ACCR_FC_MASK	0x00030000	/* Frequency Change Frequency Select */
+#define ACCR_HSIO_MASK	0x0000c000	/* High Speed IO Frequency Select */
+#define ACCR_DDR_MASK	0x00003000	/* DDR Memory Controller Frequency Select */
+#define ACCR_XN_MASK	0x00000700	/* Run Mode Frequency to Turbo Mode Frequency Multiplier */
+#define ACCR_XL_MASK	0x0000001f	/* Crystal Frequency to Memory Frequency Multiplier */
+#define ACCR_XPDIS	(1 << 31)
+#define ACCR_SPDIS	(1 << 30)
+#define ACCR_13MEND1	(1 << 27)
+#define ACCR_D0CS	(1 << 26)
+#define ACCR_13MEND2	(1 << 21)
+#define ACCR_PCCE	(1 << 11)
+
+#define CKENA_30_MSL0	(1 << 30)	/* MSL0 Interface Unit Clock Enable */
+#define CKENA_29_SSP4	(1 << 29)	/* SSP3 Unit Clock Enable */
+#define CKENA_28_SSP3	(1 << 28)	/* SSP2 Unit Clock Enable */
+#define CKENA_27_SSP2	(1 << 27)	/* SSP1 Unit Clock Enable */
+#define CKENA_26_SSP1	(1 << 26)	/* SSP0 Unit Clock Enable */
+#define CKENA_25_TSI	(1 << 25)	/* TSI Clock Enable */
+#define CKENA_24_AC97	(1 << 24)	/* AC97 Unit Clock Enable */
+#define CKENA_23_STUART	(1 << 23)	/* STUART Unit Clock Enable */
+#define CKENA_22_FFUART	(1 << 22)	/* FFUART Unit Clock Enable */
+#define CKENA_21_BTUART	(1 << 21)	/* BTUART Unit Clock Enable */
+#define CKENA_20_UDC	(1 << 20)	/* UDC Clock Enable */
+#define CKENA_19_TPM	(1 << 19)	/* TPM Unit Clock Enable */
+#define CKENA_18_USIM1	(1 << 18)	/* USIM1 Unit Clock Enable */
+#define CKENA_17_USIM0	(1 << 17)	/* USIM0 Unit Clock Enable */
+#define CKENA_15_CIR	(1 << 15)	/* Consumer IR Clock Enable */
+#define CKENA_14_KEY	(1 << 14)	/* Keypad Controller Clock Enable */
+#define CKENA_13_MMC1	(1 << 13)	/* MMC1 Clock Enable */
+#define CKENA_12_MMC0	(1 << 12)	/* MMC0 Clock Enable */
+#define CKENA_11_FLASH	(1 << 11)	/* Boot ROM Clock Enable */
+#define CKENA_10_SRAM	(1 << 10)	/* SRAM Controller Clock Enable */
+#define CKENA_9_SMC	(1 << 9)	/* Static Memory Controller */
+#define CKENA_8_DMC	(1 << 8)	/* Dynamic Memory Controller */
+#define CKENA_7_GRAPHICS (1 << 7)	/* 2D Graphics Clock Enable */
+#define CKENA_6_USBCLI	(1 << 6)	/* USB Client Unit Clock Enable */
+#define CKENA_4_NAND	(1 << 4)	/* NAND Flash Controller Clock Enable */
+#define CKENA_3_CAMERA	(1 << 3)	/* Camera Interface Clock Enable */
+#define CKENA_2_USBHOST	(1 << 2)	/* USB Host Unit Clock Enable */
+#define CKENA_1_LCD	(1 << 1)	/* LCD Unit Clock Enable */
+
+#define CKENB_8_1WIRE	((1 << 8) + 32) /* One Wire Interface Unit Clock Enable */
+#define CKENB_7_GPIO	((1 << 7) + 32)	/* GPIO Clock Enable */
+#define CKENB_6_IRQ	((1 << 6) + 32)	/* Interrupt Controller Clock Enable */
+#define CKENB_4_I2C	((1 << 4) + 32)	/* I2C Unit Clock Enable */
+#define CKENB_1_PWM1	((1 << 1) + 32)	/* PWM2 & PWM3 Clock Enable */
+#define CKENB_0_PWM0	((1 << 0) + 32)	/* PWM0 & PWM1 Clock Enable */
+
+#else /* if defined CONFIG_CPU_MONAHANS */
+
+#define CCCR		__REG(0x41300000)  /* Core Clock Configuration Register */
+#define CKEN		__REG(0x41300004)  /* Clock Enable Register */
+#define OSCC		__REG(0x41300008)  /* Oscillator Configuration Register */
+
+#define CCCR_N_MASK	0x0380		/* Run Mode Frequency to Turbo Mode Frequency Multiplier */
+#if !defined(CONFIG_PXA27X)
+#define CCCR_M_MASK	0x0060		/* Memory Frequency to Run Mode Frequency Multiplier */
+#endif
+#define CCCR_L_MASK	0x001f		/* Crystal Frequency to Memory Frequency Multiplier */
+
+#define CKEN24_CAMERA	(1 << 24)	/* Camera Interface Clock Enable */
+#define CKEN23_SSP1	(1 << 23)	/* SSP1 Unit Clock Enable */
+#define CKEN22_MEMC	(1 << 22)	/* Memory Controller Clock Enable */
+#define CKEN21_MEMSTK	(1 << 21)	/* Memory Stick Host Controller */
+#define CKEN20_IM	(1 << 20)	/* Internal Memory Clock Enable */
+#define CKEN19_KEYPAD	(1 << 19)	/* Keypad Interface Clock Enable */
+#define CKEN18_USIM	(1 << 18)	/* USIM Unit Clock Enable */
+#define CKEN17_MSL	(1 << 17)	/* MSL Unit Clock Enable */
+#define CKEN16_LCD	(1 << 16)	/* LCD Unit Clock Enable */
+#define CKEN15_PWRI2C	(1 << 15)	/* PWR I2C Unit Clock Enable */
+#define CKEN14_I2C	(1 << 14)	/* I2C Unit Clock Enable */
+#define CKEN13_FICP	(1 << 13)	/* FICP Unit Clock Enable */
+#define CKEN12_MMC	(1 << 12)	/* MMC Unit Clock Enable */
+#define CKEN11_USB	(1 << 11)	/* USB Unit Clock Enable */
+#if defined(CONFIG_PXA27X)
+#define CKEN10_USBHOST	(1 << 10)	/* USB Host Unit Clock Enable */
+#define CKEN24_CAMERA	(1 << 24)	/* Camera Unit Clock Enable */
+#endif
+#define CKEN8_I2S	(1 << 8)	/* I2S Unit Clock Enable */
+#define CKEN7_BTUART	(1 << 7)	/* BTUART Unit Clock Enable */
+#define CKEN6_FFUART	(1 << 6)	/* FFUART Unit Clock Enable */
+#define CKEN5_STUART	(1 << 5)	/* STUART Unit Clock Enable */
+#define CKEN3_SSP	(1 << 3)	/* SSP Unit Clock Enable */
+#define CKEN2_AC97	(1 << 2)	/* AC97 Unit Clock Enable */
+#define CKEN1_PWM1	(1 << 1)	/* PWM1 Clock Enable */
+#define CKEN0_PWM0	(1 << 0)	/* PWM0 Clock Enable */
+
+#define OSCC_OON	(1 << 1)	/* 32.768kHz OON (write-once only bit) */
+#define OSCC_OOK	(1 << 0)	/* 32.768kHz OOK (read-only bit) */
+
+#if !defined(CONFIG_PXA27X)
+#define	 CCCR_L09      (0x1F)
+#define	 CCCR_L27      (0x1)
+#define	 CCCR_L32      (0x2)
+#define	 CCCR_L36      (0x3)
+#define	 CCCR_L40      (0x4)
+#define	 CCCR_L45      (0x5)
+
+#define	 CCCR_M1       (0x1 << 5)
+#define	 CCCR_M2       (0x2 << 5)
+#define	 CCCR_M4       (0x3 << 5)
+
+#define	 CCCR_N10      (0x2 << 7)
+#define	 CCCR_N15      (0x3 << 7)
+#define	 CCCR_N20      (0x4 << 7)
+#define	 CCCR_N25      (0x5 << 7)
+#define	 CCCR_N30      (0x6 << 7)
+#endif
+
+#endif /* CONFIG_CPU_MONAHANS */
+
+/*
+ * LCD
+ */
+#define LCCR0		__REG(0x44000000)  /* LCD Controller Control Register 0 */
+#define LCCR1		__REG(0x44000004)  /* LCD Controller Control Register 1 */
+#define LCCR2		__REG(0x44000008)  /* LCD Controller Control Register 2 */
+#define LCCR3		__REG(0x4400000C)  /* LCD Controller Control Register 3 */
+#define DFBR0		__REG(0x44000020)  /* DMA Channel 0 Frame Branch Register */
+#define DFBR1		__REG(0x44000024)  /* DMA Channel 1 Frame Branch Register */
+#define LCSR0		__REG(0x44000038)  /* LCD Controller Status Register */
+#define LCSR1		__REG(0x44000034)  /* LCD Controller Status Register */
+#define LIIDR		__REG(0x4400003C)  /* LCD Controller Interrupt ID Register */
+#define TMEDRGBR	__REG(0x44000040)  /* TMED RGB Seed Register */
+#define TMEDCR		__REG(0x44000044)  /* TMED Control Register */
+
+#define FDADR0		__REG(0x44000200)  /* DMA Channel 0 Frame Descriptor Address Register */
+#define FSADR0		__REG(0x44000204)  /* DMA Channel 0 Frame Source Address Register */
+#define FIDR0		__REG(0x44000208)  /* DMA Channel 0 Frame ID Register */
+#define LDCMD0		__REG(0x4400020C)  /* DMA Channel 0 Command Register */
+#define FDADR1		__REG(0x44000210)  /* DMA Channel 1 Frame Descriptor Address Register */
+#define FSADR1		__REG(0x44000214)  /* DMA Channel 1 Frame Source Address Register */
+#define FIDR1		__REG(0x44000218)  /* DMA Channel 1 Frame ID Register */
+#define LDCMD1		__REG(0x4400021C)  /* DMA Channel 1 Command Register */
+
+#define LCCR0_ENB	(1 << 0)	/* LCD Controller enable */
+#define LCCR0_CMS	(1 << 1)	/* Color = 0, Monochrome = 1 */
+#define LCCR0_SDS	(1 << 2)	/* Single Panel = 0, Dual Panel = 1 */
+#define LCCR0_LDM	(1 << 3)	/* LCD Disable Done Mask */
+#define LCCR0_SFM	(1 << 4)	/* Start of frame mask */
+#define LCCR0_IUM	(1 << 5)	/* Input FIFO underrun mask */
+#define LCCR0_EFM	(1 << 6)	/* End of Frame mask */
+#define LCCR0_PAS	(1 << 7)	/* Passive = 0, Active = 1 */
+#define LCCR0_BLE	(1 << 8)	/* Little Endian = 0, Big Endian = 1 */
+#define LCCR0_DPD	(1 << 9)	/* Double Pixel mode, 4 pixel value = 0, 8 pixle values = 1 */
+#define LCCR0_DIS	(1 << 10)	/* LCD Disable */
+#define LCCR0_QDM	(1 << 11)	/* LCD Quick Disable mask */
+#define LCCR0_PDD	(0xff << 12)	/* Palette DMA request delay */
+#define LCCR0_PDD_S	12
+#define LCCR0_BM	(1 << 20)	/* Branch mask */
+#define LCCR0_OUM	(1 << 21)	/* Output FIFO underrun mask */
+#if defined(CONFIG_PXA27X)
+#define LCCR0_LCDT	(1 << 22)	/* LCD Panel Type */
+#define LCCR0_RDSTM	(1 << 23)	/* Read Status Interrupt Mask */
+#define LCCR0_CMDIM	(1 << 24)	/* Command Interrupt Mask */
+#endif
+
+#define LCCR1_PPL	Fld (10, 0)	 /* Pixels Per Line - 1 */
+#define LCCR1_DisWdth(Pixel)		/* Display Width [1..800 pix.]	*/ \
+			(((Pixel) - 1) << FShft (LCCR1_PPL))
+
+#define LCCR1_HSW	Fld (6, 10)	/* Horizontal Synchronization	  */
+#define LCCR1_HorSnchWdth(Tpix)		/* Horizontal Synchronization	  */ \
+					/* pulse Width [1..64 Tpix]	  */ \
+			(((Tpix) - 1) << FShft (LCCR1_HSW))
+
+#define LCCR1_ELW	Fld (8, 16)	/* End-of-Line pixel clock Wait	   */
+					/* count - 1 [Tpix]		   */
+#define LCCR1_EndLnDel(Tpix)		/*  End-of-Line Delay		   */ \
+					/*  [1..256 Tpix]		   */ \
+			(((Tpix) - 1) << FShft (LCCR1_ELW))
+
+#define LCCR1_BLW	Fld (8, 24)	/* Beginning-of-Line pixel clock   */
+					/* Wait count - 1 [Tpix]	   */
+#define LCCR1_BegLnDel(Tpix)		/*  Beginning-of-Line Delay	   */ \
+					/*  [1..256 Tpix]		   */ \
+			(((Tpix) - 1) << FShft (LCCR1_BLW))
+
+
+#define LCCR2_LPP	Fld (10, 0)	/* Line Per Panel - 1		   */
+#define LCCR2_DisHght(Line)		/*  Display Height [1..1024 lines] */ \
+			(((Line) - 1) << FShft (LCCR2_LPP))
+
+#define LCCR2_VSW	Fld (6, 10)	/* Vertical Synchronization pulse  */
+					/* Width - 1 [Tln] (L_FCLK)	   */
+#define LCCR2_VrtSnchWdth(Tln)		/*  Vertical Synchronization pulse */ \
+					/*  Width [1..64 Tln]		   */ \
+			(((Tln) - 1) << FShft (LCCR2_VSW))
+
+#define LCCR2_EFW	Fld (8, 16)	/* End-of-Frame line clock Wait	   */
+					/* count [Tln]			   */
+#define LCCR2_EndFrmDel(Tln)		/*  End-of-Frame Delay		   */ \
+					/*  [0..255 Tln]		   */ \
+			((Tln) << FShft (LCCR2_EFW))
+
+#define LCCR2_BFW	Fld (8, 24)	/* Beginning-of-Frame line clock   */
+					/* Wait count [Tln]		   */
+#define LCCR2_BegFrmDel(Tln)		/*  Beginning-of-Frame Delay	   */ \
+					/*  [0..255 Tln]		   */ \
+			((Tln) << FShft (LCCR2_BFW))
+
+#if 0
+#define LCCR3_PCD	(0xff)		/* Pixel clock divisor */
+#define LCCR3_ACB	(0xff << 8)	/* AC Bias pin frequency */
+#define LCCR3_ACB_S	8
+#endif
+
+#define LCCR3_API	(0xf << 16)	/* AC Bias pin trasitions per interrupt */
+#define LCCR3_API_S	16
+#define LCCR3_VSP	(1 << 20)	/* vertical sync polarity */
+#define LCCR3_HSP	(1 << 21)	/* horizontal sync polarity */
+#define LCCR3_PCP	(1 << 22)	/* pixel clock polarity */
+#define LCCR3_OEP	(1 << 23)	/* output enable polarity */
+#if 0
+#define LCCR3_BPP	(7 << 24)	/* bits per pixel */
+#define LCCR3_BPP_S	24
+#endif
+#define LCCR3_DPC	(1 << 27)	/* double pixel clock mode */
+
+#define LCCR3_PDFOR_0	 (0 << 30)
+#define LCCR3_PDFOR_1	 (1 << 30)
+#define LCCR3_PDFOR_2	 (2 << 30)
+#define LCCR3_PDFOR_3	 (3 << 30)
+
+
+#define LCCR3_PCD	Fld (8, 0)	/* Pixel Clock Divisor */
+#define LCCR3_PixClkDiv(Div)		/* Pixel Clock Divisor */ \
+			(((Div) << FShft (LCCR3_PCD)))
+
+
+#define LCCR3_BPP	Fld (3, 24)	/* Bit Per Pixel */
+#define LCCR3_Bpp(Bpp)			/* Bit Per Pixel */ \
+			((((Bpp&0x7) << FShft (LCCR3_BPP)))|(((Bpp&0x8)<<26)))
+
+#define LCCR3_ACB	Fld (8, 8)	/* AC Bias */
+#define LCCR3_Acb(Acb)			/* BAC Bias */ \
+			(((Acb) << FShft (LCCR3_ACB)))
+
+#define LCCR3_HorSnchH	(LCCR3_HSP*0)	/*  Horizontal Synchronization	   */
+					/*  pulse active High		   */
+#define LCCR3_HorSnchL	(LCCR3_HSP*1)	/*  Horizontal Synchronization	   */
+
+#define LCCR3_VrtSnchH	(LCCR3_VSP*0)	/*  Vertical Synchronization pulse */
+					/*  active High			   */
+#define LCCR3_VrtSnchL	(LCCR3_VSP*1)	/*  Vertical Synchronization pulse */
+					/*  active Low			   */
+
+#define LCSR0_LDD	(1 << 0)	/* LCD Disable Done */
+#define LCSR0_SOF	(1 << 1)	/* Start of frame */
+#define LCSR0_BER	(1 << 2)	/* Bus error */
+#define LCSR0_ABC	(1 << 3)	/* AC Bias count */
+#define LCSR0_IUL	(1 << 4)	/* input FIFO underrun Lower panel */
+#define LCSR0_IUU	(1 << 5)	/* input FIFO underrun Upper panel */
+#define LCSR0_OU	(1 << 6)	/* output FIFO underrun */
+#define LCSR0_QD	(1 << 7)	/* quick disable */
+#define LCSR0_EOF0	(1 << 8)	/* end of frame */
+#define LCSR0_BS	(1 << 9)	/* branch status */
+#define LCSR0_SINT	(1 << 10)	/* subsequent interrupt */
+
+#define LCSR1_SOF1	(1 << 0)
+#define LCSR1_SOF2	(1 << 1)
+#define LCSR1_SOF3	(1 << 2)
+#define LCSR1_SOF4	(1 << 3)
+#define LCSR1_SOF5	(1 << 4)
+#define LCSR1_SOF6	(1 << 5)
+
+#define LCSR1_EOF1	(1 << 8)
+#define LCSR1_EOF2	(1 << 9)
+#define LCSR1_EOF3	(1 << 10)
+#define LCSR1_EOF4	(1 << 11)
+#define LCSR1_EOF5	(1 << 12)
+#define LCSR1_EOF6	(1 << 13)
+
+#define LCSR1_BS1	(1 << 16)
+#define LCSR1_BS2	(1 << 17)
+#define LCSR1_BS3	(1 << 18)
+#define LCSR1_BS4	(1 << 19)
+#define LCSR1_BS5	(1 << 20)
+#define LCSR1_BS6	(1 << 21)
+
+#define LCSR1_IU2	(1 << 25)
+#define LCSR1_IU3	(1 << 26)
+#define LCSR1_IU4	(1 << 27)
+#define LCSR1_IU5	(1 << 28)
+#define LCSR1_IU6	(1 << 29)
+
+#define LDCMD_PAL	(1 << 26)	/* instructs DMA to load palette buffer */
+#if defined(CONFIG_PXA27X)
+#define LDCMD_SOFINT	(1 << 22)
+#define LDCMD_EOFINT	(1 << 21)
+#endif
+
+/*
+ * Memory controller
+ */
+
+#ifdef CONFIG_CPU_MONAHANS
+/* Static Memory Controller Registers */
+#define MSC0		__REG_2(0x4A000008)  /* Static Memory Control Register 0 */
+#define MSC1		__REG_2(0x4A00000C)  /* Static Memory Control Register 1 */
+#define MECR		__REG_2(0x4A000014)  /* Expansion Memory (PCMCIA/Compact Flash) Bus Configuration */
+#define SXCNFG		__REG_2(0x4A00001C)  /* Synchronous Static Memory Control Register */
+#define MCMEM0		__REG_2(0x4A000028)  /* Card interface Common Memory Space Socket 0 Timing */
+#define MCATT0		__REG_2(0x4A000030)  /* Card interface Attribute Space Socket 0 Timing Configuration */
+#define MCIO0		__REG_2(0x4A000038)  /* Card interface I/O Space Socket 0 Timing Configuration */
+#define MEMCLKCFG	__REG_2(0x4A000068)  /* SCLK speed configuration */
+#define CSADRCFG0	__REG_2(0x4A000080)  /* Address Configuration for chip select 0 */
+#define CSADRCFG1	__REG_2(0x4A000084)  /* Address Configuration for chip select 1 */
+#define CSADRCFG2	__REG_2(0x4A000088)  /* Address Configuration for chip select 2 */
+#define CSADRCFG3	__REG_2(0x4A00008C)  /* Address Configuration for chip select 3 */
+#define CSADRCFG_P	__REG_2(0x4A000090)  /* Address Configuration for pcmcia card interface */
+#define CSMSADRCFG	__REG_2(0x4A0000A0)  /* Master Address Configuration Register */
+#define CLK_RET_DEL	__REG_2(0x4A0000B0)  /* Delay line and mux selects for return data latching for sync. flash */
+#define ADV_RET_DEL	__REG_2(0x4A0000B4)  /* Delay line and mux selects for return data latching for sync. flash */
+
+/* Dynamic Memory Controller Registers */
+#define MDCNFG		__REG_2(0x48100000)  /* SDRAM Configuration Register 0 */
+#define MDREFR		__REG_2(0x48100004)  /* SDRAM Refresh Control Register */
+#define FLYCNFG		__REG_2(0x48100020)  /* Fly-by DMA DVAL[1:0] polarities */
+#define MDMRS		__REG_2(0x48100040)  /* MRS value to be written to SDRAM */
+#define	DDR_SCAL	__REG_2(0x48100050)  /* Software Delay Line Calibration/Configuration for external DDR memory. */
+#define	DDR_HCAL	__REG_2(0x48100060)  /* Hardware Delay Line Calibration/Configuration for external DDR memory. */
+#define	DDR_WCAL	__REG_2(0x48100068)  /* DDR Write Strobe Calibration Register */
+#define	DMCIER		__REG_2(0x48100070)  /* Dynamic MC Interrupt Enable Register. */
+#define	DMCISR		__REG_2(0x48100078)  /* Dynamic MC Interrupt Status Register. */
+#define	DDR_DLS		__REG_2(0x48100080)  /* DDR Delay Line Value Status register for external DDR memory. */
+#define	EMPI		__REG_2(0x48100090)  /* EMPI Control Register */
+#define RCOMP           __REG_2(0x48100100)
+#define PAD_MA          __REG_2(0x48100110)
+#define PAD_MDMSB       __REG_2(0x48100114)
+#define PAD_MDLSB       __REG_2(0x48100118)
+#define PAD_DMEM        __REG_2(0x4810011c)
+#define PAD_SDCLK       __REG_2(0x48100120)
+#define PAD_SDCS        __REG_2(0x48100124)
+#define PAD_SMEM        __REG_2(0x48100128)
+#define PAD_SCLK        __REG_2(0x4810012C)
+#define TAI		__REG_2(0x48100F00) /* TAI Tavor Address Isolation Register */
+
+/* Some frequently used bits */
+#define MDCNFG_DMAP	0x80000000	/* SDRAM 1GB Memory Map Enable */
+#define MDCNFG_DMCEN	0x40000000	/* Enable Dynamic Memory Controller */
+#define MDCNFG_HWFREQ	0x20000000	/* Hardware Frequency Change Calibration */
+#define MDCNFG_DTYPE	0x400		/* SDRAM Type: 1=DDR SDRAM */
+
+#define MDCNFG_DTC_0	0x0		/* Timing Category of SDRAM */
+#define MDCNFG_DTC_1	0x100
+#define MDCNFG_DTC_2	0x200
+#define MDCNFG_DTC_3	0x300
+
+#define MDCNFG_DRAC_12	0x0		/* Number of Row Access Bits */
+#define MDCNFG_DRAC_13	0x20
+#define MDCNFG_DRAC_14	0x40
+
+#define MDCNFG_DCAC_9	0x0		/* Number of Column Acess Bits */
+#define MDCNFG_DCAC_10	0x08
+#define MDCNFG_DCAC_11	0x10
+
+#define MDCNFG_DBW_16	0x4		/* SDRAM Data Bus width 16bit */
+#define MDCNFG_DCSE1	0x2		/* SDRAM CS 1 Enable */
+#define MDCNFG_DCSE0	0x1		/* SDRAM CS 0 Enable */
+
+
+/* Data Flash Controller Registers */
+
+#define NDCR		__REG(0x43100000)  /* Data Flash Control register */
+#define NDTR0CS0	__REG(0x43100004)  /* Data Controller Timing Parameter 0 Register for ND_nCS0 */
+/* #define NDTR0CS1	__REG(0x43100008)  /\* Data Controller Timing Parameter 0 Register for ND_nCS1 *\/ */
+#define NDTR1CS0	__REG(0x4310000C)  /* Data Controller Timing Parameter 1 Register for ND_nCS0 */
+/* #define NDTR1CS1	__REG(0x43100010)  /\* Data Controller Timing Parameter 1 Register for ND_nCS1 *\/ */
+#define NDSR		__REG(0x43100014)  /* Data Controller Status Register */
+#define NDPCR		__REG(0x43100018)  /* Data Controller Page Count Register */
+#define NDBDR0		__REG(0x4310001C)  /* Data Controller Bad Block Register 0 */
+#define NDBDR1		__REG(0x43100020)  /* Data Controller Bad Block Register 1 */
+#define NDDB		__REG(0x43100040)  /* Data Controller Data Buffer */
+#define NDCB0		__REG(0x43100048)  /* Data Controller Command Buffer0 */
+#define NDCB1		__REG(0x4310004C)  /* Data Controller Command Buffer1 */
+#define NDCB2		__REG(0x43100050)  /* Data Controller Command Buffer2 */
+
+#define NDCR_SPARE_EN	(0x1<<31)
+#define NDCR_ECC_EN	(0x1<<30)
+#define NDCR_DMA_EN	(0x1<<29)
+#define NDCR_ND_RUN	(0x1<<28)
+#define NDCR_DWIDTH_C	(0x1<<27)
+#define NDCR_DWIDTH_M	(0x1<<26)
+#define NDCR_PAGE_SZ	(0x3<<24)
+#define NDCR_NCSX	(0x1<<23)
+#define NDCR_ND_STOP	(0x1<<22)
+/* reserved:
+ * #define NDCR_ND_MODE	(0x3<<21)
+ * #define NDCR_NAND_MODE   0x0 */
+#define NDCR_CLR_PG_CNT	(0x1<<20)
+#define NDCR_CLR_ECC	(0x1<<19)
+#define NDCR_RD_ID_CNT	(0x7<<16)
+#define NDCR_RA_START	(0x1<<15)
+#define NDCR_PG_PER_BLK	(0x1<<14)
+#define NDCR_ND_ARB_EN	(0x1<<12)
+#define NDCR_RDYM	(0x1<<11)
+#define NDCR_CS0_PAGEDM	(0x1<<10)
+#define NDCR_CS1_PAGEDM	(0x1<<9)
+#define NDCR_CS0_CMDDM	(0x1<<8)
+#define NDCR_CS1_CMDDM	(0x1<<7)
+#define NDCR_CS0_BBDM	(0x1<<6)
+#define NDCR_CS1_BBDM	(0x1<<5)
+#define NDCR_DBERRM	(0x1<<4)
+#define NDCR_SBERRM	(0x1<<3)
+#define NDCR_WRDREQM	(0x1<<2)
+#define NDCR_RDDREQM	(0x1<<1)
+#define NDCR_WRCMDREQM	(0x1)
+
+#define NDSR_RDY	(0x1<<11)
+#define NDSR_CS0_PAGED	(0x1<<10)
+#define NDSR_CS1_PAGED	(0x1<<9)
+#define NDSR_CS0_CMDD	(0x1<<8)
+#define NDSR_CS1_CMDD	(0x1<<7)
+#define NDSR_CS0_BBD	(0x1<<6)
+#define NDSR_CS1_BBD	(0x1<<5)
+#define NDSR_DBERR	(0x1<<4)
+#define NDSR_SBERR	(0x1<<3)
+#define NDSR_WRDREQ	(0x1<<2)
+#define NDSR_RDDREQ	(0x1<<1)
+#define NDSR_WRCMDREQ	(0x1)
+
+#define NDCB0_AUTO_RS	(0x1<<25)
+#define NDCB0_CSEL	(0x1<<24)
+#define NDCB0_CMD_TYPE	(0x7<<21)
+#define NDCB0_NC	(0x1<<20)
+#define NDCB0_DBC	(0x1<<19)
+#define NDCB0_ADDR_CYC	(0x7<<16)
+#define NDCB0_CMD2	(0xff<<8)
+#define NDCB0_CMD1	(0xff)
+#define MCMEM(s) MCMEM0
+#define MCATT(s) MCATT0
+#define MCIO(s) MCIO0
+#define MECR_CIT	(1 << 1)/* Card Is There: 0 -> no card, 1 -> card inserted */
+
+/* Maximum values for NAND Interface Timing Registers in DFC clock
+ * periods */
+#define DFC_MAX_tCH	7
+#define DFC_MAX_tCS	7
+#define DFC_MAX_tWH	7
+#define DFC_MAX_tWP	7
+#define DFC_MAX_tRH	7
+#define DFC_MAX_tRP	15
+#define DFC_MAX_tR	65535
+#define DFC_MAX_tWHR	15
+#define DFC_MAX_tAR	15
+
+#define DFC_CLOCK	104		/* DFC Clock is 104 MHz */
+#define DFC_CLK_PER_US	DFC_CLOCK/1000	/* clock period in ns */
+
+#else /* CONFIG_CPU_MONAHANS */
+
+#define MEMC_BASE	__REG(0x48000000)  /* Base of Memory Controller */
+#define MDCNFG_OFFSET	0x0
+#define MDREFR_OFFSET	0x4
+#define MSC0_OFFSET	0x8
+#define MSC1_OFFSET	0xC
+#define MSC2_OFFSET	0x10
+#define MECR_OFFSET	0x14
+#define SXLCR_OFFSET	0x18
+#define SXCNFG_OFFSET	0x1C
+#define FLYCNFG_OFFSET	0x20
+#define SXMRS_OFFSET	0x24
+#define MCMEM0_OFFSET	0x28
+#define MCMEM1_OFFSET	0x2C
+#define MCATT0_OFFSET	0x30
+#define MCATT1_OFFSET	0x34
+#define MCIO0_OFFSET	0x38
+#define MCIO1_OFFSET	0x3C
+#define MDMRS_OFFSET	0x40
+
+#define MDCNFG		__REG(0x48000000)  /* SDRAM Configuration Register 0 */
+#define MDCNFG_DE0	0x00000001
+#define MDCNFG_DE1	0x00000002
+#define MDCNFG_DE2	0x00010000
+#define MDCNFG_DE3	0x00020000
+#define MDCNFG_DWID0	0x00000004
+
+#define MDREFR		__REG(0x48000004)  /* SDRAM Refresh Control Register */
+#define MSC0		__REG(0x48000008)  /* Static Memory Control Register 0 */
+#define MSC1		__REG(0x4800000C)  /* Static Memory Control Register 1 */
+#define MSC2		__REG(0x48000010)  /* Static Memory Control Register 2 */
+#define MECR		__REG(0x48000014)  /* Expansion Memory (PCMCIA/Compact Flash) Bus Configuration */
+#define SXLCR		__REG(0x48000018)  /* LCR value to be written to SDRAM-Timing Synchronous Flash */
+#define SXCNFG		__REG(0x4800001C)  /* Synchronous Static Memory Control Register */
+#define SXMRS		__REG(0x48000024)  /* MRS value to be written to Synchronous Flash or SMROM */
+#define MCMEM0		__REG(0x48000028)  /* Card interface Common Memory Space Socket 0 Timing */
+#define MCMEM1		__REG(0x4800002C)  /* Card interface Common Memory Space Socket 1 Timing */
+#define MCATT0		__REG(0x48000030)  /* Card interface Attribute Space Socket 0 Timing Configuration */
+#define MCATT1		__REG(0x48000034)  /* Card interface Attribute Space Socket 1 Timing Configuration */
+#define MCIO0		__REG(0x48000038)  /* Card interface I/O Space Socket 0 Timing Configuration */
+#define MCIO1		__REG(0x4800003C)  /* Card interface I/O Space Socket 1 Timing Configuration */
+#define MDMRS		__REG(0x48000040)  /* MRS value to be written to SDRAM */
+#define BOOT_DEF	__REG(0x48000044)  /* Read-Only Boot-Time Register. Contains BOOT_SEL and PKG_SEL */
+
+#define MDREFR_K2FREE	(1 << 25)	/* SDRAM Free-Running Control */
+#define MDREFR_K1FREE	(1 << 24)	/* SDRAM Free-Running Control */
+#define MDREFR_K0FREE	(1 << 23)	/* SDRAM Free-Running Control */
+#define MDREFR_SLFRSH	(1 << 22)	/* SDRAM Self-Refresh Control/Status */
+#define MDREFR_APD	(1 << 20)	/* SDRAM/SSRAM Auto-Power-Down Enable */
+#define MDREFR_K2DB2	(1 << 19)	/* SDCLK2 Divide by 2 Control/Status */
+#define MDREFR_K2RUN	(1 << 18)	/* SDCLK2 Run Control/Status */
+#define MDREFR_K1DB2	(1 << 17)	/* SDCLK1 Divide by 2 Control/Status */
+#define MDREFR_K1RUN	(1 << 16)	/* SDCLK1 Run Control/Status */
+#define MDREFR_E1PIN	(1 << 15)	/* SDCKE1 Level Control/Status */
+#define MDREFR_K0DB2	(1 << 14)	/* SDCLK0 Divide by 2 Control/Status */
+#define MDREFR_K0RUN	(1 << 13)	/* SDCLK0 Run Control/Status */
+#define MDREFR_E0PIN	(1 << 12)	/* SDCKE0 Level Control/Status */
+
+#if defined(CONFIG_PXA27X)
+
+#define ARB_CNTRL	__REG(0x48000048)  /* Arbiter Control Register */
+
+#define ARB_DMA_SLV_PARK	(1<<31)	   /* Be parked with DMA slave when idle */
+#define ARB_CI_PARK		(1<<30)	   /* Be parked with Camera Interface when idle */
+#define ARB_EX_MEM_PARK		(1<<29)	   /* Be parked with external MEMC when idle */
+#define ARB_INT_MEM_PARK	(1<<28)	   /* Be parked with internal MEMC when idle */
+#define ARB_USB_PARK		(1<<27)	   /* Be parked with USB when idle */
+#define ARB_LCD_PARK		(1<<26)	   /* Be parked with LCD when idle */
+#define ARB_DMA_PARK		(1<<25)	   /* Be parked with DMA when idle */
+#define ARB_CORE_PARK		(1<<24)	   /* Be parked with core when idle */
+#define ARB_LOCK_FLAG		(1<<23)	   /* Only Locking masters gain access to the bus */
+
+#endif /* CONFIG_CPU_MONAHANS */
+
+/* Interrupt Controller */
+
+#define ICIP2		__REG(0x40D0009C)  /* Interrupt Controller IRQ Pending Register 2 */
+#define ICMR2		__REG(0x40D000A0)  /* Interrupt Controller Mask Register 2 */
+#define ICLR2		__REG(0x40D000A4)  /* Interrupt Controller Level Register 2 */
+#define ICFP2		__REG(0x40D000A8)  /* Interrupt Controller FIQ Pending Register 2 */
+#define ICPR2		__REG(0x40D000AC)  /* Interrupt Controller Pending Register 2 */
+
+/* General Purpose I/O */
+
+#define GAFR3_L		__REG(0x40E0006C)  /* GPIO Alternate Function Select Register GPIO<111:96> */
+#define GAFR3_U		__REG(0x40E00070)  /* GPIO Alternate Function Select Register GPIO<127:112> */
+#define GPLR3		__REG(0x40E00100)  /* GPIO Pin-Level Register GPIO<127:96> */
+#define GPDR3		__REG(0x40E0010C)  /* GPIO Pin Direction Register GPIO<127:96> */
+#define GPSR3		__REG(0x40E00118)  /* GPIO Pin Output Set Register GPIO<127:96> */
+#define GPCR3		__REG(0x40E00124)  /* GPIO Pin Output Clear Register GPIO <127:96> */
+#define GRER3		__REG(0x40E00130)  /* GPIO Rising-Edge Detect Register GPIO<127:96> */
+#define GFER3		__REG(0x40E0013C)  /* GPIO Falling-Edge Detect Register GPIO<31:0> */
+#define GEDR3		__REG(0x40E00148)  /* GPIO Edge Detect Status Register GPIO<127:96> */
+
+/* Core Clock */
+
+#define CCSR		__REG(0x4130000C) /* Core Clock Status Register */
+
+#define CKEN23_SSP1	(1 << 23) /* SSP1 Unit Clock Enable */
+#define CKEN22_MEMC	(1 << 22) /* Memory Controler */
+#define CKEN21_MSHC	(1 << 21) /* Memery Stick Host Controller */
+#define CKEN20_IM	(1 << 20) /* Internal Memory Clock Enable */
+#define CKEN19_KEYPAD	(1 << 19) /* Keypad Interface Clock Enable */
+#define CKEN18_USIM	(1 << 18) /* USIM Unit Clock Enable */
+#define CKEN17_MSL	(1 << 17) /* MSL Interface Unit Clock Enable */
+#define CKEN15_PWR_I2C	(1 << 15) /* PWR_I2C Unit Clock Enable */
+#define CKEN9_OST	(1 << 9)  /* OS Timer Unit Clock Enable */
+#define CKEN4_SSP3	(1 << 4)  /* SSP3 Unit Clock Enable */
+
+/* Memory controller */
+
+#define MDREFR_K0DB4	(1 << 29)	  /* SDCLK[0] divide by 4 */
+
+/* LCD registers */
+#define LCCR4		__REG(0x44000010)  /* LCD Controller Control Register 4 */
+#define LCCR5		__REG(0x44000014)  /* LCD Controller Control Register 5 */
+#define FBR0		__REG(0x44000020)  /* DMA Channel 0 Frame Branch Register */
+#define FBR1		__REG(0x44000024)  /* DMA Channel 1 Frame Branch Register */
+#define FBR2		__REG(0x44000028)  /* DMA Channel 2 Frame Branch Register */
+#define FBR3		__REG(0x4400002C)  /* DMA Channel 3 Frame Branch Register */
+#define FBR4		__REG(0x44000030)  /* DMA Channel 4 Frame Branch Register */
+#define FDADR2		__REG(0x44000220)  /* DMA Channel 2 Frame Descriptor Address Register */
+#define FSADR2		__REG(0x44000224)  /* DMA Channel 2 Frame Source Address Register */
+#define FIDR2		__REG(0x44000228)  /* DMA Channel 2 Frame ID Register */
+#define LDCMD2		__REG(0x4400022C)  /* DMA Channel 2 Command Register */
+#define FDADR3		__REG(0x44000230)  /* DMA Channel 3 Frame Descriptor Address Register */
+#define FSADR3		__REG(0x44000234)  /* DMA Channel 3 Frame Source Address Register */
+#define FIDR3		__REG(0x44000238)  /* DMA Channel 3 Frame ID Register */
+#define LDCMD3		__REG(0x4400023C)  /* DMA Channel 3 Command Register */
+#define FDADR4		__REG(0x44000240)  /* DMA Channel 4 Frame Descriptor Address Register */
+#define FSADR4		__REG(0x44000244)  /* DMA Channel 4 Frame Source Address Register */
+#define FIDR4		__REG(0x44000248)  /* DMA Channel 4 Frame ID Register */
+#define LDCMD4		__REG(0x4400024C)  /* DMA Channel 4 Command Register */
+#define FDADR5		__REG(0x44000250)  /* DMA Channel 5 Frame Descriptor Address Register */
+#define FSADR5		__REG(0x44000254)  /* DMA Channel 5 Frame Source Address Register */
+#define FIDR5		__REG(0x44000258)  /* DMA Channel 5 Frame ID Register */
+#define LDCMD5		__REG(0x4400025C)  /* DMA Channel 5 Command Register */
+
+#define OVL1C1		__REG(0x44000050)  /* Overlay 1 Control Register 1 */
+#define OVL1C2		__REG(0x44000060)  /* Overlay 1 Control Register 2 */
+#define OVL2C1		__REG(0x44000070)  /* Overlay 2 Control Register 1 */
+#define OVL2C2		__REG(0x44000080)  /* Overlay 2 Control Register 2 */
+#define CCR		__REG(0x44000090)  /* Cursor Control Register */
+
+#define FBR5		__REG(0x44000110)  /* DMA Channel 5 Frame Branch Register */
+#define FBR6		__REG(0x44000114)  /* DMA Channel 6 Frame Branch Register */
+
+#define LCCR0_LDDALT	(1<<26)		/* LDD Alternate mapping bit when base pixel is RGBT16 */
+#define LCCR0_OUC	(1<<25)		/* Overlay Underlay Control Bit */
+
+#define LCCR5_SOFM1	(1<<0)		/* Start Of Frame Mask for Overlay 1 (channel 1) */
+#define LCCR5_SOFM2	(1<<1)		/* Start Of Frame Mask for Overlay 2 (channel 2) */
+#define LCCR5_SOFM3	(1<<2)		/* Start Of Frame Mask for Overlay 2 (channel 3) */
+#define LCCR5_SOFM4	(1<<3)		/* Start Of Frame Mask for Overlay 2 (channel 4) */
+#define LCCR5_SOFM5	(1<<4)		/* Start Of Frame Mask for cursor (channel 5) */
+#define LCCR5_SOFM6	(1<<5)		/* Start Of Frame Mask for command data (channel 6) */
+
+#define LCCR5_EOFM1	(1<<8)		/* End Of Frame Mask for Overlay 1 (channel 1) */
+#define LCCR5_EOFM2	(1<<9)		/* End Of Frame Mask for Overlay 2 (channel 2) */
+#define LCCR5_EOFM3	(1<<10)		/* End Of Frame Mask for Overlay 2 (channel 3) */
+#define LCCR5_EOFM4	(1<<11)		/* End Of Frame Mask for Overlay 2 (channel 4) */
+#define LCCR5_EOFM5	(1<<12)		/* End Of Frame Mask for cursor (channel 5) */
+#define LCCR5_EOFM6	(1<<13)		/* End Of Frame Mask for command data (channel 6) */
+
+#define LCCR5_BSM1	(1<<16)		/* Branch mask for Overlay 1 (channel 1) */
+#define LCCR5_BSM2	(1<<17)		/* Branch mask for Overlay 2 (channel 2) */
+#define LCCR5_BSM3	(1<<18)		/* Branch mask for Overlay 2 (channel 3) */
+#define LCCR5_BSM4	(1<<19)		/* Branch mask for Overlay 2 (channel 4) */
+#define LCCR5_BSM5	(1<<20)		/* Branch mask for cursor (channel 5) */
+#define LCCR5_BSM6	(1<<21)		/* Branch mask for data command	 (channel 6) */
+
+#define LCCR5_IUM1	(1<<24)		/* Input FIFO Underrun Mask for Overlay 1  */
+#define LCCR5_IUM2	(1<<25)		/* Input FIFO Underrun Mask for Overlay 2  */
+#define LCCR5_IUM3	(1<<26)		/* Input FIFO Underrun Mask for Overlay 2  */
+#define LCCR5_IUM4	(1<<27)		/* Input FIFO Underrun Mask for Overlay 2  */
+#define LCCR5_IUM5	(1<<28)		/* Input FIFO Underrun Mask for cursor */
+#define LCCR5_IUM6	(1<<29)		/* Input FIFO Underrun Mask for data command */
+
+#define OVL1C1_O1EN	(1<<31)		/* Enable bit for Overlay 1 */
+#define OVL2C1_O2EN	(1<<31)		/* Enable bit for Overlay 2 */
+#define CCR_CEN		(1<<31)		/* Enable bit for Cursor */
+
+/* Keypad controller */
+
+#define KPC		__REG(0x41500000) /* Keypad Interface Control register */
+#define KPDK		__REG(0x41500008) /* Keypad Interface Direct Key register */
+#define KPREC		__REG(0x41500010) /* Keypad Intefcace Rotary Encoder register */
+#define KPMK		__REG(0x41500018) /* Keypad Intefcace Matrix Key register */
+#define KPAS		__REG(0x41500020) /* Keypad Interface Automatic Scan register */
+#define KPASMKP0	__REG(0x41500028) /* Keypad Interface Automatic Scan Multiple Key Presser register 0 */
+#define KPASMKP1	__REG(0x41500030) /* Keypad Interface Automatic Scan Multiple Key Presser register 1 */
+#define KPASMKP2	__REG(0x41500038) /* Keypad Interface Automatic Scan Multiple Key Presser register 2 */
+#define KPASMKP3	__REG(0x41500040) /* Keypad Interface Automatic Scan Multiple Key Presser register 3 */
+#define KPKDI		__REG(0x41500048) /* Keypad Interface Key Debounce Interval register */
+
+#define KPC_AS		(0x1 << 30)  /* Automatic Scan bit */
+#define KPC_ASACT	(0x1 << 29)  /* Automatic Scan on Activity */
+#define KPC_MI		(0x1 << 22)  /* Matrix interrupt bit */
+#define KPC_IMKP	(0x1 << 21)  /* Ignore Multiple Key Press */
+#define KPC_MS7		(0x1 << 20)  /* Matrix scan line 7 */
+#define KPC_MS6		(0x1 << 19)  /* Matrix scan line 6 */
+#define KPC_MS5		(0x1 << 18)  /* Matrix scan line 5 */
+#define KPC_MS4		(0x1 << 17)  /* Matrix scan line 4 */
+#define KPC_MS3		(0x1 << 16)  /* Matrix scan line 3 */
+#define KPC_MS2		(0x1 << 15)  /* Matrix scan line 2 */
+#define KPC_MS1		(0x1 << 14)  /* Matrix scan line 1 */
+#define KPC_MS0		(0x1 << 13)  /* Matrix scan line 0 */
+#define KPC_ME		(0x1 << 12)  /* Matrix Keypad Enable */
+#define KPC_MIE		(0x1 << 11)  /* Matrix Interrupt Enable */
+#define KPC_DK_DEB_SEL	(0x1 <<	 9)  /* Direct Key Debounce select */
+#define KPC_DI		(0x1 <<	 5)  /* Direct key interrupt bit */
+#define KPC_DEE0	(0x1 <<	 2)  /* Rotary Encoder 0 Enable */
+#define KPC_DE		(0x1 <<	 1)  /* Direct Keypad Enable */
+#define KPC_DIE		(0x1 <<	 0)  /* Direct Keypad interrupt Enable */
+
+#define KPDK_DKP	(0x1 << 31)
+#define KPDK_DK7	(0x1 <<	 7)
+#define KPDK_DK6	(0x1 <<	 6)
+#define KPDK_DK5	(0x1 <<	 5)
+#define KPDK_DK4	(0x1 <<	 4)
+#define KPDK_DK3	(0x1 <<	 3)
+#define KPDK_DK2	(0x1 <<	 2)
+#define KPDK_DK1	(0x1 <<	 1)
+#define KPDK_DK0	(0x1 <<	 0)
+
+#define KPREC_OF1	(0x1 << 31)
+#define kPREC_UF1	(0x1 << 30)
+#define KPREC_OF0	(0x1 << 15)
+#define KPREC_UF0	(0x1 << 14)
+
+#define KPMK_MKP	(0x1 << 31)
+#define KPAS_SO		(0x1 << 31)
+#define KPASMKPx_SO	(0x1 << 31)
+
+#define GPIO113_BIT	(1 << 17)/* GPIO113 in GPSR, GPCR, bit 17 */
+#define PSLR		__REG(0x40F00034)
+#define PSTR		__REG(0x40F00038)  /* Power Manager Standby Configuration Reg */
+#define PSNR		__REG(0x40F0003C)  /* Power Manager Sense Configuration Reg */
+#define PVCR		__REG(0x40F00040)  /* Power Manager Voltage Change Control Reg */
+#define PKWR		__REG(0x40F00050)  /* Power Manager KB Wake-Up Enable Reg */
+#define PKSR		__REG(0x40F00054)  /* Power Manager KB Level-Detect Status Reg */
+#define OSMR4		__REG(0x40A00080)  /* */
+#define OSCR4		__REG(0x40A00040)  /* OS Timer Counter Register */
+#define OMCR4		__REG(0x40A000C0)  /* */
+
+#endif	/* CONFIG_PXA27X */
+
+#endif	/* _PXA_REGS_H_ */
diff -Nurd u-boot-1.2.0/include/asm/arch-s3c24x0/memory.h u-boot-1.2.0-leopard/include/asm/arch-s3c24x0/memory.h
--- u-boot-1.2.0/include/asm/arch-s3c24x0/memory.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-s3c24x0/memory.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,162 @@
+/*
+ * linux/include/asm-arm/arch-s3c2400/memory.h by gj@denx.de
+ * based on
+ * linux/include/asm-arm/arch-sa1100/memory.h
+ *
+ * Copyright (c) 1999 Nicolas Pitre <nico@visuaide.com>
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+
+/*
+ * Task size: 3GB
+ */
+#define TASK_SIZE       (0xc0000000UL)
+#define TASK_SIZE_26	(0x04000000UL)
+
+/*
+ * This decides where the kernel will search for a free chunk of vm
+ * space during mmap's.
+ */
+#define TASK_UNMAPPED_BASE (TASK_SIZE / 3)
+
+/*
+ * Page offset: 3GB
+ */
+#define PAGE_OFFSET     (0xc0000000UL)
+
+/*
+ * Physical DRAM offset is 0x0c000000 on the S3C2400
+ */
+#define PHYS_OFFSET	(0x0c000000UL)
+
+#include <linux/config.h>
+
+
+/* Modified for S3C2400, by chc, 20010509 */
+#define RAM_IN_BANK_0  32*1024*1024
+#define RAM_IN_BANK_1  0
+#define RAM_IN_BANK_2  0
+#define RAM_IN_BANK_3  0
+
+#define MEM_SIZE  (RAM_IN_BANK_0+RAM_IN_BANK_1+RAM_IN_BANK_2+RAM_IN_BANK_3)
+
+
+/* translation macros */
+#define __virt_to_phys__is_a_macro
+#define __phys_to_virt__is_a_macro
+
+#if (RAM_IN_BANK_1 + RAM_IN_BANK_2 + RAM_IN_BANK_3 == 0)
+
+#define __virt_to_phys(x) ( (x) - PAGE_OFFSET + 0x0c000000 )
+#define __phys_to_virt(x) ( (x) - 0x0c000000 + PAGE_OFFSET )
+
+#elif (RAM_IN_BANK_0 == RAM_IN_BANK_1) && \
+      (RAM_IN_BANK_2 + RAM_IN_BANK_3 == 0)
+
+/* Two identical banks */
+#define __virt_to_phys(x) \
+	  ( ((x) < PAGE_OFFSET+RAM_IN_BANK_0) ? \
+	    ((x) - PAGE_OFFSET + _DRAMBnk0) : \
+	    ((x) - PAGE_OFFSET - RAM_IN_BANK_0 + _DRAMBnk1) )
+#define __phys_to_virt(x) \
+	  ( ((x)&0x07ffffff) + \
+	    (((x)&0x08000000) ? PAGE_OFFSET+RAM_IN_BANK_0 : PAGE_OFFSET) )
+#else
+
+/* It's more efficient for all other cases to use the function call */
+#undef __virt_to_phys__is_a_macro
+#undef __phys_to_virt__is_a_macro
+extern unsigned long __virt_to_phys(unsigned long vpage);
+extern unsigned long __phys_to_virt(unsigned long ppage);
+
+#endif
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ *
+ * On the SA1100, bus addresses are equivalent to physical addresses.
+ */
+#define __virt_to_bus__is_a_macro
+#define __virt_to_bus(x)        __virt_to_phys(x)
+#define __bus_to_virt__is_a_macro
+#define __bus_to_virt(x)        __phys_to_virt(x)
+
+
+#ifdef CONFIG_DISCONTIGMEM
+#error "CONFIG_DISCONTIGMEM will not work on S3C2400"
+/*
+ * Because of the wide memory address space between physical RAM banks on the
+ * SA1100, it's much more convenient to use Linux's NUMA support to implement
+ * our memory map representation.  Assuming all memory nodes have equal access
+ * characteristics, we then have generic discontiguous memory support.
+ *
+ * Of course, all this isn't mandatory for SA1100 implementations with only
+ * one used memory bank.  For those, simply undefine CONFIG_DISCONTIGMEM.
+ *
+ * The nodes are matched with the physical memory bank addresses which are
+ * incidentally the same as virtual addresses.
+ *
+ * 	node 0:  0xc0000000 - 0xc7ffffff
+ * 	node 1:  0xc8000000 - 0xcfffffff
+ * 	node 2:  0xd0000000 - 0xd7ffffff
+ * 	node 3:  0xd8000000 - 0xdfffffff
+ */
+
+#define NR_NODES	4
+
+/*
+ * Given a kernel address, find the home node of the underlying memory.
+ */
+#define KVADDR_TO_NID(addr) \
+		(((unsigned long)(addr) - 0xc0000000) >> 27)
+
+/*
+ * Given a physical address, convert it to a node id.
+ */
+#define PHYS_TO_NID(addr) KVADDR_TO_NID(__phys_to_virt(addr))
+
+/*
+ * Given a kaddr, ADDR_TO_MAPBASE finds the owning node of the memory
+ * and returns the mem_map of that node.
+ */
+#define ADDR_TO_MAPBASE(kaddr) \
+			NODE_MEM_MAP(KVADDR_TO_NID((unsigned long)(kaddr)))
+
+/*
+ * Given a kaddr, LOCAL_MEM_MAP finds the owning node of the memory
+ * and returns the index corresponding to the appropriate page in the
+ * node's mem_map.
+ */
+#define LOCAL_MAP_NR(kvaddr) \
+	(((unsigned long)(kvaddr) & 0x07ffffff) >> PAGE_SHIFT)
+
+/*
+ * Given a kaddr, virt_to_page returns a pointer to the corresponding
+ * mem_map entry.
+ */
+#define virt_to_page(kaddr) \
+	(ADDR_TO_MAPBASE(kaddr) + LOCAL_MAP_NR(kaddr))
+
+/*
+ * VALID_PAGE returns a non-zero value if given page pointer is valid.
+ * This assumes all node's mem_maps are stored within the node they refer to.
+ */
+#define VALID_PAGE(page) \
+({ unsigned int node = KVADDR_TO_NID(page); \
+   ( (node < NR_NODES) && \
+     ((unsigned)((page) - NODE_MEM_MAP(node)) < NODE_DATA(node)->node_size) ); \
+})
+
+#else
+
+#define PHYS_TO_NID(addr)	(0)
+
+#endif
+#endif /* __ASM_ARCH_MEMORY_H */
diff -Nurd u-boot-1.2.0/include/asm/arch-s3c44b0/hardware.h u-boot-1.2.0-leopard/include/asm/arch-s3c44b0/hardware.h
--- u-boot-1.2.0/include/asm/arch-s3c44b0/hardware.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-s3c44b0/hardware.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,281 @@
+/********************************************************/
+/*							*/
+/* Samsung S3C44B0					*/
+/* tpu <tapu@371.net>					*/
+/*							*/
+/********************************************************/
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#define REGBASE		0x01c00000
+#define REGL(addr)	(*(volatile unsigned int *)(REGBASE+addr))
+#define REGW(addr)	(*(volatile unsigned short *)(REGBASE+addr))
+#define REGB(addr)	(*(volatile unsigned char *)(REGBASE+addr))
+
+
+/*****************************/
+/* CPU Wrapper Registers     */
+/*****************************/
+
+#define SYSCFG		REGL(0x000000)
+#define NCACHBE0	REGL(0x000004)
+#define NCACHBE1	REGL(0x000008)
+#define SBUSCON		REGL(0x040000)
+
+/************************************/
+/* Memory Controller Registers      */
+/************************************/
+
+#define BWSCON		REGL(0x080000)
+#define BANKCON0	REGL(0x080004)
+#define BANKCON1	REGL(0x080008)
+#define BANKCON2	REGL(0x08000c)
+#define BANKCON3	REGL(0x080010)
+#define BANKCON4	REGL(0x080014)
+#define BANKCON5	REGL(0x080018)
+#define BANKCON6	REGL(0x08001c)
+#define BANKCON7	REGL(0x080020)
+#define REFRESH		REGL(0x080024)
+#define BANKSIZE	REGL(0x080028)
+#define MRSRB6		REGL(0x08002c)
+#define MRSRB7		REGL(0x080030)
+
+/*********************/
+/* UART Registers    */
+/*********************/
+
+#define ULCON0		REGL(0x100000)
+#define ULCON1		REGL(0x104000)
+#define UCON0		REGL(0x100004)
+#define UCON1		REGL(0x104004)
+#define UFCON0		REGL(0x100008)
+#define UFCON1		REGL(0x104008)
+#define UMCON0		REGL(0x10000c)
+#define UMCON1		REGL(0x10400c)
+#define UTRSTAT0	REGL(0x100010)
+#define UTRSTAT1	REGL(0x104010)
+#define UERSTAT0	REGL(0x100014)
+#define UERSTAT1	REGL(0x104014)
+#define UFSTAT0		REGL(0x100018)
+#define UFSTAT1		REGL(0x104018)
+#define UMSTAT0		REGL(0x10001c)
+#define UMSTAT1		REGL(0x10401c)
+#define UTXH0		REGB(0x100020)
+#define UTXH1		REGB(0x104020)
+#define URXH0		REGB(0x100024)
+#define URXH1		REGB(0x104024)
+#define UBRDIV0		REGL(0x100028)
+#define UBRDIV1		REGL(0x104028)
+
+/*******************/
+/* SIO Registers   */
+/*******************/
+
+#define SIOCON		REGL(0x114000)
+#define SIODAT		REGL(0x114004)
+#define SBRDR		REGL(0x114008)
+#define ITVCNT		REGL(0x11400c)
+#define DCNTZ		REGL(0x114010)
+
+/********************/
+/* IIS Registers    */
+/********************/
+
+#define IISCON		REGL(0x118000)
+#define IISMOD		REGL(0x118004)
+#define IISPSR		REGL(0x118008)
+#define IISFIFCON	REGL(0x11800c)
+#define IISFIF		REGW(0x118010)
+
+/**************************/
+/* I/O Ports Registers    */
+/**************************/
+
+#define PCONA		REGL(0x120000)
+#define PDATA		REGL(0x120004)
+#define PCONB		REGL(0x120008)
+#define PDATB		REGL(0x12000c)
+#define PCONC		REGL(0x120010)
+#define PDATC		REGL(0x120014)
+#define PUPC		REGL(0x120018)
+#define PCOND		REGL(0x12001c)
+#define PDATD		REGL(0x120020)
+#define PUPD		REGL(0x120024)
+#define PCONE		REGL(0x120028)
+#define PDATE		REGL(0x12002c)
+#define PUPE		REGL(0x120030)
+#define PCONF		REGL(0x120034)
+#define PDATF		REGL(0x120038)
+#define PUPF		REGL(0x12003c)
+#define PCONG		REGL(0x120040)
+#define PDATG		REGL(0x120044)
+#define PUPG		REGL(0x120048)
+#define SPUCR		REGL(0x12004c)
+#define EXTINT		REGL(0x120050)
+#define EXTINTPND	REGL(0x120054)
+
+/*********************************/
+/* WatchDog Timers Registers     */
+/*********************************/
+
+#define WTCON		REGL(0x130000)
+#define WTDAT		REGL(0x130004)
+#define WTCNT		REGL(0x130008)
+
+/*********************************/
+/* A/D Converter Registers       */
+/*********************************/
+
+#define ADCCON		REGL(0x140000)
+#define ADCPSR		REGL(0x140004)
+#define ADCDAT		REGL(0x140008)
+
+/***************************/
+/* PWM Timer Registers     */
+/***************************/
+
+#define TCFG0		REGL(0x150000)
+#define TCFG1		REGL(0x150004)
+#define TCON		REGL(0x150008)
+#define TCNTB0		REGL(0x15000c)
+#define TCMPB0		REGL(0x150010)
+#define TCNTO0		REGL(0x150014)
+#define TCNTB1		REGL(0x150018)
+#define TCMPB1		REGL(0x15001c)
+#define TCNTO1		REGL(0x150020)
+#define TCNTB2		REGL(0x150024)
+#define TCMPB2		REGL(0x150028)
+#define TCNTO2		REGL(0x15002c)
+#define TCNTB3		REGL(0x150030)
+#define TCMPB3		REGL(0x150034)
+#define TCNTO3		REGL(0x150038)
+#define TCNTB4		REGL(0x15003c)
+#define TCMPB4		REGL(0x150040)
+#define TCNTO4		REGL(0x150044)
+#define TCNTB5		REGL(0x150048)
+#define TCNTO5		REGL(0x15004c)
+
+/*********************/
+/* IIC Registers     */
+/*********************/
+
+#define IICCON		REGL(0x160000)
+#define IICSTAT		REGL(0x160004)
+#define IICADD		REGL(0x160008)
+#define IICDS		REGL(0x16000c)
+
+/*********************/
+/* RTC Registers     */
+/*********************/
+
+#define RTCCON		REGB(0x170040)
+#define RTCALM		REGB(0x170050)
+#define ALMSEC		REGB(0x170054)
+#define ALMMIN		REGB(0x170058)
+#define ALMHOUR		REGB(0x17005c)
+#define ALMDAY		REGB(0x170060)
+#define ALMMON		REGB(0x170064)
+#define ALMYEAR		REGB(0x170068)
+#define RTCRST		REGB(0x17006c)
+#define BCDSEC		REGB(0x170070)
+#define BCDMIN		REGB(0x170074)
+#define BCDHOUR		REGB(0x170078)
+#define BCDDAY		REGB(0x17007c)
+#define BCDDATE		REGB(0x170080)
+#define BCDMON		REGB(0x170084)
+#define BCDYEAR		REGB(0x170088)
+#define TICINT		REGB(0x17008c)
+
+/*********************************/
+/* Clock & Power Registers       */
+/*********************************/
+
+#define PLLCON		REGL(0x180000)
+#define CLKCON		REGL(0x180004)
+#define CLKSLOW		REGL(0x180008)
+#define LOCKTIME	REGL(0x18000c)
+
+/**************************************/
+/* Interrupt Controller Registers     */
+/**************************************/
+
+#define INTCON		REGL(0x200000)
+#define INTPND		REGL(0x200004)
+#define INTMOD		REGL(0x200008)
+#define INTMSK		REGL(0x20000c)
+#define I_PSLV		REGL(0x200010)
+#define I_PMST		REGL(0x200014)
+#define I_CSLV		REGL(0x200018)
+#define I_CMST		REGL(0x20001c)
+#define I_ISPR		REGL(0x200020)
+#define I_ISPC		REGL(0x200024)
+#define F_ISPR		REGL(0x200038)
+#define F_ISPC		REGL(0x20003c)
+
+/********************************/
+/* LCD Controller Registers     */
+/********************************/
+
+#define LCDCON1		REGL(0x300000)
+#define LCDCON2		REGL(0x300004)
+#define LCDSADDR1	REGL(0x300008)
+#define LCDSADDR2	REGL(0x30000c)
+#define LCDSADDR3	REGL(0x300010)
+#define REDLUT		REGL(0x300014)
+#define GREENLUT	REGL(0x300018)
+#define BLUELUT		REGL(0x30001c)
+#define DP1_2		REGL(0x300020)
+#define DP4_7		REGL(0x300024)
+#define DP3_5		REGL(0x300028)
+#define DP2_3		REGL(0x30002c)
+#define DP5_7		REGL(0x300030)
+#define DP3_4		REGL(0x300034)
+#define DP4_5		REGL(0x300038)
+#define DP6_7		REGL(0x30003c)
+#define LCDCON3		REGL(0x300040)
+#define DITHMODE	REGL(0x300044)
+
+/*********************/
+/* DMA Registers     */
+/*********************/
+
+#define ZDCON0		REGL(0x280000)
+#define ZDISRC0		REGL(0x280004)
+#define ZDIDES0		REGL(0x280008)
+#define ZDICNT0		REGL(0x28000c)
+#define ZDCSRC0		REGL(0x280010)
+#define ZDCDES0		REGL(0x280014)
+#define ZDCCNT0		REGL(0x280018)
+
+#define ZDCON1		REGL(0x280020)
+#define ZDISRC1		REGL(0x280024)
+#define ZDIDES1		REGL(0x280028)
+#define ZDICNT1		REGL(0x28002c)
+#define ZDCSRC1		REGL(0x280030)
+#define ZDCDES1		REGL(0x280034)
+#define ZDCCNT1		REGL(0x280038)
+
+#define BDCON0		REGL(0x380000)
+#define BDISRC0		REGL(0x380004)
+#define BDIDES0		REGL(0x380008)
+#define BDICNT0		REGL(0x38000c)
+#define BDCSRC0		REGL(0x380010)
+#define BDCDES0		REGL(0x380014)
+#define BDCCNT0		REGL(0x380018)
+
+#define BDCON1		REGL(0x380020)
+#define BDISRC1		REGL(0x380024)
+#define BDIDES1		REGL(0x380028)
+#define BDICNT1		REGL(0x38002c)
+#define BDCSRC1		REGL(0x380030)
+#define BDCDES1		REGL(0x380034)
+#define BDCCNT1		REGL(0x380038)
+
+
+#define CLEAR_PEND_INT(n)       I_ISPC = (1<<(n))
+#define INT_ENABLE(n)		INTMSK &= ~(1<<(n))
+#define INT_DISABLE(n)		INTMSK |= (1<<(n))
+
+#define HARD_RESET_NOW()
+
+#endif /* __ASM_ARCH_HARDWARE_H */
diff -Nurd u-boot-1.2.0/include/asm/arch-sa1100/bitfield.h u-boot-1.2.0-leopard/include/asm/arch-sa1100/bitfield.h
--- u-boot-1.2.0/include/asm/arch-sa1100/bitfield.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/arch-sa1100/bitfield.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,112 @@
+/*
+ *	FILE    	bitfield.h
+ *
+ *	Version 	1.1
+ *	Author  	Copyright (c) Marc A. Viredaz, 1998
+ *	        	DEC Western Research Laboratory, Palo Alto, CA
+ *	Date    	April 1998 (April 1997)
+ *	System  	Advanced RISC Machine (ARM)
+ *	Language	C or ARM Assembly
+ *	Purpose 	Definition of macros to operate on bit fields.
+ */
+
+
+#ifndef __BITFIELD_H
+#define __BITFIELD_H
+
+#ifndef __ASSEMBLY__
+#define UData(Data)	((unsigned long) (Data))
+#else
+#define UData(Data)	(Data)
+#endif
+
+
+/*
+ * MACRO: Fld
+ *
+ * Purpose
+ *    The macro "Fld" encodes a bit field, given its size and its shift value
+ *    with respect to bit 0.
+ *
+ * Note
+ *    A more intuitive way to encode bit fields would have been to use their
+ *    mask. However, extracting size and shift value information from a bit
+ *    field's mask is cumbersome and might break the assembler (255-character
+ *    line-size limit).
+ *
+ * Input
+ *    Size      	Size of the bit field, in number of bits.
+ *    Shft      	Shift value of the bit field with respect to bit 0.
+ *
+ * Output
+ *    Fld       	Encoded bit field.
+ */
+
+#define Fld(Size, Shft)	(((Size) << 16) + (Shft))
+
+
+/*
+ * MACROS: FSize, FShft, FMsk, FAlnMsk, F1stBit
+ *
+ * Purpose
+ *    The macros "FSize", "FShft", "FMsk", "FAlnMsk", and "F1stBit" return
+ *    the size, shift value, mask, aligned mask, and first bit of a
+ *    bit field.
+ *
+ * Input
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FSize     	Size of the bit field, in number of bits.
+ *    FShft     	Shift value of the bit field with respect to bit 0.
+ *    FMsk      	Mask for the bit field.
+ *    FAlnMsk   	Mask for the bit field, aligned on bit 0.
+ *    F1stBit   	First bit of the bit field.
+ */
+
+#define FSize(Field)	((Field) >> 16)
+#define FShft(Field)	((Field) & 0x0000FFFF)
+#define FMsk(Field)	(((UData (1) << FSize (Field)) - 1) << FShft (Field))
+#define FAlnMsk(Field)	((UData (1) << FSize (Field)) - 1)
+#define F1stBit(Field)	(UData (1) << FShft (Field))
+
+
+/*
+ * MACRO: FInsrt
+ *
+ * Purpose
+ *    The macro "FInsrt" inserts a value into a bit field by shifting the
+ *    former appropriately.
+ *
+ * Input
+ *    Value     	Bit-field value.
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FInsrt    	Bit-field value positioned appropriately.
+ */
+
+#define FInsrt(Value, Field) \
+			(UData (Value) << FShft (Field))
+
+
+/*
+ * MACRO: FExtr
+ *
+ * Purpose
+ *    The macro "FExtr" extracts the value of a bit field by masking and
+ *    shifting it appropriately.
+ *
+ * Input
+ *    Data      	Data containing the bit-field to be extracted.
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FExtr     	Bit-field value.
+ */
+
+#define FExtr(Data, Field) \
+			((UData (Data) >> FShft (Field)) & FAlnMsk (Field))
+
+
+#endif /* __BITFIELD_H */
diff -Nurd u-boot-1.2.0/include/asm/atomic.h u-boot-1.2.0-leopard/include/asm/atomic.h
--- u-boot-1.2.0/include/asm/atomic.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/atomic.h	2007-12-04 07:50:42.000000000 -0300
@@ -0,0 +1,113 @@
+/*
+ *  linux/include/asm-arm/atomic.h
+ *
+ *  Copyright (c) 1996 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Changelog:
+ *   27-06-1996	RMK	Created
+ *   13-04-1997	RMK	Made functions atomic!
+ *   07-12-1997	RMK	Upgraded for v2.1.
+ *   26-08-1998	PJB	Added #ifdef __KERNEL__
+ */
+#ifndef __ASM_ARM_ATOMIC_H
+#define __ASM_ARM_ATOMIC_H
+
+#include <linux/config.h>
+
+#ifdef CONFIG_SMP
+#error SMP not supported
+#endif
+
+typedef struct { volatile int counter; } atomic_t;
+
+#define ATOMIC_INIT(i)	{ (i) }
+
+#ifdef __KERNEL__
+#include <asm/proc/system.h>
+
+#define atomic_read(v)	((v)->counter)
+#define atomic_set(v,i)	(((v)->counter) = (i))
+
+static inline void atomic_add(int i, volatile atomic_t *v)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	v->counter += i;
+	local_irq_restore(flags);
+}
+
+static inline void atomic_sub(int i, volatile atomic_t *v)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	v->counter -= i;
+	local_irq_restore(flags);
+}
+
+static inline void atomic_inc(volatile atomic_t *v)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	v->counter += 1;
+	local_irq_restore(flags);
+}
+
+static inline void atomic_dec(volatile atomic_t *v)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	v->counter -= 1;
+	local_irq_restore(flags);
+}
+
+static inline int atomic_dec_and_test(volatile atomic_t *v)
+{
+	unsigned long flags;
+	int val;
+
+	local_irq_save(flags);
+	val = v->counter;
+	v->counter = val -= 1;
+	local_irq_restore(flags);
+
+	return val == 0;
+}
+
+static inline int atomic_add_negative(int i, volatile atomic_t *v)
+{
+	unsigned long flags;
+	int val;
+
+	local_irq_save(flags);
+	val = v->counter;
+	v->counter = val += i;
+	local_irq_restore(flags);
+
+	return val < 0;
+}
+
+static inline void atomic_clear_mask(unsigned long mask, unsigned long *addr)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	*addr &= ~mask;
+	local_irq_restore(flags);
+}
+
+/* Atomic operations are already serializing on ARM */
+#define smp_mb__before_atomic_dec()	barrier()
+#define smp_mb__after_atomic_dec()	barrier()
+#define smp_mb__before_atomic_inc()	barrier()
+#define smp_mb__after_atomic_inc()	barrier()
+
+#endif
+#endif
diff -Nurd u-boot-1.2.0/include/asm/bitops.h u-boot-1.2.0-leopard/include/asm/bitops.h
--- u-boot-1.2.0/include/asm/bitops.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/bitops.h	2007-12-04 07:50:42.000000000 -0300
@@ -0,0 +1,144 @@
+/*
+ * Copyright 1995, Russell King.
+ * Various bits and pieces copyrights include:
+ *  Linus Torvalds (test_bit).
+ *
+ * bit 0 is the LSB of addr; bit 32 is the LSB of (addr+1).
+ *
+ * Please note that the code in this file should never be included
+ * from user space.  Many of these are not implemented in assembler
+ * since they would be too costly.  Also, they require priviledged
+ * instructions (which are not available from user mode) to ensure
+ * that they are atomic.
+ */
+
+#ifndef __ASM_ARM_BITOPS_H
+#define __ASM_ARM_BITOPS_H
+
+#ifdef __KERNEL__
+
+#define smp_mb__before_clear_bit()	do { } while (0)
+#define smp_mb__after_clear_bit()	do { } while (0)
+
+/*
+ * Function prototypes to keep gcc -Wall happy.
+ */
+extern void set_bit(int nr, volatile void * addr);
+
+static inline void __set_bit(int nr, volatile void *addr)
+{
+	((unsigned char *) addr)[nr >> 3] |= (1U << (nr & 7));
+}
+
+extern void clear_bit(int nr, volatile void * addr);
+
+static inline void __clear_bit(int nr, volatile void *addr)
+{
+	((unsigned char *) addr)[nr >> 3] &= ~(1U << (nr & 7));
+}
+
+extern void change_bit(int nr, volatile void * addr);
+
+static inline void __change_bit(int nr, volatile void *addr)
+{
+	((unsigned char *) addr)[nr >> 3] ^= (1U << (nr & 7));
+}
+
+extern int test_and_set_bit(int nr, volatile void * addr);
+
+static inline int __test_and_set_bit(int nr, volatile void *addr)
+{
+	unsigned int mask = 1 << (nr & 7);
+	unsigned int oldval;
+
+	oldval = ((unsigned char *) addr)[nr >> 3];
+	((unsigned char *) addr)[nr >> 3] = oldval | mask;
+	return oldval & mask;
+}
+
+extern int test_and_clear_bit(int nr, volatile void * addr);
+
+static inline int __test_and_clear_bit(int nr, volatile void *addr)
+{
+	unsigned int mask = 1 << (nr & 7);
+	unsigned int oldval;
+
+	oldval = ((unsigned char *) addr)[nr >> 3];
+	((unsigned char *) addr)[nr >> 3] = oldval & ~mask;
+	return oldval & mask;
+}
+
+extern int test_and_change_bit(int nr, volatile void * addr);
+
+static inline int __test_and_change_bit(int nr, volatile void *addr)
+{
+	unsigned int mask = 1 << (nr & 7);
+	unsigned int oldval;
+
+	oldval = ((unsigned char *) addr)[nr >> 3];
+	((unsigned char *) addr)[nr >> 3] = oldval ^ mask;
+	return oldval & mask;
+}
+
+extern int find_first_zero_bit(void * addr, unsigned size);
+extern int find_next_zero_bit(void * addr, int size, int offset);
+
+/*
+ * This routine doesn't need to be atomic.
+ */
+static inline int test_bit(int nr, const void * addr)
+{
+    return ((unsigned char *) addr)[nr >> 3] & (1U << (nr & 7));
+}
+
+/*
+ * ffz = Find First Zero in word. Undefined if no zero exists,
+ * so code should check against ~0UL first..
+ */
+static inline unsigned long ffz(unsigned long word)
+{
+	int k;
+
+	word = ~word;
+	k = 31;
+	if (word & 0x0000ffff) { k -= 16; word <<= 16; }
+	if (word & 0x00ff0000) { k -= 8;  word <<= 8;  }
+	if (word & 0x0f000000) { k -= 4;  word <<= 4;  }
+	if (word & 0x30000000) { k -= 2;  word <<= 2;  }
+	if (word & 0x40000000) { k -= 1; }
+	return k;
+}
+
+/*
+ * ffs: find first bit set. This is defined the same way as
+ * the libc and compiler builtin ffs routines, therefore
+ * differs in spirit from the above ffz (man ffs).
+ */
+
+#define ffs(x) generic_ffs(x)
+
+/*
+ * hweightN: returns the hamming weight (i.e. the number
+ * of bits set) of a N-bit word
+ */
+
+#define hweight32(x) generic_hweight32(x)
+#define hweight16(x) generic_hweight16(x)
+#define hweight8(x) generic_hweight8(x)
+
+#define ext2_set_bit			test_and_set_bit
+#define ext2_clear_bit			test_and_clear_bit
+#define ext2_test_bit			test_bit
+#define ext2_find_first_zero_bit	find_first_zero_bit
+#define ext2_find_next_zero_bit		find_next_zero_bit
+
+/* Bitmap functions for the minix filesystem. */
+#define minix_test_and_set_bit(nr,addr)	test_and_set_bit(nr,addr)
+#define minix_set_bit(nr,addr)		set_bit(nr,addr)
+#define minix_test_and_clear_bit(nr,addr)	test_and_clear_bit(nr,addr)
+#define minix_test_bit(nr,addr)		test_bit(nr,addr)
+#define minix_find_first_zero_bit(addr,size)	find_first_zero_bit(addr,size)
+
+#endif /* __KERNEL__ */
+
+#endif /* _ARM_BITOPS_H */
diff -Nurd u-boot-1.2.0/include/asm/byteorder.h u-boot-1.2.0-leopard/include/asm/byteorder.h
--- u-boot-1.2.0/include/asm/byteorder.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/byteorder.h	2007-12-04 07:50:42.000000000 -0300
@@ -0,0 +1,32 @@
+/*
+ *  linux/include/asm-arm/byteorder.h
+ *
+ * ARM Endian-ness.  In little endian mode, the data bus is connected such
+ * that byte accesses appear as:
+ *  0 = d0...d7, 1 = d8...d15, 2 = d16...d23, 3 = d24...d31
+ * and word accesses (data or instruction) appear as:
+ *  d0...d31
+ *
+ * When in big endian mode, byte accesses appear as:
+ *  0 = d24...d31, 1 = d16...d23, 2 = d8...d15, 3 = d0...d7
+ * and word accesses (data or instruction) appear as:
+ *  d0...d31
+ */
+#ifndef __ASM_ARM_BYTEORDER_H
+#define __ASM_ARM_BYTEORDER_H
+
+
+#include <asm/types.h>
+
+#if !defined(__STRICT_ANSI__) || defined(__KERNEL__)
+#  define __BYTEORDER_HAS_U64__
+#  define __SWAB_64_THRU_32__
+#endif
+
+#ifdef __ARMEB__
+#include <linux/byteorder/big_endian.h>
+#else
+#include <linux/byteorder/little_endian.h>
+#endif
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/errno.h u-boot-1.2.0-leopard/include/asm/errno.h
--- u-boot-1.2.0/include/asm/errno.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/errno.h	2007-12-04 07:50:42.000000000 -0300
@@ -0,0 +1,138 @@
+#ifndef _ARM_ERRNO_H
+#define _ARM_ERRNO_H
+
+#define	EPERM		 1	/* Operation not permitted */
+#define	ENOENT		 2	/* No such file or directory */
+#define	ESRCH		 3	/* No such process */
+#define	EINTR		 4	/* Interrupted system call */
+#define	EIO		 5	/* I/O error */
+#define	ENXIO		 6	/* No such device or address */
+#define	E2BIG		 7	/* Arg list too long */
+#define	ENOEXEC		 8	/* Exec format error */
+#define	EBADF		 9	/* Bad file number */
+#define	ECHILD		10	/* No child processes */
+#define	EAGAIN		11	/* Try again */
+#define	ENOMEM		12	/* Out of memory */
+#define	EACCES		13	/* Permission denied */
+#define	EFAULT		14	/* Bad address */
+#define	ENOTBLK		15	/* Block device required */
+#define	EBUSY		16	/* Device or resource busy */
+#define	EEXIST		17	/* File exists */
+#define	EXDEV		18	/* Cross-device link */
+#define	ENODEV		19	/* No such device */
+#define	ENOTDIR		20	/* Not a directory */
+#define	EISDIR		21	/* Is a directory */
+#define	EINVAL		22	/* Invalid argument */
+#define	ENFILE		23	/* File table overflow */
+#define	EMFILE		24	/* Too many open files */
+#define	ENOTTY		25	/* Not a typewriter */
+#define	ETXTBSY		26	/* Text file busy */
+#define	EFBIG		27	/* File too large */
+#define	ENOSPC		28	/* No space left on device */
+#define	ESPIPE		29	/* Illegal seek */
+#define	EROFS		30	/* Read-only file system */
+#define	EMLINK		31	/* Too many links */
+#define	EPIPE		32	/* Broken pipe */
+#define	EDOM		33	/* Math argument out of domain of func */
+#define	ERANGE		34	/* Math result not representable */
+#define	EDEADLK		35	/* Resource deadlock would occur */
+#define	ENAMETOOLONG	36	/* File name too long */
+#define	ENOLCK		37	/* No record locks available */
+#define	ENOSYS		38	/* Function not implemented */
+#define	ENOTEMPTY	39	/* Directory not empty */
+#define	ELOOP		40	/* Too many symbolic links encountered */
+#define	EWOULDBLOCK	EAGAIN	/* Operation would block */
+#define	ENOMSG		42	/* No message of desired type */
+#define	EIDRM		43	/* Identifier removed */
+#define	ECHRNG		44	/* Channel number out of range */
+#define	EL2NSYNC	45	/* Level 2 not synchronized */
+#define	EL3HLT		46	/* Level 3 halted */
+#define	EL3RST		47	/* Level 3 reset */
+#define	ELNRNG		48	/* Link number out of range */
+#define	EUNATCH		49	/* Protocol driver not attached */
+#define	ENOCSI		50	/* No CSI structure available */
+#define	EL2HLT		51	/* Level 2 halted */
+#define	EBADE		52	/* Invalid exchange */
+#define	EBADR		53	/* Invalid request descriptor */
+#define	EXFULL		54	/* Exchange full */
+#define	ENOANO		55	/* No anode */
+#define	EBADRQC		56	/* Invalid request code */
+#define	EBADSLT		57	/* Invalid slot */
+#define	EDEADLOCK	58	/* File locking deadlock error */
+#define	EBFONT		59	/* Bad font file format */
+#define	ENOSTR		60	/* Device not a stream */
+#define	ENODATA		61	/* No data available */
+#define	ETIME		62	/* Timer expired */
+#define	ENOSR		63	/* Out of streams resources */
+#define	ENONET		64	/* Machine is not on the network */
+#define	ENOPKG		65	/* Package not installed */
+#define	EREMOTE		66	/* Object is remote */
+#define	ENOLINK		67	/* Link has been severed */
+#define	EADV		68	/* Advertise error */
+#define	ESRMNT		69	/* Srmount error */
+#define	ECOMM		70	/* Communication error on send */
+#define	EPROTO		71	/* Protocol error */
+#define	EMULTIHOP	72	/* Multihop attempted */
+#define	EDOTDOT		73	/* RFS specific error */
+#define	EBADMSG		74	/* Not a data message */
+#define	EOVERFLOW	75	/* Value too large for defined data type */
+#define	ENOTUNIQ	76	/* Name not unique on network */
+#define	EBADFD		77	/* File descriptor in bad state */
+#define	EREMCHG		78	/* Remote address changed */
+#define	ELIBACC		79	/* Can not access a needed shared library */
+#define	ELIBBAD		80	/* Accessing a corrupted shared library */
+#define	ELIBSCN		81	/* .lib section in a.out corrupted */
+#define	ELIBMAX		82	/* Attempting to link in too many shared libraries */
+#define	ELIBEXEC	83	/* Cannot exec a shared library directly */
+#define	EILSEQ		84	/* Illegal byte sequence */
+#define	ERESTART	85	/* Interrupted system call should be restarted */
+#define	ESTRPIPE	86	/* Streams pipe error */
+#define	EUSERS		87	/* Too many users */
+#define	ENOTSOCK	88	/* Socket operation on non-socket */
+#define	EDESTADDRREQ	89	/* Destination address required */
+#define	EMSGSIZE	90	/* Message too long */
+#define	EPROTOTYPE	91	/* Protocol wrong type for socket */
+#define	ENOPROTOOPT	92	/* Protocol not available */
+#define	EPROTONOSUPPORT	93	/* Protocol not supported */
+#define	ESOCKTNOSUPPORT	94	/* Socket type not supported */
+#define	EOPNOTSUPP	95	/* Operation not supported on transport endpoint */
+#define	EPFNOSUPPORT	96	/* Protocol family not supported */
+#define	EAFNOSUPPORT	97	/* Address family not supported by protocol */
+#define	EADDRINUSE	98	/* Address already in use */
+#define	EADDRNOTAVAIL	99	/* Cannot assign requested address */
+#define	ENETDOWN	100	/* Network is down */
+#define	ENETUNREACH	101	/* Network is unreachable */
+#define	ENETRESET	102	/* Network dropped connection because of reset */
+#define	ECONNABORTED	103	/* Software caused connection abort */
+#define	ECONNRESET	104	/* Connection reset by peer */
+#define	ENOBUFS		105	/* No buffer space available */
+#define	EISCONN		106	/* Transport endpoint is already connected */
+#define	ENOTCONN	107	/* Transport endpoint is not connected */
+#define	ESHUTDOWN	108	/* Cannot send after transport endpoint shutdown */
+#define	ETOOMANYREFS	109	/* Too many references: cannot splice */
+#define	ETIMEDOUT	110	/* Connection timed out */
+#define	ECONNREFUSED	111	/* Connection refused */
+#define	EHOSTDOWN	112	/* Host is down */
+#define	EHOSTUNREACH	113	/* No route to host */
+#define	EALREADY	114	/* Operation already in progress */
+#define	EINPROGRESS	115	/* Operation now in progress */
+#define	ESTALE		116	/* Stale NFS file handle */
+#define	EUCLEAN		117	/* Structure needs cleaning */
+#define	ENOTNAM		118	/* Not a XENIX named type file */
+#define	ENAVAIL		119	/* No XENIX semaphores available */
+#define	EISNAM		120	/* Is a named type file */
+#define	EREMOTEIO	121	/* Remote I/O error */
+#define	EDQUOT		122	/* Quota exceeded */
+
+#define	ENOMEDIUM	123	/* No medium found */
+#define	EMEDIUMTYPE	124	/* Wrong medium type */
+
+/* Should never be seen by user programs */
+#define ERESTARTSYS	512
+#define ERESTARTNOINTR	513
+#define ERESTARTNOHAND	514	/* restart if no handler.. */
+#define ENOIOCTLCMD	515	/* No ioctl command */
+
+#define _LAST_ERRNO	515
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/global_data.h u-boot-1.2.0-leopard/include/asm/global_data.h
--- u-boot-1.2.0/include/asm/global_data.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/global_data.h	2007-12-04 07:50:42.000000000 -0300
@@ -0,0 +1,66 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef	__ASM_GBL_DATA_H
+#define __ASM_GBL_DATA_H
+/*
+ * The following data structure is placed in some memory wich is
+ * available very early after boot (like DPRAM on MPC8xx/MPC82xx, or
+ * some locked parts of the data cache) to allow for a minimum set of
+ * global variables during system initialization (until we have set
+ * up the memory controller so that we can use RAM).
+ *
+ * Keep it *SMALL* and remember to set CFG_GBL_DATA_SIZE > sizeof(gd_t)
+ */
+
+typedef	struct	global_data {
+	bd_t		*bd;
+	unsigned long	flags;
+	unsigned long	baudrate;
+	unsigned long	have_console;	/* serial_init() was called */
+	unsigned long	reloc_off;	/* Relocation Offset */
+	unsigned long	env_addr;	/* Address  of Environment struct */
+	unsigned long	env_valid;	/* Checksum of Environment valid? */
+	unsigned long	fb_base;	/* base address of frame buffer */
+#ifdef CONFIG_VFD
+	unsigned char	vfd_type;	/* display type */
+#endif
+#if 0
+	unsigned long	cpu_clk;	/* CPU clock in Hz!		*/
+	unsigned long	bus_clk;
+	unsigned long	ram_size;	/* RAM size */
+	unsigned long	reset_status;	/* reset status register at boot */
+#endif
+	void		**jt;		/* jump table */
+} gd_t;
+
+/*
+ * Global Data Flags
+ */
+#define	GD_FLG_RELOC	0x00001		/* Code was relocated to RAM		*/
+#define	GD_FLG_DEVINIT	0x00002		/* Devices have been initialized	*/
+#define	GD_FLG_SILENT	0x00004		/* Silent mode				*/
+
+#define DECLARE_GLOBAL_DATA_PTR     register volatile gd_t *gd asm ("r8")
+
+#endif /* __ASM_GBL_DATA_H */
diff -Nurd u-boot-1.2.0/include/asm/hardware.h u-boot-1.2.0-leopard/include/asm/hardware.h
--- u-boot-1.2.0/include/asm/hardware.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/hardware.h	2007-12-04 07:50:42.000000000 -0300
@@ -0,0 +1,18 @@
+/*
+ *  linux/include/asm-arm/hardware.h
+ *
+ *  Copyright (C) 1996 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Common hardware definitions
+ */
+
+#ifndef __ASM_HARDWARE_H
+#define __ASM_HARDWARE_H
+
+#include <asm/arch/hardware.h>
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/io.h u-boot-1.2.0-leopard/include/asm/io.h
--- u-boot-1.2.0/include/asm/io.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/io.h	2007-12-04 07:50:42.000000000 -0300
@@ -0,0 +1,307 @@
+/*
+ *  linux/include/asm-arm/io.h
+ *
+ *  Copyright (C) 1996-2000 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Modifications:
+ *  16-Sep-1996	RMK	Inlined the inx/outx functions & optimised for both
+ *			constant addresses and variable addresses.
+ *  04-Dec-1997	RMK	Moved a lot of this stuff to the new architecture
+ *			specific IO header files.
+ *  27-Mar-1999	PJB	Second parameter of memcpy_toio is const..
+ *  04-Apr-1999	PJB	Added check_signature.
+ *  12-Dec-1999	RMK	More cleanups
+ *  18-Jun-2000 RMK	Removed virt_to_* and friends definitions
+ */
+#ifndef __ASM_ARM_IO_H
+#define __ASM_ARM_IO_H
+
+#ifdef __KERNEL__
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+#include <asm/memory.h>
+#if 0	/* XXX###XXX */
+#include <asm/arch/hardware.h>
+#endif	/* XXX###XXX */
+
+/*
+ * Generic virtual read/write.  Note that we don't support half-word
+ * read/writes.  We define __arch_*[bl] here, and leave __arch_*w
+ * to the architecture specific code.
+ */
+#define __arch_getb(a)			(*(volatile unsigned char *)(a))
+#define __arch_getw(a)			(*(volatile unsigned short *)(a))
+#define __arch_getl(a)			(*(volatile unsigned int *)(a))
+
+#define __arch_putb(v,a)		(*(volatile unsigned char *)(a) = (v))
+#define __arch_putw(v,a)		(*(volatile unsigned short *)(a) = (v))
+#define __arch_putl(v,a)		(*(volatile unsigned int *)(a) = (v))
+
+extern void __raw_writesb(unsigned int addr, const void *data, int bytelen);
+extern void __raw_writesw(unsigned int addr, const void *data, int wordlen);
+extern void __raw_writesl(unsigned int addr, const void *data, int longlen);
+
+extern void __raw_readsb(unsigned int addr, void *data, int bytelen);
+extern void __raw_readsw(unsigned int addr, void *data, int wordlen);
+extern void __raw_readsl(unsigned int addr, void *data, int longlen);
+
+#define __raw_writeb(v,a)		__arch_putb(v,a)
+#define __raw_writew(v,a)		__arch_putw(v,a)
+#define __raw_writel(v,a)		__arch_putl(v,a)
+
+#define __raw_readb(a)			__arch_getb(a)
+#define __raw_readw(a)			__arch_getw(a)
+#define __raw_readl(a)			__arch_getl(a)
+
+#define writeb(v,a)			__arch_putb(v,a)
+#define writew(v,a)			__arch_putw(v,a)
+#define writel(v,a)			__arch_putl(v,a)
+
+#define readb(a)			__arch_getb(a)
+#define readw(a)			__arch_getw(a)
+#define readl(a)			__arch_getl(a)
+
+/*
+ * The compiler seems to be incapable of optimising constants
+ * properly.  Spell it out to the compiler in some cases.
+ * These are only valid for small values of "off" (< 1<<12)
+ */
+#define __raw_base_writeb(val,base,off)	__arch_base_putb(val,base,off)
+#define __raw_base_writew(val,base,off)	__arch_base_putw(val,base,off)
+#define __raw_base_writel(val,base,off)	__arch_base_putl(val,base,off)
+
+#define __raw_base_readb(base,off)	__arch_base_getb(base,off)
+#define __raw_base_readw(base,off)	__arch_base_getw(base,off)
+#define __raw_base_readl(base,off)	__arch_base_getl(base,off)
+
+/*
+ * Now, pick up the machine-defined IO definitions
+ */
+#if 0	/* XXX###XXX */
+#include <asm/arch/io.h>
+#endif	/* XXX###XXX */
+
+/*
+ *  IO port access primitives
+ *  -------------------------
+ *
+ * The ARM doesn't have special IO access instructions; all IO is memory
+ * mapped.  Note that these are defined to perform little endian accesses
+ * only.  Their primary purpose is to access PCI and ISA peripherals.
+ *
+ * Note that for a big endian machine, this implies that the following
+ * big endian mode connectivity is in place, as described by numerious
+ * ARM documents:
+ *
+ *    PCI:  D0-D7   D8-D15 D16-D23 D24-D31
+ *    ARM: D24-D31 D16-D23  D8-D15  D0-D7
+ *
+ * The machine specific io.h include defines __io to translate an "IO"
+ * address to a memory address.
+ *
+ * Note that we prevent GCC re-ordering or caching values in expressions
+ * by introducing sequence points into the in*() definitions.  Note that
+ * __raw_* do not guarantee this behaviour.
+ *
+ * The {in,out}[bwl] macros are for emulating x86-style PCI/ISA IO space.
+ */
+#ifdef __io
+#define outb(v,p)			__raw_writeb(v,__io(p))
+#define outw(v,p)			__raw_writew(cpu_to_le16(v),__io(p))
+#define outl(v,p)			__raw_writel(cpu_to_le32(v),__io(p))
+
+#define inb(p)	({ unsigned int __v = __raw_readb(__io(p)); __v; })
+#define inw(p)	({ unsigned int __v = le16_to_cpu(__raw_readw(__io(p))); __v; })
+#define inl(p)	({ unsigned int __v = le32_to_cpu(__raw_readl(__io(p))); __v; })
+
+#define outsb(p,d,l)			__raw_writesb(__io(p),d,l)
+#define outsw(p,d,l)			__raw_writesw(__io(p),d,l)
+#define outsl(p,d,l)			__raw_writesl(__io(p),d,l)
+
+#define insb(p,d,l)			__raw_readsb(__io(p),d,l)
+#define insw(p,d,l)			__raw_readsw(__io(p),d,l)
+#define insl(p,d,l)			__raw_readsl(__io(p),d,l)
+#endif
+
+#define outb_p(val,port)		outb((val),(port))
+#define outw_p(val,port)		outw((val),(port))
+#define outl_p(val,port)		outl((val),(port))
+#define inb_p(port)			inb((port))
+#define inw_p(port)			inw((port))
+#define inl_p(port)			inl((port))
+
+#define outsb_p(port,from,len)		outsb(port,from,len)
+#define outsw_p(port,from,len)		outsw(port,from,len)
+#define outsl_p(port,from,len)		outsl(port,from,len)
+#define insb_p(port,to,len)		insb(port,to,len)
+#define insw_p(port,to,len)		insw(port,to,len)
+#define insl_p(port,to,len)		insl(port,to,len)
+
+/*
+ * ioremap and friends.
+ *
+ * ioremap takes a PCI memory address, as specified in
+ * linux/Documentation/IO-mapping.txt.  If you want a
+ * physical address, use __ioremap instead.
+ */
+extern void * __ioremap(unsigned long offset, size_t size, unsigned long flags);
+extern void __iounmap(void *addr);
+
+/*
+ * Generic ioremap support.
+ *
+ * Define:
+ *  iomem_valid_addr(off,size)
+ *  iomem_to_phys(off)
+ */
+#ifdef iomem_valid_addr
+#define __arch_ioremap(off,sz,nocache)				\
+ ({								\
+	unsigned long _off = (off), _size = (sz);		\
+	void *_ret = (void *)0;					\
+	if (iomem_valid_addr(_off, _size))			\
+		_ret = __ioremap(iomem_to_phys(_off),_size,0);	\
+	_ret;							\
+ })
+
+#define __arch_iounmap __iounmap
+#endif
+
+#define ioremap(off,sz)			__arch_ioremap((off),(sz),0)
+#define ioremap_nocache(off,sz)		__arch_ioremap((off),(sz),1)
+#define iounmap(_addr)			__arch_iounmap(_addr)
+
+/*
+ * DMA-consistent mapping functions.  These allocate/free a region of
+ * uncached, unwrite-buffered mapped memory space for use with DMA
+ * devices.  This is the "generic" version.  The PCI specific version
+ * is in pci.h
+ */
+extern void *consistent_alloc(int gfp, size_t size, dma_addr_t *handle);
+extern void consistent_free(void *vaddr, size_t size, dma_addr_t handle);
+extern void consistent_sync(void *vaddr, size_t size, int rw);
+
+/*
+ * String version of IO memory access ops:
+ */
+extern void _memcpy_fromio(void *, unsigned long, size_t);
+extern void _memcpy_toio(unsigned long, const void *, size_t);
+extern void _memset_io(unsigned long, int, size_t);
+
+extern void __readwrite_bug(const char *fn);
+
+/*
+ * If this architecture has PCI memory IO, then define the read/write
+ * macros.  These should only be used with the cookie passed from
+ * ioremap.
+ */
+#ifdef __mem_pci
+
+#define readb(c) ({ unsigned int __v = __raw_readb(__mem_pci(c)); __v; })
+#define readw(c) ({ unsigned int __v = le16_to_cpu(__raw_readw(__mem_pci(c))); __v; })
+#define readl(c) ({ unsigned int __v = le32_to_cpu(__raw_readl(__mem_pci(c))); __v; })
+
+#define writeb(v,c)		__raw_writeb(v,__mem_pci(c))
+#define writew(v,c)		__raw_writew(cpu_to_le16(v),__mem_pci(c))
+#define writel(v,c)		__raw_writel(cpu_to_le32(v),__mem_pci(c))
+
+#define memset_io(c,v,l)		_memset_io(__mem_pci(c),(v),(l))
+#define memcpy_fromio(a,c,l)		_memcpy_fromio((a),__mem_pci(c),(l))
+#define memcpy_toio(c,a,l)		_memcpy_toio(__mem_pci(c),(a),(l))
+
+#define eth_io_copy_and_sum(s,c,l,b) \
+				eth_copy_and_sum((s),__mem_pci(c),(l),(b))
+
+static inline int
+check_signature(unsigned long io_addr, const unsigned char *signature,
+		int length)
+{
+	int retval = 0;
+	do {
+		if (readb(io_addr) != *signature)
+			goto out;
+		io_addr++;
+		signature++;
+		length--;
+	} while (length);
+	retval = 1;
+out:
+	return retval;
+}
+
+#elif !defined(readb)
+
+#define readb(addr)			(__readwrite_bug("readb"),0)
+#define readw(addr)			(__readwrite_bug("readw"),0)
+#define readl(addr)			(__readwrite_bug("readl"),0)
+#define writeb(v,addr)			__readwrite_bug("writeb")
+#define writew(v,addr)			__readwrite_bug("writew")
+#define writel(v,addr)			__readwrite_bug("writel")
+
+#define eth_io_copy_and_sum(a,b,c,d)	__readwrite_bug("eth_io_copy_and_sum")
+
+#define check_signature(io,sig,len)	(0)
+
+#endif	/* __mem_pci */
+
+/*
+ * If this architecture has ISA IO, then define the isa_read/isa_write
+ * macros.
+ */
+#ifdef __mem_isa
+
+#define isa_readb(addr)			__raw_readb(__mem_isa(addr))
+#define isa_readw(addr)			__raw_readw(__mem_isa(addr))
+#define isa_readl(addr)			__raw_readl(__mem_isa(addr))
+#define isa_writeb(val,addr)		__raw_writeb(val,__mem_isa(addr))
+#define isa_writew(val,addr)		__raw_writew(val,__mem_isa(addr))
+#define isa_writel(val,addr)		__raw_writel(val,__mem_isa(addr))
+#define isa_memset_io(a,b,c)		_memset_io(__mem_isa(a),(b),(c))
+#define isa_memcpy_fromio(a,b,c)	_memcpy_fromio((a),__mem_isa(b),(c))
+#define isa_memcpy_toio(a,b,c)		_memcpy_toio(__mem_isa((a)),(b),(c))
+
+#define isa_eth_io_copy_and_sum(a,b,c,d) \
+				eth_copy_and_sum((a),__mem_isa(b),(c),(d))
+
+static inline int
+isa_check_signature(unsigned long io_addr, const unsigned char *signature,
+		    int length)
+{
+	int retval = 0;
+	do {
+		if (isa_readb(io_addr) != *signature)
+			goto out;
+		io_addr++;
+		signature++;
+		length--;
+	} while (length);
+	retval = 1;
+out:
+	return retval;
+}
+
+#else	/* __mem_isa */
+
+#define isa_readb(addr)			(__readwrite_bug("isa_readb"),0)
+#define isa_readw(addr)			(__readwrite_bug("isa_readw"),0)
+#define isa_readl(addr)			(__readwrite_bug("isa_readl"),0)
+#define isa_writeb(val,addr)		__readwrite_bug("isa_writeb")
+#define isa_writew(val,addr)		__readwrite_bug("isa_writew")
+#define isa_writel(val,addr)		__readwrite_bug("isa_writel")
+#define isa_memset_io(a,b,c)		__readwrite_bug("isa_memset_io")
+#define isa_memcpy_fromio(a,b,c)	__readwrite_bug("isa_memcpy_fromio")
+#define isa_memcpy_toio(a,b,c)		__readwrite_bug("isa_memcpy_toio")
+
+#define isa_eth_io_copy_and_sum(a,b,c,d) \
+				__readwrite_bug("isa_eth_io_copy_and_sum")
+
+#define isa_check_signature(io,sig,len)	(0)
+
+#endif	/* __mem_isa */
+#endif	/* __KERNEL__ */
+#endif	/* __ASM_ARM_IO_H */
diff -Nurd u-boot-1.2.0/include/asm/mach-types.h u-boot-1.2.0-leopard/include/asm/mach-types.h
--- u-boot-1.2.0/include/asm/mach-types.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/mach-types.h	2007-12-04 07:50:42.000000000 -0300
@@ -0,0 +1,9415 @@
+/*
+ * This was automagically generated from arch/arm/tools/mach-types!
+ * Do NOT edit
+ */
+
+#ifndef __ASM_ARM_MACH_TYPE_H
+#define __ASM_ARM_MACH_TYPE_H
+
+#include <linux/config.h>
+
+#ifndef __ASSEMBLY__
+/* The type of machine we're running on */
+extern unsigned int __machine_arch_type;
+#endif
+
+/* see arch/arm/kernel/arch.c for a description of these */
+#define MACH_TYPE_EBSA110              0
+#define MACH_TYPE_RISCPC               1
+#define MACH_TYPE_NEXUSPCI             3
+#define MACH_TYPE_EBSA285              4
+#define MACH_TYPE_NETWINDER            5
+#define MACH_TYPE_CATS                 6
+#define MACH_TYPE_TBOX                 7
+#define MACH_TYPE_CO285                8
+#define MACH_TYPE_CLPS7110             9
+#define MACH_TYPE_ARCHIMEDES           10
+#define MACH_TYPE_A5K                  11
+#define MACH_TYPE_ETOILE               12
+#define MACH_TYPE_LACIE_NAS            13
+#define MACH_TYPE_CLPS7500             14
+#define MACH_TYPE_SHARK                15
+#define MACH_TYPE_BRUTUS               16
+#define MACH_TYPE_PERSONAL_SERVER      17
+#define MACH_TYPE_ITSY                 18
+#define MACH_TYPE_L7200                19
+#define MACH_TYPE_PLEB                 20
+#define MACH_TYPE_INTEGRATOR           21
+#define MACH_TYPE_H3600                22
+#define MACH_TYPE_IXP1200              23
+#define MACH_TYPE_P720T                24
+#define MACH_TYPE_ASSABET              25
+#define MACH_TYPE_VICTOR               26
+#define MACH_TYPE_LART                 27
+#define MACH_TYPE_RANGER               28
+#define MACH_TYPE_GRAPHICSCLIENT       29
+#define MACH_TYPE_XP860                30
+#define MACH_TYPE_CERF                 31
+#define MACH_TYPE_NANOENGINE           32
+#define MACH_TYPE_FPIC                 33
+#define MACH_TYPE_EXTENEX1             34
+#define MACH_TYPE_SHERMAN              35
+#define MACH_TYPE_ACCELENT_SA          36
+#define MACH_TYPE_ACCELENT_L7200       37
+#define MACH_TYPE_NETPORT              38
+#define MACH_TYPE_PANGOLIN             39
+#define MACH_TYPE_YOPY                 40
+#define MACH_TYPE_COOLIDGE             41
+#define MACH_TYPE_HUW_WEBPANEL         42
+#define MACH_TYPE_SPOTME               43
+#define MACH_TYPE_FREEBIRD             44
+#define MACH_TYPE_TI925                45
+#define MACH_TYPE_RISCSTATION          46
+#define MACH_TYPE_CAVY                 47
+#define MACH_TYPE_JORNADA720           48
+#define MACH_TYPE_OMNIMETER            49
+#define MACH_TYPE_EDB7211              50
+#define MACH_TYPE_CITYGO               51
+#define MACH_TYPE_PFS168               52
+#define MACH_TYPE_SPOT                 53
+#define MACH_TYPE_FLEXANET             54
+#define MACH_TYPE_WEBPAL               55
+#define MACH_TYPE_LINPDA               56
+#define MACH_TYPE_ANAKIN               57
+#define MACH_TYPE_MVI                  58
+#define MACH_TYPE_JUPITER              59
+#define MACH_TYPE_PSIONW               60
+#define MACH_TYPE_ALN                  61
+#define MACH_TYPE_CAMELOT              62
+#define MACH_TYPE_GDS2200              63
+#define MACH_TYPE_PSION_SERIES7        64
+#define MACH_TYPE_XFILE                65
+#define MACH_TYPE_ACCELENT_EP9312      66
+#define MACH_TYPE_IC200                67
+#define MACH_TYPE_CREDITLART           68
+#define MACH_TYPE_HTM                  69
+#define MACH_TYPE_IQ80310              70
+#define MACH_TYPE_FREEBOT              71
+#define MACH_TYPE_ENTEL                72
+#define MACH_TYPE_ENP3510              73
+#define MACH_TYPE_TRIZEPS              74
+#define MACH_TYPE_NESA                 75
+#define MACH_TYPE_VENUS                76
+#define MACH_TYPE_TARDIS               77
+#define MACH_TYPE_MERCURY              78
+#define MACH_TYPE_EMPEG                79
+#define MACH_TYPE_I80200FCC            80
+#define MACH_TYPE_ITT_CPB              81
+#define MACH_TYPE_SVC                  82
+#define MACH_TYPE_ALPHA2               84
+#define MACH_TYPE_ALPHA1               85
+#define MACH_TYPE_NETARM               86
+#define MACH_TYPE_SIMPAD               87
+#define MACH_TYPE_PDA1                 88
+#define MACH_TYPE_LUBBOCK              89
+#define MACH_TYPE_ANIKO                90
+#define MACH_TYPE_CLEP7212             91
+#define MACH_TYPE_CS89712              92
+#define MACH_TYPE_WEARARM              93
+#define MACH_TYPE_POSSIO_PX            94
+#define MACH_TYPE_SIDEARM              95
+#define MACH_TYPE_STORK                96
+#define MACH_TYPE_SHANNON              97
+#define MACH_TYPE_ACE                  98
+#define MACH_TYPE_BALLYARM             99
+#define MACH_TYPE_SIMPUTER             100
+#define MACH_TYPE_NEXTERM              101
+#define MACH_TYPE_SA1100_ELF           102
+#define MACH_TYPE_GATOR                103
+#define MACH_TYPE_GRANITE              104
+#define MACH_TYPE_CONSUS               105
+#define MACH_TYPE_AAED2000             106
+#define MACH_TYPE_CDB89712             107
+#define MACH_TYPE_GRAPHICSMASTER       108
+#define MACH_TYPE_ADSBITSY             109
+#define MACH_TYPE_PXA_IDP              110
+#define MACH_TYPE_PLCE                 111
+#define MACH_TYPE_PT_SYSTEM3           112
+#define MACH_TYPE_MEDALB               113
+#define MACH_TYPE_EAGLE                114
+#define MACH_TYPE_DSC21                115
+#define MACH_TYPE_DSC24                116
+#define MACH_TYPE_TI5472               117
+#define MACH_TYPE_AUTCPU12             118
+#define MACH_TYPE_UENGINE              119
+#define MACH_TYPE_BLUESTEM             120
+#define MACH_TYPE_XINGU8               121
+#define MACH_TYPE_BUSHSTB              122
+#define MACH_TYPE_EPSILON1             123
+#define MACH_TYPE_BALLOON              124
+#define MACH_TYPE_PUPPY                125
+#define MACH_TYPE_ELROY                126
+#define MACH_TYPE_GMS720               127
+#define MACH_TYPE_S24X                 128
+#define MACH_TYPE_JTEL_CLEP7312        129
+#define MACH_TYPE_CX821XX              130
+#define MACH_TYPE_EDB7312              131
+#define MACH_TYPE_BSA1110              132
+#define MACH_TYPE_POWERPIN             133
+#define MACH_TYPE_OPENARM              134
+#define MACH_TYPE_WHITECHAPEL          135
+#define MACH_TYPE_H3100                136
+#define MACH_TYPE_H3800                137
+#define MACH_TYPE_BLUE_V1              138
+#define MACH_TYPE_PXA_CERF             139
+#define MACH_TYPE_ARM7TEVB             140
+#define MACH_TYPE_D7400                141
+#define MACH_TYPE_PIRANHA              142
+#define MACH_TYPE_SBCAMELOT            143
+#define MACH_TYPE_KINGS                144
+#define MACH_TYPE_SMDK2400             145
+#define MACH_TYPE_COLLIE               146
+#define MACH_TYPE_IDR                  147
+#define MACH_TYPE_BADGE4               148
+#define MACH_TYPE_WEBNET               149
+#define MACH_TYPE_D7300                150
+#define MACH_TYPE_CEP                  151
+#define MACH_TYPE_FORTUNET             152
+#define MACH_TYPE_VC547X               153
+#define MACH_TYPE_FILEWALKER           154
+#define MACH_TYPE_NETGATEWAY           155
+#define MACH_TYPE_SYMBOL2800           156
+#define MACH_TYPE_SUNS                 157
+#define MACH_TYPE_FRODO                158
+#define MACH_TYPE_MACH_TYTE_MS301      159
+#define MACH_TYPE_MX1ADS               160
+#define MACH_TYPE_H7201                161
+#define MACH_TYPE_H7202                162
+#define MACH_TYPE_AMICO                163
+#define MACH_TYPE_IAM                  164
+#define MACH_TYPE_TT530                165
+#define MACH_TYPE_SAM2400              166
+#define MACH_TYPE_JORNADA56X           167
+#define MACH_TYPE_ACTIVE               168
+#define MACH_TYPE_IQ80321              169
+#define MACH_TYPE_WID                  170
+#define MACH_TYPE_SABINAL              171
+#define MACH_TYPE_IXP425_MATACUMBE     172
+#define MACH_TYPE_MINIPRINT            173
+#define MACH_TYPE_ADM510X              174
+#define MACH_TYPE_SVS200               175
+#define MACH_TYPE_ATG_TCU              176
+#define MACH_TYPE_JORNADA820           177
+#define MACH_TYPE_S3C44B0              178
+#define MACH_TYPE_MARGIS2              179
+#define MACH_TYPE_KS8695               180
+#define MACH_TYPE_BRH                  181
+#define MACH_TYPE_S3C2410              182
+#define MACH_TYPE_POSSIO_PX30          183
+#define MACH_TYPE_S3C2800              184
+#define MACH_TYPE_FLEETWOOD            185
+#define MACH_TYPE_OMAHA                186
+#define MACH_TYPE_TA7                  187
+#define MACH_TYPE_NOVA                 188
+#define MACH_TYPE_HMK                  189
+#define MACH_TYPE_KARO                 190
+#define MACH_TYPE_FESTER               191
+#define MACH_TYPE_GPI                  192
+#define MACH_TYPE_SMDK2410             193
+#define MACH_TYPE_I519                 194
+#define MACH_TYPE_NEXIO                195
+#define MACH_TYPE_BITBOX               196
+#define MACH_TYPE_G200                 197
+#define MACH_TYPE_GILL                 198
+#define MACH_TYPE_PXA_MERCURY          199
+#define MACH_TYPE_CEIVA                200
+#define MACH_TYPE_FRET                 201
+#define MACH_TYPE_EMAILPHONE           202
+#define MACH_TYPE_H3900                203
+#define MACH_TYPE_PXA1                 204
+#define MACH_TYPE_KOAN369              205
+#define MACH_TYPE_COGENT               206
+#define MACH_TYPE_ESL_SIMPUTER         207
+#define MACH_TYPE_ESL_SIMPUTER_CLR     208
+#define MACH_TYPE_ESL_SIMPUTER_BW      209
+#define MACH_TYPE_HHP_CRADLE           210
+#define MACH_TYPE_HE500                211
+#define MACH_TYPE_INHANDELF2           212
+#define MACH_TYPE_INHANDFTIP           213
+#define MACH_TYPE_DNP1110              214
+#define MACH_TYPE_PNP1110              215
+#define MACH_TYPE_CSB226               216
+#define MACH_TYPE_ARNOLD               217
+#define MACH_TYPE_VOICEBLUE            218
+#define MACH_TYPE_JZ8028               219
+#define MACH_TYPE_H5400                220
+#define MACH_TYPE_FORTE                221
+#define MACH_TYPE_ACAM                 222
+#define MACH_TYPE_ABOX                 223
+#define MACH_TYPE_ATMEL                224
+#define MACH_TYPE_SITSANG              225
+#define MACH_TYPE_CPU1110LCDNET        226
+#define MACH_TYPE_MPL_VCMA9            227
+#define MACH_TYPE_OPUS_A1              228
+#define MACH_TYPE_DAYTONA              229
+#define MACH_TYPE_KILLBEAR             230
+#define MACH_TYPE_YOHO                 231
+#define MACH_TYPE_JASPER               232
+#define MACH_TYPE_DSC25                233
+#define MACH_TYPE_OMAP_INNOVATOR       234
+#define MACH_TYPE_RAMSES               235
+#define MACH_TYPE_S28X                 236
+#define MACH_TYPE_MPORT3               237
+#define MACH_TYPE_PXA_EAGLE250         238
+#define MACH_TYPE_PDB                  239
+#define MACH_TYPE_BLUE_2G              240
+#define MACH_TYPE_BLUEARCH             241
+#define MACH_TYPE_IXDP2400             242
+#define MACH_TYPE_IXDP2800             243
+#define MACH_TYPE_EXPLORER             244
+#define MACH_TYPE_IXDP425              245
+#define MACH_TYPE_CHIMP                246
+#define MACH_TYPE_STORK_NEST           247
+#define MACH_TYPE_STORK_EGG            248
+#define MACH_TYPE_WISMO                249
+#define MACH_TYPE_EZLINX               250
+#define MACH_TYPE_AT91RM9200           251
+#define MACH_TYPE_ORION                252
+#define MACH_TYPE_NEPTUNE              253
+#define MACH_TYPE_HACKKIT              254
+#define MACH_TYPE_PXA_WINS30           255
+#define MACH_TYPE_LAVINNA              256
+#define MACH_TYPE_PXA_UENGINE          257
+#define MACH_TYPE_INNOKOM              258
+#define MACH_TYPE_BMS                  259
+#define MACH_TYPE_IXCDP1100            260
+#define MACH_TYPE_PRPMC1100            261
+#define MACH_TYPE_AT91RM9200DK         262
+#define MACH_TYPE_ARMSTICK             263
+#define MACH_TYPE_ARMONIE              264
+#define MACH_TYPE_MPORT1               265
+#define MACH_TYPE_S3C5410              266
+#define MACH_TYPE_ZCP320A              267
+#define MACH_TYPE_I_BOX                268
+#define MACH_TYPE_STLC1502             269
+#define MACH_TYPE_SIREN                270
+#define MACH_TYPE_GREENLAKE            271
+#define MACH_TYPE_ARGUS                272
+#define MACH_TYPE_COMBADGE             273
+#define MACH_TYPE_ROKEPXA              274
+#define MACH_TYPE_CINTEGRATOR          275
+#define MACH_TYPE_GUIDEA07             276
+#define MACH_TYPE_TAT257               277
+#define MACH_TYPE_IGP2425              278
+#define MACH_TYPE_BLUEGRAMMA           279
+#define MACH_TYPE_IPOD                 280
+#define MACH_TYPE_ADSBITSYX            281
+#define MACH_TYPE_TRIZEPS2             282
+#define MACH_TYPE_VIPER                283
+#define MACH_TYPE_ADSBITSYPLUS         284
+#define MACH_TYPE_ADSAGC               285
+#define MACH_TYPE_STP7312              286
+#define MACH_TYPE_NX_PHNX              287
+#define MACH_TYPE_WEP_EP250            288
+#define MACH_TYPE_INHANDELF3           289
+#define MACH_TYPE_ADI_COYOTE           290
+#define MACH_TYPE_IYONIX               291
+#define MACH_TYPE_DAMICAM_SA1110       292
+#define MACH_TYPE_MEG03                293
+#define MACH_TYPE_PXA_WHITECHAPEL      294
+#define MACH_TYPE_NWSC                 295
+#define MACH_TYPE_NWLARM               296
+#define MACH_TYPE_IXP425_MGUARD        297
+#define MACH_TYPE_PXA_NETDCU4          298
+#define MACH_TYPE_IXDP2401             299
+#define MACH_TYPE_IXDP2801             300
+#define MACH_TYPE_ZODIAC               301
+#define MACH_TYPE_ARMMODUL             302
+#define MACH_TYPE_KETOP                303
+#define MACH_TYPE_AV7200               304
+#define MACH_TYPE_ARCH_TI925           305
+#define MACH_TYPE_ACQ200               306
+#define MACH_TYPE_PT_DAFIT             307
+#define MACH_TYPE_IHBA                 308
+#define MACH_TYPE_QUINQUE              309
+#define MACH_TYPE_NIMBRAONE            310
+#define MACH_TYPE_NIMBRA29X            311
+#define MACH_TYPE_NIMBRA210            312
+#define MACH_TYPE_HHP_D95XX            313
+#define MACH_TYPE_LABARM               314
+#define MACH_TYPE_M825XX               315
+#define MACH_TYPE_M7100                316
+#define MACH_TYPE_NIPC2                317
+#define MACH_TYPE_FU7202               318
+#define MACH_TYPE_ADSAGX               319
+#define MACH_TYPE_PXA_POOH             320
+#define MACH_TYPE_BANDON               321
+#define MACH_TYPE_PCM7210              322
+#define MACH_TYPE_NMS9200              323
+#define MACH_TYPE_LOGODL               324
+#define MACH_TYPE_M7140                325
+#define MACH_TYPE_KOREBOT              326
+#define MACH_TYPE_IQ31244              327
+#define MACH_TYPE_KOAN393              328
+#define MACH_TYPE_INHANDFTIP3          329
+#define MACH_TYPE_GONZO                330
+#define MACH_TYPE_BAST                 331
+#define MACH_TYPE_SCANPASS             332
+#define MACH_TYPE_EP7312_POOH          333
+#define MACH_TYPE_TA7S                 334
+#define MACH_TYPE_TA7V                 335
+#define MACH_TYPE_ICARUS               336
+#define MACH_TYPE_H1900                337
+#define MACH_TYPE_GEMINI               338
+#define MACH_TYPE_AXIM                 339
+#define MACH_TYPE_AUDIOTRON            340
+#define MACH_TYPE_H2200                341
+#define MACH_TYPE_LOOX600              342
+#define MACH_TYPE_NIOP                 343
+#define MACH_TYPE_DM310                344
+#define MACH_TYPE_SEEDPXA_C2           345
+#define MACH_TYPE_IXP4XX_MGUARD_PCI    346
+#define MACH_TYPE_H1940                347
+#define MACH_TYPE_SCORPIO              348
+#define MACH_TYPE_VIVA                 349
+#define MACH_TYPE_PXA_XCARD            350
+#define MACH_TYPE_CSB335               351
+#define MACH_TYPE_IXRD425              352
+#define MACH_TYPE_IQ80315              353
+#define MACH_TYPE_NMP7312              354
+#define MACH_TYPE_CX861XX              355
+#define MACH_TYPE_ENP2611              356
+#define MACH_TYPE_XDA                  357
+#define MACH_TYPE_CSIR_IMS             358
+#define MACH_TYPE_IXP421_DNAEETH       359
+#define MACH_TYPE_POCKETSERV9200       360
+#define MACH_TYPE_TOTO                 361
+#define MACH_TYPE_S3C2440              362
+#define MACH_TYPE_KS8695P              363
+#define MACH_TYPE_SE4000               364
+#define MACH_TYPE_QUADRICEPS           365
+#define MACH_TYPE_BRONCO               366
+#define MACH_TYPE_ESL_SOFCOMP          368
+#define MACH_TYPE_S5C7375              369
+#define MACH_TYPE_SPEARHEAD            370
+#define MACH_TYPE_PANTERA              371
+#define MACH_TYPE_PRAYOGLITE           372
+#define MACH_TYPE_GUMSTIK              373
+#define MACH_TYPE_RCUBE                374
+#define MACH_TYPE_REA_OLV              375
+#define MACH_TYPE_PXA_IPHONE           376
+#define MACH_TYPE_S3C3410              377
+#define MACH_TYPE_ESPD_4510B           378
+#define MACH_TYPE_MP1X                 379
+#define MACH_TYPE_AT91RM9200TB         380
+#define MACH_TYPE_ADSVGX               381
+#define MACH_TYPE_OMAP_H2              382
+#define MACH_TYPE_PELEE                383
+#define MACH_TYPE_E740                 384
+#define MACH_TYPE_IQ80331              385
+#define MACH_TYPE_VERSATILE_PB         387
+#define MACH_TYPE_KEV7A400             388
+#define MACH_TYPE_LPD7A400             389
+#define MACH_TYPE_LPD7A404             390
+#define MACH_TYPE_FUJITSU_CAMELOT      391
+#define MACH_TYPE_JANUS2M              392
+#define MACH_TYPE_EMBTF                393
+#define MACH_TYPE_HPM                  394
+#define MACH_TYPE_SMDK2410TK           395
+#define MACH_TYPE_SMDK2410AJ           396
+#define MACH_TYPE_STREETRACER          397
+#define MACH_TYPE_EFRAME               398
+#define MACH_TYPE_CSB337               399
+#define MACH_TYPE_PXA_LARK             400
+#define MACH_TYPE_PNP2110              401
+#define MACH_TYPE_TCC72X               402
+#define MACH_TYPE_ALTAIR               403
+#define MACH_TYPE_KC3                  404
+#define MACH_TYPE_SINTEFTD             405
+#define MACH_TYPE_MAINSTONE            406
+#define MACH_TYPE_ADAY4X               407
+#define MACH_TYPE_LITE300              408
+#define MACH_TYPE_S5C7376              409
+#define MACH_TYPE_MT02                 410
+#define MACH_TYPE_MPORT3S              411
+#define MACH_TYPE_RA_ALPHA             412
+#define MACH_TYPE_XCEP                 413
+#define MACH_TYPE_ARCOM_MERCURY        414
+#define MACH_TYPE_STARGATE             415
+#define MACH_TYPE_ARMADILLOJ           416
+#define MACH_TYPE_ELROY_JACK           417
+#define MACH_TYPE_BACKEND              418
+#define MACH_TYPE_S5LINBOX             419
+#define MACH_TYPE_NOMADIK              420
+#define MACH_TYPE_IA_CPU_9200          421
+#define MACH_TYPE_AT91_BJA1            422
+#define MACH_TYPE_CORGI                423
+#define MACH_TYPE_POODLE               424
+#define MACH_TYPE_TEN                  425
+#define MACH_TYPE_ROVERP5P             426
+#define MACH_TYPE_SC2700               427
+#define MACH_TYPE_EX_EAGLE             428
+#define MACH_TYPE_NX_PXA12             429
+#define MACH_TYPE_NX_PXA5              430
+#define MACH_TYPE_BLACKBOARD2          431
+#define MACH_TYPE_I819                 432
+#define MACH_TYPE_IXMB995E             433
+#define MACH_TYPE_SKYRIDER             434
+#define MACH_TYPE_SKYHAWK              435
+#define MACH_TYPE_ENTERPRISE           436
+#define MACH_TYPE_DEP2410              437
+#define MACH_TYPE_ARMCORE              438
+#define MACH_TYPE_HOBBIT               439
+#define MACH_TYPE_H7210                440
+#define MACH_TYPE_PXA_NETDCU5          441
+#define MACH_TYPE_ACC                  442
+#define MACH_TYPE_ESL_SARVA            443
+#define MACH_TYPE_XM250                444
+#define MACH_TYPE_T6TC1XB              445
+#define MACH_TYPE_ESS710               446
+#define MACH_TYPE_MX3ADS               447
+#define MACH_TYPE_HIMALAYA             448
+#define MACH_TYPE_BOLFENK              449
+#define MACH_TYPE_AT91RM9200KR         450
+#define MACH_TYPE_EDB9312              451
+#define MACH_TYPE_OMAP_GENERIC         452
+#define MACH_TYPE_AXIMX3               453
+#define MACH_TYPE_EB67XDIP             454
+#define MACH_TYPE_WEBTXS               455
+#define MACH_TYPE_HAWK                 456
+#define MACH_TYPE_CCAT91SBC001         457
+#define MACH_TYPE_EXPRESSO             458
+#define MACH_TYPE_H4000                459
+#define MACH_TYPE_DINO                 460
+#define MACH_TYPE_ML675K               461
+#define MACH_TYPE_EDB9301              462
+#define MACH_TYPE_EDB9315              463
+#define MACH_TYPE_RECIVA_TT            464
+#define MACH_TYPE_CSTCB01              465
+#define MACH_TYPE_CSTCB1               466
+#define MACH_TYPE_SHADWELL             467
+#define MACH_TYPE_GOEPEL263            468
+#define MACH_TYPE_ACQ100               469
+#define MACH_TYPE_MX1FS2               470
+#define MACH_TYPE_HIPTOP_G1            471
+#define MACH_TYPE_SPARKY               472
+#define MACH_TYPE_NS9750               473
+#define MACH_TYPE_PHOENIX              474
+#define MACH_TYPE_VR1000               475
+#define MACH_TYPE_DEISTERPXA           476
+#define MACH_TYPE_BCM1160              477
+#define MACH_TYPE_PCM022               478
+#define MACH_TYPE_ADSGCX               479
+#define MACH_TYPE_DREADNAUGHT          480
+#define MACH_TYPE_DM320                481
+#define MACH_TYPE_MARKOV               482
+#define MACH_TYPE_COS7A400             483
+#define MACH_TYPE_MILANO               484
+#define MACH_TYPE_UE9328               485
+#define MACH_TYPE_UEX255               486
+#define MACH_TYPE_UE2410               487
+#define MACH_TYPE_A620                 488
+#define MACH_TYPE_OCELOT               489
+#define MACH_TYPE_CHEETAH              490
+#define MACH_TYPE_OMAP_PERSEUS2        491
+#define MACH_TYPE_ZVUE                 492
+#define MACH_TYPE_ROVERP1              493
+#define MACH_TYPE_ASIDIAL2             494
+#define MACH_TYPE_S3C24A0              495
+#define MACH_TYPE_E800                 496
+#define MACH_TYPE_E750                 497
+#define MACH_TYPE_S3C5500              498
+#define MACH_TYPE_SMDK5500             499
+#define MACH_TYPE_SIGNALSYNC           500
+#define MACH_TYPE_NBC                  501
+#define MACH_TYPE_KODIAK               502
+#define MACH_TYPE_NETBOOKPRO           503
+#define MACH_TYPE_HW90200              504
+#define MACH_TYPE_CONDOR               505
+#define MACH_TYPE_CUP                  506
+#define MACH_TYPE_KITE                 507
+#define MACH_TYPE_SCB9328              508
+#define MACH_TYPE_OMAP_H3              509
+#define MACH_TYPE_OMAP_H4              510
+#define MACH_TYPE_N10                  511
+#define MACH_TYPE_MONTAJADE            512
+#define MACH_TYPE_SG560                513
+#define MACH_TYPE_DP1000               514
+#define MACH_TYPE_OMAP_OSK             515
+#define MACH_TYPE_RG100V3              516
+#define MACH_TYPE_MX2ADS               517
+#define MACH_TYPE_PXA_KILO             518
+#define MACH_TYPE_IXP4XX_EAGLE         519
+#define MACH_TYPE_TOSA                 520
+#define MACH_TYPE_MB2520F              521
+#define MACH_TYPE_EMC1000              522
+#define MACH_TYPE_TIDSC25              523
+#define MACH_TYPE_AKCPMXL              524
+#define MACH_TYPE_AV3XX                525
+#define MACH_TYPE_AVILA                526
+#define MACH_TYPE_PXA_MPM10            527
+#define MACH_TYPE_PXA_KYANITE          528
+#define MACH_TYPE_SGOLD                529
+#define MACH_TYPE_OSCAR                530
+#define MACH_TYPE_EPXA4USB2            531
+#define MACH_TYPE_XSENGINE             532
+#define MACH_TYPE_IP600                533
+#define MACH_TYPE_MCAN2                534
+#define MACH_TYPE_DDI_BLUERIDGE        535
+#define MACH_TYPE_SKYMINDER            536
+#define MACH_TYPE_LPD79520             537
+#define MACH_TYPE_EDB9302              538
+#define MACH_TYPE_HW90340              539
+#define MACH_TYPE_CIP_BOX              540
+#define MACH_TYPE_IVPN                 541
+#define MACH_TYPE_RSOC2                542
+#define MACH_TYPE_HUSKY                543
+#define MACH_TYPE_BOXER                544
+#define MACH_TYPE_SHEPHERD             545
+#define MACH_TYPE_AML42800AA           546
+#define MACH_TYPE_MACH_TYPE_ML674001   547
+#define MACH_TYPE_LPC2294              548
+#define MACH_TYPE_SWITCHGRASS          549
+#define MACH_TYPE_ENS_CMU              550
+#define MACH_TYPE_MM6_SDB              551
+#define MACH_TYPE_SATURN               552
+#define MACH_TYPE_ARGONPLUSEVB         553
+#define MACH_TYPE_SCMA11EVB            554
+#define MACH_TYPE_SMDK2800             555
+#define MACH_TYPE_MTWILSON             556
+#define MACH_TYPE_ZITI                 557
+#define MACH_TYPE_GRANDFATHER          558
+#define MACH_TYPE_TENGINE              559
+#define MACH_TYPE_S3C2460              560
+#define MACH_TYPE_PDM                  561
+#define MACH_TYPE_H4700                562
+#define MACH_TYPE_H6300                563
+#define MACH_TYPE_RZ1700               564
+#define MACH_TYPE_A716                 565
+#define MACH_TYPE_ESTK2440A            566
+#define MACH_TYPE_ATWIXP425            567
+#define MACH_TYPE_CSB336               568
+#define MACH_TYPE_RIRM2                569
+#define MACH_TYPE_CX23518              570
+#define MACH_TYPE_CX2351X              571
+#define MACH_TYPE_COMPUTIME            572
+#define MACH_TYPE_IZARUS               573
+#define MACH_TYPE_RTS                  574
+#define MACH_TYPE_SE5100               575
+#define MACH_TYPE_S3C2510              576
+#define MACH_TYPE_CSB437TL             577
+#define MACH_TYPE_SLAUSON              578
+#define MACH_TYPE_PEARLRIVER           579
+#define MACH_TYPE_TDC_P210             580
+#define MACH_TYPE_SG580                581
+#define MACH_TYPE_WRSBCARM7            582
+#define MACH_TYPE_IPD                  583
+#define MACH_TYPE_PXA_DNP2110          584
+#define MACH_TYPE_XAENIAX              585
+#define MACH_TYPE_SOMN4250             586
+#define MACH_TYPE_PLEB2                587
+#define MACH_TYPE_CORNWALLIS           588
+#define MACH_TYPE_GURNEY_DRV           589
+#define MACH_TYPE_CHAFFEE              590
+#define MACH_TYPE_RMS101               591
+#define MACH_TYPE_RX3715               592
+#define MACH_TYPE_SWIFT                593
+#define MACH_TYPE_ROVERP7              594
+#define MACH_TYPE_PR818S               595
+#define MACH_TYPE_TRXPRO               596
+#define MACH_TYPE_NSLU2                597
+#define MACH_TYPE_E400                 598
+#define MACH_TYPE_TRAB                 599
+#define MACH_TYPE_CMC_PU2              600
+#define MACH_TYPE_FULCRUM              601
+#define MACH_TYPE_NETGATE42X           602
+#define MACH_TYPE_STR710               603
+#define MACH_TYPE_IXDPG425             604
+#define MACH_TYPE_TOMTOMGO             605
+#define MACH_TYPE_VERSATILE_AB         606
+#define MACH_TYPE_EDB9307              607
+#define MACH_TYPE_SG565                608
+#define MACH_TYPE_LPD79524             609
+#define MACH_TYPE_LPD79525             610
+#define MACH_TYPE_RMS100               611
+#define MACH_TYPE_KB9200               612
+#define MACH_TYPE_SX1                  613
+#define MACH_TYPE_HMS39C7092           614
+#define MACH_TYPE_ARMADILLO            615
+#define MACH_TYPE_IPCU                 616
+#define MACH_TYPE_LOOX720              617
+#define MACH_TYPE_IXDP465              618
+#define MACH_TYPE_IXDP2351             619
+#define MACH_TYPE_ADSVIX               620
+#define MACH_TYPE_DM270                621
+#define MACH_TYPE_SOCLTPLUS            622
+#define MACH_TYPE_ECIA                 623
+#define MACH_TYPE_CM4008               624
+#define MACH_TYPE_P2001                625
+#define MACH_TYPE_TWISTER              626
+#define MACH_TYPE_MUDSHARK             627
+#define MACH_TYPE_HB2                  628
+#define MACH_TYPE_IQ80332              629
+#define MACH_TYPE_SENDT                630
+#define MACH_TYPE_MX2JAZZ              631
+#define MACH_TYPE_MULTIIO              632
+#define MACH_TYPE_HRDISPLAY            633
+#define MACH_TYPE_SCMA11BB             634
+#define MACH_TYPE_TRIZEPS3             635
+#define MACH_TYPE_ZEFEERDZA            636
+#define MACH_TYPE_ZEFEERDZB            637
+#define MACH_TYPE_ZEFEERDZG            638
+#define MACH_TYPE_ZEFEERDZN            639
+#define MACH_TYPE_ZEFEERDZQ            640
+#define MACH_TYPE_GTWX5715             641
+#define MACH_TYPE_ASTRO_JACK           643
+#define MACH_TYPE_TIP03                644
+#define MACH_TYPE_A9200EC              645
+#define MACH_TYPE_PNX0105              646
+#define MACH_TYPE_ADCPOECPU            647
+#define MACH_TYPE_CSB637               648
+#define MACH_TYPE_ML69Q6203            649
+#define MACH_TYPE_MB9200               650
+#define MACH_TYPE_KULUN                651
+#define MACH_TYPE_SNAPPER              652
+#define MACH_TYPE_OPTIMA               653
+#define MACH_TYPE_DLHSBC               654
+#define MACH_TYPE_X30                  655
+#define MACH_TYPE_N30                  656
+#define MACH_TYPE_MANGA_KS8695         657
+#define MACH_TYPE_AJAX                 658
+#define MACH_TYPE_NEC_MP900            659
+#define MACH_TYPE_VVTK1000             661
+#define MACH_TYPE_KAFA                 662
+#define MACH_TYPE_VVTK3000             663
+#define MACH_TYPE_PIMX1                664
+#define MACH_TYPE_OLLIE                665
+#define MACH_TYPE_SKYMAX               666
+#define MACH_TYPE_JAZZ                 667
+#define MACH_TYPE_TEL_T3               668
+#define MACH_TYPE_AISINO_FCR255        669
+#define MACH_TYPE_BTWEB                670
+#define MACH_TYPE_DBG_LH79520          671
+#define MACH_TYPE_CM41XX               672
+#define MACH_TYPE_TS72XX               673
+#define MACH_TYPE_NGGPXA               674
+#define MACH_TYPE_CSB535               675
+#define MACH_TYPE_CSB536               676
+#define MACH_TYPE_PXA_TRAKPOD          677
+#define MACH_TYPE_PRAXIS               678
+#define MACH_TYPE_LH75411              679
+#define MACH_TYPE_OTOM                 680
+#define MACH_TYPE_NEXCODER_2440        681
+#define MACH_TYPE_LOOX410              682
+#define MACH_TYPE_WESTLAKE             683
+#define MACH_TYPE_NSB                  684
+#define MACH_TYPE_ESL_SARVA_STN        685
+#define MACH_TYPE_ESL_SARVA_TFT        686
+#define MACH_TYPE_ESL_SARVA_IAD        687
+#define MACH_TYPE_ESL_SARVA_ACC        688
+#define MACH_TYPE_TYPHOON              689
+#define MACH_TYPE_CNAV                 690
+#define MACH_TYPE_A730                 691
+#define MACH_TYPE_NETSTAR              692
+#define MACH_TYPE_PHASEFALE_SUPERCON   693
+#define MACH_TYPE_SHIVA1100            694
+#define MACH_TYPE_ETEXSC               695
+#define MACH_TYPE_IXDPG465             696
+#define MACH_TYPE_A9M2410              697
+#define MACH_TYPE_A9M2440              698
+#define MACH_TYPE_A9M9750              699
+#define MACH_TYPE_A9M9360              700
+#define MACH_TYPE_UNC90                701
+#define MACH_TYPE_ECO920               702
+#define MACH_TYPE_SATVIEW              703
+#define MACH_TYPE_ROADRUNNER           704
+#define MACH_TYPE_AT91RM9200EK         705
+#define MACH_TYPE_GP32                 706
+#define MACH_TYPE_GEM                  707
+#define MACH_TYPE_I858                 708
+#define MACH_TYPE_HX2750               709
+#define MACH_TYPE_ZEUSEVB              710
+#define MACH_TYPE_P700                 711
+#define MACH_TYPE_CPE                  712
+#define MACH_TYPE_SPITZ                713
+#define MACH_TYPE_NIMBRA340            714
+#define MACH_TYPE_LPC22XX              715
+#define MACH_TYPE_COMET3               716
+#define MACH_TYPE_COMET4               717
+#define MACH_TYPE_CSB625               718
+#define MACH_TYPE_FORTUNET2            719
+#define MACH_TYPE_S5H2200              720
+#define MACH_TYPE_OPTORM920            721
+#define MACH_TYPE_ADSBITSYXB           722
+#define MACH_TYPE_ADSSPHERE            723
+#define MACH_TYPE_ADSPORTAL            724
+#define MACH_TYPE_LN2410SBC            725
+#define MACH_TYPE_CB3RUFC              726
+#define MACH_TYPE_MP2USB               727
+#define MACH_TYPE_PDNB3               1002
+
+#ifdef CONFIG_ARCH_EBSA110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EBSA110
+# endif
+# define machine_is_ebsa110()	(machine_arch_type == MACH_TYPE_EBSA110)
+#else
+# define machine_is_ebsa110()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_RPC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RISCPC
+# endif
+# define machine_is_riscpc()	(machine_arch_type == MACH_TYPE_RISCPC)
+#else
+# define machine_is_riscpc()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NEXUSPCI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXUSPCI
+# endif
+# define machine_is_nexuspci()	(machine_arch_type == MACH_TYPE_NEXUSPCI)
+#else
+# define machine_is_nexuspci()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EBSA285
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EBSA285
+# endif
+# define machine_is_ebsa285()	(machine_arch_type == MACH_TYPE_EBSA285)
+#else
+# define machine_is_ebsa285()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NETWINDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETWINDER
+# endif
+# define machine_is_netwinder()	(machine_arch_type == MACH_TYPE_NETWINDER)
+#else
+# define machine_is_netwinder()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CATS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CATS
+# endif
+# define machine_is_cats()	(machine_arch_type == MACH_TYPE_CATS)
+#else
+# define machine_is_cats()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TBOX
+# endif
+# define machine_is_tbox()	(machine_arch_type == MACH_TYPE_TBOX)
+#else
+# define machine_is_tbox()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CO285
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CO285
+# endif
+# define machine_is_co285()	(machine_arch_type == MACH_TYPE_CO285)
+#else
+# define machine_is_co285()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CLPS7110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLPS7110
+# endif
+# define machine_is_clps7110()	(machine_arch_type == MACH_TYPE_CLPS7110)
+#else
+# define machine_is_clps7110()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCHIMEDES
+# endif
+# define machine_is_archimedes()	(machine_arch_type == MACH_TYPE_ARCHIMEDES)
+#else
+# define machine_is_archimedes()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_A5K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A5K
+# endif
+# define machine_is_a5k()	(machine_arch_type == MACH_TYPE_A5K)
+#else
+# define machine_is_a5k()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ETOILE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETOILE
+# endif
+# define machine_is_etoile()	(machine_arch_type == MACH_TYPE_ETOILE)
+#else
+# define machine_is_etoile()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LACIE_NAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LACIE_NAS
+# endif
+# define machine_is_lacie_nas()	(machine_arch_type == MACH_TYPE_LACIE_NAS)
+#else
+# define machine_is_lacie_nas()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CLPS7500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLPS7500
+# endif
+# define machine_is_clps7500()	(machine_arch_type == MACH_TYPE_CLPS7500)
+#else
+# define machine_is_clps7500()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SHARK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHARK
+# endif
+# define machine_is_shark()	(machine_arch_type == MACH_TYPE_SHARK)
+#else
+# define machine_is_shark()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BRUTUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BRUTUS
+# endif
+# define machine_is_brutus()	(machine_arch_type == MACH_TYPE_BRUTUS)
+#else
+# define machine_is_brutus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PERSONAL_SERVER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PERSONAL_SERVER
+# endif
+# define machine_is_personal_server()	(machine_arch_type == MACH_TYPE_PERSONAL_SERVER)
+#else
+# define machine_is_personal_server()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ITSY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ITSY
+# endif
+# define machine_is_itsy()	(machine_arch_type == MACH_TYPE_ITSY)
+#else
+# define machine_is_itsy()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_L7200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_L7200
+# endif
+# define machine_is_l7200()	(machine_arch_type == MACH_TYPE_L7200)
+#else
+# define machine_is_l7200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PLEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLEB
+# endif
+# define machine_is_pleb()	(machine_arch_type == MACH_TYPE_PLEB)
+#else
+# define machine_is_pleb()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_INTEGRATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INTEGRATOR
+# endif
+# define machine_is_integrator()	(machine_arch_type == MACH_TYPE_INTEGRATOR)
+#else
+# define machine_is_integrator()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_H3600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3600
+# endif
+# define machine_is_h3600()	(machine_arch_type == MACH_TYPE_H3600)
+#else
+# define machine_is_h3600()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXP1200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP1200
+# endif
+# define machine_is_ixp1200()	(machine_arch_type == MACH_TYPE_IXP1200)
+#else
+# define machine_is_ixp1200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_P720T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P720T
+# endif
+# define machine_is_p720t()	(machine_arch_type == MACH_TYPE_P720T)
+#else
+# define machine_is_p720t()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ASSABET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASSABET
+# endif
+# define machine_is_assabet()	(machine_arch_type == MACH_TYPE_ASSABET)
+#else
+# define machine_is_assabet()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_VICTOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VICTOR
+# endif
+# define machine_is_victor()	(machine_arch_type == MACH_TYPE_VICTOR)
+#else
+# define machine_is_victor()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_LART
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LART
+# endif
+# define machine_is_lart()	(machine_arch_type == MACH_TYPE_LART)
+#else
+# define machine_is_lart()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_RANGER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RANGER
+# endif
+# define machine_is_ranger()	(machine_arch_type == MACH_TYPE_RANGER)
+#else
+# define machine_is_ranger()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GRAPHICSCLIENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRAPHICSCLIENT
+# endif
+# define machine_is_graphicsclient()	(machine_arch_type == MACH_TYPE_GRAPHICSCLIENT)
+#else
+# define machine_is_graphicsclient()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_XP860
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XP860
+# endif
+# define machine_is_xp860()	(machine_arch_type == MACH_TYPE_XP860)
+#else
+# define machine_is_xp860()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CERF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CERF
+# endif
+# define machine_is_cerf()	(machine_arch_type == MACH_TYPE_CERF)
+#else
+# define machine_is_cerf()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NANOENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NANOENGINE
+# endif
+# define machine_is_nanoengine()	(machine_arch_type == MACH_TYPE_NANOENGINE)
+#else
+# define machine_is_nanoengine()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FPIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FPIC
+# endif
+# define machine_is_fpic()	(machine_arch_type == MACH_TYPE_FPIC)
+#else
+# define machine_is_fpic()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_EXTENEX1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXTENEX1
+# endif
+# define machine_is_extenex1()	(machine_arch_type == MACH_TYPE_EXTENEX1)
+#else
+# define machine_is_extenex1()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SHERMAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHERMAN
+# endif
+# define machine_is_sherman()	(machine_arch_type == MACH_TYPE_SHERMAN)
+#else
+# define machine_is_sherman()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ACCELENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACCELENT_SA
+# endif
+# define machine_is_accelent_sa()	(machine_arch_type == MACH_TYPE_ACCELENT_SA)
+#else
+# define machine_is_accelent_sa()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_L7200_ACCELENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACCELENT_L7200
+# endif
+# define machine_is_accelent_l7200()	(machine_arch_type == MACH_TYPE_ACCELENT_L7200)
+#else
+# define machine_is_accelent_l7200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NETPORT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETPORT
+# endif
+# define machine_is_netport()	(machine_arch_type == MACH_TYPE_NETPORT)
+#else
+# define machine_is_netport()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PANGOLIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PANGOLIN
+# endif
+# define machine_is_pangolin()	(machine_arch_type == MACH_TYPE_PANGOLIN)
+#else
+# define machine_is_pangolin()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_YOPY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YOPY
+# endif
+# define machine_is_yopy()	(machine_arch_type == MACH_TYPE_YOPY)
+#else
+# define machine_is_yopy()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_COOLIDGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COOLIDGE
+# endif
+# define machine_is_coolidge()	(machine_arch_type == MACH_TYPE_COOLIDGE)
+#else
+# define machine_is_coolidge()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_HUW_WEBPANEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HUW_WEBPANEL
+# endif
+# define machine_is_huw_webpanel()	(machine_arch_type == MACH_TYPE_HUW_WEBPANEL)
+#else
+# define machine_is_huw_webpanel()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SPOTME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPOTME
+# endif
+# define machine_is_spotme()	(machine_arch_type == MACH_TYPE_SPOTME)
+#else
+# define machine_is_spotme()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_FREEBIRD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FREEBIRD
+# endif
+# define machine_is_freebird()	(machine_arch_type == MACH_TYPE_FREEBIRD)
+#else
+# define machine_is_freebird()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TI925
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TI925
+# endif
+# define machine_is_ti925()	(machine_arch_type == MACH_TYPE_TI925)
+#else
+# define machine_is_ti925()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_RISCSTATION
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RISCSTATION
+# endif
+# define machine_is_riscstation()	(machine_arch_type == MACH_TYPE_RISCSTATION)
+#else
+# define machine_is_riscstation()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CAVY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAVY
+# endif
+# define machine_is_cavy()	(machine_arch_type == MACH_TYPE_CAVY)
+#else
+# define machine_is_cavy()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA720
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JORNADA720
+# endif
+# define machine_is_jornada720()	(machine_arch_type == MACH_TYPE_JORNADA720)
+#else
+# define machine_is_jornada720()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_OMNIMETER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMNIMETER
+# endif
+# define machine_is_omnimeter()	(machine_arch_type == MACH_TYPE_OMNIMETER)
+#else
+# define machine_is_omnimeter()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EDB7211
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB7211
+# endif
+# define machine_is_edb7211()	(machine_arch_type == MACH_TYPE_EDB7211)
+#else
+# define machine_is_edb7211()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CITYGO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CITYGO
+# endif
+# define machine_is_citygo()	(machine_arch_type == MACH_TYPE_CITYGO)
+#else
+# define machine_is_citygo()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PFS168
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PFS168
+# endif
+# define machine_is_pfs168()	(machine_arch_type == MACH_TYPE_PFS168)
+#else
+# define machine_is_pfs168()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SPOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPOT
+# endif
+# define machine_is_spot()	(machine_arch_type == MACH_TYPE_SPOT)
+#else
+# define machine_is_spot()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FLEXANET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLEXANET
+# endif
+# define machine_is_flexanet()	(machine_arch_type == MACH_TYPE_FLEXANET)
+#else
+# define machine_is_flexanet()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_WEBPAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEBPAL
+# endif
+# define machine_is_webpal()	(machine_arch_type == MACH_TYPE_WEBPAL)
+#else
+# define machine_is_webpal()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_LINPDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINPDA
+# endif
+# define machine_is_linpda()	(machine_arch_type == MACH_TYPE_LINPDA)
+#else
+# define machine_is_linpda()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ANAKIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANAKIN
+# endif
+# define machine_is_anakin()	(machine_arch_type == MACH_TYPE_ANAKIN)
+#else
+# define machine_is_anakin()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_MVI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MVI
+# endif
+# define machine_is_mvi()	(machine_arch_type == MACH_TYPE_MVI)
+#else
+# define machine_is_mvi()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_JUPITER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JUPITER
+# endif
+# define machine_is_jupiter()	(machine_arch_type == MACH_TYPE_JUPITER)
+#else
+# define machine_is_jupiter()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PSIONW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PSIONW
+# endif
+# define machine_is_psionw()	(machine_arch_type == MACH_TYPE_PSIONW)
+#else
+# define machine_is_psionw()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ALN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALN
+# endif
+# define machine_is_aln()	(machine_arch_type == MACH_TYPE_ALN)
+#else
+# define machine_is_aln()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CAMELOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAMELOT
+# endif
+# define machine_is_epxa()	(machine_arch_type == MACH_TYPE_CAMELOT)
+#else
+# define machine_is_epxa()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GDS2200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GDS2200
+# endif
+# define machine_is_gds2200()	(machine_arch_type == MACH_TYPE_GDS2200)
+#else
+# define machine_is_gds2200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PSION_SERIES7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PSION_SERIES7
+# endif
+# define machine_is_psion_series7()	(machine_arch_type == MACH_TYPE_PSION_SERIES7)
+#else
+# define machine_is_psion_series7()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_XFILE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XFILE
+# endif
+# define machine_is_xfile()	(machine_arch_type == MACH_TYPE_XFILE)
+#else
+# define machine_is_xfile()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ACCELENT_EP9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACCELENT_EP9312
+# endif
+# define machine_is_accelent_ep9312()	(machine_arch_type == MACH_TYPE_ACCELENT_EP9312)
+#else
+# define machine_is_accelent_ep9312()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IC200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IC200
+# endif
+# define machine_is_ic200()	(machine_arch_type == MACH_TYPE_IC200)
+#else
+# define machine_is_ic200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CREDITLART
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CREDITLART
+# endif
+# define machine_is_creditlart()	(machine_arch_type == MACH_TYPE_CREDITLART)
+#else
+# define machine_is_creditlart()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_HTM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTM
+# endif
+# define machine_is_htm()	(machine_arch_type == MACH_TYPE_HTM)
+#else
+# define machine_is_htm()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80310
+# endif
+# define machine_is_iq80310()	(machine_arch_type == MACH_TYPE_IQ80310)
+#else
+# define machine_is_iq80310()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FREEBOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FREEBOT
+# endif
+# define machine_is_freebot()	(machine_arch_type == MACH_TYPE_FREEBOT)
+#else
+# define machine_is_freebot()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ENTEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENTEL
+# endif
+# define machine_is_entel()	(machine_arch_type == MACH_TYPE_ENTEL)
+#else
+# define machine_is_entel()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ENP3510
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENP3510
+# endif
+# define machine_is_enp3510()	(machine_arch_type == MACH_TYPE_ENP3510)
+#else
+# define machine_is_enp3510()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_TRIZEPS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS
+# endif
+# define machine_is_trizeps()	(machine_arch_type == MACH_TYPE_TRIZEPS)
+#else
+# define machine_is_trizeps()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NESA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NESA
+# endif
+# define machine_is_nesa()	(machine_arch_type == MACH_TYPE_NESA)
+#else
+# define machine_is_nesa()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VENUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VENUS
+# endif
+# define machine_is_venus()	(machine_arch_type == MACH_TYPE_VENUS)
+#else
+# define machine_is_venus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TARDIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TARDIS
+# endif
+# define machine_is_tardis()	(machine_arch_type == MACH_TYPE_TARDIS)
+#else
+# define machine_is_tardis()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MERCURY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MERCURY
+# endif
+# define machine_is_mercury()	(machine_arch_type == MACH_TYPE_MERCURY)
+#else
+# define machine_is_mercury()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_EMPEG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPEG
+# endif
+# define machine_is_empeg()	(machine_arch_type == MACH_TYPE_EMPEG)
+#else
+# define machine_is_empeg()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_I80200FCC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I80200FCC
+# endif
+# define machine_is_adi_evb()	(machine_arch_type == MACH_TYPE_I80200FCC)
+#else
+# define machine_is_adi_evb()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ITT_CPB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ITT_CPB
+# endif
+# define machine_is_itt_cpb()	(machine_arch_type == MACH_TYPE_ITT_CPB)
+#else
+# define machine_is_itt_cpb()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SVC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVC
+# endif
+# define machine_is_svc()	(machine_arch_type == MACH_TYPE_SVC)
+#else
+# define machine_is_svc()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ALPHA2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALPHA2
+# endif
+# define machine_is_alpha2()	(machine_arch_type == MACH_TYPE_ALPHA2)
+#else
+# define machine_is_alpha2()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ALPHA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALPHA1
+# endif
+# define machine_is_alpha1()	(machine_arch_type == MACH_TYPE_ALPHA1)
+#else
+# define machine_is_alpha1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NETARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETARM
+# endif
+# define machine_is_netarm()	(machine_arch_type == MACH_TYPE_NETARM)
+#else
+# define machine_is_netarm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SIMPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMPAD
+# endif
+# define machine_is_simpad()	(machine_arch_type == MACH_TYPE_SIMPAD)
+#else
+# define machine_is_simpad()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PDA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PDA1
+# endif
+# define machine_is_pda1()	(machine_arch_type == MACH_TYPE_PDA1)
+#else
+# define machine_is_pda1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LUBBOCK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LUBBOCK
+# endif
+# define machine_is_lubbock()	(machine_arch_type == MACH_TYPE_LUBBOCK)
+#else
+# define machine_is_lubbock()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ANIKO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANIKO
+# endif
+# define machine_is_aniko()	(machine_arch_type == MACH_TYPE_ANIKO)
+#else
+# define machine_is_aniko()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CLEP7212
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLEP7212
+# endif
+# define machine_is_clep7212()	(machine_arch_type == MACH_TYPE_CLEP7212)
+#else
+# define machine_is_clep7212()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CS89712
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CS89712
+# endif
+# define machine_is_cs89712()	(machine_arch_type == MACH_TYPE_CS89712)
+#else
+# define machine_is_cs89712()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_WEARARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEARARM
+# endif
+# define machine_is_weararm()	(machine_arch_type == MACH_TYPE_WEARARM)
+#else
+# define machine_is_weararm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_POSSIO_PX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POSSIO_PX
+# endif
+# define machine_is_possio_px()	(machine_arch_type == MACH_TYPE_POSSIO_PX)
+#else
+# define machine_is_possio_px()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SIDEARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIDEARM
+# endif
+# define machine_is_sidearm()	(machine_arch_type == MACH_TYPE_SIDEARM)
+#else
+# define machine_is_sidearm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_STORK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STORK
+# endif
+# define machine_is_stork()	(machine_arch_type == MACH_TYPE_STORK)
+#else
+# define machine_is_stork()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SHANNON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHANNON
+# endif
+# define machine_is_shannon()	(machine_arch_type == MACH_TYPE_SHANNON)
+#else
+# define machine_is_shannon()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ACE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACE
+# endif
+# define machine_is_ace()	(machine_arch_type == MACH_TYPE_ACE)
+#else
+# define machine_is_ace()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BALLYARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BALLYARM
+# endif
+# define machine_is_ballyarm()	(machine_arch_type == MACH_TYPE_BALLYARM)
+#else
+# define machine_is_ballyarm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SIMPUTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMPUTER
+# endif
+# define machine_is_simputer()	(machine_arch_type == MACH_TYPE_SIMPUTER)
+#else
+# define machine_is_simputer()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NEXTERM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXTERM
+# endif
+# define machine_is_nexterm()	(machine_arch_type == MACH_TYPE_NEXTERM)
+#else
+# define machine_is_nexterm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SA1100_ELF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SA1100_ELF
+# endif
+# define machine_is_sa1100_elf()	(machine_arch_type == MACH_TYPE_SA1100_ELF)
+#else
+# define machine_is_sa1100_elf()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GATOR
+# endif
+# define machine_is_gator()	(machine_arch_type == MACH_TYPE_GATOR)
+#else
+# define machine_is_gator()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GRANITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRANITE
+# endif
+# define machine_is_granite()	(machine_arch_type == MACH_TYPE_GRANITE)
+#else
+# define machine_is_granite()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CONSUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CONSUS
+# endif
+# define machine_is_consus()	(machine_arch_type == MACH_TYPE_CONSUS)
+#else
+# define machine_is_consus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AAED2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AAED2000
+# endif
+# define machine_is_aaed2000()	(machine_arch_type == MACH_TYPE_AAED2000)
+#else
+# define machine_is_aaed2000()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CDB89712
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CDB89712
+# endif
+# define machine_is_cdb89712()	(machine_arch_type == MACH_TYPE_CDB89712)
+#else
+# define machine_is_cdb89712()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GRAPHICSMASTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRAPHICSMASTER
+# endif
+# define machine_is_graphicsmaster()	(machine_arch_type == MACH_TYPE_GRAPHICSMASTER)
+#else
+# define machine_is_graphicsmaster()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ADSBITSY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSY
+# endif
+# define machine_is_adsbitsy()	(machine_arch_type == MACH_TYPE_ADSBITSY)
+#else
+# define machine_is_adsbitsy()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_IDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_IDP
+# endif
+# define machine_is_pxa_idp()	(machine_arch_type == MACH_TYPE_PXA_IDP)
+#else
+# define machine_is_pxa_idp()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PLCE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLCE
+# endif
+# define machine_is_plce()	(machine_arch_type == MACH_TYPE_PLCE)
+#else
+# define machine_is_plce()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PT_SYSTEM3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PT_SYSTEM3
+# endif
+# define machine_is_pt_system3()	(machine_arch_type == MACH_TYPE_PT_SYSTEM3)
+#else
+# define machine_is_pt_system3()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MEDALB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MEDALB
+# endif
+# define machine_is_murphy()	(machine_arch_type == MACH_TYPE_MEDALB)
+#else
+# define machine_is_murphy()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EAGLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EAGLE
+# endif
+# define machine_is_eagle()	(machine_arch_type == MACH_TYPE_EAGLE)
+#else
+# define machine_is_eagle()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DSC21
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSC21
+# endif
+# define machine_is_dsc21()	(machine_arch_type == MACH_TYPE_DSC21)
+#else
+# define machine_is_dsc21()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DSC24
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSC24
+# endif
+# define machine_is_dsc24()	(machine_arch_type == MACH_TYPE_DSC24)
+#else
+# define machine_is_dsc24()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TI5472
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TI5472
+# endif
+# define machine_is_ti5472()	(machine_arch_type == MACH_TYPE_TI5472)
+#else
+# define machine_is_ti5472()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AUTCPU12
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AUTCPU12
+# endif
+# define machine_is_autcpu12()	(machine_arch_type == MACH_TYPE_AUTCPU12)
+#else
+# define machine_is_autcpu12()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_UENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UENGINE
+# endif
+# define machine_is_uengine()	(machine_arch_type == MACH_TYPE_UENGINE)
+#else
+# define machine_is_uengine()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BLUESTEM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUESTEM
+# endif
+# define machine_is_bluestem()	(machine_arch_type == MACH_TYPE_BLUESTEM)
+#else
+# define machine_is_bluestem()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_XINGU8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XINGU8
+# endif
+# define machine_is_xingu8()	(machine_arch_type == MACH_TYPE_XINGU8)
+#else
+# define machine_is_xingu8()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BUSHSTB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUSHSTB
+# endif
+# define machine_is_bushstb()	(machine_arch_type == MACH_TYPE_BUSHSTB)
+#else
+# define machine_is_bushstb()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_EPSILON1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EPSILON1
+# endif
+# define machine_is_epsilon1()	(machine_arch_type == MACH_TYPE_EPSILON1)
+#else
+# define machine_is_epsilon1()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BALLOON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BALLOON
+# endif
+# define machine_is_balloon()	(machine_arch_type == MACH_TYPE_BALLOON)
+#else
+# define machine_is_balloon()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PUPPY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PUPPY
+# endif
+# define machine_is_puppy()	(machine_arch_type == MACH_TYPE_PUPPY)
+#else
+# define machine_is_puppy()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ELROY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELROY
+# endif
+# define machine_is_elroy()	(machine_arch_type == MACH_TYPE_ELROY)
+#else
+# define machine_is_elroy()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GMS720
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GMS720
+# endif
+# define machine_is_gms720()	(machine_arch_type == MACH_TYPE_GMS720)
+#else
+# define machine_is_gms720()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S24X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S24X
+# endif
+# define machine_is_s24x()	(machine_arch_type == MACH_TYPE_S24X)
+#else
+# define machine_is_s24x()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_JTEL_CLEP7312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JTEL_CLEP7312
+# endif
+# define machine_is_jtel_clep7312()	(machine_arch_type == MACH_TYPE_JTEL_CLEP7312)
+#else
+# define machine_is_jtel_clep7312()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CX821XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CX821XX
+# endif
+# define machine_is_cx821xx()	(machine_arch_type == MACH_TYPE_CX821XX)
+#else
+# define machine_is_cx821xx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EDB7312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB7312
+# endif
+# define machine_is_edb7312()	(machine_arch_type == MACH_TYPE_EDB7312)
+#else
+# define machine_is_edb7312()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BSA1110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BSA1110
+# endif
+# define machine_is_bsa1110()	(machine_arch_type == MACH_TYPE_BSA1110)
+#else
+# define machine_is_bsa1110()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_POWERPIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POWERPIN
+# endif
+# define machine_is_powerpin()	(machine_arch_type == MACH_TYPE_POWERPIN)
+#else
+# define machine_is_powerpin()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_OPENARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENARM
+# endif
+# define machine_is_openarm()	(machine_arch_type == MACH_TYPE_OPENARM)
+#else
+# define machine_is_openarm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_WHITECHAPEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WHITECHAPEL
+# endif
+# define machine_is_whitechapel()	(machine_arch_type == MACH_TYPE_WHITECHAPEL)
+#else
+# define machine_is_whitechapel()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_H3100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3100
+# endif
+# define machine_is_h3100()	(machine_arch_type == MACH_TYPE_H3100)
+#else
+# define machine_is_h3100()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_H3800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3800
+# endif
+# define machine_is_h3800()	(machine_arch_type == MACH_TYPE_H3800)
+#else
+# define machine_is_h3800()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BLUE_V1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUE_V1
+# endif
+# define machine_is_blue_v1()	(machine_arch_type == MACH_TYPE_BLUE_V1)
+#else
+# define machine_is_blue_v1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_CERF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_CERF
+# endif
+# define machine_is_pxa_cerf()	(machine_arch_type == MACH_TYPE_PXA_CERF)
+#else
+# define machine_is_pxa_cerf()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARM7TEVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARM7TEVB
+# endif
+# define machine_is_arm7tevb()	(machine_arch_type == MACH_TYPE_ARM7TEVB)
+#else
+# define machine_is_arm7tevb()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_D7400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D7400
+# endif
+# define machine_is_d7400()	(machine_arch_type == MACH_TYPE_D7400)
+#else
+# define machine_is_d7400()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PIRANHA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PIRANHA
+# endif
+# define machine_is_piranha()	(machine_arch_type == MACH_TYPE_PIRANHA)
+#else
+# define machine_is_piranha()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SBCAMELOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBCAMELOT
+# endif
+# define machine_is_sbcamelot()	(machine_arch_type == MACH_TYPE_SBCAMELOT)
+#else
+# define machine_is_sbcamelot()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_KINGS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KINGS
+# endif
+# define machine_is_kings()	(machine_arch_type == MACH_TYPE_KINGS)
+#else
+# define machine_is_kings()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SMDK2400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2400
+# endif
+# define machine_is_smdk2400()	(machine_arch_type == MACH_TYPE_SMDK2400)
+#else
+# define machine_is_smdk2400()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_COLLIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLLIE
+# endif
+# define machine_is_collie()	(machine_arch_type == MACH_TYPE_COLLIE)
+#else
+# define machine_is_collie()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IDR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IDR
+# endif
+# define machine_is_idr()	(machine_arch_type == MACH_TYPE_IDR)
+#else
+# define machine_is_idr()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BADGE4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BADGE4
+# endif
+# define machine_is_badge4()	(machine_arch_type == MACH_TYPE_BADGE4)
+#else
+# define machine_is_badge4()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_WEBNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEBNET
+# endif
+# define machine_is_webnet()	(machine_arch_type == MACH_TYPE_WEBNET)
+#else
+# define machine_is_webnet()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_D7300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D7300
+# endif
+# define machine_is_d7300()	(machine_arch_type == MACH_TYPE_D7300)
+#else
+# define machine_is_d7300()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CEP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CEP
+# endif
+# define machine_is_cep()	(machine_arch_type == MACH_TYPE_CEP)
+#else
+# define machine_is_cep()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_FORTUNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FORTUNET
+# endif
+# define machine_is_fortunet()	(machine_arch_type == MACH_TYPE_FORTUNET)
+#else
+# define machine_is_fortunet()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VC547X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VC547X
+# endif
+# define machine_is_vc547x()	(machine_arch_type == MACH_TYPE_VC547X)
+#else
+# define machine_is_vc547x()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FILEWALKER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FILEWALKER
+# endif
+# define machine_is_filewalker()	(machine_arch_type == MACH_TYPE_FILEWALKER)
+#else
+# define machine_is_filewalker()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NETGATEWAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETGATEWAY
+# endif
+# define machine_is_netgateway()	(machine_arch_type == MACH_TYPE_NETGATEWAY)
+#else
+# define machine_is_netgateway()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SYMBOL2800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYMBOL2800
+# endif
+# define machine_is_symbol2800()	(machine_arch_type == MACH_TYPE_SYMBOL2800)
+#else
+# define machine_is_symbol2800()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SUNS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SUNS
+# endif
+# define machine_is_suns()	(machine_arch_type == MACH_TYPE_SUNS)
+#else
+# define machine_is_suns()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FRODO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FRODO
+# endif
+# define machine_is_frodo()	(machine_arch_type == MACH_TYPE_FRODO)
+#else
+# define machine_is_frodo()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_MACH_TYTE_MS301
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACH_TYTE_MS301
+# endif
+# define machine_is_ms301()	(machine_arch_type == MACH_TYPE_MACH_TYTE_MS301)
+#else
+# define machine_is_ms301()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MX1ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX1ADS
+# endif
+# define machine_is_mx1ads()	(machine_arch_type == MACH_TYPE_MX1ADS)
+#else
+# define machine_is_mx1ads()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H7201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H7201
+# endif
+# define machine_is_h7201()	(machine_arch_type == MACH_TYPE_H7201)
+#else
+# define machine_is_h7201()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H7202
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H7202
+# endif
+# define machine_is_h7202()	(machine_arch_type == MACH_TYPE_H7202)
+#else
+# define machine_is_h7202()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AMICO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMICO
+# endif
+# define machine_is_amico()	(machine_arch_type == MACH_TYPE_AMICO)
+#else
+# define machine_is_amico()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_IAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IAM
+# endif
+# define machine_is_iam()	(machine_arch_type == MACH_TYPE_IAM)
+#else
+# define machine_is_iam()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_TT530
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TT530
+# endif
+# define machine_is_tt530()	(machine_arch_type == MACH_TYPE_TT530)
+#else
+# define machine_is_tt530()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SAM2400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM2400
+# endif
+# define machine_is_sam2400()	(machine_arch_type == MACH_TYPE_SAM2400)
+#else
+# define machine_is_sam2400()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA56X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JORNADA56X
+# endif
+# define machine_is_jornada56x()	(machine_arch_type == MACH_TYPE_JORNADA56X)
+#else
+# define machine_is_jornada56x()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ACTIVE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACTIVE
+# endif
+# define machine_is_active()	(machine_arch_type == MACH_TYPE_ACTIVE)
+#else
+# define machine_is_active()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80321
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80321
+# endif
+# define machine_is_iq80321()	(machine_arch_type == MACH_TYPE_IQ80321)
+#else
+# define machine_is_iq80321()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_WID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WID
+# endif
+# define machine_is_wid()	(machine_arch_type == MACH_TYPE_WID)
+#else
+# define machine_is_wid()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SABINAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SABINAL
+# endif
+# define machine_is_sabinal()	(machine_arch_type == MACH_TYPE_SABINAL)
+#else
+# define machine_is_sabinal()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXP425_MATACUMBE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP425_MATACUMBE
+# endif
+# define machine_is_ixp425_matacumbe()	(machine_arch_type == MACH_TYPE_IXP425_MATACUMBE)
+#else
+# define machine_is_ixp425_matacumbe()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_MINIPRINT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINIPRINT
+# endif
+# define machine_is_miniprint()	(machine_arch_type == MACH_TYPE_MINIPRINT)
+#else
+# define machine_is_miniprint()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADM510X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADM510X
+# endif
+# define machine_is_adm510x()	(machine_arch_type == MACH_TYPE_ADM510X)
+#else
+# define machine_is_adm510x()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SVS200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVS200
+# endif
+# define machine_is_svs200()	(machine_arch_type == MACH_TYPE_SVS200)
+#else
+# define machine_is_svs200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ATG_TCU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATG_TCU
+# endif
+# define machine_is_atg_tcu()	(machine_arch_type == MACH_TYPE_ATG_TCU)
+#else
+# define machine_is_atg_tcu()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA820
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JORNADA820
+# endif
+# define machine_is_jornada820()	(machine_arch_type == MACH_TYPE_JORNADA820)
+#else
+# define machine_is_jornada820()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C44B0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C44B0
+# endif
+# define machine_is_s3c44b0()	(machine_arch_type == MACH_TYPE_S3C44B0)
+#else
+# define machine_is_s3c44b0()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MARGIS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARGIS2
+# endif
+# define machine_is_margis2()	(machine_arch_type == MACH_TYPE_MARGIS2)
+#else
+# define machine_is_margis2()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KS8695
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KS8695
+# endif
+# define machine_is_ks8695()	(machine_arch_type == MACH_TYPE_KS8695)
+#else
+# define machine_is_ks8695()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BRH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BRH
+# endif
+# define machine_is_brh()	(machine_arch_type == MACH_TYPE_BRH)
+#else
+# define machine_is_brh()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2410
+# endif
+# define machine_is_s3c2410()	(machine_arch_type == MACH_TYPE_S3C2410)
+#else
+# define machine_is_s3c2410()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_POSSIO_PX30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POSSIO_PX30
+# endif
+# define machine_is_possio_px30()	(machine_arch_type == MACH_TYPE_POSSIO_PX30)
+#else
+# define machine_is_possio_px30()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C2800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2800
+# endif
+# define machine_is_s3c2800()	(machine_arch_type == MACH_TYPE_S3C2800)
+#else
+# define machine_is_s3c2800()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FLEETWOOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLEETWOOD
+# endif
+# define machine_is_fleetwood()	(machine_arch_type == MACH_TYPE_FLEETWOOD)
+#else
+# define machine_is_fleetwood()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_OMAHA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAHA
+# endif
+# define machine_is_omaha()	(machine_arch_type == MACH_TYPE_OMAHA)
+#else
+# define machine_is_omaha()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TA7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TA7
+# endif
+# define machine_is_ta7()	(machine_arch_type == MACH_TYPE_TA7)
+#else
+# define machine_is_ta7()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NOVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOVA
+# endif
+# define machine_is_nova()	(machine_arch_type == MACH_TYPE_NOVA)
+#else
+# define machine_is_nova()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_HMK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HMK
+# endif
+# define machine_is_hmk()	(machine_arch_type == MACH_TYPE_HMK)
+#else
+# define machine_is_hmk()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KARO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KARO
+# endif
+# define machine_is_karo()	(machine_arch_type == MACH_TYPE_KARO)
+#else
+# define machine_is_karo()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FESTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FESTER
+# endif
+# define machine_is_fester()	(machine_arch_type == MACH_TYPE_FESTER)
+#else
+# define machine_is_fester()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GPI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GPI
+# endif
+# define machine_is_gpi()	(machine_arch_type == MACH_TYPE_GPI)
+#else
+# define machine_is_gpi()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SMDK2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2410
+# endif
+# define machine_is_smdk2410()	(machine_arch_type == MACH_TYPE_SMDK2410)
+#else
+# define machine_is_smdk2410()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_I519
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I519
+# endif
+# define machine_is_i519()	(machine_arch_type == MACH_TYPE_I519)
+#else
+# define machine_is_i519()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NEXIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXIO
+# endif
+# define machine_is_nexio()	(machine_arch_type == MACH_TYPE_NEXIO)
+#else
+# define machine_is_nexio()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BITBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BITBOX
+# endif
+# define machine_is_bitbox()	(machine_arch_type == MACH_TYPE_BITBOX)
+#else
+# define machine_is_bitbox()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_G200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G200
+# endif
+# define machine_is_g200()	(machine_arch_type == MACH_TYPE_G200)
+#else
+# define machine_is_g200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GILL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GILL
+# endif
+# define machine_is_gill()	(machine_arch_type == MACH_TYPE_GILL)
+#else
+# define machine_is_gill()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_MERCURY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_MERCURY
+# endif
+# define machine_is_pxa_mercury()	(machine_arch_type == MACH_TYPE_PXA_MERCURY)
+#else
+# define machine_is_pxa_mercury()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CEIVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CEIVA
+# endif
+# define machine_is_ceiva()	(machine_arch_type == MACH_TYPE_CEIVA)
+#else
+# define machine_is_ceiva()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FRET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FRET
+# endif
+# define machine_is_fret()	(machine_arch_type == MACH_TYPE_FRET)
+#else
+# define machine_is_fret()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_EMAILPHONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMAILPHONE
+# endif
+# define machine_is_emailphone()	(machine_arch_type == MACH_TYPE_EMAILPHONE)
+#else
+# define machine_is_emailphone()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H3900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3900
+# endif
+# define machine_is_h3900()	(machine_arch_type == MACH_TYPE_H3900)
+#else
+# define machine_is_h3900()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA1
+# endif
+# define machine_is_pxa1()	(machine_arch_type == MACH_TYPE_PXA1)
+#else
+# define machine_is_pxa1()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_KOAN369
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KOAN369
+# endif
+# define machine_is_koan369()	(machine_arch_type == MACH_TYPE_KOAN369)
+#else
+# define machine_is_koan369()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_COGENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COGENT
+# endif
+# define machine_is_cogent()	(machine_arch_type == MACH_TYPE_COGENT)
+#else
+# define machine_is_cogent()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ESL_SIMPUTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SIMPUTER
+# endif
+# define machine_is_esl_simputer()	(machine_arch_type == MACH_TYPE_ESL_SIMPUTER)
+#else
+# define machine_is_esl_simputer()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ESL_SIMPUTER_CLR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SIMPUTER_CLR
+# endif
+# define machine_is_esl_simputer_clr()	(machine_arch_type == MACH_TYPE_ESL_SIMPUTER_CLR)
+#else
+# define machine_is_esl_simputer_clr()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ESL_SIMPUTER_BW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SIMPUTER_BW
+# endif
+# define machine_is_esl_simputer_bw()	(machine_arch_type == MACH_TYPE_ESL_SIMPUTER_BW)
+#else
+# define machine_is_esl_simputer_bw()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_HHP_CRADLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HHP_CRADLE
+# endif
+# define machine_is_hhp_cradle()	(machine_arch_type == MACH_TYPE_HHP_CRADLE)
+#else
+# define machine_is_hhp_cradle()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_HE500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HE500
+# endif
+# define machine_is_he500()	(machine_arch_type == MACH_TYPE_HE500)
+#else
+# define machine_is_he500()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_INHANDELF2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHANDELF2
+# endif
+# define machine_is_inhandelf2()	(machine_arch_type == MACH_TYPE_INHANDELF2)
+#else
+# define machine_is_inhandelf2()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_INHANDFTIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHANDFTIP
+# endif
+# define machine_is_inhandftip()	(machine_arch_type == MACH_TYPE_INHANDFTIP)
+#else
+# define machine_is_inhandftip()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_DNP1110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DNP1110
+# endif
+# define machine_is_dnp1110()	(machine_arch_type == MACH_TYPE_DNP1110)
+#else
+# define machine_is_dnp1110()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PNP1110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNP1110
+# endif
+# define machine_is_pnp1110()	(machine_arch_type == MACH_TYPE_PNP1110)
+#else
+# define machine_is_pnp1110()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CSB226
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB226
+# endif
+# define machine_is_csb226()	(machine_arch_type == MACH_TYPE_CSB226)
+#else
+# define machine_is_csb226()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ARNOLD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARNOLD
+# endif
+# define machine_is_arnold()	(machine_arch_type == MACH_TYPE_ARNOLD)
+#else
+# define machine_is_arnold()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VOICEBLUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VOICEBLUE
+# endif
+# define machine_is_voiceblue()	(machine_arch_type == MACH_TYPE_VOICEBLUE)
+#else
+# define machine_is_voiceblue()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_JZ8028
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JZ8028
+# endif
+# define machine_is_jz8028()	(machine_arch_type == MACH_TYPE_JZ8028)
+#else
+# define machine_is_jz8028()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H5400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H5400
+# endif
+# define machine_is_h5400()	(machine_arch_type == MACH_TYPE_H5400)
+#else
+# define machine_is_h5400()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FORTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FORTE
+# endif
+# define machine_is_forte()	(machine_arch_type == MACH_TYPE_FORTE)
+#else
+# define machine_is_forte()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ACAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACAM
+# endif
+# define machine_is_acam()	(machine_arch_type == MACH_TYPE_ACAM)
+#else
+# define machine_is_acam()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ABOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ABOX
+# endif
+# define machine_is_abox()	(machine_arch_type == MACH_TYPE_ABOX)
+#else
+# define machine_is_abox()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ATMEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATMEL
+# endif
+# define machine_is_atmel()	(machine_arch_type == MACH_TYPE_ATMEL)
+#else
+# define machine_is_atmel()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SITSANG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SITSANG
+# endif
+# define machine_is_sitsang()	(machine_arch_type == MACH_TYPE_SITSANG)
+#else
+# define machine_is_sitsang()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CPU1110LCDNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPU1110LCDNET
+# endif
+# define machine_is_cpu1110lcdnet()	(machine_arch_type == MACH_TYPE_CPU1110LCDNET)
+#else
+# define machine_is_cpu1110lcdnet()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MPL_VCMA9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPL_VCMA9
+# endif
+# define machine_is_mpl_vcma9()	(machine_arch_type == MACH_TYPE_MPL_VCMA9)
+#else
+# define machine_is_mpl_vcma9()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_OPUS_A1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPUS_A1
+# endif
+# define machine_is_opus_a1()	(machine_arch_type == MACH_TYPE_OPUS_A1)
+#else
+# define machine_is_opus_a1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DAYTONA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAYTONA
+# endif
+# define machine_is_daytona()	(machine_arch_type == MACH_TYPE_DAYTONA)
+#else
+# define machine_is_daytona()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_KILLBEAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KILLBEAR
+# endif
+# define machine_is_killbear()	(machine_arch_type == MACH_TYPE_KILLBEAR)
+#else
+# define machine_is_killbear()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_YOHO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YOHO
+# endif
+# define machine_is_yoho()	(machine_arch_type == MACH_TYPE_YOHO)
+#else
+# define machine_is_yoho()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_JASPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JASPER
+# endif
+# define machine_is_jasper()	(machine_arch_type == MACH_TYPE_JASPER)
+#else
+# define machine_is_jasper()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DSC25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSC25
+# endif
+# define machine_is_dsc25()	(machine_arch_type == MACH_TYPE_DSC25)
+#else
+# define machine_is_dsc25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_INNOVATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_INNOVATOR
+# endif
+# define machine_is_omap_innovator()	(machine_arch_type == MACH_TYPE_OMAP_INNOVATOR)
+#else
+# define machine_is_omap_innovator()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_RAMSES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAMSES
+# endif
+# define machine_is_ramses()	(machine_arch_type == MACH_TYPE_RAMSES)
+#else
+# define machine_is_ramses()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S28X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S28X
+# endif
+# define machine_is_s28x()	(machine_arch_type == MACH_TYPE_S28X)
+#else
+# define machine_is_s28x()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MPORT3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPORT3
+# endif
+# define machine_is_mport3()	(machine_arch_type == MACH_TYPE_MPORT3)
+#else
+# define machine_is_mport3()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_EAGLE250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_EAGLE250
+# endif
+# define machine_is_pxa_eagle250()	(machine_arch_type == MACH_TYPE_PXA_EAGLE250)
+#else
+# define machine_is_pxa_eagle250()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PDB
+# endif
+# define machine_is_pdb()	(machine_arch_type == MACH_TYPE_PDB)
+#else
+# define machine_is_pdb()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BLUE_2G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUE_2G
+# endif
+# define machine_is_blue_2g()	(machine_arch_type == MACH_TYPE_BLUE_2G)
+#else
+# define machine_is_blue_2g()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BLUEARCH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUEARCH
+# endif
+# define machine_is_bluearch()	(machine_arch_type == MACH_TYPE_BLUEARCH)
+#else
+# define machine_is_bluearch()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2400
+# endif
+# define machine_is_ixdp2400()	(machine_arch_type == MACH_TYPE_IXDP2400)
+#else
+# define machine_is_ixdp2400()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2800
+# endif
+# define machine_is_ixdp2800()	(machine_arch_type == MACH_TYPE_IXDP2800)
+#else
+# define machine_is_ixdp2800()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_EXPLORER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXPLORER
+# endif
+# define machine_is_explorer()	(machine_arch_type == MACH_TYPE_EXPLORER)
+#else
+# define machine_is_explorer()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP425
+# endif
+# define machine_is_ixdp425()	(machine_arch_type == MACH_TYPE_IXDP425)
+#else
+# define machine_is_ixdp425()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CHIMP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHIMP
+# endif
+# define machine_is_chimp()	(machine_arch_type == MACH_TYPE_CHIMP)
+#else
+# define machine_is_chimp()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_STORK_NEST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STORK_NEST
+# endif
+# define machine_is_stork_nest()	(machine_arch_type == MACH_TYPE_STORK_NEST)
+#else
+# define machine_is_stork_nest()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_STORK_EGG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STORK_EGG
+# endif
+# define machine_is_stork_egg()	(machine_arch_type == MACH_TYPE_STORK_EGG)
+#else
+# define machine_is_stork_egg()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_WISMO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WISMO
+# endif
+# define machine_is_wismo()	(machine_arch_type == MACH_TYPE_WISMO)
+#else
+# define machine_is_wismo()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EZLINX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZLINX
+# endif
+# define machine_is_ezlinx()	(machine_arch_type == MACH_TYPE_EZLINX)
+#else
+# define machine_is_ezlinx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AT91RM9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200
+# endif
+# define machine_is_at91rm9200()	(machine_arch_type == MACH_TYPE_AT91RM9200)
+#else
+# define machine_is_at91rm9200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ORION
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORION
+# endif
+# define machine_is_orion()	(machine_arch_type == MACH_TYPE_ORION)
+#else
+# define machine_is_orion()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NEPTUNE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEPTUNE
+# endif
+# define machine_is_neptune()	(machine_arch_type == MACH_TYPE_NEPTUNE)
+#else
+# define machine_is_neptune()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_HACKKIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HACKKIT
+# endif
+# define machine_is_hackkit()	(machine_arch_type == MACH_TYPE_HACKKIT)
+#else
+# define machine_is_hackkit()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_WINS30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_WINS30
+# endif
+# define machine_is_pxa_wins30()	(machine_arch_type == MACH_TYPE_PXA_WINS30)
+#else
+# define machine_is_pxa_wins30()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_LAVINNA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LAVINNA
+# endif
+# define machine_is_lavinna()	(machine_arch_type == MACH_TYPE_LAVINNA)
+#else
+# define machine_is_lavinna()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_UENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_UENGINE
+# endif
+# define machine_is_pxa_uengine()	(machine_arch_type == MACH_TYPE_PXA_UENGINE)
+#else
+# define machine_is_pxa_uengine()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_INNOKOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INNOKOM
+# endif
+# define machine_is_innokom()	(machine_arch_type == MACH_TYPE_INNOKOM)
+#else
+# define machine_is_innokom()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BMS
+# endif
+# define machine_is_bms()	(machine_arch_type == MACH_TYPE_BMS)
+#else
+# define machine_is_bms()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXCDP1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXCDP1100
+# endif
+# define machine_is_ixcdp1100()	(machine_arch_type == MACH_TYPE_IXCDP1100)
+#else
+# define machine_is_ixcdp1100()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PRPMC1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRPMC1100
+# endif
+# define machine_is_prpmc1100()	(machine_arch_type == MACH_TYPE_PRPMC1100)
+#else
+# define machine_is_prpmc1100()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AT91RM9200DK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200DK
+# endif
+# define machine_is_at91rm9200dk()	(machine_arch_type == MACH_TYPE_AT91RM9200DK)
+#else
+# define machine_is_at91rm9200dk()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARMSTICK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMSTICK
+# endif
+# define machine_is_armstick()	(machine_arch_type == MACH_TYPE_ARMSTICK)
+#else
+# define machine_is_armstick()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARMONIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMONIE
+# endif
+# define machine_is_armonie()	(machine_arch_type == MACH_TYPE_ARMONIE)
+#else
+# define machine_is_armonie()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MPORT1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPORT1
+# endif
+# define machine_is_mport1()	(machine_arch_type == MACH_TYPE_MPORT1)
+#else
+# define machine_is_mport1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C5410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C5410
+# endif
+# define machine_is_s3c5410()	(machine_arch_type == MACH_TYPE_S3C5410)
+#else
+# define machine_is_s3c5410()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ZCP320A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZCP320A
+# endif
+# define machine_is_zcp320a()	(machine_arch_type == MACH_TYPE_ZCP320A)
+#else
+# define machine_is_zcp320a()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_I_BOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I_BOX
+# endif
+# define machine_is_i_box()	(machine_arch_type == MACH_TYPE_I_BOX)
+#else
+# define machine_is_i_box()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_STLC1502
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STLC1502
+# endif
+# define machine_is_stlc1502()	(machine_arch_type == MACH_TYPE_STLC1502)
+#else
+# define machine_is_stlc1502()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SIREN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIREN
+# endif
+# define machine_is_siren()	(machine_arch_type == MACH_TYPE_SIREN)
+#else
+# define machine_is_siren()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GREENLAKE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GREENLAKE
+# endif
+# define machine_is_greenlake()	(machine_arch_type == MACH_TYPE_GREENLAKE)
+#else
+# define machine_is_greenlake()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARGUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARGUS
+# endif
+# define machine_is_argus()	(machine_arch_type == MACH_TYPE_ARGUS)
+#else
+# define machine_is_argus()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_COMBADGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMBADGE
+# endif
+# define machine_is_combadge()	(machine_arch_type == MACH_TYPE_COMBADGE)
+#else
+# define machine_is_combadge()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ROKEPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROKEPXA
+# endif
+# define machine_is_rokepxa()	(machine_arch_type == MACH_TYPE_ROKEPXA)
+#else
+# define machine_is_rokepxa()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CINTEGRATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CINTEGRATOR
+# endif
+# define machine_is_cintegrator()	(machine_arch_type == MACH_TYPE_CINTEGRATOR)
+#else
+# define machine_is_cintegrator()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GUIDEA07
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GUIDEA07
+# endif
+# define machine_is_guidea07()	(machine_arch_type == MACH_TYPE_GUIDEA07)
+#else
+# define machine_is_guidea07()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TAT257
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAT257
+# endif
+# define machine_is_tat257()	(machine_arch_type == MACH_TYPE_TAT257)
+#else
+# define machine_is_tat257()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IGP2425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IGP2425
+# endif
+# define machine_is_igp2425()	(machine_arch_type == MACH_TYPE_IGP2425)
+#else
+# define machine_is_igp2425()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BLUEGRAMMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUEGRAMMA
+# endif
+# define machine_is_bluegrama()	(machine_arch_type == MACH_TYPE_BLUEGRAMMA)
+#else
+# define machine_is_bluegrama()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IPOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPOD
+# endif
+# define machine_is_ipod()	(machine_arch_type == MACH_TYPE_IPOD)
+#else
+# define machine_is_ipod()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADSBITSYX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSYX
+# endif
+# define machine_is_adsbitsyx()	(machine_arch_type == MACH_TYPE_ADSBITSYX)
+#else
+# define machine_is_adsbitsyx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TRIZEPS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS2
+# endif
+# define machine_is_trizeps2()	(machine_arch_type == MACH_TYPE_TRIZEPS2)
+#else
+# define machine_is_trizeps2()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VIPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIPER
+# endif
+# define machine_is_viper()	(machine_arch_type == MACH_TYPE_VIPER)
+#else
+# define machine_is_viper()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ADSBITSYPLUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSYPLUS
+# endif
+# define machine_is_adsbitsyplus()	(machine_arch_type == MACH_TYPE_ADSBITSYPLUS)
+#else
+# define machine_is_adsbitsyplus()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ADSAGC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSAGC
+# endif
+# define machine_is_adsagc()	(machine_arch_type == MACH_TYPE_ADSAGC)
+#else
+# define machine_is_adsagc()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_STP7312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STP7312
+# endif
+# define machine_is_stp7312()	(machine_arch_type == MACH_TYPE_STP7312)
+#else
+# define machine_is_stp7312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NX_PHNX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NX_PHNX
+# endif
+# define machine_is_nx_phnx()	(machine_arch_type == MACH_TYPE_NX_PHNX)
+#else
+# define machine_is_nx_phnx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_WEP_EP250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEP_EP250
+# endif
+# define machine_is_wep_ep250()	(machine_arch_type == MACH_TYPE_WEP_EP250)
+#else
+# define machine_is_wep_ep250()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_INHANDELF3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHANDELF3
+# endif
+# define machine_is_inhandelf3()	(machine_arch_type == MACH_TYPE_INHANDELF3)
+#else
+# define machine_is_inhandelf3()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADI_COYOTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADI_COYOTE
+# endif
+# define machine_is_adi_coyote()	(machine_arch_type == MACH_TYPE_ADI_COYOTE)
+#else
+# define machine_is_adi_coyote()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IYONIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IYONIX
+# endif
+# define machine_is_iyonix()	(machine_arch_type == MACH_TYPE_IYONIX)
+#else
+# define machine_is_iyonix()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DAMICAM_SA1110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAMICAM_SA1110
+# endif
+# define machine_is_damicam1()	(machine_arch_type == MACH_TYPE_DAMICAM_SA1110)
+#else
+# define machine_is_damicam1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MEG03
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MEG03
+# endif
+# define machine_is_meg03()	(machine_arch_type == MACH_TYPE_MEG03)
+#else
+# define machine_is_meg03()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_WHITECHAPEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_WHITECHAPEL
+# endif
+# define machine_is_pxa_whitechapel()	(machine_arch_type == MACH_TYPE_PXA_WHITECHAPEL)
+#else
+# define machine_is_pxa_whitechapel()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NWSC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NWSC
+# endif
+# define machine_is_nwsc()	(machine_arch_type == MACH_TYPE_NWSC)
+#else
+# define machine_is_nwsc()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NWLARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NWLARM
+# endif
+# define machine_is_nwlarm()	(machine_arch_type == MACH_TYPE_NWLARM)
+#else
+# define machine_is_nwlarm()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXP425_MGUARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP425_MGUARD
+# endif
+# define machine_is_ixp425_mguard()	(machine_arch_type == MACH_TYPE_IXP425_MGUARD)
+#else
+# define machine_is_ixp425_mguard()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_NETDCU4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_NETDCU4
+# endif
+# define machine_is_pxa_netdcu4()	(machine_arch_type == MACH_TYPE_PXA_NETDCU4)
+#else
+# define machine_is_pxa_netdcu4()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2401
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2401
+# endif
+# define machine_is_ixdp2401()	(machine_arch_type == MACH_TYPE_IXDP2401)
+#else
+# define machine_is_ixdp2401()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2801
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2801
+# endif
+# define machine_is_ixdp2801()	(machine_arch_type == MACH_TYPE_IXDP2801)
+#else
+# define machine_is_ixdp2801()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ZODIAC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZODIAC
+# endif
+# define machine_is_zodiac()	(machine_arch_type == MACH_TYPE_ZODIAC)
+#else
+# define machine_is_zodiac()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARMMODUL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMMODUL
+# endif
+# define machine_is_armmodul()	(machine_arch_type == MACH_TYPE_ARMMODUL)
+#else
+# define machine_is_armmodul()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_KETOP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KETOP
+# endif
+# define machine_is_ketop()	(machine_arch_type == MACH_TYPE_KETOP)
+#else
+# define machine_is_ketop()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AV7200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AV7200
+# endif
+# define machine_is_av7200()	(machine_arch_type == MACH_TYPE_AV7200)
+#else
+# define machine_is_av7200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARCH_TI925
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCH_TI925
+# endif
+# define machine_is_arch_ti925()	(machine_arch_type == MACH_TYPE_ARCH_TI925)
+#else
+# define machine_is_arch_ti925()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ACQ200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACQ200
+# endif
+# define machine_is_acq200()	(machine_arch_type == MACH_TYPE_ACQ200)
+#else
+# define machine_is_acq200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PT_DAFIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PT_DAFIT
+# endif
+# define machine_is_pt_dafit()	(machine_arch_type == MACH_TYPE_PT_DAFIT)
+#else
+# define machine_is_pt_dafit()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IHBA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IHBA
+# endif
+# define machine_is_ihba()	(machine_arch_type == MACH_TYPE_IHBA)
+#else
+# define machine_is_ihba()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_QUINQUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUINQUE
+# endif
+# define machine_is_quinque()	(machine_arch_type == MACH_TYPE_QUINQUE)
+#else
+# define machine_is_quinque()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NIMBRAONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIMBRAONE
+# endif
+# define machine_is_nimbraone()	(machine_arch_type == MACH_TYPE_NIMBRAONE)
+#else
+# define machine_is_nimbraone()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NIMBRA29X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIMBRA29X
+# endif
+# define machine_is_nimbra29x()	(machine_arch_type == MACH_TYPE_NIMBRA29X)
+#else
+# define machine_is_nimbra29x()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NIMBRA210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIMBRA210
+# endif
+# define machine_is_nimbra210()	(machine_arch_type == MACH_TYPE_NIMBRA210)
+#else
+# define machine_is_nimbra210()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_HHP_D95XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HHP_D95XX
+# endif
+# define machine_is_hhp_d95xx()	(machine_arch_type == MACH_TYPE_HHP_D95XX)
+#else
+# define machine_is_hhp_d95xx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LABARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LABARM
+# endif
+# define machine_is_labarm()	(machine_arch_type == MACH_TYPE_LABARM)
+#else
+# define machine_is_labarm()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_M825XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M825XX
+# endif
+# define machine_is_m825xx()	(machine_arch_type == MACH_TYPE_M825XX)
+#else
+# define machine_is_m825xx()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_M7100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M7100
+# endif
+# define machine_is_m7100()	(machine_arch_type == MACH_TYPE_M7100)
+#else
+# define machine_is_m7100()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NIPC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIPC2
+# endif
+# define machine_is_nipc2()	(machine_arch_type == MACH_TYPE_NIPC2)
+#else
+# define machine_is_nipc2()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_FU7202
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FU7202
+# endif
+# define machine_is_fu7202()	(machine_arch_type == MACH_TYPE_FU7202)
+#else
+# define machine_is_fu7202()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADSAGX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSAGX
+# endif
+# define machine_is_adsagx()	(machine_arch_type == MACH_TYPE_ADSAGX)
+#else
+# define machine_is_adsagx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_POOH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_POOH
+# endif
+# define machine_is_pxa_pooh()	(machine_arch_type == MACH_TYPE_PXA_POOH)
+#else
+# define machine_is_pxa_pooh()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BANDON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BANDON
+# endif
+# define machine_is_bandon()	(machine_arch_type == MACH_TYPE_BANDON)
+#else
+# define machine_is_bandon()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PCM7210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM7210
+# endif
+# define machine_is_pcm7210()	(machine_arch_type == MACH_TYPE_PCM7210)
+#else
+# define machine_is_pcm7210()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NMS9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NMS9200
+# endif
+# define machine_is_nms9200()	(machine_arch_type == MACH_TYPE_NMS9200)
+#else
+# define machine_is_nms9200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LOGODL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOGODL
+# endif
+# define machine_is_logodl()	(machine_arch_type == MACH_TYPE_LOGODL)
+#else
+# define machine_is_logodl()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_M7140
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M7140
+# endif
+# define machine_is_m7140()	(machine_arch_type == MACH_TYPE_M7140)
+#else
+# define machine_is_m7140()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KOREBOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KOREBOT
+# endif
+# define machine_is_korebot()	(machine_arch_type == MACH_TYPE_KOREBOT)
+#else
+# define machine_is_korebot()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ31244
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ31244
+# endif
+# define machine_is_iq31244()	(machine_arch_type == MACH_TYPE_IQ31244)
+#else
+# define machine_is_iq31244()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_KOAN393
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KOAN393
+# endif
+# define machine_is_koan393()	(machine_arch_type == MACH_TYPE_KOAN393)
+#else
+# define machine_is_koan393()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_INHANDFTIP3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHANDFTIP3
+# endif
+# define machine_is_inhandftip3()	(machine_arch_type == MACH_TYPE_INHANDFTIP3)
+#else
+# define machine_is_inhandftip3()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GONZO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GONZO
+# endif
+# define machine_is_gonzo()	(machine_arch_type == MACH_TYPE_GONZO)
+#else
+# define machine_is_gonzo()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BAST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BAST
+# endif
+# define machine_is_bast()	(machine_arch_type == MACH_TYPE_BAST)
+#else
+# define machine_is_bast()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SCANPASS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCANPASS
+# endif
+# define machine_is_scanpass()	(machine_arch_type == MACH_TYPE_SCANPASS)
+#else
+# define machine_is_scanpass()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EP7312_POOH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EP7312_POOH
+# endif
+# define machine_is_ep7312_pooh()	(machine_arch_type == MACH_TYPE_EP7312_POOH)
+#else
+# define machine_is_ep7312_pooh()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TA7S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TA7S
+# endif
+# define machine_is_ta7s()	(machine_arch_type == MACH_TYPE_TA7S)
+#else
+# define machine_is_ta7s()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TA7V
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TA7V
+# endif
+# define machine_is_ta7v()	(machine_arch_type == MACH_TYPE_TA7V)
+#else
+# define machine_is_ta7v()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ICARUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICARUS
+# endif
+# define machine_is_icarus()	(machine_arch_type == MACH_TYPE_ICARUS)
+#else
+# define machine_is_icarus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H1900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H1900
+# endif
+# define machine_is_h1900()	(machine_arch_type == MACH_TYPE_H1900)
+#else
+# define machine_is_h1900()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GEMINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GEMINI
+# endif
+# define machine_is_gemini()	(machine_arch_type == MACH_TYPE_GEMINI)
+#else
+# define machine_is_gemini()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AXIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AXIM
+# endif
+# define machine_is_axim()	(machine_arch_type == MACH_TYPE_AXIM)
+#else
+# define machine_is_axim()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AUDIOTRON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AUDIOTRON
+# endif
+# define machine_is_audiotron()	(machine_arch_type == MACH_TYPE_AUDIOTRON)
+#else
+# define machine_is_audiotron()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H2200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H2200
+# endif
+# define machine_is_h2200()	(machine_arch_type == MACH_TYPE_H2200)
+#else
+# define machine_is_h2200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LOOX600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOOX600
+# endif
+# define machine_is_loox600()	(machine_arch_type == MACH_TYPE_LOOX600)
+#else
+# define machine_is_loox600()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NIOP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIOP
+# endif
+# define machine_is_niop()	(machine_arch_type == MACH_TYPE_NIOP)
+#else
+# define machine_is_niop()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DM310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM310
+# endif
+# define machine_is_dm310()	(machine_arch_type == MACH_TYPE_DM310)
+#else
+# define machine_is_dm310()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SEEDPXA_C2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SEEDPXA_C2
+# endif
+# define machine_is_seedpxa_c2()	(machine_arch_type == MACH_TYPE_SEEDPXA_C2)
+#else
+# define machine_is_seedpxa_c2()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXP4XX_MGUARD_PCI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP4XX_MGUARD_PCI
+# endif
+# define machine_is_ixp4xx_mguardpci()	(machine_arch_type == MACH_TYPE_IXP4XX_MGUARD_PCI)
+#else
+# define machine_is_ixp4xx_mguardpci()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H1940
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H1940
+# endif
+# define machine_is_h1940()	(machine_arch_type == MACH_TYPE_H1940)
+#else
+# define machine_is_h1940()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SCORPIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCORPIO
+# endif
+# define machine_is_scorpio()	(machine_arch_type == MACH_TYPE_SCORPIO)
+#else
+# define machine_is_scorpio()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VIVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIVA
+# endif
+# define machine_is_viva()	(machine_arch_type == MACH_TYPE_VIVA)
+#else
+# define machine_is_viva()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_XCARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_XCARD
+# endif
+# define machine_is_pxa_xcard()	(machine_arch_type == MACH_TYPE_PXA_XCARD)
+#else
+# define machine_is_pxa_xcard()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CSB335
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB335
+# endif
+# define machine_is_csb335()	(machine_arch_type == MACH_TYPE_CSB335)
+#else
+# define machine_is_csb335()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXRD425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXRD425
+# endif
+# define machine_is_ixrd425()	(machine_arch_type == MACH_TYPE_IXRD425)
+#else
+# define machine_is_ixrd425()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80315
+# endif
+# define machine_is_iq80315()	(machine_arch_type == MACH_TYPE_IQ80315)
+#else
+# define machine_is_iq80315()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NMP7312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NMP7312
+# endif
+# define machine_is_nmp7312()	(machine_arch_type == MACH_TYPE_NMP7312)
+#else
+# define machine_is_nmp7312()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CX861XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CX861XX
+# endif
+# define machine_is_cx861xx()	(machine_arch_type == MACH_TYPE_CX861XX)
+#else
+# define machine_is_cx861xx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ENP2611
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENP2611
+# endif
+# define machine_is_enp2611()	(machine_arch_type == MACH_TYPE_ENP2611)
+#else
+# define machine_is_enp2611()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_XDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XDA
+# endif
+# define machine_is_xda()	(machine_arch_type == MACH_TYPE_XDA)
+#else
+# define machine_is_xda()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CSIR_IMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSIR_IMS
+# endif
+# define machine_is_csir_ims()	(machine_arch_type == MACH_TYPE_CSIR_IMS)
+#else
+# define machine_is_csir_ims()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXP421_DNAEETH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP421_DNAEETH
+# endif
+# define machine_is_ixp421_dnaeeth()	(machine_arch_type == MACH_TYPE_IXP421_DNAEETH)
+#else
+# define machine_is_ixp421_dnaeeth()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_POCKETSERV9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POCKETSERV9200
+# endif
+# define machine_is_pocketserv9200()	(machine_arch_type == MACH_TYPE_POCKETSERV9200)
+#else
+# define machine_is_pocketserv9200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TOTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOTO
+# endif
+# define machine_is_toto()	(machine_arch_type == MACH_TYPE_TOTO)
+#else
+# define machine_is_toto()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2440
+# endif
+# define machine_is_s3c2440()	(machine_arch_type == MACH_TYPE_S3C2440)
+#else
+# define machine_is_s3c2440()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KS8695P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KS8695P
+# endif
+# define machine_is_ks8695p()	(machine_arch_type == MACH_TYPE_KS8695P)
+#else
+# define machine_is_ks8695p()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SE4000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SE4000
+# endif
+# define machine_is_se4000()	(machine_arch_type == MACH_TYPE_SE4000)
+#else
+# define machine_is_se4000()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_QUADRICEPS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUADRICEPS
+# endif
+# define machine_is_quadriceps()	(machine_arch_type == MACH_TYPE_QUADRICEPS)
+#else
+# define machine_is_quadriceps()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BRONCO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BRONCO
+# endif
+# define machine_is_bronco()	(machine_arch_type == MACH_TYPE_BRONCO)
+#else
+# define machine_is_bronco()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ESL_SOFCOMP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SOFCOMP
+# endif
+# define machine_is_esl_sofcomp()	(machine_arch_type == MACH_TYPE_ESL_SOFCOMP)
+#else
+# define machine_is_esl_sofcomp()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S5C7375
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5C7375
+# endif
+# define machine_is_s5c7375()	(machine_arch_type == MACH_TYPE_S5C7375)
+#else
+# define machine_is_s5c7375()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SPEARHEAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEARHEAD
+# endif
+# define machine_is_spearhead()	(machine_arch_type == MACH_TYPE_SPEARHEAD)
+#else
+# define machine_is_spearhead()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PANTERA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PANTERA
+# endif
+# define machine_is_pantera()	(machine_arch_type == MACH_TYPE_PANTERA)
+#else
+# define machine_is_pantera()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PRAYOGLITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRAYOGLITE
+# endif
+# define machine_is_prayoglite()	(machine_arch_type == MACH_TYPE_PRAYOGLITE)
+#else
+# define machine_is_prayoglite()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GUMSTIK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GUMSTIK
+# endif
+# define machine_is_gumstix()	(machine_arch_type == MACH_TYPE_GUMSTIK)
+#else
+# define machine_is_gumstix()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_RCUBE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RCUBE
+# endif
+# define machine_is_rcube()	(machine_arch_type == MACH_TYPE_RCUBE)
+#else
+# define machine_is_rcube()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_REA_OLV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REA_OLV
+# endif
+# define machine_is_rea_olv()	(machine_arch_type == MACH_TYPE_REA_OLV)
+#else
+# define machine_is_rea_olv()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_IPHONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_IPHONE
+# endif
+# define machine_is_pxa_iphone()	(machine_arch_type == MACH_TYPE_PXA_IPHONE)
+#else
+# define machine_is_pxa_iphone()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C3410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C3410
+# endif
+# define machine_is_s3c3410()	(machine_arch_type == MACH_TYPE_S3C3410)
+#else
+# define machine_is_s3c3410()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ESPD_4510B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESPD_4510B
+# endif
+# define machine_is_espd_4510b()	(machine_arch_type == MACH_TYPE_ESPD_4510B)
+#else
+# define machine_is_espd_4510b()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MP1X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MP1X
+# endif
+# define machine_is_mp1x()	(machine_arch_type == MACH_TYPE_MP1X)
+#else
+# define machine_is_mp1x()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AT91RM9200TB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200TB
+# endif
+# define machine_is_at91rm9200tb()	(machine_arch_type == MACH_TYPE_AT91RM9200TB)
+#else
+# define machine_is_at91rm9200tb()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADSVGX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSVGX
+# endif
+# define machine_is_adsvgx()	(machine_arch_type == MACH_TYPE_ADSVGX)
+#else
+# define machine_is_adsvgx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H2
+# endif
+# define machine_is_omap_h2()	(machine_arch_type == MACH_TYPE_OMAP_H2)
+#else
+# define machine_is_omap_h2()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PELEE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELEE
+# endif
+# define machine_is_pelee()	(machine_arch_type == MACH_TYPE_PELEE)
+#else
+# define machine_is_pelee()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E740
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E740
+# endif
+# define machine_is_e740()	(machine_arch_type == MACH_TYPE_E740)
+#else
+# define machine_is_e740()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80331
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80331
+# endif
+# define machine_is_iq80331()	(machine_arch_type == MACH_TYPE_IQ80331)
+#else
+# define machine_is_iq80331()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VERSATILE_PB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERSATILE_PB
+# endif
+# define machine_is_versatile_pb()	(machine_arch_type == MACH_TYPE_VERSATILE_PB)
+#else
+# define machine_is_versatile_pb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KEV7A400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KEV7A400
+# endif
+# define machine_is_kev7a400()	(machine_arch_type == MACH_TYPE_KEV7A400)
+#else
+# define machine_is_kev7a400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD7A400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD7A400
+# endif
+# define machine_is_lpd7a400()	(machine_arch_type == MACH_TYPE_LPD7A400)
+#else
+# define machine_is_lpd7a400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD7A404
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD7A404
+# endif
+# define machine_is_lpd7a404()	(machine_arch_type == MACH_TYPE_LPD7A404)
+#else
+# define machine_is_lpd7a404()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_FUJITSU_CAMELOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FUJITSU_CAMELOT
+# endif
+# define machine_is_fujitsu_camelot()	(machine_arch_type == MACH_TYPE_FUJITSU_CAMELOT)
+#else
+# define machine_is_fujitsu_camelot()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_JANUS2M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JANUS2M
+# endif
+# define machine_is_janus2m()	(machine_arch_type == MACH_TYPE_JANUS2M)
+#else
+# define machine_is_janus2m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMBTF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMBTF
+# endif
+# define machine_is_embtf()	(machine_arch_type == MACH_TYPE_EMBTF)
+#else
+# define machine_is_embtf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HPM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HPM
+# endif
+# define machine_is_hpm()	(machine_arch_type == MACH_TYPE_HPM)
+#else
+# define machine_is_hpm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2410TK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2410TK
+# endif
+# define machine_is_smdk2410tk()	(machine_arch_type == MACH_TYPE_SMDK2410TK)
+#else
+# define machine_is_smdk2410tk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2410AJ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2410AJ
+# endif
+# define machine_is_smdk2410aj()	(machine_arch_type == MACH_TYPE_SMDK2410AJ)
+#else
+# define machine_is_smdk2410aj()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STREETRACER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STREETRACER
+# endif
+# define machine_is_streetracer()	(machine_arch_type == MACH_TYPE_STREETRACER)
+#else
+# define machine_is_streetracer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EFRAME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EFRAME
+# endif
+# define machine_is_eframe()	(machine_arch_type == MACH_TYPE_EFRAME)
+#else
+# define machine_is_eframe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB337
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB337
+# endif
+# define machine_is_csb337()	(machine_arch_type == MACH_TYPE_CSB337)
+#else
+# define machine_is_csb337()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_LARK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_LARK
+# endif
+# define machine_is_pxa_lark()	(machine_arch_type == MACH_TYPE_PXA_LARK)
+#else
+# define machine_is_pxa_lark()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNP2110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNP2110
+# endif
+# define machine_is_pxa_pnp2110()	(machine_arch_type == MACH_TYPE_PNP2110)
+#else
+# define machine_is_pxa_pnp2110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TCC72X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TCC72X
+# endif
+# define machine_is_tcc72x()	(machine_arch_type == MACH_TYPE_TCC72X)
+#else
+# define machine_is_tcc72x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ALTAIR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALTAIR
+# endif
+# define machine_is_altair()	(machine_arch_type == MACH_TYPE_ALTAIR)
+#else
+# define machine_is_altair()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KC3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KC3
+# endif
+# define machine_is_kc3()	(machine_arch_type == MACH_TYPE_KC3)
+#else
+# define machine_is_kc3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SINTEFTD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SINTEFTD
+# endif
+# define machine_is_sinteftd()	(machine_arch_type == MACH_TYPE_SINTEFTD)
+#else
+# define machine_is_sinteftd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAINSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAINSTONE
+# endif
+# define machine_is_mainstone()	(machine_arch_type == MACH_TYPE_MAINSTONE)
+#else
+# define machine_is_mainstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADAY4X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADAY4X
+# endif
+# define machine_is_aday4x()	(machine_arch_type == MACH_TYPE_ADAY4X)
+#else
+# define machine_is_aday4x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LITE300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LITE300
+# endif
+# define machine_is_lite300()	(machine_arch_type == MACH_TYPE_LITE300)
+#else
+# define machine_is_lite300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S5C7376
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5C7376
+# endif
+# define machine_is_s5c7376()	(machine_arch_type == MACH_TYPE_S5C7376)
+#else
+# define machine_is_s5c7376()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MT02
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MT02
+# endif
+# define machine_is_mt02()	(machine_arch_type == MACH_TYPE_MT02)
+#else
+# define machine_is_mt02()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MPORT3S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPORT3S
+# endif
+# define machine_is_mport3s()	(machine_arch_type == MACH_TYPE_MPORT3S)
+#else
+# define machine_is_mport3s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RA_ALPHA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RA_ALPHA
+# endif
+# define machine_is_ra_alpha()	(machine_arch_type == MACH_TYPE_RA_ALPHA)
+#else
+# define machine_is_ra_alpha()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XCEP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XCEP
+# endif
+# define machine_is_xcep()	(machine_arch_type == MACH_TYPE_XCEP)
+#else
+# define machine_is_xcep()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCOM_MERCURY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCOM_MERCURY
+# endif
+# define machine_is_arcom_mercury()	(machine_arch_type == MACH_TYPE_ARCOM_MERCURY)
+#else
+# define machine_is_arcom_mercury()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STARGATE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STARGATE
+# endif
+# define machine_is_stargate()	(machine_arch_type == MACH_TYPE_STARGATE)
+#else
+# define machine_is_stargate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLOJ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLOJ
+# endif
+# define machine_is_armadilloj()	(machine_arch_type == MACH_TYPE_ARMADILLOJ)
+#else
+# define machine_is_armadilloj()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELROY_JACK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELROY_JACK
+# endif
+# define machine_is_elroy_jack()	(machine_arch_type == MACH_TYPE_ELROY_JACK)
+#else
+# define machine_is_elroy_jack()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BACKEND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BACKEND
+# endif
+# define machine_is_backend()	(machine_arch_type == MACH_TYPE_BACKEND)
+#else
+# define machine_is_backend()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S5LINBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5LINBOX
+# endif
+# define machine_is_s5linbox()	(machine_arch_type == MACH_TYPE_S5LINBOX)
+#else
+# define machine_is_s5linbox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOMADIK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOMADIK
+# endif
+# define machine_is_nomadik()	(machine_arch_type == MACH_TYPE_NOMADIK)
+#else
+# define machine_is_nomadik()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IA_CPU_9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IA_CPU_9200
+# endif
+# define machine_is_ia_cpu_9200()	(machine_arch_type == MACH_TYPE_IA_CPU_9200)
+#else
+# define machine_is_ia_cpu_9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91_BJA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91_BJA1
+# endif
+# define machine_is_at91_bja1()	(machine_arch_type == MACH_TYPE_AT91_BJA1)
+#else
+# define machine_is_at91_bja1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CORGI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CORGI
+# endif
+# define machine_is_corgi()	(machine_arch_type == MACH_TYPE_CORGI)
+#else
+# define machine_is_corgi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POODLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POODLE
+# endif
+# define machine_is_poodle()	(machine_arch_type == MACH_TYPE_POODLE)
+#else
+# define machine_is_poodle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEN
+# endif
+# define machine_is_ten()	(machine_arch_type == MACH_TYPE_TEN)
+#else
+# define machine_is_ten()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERP5P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERP5P
+# endif
+# define machine_is_roverp5p()	(machine_arch_type == MACH_TYPE_ROVERP5P)
+#else
+# define machine_is_roverp5p()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SC2700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SC2700
+# endif
+# define machine_is_sc2700()	(machine_arch_type == MACH_TYPE_SC2700)
+#else
+# define machine_is_sc2700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EX_EAGLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EX_EAGLE
+# endif
+# define machine_is_ex_eagle()	(machine_arch_type == MACH_TYPE_EX_EAGLE)
+#else
+# define machine_is_ex_eagle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NX_PXA12
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NX_PXA12
+# endif
+# define machine_is_nx_pxa12()	(machine_arch_type == MACH_TYPE_NX_PXA12)
+#else
+# define machine_is_nx_pxa12()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NX_PXA5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NX_PXA5
+# endif
+# define machine_is_nx_pxa5()	(machine_arch_type == MACH_TYPE_NX_PXA5)
+#else
+# define machine_is_nx_pxa5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLACKBOARD2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLACKBOARD2
+# endif
+# define machine_is_blackboard2()	(machine_arch_type == MACH_TYPE_BLACKBOARD2)
+#else
+# define machine_is_blackboard2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_I819
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I819
+# endif
+# define machine_is_i819()	(machine_arch_type == MACH_TYPE_I819)
+#else
+# define machine_is_i819()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXMB995E
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXMB995E
+# endif
+# define machine_is_ixmb995e()	(machine_arch_type == MACH_TYPE_IXMB995E)
+#else
+# define machine_is_ixmb995e()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKYRIDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKYRIDER
+# endif
+# define machine_is_skyrider()	(machine_arch_type == MACH_TYPE_SKYRIDER)
+#else
+# define machine_is_skyrider()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKYHAWK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKYHAWK
+# endif
+# define machine_is_skyhawk()	(machine_arch_type == MACH_TYPE_SKYHAWK)
+#else
+# define machine_is_skyhawk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENTERPRISE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENTERPRISE
+# endif
+# define machine_is_enterprise()	(machine_arch_type == MACH_TYPE_ENTERPRISE)
+#else
+# define machine_is_enterprise()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEP2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEP2410
+# endif
+# define machine_is_dep2410()	(machine_arch_type == MACH_TYPE_DEP2410)
+#else
+# define machine_is_dep2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMCORE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMCORE
+# endif
+# define machine_is_armcore()	(machine_arch_type == MACH_TYPE_ARMCORE)
+#else
+# define machine_is_armcore()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HOBBIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HOBBIT
+# endif
+# define machine_is_hobbit()	(machine_arch_type == MACH_TYPE_HOBBIT)
+#else
+# define machine_is_hobbit()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H7210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H7210
+# endif
+# define machine_is_h7210()	(machine_arch_type == MACH_TYPE_H7210)
+#else
+# define machine_is_h7210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_NETDCU5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_NETDCU5
+# endif
+# define machine_is_pxa_netdcu5()	(machine_arch_type == MACH_TYPE_PXA_NETDCU5)
+#else
+# define machine_is_pxa_netdcu5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACC
+# endif
+# define machine_is_acc()	(machine_arch_type == MACH_TYPE_ACC)
+#else
+# define machine_is_acc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_SARVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SARVA
+# endif
+# define machine_is_esl_sarva()	(machine_arch_type == MACH_TYPE_ESL_SARVA)
+#else
+# define machine_is_esl_sarva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XM250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XM250
+# endif
+# define machine_is_xm250()	(machine_arch_type == MACH_TYPE_XM250)
+#else
+# define machine_is_xm250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T6TC1XB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T6TC1XB
+# endif
+# define machine_is_t6tc1xb()	(machine_arch_type == MACH_TYPE_T6TC1XB)
+#else
+# define machine_is_t6tc1xb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESS710
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESS710
+# endif
+# define machine_is_ess710()	(machine_arch_type == MACH_TYPE_ESS710)
+#else
+# define machine_is_ess710()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX3ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX3ADS
+# endif
+# define machine_is_mx3ads()	(machine_arch_type == MACH_TYPE_MX3ADS)
+#else
+# define machine_is_mx3ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HIMALAYA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HIMALAYA
+# endif
+# define machine_is_himalaya()	(machine_arch_type == MACH_TYPE_HIMALAYA)
+#else
+# define machine_is_himalaya()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BOLFENK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BOLFENK
+# endif
+# define machine_is_bolfenk()	(machine_arch_type == MACH_TYPE_BOLFENK)
+#else
+# define machine_is_bolfenk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200KR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200KR
+# endif
+# define machine_is_at91rm9200kr()	(machine_arch_type == MACH_TYPE_AT91RM9200KR)
+#else
+# define machine_is_at91rm9200kr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9312
+# endif
+# define machine_is_edb9312()	(machine_arch_type == MACH_TYPE_EDB9312)
+#else
+# define machine_is_edb9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_GENERIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_GENERIC
+# endif
+# define machine_is_omap_generic()	(machine_arch_type == MACH_TYPE_OMAP_GENERIC)
+#else
+# define machine_is_omap_generic()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AXIMX3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AXIMX3
+# endif
+# define machine_is_aximx3()	(machine_arch_type == MACH_TYPE_AXIMX3)
+#else
+# define machine_is_aximx3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EB67XDIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EB67XDIP
+# endif
+# define machine_is_eb67xdip()	(machine_arch_type == MACH_TYPE_EB67XDIP)
+#else
+# define machine_is_eb67xdip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WEBTXS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEBTXS
+# endif
+# define machine_is_webtxs()	(machine_arch_type == MACH_TYPE_WEBTXS)
+#else
+# define machine_is_webtxs()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HAWK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HAWK
+# endif
+# define machine_is_hawk()	(machine_arch_type == MACH_TYPE_HAWK)
+#else
+# define machine_is_hawk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCAT91SBC001
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCAT91SBC001
+# endif
+# define machine_is_ccat91sbc001()	(machine_arch_type == MACH_TYPE_CCAT91SBC001)
+#else
+# define machine_is_ccat91sbc001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXPRESSO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXPRESSO
+# endif
+# define machine_is_expresso()	(machine_arch_type == MACH_TYPE_EXPRESSO)
+#else
+# define machine_is_expresso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H4000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H4000
+# endif
+# define machine_is_h4000()	(machine_arch_type == MACH_TYPE_H4000)
+#else
+# define machine_is_h4000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DINO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DINO
+# endif
+# define machine_is_dino()	(machine_arch_type == MACH_TYPE_DINO)
+#else
+# define machine_is_dino()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ML675K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ML675K
+# endif
+# define machine_is_ml675k()	(machine_arch_type == MACH_TYPE_ML675K)
+#else
+# define machine_is_ml675k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9301
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9301
+# endif
+# define machine_is_edb9301()	(machine_arch_type == MACH_TYPE_EDB9301)
+#else
+# define machine_is_edb9301()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9315
+# endif
+# define machine_is_edb9315()	(machine_arch_type == MACH_TYPE_EDB9315)
+#else
+# define machine_is_edb9315()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RECIVA_TT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RECIVA_TT
+# endif
+# define machine_is_reciva_tt()	(machine_arch_type == MACH_TYPE_RECIVA_TT)
+#else
+# define machine_is_reciva_tt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSTCB01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSTCB01
+# endif
+# define machine_is_cstcb01()	(machine_arch_type == MACH_TYPE_CSTCB01)
+#else
+# define machine_is_cstcb01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSTCB1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSTCB1
+# endif
+# define machine_is_cstcb1()	(machine_arch_type == MACH_TYPE_CSTCB1)
+#else
+# define machine_is_cstcb1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHADWELL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHADWELL
+# endif
+# define machine_is_shadwell()	(machine_arch_type == MACH_TYPE_SHADWELL)
+#else
+# define machine_is_shadwell()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GOEPEL263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GOEPEL263
+# endif
+# define machine_is_goepel263()	(machine_arch_type == MACH_TYPE_GOEPEL263)
+#else
+# define machine_is_goepel263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACQ100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACQ100
+# endif
+# define machine_is_acq100()	(machine_arch_type == MACH_TYPE_ACQ100)
+#else
+# define machine_is_acq100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX1FS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX1FS2
+# endif
+# define machine_is_mx1fs2()	(machine_arch_type == MACH_TYPE_MX1FS2)
+#else
+# define machine_is_mx1fs2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HIPTOP_G1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HIPTOP_G1
+# endif
+# define machine_is_hiptop_g1()	(machine_arch_type == MACH_TYPE_HIPTOP_G1)
+#else
+# define machine_is_hiptop_g1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPARKY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPARKY
+# endif
+# define machine_is_sparky()	(machine_arch_type == MACH_TYPE_SPARKY)
+#else
+# define machine_is_sparky()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS9750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS9750
+# endif
+# define machine_is_ns9750()	(machine_arch_type == MACH_TYPE_NS9750)
+#else
+# define machine_is_ns9750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHOENIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHOENIX
+# endif
+# define machine_is_phoenix()	(machine_arch_type == MACH_TYPE_PHOENIX)
+#else
+# define machine_is_phoenix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VR1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VR1000
+# endif
+# define machine_is_vr1000()	(machine_arch_type == MACH_TYPE_VR1000)
+#else
+# define machine_is_vr1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEISTERPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEISTERPXA
+# endif
+# define machine_is_deisterpxa()	(machine_arch_type == MACH_TYPE_DEISTERPXA)
+#else
+# define machine_is_deisterpxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCM1160
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCM1160
+# endif
+# define machine_is_bcm1160()	(machine_arch_type == MACH_TYPE_BCM1160)
+#else
+# define machine_is_bcm1160()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM022
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM022
+# endif
+# define machine_is_pcm022()	(machine_arch_type == MACH_TYPE_PCM022)
+#else
+# define machine_is_pcm022()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSGCX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSGCX
+# endif
+# define machine_is_adsgcx()	(machine_arch_type == MACH_TYPE_ADSGCX)
+#else
+# define machine_is_adsgcx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DREADNAUGHT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DREADNAUGHT
+# endif
+# define machine_is_dreadnaught()	(machine_arch_type == MACH_TYPE_DREADNAUGHT)
+#else
+# define machine_is_dreadnaught()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM320
+# endif
+# define machine_is_dm320()	(machine_arch_type == MACH_TYPE_DM320)
+#else
+# define machine_is_dm320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARKOV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARKOV
+# endif
+# define machine_is_markov()	(machine_arch_type == MACH_TYPE_MARKOV)
+#else
+# define machine_is_markov()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COS7A400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COS7A400
+# endif
+# define machine_is_cos7a400()	(machine_arch_type == MACH_TYPE_COS7A400)
+#else
+# define machine_is_cos7a400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MILANO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MILANO
+# endif
+# define machine_is_milano()	(machine_arch_type == MACH_TYPE_MILANO)
+#else
+# define machine_is_milano()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UE9328
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UE9328
+# endif
+# define machine_is_ue9328()	(machine_arch_type == MACH_TYPE_UE9328)
+#else
+# define machine_is_ue9328()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UEX255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UEX255
+# endif
+# define machine_is_uex255()	(machine_arch_type == MACH_TYPE_UEX255)
+#else
+# define machine_is_uex255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UE2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UE2410
+# endif
+# define machine_is_ue2410()	(machine_arch_type == MACH_TYPE_UE2410)
+#else
+# define machine_is_ue2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A620
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A620
+# endif
+# define machine_is_a620()	(machine_arch_type == MACH_TYPE_A620)
+#else
+# define machine_is_a620()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OCELOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OCELOT
+# endif
+# define machine_is_ocelot()	(machine_arch_type == MACH_TYPE_OCELOT)
+#else
+# define machine_is_ocelot()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHEETAH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHEETAH
+# endif
+# define machine_is_cheetah()	(machine_arch_type == MACH_TYPE_CHEETAH)
+#else
+# define machine_is_cheetah()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PERSEUS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PERSEUS2
+# endif
+# define machine_is_omap_perseus2()	(machine_arch_type == MACH_TYPE_OMAP_PERSEUS2)
+#else
+# define machine_is_omap_perseus2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZVUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZVUE
+# endif
+# define machine_is_zvue()	(machine_arch_type == MACH_TYPE_ZVUE)
+#else
+# define machine_is_zvue()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERP1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERP1
+# endif
+# define machine_is_roverp1()	(machine_arch_type == MACH_TYPE_ROVERP1)
+#else
+# define machine_is_roverp1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASIDIAL2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASIDIAL2
+# endif
+# define machine_is_asidial2()	(machine_arch_type == MACH_TYPE_ASIDIAL2)
+#else
+# define machine_is_asidial2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C24A0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C24A0
+# endif
+# define machine_is_s3c24a0()	(machine_arch_type == MACH_TYPE_S3C24A0)
+#else
+# define machine_is_s3c24a0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E800
+# endif
+# define machine_is_e800()	(machine_arch_type == MACH_TYPE_E800)
+#else
+# define machine_is_e800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E750
+# endif
+# define machine_is_e750()	(machine_arch_type == MACH_TYPE_E750)
+#else
+# define machine_is_e750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C5500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C5500
+# endif
+# define machine_is_s3c5500()	(machine_arch_type == MACH_TYPE_S3C5500)
+#else
+# define machine_is_s3c5500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK5500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK5500
+# endif
+# define machine_is_smdk5500()	(machine_arch_type == MACH_TYPE_SMDK5500)
+#else
+# define machine_is_smdk5500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIGNALSYNC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIGNALSYNC
+# endif
+# define machine_is_signalsync()	(machine_arch_type == MACH_TYPE_SIGNALSYNC)
+#else
+# define machine_is_signalsync()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NBC
+# endif
+# define machine_is_nbc()	(machine_arch_type == MACH_TYPE_NBC)
+#else
+# define machine_is_nbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KODIAK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KODIAK
+# endif
+# define machine_is_kodiak()	(machine_arch_type == MACH_TYPE_KODIAK)
+#else
+# define machine_is_kodiak()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETBOOKPRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETBOOKPRO
+# endif
+# define machine_is_netbookpro()	(machine_arch_type == MACH_TYPE_NETBOOKPRO)
+#else
+# define machine_is_netbookpro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW90200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW90200
+# endif
+# define machine_is_hw90200()	(machine_arch_type == MACH_TYPE_HW90200)
+#else
+# define machine_is_hw90200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CONDOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CONDOR
+# endif
+# define machine_is_condor()	(machine_arch_type == MACH_TYPE_CONDOR)
+#else
+# define machine_is_condor()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CUP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CUP
+# endif
+# define machine_is_cup()	(machine_arch_type == MACH_TYPE_CUP)
+#else
+# define machine_is_cup()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KITE
+# endif
+# define machine_is_kite()	(machine_arch_type == MACH_TYPE_KITE)
+#else
+# define machine_is_kite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCB9328
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCB9328
+# endif
+# define machine_is_scb9328()	(machine_arch_type == MACH_TYPE_SCB9328)
+#else
+# define machine_is_scb9328()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H3
+# endif
+# define machine_is_omap_h3()	(machine_arch_type == MACH_TYPE_OMAP_H3)
+#else
+# define machine_is_omap_h3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H4
+# endif
+# define machine_is_omap_h4()	(machine_arch_type == MACH_TYPE_OMAP_H4)
+#else
+# define machine_is_omap_h4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N10
+# endif
+# define machine_is_n10()	(machine_arch_type == MACH_TYPE_N10)
+#else
+# define machine_is_n10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MONTAJADE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MONTAJADE
+# endif
+# define machine_is_montejade()	(machine_arch_type == MACH_TYPE_MONTAJADE)
+#else
+# define machine_is_montejade()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG560
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG560
+# endif
+# define machine_is_sg560()	(machine_arch_type == MACH_TYPE_SG560)
+#else
+# define machine_is_sg560()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DP1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DP1000
+# endif
+# define machine_is_dp1000()	(machine_arch_type == MACH_TYPE_DP1000)
+#else
+# define machine_is_dp1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_OSK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_OSK
+# endif
+# define machine_is_omap_osk()	(machine_arch_type == MACH_TYPE_OMAP_OSK)
+#else
+# define machine_is_omap_osk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RG100V3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RG100V3
+# endif
+# define machine_is_rg100v3()	(machine_arch_type == MACH_TYPE_RG100V3)
+#else
+# define machine_is_rg100v3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX2ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX2ADS
+# endif
+# define machine_is_mx2ads()	(machine_arch_type == MACH_TYPE_MX2ADS)
+#else
+# define machine_is_mx2ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_KILO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_KILO
+# endif
+# define machine_is_pxa_kilo()	(machine_arch_type == MACH_TYPE_PXA_KILO)
+#else
+# define machine_is_pxa_kilo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXP4XX_EAGLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP4XX_EAGLE
+# endif
+# define machine_is_ixp4xx_eagle()	(machine_arch_type == MACH_TYPE_IXP4XX_EAGLE)
+#else
+# define machine_is_ixp4xx_eagle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOSA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOSA
+# endif
+# define machine_is_tosa()	(machine_arch_type == MACH_TYPE_TOSA)
+#else
+# define machine_is_tosa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB2520F
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB2520F
+# endif
+# define machine_is_mb2520f()	(machine_arch_type == MACH_TYPE_MB2520F)
+#else
+# define machine_is_mb2520f()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMC1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMC1000
+# endif
+# define machine_is_emc1000()	(machine_arch_type == MACH_TYPE_EMC1000)
+#else
+# define machine_is_emc1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TIDSC25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TIDSC25
+# endif
+# define machine_is_tidsc25()	(machine_arch_type == MACH_TYPE_TIDSC25)
+#else
+# define machine_is_tidsc25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AKCPMXL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AKCPMXL
+# endif
+# define machine_is_akcpmxl()	(machine_arch_type == MACH_TYPE_AKCPMXL)
+#else
+# define machine_is_akcpmxl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AV3XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AV3XX
+# endif
+# define machine_is_av3xx()	(machine_arch_type == MACH_TYPE_AV3XX)
+#else
+# define machine_is_av3xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVILA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVILA
+# endif
+# define machine_is_avila()	(machine_arch_type == MACH_TYPE_AVILA)
+#else
+# define machine_is_avila()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_MPM10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_MPM10
+# endif
+# define machine_is_pxa_mpm10()	(machine_arch_type == MACH_TYPE_PXA_MPM10)
+#else
+# define machine_is_pxa_mpm10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_KYANITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_KYANITE
+# endif
+# define machine_is_pxa_kyanite()	(machine_arch_type == MACH_TYPE_PXA_KYANITE)
+#else
+# define machine_is_pxa_kyanite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SGOLD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SGOLD
+# endif
+# define machine_is_sgold()	(machine_arch_type == MACH_TYPE_SGOLD)
+#else
+# define machine_is_sgold()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSCAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSCAR
+# endif
+# define machine_is_oscar()	(machine_arch_type == MACH_TYPE_OSCAR)
+#else
+# define machine_is_oscar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EPXA4USB2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EPXA4USB2
+# endif
+# define machine_is_epxa4usb2()	(machine_arch_type == MACH_TYPE_EPXA4USB2)
+#else
+# define machine_is_epxa4usb2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSENGINE
+# endif
+# define machine_is_xsengine()	(machine_arch_type == MACH_TYPE_XSENGINE)
+#else
+# define machine_is_xsengine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IP600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IP600
+# endif
+# define machine_is_ip600()	(machine_arch_type == MACH_TYPE_IP600)
+#else
+# define machine_is_ip600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MCAN2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MCAN2
+# endif
+# define machine_is_mcan2()	(machine_arch_type == MACH_TYPE_MCAN2)
+#else
+# define machine_is_mcan2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DDI_BLUERIDGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DDI_BLUERIDGE
+# endif
+# define machine_is_ddi_blueridge()	(machine_arch_type == MACH_TYPE_DDI_BLUERIDGE)
+#else
+# define machine_is_ddi_blueridge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKYMINDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKYMINDER
+# endif
+# define machine_is_skyminder()	(machine_arch_type == MACH_TYPE_SKYMINDER)
+#else
+# define machine_is_skyminder()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD79520
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD79520
+# endif
+# define machine_is_lpd79520()	(machine_arch_type == MACH_TYPE_LPD79520)
+#else
+# define machine_is_lpd79520()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9302
+# endif
+# define machine_is_edb9302()	(machine_arch_type == MACH_TYPE_EDB9302)
+#else
+# define machine_is_edb9302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW90340
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW90340
+# endif
+# define machine_is_hw90340()	(machine_arch_type == MACH_TYPE_HW90340)
+#else
+# define machine_is_hw90340()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CIP_BOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CIP_BOX
+# endif
+# define machine_is_cip_box()	(machine_arch_type == MACH_TYPE_CIP_BOX)
+#else
+# define machine_is_cip_box()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IVPN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IVPN
+# endif
+# define machine_is_ivpn()	(machine_arch_type == MACH_TYPE_IVPN)
+#else
+# define machine_is_ivpn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RSOC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RSOC2
+# endif
+# define machine_is_rsoc2()	(machine_arch_type == MACH_TYPE_RSOC2)
+#else
+# define machine_is_rsoc2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HUSKY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HUSKY
+# endif
+# define machine_is_husky()	(machine_arch_type == MACH_TYPE_HUSKY)
+#else
+# define machine_is_husky()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BOXER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BOXER
+# endif
+# define machine_is_boxer()	(machine_arch_type == MACH_TYPE_BOXER)
+#else
+# define machine_is_boxer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHEPHERD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHEPHERD
+# endif
+# define machine_is_shepherd()	(machine_arch_type == MACH_TYPE_SHEPHERD)
+#else
+# define machine_is_shepherd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AML42800AA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AML42800AA
+# endif
+# define machine_is_aml42800aa()	(machine_arch_type == MACH_TYPE_AML42800AA)
+#else
+# define machine_is_aml42800aa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MACH_TYPE_ML674001
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACH_TYPE_ML674001
+# endif
+# define machine_is_ml674001()	(machine_arch_type == MACH_TYPE_MACH_TYPE_ML674001)
+#else
+# define machine_is_ml674001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPC2294
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPC2294
+# endif
+# define machine_is_lpc2294()	(machine_arch_type == MACH_TYPE_LPC2294)
+#else
+# define machine_is_lpc2294()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWITCHGRASS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWITCHGRASS
+# endif
+# define machine_is_switchgrass()	(machine_arch_type == MACH_TYPE_SWITCHGRASS)
+#else
+# define machine_is_switchgrass()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENS_CMU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENS_CMU
+# endif
+# define machine_is_ens_cmu()	(machine_arch_type == MACH_TYPE_ENS_CMU)
+#else
+# define machine_is_ens_cmu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MM6_SDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MM6_SDB
+# endif
+# define machine_is_mm6_sdb()	(machine_arch_type == MACH_TYPE_MM6_SDB)
+#else
+# define machine_is_mm6_sdb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SATURN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SATURN
+# endif
+# define machine_is_saturn()	(machine_arch_type == MACH_TYPE_SATURN)
+#else
+# define machine_is_saturn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARGONPLUSEVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARGONPLUSEVB
+# endif
+# define machine_is_argonplusevb()	(machine_arch_type == MACH_TYPE_ARGONPLUSEVB)
+#else
+# define machine_is_argonplusevb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCMA11EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCMA11EVB
+# endif
+# define machine_is_scma11evb()	(machine_arch_type == MACH_TYPE_SCMA11EVB)
+#else
+# define machine_is_scma11evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2800
+# endif
+# define machine_is_smdk2800()	(machine_arch_type == MACH_TYPE_SMDK2800)
+#else
+# define machine_is_smdk2800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MTWILSON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MTWILSON
+# endif
+# define machine_is_mtwilson()	(machine_arch_type == MACH_TYPE_MTWILSON)
+#else
+# define machine_is_mtwilson()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZITI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZITI
+# endif
+# define machine_is_ziti()	(machine_arch_type == MACH_TYPE_ZITI)
+#else
+# define machine_is_ziti()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GRANDFATHER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRANDFATHER
+# endif
+# define machine_is_grandfather()	(machine_arch_type == MACH_TYPE_GRANDFATHER)
+#else
+# define machine_is_grandfather()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TENGINE
+# endif
+# define machine_is_tengine()	(machine_arch_type == MACH_TYPE_TENGINE)
+#else
+# define machine_is_tengine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2460
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2460
+# endif
+# define machine_is_s3c2460()	(machine_arch_type == MACH_TYPE_S3C2460)
+#else
+# define machine_is_s3c2460()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PDM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PDM
+# endif
+# define machine_is_pdm()	(machine_arch_type == MACH_TYPE_PDM)
+#else
+# define machine_is_pdm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H4700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H4700
+# endif
+# define machine_is_h4700()	(machine_arch_type == MACH_TYPE_H4700)
+#else
+# define machine_is_h4700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H6300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H6300
+# endif
+# define machine_is_h6300()	(machine_arch_type == MACH_TYPE_H6300)
+#else
+# define machine_is_h6300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RZ1700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RZ1700
+# endif
+# define machine_is_rz1700()	(machine_arch_type == MACH_TYPE_RZ1700)
+#else
+# define machine_is_rz1700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A716
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A716
+# endif
+# define machine_is_a716()	(machine_arch_type == MACH_TYPE_A716)
+#else
+# define machine_is_a716()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESTK2440A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESTK2440A
+# endif
+# define machine_is_estk2440a()	(machine_arch_type == MACH_TYPE_ESTK2440A)
+#else
+# define machine_is_estk2440a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATWIXP425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATWIXP425
+# endif
+# define machine_is_atwixp425()	(machine_arch_type == MACH_TYPE_ATWIXP425)
+#else
+# define machine_is_atwixp425()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB336
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB336
+# endif
+# define machine_is_csb336()	(machine_arch_type == MACH_TYPE_CSB336)
+#else
+# define machine_is_csb336()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIRM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIRM2
+# endif
+# define machine_is_rirm2()	(machine_arch_type == MACH_TYPE_RIRM2)
+#else
+# define machine_is_rirm2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CX23518
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CX23518
+# endif
+# define machine_is_cx23518()	(machine_arch_type == MACH_TYPE_CX23518)
+#else
+# define machine_is_cx23518()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CX2351X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CX2351X
+# endif
+# define machine_is_cx2351x()	(machine_arch_type == MACH_TYPE_CX2351X)
+#else
+# define machine_is_cx2351x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMPUTIME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMPUTIME
+# endif
+# define machine_is_computime()	(machine_arch_type == MACH_TYPE_COMPUTIME)
+#else
+# define machine_is_computime()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IZARUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IZARUS
+# endif
+# define machine_is_izarus()	(machine_arch_type == MACH_TYPE_IZARUS)
+#else
+# define machine_is_izarus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RTS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RTS
+# endif
+# define machine_is_pxa_rts()	(machine_arch_type == MACH_TYPE_RTS)
+#else
+# define machine_is_pxa_rts()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SE5100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SE5100
+# endif
+# define machine_is_se5100()	(machine_arch_type == MACH_TYPE_SE5100)
+#else
+# define machine_is_se5100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2510
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2510
+# endif
+# define machine_is_s3c2510()	(machine_arch_type == MACH_TYPE_S3C2510)
+#else
+# define machine_is_s3c2510()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB437TL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB437TL
+# endif
+# define machine_is_csb437tl()	(machine_arch_type == MACH_TYPE_CSB437TL)
+#else
+# define machine_is_csb437tl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SLAUSON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SLAUSON
+# endif
+# define machine_is_slauson()	(machine_arch_type == MACH_TYPE_SLAUSON)
+#else
+# define machine_is_slauson()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PEARLRIVER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PEARLRIVER
+# endif
+# define machine_is_pearlriver()	(machine_arch_type == MACH_TYPE_PEARLRIVER)
+#else
+# define machine_is_pearlriver()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TDC_P210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TDC_P210
+# endif
+# define machine_is_tdc_p210()	(machine_arch_type == MACH_TYPE_TDC_P210)
+#else
+# define machine_is_tdc_p210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG580
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG580
+# endif
+# define machine_is_sg580()	(machine_arch_type == MACH_TYPE_SG580)
+#else
+# define machine_is_sg580()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WRSBCARM7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WRSBCARM7
+# endif
+# define machine_is_wrsbcarm7()	(machine_arch_type == MACH_TYPE_WRSBCARM7)
+#else
+# define machine_is_wrsbcarm7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPD
+# endif
+# define machine_is_ipd()	(machine_arch_type == MACH_TYPE_IPD)
+#else
+# define machine_is_ipd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_DNP2110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_DNP2110
+# endif
+# define machine_is_pxa_dnp2110()	(machine_arch_type == MACH_TYPE_PXA_DNP2110)
+#else
+# define machine_is_pxa_dnp2110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XAENIAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XAENIAX
+# endif
+# define machine_is_xaeniax()	(machine_arch_type == MACH_TYPE_XAENIAX)
+#else
+# define machine_is_xaeniax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SOMN4250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SOMN4250
+# endif
+# define machine_is_somn4250()	(machine_arch_type == MACH_TYPE_SOMN4250)
+#else
+# define machine_is_somn4250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PLEB2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLEB2
+# endif
+# define machine_is_pleb2()	(machine_arch_type == MACH_TYPE_PLEB2)
+#else
+# define machine_is_pleb2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CORNWALLIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CORNWALLIS
+# endif
+# define machine_is_cornwallis()	(machine_arch_type == MACH_TYPE_CORNWALLIS)
+#else
+# define machine_is_cornwallis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GURNEY_DRV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GURNEY_DRV
+# endif
+# define machine_is_gurney_drv()	(machine_arch_type == MACH_TYPE_GURNEY_DRV)
+#else
+# define machine_is_gurney_drv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHAFFEE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHAFFEE
+# endif
+# define machine_is_chaffee()	(machine_arch_type == MACH_TYPE_CHAFFEE)
+#else
+# define machine_is_chaffee()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RMS101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RMS101
+# endif
+# define machine_is_rms101()	(machine_arch_type == MACH_TYPE_RMS101)
+#else
+# define machine_is_rms101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RX3715
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RX3715
+# endif
+# define machine_is_rx3715()	(machine_arch_type == MACH_TYPE_RX3715)
+#else
+# define machine_is_rx3715()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWIFT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWIFT
+# endif
+# define machine_is_swift()	(machine_arch_type == MACH_TYPE_SWIFT)
+#else
+# define machine_is_swift()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERP7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERP7
+# endif
+# define machine_is_roverp7()	(machine_arch_type == MACH_TYPE_ROVERP7)
+#else
+# define machine_is_roverp7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PR818S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PR818S
+# endif
+# define machine_is_pr818s()	(machine_arch_type == MACH_TYPE_PR818S)
+#else
+# define machine_is_pr818s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRXPRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRXPRO
+# endif
+# define machine_is_trxpro()	(machine_arch_type == MACH_TYPE_TRXPRO)
+#else
+# define machine_is_trxpro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSLU2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSLU2
+# endif
+# define machine_is_nslu2()	(machine_arch_type == MACH_TYPE_NSLU2)
+#else
+# define machine_is_nslu2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E400
+# endif
+# define machine_is_e400()	(machine_arch_type == MACH_TYPE_E400)
+#else
+# define machine_is_e400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRAB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRAB
+# endif
+# define machine_is_trab()	(machine_arch_type == MACH_TYPE_TRAB)
+#else
+# define machine_is_trab()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CMC_PU2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CMC_PU2
+# endif
+# define machine_is_cmc_pu2()	(machine_arch_type == MACH_TYPE_CMC_PU2)
+#else
+# define machine_is_cmc_pu2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FULCRUM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FULCRUM
+# endif
+# define machine_is_fulcrum()	(machine_arch_type == MACH_TYPE_FULCRUM)
+#else
+# define machine_is_fulcrum()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETGATE42X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETGATE42X
+# endif
+# define machine_is_netgate42x()	(machine_arch_type == MACH_TYPE_NETGATE42X)
+#else
+# define machine_is_netgate42x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STR710
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STR710
+# endif
+# define machine_is_str710()	(machine_arch_type == MACH_TYPE_STR710)
+#else
+# define machine_is_str710()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDPG425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDPG425
+# endif
+# define machine_is_ixdpg425()	(machine_arch_type == MACH_TYPE_IXDPG425)
+#else
+# define machine_is_ixdpg425()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOMTOMGO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOMTOMGO
+# endif
+# define machine_is_tomtomgo()	(machine_arch_type == MACH_TYPE_TOMTOMGO)
+#else
+# define machine_is_tomtomgo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VERSATILE_AB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERSATILE_AB
+# endif
+# define machine_is_versatile_ab()	(machine_arch_type == MACH_TYPE_VERSATILE_AB)
+#else
+# define machine_is_versatile_ab()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9307
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9307
+# endif
+# define machine_is_edb9307()	(machine_arch_type == MACH_TYPE_EDB9307)
+#else
+# define machine_is_edb9307()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG565
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG565
+# endif
+# define machine_is_sg565()	(machine_arch_type == MACH_TYPE_SG565)
+#else
+# define machine_is_sg565()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD79524
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD79524
+# endif
+# define machine_is_lpd79524()	(machine_arch_type == MACH_TYPE_LPD79524)
+#else
+# define machine_is_lpd79524()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD79525
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD79525
+# endif
+# define machine_is_lpd79525()	(machine_arch_type == MACH_TYPE_LPD79525)
+#else
+# define machine_is_lpd79525()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RMS100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RMS100
+# endif
+# define machine_is_rms100()	(machine_arch_type == MACH_TYPE_RMS100)
+#else
+# define machine_is_rms100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KB9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KB9200
+# endif
+# define machine_is_kb9200()	(machine_arch_type == MACH_TYPE_KB9200)
+#else
+# define machine_is_kb9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SX1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SX1
+# endif
+# define machine_is_sx1()	(machine_arch_type == MACH_TYPE_SX1)
+#else
+# define machine_is_sx1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HMS39C7092
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HMS39C7092
+# endif
+# define machine_is_hms39c7092()	(machine_arch_type == MACH_TYPE_HMS39C7092)
+#else
+# define machine_is_hms39c7092()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO
+# endif
+# define machine_is_armadillo()	(machine_arch_type == MACH_TYPE_ARMADILLO)
+#else
+# define machine_is_armadillo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPCU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPCU
+# endif
+# define machine_is_ipcu()	(machine_arch_type == MACH_TYPE_IPCU)
+#else
+# define machine_is_ipcu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOOX720
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOOX720
+# endif
+# define machine_is_loox720()	(machine_arch_type == MACH_TYPE_LOOX720)
+#else
+# define machine_is_loox720()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP465
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP465
+# endif
+# define machine_is_ixdp465()	(machine_arch_type == MACH_TYPE_IXDP465)
+#else
+# define machine_is_ixdp465()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP2351
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2351
+# endif
+# define machine_is_ixdp2351()	(machine_arch_type == MACH_TYPE_IXDP2351)
+#else
+# define machine_is_ixdp2351()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSVIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSVIX
+# endif
+# define machine_is_adsvix()	(machine_arch_type == MACH_TYPE_ADSVIX)
+#else
+# define machine_is_adsvix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM270
+# endif
+# define machine_is_dm270()	(machine_arch_type == MACH_TYPE_DM270)
+#else
+# define machine_is_dm270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SOCLTPLUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SOCLTPLUS
+# endif
+# define machine_is_socltplus()	(machine_arch_type == MACH_TYPE_SOCLTPLUS)
+#else
+# define machine_is_socltplus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECIA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECIA
+# endif
+# define machine_is_ecia()	(machine_arch_type == MACH_TYPE_ECIA)
+#else
+# define machine_is_ecia()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM4008
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM4008
+# endif
+# define machine_is_cm4008()	(machine_arch_type == MACH_TYPE_CM4008)
+#else
+# define machine_is_cm4008()	(0)
+#endif
+
+#ifdef CONFIG_MACH_P2001
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P2001
+# endif
+# define machine_is_p2001()	(machine_arch_type == MACH_TYPE_P2001)
+#else
+# define machine_is_p2001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TWISTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TWISTER
+# endif
+# define machine_is_twister()	(machine_arch_type == MACH_TYPE_TWISTER)
+#else
+# define machine_is_twister()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MUDSHARK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MUDSHARK
+# endif
+# define machine_is_mudshark()	(machine_arch_type == MACH_TYPE_MUDSHARK)
+#else
+# define machine_is_mudshark()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HB2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HB2
+# endif
+# define machine_is_hb2()	(machine_arch_type == MACH_TYPE_HB2)
+#else
+# define machine_is_hb2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ80332
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80332
+# endif
+# define machine_is_iq80332()	(machine_arch_type == MACH_TYPE_IQ80332)
+#else
+# define machine_is_iq80332()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SENDT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SENDT
+# endif
+# define machine_is_sendt()	(machine_arch_type == MACH_TYPE_SENDT)
+#else
+# define machine_is_sendt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX2JAZZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX2JAZZ
+# endif
+# define machine_is_mx2jazz()	(machine_arch_type == MACH_TYPE_MX2JAZZ)
+#else
+# define machine_is_mx2jazz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MULTIIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MULTIIO
+# endif
+# define machine_is_multiio()	(machine_arch_type == MACH_TYPE_MULTIIO)
+#else
+# define machine_is_multiio()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HRDISPLAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HRDISPLAY
+# endif
+# define machine_is_hrdisplay()	(machine_arch_type == MACH_TYPE_HRDISPLAY)
+#else
+# define machine_is_hrdisplay()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCMA11BB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCMA11BB
+# endif
+# define machine_is_scma11bb()	(machine_arch_type == MACH_TYPE_SCMA11BB)
+#else
+# define machine_is_scma11bb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIZEPS3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS3
+# endif
+# define machine_is_trizeps3()	(machine_arch_type == MACH_TYPE_TRIZEPS3)
+#else
+# define machine_is_trizeps3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEFEERDZA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEFEERDZA
+# endif
+# define machine_is_zefeerdza()	(machine_arch_type == MACH_TYPE_ZEFEERDZA)
+#else
+# define machine_is_zefeerdza()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEFEERDZB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEFEERDZB
+# endif
+# define machine_is_zefeerdzb()	(machine_arch_type == MACH_TYPE_ZEFEERDZB)
+#else
+# define machine_is_zefeerdzb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEFEERDZG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEFEERDZG
+# endif
+# define machine_is_zefeerdzg()	(machine_arch_type == MACH_TYPE_ZEFEERDZG)
+#else
+# define machine_is_zefeerdzg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEFEERDZN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEFEERDZN
+# endif
+# define machine_is_zefeerdzn()	(machine_arch_type == MACH_TYPE_ZEFEERDZN)
+#else
+# define machine_is_zefeerdzn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEFEERDZQ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEFEERDZQ
+# endif
+# define machine_is_zefeerdzq()	(machine_arch_type == MACH_TYPE_ZEFEERDZQ)
+#else
+# define machine_is_zefeerdzq()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GTWX5715
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GTWX5715
+# endif
+# define machine_is_gtwx5715()	(machine_arch_type == MACH_TYPE_GTWX5715)
+#else
+# define machine_is_gtwx5715()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASTRO_JACK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASTRO_JACK
+# endif
+# define machine_is_astro_jack()	(machine_arch_type == MACH_TYPE_ASTRO_JACK)
+#else
+# define machine_is_astro_jack()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TIP03
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TIP03
+# endif
+# define machine_is_tip03()	(machine_arch_type == MACH_TYPE_TIP03)
+#else
+# define machine_is_tip03()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9200EC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9200EC
+# endif
+# define machine_is_a9200ec()	(machine_arch_type == MACH_TYPE_A9200EC)
+#else
+# define machine_is_a9200ec()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX0105
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX0105
+# endif
+# define machine_is_pnx0105()	(machine_arch_type == MACH_TYPE_PNX0105)
+#else
+# define machine_is_pnx0105()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADCPOECPU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADCPOECPU
+# endif
+# define machine_is_adcpoecpu()	(machine_arch_type == MACH_TYPE_ADCPOECPU)
+#else
+# define machine_is_adcpoecpu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB637
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB637
+# endif
+# define machine_is_csb637()	(machine_arch_type == MACH_TYPE_CSB637)
+#else
+# define machine_is_csb637()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ML69Q6203
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ML69Q6203
+# endif
+# define machine_is_ml69q6203()	(machine_arch_type == MACH_TYPE_ML69Q6203)
+#else
+# define machine_is_ml69q6203()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB9200
+# endif
+# define machine_is_mb9200()	(machine_arch_type == MACH_TYPE_MB9200)
+#else
+# define machine_is_mb9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KULUN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KULUN
+# endif
+# define machine_is_kulun()	(machine_arch_type == MACH_TYPE_KULUN)
+#else
+# define machine_is_kulun()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPER
+# endif
+# define machine_is_snapper()	(machine_arch_type == MACH_TYPE_SNAPPER)
+#else
+# define machine_is_snapper()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPTIMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPTIMA
+# endif
+# define machine_is_optima()	(machine_arch_type == MACH_TYPE_OPTIMA)
+#else
+# define machine_is_optima()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DLHSBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DLHSBC
+# endif
+# define machine_is_dlhsbc()	(machine_arch_type == MACH_TYPE_DLHSBC)
+#else
+# define machine_is_dlhsbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_X30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_X30
+# endif
+# define machine_is_x30()	(machine_arch_type == MACH_TYPE_X30)
+#else
+# define machine_is_x30()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N30
+# endif
+# define machine_is_n30()	(machine_arch_type == MACH_TYPE_N30)
+#else
+# define machine_is_n30()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MANGA_KS8695
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MANGA_KS8695
+# endif
+# define machine_is_manga_ks8695()	(machine_arch_type == MACH_TYPE_MANGA_KS8695)
+#else
+# define machine_is_manga_ks8695()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AJAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AJAX
+# endif
+# define machine_is_ajax()	(machine_arch_type == MACH_TYPE_AJAX)
+#else
+# define machine_is_ajax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEC_MP900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEC_MP900
+# endif
+# define machine_is_nec_mp900()	(machine_arch_type == MACH_TYPE_NEC_MP900)
+#else
+# define machine_is_nec_mp900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVTK1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVTK1000
+# endif
+# define machine_is_vvtk1000()	(machine_arch_type == MACH_TYPE_VVTK1000)
+#else
+# define machine_is_vvtk1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KAFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KAFA
+# endif
+# define machine_is_kafa()	(machine_arch_type == MACH_TYPE_KAFA)
+#else
+# define machine_is_kafa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVTK3000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVTK3000
+# endif
+# define machine_is_vvtk3000()	(machine_arch_type == MACH_TYPE_VVTK3000)
+#else
+# define machine_is_vvtk3000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PIMX1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PIMX1
+# endif
+# define machine_is_pimx1()	(machine_arch_type == MACH_TYPE_PIMX1)
+#else
+# define machine_is_pimx1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OLLIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OLLIE
+# endif
+# define machine_is_ollie()	(machine_arch_type == MACH_TYPE_OLLIE)
+#else
+# define machine_is_ollie()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKYMAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKYMAX
+# endif
+# define machine_is_skymax()	(machine_arch_type == MACH_TYPE_SKYMAX)
+#else
+# define machine_is_skymax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JAZZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JAZZ
+# endif
+# define machine_is_jazz()	(machine_arch_type == MACH_TYPE_JAZZ)
+#else
+# define machine_is_jazz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEL_T3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEL_T3
+# endif
+# define machine_is_tel_t3()	(machine_arch_type == MACH_TYPE_TEL_T3)
+#else
+# define machine_is_tel_t3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AISINO_FCR255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AISINO_FCR255
+# endif
+# define machine_is_aisino_fcr255()	(machine_arch_type == MACH_TYPE_AISINO_FCR255)
+#else
+# define machine_is_aisino_fcr255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BTWEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BTWEB
+# endif
+# define machine_is_btweb()	(machine_arch_type == MACH_TYPE_BTWEB)
+#else
+# define machine_is_btweb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DBG_LH79520
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DBG_LH79520
+# endif
+# define machine_is_dbg_lh79520()	(machine_arch_type == MACH_TYPE_DBG_LH79520)
+#else
+# define machine_is_dbg_lh79520()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM41XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM41XX
+# endif
+# define machine_is_cm41xx()	(machine_arch_type == MACH_TYPE_CM41XX)
+#else
+# define machine_is_cm41xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS72XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS72XX
+# endif
+# define machine_is_ts72xx()	(machine_arch_type == MACH_TYPE_TS72XX)
+#else
+# define machine_is_ts72xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NGGPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NGGPXA
+# endif
+# define machine_is_nggpxa()	(machine_arch_type == MACH_TYPE_NGGPXA)
+#else
+# define machine_is_nggpxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB535
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB535
+# endif
+# define machine_is_csb535()	(machine_arch_type == MACH_TYPE_CSB535)
+#else
+# define machine_is_csb535()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB536
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB536
+# endif
+# define machine_is_csb536()	(machine_arch_type == MACH_TYPE_CSB536)
+#else
+# define machine_is_csb536()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_TRAKPOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_TRAKPOD
+# endif
+# define machine_is_pxa_trakpod()	(machine_arch_type == MACH_TYPE_PXA_TRAKPOD)
+#else
+# define machine_is_pxa_trakpod()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRAXIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRAXIS
+# endif
+# define machine_is_praxis()	(machine_arch_type == MACH_TYPE_PRAXIS)
+#else
+# define machine_is_praxis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LH75411
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LH75411
+# endif
+# define machine_is_lh75411()	(machine_arch_type == MACH_TYPE_LH75411)
+#else
+# define machine_is_lh75411()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OTOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OTOM
+# endif
+# define machine_is_otom()	(machine_arch_type == MACH_TYPE_OTOM)
+#else
+# define machine_is_otom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEXCODER_2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXCODER_2440
+# endif
+# define machine_is_nexcoder_2440()	(machine_arch_type == MACH_TYPE_NEXCODER_2440)
+#else
+# define machine_is_nexcoder_2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOOX410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOOX410
+# endif
+# define machine_is_loox410()	(machine_arch_type == MACH_TYPE_LOOX410)
+#else
+# define machine_is_loox410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WESTLAKE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WESTLAKE
+# endif
+# define machine_is_westlake()	(machine_arch_type == MACH_TYPE_WESTLAKE)
+#else
+# define machine_is_westlake()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSB
+# endif
+# define machine_is_nsb()	(machine_arch_type == MACH_TYPE_NSB)
+#else
+# define machine_is_nsb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_SARVA_STN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SARVA_STN
+# endif
+# define machine_is_esl_sarva_stn()	(machine_arch_type == MACH_TYPE_ESL_SARVA_STN)
+#else
+# define machine_is_esl_sarva_stn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_SARVA_TFT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SARVA_TFT
+# endif
+# define machine_is_esl_sarva_tft()	(machine_arch_type == MACH_TYPE_ESL_SARVA_TFT)
+#else
+# define machine_is_esl_sarva_tft()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_SARVA_IAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SARVA_IAD
+# endif
+# define machine_is_esl_sarva_iad()	(machine_arch_type == MACH_TYPE_ESL_SARVA_IAD)
+#else
+# define machine_is_esl_sarva_iad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_SARVA_ACC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SARVA_ACC
+# endif
+# define machine_is_esl_sarva_acc()	(machine_arch_type == MACH_TYPE_ESL_SARVA_ACC)
+#else
+# define machine_is_esl_sarva_acc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TYPHOON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TYPHOON
+# endif
+# define machine_is_typhoon()	(machine_arch_type == MACH_TYPE_TYPHOON)
+#else
+# define machine_is_typhoon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CNAV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CNAV
+# endif
+# define machine_is_cnav()	(machine_arch_type == MACH_TYPE_CNAV)
+#else
+# define machine_is_cnav()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A730
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A730
+# endif
+# define machine_is_a730()	(machine_arch_type == MACH_TYPE_A730)
+#else
+# define machine_is_a730()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETSTAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETSTAR
+# endif
+# define machine_is_netstar()	(machine_arch_type == MACH_TYPE_NETSTAR)
+#else
+# define machine_is_netstar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHASEFALE_SUPERCON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHASEFALE_SUPERCON
+# endif
+# define machine_is_supercon()	(machine_arch_type == MACH_TYPE_PHASEFALE_SUPERCON)
+#else
+# define machine_is_supercon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHIVA1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHIVA1100
+# endif
+# define machine_is_shiva1100()	(machine_arch_type == MACH_TYPE_SHIVA1100)
+#else
+# define machine_is_shiva1100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETEXSC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETEXSC
+# endif
+# define machine_is_etexsc()	(machine_arch_type == MACH_TYPE_ETEXSC)
+#else
+# define machine_is_etexsc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDPG465
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDPG465
+# endif
+# define machine_is_ixdpg465()	(machine_arch_type == MACH_TYPE_IXDPG465)
+#else
+# define machine_is_ixdpg465()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9M2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9M2410
+# endif
+# define machine_is_a9m2410()	(machine_arch_type == MACH_TYPE_A9M2410)
+#else
+# define machine_is_a9m2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9M2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9M2440
+# endif
+# define machine_is_a9m2440()	(machine_arch_type == MACH_TYPE_A9M2440)
+#else
+# define machine_is_a9m2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9M9750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9M9750
+# endif
+# define machine_is_a9m9750()	(machine_arch_type == MACH_TYPE_A9M9750)
+#else
+# define machine_is_a9m9750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9M9360
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9M9360
+# endif
+# define machine_is_a9m9360()	(machine_arch_type == MACH_TYPE_A9M9360)
+#else
+# define machine_is_a9m9360()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNC90
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNC90
+# endif
+# define machine_is_unc90()	(machine_arch_type == MACH_TYPE_UNC90)
+#else
+# define machine_is_unc90()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECO920
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECO920
+# endif
+# define machine_is_eco920()	(machine_arch_type == MACH_TYPE_ECO920)
+#else
+# define machine_is_eco920()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SATVIEW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SATVIEW
+# endif
+# define machine_is_satview()	(machine_arch_type == MACH_TYPE_SATVIEW)
+#else
+# define machine_is_satview()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROADRUNNER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROADRUNNER
+# endif
+# define machine_is_roadrunner()	(machine_arch_type == MACH_TYPE_ROADRUNNER)
+#else
+# define machine_is_roadrunner()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200EK
+# endif
+# define machine_is_at91rm9200ek()	(machine_arch_type == MACH_TYPE_AT91RM9200EK)
+#else
+# define machine_is_at91rm9200ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GP32
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GP32
+# endif
+# define machine_is_gp32()	(machine_arch_type == MACH_TYPE_GP32)
+#else
+# define machine_is_gp32()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GEM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GEM
+# endif
+# define machine_is_gem()	(machine_arch_type == MACH_TYPE_GEM)
+#else
+# define machine_is_gem()	(0)
+#endif
+
+#ifdef CONFIG_MACH_I858
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I858
+# endif
+# define machine_is_i858()	(machine_arch_type == MACH_TYPE_I858)
+#else
+# define machine_is_i858()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HX2750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HX2750
+# endif
+# define machine_is_hx2750()	(machine_arch_type == MACH_TYPE_HX2750)
+#else
+# define machine_is_hx2750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEUSEVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEUSEVB
+# endif
+# define machine_is_zeusevb()	(machine_arch_type == MACH_TYPE_ZEUSEVB)
+#else
+# define machine_is_zeusevb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_P700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P700
+# endif
+# define machine_is_p700()	(machine_arch_type == MACH_TYPE_P700)
+#else
+# define machine_is_p700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPE
+# endif
+# define machine_is_cpe()	(machine_arch_type == MACH_TYPE_CPE)
+#else
+# define machine_is_cpe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPITZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPITZ
+# endif
+# define machine_is_spitz()	(machine_arch_type == MACH_TYPE_SPITZ)
+#else
+# define machine_is_spitz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NIMBRA340
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIMBRA340
+# endif
+# define machine_is_nimbra340()	(machine_arch_type == MACH_TYPE_NIMBRA340)
+#else
+# define machine_is_nimbra340()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPC22XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPC22XX
+# endif
+# define machine_is_lpc22xx()	(machine_arch_type == MACH_TYPE_LPC22XX)
+#else
+# define machine_is_lpc22xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMET3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMET3
+# endif
+# define machine_is_omap_comet3()	(machine_arch_type == MACH_TYPE_COMET3)
+#else
+# define machine_is_omap_comet3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMET4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMET4
+# endif
+# define machine_is_omap_comet4()	(machine_arch_type == MACH_TYPE_COMET4)
+#else
+# define machine_is_omap_comet4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB625
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB625
+# endif
+# define machine_is_csb625()	(machine_arch_type == MACH_TYPE_CSB625)
+#else
+# define machine_is_csb625()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FORTUNET2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FORTUNET2
+# endif
+# define machine_is_fortunet2()	(machine_arch_type == MACH_TYPE_FORTUNET2)
+#else
+# define machine_is_fortunet2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S5H2200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5H2200
+# endif
+# define machine_is_s5h2200()	(machine_arch_type == MACH_TYPE_S5H2200)
+#else
+# define machine_is_s5h2200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPTORM920
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPTORM920
+# endif
+# define machine_is_optorm920()	(machine_arch_type == MACH_TYPE_OPTORM920)
+#else
+# define machine_is_optorm920()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSBITSYXB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSYXB
+# endif
+# define machine_is_adsbitsyxb()	(machine_arch_type == MACH_TYPE_ADSBITSYXB)
+#else
+# define machine_is_adsbitsyxb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSSPHERE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSSPHERE
+# endif
+# define machine_is_adssphere()	(machine_arch_type == MACH_TYPE_ADSSPHERE)
+#else
+# define machine_is_adssphere()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSPORTAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSPORTAL
+# endif
+# define machine_is_adsportal()	(machine_arch_type == MACH_TYPE_ADSPORTAL)
+#else
+# define machine_is_adsportal()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LN2410SBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LN2410SBC
+# endif
+# define machine_is_ln2410sbc()	(machine_arch_type == MACH_TYPE_LN2410SBC)
+#else
+# define machine_is_ln2410sbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CB3RUFC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CB3RUFC
+# endif
+# define machine_is_cb3rufc()	(machine_arch_type == MACH_TYPE_CB3RUFC)
+#else
+# define machine_is_cb3rufc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MP2USB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MP2USB
+# endif
+# define machine_is_mp2usb()	(machine_arch_type == MACH_TYPE_MP2USB)
+#else
+# define machine_is_mp2usb()	(0)
+#endif
+
+/*
+ * These have not yet been registered
+ */
+/* #define MACH_TYPE_367                  <<not registered>> */
+#define machine_is_esl_wireless_tab()	(0)
+
+#ifndef machine_arch_type
+#define machine_arch_type	__machine_arch_type
+#endif
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/memory.h u-boot-1.2.0-leopard/include/asm/memory.h
--- u-boot-1.2.0/include/asm/memory.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/memory.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,137 @@
+/*
+ *  linux/include/asm-arm/memory.h
+ *
+ *  Copyright (C) 2000-2002 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Note: this file should not be included by non-asm/.h files
+ */
+#ifndef __ASM_ARM_MEMORY_H
+#define __ASM_ARM_MEMORY_H
+
+#if 0	/* XXX###XXX */
+
+#include <linux/config.h>
+#include <asm/arch/memory.h>
+
+/*
+ * PFNs are used to describe any physical page; this means
+ * PFN 0 == physical address 0.
+ *
+ * This is the PFN of the first RAM page in the kernel
+ * direct-mapped view.  We assume this is the first page
+ * of RAM in the mem_map as well.
+ */
+#define PHYS_PFN_OFFSET	(PHYS_OFFSET >> PAGE_SHIFT)
+
+/*
+ * These are *only* valid on the kernel direct mapped RAM memory.
+ */
+static inline unsigned long virt_to_phys(void *x)
+{
+	return __virt_to_phys((unsigned long)(x));
+}
+
+static inline void *phys_to_virt(unsigned long x)
+{
+	return (void *)(__phys_to_virt((unsigned long)(x)));
+}
+
+#define __pa(x)			__virt_to_phys((unsigned long)(x))
+#define __va(x)			((void *)__phys_to_virt((unsigned long)(x)))
+
+/*
+ * Virtual <-> DMA view memory address translations
+ * Again, these are *only* valid on the kernel direct mapped RAM
+ * memory.  Use of these is *depreciated*.
+ */
+#define virt_to_bus(x)		(__virt_to_bus((unsigned long)(x)))
+#define bus_to_virt(x)		((void *)(__bus_to_virt((unsigned long)(x))))
+
+/*
+ * Conversion between a struct page and a physical address.
+ *
+ * Note: when converting an unknown physical address to a
+ * struct page, the resulting pointer must be validated
+ * using VALID_PAGE().  It must return an invalid struct page
+ * for any physical address not corresponding to a system
+ * RAM address.
+ *
+ *  page_to_pfn(page)	convert a struct page * to a PFN number
+ *  pfn_to_page(pfn)	convert a _valid_ PFN number to struct page *
+ *  pfn_valid(pfn)	indicates whether a PFN number is valid
+ *
+ *  virt_to_page(k)	convert a _valid_ virtual address to struct page *
+ *  virt_addr_valid(k)	indicates whether a virtual address is valid
+ */
+#ifndef CONFIG_DISCONTIGMEM
+
+#define page_to_pfn(page)	(((page) - mem_map) + PHYS_PFN_OFFSET)
+#define pfn_to_page(pfn)	((mem_map + (pfn)) - PHYS_PFN_OFFSET)
+#define pfn_valid(pfn)		((pfn) >= PHYS_PFN_OFFSET && (pfn) < (PHYS_PFN_OFFSET + max_mapnr))
+
+#define virt_to_page(kaddr)	(pfn_to_page(__pa(kaddr) >> PAGE_SHIFT))
+#define virt_addr_valid(kaddr)	((kaddr) >= PAGE_OFFSET && (kaddr) < (unsigned long)high_memory)
+
+#define PHYS_TO_NID(addr)	(0)
+
+#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
+
+#else
+
+/*
+ * This is more complex.  We have a set of mem_map arrays spread
+ * around in memory.
+ */
+#define page_to_pfn(page)					\
+	(((page) - page_zone(page)->zone_mem_map)		\
+	  + (page_zone(page)->zone_start_paddr >> PAGE_SHIFT))
+
+#define pfn_to_page(pfn)					\
+	(PFN_TO_MAPBASE(pfn) + LOCAL_MAP_NR((pfn) << PAGE_SHIFT))
+
+#define pfn_valid(pfn)						\
+  ({								\
+	unsigned int node = PFN_TO_NID(pfn);			\
+	struct pglist_data *nd = NODE_DATA(node);		\
+	((node < NR_NODES) &&					\
+	 ((pfn - (nd->node_start_paddr >> PAGE_SHIFT)) < nd->node_size));\
+   })
+
+#define virt_to_page(kaddr)					\
+	(ADDR_TO_MAPBASE(kaddr) + LOCAL_MAP_NR(kaddr))
+
+#define virt_addr_valid(kaddr)	(KVADDR_TO_NID(kaddr) < NR_NODES)
+
+/*
+ * Common discontigmem stuff.
+ *  PHYS_TO_NID is used by the ARM kernel/setup.c
+ */
+#define PHYS_TO_NID(addr)	PFN_TO_NID((addr) >> PAGE_SHIFT)
+
+/*
+ * 2.4 compatibility
+ *
+ * VALID_PAGE returns a non-zero value if given page pointer is valid.
+ * This assumes all node's mem_maps are stored within the node they
+ * refer to.  This is actually inherently buggy.
+ */
+#define VALID_PAGE(page) \
+({ unsigned int node = KVADDR_TO_NID(page); \
+   ((node < NR_NODES) && \
+     ((unsigned)((page) - NODE_MEM_MAP(node)) < NODE_DATA(node)->node_size)); \
+})
+
+#endif
+
+/*
+ * We should really eliminate virt_to_bus() here - it's depreciated.
+ */
+#define page_to_bus(page)	(virt_to_bus(page_address(page)))
+
+#endif	/* XXX###XXX */
+
+#endif	/* __ASM_ARM_MEMORY_H */
diff -Nurd u-boot-1.2.0/include/asm/posix_types.h u-boot-1.2.0-leopard/include/asm/posix_types.h
--- u-boot-1.2.0/include/asm/posix_types.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/posix_types.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,79 @@
+/*
+ *  linux/include/asm-arm/posix_types.h
+ *
+ *  Copyright (C) 1996-1998 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Changelog:
+ *   27-06-1996	RMK	Created
+ */
+#ifndef __ARCH_ARM_POSIX_TYPES_H
+#define __ARCH_ARM_POSIX_TYPES_H
+
+/*
+ * This file is generally used by user-level software, so you need to
+ * be a little careful about namespace pollution etc.  Also, we cannot
+ * assume GCC is being used.
+ */
+
+typedef unsigned short		__kernel_dev_t;
+typedef unsigned long		__kernel_ino_t;
+typedef unsigned short		__kernel_mode_t;
+typedef unsigned short		__kernel_nlink_t;
+typedef long			__kernel_off_t;
+typedef int			__kernel_pid_t;
+typedef unsigned short		__kernel_ipc_pid_t;
+typedef unsigned short		__kernel_uid_t;
+typedef unsigned short		__kernel_gid_t;
+typedef unsigned int		__kernel_size_t;
+typedef int			__kernel_ssize_t;
+typedef int			__kernel_ptrdiff_t;
+typedef long			__kernel_time_t;
+typedef long			__kernel_suseconds_t;
+typedef long			__kernel_clock_t;
+typedef int			__kernel_daddr_t;
+typedef char *			__kernel_caddr_t;
+typedef unsigned short		__kernel_uid16_t;
+typedef unsigned short		__kernel_gid16_t;
+typedef unsigned int		__kernel_uid32_t;
+typedef unsigned int		__kernel_gid32_t;
+
+typedef unsigned short		__kernel_old_uid_t;
+typedef unsigned short		__kernel_old_gid_t;
+
+#ifdef __GNUC__
+typedef long long		__kernel_loff_t;
+#endif
+
+typedef struct {
+#if defined(__KERNEL__) || defined(__USE_ALL)
+	int	val[2];
+#else /* !defined(__KERNEL__) && !defined(__USE_ALL) */
+	int	__val[2];
+#endif /* !defined(__KERNEL__) && !defined(__USE_ALL) */
+} __kernel_fsid_t;
+
+#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)
+
+#undef	__FD_SET
+#define __FD_SET(fd, fdsetp) \
+		(((fd_set *)fdsetp)->fds_bits[fd >> 5] |= (1<<(fd & 31)))
+
+#undef	__FD_CLR
+#define __FD_CLR(fd, fdsetp) \
+		(((fd_set *)fdsetp)->fds_bits[fd >> 5] &= ~(1<<(fd & 31)))
+
+#undef	__FD_ISSET
+#define __FD_ISSET(fd, fdsetp) \
+		((((fd_set *)fdsetp)->fds_bits[fd >> 5] & (1<<(fd & 31))) != 0)
+
+#undef	__FD_ZERO
+#define __FD_ZERO(fdsetp) \
+		(memset (fdsetp, 0, sizeof (*(fd_set *)fdsetp)))
+
+#endif
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/proc/domain.h u-boot-1.2.0-leopard/include/asm/proc/domain.h
--- u-boot-1.2.0/include/asm/proc/domain.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/proc/domain.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,50 @@
+/*
+ *  linux/include/asm-arm/proc-armv/domain.h
+ *
+ *  Copyright (C) 1999 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_PROC_DOMAIN_H
+#define __ASM_PROC_DOMAIN_H
+
+/*
+ * Domain numbers
+ *
+ *  DOMAIN_IO     - domain 2 includes all IO only
+ *  DOMAIN_KERNEL - domain 1 includes all kernel memory only
+ *  DOMAIN_USER   - domain 0 includes all user memory only
+ */
+#define DOMAIN_USER	0
+#define DOMAIN_KERNEL	1
+#define DOMAIN_TABLE	1
+#define DOMAIN_IO	2
+
+/*
+ * Domain types
+ */
+#define DOMAIN_NOACCESS	0
+#define DOMAIN_CLIENT	1
+#define DOMAIN_MANAGER	3
+
+#define domain_val(dom,type)	((type) << 2*(dom))
+
+#define set_domain(x)					\
+	do {						\
+	__asm__ __volatile__(				\
+	"mcr	p15, 0, %0, c3, c0	@ set domain"	\
+	  : : "r" (x));					\
+	} while (0)
+
+#define modify_domain(dom,type)				\
+	do {						\
+	unsigned int domain = current->thread.domain;	\
+	domain &= ~domain_val(dom, DOMAIN_MANAGER);	\
+	domain |= domain_val(dom, type);		\
+	current->thread.domain = domain;		\
+	set_domain(current->thread.domain);		\
+	} while (0)
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/proc/processor.h u-boot-1.2.0-leopard/include/asm/proc/processor.h
--- u-boot-1.2.0/include/asm/proc/processor.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/proc/processor.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,74 @@
+/*
+ *  linux/include/asm-arm/proc-armv/processor.h
+ *
+ *  Copyright (C) 1996-1999 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Changelog:
+ *   20-09-1996	RMK	Created
+ *   26-09-1996	RMK	Added 'EXTRA_THREAD_STRUCT*'
+ *   28-09-1996	RMK	Moved start_thread into the processor dependencies
+ *   09-09-1998	PJB	Delete redundant `wp_works_ok'
+ *   30-05-1999	PJB	Save sl across context switches
+ *   31-07-1999	RMK	Added 'domain' stuff
+ */
+#ifndef __ASM_PROC_PROCESSOR_H
+#define __ASM_PROC_PROCESSOR_H
+
+#include <asm/proc/domain.h>
+
+#define KERNEL_STACK_SIZE	PAGE_SIZE
+
+struct context_save_struct {
+	unsigned long cpsr;
+	unsigned long r4;
+	unsigned long r5;
+	unsigned long r6;
+	unsigned long r7;
+	unsigned long r8;
+	unsigned long r9;
+	unsigned long sl;
+	unsigned long fp;
+	unsigned long pc;
+};
+
+#define INIT_CSS (struct context_save_struct){ SVC_MODE, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
+
+#define EXTRA_THREAD_STRUCT						\
+	unsigned int	domain;
+
+#define EXTRA_THREAD_STRUCT_INIT					\
+	domain:	  domain_val(DOMAIN_USER, DOMAIN_CLIENT) |		\
+		  domain_val(DOMAIN_KERNEL, DOMAIN_MANAGER) |		\
+		  domain_val(DOMAIN_IO, DOMAIN_CLIENT)
+
+#define start_thread(regs,pc,sp)					\
+({									\
+	unsigned long *stack = (unsigned long *)sp;			\
+	set_fs(USER_DS);						\
+	memzero(regs->uregs, sizeof(regs->uregs));			\
+	if (current->personality & ADDR_LIMIT_32BIT)			\
+		regs->ARM_cpsr = USR_MODE;				\
+	else								\
+		regs->ARM_cpsr = USR26_MODE;				\
+	regs->ARM_pc = pc;		/* pc */			\
+	regs->ARM_sp = sp;		/* sp */			\
+	regs->ARM_r2 = stack[2];	/* r2 (envp) */			\
+	regs->ARM_r1 = stack[1];	/* r1 (argv) */			\
+	regs->ARM_r0 = stack[0];	/* r0 (argc) */			\
+})
+
+#define KSTK_EIP(tsk)	(((unsigned long *)(4096+(unsigned long)(tsk)))[1019])
+#define KSTK_ESP(tsk)	(((unsigned long *)(4096+(unsigned long)(tsk)))[1017])
+
+/* Allocation and freeing of basic task resources. */
+/*
+ * NOTE! The task struct and the stack go together
+ */
+#define ll_alloc_task_struct() ((struct task_struct *) __get_free_pages(GFP_KERNEL,1))
+#define ll_free_task_struct(p) free_pages((unsigned long)(p),1)
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/proc/ptrace.h u-boot-1.2.0-leopard/include/asm/proc/ptrace.h
--- u-boot-1.2.0/include/asm/proc/ptrace.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/proc/ptrace.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,109 @@
+/*
+ *  linux/include/asm-arm/proc-armv/ptrace.h
+ *
+ *  Copyright (C) 1996-1999 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_PROC_PTRACE_H
+#define __ASM_PROC_PTRACE_H
+
+#include <linux/config.h>
+
+#define USR26_MODE	0x00
+#define FIQ26_MODE	0x01
+#define IRQ26_MODE	0x02
+#define SVC26_MODE	0x03
+#define USR_MODE	0x10
+#define FIQ_MODE	0x11
+#define IRQ_MODE	0x12
+#define SVC_MODE	0x13
+#define ABT_MODE	0x17
+#define UND_MODE	0x1b
+#define SYSTEM_MODE	0x1f
+#define MODE_MASK	0x1f
+#define T_BIT		0x20
+#define F_BIT		0x40
+#define I_BIT		0x80
+#define CC_V_BIT	(1 << 28)
+#define CC_C_BIT	(1 << 29)
+#define CC_Z_BIT	(1 << 30)
+#define CC_N_BIT	(1 << 31)
+#define PCMASK		0
+
+#ifndef __ASSEMBLY__
+
+/* this struct defines the way the registers are stored on the
+   stack during a system call. */
+
+struct pt_regs {
+	long uregs[18];
+};
+
+#define ARM_cpsr	uregs[16]
+#define ARM_pc		uregs[15]
+#define ARM_lr		uregs[14]
+#define ARM_sp		uregs[13]
+#define ARM_ip		uregs[12]
+#define ARM_fp		uregs[11]
+#define ARM_r10		uregs[10]
+#define ARM_r9		uregs[9]
+#define ARM_r8		uregs[8]
+#define ARM_r7		uregs[7]
+#define ARM_r6		uregs[6]
+#define ARM_r5		uregs[5]
+#define ARM_r4		uregs[4]
+#define ARM_r3		uregs[3]
+#define ARM_r2		uregs[2]
+#define ARM_r1		uregs[1]
+#define ARM_r0		uregs[0]
+#define ARM_ORIG_r0	uregs[17]
+
+#ifdef __KERNEL__
+
+#define user_mode(regs)	\
+	(((regs)->ARM_cpsr & 0xf) == 0)
+
+#ifdef CONFIG_ARM_THUMB
+#define thumb_mode(regs) \
+	(((regs)->ARM_cpsr & T_BIT))
+#else
+#define thumb_mode(regs) (0)
+#endif
+
+#define processor_mode(regs) \
+	((regs)->ARM_cpsr & MODE_MASK)
+
+#define interrupts_enabled(regs) \
+	(!((regs)->ARM_cpsr & I_BIT))
+
+#define fast_interrupts_enabled(regs) \
+	(!((regs)->ARM_cpsr & F_BIT))
+
+#define condition_codes(regs) \
+	((regs)->ARM_cpsr & (CC_V_BIT|CC_C_BIT|CC_Z_BIT|CC_N_BIT))
+
+/* Are the current registers suitable for user mode?
+ * (used to maintain security in signal handlers)
+ */
+static inline int valid_user_regs(struct pt_regs *regs)
+{
+	if ((regs->ARM_cpsr & 0xf) == 0 &&
+	    (regs->ARM_cpsr & (F_BIT|I_BIT)) == 0)
+		return 1;
+
+	/*
+	 * Force CPSR to something logical...
+	 */
+	regs->ARM_cpsr &= (CC_V_BIT|CC_C_BIT|CC_Z_BIT|CC_N_BIT|0x10);
+
+	return 0;
+}
+
+#endif	/* __KERNEL__ */
+
+#endif	/* __ASSEMBLY__ */
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/proc/system.h u-boot-1.2.0-leopard/include/asm/proc/system.h
--- u-boot-1.2.0/include/asm/proc/system.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/proc/system.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,199 @@
+/*
+ *  linux/include/asm-arm/proc-armv/system.h
+ *
+ *  Copyright (C) 1996 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_PROC_SYSTEM_H
+#define __ASM_PROC_SYSTEM_H
+
+#include <linux/config.h>
+
+#define set_cr(x)					\
+	__asm__ __volatile__(				\
+	"mcr	p15, 0, %0, c1, c0	@ set CR"	\
+	: : "r" (x))
+
+#define CR_M	(1 << 0)	/* MMU enable				*/
+#define CR_A	(1 << 1)	/* Alignment abort enable		*/
+#define CR_C	(1 << 2)	/* Dcache enable			*/
+#define CR_W	(1 << 3)	/* Write buffer enable			*/
+#define CR_P	(1 << 4)	/* 32-bit exception handler		*/
+#define CR_D	(1 << 5)	/* 32-bit data address range		*/
+#define CR_L	(1 << 6)	/* Implementation defined		*/
+#define CD_B	(1 << 7)	/* Big endian				*/
+#define CR_S	(1 << 8)	/* System MMU protection		*/
+#define CD_R	(1 << 9)	/* ROM MMU protection			*/
+#define CR_F	(1 << 10)	/* Implementation defined		*/
+#define CR_Z	(1 << 11)	/* Implementation defined		*/
+#define CR_I	(1 << 12)	/* Icache enable			*/
+#define CR_V	(1 << 13)	/* Vectors relocated to 0xffff0000	*/
+#define CR_RR	(1 << 14)	/* Round Robin cache replacement	*/
+
+extern unsigned long cr_no_alignment;	/* defined in entry-armv.S */
+extern unsigned long cr_alignment;	/* defined in entry-armv.S */
+
+#if __LINUX_ARM_ARCH__ >= 4
+#define vectors_base()	((cr_alignment & CR_V) ? 0xffff0000 : 0)
+#else
+#define vectors_base()	(0)
+#endif
+
+/*
+ * Save the current interrupt enable state & disable IRQs
+ */
+#define local_irq_save(x)					\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_irq_save\n"	\
+"	orr	%1, %0, #128\n"					\
+"	msr	cpsr_c, %1"					\
+	: "=r" (x), "=r" (temp)					\
+	:							\
+	: "memory");						\
+	})
+
+/*
+ * Enable IRQs
+ */
+#define local_irq_enable()					\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_irq_enable\n"	\
+"	bic	%0, %0, #128\n"					\
+"	msr	cpsr_c, %0"					\
+	: "=r" (temp)						\
+	:							\
+	: "memory");						\
+	})
+
+/*
+ * Disable IRQs
+ */
+#define local_irq_disable()					\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_irq_disable\n"	\
+"	orr	%0, %0, #128\n"					\
+"	msr	cpsr_c, %0"					\
+	: "=r" (temp)						\
+	:							\
+	: "memory");						\
+	})
+
+/*
+ * Enable FIQs
+ */
+#define __stf()							\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ stf\n"		\
+"	bic	%0, %0, #64\n"					\
+"	msr	cpsr_c, %0"					\
+	: "=r" (temp)						\
+	:							\
+	: "memory");						\
+	})
+
+/*
+ * Disable FIQs
+ */
+#define __clf()							\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ clf\n"		\
+"	orr	%0, %0, #64\n"					\
+"	msr	cpsr_c, %0"					\
+	: "=r" (temp)						\
+	:							\
+	: "memory");						\
+	})
+
+/*
+ * Save the current interrupt enable state.
+ */
+#define local_save_flags(x)					\
+	({							\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_save_flags\n"	\
+	  : "=r" (x)						\
+	  :							\
+	  : "memory");						\
+	})
+
+/*
+ * restore saved IRQ & FIQ state
+ */
+#define local_irq_restore(x)					\
+	__asm__ __volatile__(					\
+	"msr	cpsr_c, %0		@ local_irq_restore\n"	\
+	:							\
+	: "r" (x)						\
+	: "memory")
+
+#if defined(CONFIG_CPU_SA1100) || defined(CONFIG_CPU_SA110)
+/*
+ * On the StrongARM, "swp" is terminally broken since it bypasses the
+ * cache totally.  This means that the cache becomes inconsistent, and,
+ * since we use normal loads/stores as well, this is really bad.
+ * Typically, this causes oopsen in filp_close, but could have other,
+ * more disasterous effects.  There are two work-arounds:
+ *  1. Disable interrupts and emulate the atomic swap
+ *  2. Clean the cache, perform atomic swap, flush the cache
+ *
+ * We choose (1) since its the "easiest" to achieve here and is not
+ * dependent on the processor type.
+ */
+#define swp_is_buggy
+#endif
+
+static inline unsigned long __xchg(unsigned long x, volatile void *ptr, int size)
+{
+	extern void __bad_xchg(volatile void *, int);
+	unsigned long ret;
+#ifdef swp_is_buggy
+	unsigned long flags;
+#endif
+
+	switch (size) {
+#ifdef swp_is_buggy
+		case 1:
+			local_irq_save(flags);
+			ret = *(volatile unsigned char *)ptr;
+			*(volatile unsigned char *)ptr = x;
+			local_irq_restore(flags);
+			break;
+
+		case 4:
+			local_irq_save(flags);
+			ret = *(volatile unsigned long *)ptr;
+			*(volatile unsigned long *)ptr = x;
+			local_irq_restore(flags);
+			break;
+#else
+		case 1:	__asm__ __volatile__ ("swpb %0, %1, [%2]"
+					: "=&r" (ret)
+					: "r" (x), "r" (ptr)
+					: "memory");
+			break;
+		case 4:	__asm__ __volatile__ ("swp %0, %1, [%2]"
+					: "=&r" (ret)
+					: "r" (x), "r" (ptr)
+					: "memory");
+			break;
+#endif
+		default: __bad_xchg(ptr, size), ret = 0;
+	}
+
+	return ret;
+}
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/proc-armv/domain.h u-boot-1.2.0-leopard/include/asm/proc-armv/domain.h
--- u-boot-1.2.0/include/asm/proc-armv/domain.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/proc-armv/domain.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,50 @@
+/*
+ *  linux/include/asm-arm/proc-armv/domain.h
+ *
+ *  Copyright (C) 1999 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_PROC_DOMAIN_H
+#define __ASM_PROC_DOMAIN_H
+
+/*
+ * Domain numbers
+ *
+ *  DOMAIN_IO     - domain 2 includes all IO only
+ *  DOMAIN_KERNEL - domain 1 includes all kernel memory only
+ *  DOMAIN_USER   - domain 0 includes all user memory only
+ */
+#define DOMAIN_USER	0
+#define DOMAIN_KERNEL	1
+#define DOMAIN_TABLE	1
+#define DOMAIN_IO	2
+
+/*
+ * Domain types
+ */
+#define DOMAIN_NOACCESS	0
+#define DOMAIN_CLIENT	1
+#define DOMAIN_MANAGER	3
+
+#define domain_val(dom,type)	((type) << 2*(dom))
+
+#define set_domain(x)					\
+	do {						\
+	__asm__ __volatile__(				\
+	"mcr	p15, 0, %0, c3, c0	@ set domain"	\
+	  : : "r" (x));					\
+	} while (0)
+
+#define modify_domain(dom,type)				\
+	do {						\
+	unsigned int domain = current->thread.domain;	\
+	domain &= ~domain_val(dom, DOMAIN_MANAGER);	\
+	domain |= domain_val(dom, type);		\
+	current->thread.domain = domain;		\
+	set_domain(current->thread.domain);		\
+	} while (0)
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/proc-armv/processor.h u-boot-1.2.0-leopard/include/asm/proc-armv/processor.h
--- u-boot-1.2.0/include/asm/proc-armv/processor.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/proc-armv/processor.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,74 @@
+/*
+ *  linux/include/asm-arm/proc-armv/processor.h
+ *
+ *  Copyright (C) 1996-1999 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Changelog:
+ *   20-09-1996	RMK	Created
+ *   26-09-1996	RMK	Added 'EXTRA_THREAD_STRUCT*'
+ *   28-09-1996	RMK	Moved start_thread into the processor dependencies
+ *   09-09-1998	PJB	Delete redundant `wp_works_ok'
+ *   30-05-1999	PJB	Save sl across context switches
+ *   31-07-1999	RMK	Added 'domain' stuff
+ */
+#ifndef __ASM_PROC_PROCESSOR_H
+#define __ASM_PROC_PROCESSOR_H
+
+#include <asm/proc/domain.h>
+
+#define KERNEL_STACK_SIZE	PAGE_SIZE
+
+struct context_save_struct {
+	unsigned long cpsr;
+	unsigned long r4;
+	unsigned long r5;
+	unsigned long r6;
+	unsigned long r7;
+	unsigned long r8;
+	unsigned long r9;
+	unsigned long sl;
+	unsigned long fp;
+	unsigned long pc;
+};
+
+#define INIT_CSS (struct context_save_struct){ SVC_MODE, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
+
+#define EXTRA_THREAD_STRUCT						\
+	unsigned int	domain;
+
+#define EXTRA_THREAD_STRUCT_INIT					\
+	domain:	  domain_val(DOMAIN_USER, DOMAIN_CLIENT) |		\
+		  domain_val(DOMAIN_KERNEL, DOMAIN_MANAGER) |		\
+		  domain_val(DOMAIN_IO, DOMAIN_CLIENT)
+
+#define start_thread(regs,pc,sp)					\
+({									\
+	unsigned long *stack = (unsigned long *)sp;			\
+	set_fs(USER_DS);						\
+	memzero(regs->uregs, sizeof(regs->uregs));			\
+	if (current->personality & ADDR_LIMIT_32BIT)			\
+		regs->ARM_cpsr = USR_MODE;				\
+	else								\
+		regs->ARM_cpsr = USR26_MODE;				\
+	regs->ARM_pc = pc;		/* pc */			\
+	regs->ARM_sp = sp;		/* sp */			\
+	regs->ARM_r2 = stack[2];	/* r2 (envp) */			\
+	regs->ARM_r1 = stack[1];	/* r1 (argv) */			\
+	regs->ARM_r0 = stack[0];	/* r0 (argc) */			\
+})
+
+#define KSTK_EIP(tsk)	(((unsigned long *)(4096+(unsigned long)(tsk)))[1019])
+#define KSTK_ESP(tsk)	(((unsigned long *)(4096+(unsigned long)(tsk)))[1017])
+
+/* Allocation and freeing of basic task resources. */
+/*
+ * NOTE! The task struct and the stack go together
+ */
+#define ll_alloc_task_struct() ((struct task_struct *) __get_free_pages(GFP_KERNEL,1))
+#define ll_free_task_struct(p) free_pages((unsigned long)(p),1)
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/proc-armv/ptrace.h u-boot-1.2.0-leopard/include/asm/proc-armv/ptrace.h
--- u-boot-1.2.0/include/asm/proc-armv/ptrace.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/proc-armv/ptrace.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,109 @@
+/*
+ *  linux/include/asm-arm/proc-armv/ptrace.h
+ *
+ *  Copyright (C) 1996-1999 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_PROC_PTRACE_H
+#define __ASM_PROC_PTRACE_H
+
+#include <linux/config.h>
+
+#define USR26_MODE	0x00
+#define FIQ26_MODE	0x01
+#define IRQ26_MODE	0x02
+#define SVC26_MODE	0x03
+#define USR_MODE	0x10
+#define FIQ_MODE	0x11
+#define IRQ_MODE	0x12
+#define SVC_MODE	0x13
+#define ABT_MODE	0x17
+#define UND_MODE	0x1b
+#define SYSTEM_MODE	0x1f
+#define MODE_MASK	0x1f
+#define T_BIT		0x20
+#define F_BIT		0x40
+#define I_BIT		0x80
+#define CC_V_BIT	(1 << 28)
+#define CC_C_BIT	(1 << 29)
+#define CC_Z_BIT	(1 << 30)
+#define CC_N_BIT	(1 << 31)
+#define PCMASK		0
+
+#ifndef __ASSEMBLY__
+
+/* this struct defines the way the registers are stored on the
+   stack during a system call. */
+
+struct pt_regs {
+	long uregs[18];
+};
+
+#define ARM_cpsr	uregs[16]
+#define ARM_pc		uregs[15]
+#define ARM_lr		uregs[14]
+#define ARM_sp		uregs[13]
+#define ARM_ip		uregs[12]
+#define ARM_fp		uregs[11]
+#define ARM_r10		uregs[10]
+#define ARM_r9		uregs[9]
+#define ARM_r8		uregs[8]
+#define ARM_r7		uregs[7]
+#define ARM_r6		uregs[6]
+#define ARM_r5		uregs[5]
+#define ARM_r4		uregs[4]
+#define ARM_r3		uregs[3]
+#define ARM_r2		uregs[2]
+#define ARM_r1		uregs[1]
+#define ARM_r0		uregs[0]
+#define ARM_ORIG_r0	uregs[17]
+
+#ifdef __KERNEL__
+
+#define user_mode(regs)	\
+	(((regs)->ARM_cpsr & 0xf) == 0)
+
+#ifdef CONFIG_ARM_THUMB
+#define thumb_mode(regs) \
+	(((regs)->ARM_cpsr & T_BIT))
+#else
+#define thumb_mode(regs) (0)
+#endif
+
+#define processor_mode(regs) \
+	((regs)->ARM_cpsr & MODE_MASK)
+
+#define interrupts_enabled(regs) \
+	(!((regs)->ARM_cpsr & I_BIT))
+
+#define fast_interrupts_enabled(regs) \
+	(!((regs)->ARM_cpsr & F_BIT))
+
+#define condition_codes(regs) \
+	((regs)->ARM_cpsr & (CC_V_BIT|CC_C_BIT|CC_Z_BIT|CC_N_BIT))
+
+/* Are the current registers suitable for user mode?
+ * (used to maintain security in signal handlers)
+ */
+static inline int valid_user_regs(struct pt_regs *regs)
+{
+	if ((regs->ARM_cpsr & 0xf) == 0 &&
+	    (regs->ARM_cpsr & (F_BIT|I_BIT)) == 0)
+		return 1;
+
+	/*
+	 * Force CPSR to something logical...
+	 */
+	regs->ARM_cpsr &= (CC_V_BIT|CC_C_BIT|CC_Z_BIT|CC_N_BIT|0x10);
+
+	return 0;
+}
+
+#endif	/* __KERNEL__ */
+
+#endif	/* __ASSEMBLY__ */
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/proc-armv/system.h u-boot-1.2.0-leopard/include/asm/proc-armv/system.h
--- u-boot-1.2.0/include/asm/proc-armv/system.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/proc-armv/system.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,199 @@
+/*
+ *  linux/include/asm-arm/proc-armv/system.h
+ *
+ *  Copyright (C) 1996 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_PROC_SYSTEM_H
+#define __ASM_PROC_SYSTEM_H
+
+#include <linux/config.h>
+
+#define set_cr(x)					\
+	__asm__ __volatile__(				\
+	"mcr	p15, 0, %0, c1, c0	@ set CR"	\
+	: : "r" (x))
+
+#define CR_M	(1 << 0)	/* MMU enable				*/
+#define CR_A	(1 << 1)	/* Alignment abort enable		*/
+#define CR_C	(1 << 2)	/* Dcache enable			*/
+#define CR_W	(1 << 3)	/* Write buffer enable			*/
+#define CR_P	(1 << 4)	/* 32-bit exception handler		*/
+#define CR_D	(1 << 5)	/* 32-bit data address range		*/
+#define CR_L	(1 << 6)	/* Implementation defined		*/
+#define CD_B	(1 << 7)	/* Big endian				*/
+#define CR_S	(1 << 8)	/* System MMU protection		*/
+#define CD_R	(1 << 9)	/* ROM MMU protection			*/
+#define CR_F	(1 << 10)	/* Implementation defined		*/
+#define CR_Z	(1 << 11)	/* Implementation defined		*/
+#define CR_I	(1 << 12)	/* Icache enable			*/
+#define CR_V	(1 << 13)	/* Vectors relocated to 0xffff0000	*/
+#define CR_RR	(1 << 14)	/* Round Robin cache replacement	*/
+
+extern unsigned long cr_no_alignment;	/* defined in entry-armv.S */
+extern unsigned long cr_alignment;	/* defined in entry-armv.S */
+
+#if __LINUX_ARM_ARCH__ >= 4
+#define vectors_base()	((cr_alignment & CR_V) ? 0xffff0000 : 0)
+#else
+#define vectors_base()	(0)
+#endif
+
+/*
+ * Save the current interrupt enable state & disable IRQs
+ */
+#define local_irq_save(x)					\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_irq_save\n"	\
+"	orr	%1, %0, #128\n"					\
+"	msr	cpsr_c, %1"					\
+	: "=r" (x), "=r" (temp)					\
+	:							\
+	: "memory");						\
+	})
+
+/*
+ * Enable IRQs
+ */
+#define local_irq_enable()					\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_irq_enable\n"	\
+"	bic	%0, %0, #128\n"					\
+"	msr	cpsr_c, %0"					\
+	: "=r" (temp)						\
+	:							\
+	: "memory");						\
+	})
+
+/*
+ * Disable IRQs
+ */
+#define local_irq_disable()					\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_irq_disable\n"	\
+"	orr	%0, %0, #128\n"					\
+"	msr	cpsr_c, %0"					\
+	: "=r" (temp)						\
+	:							\
+	: "memory");						\
+	})
+
+/*
+ * Enable FIQs
+ */
+#define __stf()							\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ stf\n"		\
+"	bic	%0, %0, #64\n"					\
+"	msr	cpsr_c, %0"					\
+	: "=r" (temp)						\
+	:							\
+	: "memory");						\
+	})
+
+/*
+ * Disable FIQs
+ */
+#define __clf()							\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ clf\n"		\
+"	orr	%0, %0, #64\n"					\
+"	msr	cpsr_c, %0"					\
+	: "=r" (temp)						\
+	:							\
+	: "memory");						\
+	})
+
+/*
+ * Save the current interrupt enable state.
+ */
+#define local_save_flags(x)					\
+	({							\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_save_flags\n"	\
+	  : "=r" (x)						\
+	  :							\
+	  : "memory");						\
+	})
+
+/*
+ * restore saved IRQ & FIQ state
+ */
+#define local_irq_restore(x)					\
+	__asm__ __volatile__(					\
+	"msr	cpsr_c, %0		@ local_irq_restore\n"	\
+	:							\
+	: "r" (x)						\
+	: "memory")
+
+#if defined(CONFIG_CPU_SA1100) || defined(CONFIG_CPU_SA110)
+/*
+ * On the StrongARM, "swp" is terminally broken since it bypasses the
+ * cache totally.  This means that the cache becomes inconsistent, and,
+ * since we use normal loads/stores as well, this is really bad.
+ * Typically, this causes oopsen in filp_close, but could have other,
+ * more disasterous effects.  There are two work-arounds:
+ *  1. Disable interrupts and emulate the atomic swap
+ *  2. Clean the cache, perform atomic swap, flush the cache
+ *
+ * We choose (1) since its the "easiest" to achieve here and is not
+ * dependent on the processor type.
+ */
+#define swp_is_buggy
+#endif
+
+static inline unsigned long __xchg(unsigned long x, volatile void *ptr, int size)
+{
+	extern void __bad_xchg(volatile void *, int);
+	unsigned long ret;
+#ifdef swp_is_buggy
+	unsigned long flags;
+#endif
+
+	switch (size) {
+#ifdef swp_is_buggy
+		case 1:
+			local_irq_save(flags);
+			ret = *(volatile unsigned char *)ptr;
+			*(volatile unsigned char *)ptr = x;
+			local_irq_restore(flags);
+			break;
+
+		case 4:
+			local_irq_save(flags);
+			ret = *(volatile unsigned long *)ptr;
+			*(volatile unsigned long *)ptr = x;
+			local_irq_restore(flags);
+			break;
+#else
+		case 1:	__asm__ __volatile__ ("swpb %0, %1, [%2]"
+					: "=&r" (ret)
+					: "r" (x), "r" (ptr)
+					: "memory");
+			break;
+		case 4:	__asm__ __volatile__ ("swp %0, %1, [%2]"
+					: "=&r" (ret)
+					: "r" (x), "r" (ptr)
+					: "memory");
+			break;
+#endif
+		default: __bad_xchg(ptr, size), ret = 0;
+	}
+
+	return ret;
+}
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/processor.h u-boot-1.2.0-leopard/include/asm/processor.h
--- u-boot-1.2.0/include/asm/processor.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/processor.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,134 @@
+/*
+ *  linux/include/asm-arm/processor.h
+ *
+ *  Copyright (C) 1995-2002 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARM_PROCESSOR_H
+#define __ASM_ARM_PROCESSOR_H
+
+/*
+ * Default implementation of macro that returns current
+ * instruction pointer ("program counter").
+ */
+#define current_text_addr() ({ __label__ _l; _l: &&_l;})
+
+#define FP_SIZE 35
+
+struct fp_hard_struct {
+	unsigned int save[FP_SIZE];		/* as yet undefined */
+};
+
+struct fp_soft_struct {
+	unsigned int save[FP_SIZE];		/* undefined information */
+};
+
+union fp_state {
+	struct fp_hard_struct	hard;
+	struct fp_soft_struct	soft;
+};
+
+typedef unsigned long mm_segment_t;		/* domain register	*/
+
+#ifdef __KERNEL__
+
+#define EISA_bus 0
+#define MCA_bus 0
+#define MCA_bus__is_a_macro
+
+#include <asm/atomic.h>
+#include <asm/ptrace.h>
+#if 0	/* XXX###XXX */
+#include <asm/arch/memory.h>
+#endif	/* XXX###XXX */
+#include <asm/proc/processor.h>
+#include <asm/types.h>
+
+union debug_insn {
+	u32	arm;
+	u16	thumb;
+};
+
+struct debug_entry {
+	u32			address;
+	union debug_insn	insn;
+};
+
+struct debug_info {
+	int			nsaved;
+	struct debug_entry	bp[2];
+};
+
+struct thread_struct {
+	atomic_t			refcount;
+							/* fault info	  */
+	unsigned long			address;
+	unsigned long			trap_no;
+	unsigned long			error_code;
+							/* floating point */
+	union fp_state			fpstate;
+							/* debugging	  */
+	struct debug_info		debug;
+							/* context info	  */
+	struct context_save_struct	*save;
+	EXTRA_THREAD_STRUCT
+};
+
+#define INIT_THREAD  {					\
+	refcount:	ATOMIC_INIT(1),			\
+	EXTRA_THREAD_STRUCT_INIT			\
+}
+
+/*
+ * Return saved PC of a blocked thread.
+ */
+static inline unsigned long thread_saved_pc(struct thread_struct *t)
+{
+	return t->save ? pc_pointer(t->save->pc) : 0;
+}
+
+static inline unsigned long thread_saved_fp(struct thread_struct *t)
+{
+	return t->save ? t->save->fp : 0;
+}
+
+/* Forward declaration, a strange C thing */
+struct task_struct;
+
+/* Free all resources held by a thread. */
+extern void release_thread(struct task_struct *);
+
+/* Copy and release all segment info associated with a VM */
+#define copy_segments(tsk, mm)		do { } while (0)
+#define release_segments(mm)		do { } while (0)
+
+unsigned long get_wchan(struct task_struct *p);
+
+#define THREAD_SIZE	(8192)
+
+extern struct task_struct *alloc_task_struct(void);
+extern void __free_task_struct(struct task_struct *);
+#define get_task_struct(p)	atomic_inc(&(p)->thread.refcount)
+#define free_task_struct(p)					\
+ do {								\
+	if (atomic_dec_and_test(&(p)->thread.refcount))		\
+		__free_task_struct((p));			\
+ } while (0)
+
+#define init_task	(init_task_union.task)
+#define init_stack	(init_task_union.stack)
+
+#define cpu_relax()	barrier()
+
+/*
+ * Create a new kernel thread
+ */
+extern int arch_kernel_thread(int (*fn)(void *), void *arg, unsigned long flags);
+
+#endif
+
+#endif /* __ASM_ARM_PROCESSOR_H */
diff -Nurd u-boot-1.2.0/include/asm/ptrace.h u-boot-1.2.0-leopard/include/asm/ptrace.h
--- u-boot-1.2.0/include/asm/ptrace.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/ptrace.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,33 @@
+#ifndef __ASM_ARM_PTRACE_H
+#define __ASM_ARM_PTRACE_H
+
+#define PTRACE_GETREGS		12
+#define PTRACE_SETREGS		13
+#define PTRACE_GETFPREGS	14
+#define PTRACE_SETFPREGS	15
+
+#define PTRACE_SETOPTIONS	21
+
+/* options set using PTRACE_SETOPTIONS */
+#define PTRACE_O_TRACESYSGOOD	0x00000001
+
+#include <asm/proc/ptrace.h>
+
+#ifndef __ASSEMBLY__
+#define pc_pointer(v) \
+	((v) & ~PCMASK)
+
+#define instruction_pointer(regs) \
+	(pc_pointer((regs)->ARM_pc))
+
+#ifdef __KERNEL__
+extern void show_regs(struct pt_regs *);
+
+#define predicate(x)	(x & 0xf0000000)
+#define PREDICATE_ALWAYS	0xe0000000
+
+#endif
+
+#endif /* __ASSEMBLY__ */
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/setup.h u-boot-1.2.0-leopard/include/asm/setup.h
--- u-boot-1.2.0/include/asm/setup.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/setup.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,269 @@
+/*
+ *  linux/include/asm/setup.h
+ *
+ *  Copyright (C) 1997-1999 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Structure passed to kernel to tell it about the
+ *  hardware it's running on.  See linux/Documentation/arm/Setup
+ *  for more info.
+ *
+ * NOTE:
+ *  This file contains two ways to pass information from the boot
+ *  loader to the kernel. The old struct param_struct is deprecated,
+ *  but it will be kept in the kernel for 5 years from now
+ *  (2001). This will allow boot loaders to convert to the new struct
+ *  tag way.
+ */
+#ifndef __ASMARM_SETUP_H
+#define __ASMARM_SETUP_H
+
+/*
+ * Usage:
+ *  - do not go blindly adding fields, add them at the end
+ *  - when adding fields, don't rely on the address until
+ *    a patch from me has been released
+ *  - unused fields should be zero (for future expansion)
+ *  - this structure is relatively short-lived - only
+ *    guaranteed to contain useful data in setup_arch()
+ */
+#define COMMAND_LINE_SIZE 1024
+
+/* This is the old deprecated way to pass parameters to the kernel */
+struct param_struct {
+    union {
+	struct {
+	    unsigned long page_size;		/*  0 */
+	    unsigned long nr_pages;		/*  4 */
+	    unsigned long ramdisk_size;		/*  8 */
+	    unsigned long flags;		/* 12 */
+#define FLAG_READONLY	1
+#define FLAG_RDLOAD	4
+#define FLAG_RDPROMPT	8
+	    unsigned long rootdev;		/* 16 */
+	    unsigned long video_num_cols;	/* 20 */
+	    unsigned long video_num_rows;	/* 24 */
+	    unsigned long video_x;		/* 28 */
+	    unsigned long video_y;		/* 32 */
+	    unsigned long memc_control_reg;	/* 36 */
+	    unsigned char sounddefault;		/* 40 */
+	    unsigned char adfsdrives;		/* 41 */
+	    unsigned char bytes_per_char_h;	/* 42 */
+	    unsigned char bytes_per_char_v;	/* 43 */
+	    unsigned long pages_in_bank[4];	/* 44 */
+	    unsigned long pages_in_vram;	/* 60 */
+	    unsigned long initrd_start;		/* 64 */
+	    unsigned long initrd_size;		/* 68 */
+	    unsigned long rd_start;		/* 72 */
+	    unsigned long system_rev;		/* 76 */
+	    unsigned long system_serial_low;	/* 80 */
+	    unsigned long system_serial_high;	/* 84 */
+	    unsigned long mem_fclk_21285;       /* 88 */
+	} s;
+	char unused[256];
+    } u1;
+    union {
+	char paths[8][128];
+	struct {
+	    unsigned long magic;
+	    char n[1024 - sizeof(unsigned long)];
+	} s;
+    } u2;
+    char commandline[COMMAND_LINE_SIZE];
+};
+
+
+/*
+ * The new way of passing information: a list of tagged entries
+ */
+
+/* The list ends with an ATAG_NONE node. */
+#define ATAG_NONE	0x00000000
+
+struct tag_header {
+	u32 size;
+	u32 tag;
+};
+
+/* The list must start with an ATAG_CORE node */
+#define ATAG_CORE	0x54410001
+
+struct tag_core {
+	u32 flags;		/* bit 0 = read-only */
+	u32 pagesize;
+	u32 rootdev;
+};
+
+/* it is allowed to have multiple ATAG_MEM nodes */
+#define ATAG_MEM	0x54410002
+
+struct tag_mem32 {
+	u32	size;
+	u32	start;	/* physical start address */
+};
+
+/* VGA text type displays */
+#define ATAG_VIDEOTEXT	0x54410003
+
+struct tag_videotext {
+	u8		x;
+	u8		y;
+	u16		video_page;
+	u8		video_mode;
+	u8		video_cols;
+	u16		video_ega_bx;
+	u8		video_lines;
+	u8		video_isvga;
+	u16		video_points;
+};
+
+/* describes how the ramdisk will be used in kernel */
+#define ATAG_RAMDISK	0x54410004
+
+struct tag_ramdisk {
+	u32 flags;	/* bit 0 = load, bit 1 = prompt */
+	u32 size;	/* decompressed ramdisk size in _kilo_ bytes */
+	u32 start;	/* starting block of floppy-based RAM disk image */
+};
+
+/* describes where the compressed ramdisk image lives (virtual address) */
+/*
+ * this one accidentally used virtual addresses - as such,
+ * its depreciated.
+ */
+#define ATAG_INITRD	0x54410005
+
+/* describes where the compressed ramdisk image lives (physical address) */
+#define ATAG_INITRD2	0x54420005
+
+struct tag_initrd {
+	u32 start;	/* physical start address */
+	u32 size;	/* size of compressed ramdisk image in bytes */
+};
+
+/* board serial number. "64 bits should be enough for everybody" */
+#define ATAG_SERIAL	0x54410006
+
+struct tag_serialnr {
+	u32 low;
+	u32 high;
+};
+
+/* board revision */
+#define ATAG_REVISION	0x54410007
+
+struct tag_revision {
+	u32 rev;
+};
+
+/* initial values for vesafb-type framebuffers. see struct screen_info
+ * in include/linux/tty.h
+ */
+#define ATAG_VIDEOLFB	0x54410008
+
+struct tag_videolfb {
+	u16		lfb_width;
+	u16		lfb_height;
+	u16		lfb_depth;
+	u16		lfb_linelength;
+	u32		lfb_base;
+	u32		lfb_size;
+	u8		red_size;
+	u8		red_pos;
+	u8		green_size;
+	u8		green_pos;
+	u8		blue_size;
+	u8		blue_pos;
+	u8		rsvd_size;
+	u8		rsvd_pos;
+};
+
+/* command line: \0 terminated string */
+#define ATAG_CMDLINE	0x54410009
+
+struct tag_cmdline {
+	char	cmdline[1];	/* this is the minimum size */
+};
+
+/* acorn RiscPC specific information */
+#define ATAG_ACORN	0x41000101
+
+struct tag_acorn {
+	u32 memc_control_reg;
+	u32 vram_pages;
+	u8 sounddefault;
+	u8 adfsdrives;
+};
+
+/* footbridge memory clock, see arch/arm/mach-footbridge/arch.c */
+#define ATAG_MEMCLK	0x41000402
+
+struct tag_memclk {
+	u32 fmemclk;
+};
+
+struct tag {
+	struct tag_header hdr;
+	union {
+		struct tag_core		core;
+		struct tag_mem32	mem;
+		struct tag_videotext	videotext;
+		struct tag_ramdisk	ramdisk;
+		struct tag_initrd	initrd;
+		struct tag_serialnr	serialnr;
+		struct tag_revision	revision;
+		struct tag_videolfb	videolfb;
+		struct tag_cmdline	cmdline;
+
+		/*
+		 * Acorn specific
+		 */
+		struct tag_acorn	acorn;
+
+		/*
+		 * DC21285 specific
+		 */
+		struct tag_memclk	memclk;
+	} u;
+};
+
+struct tagtable {
+	u32 tag;
+	int (*parse)(const struct tag *);
+};
+
+#define __tag __attribute__((unused, __section__(".taglist")))
+#define __tagtable(tag, fn) \
+static struct tagtable __tagtable_##fn __tag = { tag, fn }
+
+#define tag_member_present(tag,member)				\
+	((unsigned long)(&((struct tag *)0L)->member + 1)	\
+		<= (tag)->hdr.size * 4)
+
+#define tag_next(t)	((struct tag *)((u32 *)(t) + (t)->hdr.size))
+#define tag_size(type)	((sizeof(struct tag_header) + sizeof(struct type)) >> 2)
+
+#define for_each_tag(t,base)		\
+	for (t = base; t->hdr.size; t = tag_next(t))
+
+/*
+ * Memory map description
+ */
+#define NR_BANKS 8
+
+struct meminfo {
+	int nr_banks;
+	unsigned long end;
+	struct {
+		unsigned long start;
+		unsigned long size;
+		int           node;
+	} bank[NR_BANKS];
+};
+
+extern struct meminfo meminfo;
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/sizes.h u-boot-1.2.0-leopard/include/asm/sizes.h
--- u-boot-1.2.0/include/asm/sizes.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/sizes.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,52 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/*  Size defintions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h                       1
+
+/* handy sizes */
+#define SZ_1K                           0x00000400
+#define SZ_4K                           0x00001000
+#define SZ_8K                           0x00002000
+#define SZ_16K                          0x00004000
+#define SZ_64K                          0x00010000
+#define SZ_128K                         0x00020000
+#define SZ_256K                         0x00040000
+#define SZ_512K                         0x00080000
+
+#define SZ_1M                           0x00100000
+#define SZ_2M                           0x00200000
+#define SZ_4M                           0x00400000
+#define SZ_8M                           0x00800000
+#define SZ_16M                          0x01000000
+#define SZ_32M                          0x02000000
+#define SZ_64M                          0x04000000
+#define SZ_128M                         0x08000000
+#define SZ_256M                         0x10000000
+#define SZ_512M                         0x20000000
+
+#define SZ_1G                           0x40000000
+#define SZ_2G                           0x80000000
+
+#endif
+
+/*         END */
diff -Nurd u-boot-1.2.0/include/asm/string.h u-boot-1.2.0-leopard/include/asm/string.h
--- u-boot-1.2.0/include/asm/string.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/string.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,47 @@
+#ifndef __ASM_ARM_STRING_H
+#define __ASM_ARM_STRING_H
+
+/*
+ * We don't do inline string functions, since the
+ * optimised inline asm versions are not small.
+ */
+
+#undef __HAVE_ARCH_STRRCHR
+extern char * strrchr(const char * s, int c);
+
+#undef __HAVE_ARCH_STRCHR
+extern char * strchr(const char * s, int c);
+
+#undef __HAVE_ARCH_MEMCPY
+extern void * memcpy(void *, const void *, __kernel_size_t);
+
+#undef __HAVE_ARCH_MEMMOVE
+extern void * memmove(void *, const void *, __kernel_size_t);
+
+#undef __HAVE_ARCH_MEMCHR
+extern void * memchr(const void *, int, __kernel_size_t);
+
+#undef __HAVE_ARCH_MEMZERO
+#undef __HAVE_ARCH_MEMSET
+extern void * memset(void *, int, __kernel_size_t);
+
+#if 0
+extern void __memzero(void *ptr, __kernel_size_t n);
+
+#define memset(p,v,n)							\
+	({								\
+		if ((n) != 0) {						\
+			if (__builtin_constant_p((v)) && (v) == 0)	\
+				__memzero((p),(n));			\
+			else						\
+				memset((p),(v),(n));			\
+		}							\
+		(p);							\
+	})
+
+#define memzero(p,n) ({ if ((n) != 0) __memzero((p),(n)); (p); })
+#else
+extern void memzero(void *ptr, __kernel_size_t n);
+#endif
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/types.h u-boot-1.2.0-leopard/include/asm/types.h
--- u-boot-1.2.0/include/asm/types.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/types.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,50 @@
+#ifndef __ASM_ARM_TYPES_H
+#define __ASM_ARM_TYPES_H
+
+typedef unsigned short umode_t;
+
+/*
+ * __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
+ * header files exported to user space
+ */
+
+typedef __signed__ char __s8;
+typedef unsigned char __u8;
+
+typedef __signed__ short __s16;
+typedef unsigned short __u16;
+
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
+typedef __signed__ long long __s64;
+typedef unsigned long long __u64;
+#endif
+
+/*
+ * These aren't exported outside the kernel to avoid name space clashes
+ */
+#ifdef __KERNEL__
+
+typedef signed char s8;
+typedef unsigned char u8;
+
+typedef signed short s16;
+typedef unsigned short u16;
+
+typedef signed int s32;
+typedef unsigned int u32;
+
+typedef signed long long s64;
+typedef unsigned long long u64;
+
+#define BITS_PER_LONG 32
+
+/* Dma addresses are 32-bits wide.  */
+
+typedef u32 dma_addr_t;
+
+#endif /* __KERNEL__ */
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm/u-boot-arm.h u-boot-1.2.0-leopard/include/asm/u-boot-arm.h
--- u-boot-1.2.0/include/asm/u-boot-arm.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/u-boot-arm.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _U_BOOT_ARM_H_
+#define _U_BOOT_ARM_H_	1
+
+/* for the following variables, see start.S */
+extern ulong _armboot_start;	/* code start */
+extern ulong _bss_start;	/* code + data end == BSS start */
+extern ulong _bss_end;		/* BSS end */
+extern ulong IRQ_STACK_START;	/* top of IRQ stack */
+extern ulong FIQ_STACK_START;	/* top of FIQ stack */
+
+/* cpu/.../cpu.c */
+int	cpu_init(void);
+int	cleanup_before_linux(void);
+
+/* board/.../... */
+int	board_init(void);
+int	dram_init (void);
+void	setup_serial_tag (struct tag **params);
+void	setup_revision_tag (struct tag **params);
+
+/* ------------------------------------------------------------ */
+/* Here is a list of some prototypes which are incompatible to	*/
+/* the U-Boot implementation					*/
+/* To be fixed!							*/
+/* ------------------------------------------------------------ */
+/* common/cmd_nvedit.c */
+void	setenv		(char *, char *);
+
+/* cpu/.../interrupt.c */
+void	reset_timer_masked	(void);
+ulong	get_timer_masked	(void);
+void	udelay_masked		(unsigned long usec);
+
+#endif	/* _U_BOOT_ARM_H_ */
diff -Nurd u-boot-1.2.0/include/asm/u-boot.h u-boot-1.2.0-leopard/include/asm/u-boot.h
--- u-boot-1.2.0/include/asm/u-boot.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm/u-boot.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,60 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ ********************************************************************
+ * NOTE: This header file defines an interface to U-Boot. Including
+ * this (unmodified) header file in another file is considered normal
+ * use of U-Boot, and does *not* fall under the heading of "derived
+ * work".
+ ********************************************************************
+ */
+
+#ifndef _U_BOOT_H_
+#define _U_BOOT_H_	1
+
+typedef struct bd_info {
+    int			bi_baudrate;	/* serial console baudrate */
+    unsigned long	bi_ip_addr;	/* IP Address */
+    unsigned char	bi_enetaddr[6]; /* Ethernet adress */
+    struct environment_s	       *bi_env;
+    ulong	        bi_arch_number;	/* unique id for this board */
+    ulong	        bi_boot_params;	/* where this board expects params */
+    struct				/* RAM configuration */
+    {
+	ulong start;
+	ulong size;
+    } 			bi_dram[CONFIG_NR_DRAM_BANKS];
+#ifdef CONFIG_HAS_ETH1
+    /* second onboard ethernet port */
+    unsigned char   bi_enet1addr[6];
+#endif
+} bd_t;
+
+#define bi_env_data bi_env->data
+#define bi_env_crc  bi_env->crc
+
+#endif	/* _U_BOOT_H_ */
diff -Nurd u-boot-1.2.0/include/asm-arm/arch/emif_defs.h u-boot-1.2.0-leopard/include/asm-arm/arch/emif_defs.h
--- u-boot-1.2.0/include/asm-arm/arch/emif_defs.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm-arm/arch/emif_defs.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) Sergey Kubushyn <ksi@koi8.net>, 2007.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _EMIF_DEFS_H_
+#define _EMIF_DEFS_H_
+
+typedef struct {
+	dv_reg		ERCSR;
+	dv_reg		AWCCR;
+	dv_reg		SDBCR;
+	dv_reg		SDRCR;
+	dv_reg		AB1CR;
+	dv_reg		AB2CR;
+	dv_reg		AB3CR;
+	dv_reg		AB4CR;
+	dv_reg		SDTIMR;
+	dv_reg		DDRSR;
+	dv_reg		DDRPHYCR;
+	dv_reg		DDRPHYSR;
+	dv_reg		TOTAR;
+	dv_reg		TOTACTR;
+	dv_reg		DDRPHYID_REV;
+	dv_reg		SDSRETR;
+	dv_reg		EIRR;
+	dv_reg		EIMR;
+	dv_reg		EIMSR;
+	dv_reg		EIMCR;
+	dv_reg		IOCTRLR;
+	dv_reg		IOSTATR;
+	u_int8_t	RSVD0[8];
+	dv_reg		NANDFCR;
+	dv_reg		NANDFSR;
+	u_int8_t	RSVD1[8];
+	dv_reg		NANDF1ECC;
+	dv_reg		NANDF2ECC;
+	dv_reg		NANDF3ECC;
+	dv_reg		NANDF4ECC;
+} emif_registers;
+
+typedef emif_registers	*emifregs;
+#endif
diff -Nurd u-boot-1.2.0/include/asm-arm/arch/nand_defs.h u-boot-1.2.0-leopard/include/asm-arm/arch/nand_defs.h
--- u-boot-1.2.0/include/asm-arm/arch/nand_defs.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm-arm/arch/nand_defs.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) Sergey Kubushyn <ksi@koi8.net>, 2007.
+ *
+ * Parts shamelesly stolen from Linux Kernel source tree.
+ *
+ * ------------------------------------------------------------
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _NAND_DEFS_H_
+#define _NAND_DEFS_H_
+
+#define	MASK_CLE	0x10
+//#define	MASK_ALE	0x0a
+#define	MASK_ALE	0x08
+
+#define NAND_CE0CLE	((volatile u_int8_t *)(CFG_NAND_BASE + 0x10))
+//#define NAND_CE0ALE	((volatile u_int8_t *)(CFG_NAND_BASE + 0x0a))
+#define NAND_CE0ALE	((volatile u_int8_t *)(CFG_NAND_BASE + 0x08))
+#define NAND_CE0DATA	((volatile u_int8_t *)CFG_NAND_BASE)
+
+typedef struct  {
+	u_int32_t	NRCSR;
+	u_int32_t	AWCCR;
+	u_int8_t	RSVD0[8];
+	u_int32_t	AB1CR;
+	u_int32_t	AB2CR;
+	u_int32_t	AB3CR;
+	u_int32_t	AB4CR;
+	u_int8_t	RSVD1[32];
+	u_int32_t	NIRR;
+	u_int32_t	NIMR;
+	u_int32_t	NIMSR;
+	u_int32_t	NIMCR;
+	u_int8_t	RSVD2[16];
+	u_int32_t	NANDFCR;
+	u_int32_t	NANDFSR;
+	u_int8_t	RSVD3[8];
+	u_int32_t	NANDF1ECC;
+	u_int32_t	NANDF2ECC;
+	u_int32_t	NANDF3ECC;
+	u_int32_t	NANDF4ECC;
+	u_int8_t	RSVD4[4];
+	u_int32_t	IODFTECR;
+	u_int32_t	IODFTGCR;
+	u_int8_t	RSVD5[4];
+	u_int32_t	IODFTMRLR;
+	u_int32_t	IODFTMRMR;
+	u_int32_t	IODFTMRMSBR;
+	u_int8_t	RSVD6[20];
+	u_int32_t	MODRNR;
+	u_int8_t	RSVD7[76];
+	u_int32_t	CE0DATA;
+	u_int32_t	CE0ALE;
+	u_int32_t	CE0CLE;
+	u_int8_t	RSVD8[4];
+	u_int32_t	CE1DATA;
+	u_int32_t	CE1ALE;
+	u_int32_t	CE1CLE;
+	u_int8_t	RSVD9[4];
+	u_int32_t	CE2DATA;
+	u_int32_t	CE2ALE;
+	u_int32_t	CE2CLE;
+	u_int8_t	RSVD10[4];
+	u_int32_t	CE3DATA;
+	u_int32_t	CE3ALE;
+	u_int32_t	CE3CLE;
+} nand_registers;
+
+typedef volatile nand_registers	*nandregs;
+
+#define NAND_READ_START		0x00
+#define NAND_READ_END		0x30
+#define NAND_STATUS		0x70
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm-arm/arch/sizes.h u-boot-1.2.0-leopard/include/asm-arm/arch/sizes.h
--- u-boot-1.2.0/include/asm-arm/arch/sizes.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm-arm/arch/sizes.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,51 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA0 2111-1307
+ * USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *		   from .s file by awk -f s2h.awk
+ */
+/*  Size defintions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h			1
+
+/* handy sizes */
+#define SZ_1K		0x00000400
+#define SZ_4K		0x00001000
+#define SZ_8K		0x00002000
+#define SZ_16K		0x00004000
+#define SZ_64K		0x00010000
+#define SZ_128K	0x00020000
+#define SZ_256K	0x00040000
+#define SZ_512K	0x00080000
+
+#define SZ_1M		0x00100000
+#define SZ_2M		0x00200000
+#define SZ_4M		0x00400000
+#define SZ_8M		0x00800000
+#define SZ_16M		0x01000000
+#define SZ_32M		0x02000000
+#define SZ_64M		0x04000000
+#define SZ_128M	0x08000000
+#define SZ_256M	0x10000000
+#define SZ_512M	0x20000000
+
+#define SZ_1G		0x40000000
+#define SZ_2G		0x80000000
+
+#endif	/* __sizes_h */
diff -Nurd u-boot-1.2.0/include/asm-arm/arch/types.h u-boot-1.2.0-leopard/include/asm-arm/arch/types.h
--- u-boot-1.2.0/include/asm-arm/arch/types.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm-arm/arch/types.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) Sergey Kubushyn <ksi@koi8.net>, 2007.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _ASM_ARCH_TYPES_H_
+#define _ASM_ARCH_TYPES_H_
+
+#define	REG(addr)	(*(volatile unsigned int *)(addr))
+#define REG_P(addr)	((volatile unsigned int *)(addr))
+
+typedef volatile unsigned int	dv_reg;
+typedef volatile unsigned int *	dv_reg_p;
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm-arm/arch-arm926ejs/emif_defs.h u-boot-1.2.0-leopard/include/asm-arm/arch-arm926ejs/emif_defs.h
--- u-boot-1.2.0/include/asm-arm/arch-arm926ejs/emif_defs.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm-arm/arch-arm926ejs/emif_defs.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) Sergey Kubushyn <ksi@koi8.net>, 2007.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _EMIF_DEFS_H_
+#define _EMIF_DEFS_H_
+
+typedef struct {
+	dv_reg		ERCSR;
+	dv_reg		AWCCR;
+	dv_reg		SDBCR;
+	dv_reg		SDRCR;
+	dv_reg		AB1CR;
+	dv_reg		AB2CR;
+	dv_reg		AB3CR;
+	dv_reg		AB4CR;
+	dv_reg		SDTIMR;
+	dv_reg		DDRSR;
+	dv_reg		DDRPHYCR;
+	dv_reg		DDRPHYSR;
+	dv_reg		TOTAR;
+	dv_reg		TOTACTR;
+	dv_reg		DDRPHYID_REV;
+	dv_reg		SDSRETR;
+	dv_reg		EIRR;
+	dv_reg		EIMR;
+	dv_reg		EIMSR;
+	dv_reg		EIMCR;
+	dv_reg		IOCTRLR;
+	dv_reg		IOSTATR;
+	u_int8_t	RSVD0[8];
+	dv_reg		NANDFCR;
+	dv_reg		NANDFSR;
+	u_int8_t	RSVD1[8];
+	dv_reg		NANDF1ECC;
+	dv_reg		NANDF2ECC;
+	dv_reg		NANDF3ECC;
+	dv_reg		NANDF4ECC;
+} emif_registers;
+
+typedef emif_registers	*emifregs;
+#endif
diff -Nurd u-boot-1.2.0/include/asm-arm/arch-arm926ejs/nand_defs.h u-boot-1.2.0-leopard/include/asm-arm/arch-arm926ejs/nand_defs.h
--- u-boot-1.2.0/include/asm-arm/arch-arm926ejs/nand_defs.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm-arm/arch-arm926ejs/nand_defs.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) Sergey Kubushyn <ksi@koi8.net>, 2007.
+ *
+ * Parts shamelesly stolen from Linux Kernel source tree.
+ *
+ * ------------------------------------------------------------
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _NAND_DEFS_H_
+#define _NAND_DEFS_H_
+
+#define	MASK_CLE	0x10
+//#define	MASK_ALE	0x0a
+#define	MASK_ALE	0x08
+
+#define NAND_CE0CLE	((volatile u_int8_t *)(CFG_NAND_BASE + 0x10))
+//#define NAND_CE0ALE	((volatile u_int8_t *)(CFG_NAND_BASE + 0x0a))
+#define NAND_CE0ALE	((volatile u_int8_t *)(CFG_NAND_BASE + 0x08))
+#define NAND_CE0DATA	((volatile u_int8_t *)CFG_NAND_BASE)
+
+typedef struct  {
+	u_int32_t	NRCSR;
+	u_int32_t	AWCCR;
+	u_int8_t	RSVD0[8];
+	u_int32_t	AB1CR;
+	u_int32_t	AB2CR;
+	u_int32_t	AB3CR;
+	u_int32_t	AB4CR;
+	u_int8_t	RSVD1[32];
+	u_int32_t	NIRR;
+	u_int32_t	NIMR;
+	u_int32_t	NIMSR;
+	u_int32_t	NIMCR;
+	u_int8_t	RSVD2[16];
+	u_int32_t	NANDFCR;
+	u_int32_t	NANDFSR;
+	u_int8_t	RSVD3[8];
+	u_int32_t	NANDF1ECC;
+	u_int32_t	NANDF2ECC;
+	u_int32_t	NANDF3ECC;
+	u_int32_t	NANDF4ECC;
+	u_int8_t	RSVD4[4];
+	u_int32_t	IODFTECR;
+	u_int32_t	IODFTGCR;
+	u_int8_t	RSVD5[4];
+	u_int32_t	IODFTMRLR;
+	u_int32_t	IODFTMRMR;
+	u_int32_t	IODFTMRMSBR;
+	u_int8_t	RSVD6[20];
+	u_int32_t	MODRNR;
+	u_int8_t	RSVD7[76];
+	u_int32_t	CE0DATA;
+	u_int32_t	CE0ALE;
+	u_int32_t	CE0CLE;
+	u_int8_t	RSVD8[4];
+	u_int32_t	CE1DATA;
+	u_int32_t	CE1ALE;
+	u_int32_t	CE1CLE;
+	u_int8_t	RSVD9[4];
+	u_int32_t	CE2DATA;
+	u_int32_t	CE2ALE;
+	u_int32_t	CE2CLE;
+	u_int8_t	RSVD10[4];
+	u_int32_t	CE3DATA;
+	u_int32_t	CE3ALE;
+	u_int32_t	CE3CLE;
+} nand_registers;
+
+typedef volatile nand_registers	*nandregs;
+
+#define NAND_READ_START		0x00
+#define NAND_READ_END		0x30
+#define NAND_STATUS		0x70
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm-arm/arch-arm926ejs/types.h u-boot-1.2.0-leopard/include/asm-arm/arch-arm926ejs/types.h
--- u-boot-1.2.0/include/asm-arm/arch-arm926ejs/types.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm-arm/arch-arm926ejs/types.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) Sergey Kubushyn <ksi@koi8.net>, 2007.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _ASM_ARCH_TYPES_H_
+#define _ASM_ARCH_TYPES_H_
+
+#define	REG(addr)	(*(volatile unsigned int *)(addr))
+#define REG_P(addr)	((volatile unsigned int *)(addr))
+
+typedef volatile unsigned int	dv_reg;
+typedef volatile unsigned int *	dv_reg_p;
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm-arm/proc/domain.h u-boot-1.2.0-leopard/include/asm-arm/proc/domain.h
--- u-boot-1.2.0/include/asm-arm/proc/domain.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm-arm/proc/domain.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,50 @@
+/*
+ *  linux/include/asm-arm/proc-armv/domain.h
+ *
+ *  Copyright (C) 1999 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_PROC_DOMAIN_H
+#define __ASM_PROC_DOMAIN_H
+
+/*
+ * Domain numbers
+ *
+ *  DOMAIN_IO     - domain 2 includes all IO only
+ *  DOMAIN_KERNEL - domain 1 includes all kernel memory only
+ *  DOMAIN_USER   - domain 0 includes all user memory only
+ */
+#define DOMAIN_USER	0
+#define DOMAIN_KERNEL	1
+#define DOMAIN_TABLE	1
+#define DOMAIN_IO	2
+
+/*
+ * Domain types
+ */
+#define DOMAIN_NOACCESS	0
+#define DOMAIN_CLIENT	1
+#define DOMAIN_MANAGER	3
+
+#define domain_val(dom,type)	((type) << 2*(dom))
+
+#define set_domain(x)					\
+	do {						\
+	__asm__ __volatile__(				\
+	"mcr	p15, 0, %0, c3, c0	@ set domain"	\
+	  : : "r" (x));					\
+	} while (0)
+
+#define modify_domain(dom,type)				\
+	do {						\
+	unsigned int domain = current->thread.domain;	\
+	domain &= ~domain_val(dom, DOMAIN_MANAGER);	\
+	domain |= domain_val(dom, type);		\
+	current->thread.domain = domain;		\
+	set_domain(current->thread.domain);		\
+	} while (0)
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm-arm/proc/processor.h u-boot-1.2.0-leopard/include/asm-arm/proc/processor.h
--- u-boot-1.2.0/include/asm-arm/proc/processor.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm-arm/proc/processor.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,74 @@
+/*
+ *  linux/include/asm-arm/proc-armv/processor.h
+ *
+ *  Copyright (C) 1996-1999 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Changelog:
+ *   20-09-1996	RMK	Created
+ *   26-09-1996	RMK	Added 'EXTRA_THREAD_STRUCT*'
+ *   28-09-1996	RMK	Moved start_thread into the processor dependencies
+ *   09-09-1998	PJB	Delete redundant `wp_works_ok'
+ *   30-05-1999	PJB	Save sl across context switches
+ *   31-07-1999	RMK	Added 'domain' stuff
+ */
+#ifndef __ASM_PROC_PROCESSOR_H
+#define __ASM_PROC_PROCESSOR_H
+
+#include <asm/proc/domain.h>
+
+#define KERNEL_STACK_SIZE	PAGE_SIZE
+
+struct context_save_struct {
+	unsigned long cpsr;
+	unsigned long r4;
+	unsigned long r5;
+	unsigned long r6;
+	unsigned long r7;
+	unsigned long r8;
+	unsigned long r9;
+	unsigned long sl;
+	unsigned long fp;
+	unsigned long pc;
+};
+
+#define INIT_CSS (struct context_save_struct){ SVC_MODE, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
+
+#define EXTRA_THREAD_STRUCT						\
+	unsigned int	domain;
+
+#define EXTRA_THREAD_STRUCT_INIT					\
+	domain:	  domain_val(DOMAIN_USER, DOMAIN_CLIENT) |		\
+		  domain_val(DOMAIN_KERNEL, DOMAIN_MANAGER) |		\
+		  domain_val(DOMAIN_IO, DOMAIN_CLIENT)
+
+#define start_thread(regs,pc,sp)					\
+({									\
+	unsigned long *stack = (unsigned long *)sp;			\
+	set_fs(USER_DS);						\
+	memzero(regs->uregs, sizeof(regs->uregs));			\
+	if (current->personality & ADDR_LIMIT_32BIT)			\
+		regs->ARM_cpsr = USR_MODE;				\
+	else								\
+		regs->ARM_cpsr = USR26_MODE;				\
+	regs->ARM_pc = pc;		/* pc */			\
+	regs->ARM_sp = sp;		/* sp */			\
+	regs->ARM_r2 = stack[2];	/* r2 (envp) */			\
+	regs->ARM_r1 = stack[1];	/* r1 (argv) */			\
+	regs->ARM_r0 = stack[0];	/* r0 (argc) */			\
+})
+
+#define KSTK_EIP(tsk)	(((unsigned long *)(4096+(unsigned long)(tsk)))[1019])
+#define KSTK_ESP(tsk)	(((unsigned long *)(4096+(unsigned long)(tsk)))[1017])
+
+/* Allocation and freeing of basic task resources. */
+/*
+ * NOTE! The task struct and the stack go together
+ */
+#define ll_alloc_task_struct() ((struct task_struct *) __get_free_pages(GFP_KERNEL,1))
+#define ll_free_task_struct(p) free_pages((unsigned long)(p),1)
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm-arm/proc/ptrace.h u-boot-1.2.0-leopard/include/asm-arm/proc/ptrace.h
--- u-boot-1.2.0/include/asm-arm/proc/ptrace.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm-arm/proc/ptrace.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,109 @@
+/*
+ *  linux/include/asm-arm/proc-armv/ptrace.h
+ *
+ *  Copyright (C) 1996-1999 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_PROC_PTRACE_H
+#define __ASM_PROC_PTRACE_H
+
+#include <linux/config.h>
+
+#define USR26_MODE	0x00
+#define FIQ26_MODE	0x01
+#define IRQ26_MODE	0x02
+#define SVC26_MODE	0x03
+#define USR_MODE	0x10
+#define FIQ_MODE	0x11
+#define IRQ_MODE	0x12
+#define SVC_MODE	0x13
+#define ABT_MODE	0x17
+#define UND_MODE	0x1b
+#define SYSTEM_MODE	0x1f
+#define MODE_MASK	0x1f
+#define T_BIT		0x20
+#define F_BIT		0x40
+#define I_BIT		0x80
+#define CC_V_BIT	(1 << 28)
+#define CC_C_BIT	(1 << 29)
+#define CC_Z_BIT	(1 << 30)
+#define CC_N_BIT	(1 << 31)
+#define PCMASK		0
+
+#ifndef __ASSEMBLY__
+
+/* this struct defines the way the registers are stored on the
+   stack during a system call. */
+
+struct pt_regs {
+	long uregs[18];
+};
+
+#define ARM_cpsr	uregs[16]
+#define ARM_pc		uregs[15]
+#define ARM_lr		uregs[14]
+#define ARM_sp		uregs[13]
+#define ARM_ip		uregs[12]
+#define ARM_fp		uregs[11]
+#define ARM_r10		uregs[10]
+#define ARM_r9		uregs[9]
+#define ARM_r8		uregs[8]
+#define ARM_r7		uregs[7]
+#define ARM_r6		uregs[6]
+#define ARM_r5		uregs[5]
+#define ARM_r4		uregs[4]
+#define ARM_r3		uregs[3]
+#define ARM_r2		uregs[2]
+#define ARM_r1		uregs[1]
+#define ARM_r0		uregs[0]
+#define ARM_ORIG_r0	uregs[17]
+
+#ifdef __KERNEL__
+
+#define user_mode(regs)	\
+	(((regs)->ARM_cpsr & 0xf) == 0)
+
+#ifdef CONFIG_ARM_THUMB
+#define thumb_mode(regs) \
+	(((regs)->ARM_cpsr & T_BIT))
+#else
+#define thumb_mode(regs) (0)
+#endif
+
+#define processor_mode(regs) \
+	((regs)->ARM_cpsr & MODE_MASK)
+
+#define interrupts_enabled(regs) \
+	(!((regs)->ARM_cpsr & I_BIT))
+
+#define fast_interrupts_enabled(regs) \
+	(!((regs)->ARM_cpsr & F_BIT))
+
+#define condition_codes(regs) \
+	((regs)->ARM_cpsr & (CC_V_BIT|CC_C_BIT|CC_Z_BIT|CC_N_BIT))
+
+/* Are the current registers suitable for user mode?
+ * (used to maintain security in signal handlers)
+ */
+static inline int valid_user_regs(struct pt_regs *regs)
+{
+	if ((regs->ARM_cpsr & 0xf) == 0 &&
+	    (regs->ARM_cpsr & (F_BIT|I_BIT)) == 0)
+		return 1;
+
+	/*
+	 * Force CPSR to something logical...
+	 */
+	regs->ARM_cpsr &= (CC_V_BIT|CC_C_BIT|CC_Z_BIT|CC_N_BIT|0x10);
+
+	return 0;
+}
+
+#endif	/* __KERNEL__ */
+
+#endif	/* __ASSEMBLY__ */
+
+#endif
diff -Nurd u-boot-1.2.0/include/asm-arm/proc/system.h u-boot-1.2.0-leopard/include/asm-arm/proc/system.h
--- u-boot-1.2.0/include/asm-arm/proc/system.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/asm-arm/proc/system.h	2007-12-04 07:50:43.000000000 -0300
@@ -0,0 +1,199 @@
+/*
+ *  linux/include/asm-arm/proc-armv/system.h
+ *
+ *  Copyright (C) 1996 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ASM_PROC_SYSTEM_H
+#define __ASM_PROC_SYSTEM_H
+
+#include <linux/config.h>
+
+#define set_cr(x)					\
+	__asm__ __volatile__(				\
+	"mcr	p15, 0, %0, c1, c0	@ set CR"	\
+	: : "r" (x))
+
+#define CR_M	(1 << 0)	/* MMU enable				*/
+#define CR_A	(1 << 1)	/* Alignment abort enable		*/
+#define CR_C	(1 << 2)	/* Dcache enable			*/
+#define CR_W	(1 << 3)	/* Write buffer enable			*/
+#define CR_P	(1 << 4)	/* 32-bit exception handler		*/
+#define CR_D	(1 << 5)	/* 32-bit data address range		*/
+#define CR_L	(1 << 6)	/* Implementation defined		*/
+#define CD_B	(1 << 7)	/* Big endian				*/
+#define CR_S	(1 << 8)	/* System MMU protection		*/
+#define CD_R	(1 << 9)	/* ROM MMU protection			*/
+#define CR_F	(1 << 10)	/* Implementation defined		*/
+#define CR_Z	(1 << 11)	/* Implementation defined		*/
+#define CR_I	(1 << 12)	/* Icache enable			*/
+#define CR_V	(1 << 13)	/* Vectors relocated to 0xffff0000	*/
+#define CR_RR	(1 << 14)	/* Round Robin cache replacement	*/
+
+extern unsigned long cr_no_alignment;	/* defined in entry-armv.S */
+extern unsigned long cr_alignment;	/* defined in entry-armv.S */
+
+#if __LINUX_ARM_ARCH__ >= 4
+#define vectors_base()	((cr_alignment & CR_V) ? 0xffff0000 : 0)
+#else
+#define vectors_base()	(0)
+#endif
+
+/*
+ * Save the current interrupt enable state & disable IRQs
+ */
+#define local_irq_save(x)					\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_irq_save\n"	\
+"	orr	%1, %0, #128\n"					\
+"	msr	cpsr_c, %1"					\
+	: "=r" (x), "=r" (temp)					\
+	:							\
+	: "memory");						\
+	})
+
+/*
+ * Enable IRQs
+ */
+#define local_irq_enable()					\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_irq_enable\n"	\
+"	bic	%0, %0, #128\n"					\
+"	msr	cpsr_c, %0"					\
+	: "=r" (temp)						\
+	:							\
+	: "memory");						\
+	})
+
+/*
+ * Disable IRQs
+ */
+#define local_irq_disable()					\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_irq_disable\n"	\
+"	orr	%0, %0, #128\n"					\
+"	msr	cpsr_c, %0"					\
+	: "=r" (temp)						\
+	:							\
+	: "memory");						\
+	})
+
+/*
+ * Enable FIQs
+ */
+#define __stf()							\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ stf\n"		\
+"	bic	%0, %0, #64\n"					\
+"	msr	cpsr_c, %0"					\
+	: "=r" (temp)						\
+	:							\
+	: "memory");						\
+	})
+
+/*
+ * Disable FIQs
+ */
+#define __clf()							\
+	({							\
+		unsigned long temp;				\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ clf\n"		\
+"	orr	%0, %0, #64\n"					\
+"	msr	cpsr_c, %0"					\
+	: "=r" (temp)						\
+	:							\
+	: "memory");						\
+	})
+
+/*
+ * Save the current interrupt enable state.
+ */
+#define local_save_flags(x)					\
+	({							\
+	__asm__ __volatile__(					\
+	"mrs	%0, cpsr		@ local_save_flags\n"	\
+	  : "=r" (x)						\
+	  :							\
+	  : "memory");						\
+	})
+
+/*
+ * restore saved IRQ & FIQ state
+ */
+#define local_irq_restore(x)					\
+	__asm__ __volatile__(					\
+	"msr	cpsr_c, %0		@ local_irq_restore\n"	\
+	:							\
+	: "r" (x)						\
+	: "memory")
+
+#if defined(CONFIG_CPU_SA1100) || defined(CONFIG_CPU_SA110)
+/*
+ * On the StrongARM, "swp" is terminally broken since it bypasses the
+ * cache totally.  This means that the cache becomes inconsistent, and,
+ * since we use normal loads/stores as well, this is really bad.
+ * Typically, this causes oopsen in filp_close, but could have other,
+ * more disasterous effects.  There are two work-arounds:
+ *  1. Disable interrupts and emulate the atomic swap
+ *  2. Clean the cache, perform atomic swap, flush the cache
+ *
+ * We choose (1) since its the "easiest" to achieve here and is not
+ * dependent on the processor type.
+ */
+#define swp_is_buggy
+#endif
+
+static inline unsigned long __xchg(unsigned long x, volatile void *ptr, int size)
+{
+	extern void __bad_xchg(volatile void *, int);
+	unsigned long ret;
+#ifdef swp_is_buggy
+	unsigned long flags;
+#endif
+
+	switch (size) {
+#ifdef swp_is_buggy
+		case 1:
+			local_irq_save(flags);
+			ret = *(volatile unsigned char *)ptr;
+			*(volatile unsigned char *)ptr = x;
+			local_irq_restore(flags);
+			break;
+
+		case 4:
+			local_irq_save(flags);
+			ret = *(volatile unsigned long *)ptr;
+			*(volatile unsigned long *)ptr = x;
+			local_irq_restore(flags);
+			break;
+#else
+		case 1:	__asm__ __volatile__ ("swpb %0, %1, [%2]"
+					: "=&r" (ret)
+					: "r" (x), "r" (ptr)
+					: "memory");
+			break;
+		case 4:	__asm__ __volatile__ ("swp %0, %1, [%2]"
+					: "=&r" (ret)
+					: "r" (x), "r" (ptr)
+					: "memory");
+			break;
+#endif
+		default: __bad_xchg(ptr, size), ret = 0;
+	}
+
+	return ret;
+}
+
+#endif
diff -Nurd u-boot-1.2.0/include/config.h u-boot-1.2.0-leopard/include/config.h
--- u-boot-1.2.0/include/config.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/config.h	2009-03-10 02:21:15.000000000 -0300
@@ -0,0 +1,2 @@
+/* Automatically generated - do not edit */
+#include <configs/dm355_leopard.h>
diff -Nurd u-boot-1.2.0/include/config.mk u-boot-1.2.0-leopard/include/config.mk
--- u-boot-1.2.0/include/config.mk	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/config.mk	2009-03-10 02:21:15.000000000 -0300
@@ -0,0 +1,3 @@
+ARCH   = arm
+CPU    = arm926ejs
+BOARD  = dm355_leopard
diff -Nurd u-boot-1.2.0/include/configs/davinci.h u-boot-1.2.0-leopard/include/configs/davinci.h
--- u-boot-1.2.0/include/configs/davinci.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/configs/davinci.h	2007-12-04 07:50:49.000000000 -0300
@@ -0,0 +1,222 @@
+/*
+ * (C) Copyright 2003
+ * Texas Instruments.
+ * Swaminathan S <swami.iyer@ti.com>
+ * Configuation settings for the TI DaVinci EVM board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/* Chip Configurations */
+/*============================================================================*/
+#define CFG_DAVINCI
+#define CONFIG_ARM926EJS	/* This is an arm926ejs CPU core  	  */
+#define CONFIG_SYS_CLK_FREQ	229500000	/* Arm Clock frequency    */
+#define CFG_TIMERBASE		0x01C21400	/* use timer 0 		  */
+#define CFG_HZ			27000000	/* Timer Input clock freq */	
+/*============================================================================*/
+
+/* Flash Boot info */
+/*============================================================================*/
+#define CFG_ENV_IS_IN_FLASH 	1		/* U-Boot env in NOR Flash   */
+
+#ifndef CFG_ENV_IS_IN_FLASH
+#define CONFIG_INITRD_TAG  	1
+#define CFG_ENV_IS_IN_NAND 	1               /* U-Boot env in NAND Flash  */
+#define CFG_ENV_SECT_SIZE	0x4000		/* Env sector Size */
+#define CFG_ENV_SIZE		(16 * 1024)
+#else
+#define CONFIG_INITRD_TAG  	1
+#define CFG_ENV_SECT_SIZE	CFG_FLASH_SECT_SZ	/* Env sector Size */
+#define CFG_ENV_SIZE		CFG_FLASH_SECT_SZ
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + 0x60000)
+#endif
+
+
+/*
+ * NOR Flash Info 
+ */
+/*============================================================================*/
+#define CONFIG_CS0_BOOT				/* Boot from Flash 	     */
+#define CFG_MAX_FLASH_BANKS	1		/* max number of flash banks */
+#define CFG_FLASH_SECT_SZ	0x20000		/* 128KB sect size Intel Flash */
+
+#ifdef CONFIG_CS0_BOOT
+#define PHYS_FLASH_1		0x02000000	/* CS0 Base address 	 */
+#endif
+#ifdef CONFIG_CS3_BOOT
+#define PHYS_FLASH_1		0x00000000	/* Need to update CHECK  */
+#endif
+#define CFG_FLASH_BASE		PHYS_FLASH_1 	/* Flash Base for U-Boot */
+#define CONFIG_ENV_OVERWRITE			/* allow env overwrie 	 */
+#define PHYS_FLASH_SIZE		0x1000000	/* Flash size 16MB 	 */
+#define CFG_MAX_FLASH_SECT	256		/* max sectors on flash  */
+						/* Intel 28F128P30T has  */
+						/* 131 sectors, 256      */
+						/* is used for backwards */
+						/* compatibility with    */
+						/* AMD AMLV256U on early */
+						/* boards.               */
+#if(0)
+#define CFG_MAX_FLASH_SECT	(PHYS_FLASH_SIZE/CFG_FLASH_SECT_SZ)
+#endif
+#define CFG_FLASH_ERASE_TOUT	(20*CFG_HZ)	/* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(20*CFG_HZ)	/* Timeout for Flash Write */
+/*============================================================================*/
+
+/*
+ * Memory Info 
+ */
+/*============================================================================*/
+#define CFG_MALLOC_LEN		(0x20000 + 128*1024)  /* malloc () len */
+#define CFG_GBL_DATA_SIZE	128		/* reserved for initial data */
+#define CFG_MEMTEST_START	0x82000000	/* memtest start address  */
+#define CFG_MEMTEST_END		0x90000000	/* 16MB RAM test   	  */
+#define CONFIG_NR_DRAM_BANKS	1		/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x80000000	/* DDR Start 		  */
+#define PHYS_SDRAM_1_SIZE	0x10000000	/* DDR size 256MB 	  */
+#define CONFIG_STACKSIZE	(256*1024)	/* regular stack	  */
+/*============================================================================*/
+
+/*
+ * Serial Driver info
+ */
+/*============================================================================*/
+#define CFG_NS16550			/* Include NS16550 as serial driver */
+#define CFG_NS16550_SERIAL
+#define CFG_NS16550_REG_SIZE 	4		/* NS16550 register size */
+#define CFG_NS16550_COM1 	0X01C20000	/* Base address of UART0  */
+#define CFG_NS16550_CLK 	27000000	/* Input clock to NS16550 */
+#define CONFIG_CONS_INDEX	1		/* use UART0 for console  */
+#define CONFIG_BAUDRATE		115200		/* Default baud rate      */
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+/*============================================================================*/
+
+/* U-Boot Configurations */
+/*============================================================================*/
+/*
+ * If we are developing, we might want to start armboot from ram
+ * so we MUST NOT initialize critical regs like mem-timing ...
+ */
+/*#undef CONFIG_INIT_CRITICAL             undef for developing */
+
+#undef 	CONFIG_USE_IRQ				/* we don't need IRQ/FIQ */
+#define CONFIG_MISC_INIT_R
+#define CONFIG_BOOTDELAY	  3     	/* Boot delay before OS boot*/
+#define CONFIG_BOOTFILE		"uImage"	/* file to load */
+#define CFG_LONGHELP				/* undef to save memory     */
+#define CFG_PROMPT	"DaVinci EVM # "	/* Monitor Command Prompt   */
+#define CFG_CBSIZE	1024			/* Console I/O Buffer Size  */
+#define CFG_PBSIZE	(CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print buffer sz */
+#define CFG_MAXARGS	16		/* max number of command args   */
+#define CFG_BARGSIZE	CFG_CBSIZE	/* Boot Argument Buffer Size    */
+#undef	CFG_CLKS_IN_HZ			/* Clock info are in HZ */
+#define CFG_LOAD_ADDR	0x80700000	/* default load address of Linux */
+
+/*
+ *  I2C Configuration 
+ */
+#define CONFIG_HARD_I2C
+#define CFG_I2C_SPEED 100000
+#define CFG_I2C_SLAVE 10
+#define CONFIG_DRIVER_DAVINCI_I2C
+
+/* macro to read the 32 bit timer Timer 2 */
+#define READ_TIMER (0xFFFFFFFF - (*(volatile ulong *)(CFG_TIMERBASE + 0x14)))
+
+/* Linux Information */
+
+#define LINUX_BOOT_PARAM_ADDR	0x80000100	/* Set the Boot location at the
+						 * end of DDR
+						 */
+#define CONFIG_CMDLINE_TAG	  1	/* enable passing of ATAGs  */
+#define CONFIG_SETUP_MEMORY_TAGS  1
+#define CONFIG_BOOTARGS		"mem=120M console=ttyS0,115200n8 root=/dev/ram0 rw init=/bin/ash initrd=0x82000000,4M"
+
+#define CONFIG_BOOTCOMMAND	"dhcp;tftpboot 0x82000000 initrd.image;setenv addip setenv bootargs \$(bootargs) ip=\$(ipaddr):\$(serverip):\$(gatewayip):\$(netmask):\$(hostname)::off eth=\$(ethaddr) video=dm64xxfb:output=\$(videostd);run addip;bootm 0x80700000"
+
+/*============================================================================*/
+
+/*
+ * Network & Ethernet Configuration
+ */
+/*============================================================================*/
+#define CONFIG_DRIVER_TI_EMAC
+
+#define CONFIG_BOOTP_MASK	(CONFIG_BOOTP_DEFAULT | CONFIG_BOOTP_DNS | CONFIG_BOOTP_DNS2 | CONFIG_BOOTP_SEND_HOSTNAME)
+#define CONFIG_NET_RETRY_COUNT  10
+/*============================================================================*/
+
+/*============================================================================*/
+
+/* NAND Flash stuff */
+/*============================================================================*/
+#define CONFIG_SKIP_LOWLEVEL_INIT       
+#ifdef CFG_ENV_IS_IN_NAND
+#define CONFIG_COMMANDS		(CFG_CMD_DFL | CFG_CMD_ENV | CFG_CMD_NAND | CFG_CMD_LOADB | CFG_CMD_LOADS | CFG_CMD_MEMORY | CFG_CMD_ASKENV | CFG_CMD_RUN | CFG_CMD_AUTOSCRIPT | CFG_CMD_BDI | CFG_CMD_CONSOLE | CFG_CMD_IMI | CFG_CMD_BOOTD | CFG_CMD_MISC | CFG_CMD_PING | CFG_CMD_DHCP | CFG_CMD_NET )
+#define CONFIG_SKIP_LOWLEVEL_INIT       /* needed for booting from NAND as UBL
+					 * bootloads u-boot.  The low level init
+					 * is configured by the UBL.
+					 */
+#define CFG_NAND_ADDR           0x02000000
+#define CFG_NAND_BASE           0x02000000
+
+#define CFG_MAX_NAND_DEVICE     1	/* Max number of NAND devices */
+#define SECTORSIZE              512
+
+#define ADDR_COLUMN             1
+#define ADDR_PAGE               2
+#define ADDR_COLUMN_PAGE        3
+
+#define NAND_ChipID_UNKNOWN     0x00
+#define NAND_MAX_FLOORS         1
+#define NAND_MAX_CHIPS          1
+#define CFG_ENV_OFFSET	        0x60000 //0x40000 /* environment starts here  */
+
+#define WRITE_NAND_COMMAND(d, adr) do {*(volatile u8 *)0x02000010 = (u8)d;} while(0)
+#define WRITE_NAND_ADDRESS(d, adr) do {*(volatile u8 *)0x0200000A = (u8)d;} while(0)
+#define WRITE_NAND(d, adr) do {*(volatile u8 *)0x02000000 = (u8)d;} while(0)
+#define READ_NAND(adr) (*(volatile u8 *)0x02000000)
+#define NAND_WAIT_READY(nand) while (!((*(volatile u32 *)0x01E00064) & 1))
+
+#define NAND_NO_RB          1
+
+#define NAND_CTL_CLRALE(nandptr) do {} while(0)
+#define NAND_CTL_SETALE(nandptr) do {} while(0)
+#define NAND_CTL_CLRCLE(nandptr) do {} while(0)
+#define NAND_CTL_SETCLE(nandptr) do {} while(0)
+#define NAND_DISABLE_CE(nand) do {*(volatile u32 *)0x01E00060 &= ~0x01;} while(0)
+#define NAND_ENABLE_CE(nand) do {*(volatile u32 *)0x01E00060 |= 0x01;} while(0)
+#else
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_DHCP)
+#endif
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+/* KGDB support */
+/*============================================================================*/
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	1	/* which serial port to use */
+#endif
+#endif /* __CONFIG_H */
diff -Nurd u-boot-1.2.0/include/configs/dm355_evm.h u-boot-1.2.0-leopard/include/configs/dm355_evm.h
--- u-boot-1.2.0/include/configs/dm355_evm.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/configs/dm355_evm.h	2007-12-04 07:50:49.000000000 -0300
@@ -0,0 +1,227 @@
+/*
+ * (C) Copyright 2003
+ * Texas Instruments.
+ * Swaminathan S <swami.iyer@ti.com>
+ * Configuation settings for the TI DM350 EVM board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/* Chip Configurations */
+/*============================================================================*/
+#define CFG_DM355_EVM
+#define CONFIG_ARM926EJS	/* This is an arm926ejs CPU core  	  */
+#define CONFIG_SYS_CLK_FREQ	216000000	/* Arm Clock frequency    */
+#define CFG_TIMERBASE		0x01C21400	/* use timer 0 		  */
+#define CFG_HZ			24000000	/* Timer Input clock freq */	
+/*============================================================================*/
+
+/* Flash Boot info */
+/*============================================================================*/
+//#define CFG_ENV_IS_IN_FLASH 	1		/* U-Boot env in NOR Flash   */
+
+#define CFG_NO_FLASH    1
+#ifndef CFG_ENV_IS_IN_FLASH
+#define CONFIG_INITRD_TAG  	1
+#define CFG_ENV_IS_IN_NAND 	1               /* U-Boot env in NAND Flash  */
+#define CFG_ENV_SECT_SIZE	0x40000		    /* Env sector Size */
+#define CFG_ENV_SIZE		(16 * 1024)
+#else
+#define CONFIG_INITRD_TAG  	1
+#define CFG_ENV_SECT_SIZE	CFG_FLASH_SECT_SZ	/* Env sector Size */
+#define CFG_ENV_SIZE		CFG_FLASH_SECT_SZ
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + 0x40000)
+#endif
+
+
+/*
+ * NOR Flash Info 
+ */
+/*============================================================================*/
+#define CONFIG_CS1_BOOT				/* Boot from Flash 	     */
+#define CFG_MAX_FLASH_BANKS	1		/* max number of flash banks */
+#define CFG_FLASH_CFI
+#define CFG_FLASH_SECT_SZ	0x20000		/* 128KB sect size Intel Flash */
+
+#ifdef CONFIG_CS0_BOOT
+#define PHYS_FLASH_1		0x02000000	/* CS0 Base address 	 */
+#endif
+#ifdef CONFIG_CS1_BOOT
+#define PHYS_FLASH_1		0x04000000	/* Need to update CHECK  */
+#endif
+#define CFG_FLASH_BASE		PHYS_FLASH_1 	/* Flash Base for U-Boot */
+#define CFG_CPLD            (CFG_FLASH_BASE + (0x1c000 << 0))
+#define CONFIG_ENV_OVERWRITE			/* allow env overwrie 	 */
+#define PHYS_FLASH_SIZE		0x2000000	/* Flash size 16MB 	 */
+#define CFG_MAX_FLASH_SECT	256		/* max sectors on flash  */
+						/* Intel 28F128P30T has  */
+						/* 131 sectors, 256      */
+						/* is used for backwards */
+						/* compatibility with    */
+						/* AMD AMLV256U on early */
+						/* boards.               */
+#if(0)
+#define CFG_MAX_FLASH_SECT	(PHYS_FLASH_SIZE/CFG_FLASH_SECT_SZ)
+#endif
+#define CFG_FLASH_ERASE_TOUT	(20*CFG_HZ)	/* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(20*CFG_HZ)	/* Timeout for Flash Write */
+/*============================================================================*/
+
+/*
+ * Memory Info 
+ */
+/*============================================================================*/
+#define CFG_MALLOC_LEN		(0x40000 + 128*1024)  /* malloc () len */
+#define CFG_GBL_DATA_SIZE	128		/* reserved for initial data */
+#define CFG_MEMTEST_START	0x82000000	/* memtest start address  */
+#define CFG_MEMTEST_END		0x90000000	/* 16MB RAM test   	  */
+#define CONFIG_NR_DRAM_BANKS	1		/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x80000000	/* DDR Start 		  */
+#define PHYS_SDRAM_1_SIZE	0x8000000	/* DDR size 128MB 	  */
+#define CONFIG_STACKSIZE	(256*1024)	/* regular stack	  */
+/*============================================================================*/
+
+/*
+ * Serial Driver info
+ */
+/*============================================================================*/
+#define CFG_NS16550			/* Include NS16550 as serial driver */
+#define CFG_NS16550_SERIAL
+#define CFG_NS16550_REG_SIZE 	4		/* NS16550 register size */
+#define CFG_NS16550_COM1 	0x01C20000	/* Base address of UART0  */
+#define CFG_NS16550_CLK 	24000000	/* Input clock to NS16550 */
+#define CONFIG_CONS_INDEX	1		/* use UART0 for console  */
+#define CONFIG_BAUDRATE		115200		/* Default baud rate      */
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+/*============================================================================*/
+
+/* U-Boot Configurations */
+/*============================================================================*/
+/*
+ * If we are developing, we might want to start armboot from ram
+ * so we MUST NOT initialize critical regs like mem-timing ...
+ */
+/*#undef CONFIG_INIT_CRITICAL             undef for developing */
+
+#undef 	CONFIG_USE_IRQ				/* we don't need IRQ/FIQ */
+#define CONFIG_MISC_INIT_R
+#define CONFIG_BOOTDELAY	  3     	/* Boot delay before OS boot*/
+#define CONFIG_BOOTFILE		"uImage"	/* file to load */
+#define CFG_LONGHELP				/* undef to save memory     */
+#define CFG_PROMPT	"DM355 EVM # "	/* Monitor Command Prompt   */
+#define CFG_CBSIZE	1024			/* Console I/O Buffer Size  */
+#define CFG_PBSIZE	(CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print buffer sz */
+#define CFG_MAXARGS	16		/* max number of command args   */
+#define CFG_BARGSIZE	CFG_CBSIZE	/* Boot Argument Buffer Size    */
+#undef	CFG_CLKS_IN_HZ			/* Clock info are in HZ */
+#define CFG_LOAD_ADDR	0x80700000	/* default load address of Linux */
+
+/*
+ *  I2C Configuration 
+ */
+/*#define CONFIG_HARD_I2C */
+#define CFG_I2C_SPEED 100000
+#define CFG_I2C_SLAVE 10
+/*#define CONFIG_DRIVER_DAVINCI_I2C */
+
+/* macro to read the 32 bit timer Timer 2 */
+#define READ_TIMER (0xFFFFFFFF - (*(volatile ulong *)(CFG_TIMERBASE + 0x14)))
+
+/* Linux Information */
+
+#define LINUX_BOOT_PARAM_ADDR	0x80000100	/* Set the Boot location at the
+						 * end of DDR
+						 */
+#define CONFIG_CMDLINE_TAG	  1	/* enable passing of ATAGs  */
+#define CONFIG_SETUP_MEMORY_TAGS  1
+#define CONFIG_BOOTARGS		"ip=dhcp mem=120M console=ttyS0,115200n8 root=/dev/ram0 rw initrd=0x82000000,4M"
+
+#define CONFIG_BOOTCOMMAND	"dhcp;tftpboot 0x82000000 initrd.image;setenv addip setenv bootargs \$(bootargs) ip=\$(ipaddr):\$(serverip):\$(gatewayip):\$(netmask):\$(hostname)::off eth=\$(ethaddr) video=dm64xxfb:output=\$(videostd);run addip;bootm 0x80700000"
+
+/*============================================================================*/
+
+/*
+ * Network & Ethernet Configuration
+ */
+/*============================================================================*/
+#define CONFIG_DM9000_BASE    0x04014000
+
+#define DM9000_IO        CONFIG_DM9000_BASE
+
+#define DM9000_DATA     (CONFIG_DM9000_BASE+2)
+
+/* #define CONFIG_DM9000_USE_8BIT */
+
+#define CONFIG_DM9000_USE_16BIT
+
+/* #define CONFIG_DM9000_USE_32BIT */
+
+#define CONFIG_DRIVER_DM9000
+
+#define CONFIG_BOOTP_MASK	(CONFIG_BOOTP_DEFAULT | CONFIG_BOOTP_DNS | CONFIG_BOOTP_DNS2 | CONFIG_BOOTP_SEND_HOSTNAME)
+#define CONFIG_NET_RETRY_COUNT  10
+/*============================================================================*/
+
+/*============================================================================*/
+
+/* NAND Flash stuff */
+/*============================================================================*/
+#ifdef CFG_ENV_IS_IN_NAND
+#define CONFIG_COMMANDS		(CFG_CMD_DFL | CFG_CMD_ENV | CFG_CMD_NAND | CFG_CMD_LOADB | CFG_CMD_LOADS | CFG_CMD_MEMORY | CFG_CMD_ASKENV | CFG_CMD_RUN | CFG_CMD_AUTOSCRIPT | CFG_CMD_BDI | CFG_CMD_CONSOLE | CFG_CMD_IMI | CFG_CMD_BOOTD | CFG_CMD_MISC | CFG_CMD_PING | CFG_CMD_DHCP | CFG_CMD_NET )
+#define CONFIG_SKIP_LOWLEVEL_INIT        /*needed for booting from NAND as UBL
+					 * bootloads u-boot.  The low level init
+					 * is configured by the UBL.*/
+					 
+#define CFG_NAND_ADDR           0x02000000
+#define CFG_NAND_BASE           0x02000000
+
+#define CFG_MAX_NAND_DEVICE     2	/* Max number of NAND devices */
+#define SECTORSIZE              (2048 * 2)
+
+#define ADDR_COLUMN             1
+#define ADDR_PAGE               2
+#define ADDR_COLUMN_PAGE        3
+
+#define NAND_ChipID_UNKNOWN     0x00
+#define NAND_MAX_FLOORS         2
+#define NAND_MAX_CHIPS          2
+#define CFG_ENV_BLOCK           15          /* environment starts from this block */
+#define CFG_ENV_OFFSET	        (0x1e0000)  /* environment starts here  */
+
+#define CFG_NAND_BASE_LIST      {CFG_NAND_BASE, CFG_NAND_BASE+0x4000}
+#define CONFIG_MTD_DEBUG
+#define CONFIG_MTD_DEBUG_VERBOSE 1
+
+#else
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_DHCP)
+#endif
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+/* KGDB support */
+/*============================================================================*/
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+#endif /* __CONFIG_H */
diff -Nurd u-boot-1.2.0/include/configs/dm355_ipnc.h u-boot-1.2.0-leopard/include/configs/dm355_ipnc.h
--- u-boot-1.2.0/include/configs/dm355_ipnc.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/configs/dm355_ipnc.h	2009-02-13 04:44:43.000000000 -0300
@@ -0,0 +1,234 @@
+/*
+ * (C) Copyright 2003
+ * Texas Instruments.
+ * Swaminathan S <swami.iyer@ti.com>
+ * Configuation settings for the TI DM350 EVM board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/* Chip Configurations */
+/*============================================================================*/
+#define CFG_DM355_IPNC
+#define CONFIG_ARM926EJS	/* This is an arm926ejs CPU core  	  */
+#define CONFIG_SYS_CLK_FREQ	216000000	/* Arm Clock frequency    */
+#define CFG_TIMERBASE		0x01C21400	/* use timer 0 		  */
+#define CFG_HZ			24000000	/* Timer Input clock freq */	
+/*============================================================================*/
+
+/* Flash Boot info */
+/*============================================================================*/
+//#define CFG_ENV_IS_IN_FLASH 	1		/* U-Boot env in NOR Flash   */
+
+#define CFG_NO_FLASH    1
+#ifndef CFG_ENV_IS_IN_FLASH
+#define CONFIG_INITRD_TAG  	1
+#define CFG_ENV_IS_IN_NAND 	1               /* U-Boot env in NAND Flash  */
+#define CFG_ENV_SECT_SIZE	0x40000		    /* Env sector Size */
+#define CFG_ENV_SIZE		(16 * 1024)
+#else
+#define CONFIG_INITRD_TAG  	1
+#define CFG_ENV_SECT_SIZE	CFG_FLASH_SECT_SZ	/* Env sector Size */
+#define CFG_ENV_SIZE		CFG_FLASH_SECT_SZ
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + 0x40000)
+#endif
+
+
+/*
+ * NOR Flash Info 
+ */
+/*============================================================================*/
+#define CONFIG_CS1_BOOT				/* Boot from Flash 	     */
+#define CFG_MAX_FLASH_BANKS	1		/* max number of flash banks */
+#define CFG_FLASH_CFI
+#define CFG_FLASH_SECT_SZ	0x20000		/* 128KB sect size Intel Flash */
+
+#ifdef CONFIG_CS0_BOOT
+#define PHYS_FLASH_1		0x02000000	/* CS0 Base address 	 */
+#endif
+#ifdef CONFIG_CS1_BOOT
+#define PHYS_FLASH_1		0x04000000	/* Need to update CHECK  */
+#endif
+#define CFG_FLASH_BASE		PHYS_FLASH_1 	/* Flash Base for U-Boot */
+#define CFG_CPLD            (CFG_FLASH_BASE + (0x1c000 << 0))
+#define CONFIG_ENV_OVERWRITE			/* allow env overwrie 	 */
+#define PHYS_FLASH_SIZE		0x2000000	/* Flash size 16MB 	 */
+#define CFG_MAX_FLASH_SECT	256		/* max sectors on flash  */
+						/* Intel 28F128P30T has  */
+						/* 131 sectors, 256      */
+						/* is used for backwards */
+						/* compatibility with    */
+						/* AMD AMLV256U on early */
+						/* boards.               */
+#if(0)
+#define CFG_MAX_FLASH_SECT	(PHYS_FLASH_SIZE/CFG_FLASH_SECT_SZ)
+#endif
+#define CFG_FLASH_ERASE_TOUT	(20*CFG_HZ)	/* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(20*CFG_HZ)	/* Timeout for Flash Write */
+/*============================================================================*/
+
+/*
+ * Memory Info 
+ */
+/*============================================================================*/
+#define CFG_MALLOC_LEN		(0x40000 + 128*1024)  /* malloc () len */
+#define CFG_GBL_DATA_SIZE	128		/* reserved for initial data */
+#define CFG_MEMTEST_START	0x82000000	/* memtest start address  */
+#define CFG_MEMTEST_END		0x90000000	/* 16MB RAM test   	  */
+#define CONFIG_NR_DRAM_BANKS	1		/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x80000000	/* DDR Start 		  */
+#define PHYS_SDRAM_1_SIZE	0x8000000	/* DDR size 128MB 	  */
+#define CONFIG_STACKSIZE	(256*1024)	/* regular stack	  */
+/*============================================================================*/
+
+/*
+ * Serial Driver info
+ */
+/*============================================================================*/
+#define CFG_NS16550			/* Include NS16550 as serial driver */
+#define CFG_NS16550_SERIAL
+#define CFG_NS16550_REG_SIZE 	4		/* NS16550 register size */
+#define CFG_NS16550_COM1 	0x01C20000	/* Base address of UART0  */
+#define CFG_NS16550_COM2 	0x01C20400	/* Base address of UART1  */
+#define CFG_NS16550_CLK 	24000000	/* Input clock to NS16550 */
+#define CONFIG_CONS_INDEX	1 /* use UART0 for console */ //1		/* use UART0 for console  */
+#define CONFIG_BAUDRATE		115200		/* Default baud rate      */
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+/*============================================================================*/
+
+/* U-Boot Configurations */
+/*============================================================================*/
+/*
+ * If we are developing, we might want to start armboot from ram
+ * so we MUST NOT initialize critical regs like mem-timing ...
+ */
+/*#undef CONFIG_INIT_CRITICAL             undef for developing */
+
+#undef 	CONFIG_USE_IRQ				/* we don't need IRQ/FIQ */
+#define CONFIG_MISC_INIT_R
+#define CONFIG_BOOTDELAY	  3     	/* Boot delay before OS boot*/
+#define CONFIG_BOOTFILE		"uImage"	/* file to load */
+#define CFG_LONGHELP				/* undef to save memory     */
+#define CFG_PROMPT	"DM355 IPNC # "	/* Monitor Command Prompt   */
+#define CFG_CBSIZE	1024			/* Console I/O Buffer Size  */
+#define CFG_PBSIZE	(CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print buffer sz */
+#define CFG_MAXARGS	16		/* max number of command args   */
+#define CFG_BARGSIZE	CFG_CBSIZE	/* Boot Argument Buffer Size    */
+#undef	CFG_CLKS_IN_HZ			/* Clock info are in HZ */
+#define CFG_LOAD_ADDR	0x80700000	/* default load address of Linux */
+
+/*
+ *  I2C Configuration 
+ */
+/*#define CONFIG_HARD_I2C */
+#define CFG_I2C_SPEED 100000
+#define CFG_I2C_SLAVE 10
+/*#define CONFIG_DRIVER_DAVINCI_I2C */
+
+/* macro to read the 32 bit timer Timer 2 */
+#define READ_TIMER (0xFFFFFFFF - (*(volatile ulong *)(CFG_TIMERBASE + 0x14)))
+
+/* Linux Information */
+
+#define LINUX_BOOT_PARAM_ADDR	0x80000100	/* Set the Boot location at the
+						 * end of DDR
+						 */
+#define CONFIG_CMDLINE_TAG	  1	/* enable passing of ATAGs  */
+#define CONFIG_SETUP_MEMORY_TAGS  1
+#define CONFIG_BOOTARGS		"ip=dhcp mem=80M console=ttyS1,115200n8 root=/dev/ram0 rw initrd=0x82000000,8M"
+
+#define CONFIG_BOOTCOMMAND	"tftpboot 0x82000000 ramdisk.gz;setenv addip setenv bootargs \$(bootargs) ip=\$(ipaddr):\$(serverip):\$(gatewayip):\$(netmask):\$(hostname)::off eth=\$(ethaddr) video=dm64xxfb:output=\$(videostd);run addip;bootm 0x80700000"
+
+/*============================================================================*/
+
+/*
+ * Network & Ethernet Configuration
+ */
+/*============================================================================*/
+#define CONFIG_DM9000_BASE    0x04000000
+
+#define DM9000_IO        CONFIG_DM9000_BASE
+
+#define DM9000_DATA     (CONFIG_DM9000_BASE+16)
+
+/* #define CONFIG_DM9000_USE_8BIT */
+
+#define CONFIG_DM9000_USE_16BIT
+
+/* #define CONFIG_DM9000_USE_32BIT */
+
+#define CONFIG_DRIVER_DM9000
+
+#define CONFIG_BOOTP_MASK	(CONFIG_BOOTP_DEFAULT | CONFIG_BOOTP_DNS | CONFIG_BOOTP_DNS2 | CONFIG_BOOTP_SEND_HOSTNAME)
+#define CONFIG_NET_RETRY_COUNT  10
+/*============================================================================*/
+
+/*============================================================================*/
+
+/* NAND Flash stuff */
+/*============================================================================*/
+#ifdef CFG_ENV_IS_IN_NAND
+#define CONFIG_COMMANDS		(CFG_CMD_DFL | CFG_CMD_ENV | CFG_CMD_NAND | CFG_CMD_LOADB | CFG_CMD_LOADS | CFG_CMD_MEMORY | CFG_CMD_ASKENV | CFG_CMD_RUN | CFG_CMD_AUTOSCRIPT | CFG_CMD_BDI | CFG_CMD_CONSOLE | CFG_CMD_IMI | CFG_CMD_BOOTD | CFG_CMD_MISC | CFG_CMD_PING | CFG_CMD_DHCP | CFG_CMD_NET )
+#define CONFIG_SKIP_LOWLEVEL_INIT        /*needed for booting from NAND as UBL
+					 * bootloads u-boot.  The low level init
+					 * is configured by the UBL.*/
+					 
+#define CFG_NAND_ADDR           0x02000000
+#define CFG_NAND_BASE           0x02000000
+
+#define CFG_MAX_NAND_DEVICE     1	/* Max number of NAND devices */
+#define SECTORSIZE              2048 //512 //(2048 * 2)
+
+#define ADDR_COLUMN             1
+#define ADDR_PAGE               2
+#define ADDR_COLUMN_PAGE        3
+
+#define NAND_ChipID_UNKNOWN     0x00
+#define NAND_MAX_FLOORS         1
+#define NAND_MAX_CHIPS          1
+#define CFG_ENV_BLOCK           20          /* environment starts from this block */
+#define CFG_ENV_OFFSET	        (0x50000)//(0x1e0000)  /* environment starts here  */
+
+#define CFG_NAND_BASE_LIST      {CFG_NAND_BASE, CFG_NAND_BASE+0x4000}
+#define CONFIG_MTD_DEBUG
+#define CONFIG_MTD_DEBUG_VERBOSE 1
+
+#else
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_DHCP)
+#endif
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+/*
+ * Miscellaneous configurable options
+ */
+
+#define CONFIG_VERSION_VARIABLE 1	/* include version env variable */
+#define CONFIG_IDENT_STRING " BASSET-1.0.0"
+
+/* KGDB support */
+/*============================================================================*/
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+#endif /* __CONFIG_H */
diff -Nurd u-boot-1.2.0/include/configs/dm355_leopard.h u-boot-1.2.0-leopard/include/configs/dm355_leopard.h
--- u-boot-1.2.0/include/configs/dm355_leopard.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/configs/dm355_leopard.h	2009-03-10 02:19:29.000000000 -0300
@@ -0,0 +1,234 @@
+/*
+ * (C) Copyright 2003
+ * Texas Instruments.
+ * Swaminathan S <swami.iyer@ti.com>
+ * Configuation settings for the TI DM350 EVM board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/* Chip Configurations */
+/*============================================================================*/
+#define CFG_DM355_LEOPARD
+#define CONFIG_ARM926EJS	/* This is an arm926ejs CPU core  	  */
+#define CONFIG_SYS_CLK_FREQ	216000000	/* Arm Clock frequency    */
+#define CFG_TIMERBASE		0x01C21400	/* use timer 0 		  */
+#define CFG_HZ			24000000	/* Timer Input clock freq */	
+/*============================================================================*/
+
+/* Flash Boot info */
+/*============================================================================*/
+//#define CFG_ENV_IS_IN_FLASH 	1		/* U-Boot env in NOR Flash   */
+
+#define CFG_NO_FLASH    1
+#ifndef CFG_ENV_IS_IN_FLASH
+#define CONFIG_INITRD_TAG  	1
+#define CFG_ENV_IS_IN_NAND 	1               /* U-Boot env in NAND Flash  */
+#define CFG_ENV_SECT_SIZE	0x40000		    /* Env sector Size */
+#define CFG_ENV_SIZE		(16 * 1024)
+#else
+#define CONFIG_INITRD_TAG  	1
+#define CFG_ENV_SECT_SIZE	CFG_FLASH_SECT_SZ	/* Env sector Size */
+#define CFG_ENV_SIZE		CFG_FLASH_SECT_SZ
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + 0x40000)
+#endif
+
+
+/*
+ * NOR Flash Info 
+ */
+/*============================================================================*/
+#define CONFIG_CS1_BOOT				/* Boot from Flash 	     */
+#define CFG_MAX_FLASH_BANKS	1		/* max number of flash banks */
+#define CFG_FLASH_CFI
+#define CFG_FLASH_SECT_SZ	0x20000		/* 128KB sect size Intel Flash */
+
+#ifdef CONFIG_CS0_BOOT
+#define PHYS_FLASH_1		0x02000000	/* CS0 Base address 	 */
+#endif
+#ifdef CONFIG_CS1_BOOT
+#define PHYS_FLASH_1		0x04000000	/* Need to update CHECK  */
+#endif
+#define CFG_FLASH_BASE		PHYS_FLASH_1 	/* Flash Base for U-Boot */
+#define CFG_CPLD            (CFG_FLASH_BASE + (0x1c000 << 0))
+#define CONFIG_ENV_OVERWRITE			/* allow env overwrie 	 */
+#define PHYS_FLASH_SIZE		0x2000000	/* Flash size 16MB 	 */
+#define CFG_MAX_FLASH_SECT	256		/* max sectors on flash  */
+						/* Intel 28F128P30T has  */
+						/* 131 sectors, 256      */
+						/* is used for backwards */
+						/* compatibility with    */
+						/* AMD AMLV256U on early */
+						/* boards.               */
+#if(0)
+#define CFG_MAX_FLASH_SECT	(PHYS_FLASH_SIZE/CFG_FLASH_SECT_SZ)
+#endif
+#define CFG_FLASH_ERASE_TOUT	(20*CFG_HZ)	/* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(20*CFG_HZ)	/* Timeout for Flash Write */
+/*============================================================================*/
+
+/*
+ * Memory Info 
+ */
+/*============================================================================*/
+#define CFG_MALLOC_LEN		(0x40000 + 128*1024)  /* malloc () len */
+#define CFG_GBL_DATA_SIZE	128		/* reserved for initial data */
+#define CFG_MEMTEST_START	0x82000000	/* memtest start address  */
+#define CFG_MEMTEST_END		0x90000000	/* 16MB RAM test   	  */
+#define CONFIG_NR_DRAM_BANKS	1		/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x80000000	/* DDR Start 		  */
+#define PHYS_SDRAM_1_SIZE	0x8000000	/* DDR size 128MB 	  */
+#define CONFIG_STACKSIZE	(256*1024)	/* regular stack	  */
+/*============================================================================*/
+
+/*
+ * Serial Driver info
+ */
+/*============================================================================*/
+#define CFG_NS16550			/* Include NS16550 as serial driver */
+#define CFG_NS16550_SERIAL
+#define CFG_NS16550_REG_SIZE 	4		/* NS16550 register size */
+#define CFG_NS16550_COM1 	0x01C20000	/* Base address of UART0  */
+#define CFG_NS16550_COM2 	0x01C20400	/* Base address of UART1  */
+#define CFG_NS16550_CLK 	24000000	/* Input clock to NS16550 */
+#define CONFIG_CONS_INDEX	1 /* use UART0 for console */ //1		/* use UART0 for console  */
+#define CONFIG_BAUDRATE		115200		/* Default baud rate      */
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+/*============================================================================*/
+
+/* U-Boot Configurations */
+/*============================================================================*/
+/*
+ * If we are developing, we might want to start armboot from ram
+ * so we MUST NOT initialize critical regs like mem-timing ...
+ */
+/*#undef CONFIG_INIT_CRITICAL             undef for developing */
+
+#undef 	CONFIG_USE_IRQ				/* we don't need IRQ/FIQ */
+#define CONFIG_MISC_INIT_R
+#define CONFIG_BOOTDELAY	  3     	/* Boot delay before OS boot*/
+#define CONFIG_BOOTFILE		"uImage"	/* file to load */
+#define CFG_LONGHELP				/* undef to save memory     */
+#define CFG_PROMPT	"DM355 LEOPARD# "	/* Monitor Command Prompt   */
+#define CFG_CBSIZE	1024			/* Console I/O Buffer Size  */
+#define CFG_PBSIZE	(CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print buffer sz */
+#define CFG_MAXARGS	16		/* max number of command args   */
+#define CFG_BARGSIZE	CFG_CBSIZE	/* Boot Argument Buffer Size    */
+#undef	CFG_CLKS_IN_HZ			/* Clock info are in HZ */
+#define CFG_LOAD_ADDR	0x80700000	/* default load address of Linux */
+
+/*
+ *  I2C Configuration 
+ */
+/*#define CONFIG_HARD_I2C */
+#define CFG_I2C_SPEED 100000
+#define CFG_I2C_SLAVE 10
+/*#define CONFIG_DRIVER_DAVINCI_I2C */
+
+/* macro to read the 32 bit timer Timer 2 */
+#define READ_TIMER (0xFFFFFFFF - (*(volatile ulong *)(CFG_TIMERBASE + 0x14)))
+
+/* Linux Information */
+
+#define LINUX_BOOT_PARAM_ADDR	0x80000100	/* Set the Boot location at the
+						 * end of DDR
+						 */
+#define CONFIG_CMDLINE_TAG	  1	/* enable passing of ATAGs  */
+#define CONFIG_SETUP_MEMORY_TAGS  1
+#define CONFIG_BOOTARGS		"ip=dhcp mem=80M console=ttyS0,115200n8 root=/dev/ram0 rw initrd=0x82000000,8M"
+
+#define CONFIG_BOOTCOMMAND	"tftpboot 0x82000000 ramdisk.gz;setenv addip setenv bootargs \$(bootargs) ip=\$(ipaddr):\$(serverip):\$(gatewayip):\$(netmask):\$(hostname)::off eth=\$(ethaddr) video=dm64xxfb:output=\$(videostd);run addip;bootm 0x80700000"
+
+/*============================================================================*/
+
+/*
+ * Network & Ethernet Configuration
+ */
+/*============================================================================*/
+#define CONFIG_DM9000_BASE    0x04000000
+
+#define DM9000_IO        CONFIG_DM9000_BASE
+
+#define DM9000_DATA     (CONFIG_DM9000_BASE+16)
+
+/* #define CONFIG_DM9000_USE_8BIT */
+
+#define CONFIG_DM9000_USE_16BIT
+
+/* #define CONFIG_DM9000_USE_32BIT */
+
+#define CONFIG_DRIVER_DM9000
+
+#define CONFIG_BOOTP_MASK	(CONFIG_BOOTP_DEFAULT | CONFIG_BOOTP_DNS | CONFIG_BOOTP_DNS2 | CONFIG_BOOTP_SEND_HOSTNAME)
+#define CONFIG_NET_RETRY_COUNT  10
+/*============================================================================*/
+
+/*============================================================================*/
+
+/* NAND Flash stuff */
+/*============================================================================*/
+#ifdef CFG_ENV_IS_IN_NAND
+#define CONFIG_COMMANDS		(CFG_CMD_DFL | CFG_CMD_ENV | CFG_CMD_NAND | CFG_CMD_LOADB | CFG_CMD_LOADS | CFG_CMD_MEMORY | CFG_CMD_ASKENV | CFG_CMD_RUN | CFG_CMD_AUTOSCRIPT | CFG_CMD_BDI | CFG_CMD_CONSOLE | CFG_CMD_IMI | CFG_CMD_BOOTD | CFG_CMD_MISC | CFG_CMD_PING | CFG_CMD_DHCP | CFG_CMD_NET )
+#define CONFIG_SKIP_LOWLEVEL_INIT        /*needed for booting from NAND as UBL
+					 * bootloads u-boot.  The low level init
+					 * is configured by the UBL.*/
+					 
+#define CFG_NAND_ADDR           0x02000000
+#define CFG_NAND_BASE           0x02000000
+
+#define CFG_MAX_NAND_DEVICE     1	/* Max number of NAND devices */
+#define SECTORSIZE              2048 //512 //(2048 * 2)
+
+#define ADDR_COLUMN             1
+#define ADDR_PAGE               2
+#define ADDR_COLUMN_PAGE        3
+
+#define NAND_ChipID_UNKNOWN     0x00
+#define NAND_MAX_FLOORS         1
+#define NAND_MAX_CHIPS          1
+#define CFG_ENV_BLOCK           20          /* environment starts from this block */
+#define CFG_ENV_OFFSET	        (0x50000)//(0x1e0000)  /* environment starts here  */
+
+#define CFG_NAND_BASE_LIST      {CFG_NAND_BASE, CFG_NAND_BASE+0x4000}
+#define CONFIG_MTD_DEBUG
+#define CONFIG_MTD_DEBUG_VERBOSE 1
+
+#else
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_DHCP)
+#endif
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+/*
+ * Miscellaneous configurable options
+ */
+
+#define CONFIG_VERSION_VARIABLE 1	/* include version env variable */
+#define CONFIG_IDENT_STRING "LEOPARD-1.0.0"
+
+/* KGDB support */
+/*============================================================================*/
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+#endif /* __CONFIG_H */
diff -Nurd u-boot-1.2.0/include/configs/dm700.h u-boot-1.2.0-leopard/include/configs/dm700.h
--- u-boot-1.2.0/include/configs/dm700.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/configs/dm700.h	2007-12-04 07:50:49.000000000 -0300
@@ -0,0 +1,204 @@
+/*
+ * (C) Copyright 2003
+ * Texas Instruments.
+ * Swaminathan S <swami.iyer@ti.com>
+ * Configuation settings for the TI DaVinci EVM board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/* Chip Configurations */
+/*============================================================================*/
+#define CFG_DAVINCI_HD
+#define CONFIG_ARM926EJS	/* This is an arm926ejs CPU core  	  */
+#define CONFIG_SYS_CLK_FREQ	297000000	/* Arm Clock frequency    */
+#define CFG_TIMERBASE		0x01C21400	/* use timer 0 		  */
+#define CFG_HZ			27000000	/* Timer Input clock freq */	
+/*============================================================================*/
+
+/* Flash Boot info */
+/*============================================================================*/
+/*#define CFG_ENV_IS_IN_FLASH 	1*/		/* U-Boot env in NOR Flash   */
+
+#ifndef CFG_ENV_IS_IN_FLASH
+#define CONFIG_INITRD_TAG  	1
+#define CFG_ENV_IS_IN_NAND 	1               /* U-Boot env in NAND Flash  */
+#define CFG_ENV_SECT_SIZE	512		/* Env sector Size */
+#define CFG_ENV_SIZE		(16 * 1024)
+#else
+#define CONFIG_INITRD_TAG  	1
+#define CFG_ENV_SECT_SIZE	CFG_FLASH_SECT_SZ	/* Env sector Size */
+#define CFG_ENV_SIZE		CFG_FLASH_SECT_SZ
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + 0x20000)
+#endif
+
+
+/*
+ * NOR Flash Info 
+ */
+/*============================================================================*/
+#define CONFIG_CS0_BOOT				/* Boot from Flash 	     */
+#define CFG_MAX_FLASH_BANKS	1		/* max number of flash banks */
+#define CFG_FLASH_SECT_SZ	0x20000		/* 128KB sect size Intel Flash */
+
+#ifdef CONFIG_CS0_BOOT
+#define PHYS_FLASH_1		0x02000000	/* CS0 Base address 	 */
+#endif
+#ifdef CONFIG_CS3_BOOT
+#define PHYS_FLASH_1		0x00000000	/* Need to update CHECK  */
+#endif
+#define CFG_FLASH_BASE		PHYS_FLASH_1 	/* Flash Base for U-Boot */
+#define CONFIG_ENV_OVERWRITE			/* allow env overwrie 	 */
+#define PHYS_FLASH_SIZE		0x1000000	/* Flash size 16MB 	 */
+#define CFG_MAX_FLASH_SECT	256		/* max sectors on flash  */
+						/* Intel 28F128P30T has  */
+						/* 131 sectors, 256      */
+						/* is used for backwards */
+						/* compatibility with    */
+						/* AMD AMLV256U on early */
+						/* boards.               */
+#if(0)
+#define CFG_MAX_FLASH_SECT	(PHYS_FLASH_SIZE/CFG_FLASH_SECT_SZ)
+#endif
+#define CFG_FLASH_ERASE_TOUT	(20*CFG_HZ)	/* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(20*CFG_HZ)	/* Timeout for Flash Write */
+/*============================================================================*/
+
+/*
+ * Memory Info 
+ */
+/*============================================================================*/
+#define CFG_MALLOC_LEN		(0x20000 + 128*1024)  /* malloc () len */
+#define CFG_GBL_DATA_SIZE	128		/* reserved for initial data */
+#define CFG_MEMTEST_START	0x82000000	/* memtest start address  */
+#define CFG_MEMTEST_END		0x90000000	/* 16MB RAM test   	  */
+#define CONFIG_NR_DRAM_BANKS	1		/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x80000000	/* DDR Start 		  */
+#define PHYS_SDRAM_1_SIZE	0x10000000	/* DDR size 256MB 	  */
+#define CONFIG_STACKSIZE	(256*1024)	/* regular stack	  */
+/*============================================================================*/
+
+/*
+ * Serial Driver info
+ */
+/*============================================================================*/
+#define CFG_NS16550			/* Include NS16550 as serial driver */
+#define CFG_NS16550_SERIAL
+#define CFG_NS16550_REG_SIZE 	4		/* NS16550 register size */
+#define CFG_NS16550_COM1 	0X01C20000	/* Base address of UART0  */
+#define CFG_NS16550_CLK 	27000000	/* Input clock to NS16550 */
+#define CONFIG_CONS_INDEX	1		/* use UART0 for console  */
+#define CONFIG_BAUDRATE		115200		/* Default baud rate      */
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+/*============================================================================*/
+
+/* U-Boot Configurations */
+/*============================================================================*/
+/*
+ * If we are developing, we might want to start armboot from ram
+ * so we MUST NOT initialize critical regs like mem-timing ...
+ */
+/*#undef CONFIG_INIT_CRITICAL             undef for developing */
+
+#undef 	CONFIG_USE_IRQ				/* we don't need IRQ/FIQ */
+#define CONFIG_MISC_INIT_R
+#define CONFIG_BOOTDELAY	  3     	/* Boot delay before OS boot*/
+#define CONFIG_BOOTFILE		"uImage"	/* file to load */
+#define CFG_LONGHELP				/* undef to save memory     */
+#define CFG_PROMPT	"DaVinci EVM # "	/* Monitor Command Prompt   */
+#define CFG_CBSIZE	1024			/* Console I/O Buffer Size  */
+#define CFG_PBSIZE	(CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print buffer sz */
+#define CFG_MAXARGS	16		/* max number of command args   */
+#define CFG_BARGSIZE	CFG_CBSIZE	/* Boot Argument Buffer Size    */
+#undef	CFG_CLKS_IN_HZ			/* Clock info are in HZ */
+#define CFG_LOAD_ADDR	0x80700000	/* default load address of Linux */
+
+/*
+ *  I2C Configuration 
+ */
+#define CONFIG_HARD_I2C
+#define CFG_I2C_SPEED 100000
+#define CFG_I2C_SLAVE 10
+#define CONFIG_DRIVER_DAVINCI_I2C
+
+/* macro to read the 32 bit timer Timer 2 */
+#define READ_TIMER (0xFFFFFFFF - (*(volatile ulong *)(CFG_TIMERBASE + 0x14)))
+
+/* Linux Information */
+
+#define LINUX_BOOT_PARAM_ADDR	0x80000100	/* Set the Boot location at the
+						 * end of DDR
+						 */
+#define CONFIG_CMDLINE_TAG	  1	/* enable passing of ATAGs  */
+#define CONFIG_SETUP_MEMORY_TAGS  1
+#define CONFIG_BOOTARGS		"mem=120M console=ttyS0,115200n8 root=/dev/ram0 rw init=/bin/ash initrd=0x82000000,4M"
+
+#define CONFIG_BOOTCOMMAND	"dhcp;tftpboot 0x82000000 initrd.image;setenv addip setenv bootargs \$(bootargs) ip=\$(ipaddr):\$(serverip):\$(gatewayip):\$(netmask):\$(hostname)::off eth=\$(ethaddr) video=dm64xxfb:output=\$(videostd);run addip;bootm 0x80700000"
+
+/*============================================================================*/
+
+/*
+ * Network & Ethernet Configuration
+ */
+/*============================================================================*/
+#define CONFIG_DRIVER_TI_EMAC
+
+#define CONFIG_BOOTP_MASK	(CONFIG_BOOTP_DEFAULT | CONFIG_BOOTP_DNS | CONFIG_BOOTP_DNS2 | CONFIG_BOOTP_SEND_HOSTNAME)
+#define CONFIG_NET_RETRY_COUNT  10
+/*============================================================================*/
+
+/*============================================================================*/
+
+/* NAND Flash stuff */
+/*============================================================================*/
+#ifdef CFG_ENV_IS_IN_NAND
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_DHCP | CFG_CMD_NAND)
+#define CONFIG_SKIP_LOWLEVEL_INIT       /* needed for booting from NAND as UBL
+					 * bootloads u-boot.  The low level init
+					 * is configured by the UBL.
+					 */
+#define CFG_NAND_BASE           0x42000000
+
+#define CFG_MAX_NAND_DEVICE     1	/* Max number of NAND devices */
+#define SECTORSIZE              2048
+
+#define ADDR_COLUMN             1
+#define ADDR_PAGE               2
+#define ADDR_COLUMN_PAGE        3
+
+#define NAND_MAX_FLOORS         1
+#define NAND_MAX_CHIPS          1
+#define CFG_ENV_OFFSET	        0x40000 /* environment starts here  */
+#else
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_DHCP)
+#endif
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+/* KGDB support */
+/*============================================================================*/
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	1	/* which serial port to use */
+#endif
+#endif /* __CONFIG_H */
diff -Nurd u-boot-1.2.0/include/configs/omap2420h4.h u-boot-1.2.0-leopard/include/configs/omap2420h4.h
--- u-boot-1.2.0/include/configs/omap2420h4.h	2007-01-06 20:13:11.000000000 -0300
+++ u-boot-1.2.0-leopard/include/configs/omap2420h4.h	2007-12-04 07:50:50.000000000 -0300
@@ -47,7 +47,7 @@
 /* On H4, NOR and NAND flash are mutual exclusive.
    Define this if you want to use NAND
  */
-/*#define CFG_NAND_BOOT */
+#define CFG_NAND_BOOT
 
 #ifdef CONFIG_APTIX
 #define V_SCLK                   1500000
diff -Nurd u-boot-1.2.0/include/flash.h u-boot-1.2.0-leopard/include/flash.h
--- u-boot-1.2.0/include/flash.h	2007-01-06 20:13:11.000000000 -0300
+++ u-boot-1.2.0-leopard/include/flash.h	2007-12-04 07:50:42.000000000 -0300
@@ -417,6 +417,7 @@
 #define FLASH_28F64K3	0x00B4		/* Intel 28F64K3   (  64M)		*/
 #define FLASH_28F128K3	0x00B6		/* Intel 28F128K3  ( 128M = 8M x 16 )	*/
 #define FLASH_28F256K3	0x00B8		/* Intel 28F256K3  ( 256M = 16M x 16 )	*/
+#define FLASH_28F128P30T        0x00BA          /* Intel 28F128P30 ( 128M = 128K x 155 + 32k x 4 */
 
 #define FLASH_28F320J3A 0x00C0		/* INTEL 28F320J3A ( 32M = 128K x  32)	*/
 #define FLASH_28F640J3A 0x00C2		/* INTEL 28F640J3A ( 64M = 128K x  64)	*/
@@ -427,6 +428,7 @@
 #define FLASH_MT28S4M16LC 0x00E1	/* Micron MT28S4M16LC			*/
 #define FLASH_S29GL064M 0x00F0		/* Spansion S29GL064M-R6		*/
 #define FLASH_S29GL128N 0x00F1		/* Spansion S29GL128N			*/
+#define FLASH_S29GL256N 0x00F2		/* Spansion S29GL128N			*/
 
 #define FLASH_UNKNOWN	0xFFFF		/* unknown flash type			*/
 
diff -Nurd u-boot-1.2.0/include/linux/mtd/nand.h u-boot-1.2.0-leopard/include/linux/mtd/nand.h
--- u-boot-1.2.0/include/linux/mtd/nand.h	2007-01-06 20:13:11.000000000 -0300
+++ u-boot-1.2.0-leopard/include/linux/mtd/nand.h	2007-12-04 07:50:51.000000000 -0300
@@ -2,10 +2,10 @@
  *  linux/include/linux/mtd/nand.h
  *
  *  Copyright (c) 2000 David Woodhouse <dwmw2@mvhi.com>
- *		       Steven J. Hill <sjhill@realitydiluted.com>
+ *                     Steven J. Hill <sjhill@realitydiluted.com>
  *		       Thomas Gleixner <tglx@linutronix.de>
  *
- * $Id: nand.h,v 1.68 2004/11/12 10:40:37 gleixner Exp $
+ * $Id: nand.h,v 1.72 2005/05/27 08:31:33 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -15,16 +15,16 @@
  *   Contains standard defines and IDs for NAND flash devices
  *
  *  Changelog:
- *   01-31-2000 DMW	Created
- *   09-18-2000 SJH	Moved structure out of the Disk-On-Chip drivers
+ *   01-31-2000 DMW     Created
+ *   09-18-2000 SJH     Moved structure out of the Disk-On-Chip drivers
  *			so it can be used by other NAND flash device
  *			drivers. I also changed the copyright since none
  *			of the original contents of this file are specific
  *			to DoC devices. David can whack me with a baseball
  *			bat later if I did something naughty.
- *   10-11-2000 SJH	Added private NAND flash structure for driver
- *   10-24-2000 SJH	Added prototype for 'nand_scan' function
- *   10-29-2001 TG	changed nand_chip structure to support
+ *   10-11-2000 SJH     Added private NAND flash structure for driver
+ *   10-24-2000 SJH     Added prototype for 'nand_scan' function
+ *   10-29-2001 TG	changed nand_chip structure to support 
  *			hardwarespecific function for accessing control lines
  *   02-21-2002 TG	added support for different read/write adress and
  *			ready/busy line access function
@@ -36,18 +36,24 @@
  *			CONFIG_MTD_NAND_ECC_JFFS2 is not set
  *   08-10-2002 TG	extensions to nand_chip structure to support HW-ECC
  *
- *   08-29-2002 tglx	nand_chip structure: data_poi for selecting
+ *   08-29-2002 tglx 	nand_chip structure: data_poi for selecting 
  *			internal / fs-driver buffer
  *			support for 6byte/512byte hardware ECC
  *			read_ecc, write_ecc extended for different oob-layout
  *			oob layout selections: NAND_NONE_OOB, NAND_JFFS2_OOB,
  *			NAND_YAFFS_OOB
  *  11-25-2002 tglx	Added Manufacturer code FUJITSU, NATIONAL
- *			Split manufacturer and device ID structures
+ *			Split manufacturer and device ID structures 
  *
- *  02-08-2004 tglx	added option field to nand structure for chip anomalities
- *  05-25-2004 tglx	added bad block table support, ST-MICRO manufacturer id
+ *  02-08-2004 tglx 	added option field to nand structure for chip anomalities
+ *  05-25-2004 tglx 	added bad block table support, ST-MICRO manufacturer id
  *			update of nand_chip structure description
+ *  01-17-2005 dmarlin	added extended commands for AG-AND device and added option 
+ * 			for BBT_AUTO_REFRESH.
+ *  01-20-2005 dmarlin	added optional pointer to hardware specific callback for 
+ *			extra error status checks.
+ *
+ *  11-01-2005 vwool	NAND page layouts introduces for HW ECC handling
  */
 #ifndef __LINUX_MTD_NAND_H
 #define __LINUX_MTD_NAND_H
@@ -75,7 +81,7 @@
  * Constants for hardware specific CLE/ALE/NCE function
 */
 /* Select the chip by setting nCE to low */
-#define NAND_CTL_SETNCE		1
+#define NAND_CTL_SETNCE 	1
 /* Deselect the chip by setting nCE to high */
 #define NAND_CTL_CLRNCE		2
 /* Select the command latch by setting CLE to high */
@@ -110,6 +116,25 @@
 #define NAND_CMD_READSTART	0x30
 #define NAND_CMD_CACHEDPROG	0x15
 
+/* Extended commands for AG-AND device */
+/* 
+ * Note: the command for NAND_CMD_DEPLETE1 is really 0x00 but 
+ *       there is no way to distinguish that from NAND_CMD_READ0
+ *       until the remaining sequence of commands has been completed
+ *       so add a high order bit and mask it off in the command.
+ */
+#define NAND_CMD_DEPLETE1	0x100
+#define NAND_CMD_DEPLETE2	0x38
+#define NAND_CMD_STATUS_MULTI	0x71
+#define NAND_CMD_STATUS_ERROR	0x72
+/* multi-bank error status (banks 0-3) */
+#define NAND_CMD_STATUS_ERROR0	0x73
+#define NAND_CMD_STATUS_ERROR1	0x74
+#define NAND_CMD_STATUS_ERROR2	0x75
+#define NAND_CMD_STATUS_ERROR3	0x76
+#define NAND_CMD_STATUS_RESET	0x7f
+#define NAND_CMD_STATUS_CLEAR	0xff
+
 /* Status bits */
 #define NAND_STATUS_FAIL	0x01
 #define NAND_STATUS_FAIL_N1	0x02
@@ -117,7 +142,7 @@
 #define NAND_STATUS_READY	0x40
 #define NAND_STATUS_WP		0x80
 
-/*
+/* 
  * Constants for ECC_MODES
  */
 
@@ -129,22 +154,40 @@
 #define NAND_ECC_HW3_256	2
 /* Hardware ECC 3 byte ECC per 512 Byte data */
 #define NAND_ECC_HW3_512	3
-/* Hardware ECC 3 byte ECC per 512 Byte data */
+/* Hardware ECC 6 byte ECC per 512 Byte data */
 #define NAND_ECC_HW6_512	4
 /* Hardware ECC 8 byte ECC per 512 Byte data */
 #define NAND_ECC_HW8_512	6
 /* Hardware ECC 12 byte ECC per 2048 Byte data */
 #define NAND_ECC_HW12_2048	7
+/* Hardware ECC 10 byte ECC per 512 Byte data */
+#define NAND_ECC_HW10_512	8
+
+struct page_layout_item {
+	int length;
+	enum {
+		ITEM_TYPE_DATA, 
+		ITEM_TYPE_OOB, 
+		ITEM_TYPE_ECC,
+	} type;
+}; 
 
 /*
  * Constants for Hardware ECC
-*/
+ */
 /* Reset Hardware ECC for read */
 #define NAND_ECC_READ		0
 /* Reset Hardware ECC for write */
 #define NAND_ECC_WRITE		1
 /* Enable Hardware ECC before syndrom is read back from flash */
 #define NAND_ECC_READSYN	2
+#define NAND_ECC_WRITESYN	3
+#define NAND_ECC_READOOB	4
+#define NAND_ECC_WRITEOOB	5
+
+/* Bit mask for flags passed to do_nand_read_ecc */
+#define NAND_GET_DEVICE		0x80
+
 
 /* Option constants for bizarre disfunctionality and real
 *  features
@@ -159,12 +202,16 @@
 #define NAND_CACHEPRG		0x00000008
 /* Chip has copy back function */
 #define NAND_COPYBACK		0x00000010
-/* AND Chip which has 4 banks and a confusing page / block
+/* AND Chip which has 4 banks and a confusing page / block 
  * assignment. See Renesas datasheet for further information */
 #define NAND_IS_AND		0x00000020
 /* Chip has a array of 4 pages which can be read without
  * additional ready /busy waits */
-#define NAND_4PAGE_ARRAY	0x00000040
+#define NAND_4PAGE_ARRAY	0x00000040 
+/* Chip requires that BBT is periodically rewritten to prevent
+ * bits from adjacent blocks from 'leaking' in altering data.
+ * This happens with the Renesas AG-AND chips, possibly others.  */
+#define BBT_AUTO_REFRESH	0x00000080
 
 /* Options valid for Samsung large page devices */
 #define NAND_SAMSUNG_LP_OPTIONS \
@@ -183,11 +230,16 @@
 /* Use a flash based bad block table. This option is passed to the
  * default bad block table function. */
 #define NAND_USE_FLASH_BBT	0x00010000
-/* The hw ecc generator provides a syndrome instead a ecc value on read
- * This can only work if we have the ecc bytes directly behind the
+/* The hw ecc generator provides a syndrome instead a ecc value on read 
+ * This can only work if we have the ecc bytes directly behind the 
  * data bytes. Applies for DOC and AG-AND Renesas HW Reed Solomon generators */
 #define NAND_HWECC_SYNDROME	0x00020000
-
+/* This option skips the bbt scan during initialization. */
+#define NAND_SKIP_BBTSCAN	0x00040000
+/* This option specifies that a whole NAND page is to be written in
+ * nand_write_oob. This is needed for some HW ECC generators that need a
+ * whole page to be written to generate ECC properly */
+#define NAND_COMPLEX_OOB_WRITE	0x00080000
 
 /* Options set by nand scan */
 /* Nand scan has allocated oob_buf */
@@ -207,27 +259,31 @@
 	FL_ERASING,
 	FL_SYNCING,
 	FL_CACHEDPRG,
+	FL_PM_SUSPENDED,
 } nand_state_t;
 
 /* Keep gcc happy */
 struct nand_chip;
 
-#if 0
 /**
  * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independend devices
- * @lock:		protection lock
+ * @lock:               protection lock  
  * @active:		the mtd device which holds the controller currently
+ * @wq:			wait queue to sleep on if a NAND operation is in progress
+ *                      used instead of the per chip wait queue when a hw controller is available
  */
+#if 0
 struct nand_hw_control {
 	spinlock_t	 lock;
 	struct nand_chip *active;
+	wait_queue_head_t wq;
 };
 #endif
 
 /**
  * struct nand_chip - NAND Private Flash Chip Data
- * @IO_ADDR_R:		[BOARDSPECIFIC] address to read the 8 I/O lines of the flash device
- * @IO_ADDR_W:		[BOARDSPECIFIC] address to write the 8 I/O lines of the flash device
+ * @IO_ADDR_R:		[BOARDSPECIFIC] address to read the 8 I/O lines of the flash device 
+ * @IO_ADDR_W:		[BOARDSPECIFIC] address to write the 8 I/O lines of the flash device 
  * @read_byte:		[REPLACEABLE] read one byte from the chip
  * @write_byte:		[REPLACEABLE] write one byte to the chip
  * @read_word:		[REPLACEABLE] read one word from the chip
@@ -244,25 +300,25 @@
  *			is read from the chip status register
  * @cmdfunc:		[REPLACEABLE] hardwarespecific function for writing commands to the chip
  * @waitfunc:		[REPLACEABLE] hardwarespecific function for wait on ready
- * @calculate_ecc:	[REPLACEABLE] function for ecc calculation or readback from ecc hardware
+ * @calculate_ecc: 	[REPLACEABLE] function for ecc calculation or readback from ecc hardware
  * @correct_data:	[REPLACEABLE] function for ecc correction, matching to ecc generator (sw/hw)
  * @enable_hwecc:	[BOARDSPECIFIC] function to enable (reset) hardware ecc generator. Must only
  *			be provided if a hardware ECC is available
  * @erase_cmd:		[INTERN] erase command write function, selectable due to AND support
  * @scan_bbt:		[REPLACEABLE] function to scan bad block table
- * @eccmode:		[BOARDSPECIFIC] mode of ecc, see defines
- * @eccsize:		[INTERN] databytes used per ecc-calculation
- * @eccbytes:		[INTERN] number of ecc bytes per ecc-calculation step
+ * @eccmode:		[BOARDSPECIFIC] mode of ecc, see defines 
+ * @eccsize: 		[INTERN] databytes used per ecc-calculation
+ * @eccbytes: 		[INTERN] number of ecc bytes per ecc-calculation step
  * @eccsteps:		[INTERN] number of ecc calculation steps per page
  * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transfering data from array to read regs (tR)
  * @chip_lock:		[INTERN] spinlock used to protect access to this structure and the chip
  * @wq:			[INTERN] wait queue to sleep on if a NAND operation is in progress
- * @state:		[INTERN] the current state of the NAND device
+ * @state: 		[INTERN] the current state of the NAND device
  * @page_shift:		[INTERN] number of address bits in a page (column address bits)
  * @phys_erase_shift:	[INTERN] number of address bits in a physical eraseblock
  * @bbt_erase_shift:	[INTERN] number of address bits in a bbt entry
  * @chip_shift:		[INTERN] number of address bits in one chip
- * @data_buf:		[INTERN] internal buffer for one page + oob
+ * @data_buf:		[INTERN] internal buffer for one page + oob 
  * @oob_buf:		[INTERN] oob buffer for one eraseblock
  * @oobdirty:		[INTERN] indicates that oob_buf must be reinitialized
  * @data_poi:		[INTERN] pointer to a data buffer
@@ -277,32 +333,34 @@
  * @bbt:		[INTERN] bad block table pointer
  * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash lookup
  * @bbt_md:		[REPLACEABLE] bad block table mirror descriptor
- * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for initial bad block scan
+ * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for initial bad block scan 
  * @controller:		[OPTIONAL] a pointer to a hardware controller structure which is shared among multiple independend devices
  * @priv:		[OPTIONAL] pointer to private chip date
+ * @errstat:		[OPTIONAL] hardware specific function to perform additional error status checks 
+ *			(determine if errors are correctable)
  */
-
+ 
 struct nand_chip {
 	void  __iomem	*IO_ADDR_R;
-	void  __iomem	*IO_ADDR_W;
-
+	void  __iomem 	*IO_ADDR_W;
+	
 	u_char		(*read_byte)(struct mtd_info *mtd);
 	void		(*write_byte)(struct mtd_info *mtd, u_char byte);
 	u16		(*read_word)(struct mtd_info *mtd);
 	void		(*write_word)(struct mtd_info *mtd, u16 word);
-
+	
 	void		(*write_buf)(struct mtd_info *mtd, const u_char *buf, int len);
 	void		(*read_buf)(struct mtd_info *mtd, u_char *buf, int len);
 	int		(*verify_buf)(struct mtd_info *mtd, const u_char *buf, int len);
 	void		(*select_chip)(struct mtd_info *mtd, int chip);
 	int		(*block_bad)(struct mtd_info *mtd, loff_t ofs, int getchip);
 	int		(*block_markbad)(struct mtd_info *mtd, loff_t ofs);
-	void		(*hwcontrol)(struct mtd_info *mtd, int cmd);
-	int		(*dev_ready)(struct mtd_info *mtd);
-	void		(*cmdfunc)(struct mtd_info *mtd, unsigned command, int column, int page_addr);
-	int		(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this, int state);
+	void 		(*hwcontrol)(struct mtd_info *mtd, int cmd);
+	int  		(*dev_ready)(struct mtd_info *mtd);
+	void 		(*cmdfunc)(struct mtd_info *mtd, unsigned command, int column, int page_addr);
+	int 		(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this, int state);
 	int		(*calculate_ecc)(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code);
-	int		(*correct_data)(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc);
+	int 		(*correct_data)(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc);
 	void		(*enable_hwecc)(struct mtd_info *mtd, int mode);
 	void		(*erase_cmd)(struct mtd_info *mtd, int page);
 	int		(*scan_bbt)(struct mtd_info *mtd);
@@ -310,17 +368,17 @@
 	int		eccsize;
 	int		eccbytes;
 	int		eccsteps;
-	int		chip_delay;
+	int 		chip_delay;
 #if 0
 	spinlock_t	chip_lock;
 	wait_queue_head_t wq;
-	nand_state_t	state;
+	nand_state_t 	state;
 #endif
-	int		page_shift;
+	int 		page_shift;
 	int		phys_erase_shift;
 	int		bbt_erase_shift;
 	int		chip_shift;
-	u_char		*data_buf;
+	u_char 		*data_buf;
 	u_char		*oob_buf;
 	int		oobdirty;
 	u_char		*data_poi;
@@ -331,12 +389,15 @@
 	int		pagemask;
 	int		pagebuf;
 	struct nand_oobinfo	*autooob;
+	struct page_layout_item *layout;
+	int		layout_allocated;
 	uint8_t		*bbt;
 	struct nand_bbt_descr	*bbt_td;
 	struct nand_bbt_descr	*bbt_md;
 	struct nand_bbt_descr	*badblock_pattern;
-	struct nand_hw_control	*controller;
+	struct nand_hw_control  *controller;
 	void		*priv;
+	int		(*errstat)(struct mtd_info *mtd, struct nand_chip *this, int state, int status, int page);
 };
 
 /*
@@ -348,18 +409,20 @@
 #define NAND_MFR_NATIONAL	0x8f
 #define NAND_MFR_RENESAS	0x07
 #define NAND_MFR_STMICRO	0x20
+#define NAND_MFR_HYNIX          0xad
+#define NAND_MFR_MICRON 	0x2c
 
 /**
  * struct nand_flash_dev - NAND Flash Device ID Structure
  *
- * @name:	Identify the device type
- * @id:		device ID code
- * @pagesize:	Pagesize in bytes. Either 256 or 512 or 0
- *		If the pagesize is 0, then the real pagesize
+ * @name:  	Identify the device type
+ * @id:   	device ID code
+ * @pagesize:  	Pagesize in bytes. Either 256 or 512 or 0
+ *		If the pagesize is 0, then the real pagesize 
  *		and the eraseize are determined from the
  *		extended id bytes in the chip
- * @erasesize:	Size of an erase block in the flash device.
- * @chipsize:	Total chipsize in Mega Bytes
+ * @erasesize: 	Size of an erase block in the flash device.
+ * @chipsize:  	Total chipsize in Mega Bytes
  * @options:	Bitfield to store chip relevant options
  */
 struct nand_flash_dev {
@@ -374,7 +437,7 @@
 /**
  * struct nand_manufacturers - NAND Flash Manufacturer ID Structure
  * @name:	Manufacturer name
- * @id:		manufacturer ID code of device.
+ * @id: 	manufacturer ID code of device.
 */
 struct nand_manufacturers {
 	int id;
@@ -384,7 +447,7 @@
 extern struct nand_flash_dev nand_flash_ids[];
 extern struct nand_manufacturers nand_manuf_ids[];
 
-/**
+/** 
  * struct nand_bbt_descr - bad block table descriptor
  * @options:	options for this descriptor
  * @pages:	the page(s) where we find the bbt, used with option BBT_ABSPAGE
@@ -395,14 +458,14 @@
  * @version:	version read from the bbt page during scan
  * @len:	length of the pattern, if 0 no pattern check is performed
  * @maxblocks:	maximum number of blocks to search for a bbt. This number of
- *		blocks is reserved at the end of the device where the tables are
+ *		blocks is reserved at the end of the device where the tables are 
  *		written.
  * @reserved_block_code: if non-0, this pattern denotes a reserved (rather than
- *		bad) block in the stored bbt
- * @pattern:	pattern to identify bad block table or factory marked good /
+ *              bad) block in the stored bbt
+ * @pattern:	pattern to identify bad block table or factory marked good / 
  *		bad blocks, can be NULL, if len = 0
  *
- * Descriptor for the bad block table marker and the descriptor for the
+ * Descriptor for the bad block table marker and the descriptor for the 
  * pattern which identifies good and bad blocks. The assumption is made
  * that the pattern and the version count are always located in the oob area
  * of the first block.
@@ -412,11 +475,11 @@
 	int	pages[NAND_MAX_CHIPS];
 	int	offs;
 	int	veroffs;
-	uint8_t version[NAND_MAX_CHIPS];
+	uint8_t	version[NAND_MAX_CHIPS];
 	int	len;
-	int	maxblocks;
+	int 	maxblocks;
 	int	reserved_block_code;
-	uint8_t *pattern;
+	uint8_t	*pattern;
 };
 
 /* Options for the bad block table descriptors */
@@ -428,7 +491,7 @@
 #define NAND_BBT_4BIT		0x00000004
 #define NAND_BBT_8BIT		0x00000008
 /* The bad block table is in the last good block of the device */
-#define NAND_BBT_LASTBLOCK	0x00000010
+#define	NAND_BBT_LASTBLOCK	0x00000010
 /* The bbt is at the given page, else we must scan for the bbt */
 #define NAND_BBT_ABSPAGE	0x00000020
 /* The bbt is at the given page, else we must scan for the bbt */
@@ -451,13 +514,16 @@
 #define NAND_BBT_SCAN2NDPAGE	0x00004000
 
 /* The maximum number of blocks to scan for a bbt */
-#define NAND_BBT_SCAN_MAXBLOCKS 4
+#define NAND_BBT_SCAN_MAXBLOCKS	4
 
 extern int nand_scan_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd);
 extern int nand_update_bbt (struct mtd_info *mtd, loff_t offs);
 extern int nand_default_bbt (struct mtd_info *mtd);
 extern int nand_isbad_bbt (struct mtd_info *mtd, loff_t offs, int allowbbt);
 extern int nand_erase_nand (struct mtd_info *mtd, struct erase_info *instr, int allowbbt);
+extern int nand_do_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+                             size_t * retlen, u_char * buf, u_char * oob_buf,
+                             struct nand_oobinfo *oobsel, int flags);
 
 /*
 * Constants for oob configuration
diff -Nurd u-boot-1.2.0/include/linux/mtd/nand_ids.h u-boot-1.2.0-leopard/include/linux/mtd/nand_ids.h
--- u-boot-1.2.0/include/linux/mtd/nand_ids.h	2007-01-06 20:13:11.000000000 -0300
+++ u-boot-1.2.0-leopard/include/linux/mtd/nand_ids.h	2007-12-04 07:50:51.000000000 -0300
@@ -53,6 +53,7 @@
 	{"Samsung KM29W16000",    NAND_MFR_SAMSUNG, 0xea, 21, 1, 2, 0x1000, 0},
 	{"Samsung K9F5616Q0C",    NAND_MFR_SAMSUNG, 0x45, 25, 0, 2, 0x4000, 1},
 	{"Samsung K9K1216Q0C",    NAND_MFR_SAMSUNG, 0x46, 26, 0, 3, 0x4000, 1},
+	{"Samsung K9K1208Q0C",    NAND_MFR_SAMSUNG, 0x36, 26, 0, 3, 0x4000, 0},
 	{"Samsung K9F1G08U0M",    NAND_MFR_SAMSUNG, 0xf1, 27, 0, 2, 0, 0},
 	{NULL,}
 };
diff -Nurd u-boot-1.2.0/include/version_autogenerated.h u-boot-1.2.0-leopard/include/version_autogenerated.h
--- u-boot-1.2.0/include/version_autogenerated.h	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/include/version_autogenerated.h	2009-03-10 02:21:23.000000000 -0300
@@ -0,0 +1 @@
+#define U_BOOT_VERSION "U-Boot 1.2.0"
diff -Nurd u-boot-1.2.0/lib_arm/board.c u-boot-1.2.0-leopard/lib_arm/board.c
--- u-boot-1.2.0/lib_arm/board.c	2007-01-06 20:13:11.000000000 -0300
+++ u-boot-1.2.0-leopard/lib_arm/board.c	2007-12-04 07:50:51.000000000 -0300
@@ -364,6 +364,14 @@
 	enable_interrupts ();
 
 	/* Perform network card initialisation if necessary */
+
+#ifdef CONFIG_DRIVER_TI_EMAC
+extern void emac_set_mac_addr (const char *addr);
+        if (getenv ("ethaddr")) {
+                emac_set_mac_addr(gd->bd->bi_enetaddr);
+        }
+#endif
+
 #ifdef CONFIG_DRIVER_CS8900
 	cs8900_get_enetaddr (gd->bd->bi_enetaddr);
 #endif
diff -Nurd u-boot-1.2.0/tools/crc32.c u-boot-1.2.0-leopard/tools/crc32.c
--- u-boot-1.2.0/tools/crc32.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/tools/crc32.c	2007-12-04 07:50:51.000000000 -0300
@@ -0,0 +1,198 @@
+/*
+ * This file is derived from crc32.c from the zlib-1.1.3 distribution
+ * by Jean-loup Gailly and Mark Adler.
+ */
+
+/* crc32.c -- compute the CRC-32 of a data stream
+ * Copyright (C) 1995-1998 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+#ifndef USE_HOSTCC	/* Shut down "ANSI does not permit..." warnings */
+#include <common.h>	/* to get command definitions like CFG_CMD_JFFS2 */
+#endif
+
+#include "zlib.h"
+
+#define local static
+#define ZEXPORT	/* empty */
+unsigned long crc32 (unsigned long, const unsigned char *, unsigned int);
+
+#ifdef DYNAMIC_CRC_TABLE
+
+local int crc_table_empty = 1;
+local uLongf crc_table[256];
+local void make_crc_table OF((void));
+
+/*
+  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
+  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
+
+  Polynomials over GF(2) are represented in binary, one bit per coefficient,
+  with the lowest powers in the most significant bit.  Then adding polynomials
+  is just exclusive-or, and multiplying a polynomial by x is a right shift by
+  one.  If we call the above polynomial p, and represent a byte as the
+  polynomial q, also with the lowest power in the most significant bit (so the
+  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
+  where a mod b means the remainder after dividing a by b.
+
+  This calculation is done using the shift-register method of multiplying and
+  taking the remainder.  The register is initialized to zero, and for each
+  incoming bit, x^32 is added mod p to the register if the bit is a one (where
+  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
+  x (which is shifting right by one and adding x^32 mod p if the bit shifted
+  out is a one).  We start with the highest power (least significant bit) of
+  q and repeat for all eight bits of q.
+
+  The table is simply the CRC of all possible eight bit values.  This is all
+  the information needed to generate CRC's on data a byte at a time for all
+  combinations of CRC register values and incoming bytes.
+*/
+local void make_crc_table()
+{
+  uLong c;
+  int n, k;
+  uLong poly;            /* polynomial exclusive-or pattern */
+  /* terms of polynomial defining this crc (except x^32): */
+  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
+
+  /* make exclusive-or pattern from polynomial (0xedb88320L) */
+  poly = 0L;
+  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)
+    poly |= 1L << (31 - p[n]);
+
+  for (n = 0; n < 256; n++)
+  {
+    c = (uLong)n;
+    for (k = 0; k < 8; k++)
+      c = c & 1 ? poly ^ (c >> 1) : c >> 1;
+    crc_table[n] = c;
+  }
+  crc_table_empty = 0;
+}
+#else
+/* ========================================================================
+ * Table of CRC-32's of all single-byte values (made by make_crc_table)
+ */
+local const uLongf crc_table[256] = {
+  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
+  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
+  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
+  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
+  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
+  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
+  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
+  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
+  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
+  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
+  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
+  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
+  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
+  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
+  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
+  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
+  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
+  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
+  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
+  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
+  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
+  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
+  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
+  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
+  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
+  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
+  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
+  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
+  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
+  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
+  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
+  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
+  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
+  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
+  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
+  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
+  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
+  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
+  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
+  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
+  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
+  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
+  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
+  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
+  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
+  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
+  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
+  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
+  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
+  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
+  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
+  0x2d02ef8dL
+};
+#endif
+
+#if 0
+/* =========================================================================
+ * This function can be used by asm versions of crc32()
+ */
+const uLongf * ZEXPORT get_crc_table()
+{
+#ifdef DYNAMIC_CRC_TABLE
+  if (crc_table_empty) make_crc_table();
+#endif
+  return (const uLongf *)crc_table;
+}
+#endif
+
+/* ========================================================================= */
+#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
+#define DO2(buf)  DO1(buf); DO1(buf);
+#define DO4(buf)  DO2(buf); DO2(buf);
+#define DO8(buf)  DO4(buf); DO4(buf);
+
+/* ========================================================================= */
+uLong ZEXPORT crc32(crc, buf, len)
+    uLong crc;
+    const Bytef *buf;
+    uInt len;
+{
+#ifdef DYNAMIC_CRC_TABLE
+    if (crc_table_empty)
+      make_crc_table();
+#endif
+    crc = crc ^ 0xffffffffL;
+    while (len >= 8)
+    {
+      DO8(buf);
+      len -= 8;
+    }
+    if (len) do {
+      DO1(buf);
+    } while (--len);
+    return crc ^ 0xffffffffL;
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) || \
+	((CONFIG_COMMANDS & CFG_CMD_NAND) && !defined(CFG_NAND_LEGACY))
+
+/* No ones complement version. JFFS2 (and other things ?)
+ * don't use ones compliment in their CRC calculations.
+ */
+uLong ZEXPORT crc32_no_comp(uLong crc, const Bytef *buf, uInt len)
+{
+#ifdef DYNAMIC_CRC_TABLE
+    if (crc_table_empty)
+      make_crc_table();
+#endif
+    while (len >= 8)
+    {
+      DO8(buf);
+      len -= 8;
+    }
+    if (len) do {
+      DO1(buf);
+    } while (--len);
+
+    return crc;
+}
+
+#endif	/* CFG_CMD_JFFS2 */
diff -Nurd u-boot-1.2.0/tools/environment.c u-boot-1.2.0-leopard/tools/environment.c
--- u-boot-1.2.0/tools/environment.c	1969-12-31 21:00:00.000000000 -0300
+++ u-boot-1.2.0-leopard/tools/environment.c	2007-12-04 07:50:36.000000000 -0300
@@ -0,0 +1,214 @@
+/*
+ * (C) Copyright 2001
+ * Erik Theisen,  Wave 7 Optics, etheisen@mindspring.com.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __ASSEMBLY__
+#define	__ASSEMBLY__			/* Dirty trick to get only #defines	*/
+#endif
+#define	__ASM_STUB_PROCESSOR_H__	/* don't include asm/processor.		*/
+#include <config.h>
+#undef	__ASSEMBLY__
+#include <environment.h>
+
+/*
+ * Handle HOSTS that have prepended
+ * crap on symbol names, not TARGETS.
+ */
+#if defined(__APPLE__)
+/* Leading underscore on symbols */
+#  define SYM_CHAR "_"
+#else /* No leading character on symbols */
+#  define SYM_CHAR
+#endif
+
+/*
+ * Generate embedded environment table
+ * inside U-Boot image, if needed.
+ */
+#if defined(ENV_IS_EMBEDDED)
+/*
+ * Only put the environment in it's own section when we are building
+ * U-Boot proper.  The host based program "tools/envcrc" does not need
+ * a seperate section.  Note that ENV_CRC is only defined when building
+ * U-Boot itself.
+ */
+#if (defined(CONFIG_CMI)	|| \
+     defined(CONFIG_FADS)	|| \
+     defined(CONFIG_HYMOD)	|| \
+     defined(CONFIG_ICU862)	|| \
+     defined(CONFIG_R360MPI)	|| \
+     defined(CONFIG_TQM8xxL)	|| \
+     defined(CONFIG_RRVISION)	|| \
+     defined(CONFIG_TRAB)   	|| \
+     defined(CONFIG_PPCHAMELEONEVB) || \
+     defined(CONFIG_M5271EVB)	|| \
+     defined(CONFIG_IDMR)	|| \
+     defined(CONFIG_NAND_U_BOOT))	&& \
+     defined(ENV_CRC) /* Environment embedded in U-Boot .ppcenv section */
+/* XXX - This only works with GNU C */
+#  define __PPCENV__ __attribute__ ((section(".ppcenv")))
+#  define __PPCTEXT__ __attribute__ ((section(".text")))
+
+#elif defined(USE_HOSTCC) /* Native for 'tools/envcrc' */
+#  define __PPCENV__ /*XXX DO_NOT_DEL_THIS_COMMENT*/
+#  define __PPCTEXT__ /*XXX DO_NOT_DEL_THIS_COMMENT*/
+
+#else /* Environment is embedded in U-Boot's .text section */
+/* XXX - This only works with GNU C */
+#  define __PPCENV__ __attribute__ ((section(".text")))
+#  define __PPCTEXT__ __attribute__ ((section(".text")))
+#endif
+
+/*
+ * Macros to generate global absolutes.
+ */
+#define GEN_SYMNAME(str) SYM_CHAR #str
+#define GEN_VALUE(str) #str
+#define GEN_ABS(name, value) \
+		asm (".globl " GEN_SYMNAME(name)); \
+		asm (GEN_SYMNAME(name) " = " GEN_VALUE(value))
+
+/*
+ * Macros to transform values
+ * into environment strings.
+ */
+#define XMK_STR(x)	#x
+#define MK_STR(x)	XMK_STR(x)
+
+/*
+ * Check to see if we are building with a
+ * computed CRC.  Otherwise define it as ~0.
+ */
+#if !defined(ENV_CRC)
+#  define ENV_CRC	~0
+#endif
+
+env_t environment __PPCENV__ = {
+	ENV_CRC,	/* CRC Sum */
+#ifdef CFG_REDUNDAND_ENVIRONMENT
+	1,		/* Flags: valid */
+#endif
+	{
+#if defined(CONFIG_BOOTARGS)
+	"bootargs="	CONFIG_BOOTARGS			"\0"
+#endif
+#if defined(CONFIG_BOOTCOMMAND)
+	"bootcmd="	CONFIG_BOOTCOMMAND		"\0"
+#endif
+#if defined(CONFIG_RAMBOOTCOMMAND)
+	"ramboot="	CONFIG_RAMBOOTCOMMAND		"\0"
+#endif
+#if defined(CONFIG_NFSBOOTCOMMAND)
+	"nfsboot="	CONFIG_NFSBOOTCOMMAND		"\0"
+#endif
+#if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
+	"bootdelay="	MK_STR(CONFIG_BOOTDELAY)	"\0"
+#endif
+#if defined(CONFIG_BAUDRATE) && (CONFIG_BAUDRATE >= 0)
+	"baudrate="	MK_STR(CONFIG_BAUDRATE)		"\0"
+#endif
+#ifdef	CONFIG_LOADS_ECHO
+	"loads_echo="	MK_STR(CONFIG_LOADS_ECHO)	"\0"
+#endif
+#ifdef	CONFIG_ETHADDR
+	"ethaddr="	MK_STR(CONFIG_ETHADDR)		"\0"
+#endif
+#ifdef	CONFIG_ETH1ADDR
+	"eth1addr="	MK_STR(CONFIG_ETH1ADDR)		"\0"
+#endif
+#ifdef	CONFIG_ETH2ADDR
+	"eth2addr="	MK_STR(CONFIG_ETH2ADDR)		"\0"
+#endif
+#ifdef	CONFIG_ETH3ADDR
+	"eth3addr="	MK_STR(CONFIG_ETH3ADDR)		"\0"
+#endif
+#ifdef	CONFIG_ETHPRIME
+	"ethprime="	CONFIG_ETHPRIME			"\0"
+#endif
+#ifdef	CONFIG_IPADDR
+	"ipaddr="	MK_STR(CONFIG_IPADDR)		"\0"
+#endif
+#ifdef	CONFIG_SERVERIP
+	"serverip="	MK_STR(CONFIG_SERVERIP)		"\0"
+#endif
+#ifdef	CFG_AUTOLOAD
+	"autoload="	CFG_AUTOLOAD			"\0"
+#endif
+#ifdef	CONFIG_ROOTPATH
+	"rootpath="	MK_STR(CONFIG_ROOTPATH)		"\0"
+#endif
+#ifdef	CONFIG_GATEWAYIP
+	"gatewayip="	MK_STR(CONFIG_GATEWAYIP)	"\0"
+#endif
+#ifdef	CONFIG_NETMASK
+	"netmask="	MK_STR(CONFIG_NETMASK)		"\0"
+#endif
+#ifdef	CONFIG_HOSTNAME
+	"hostname="	MK_STR(CONFIG_HOSTNAME)		"\0"
+#endif
+#ifdef	CONFIG_BOOTFILE
+	"bootfile="	MK_STR(CONFIG_BOOTFILE)		"\0"
+#endif
+#ifdef	CONFIG_LOADADDR
+	"loadaddr="	MK_STR(CONFIG_LOADADDR)		"\0"
+#endif
+#ifdef	CONFIG_PREBOOT
+	"preboot="	CONFIG_PREBOOT			"\0"
+#endif
+#ifdef	CONFIG_CLOCKS_IN_MHZ
+	"clocks_in_mhz=" "1"				"\0"
+#endif
+#if defined(CONFIG_PCI_BOOTDELAY) && (CONFIG_PCI_BOOTDELAY > 0)
+	"pcidelay="	MK_STR(CONFIG_PCI_BOOTDELAY)	"\0"
+#endif
+#ifdef  CONFIG_EXTRA_ENV_SETTINGS
+	CONFIG_EXTRA_ENV_SETTINGS
+#endif
+	"\0"		/* Term. env_t.data with 2 NULs */
+	}
+};
+#ifdef CFG_ENV_ADDR_REDUND
+env_t redundand_environment __PPCENV__ = {
+	0,		/* CRC Sum: invalid */
+	0,		/* Flags:   invalid */
+	{
+	"\0"
+	}
+};
+#endif	/* CFG_ENV_ADDR_REDUND */
+
+/*
+ * These will end up in the .text section
+ * if the environment strings are embedded
+ * in the image.  When this is used for
+ * tools/envcrc, they are placed in the
+ * .data/.sdata section.
+ *
+ */
+unsigned long env_size __PPCTEXT__ = sizeof(env_t);
+
+/*
+ * Add in absolutes.
+ */
+GEN_ABS(env_offset, CFG_ENV_OFFSET);
+
+#endif /* ENV_IS_EMBEDDED */
