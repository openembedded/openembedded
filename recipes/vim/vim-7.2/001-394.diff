Patches for Vim - Vi IMproved 7.2

Individual patches for Vim 7.2:

  SIZE  NAME     FIXES
  1877  7.2.001  Mac: pseudo-ttys don't work properly on Leopard
  1462  7.2.002  leaking memory when displaying menus
  3663  7.2.003  typo in translated message, message not translated
  3413  7.2.004  Cscope help message is not translated
  4638  7.2.005  a few problems when profiling
  1552  7.2.006  HTML files are not recognized by contents
 16735  7.2.007  (extra) minor issues for VMS
  1947  7.2.008  wrong window count when using :bunload in a BufHidden autocmd
  2245  7.2.009  can't compile with Perl 5.10 on MS-aindows
  5415  7.2.010  "K" in Visual mode does not properly escape all characters
  2873  7.2.011  error when inserting a float value from expression register
  1444  7.2.012  compiler warnings when building with startup timing
  4157  7.2.013  hang when waiting for X selection, consuming lots of CPU time
  1769  7.2.014  synstack() doesn't work in an emptly line
  1943  7.2.015  "make all test install" doesn't stop when the test fails
  4536  7.2.016  cmdline completion pattern can be in freed memory
  5319  7.2.017  X11: strlen() used wrongly, pasting very big selection fails
  1390  7.2.018  memory leak when substitute is aborted
  2269  7.2.019  completion and exists() don't work for ":noautocmd"
  1521  7.2.020  "kvim" starts the GUI even though KDE is no longer supported
  4806  7.2.021  getting full file name when executing autocmds may be slow
  3823  7.2.022  (extra) cannot run tests with the MingW compiler
  2062  7.2.023  'cursorcolumn' wrong in a closed fold when display is shifted
  1452  7.2.024  'history' can be made negative, causes out-of-memory error
  1470  7.2.025  a CursorHold event that invokes system() is retriggered
  2969  7.2.026  (after 7.2.010) 'K' uses the rest of the line
  3235  7.2.027  can use cscope commands in the sandbox, might not be safe
  1466  7.2.028  confusing error message for missing ()
  1291  7.2.029  no completion for ":doautoall" like for ":doautocmd"
  1546  7.2.030  (after 7.2.027) can't compile, ex_oldfiles undefined
 39400  7.2.031  file names from viminfo are not available to the user
  1583  7.2.032  (after 7.2.031) can't compile with EXITFREE defined
  2270  7.2.033  using "ucs-2le" for two-byte BOM, but text might be "utf-16le"
  2372  7.2.034  memory leak in spell info when deleting a buffer
  3522  7.2.035  mismatches for library and Vim alloc/free functions
  7545  7.2.036  (extra) mismatches for library and Vim alloc/free functions
  1576  7.2.037  double free with GTK 1 and compiled with EXITFREE
  2438  7.2.038  overlapping arguments to memcpy()
  1378  7.2.039  accessing freed memory on exit when EXITFREE is defined
  1836  7.2.040  ":e ++ff=dos foo" gets "unix" 'ff' when CR before NL missing
 22993  7.2.041  (extra) diff wrong when edit diff buffer in another tab page
  4987  7.2.042  restoring view in autocmd sometimes doesn't work completely
  2550  7.2.043  VMS: Too many chars escaped in filename and shell commands
  5639  7.2.044  crash because of gcc 4 being over protective for strcpy()
  2056  7.2.045  the Python interface has an empty entry in sys.path
  1704  7.2.046  wrong check for filling buffer with encoding
  2470  7.2.047  using -nb while it is not supported makes other side hang
  4758  7.2.048  v:count and v:prevcount are not set correctly
 32552  7.2.049  (extra) Win32: the clipboard doesn't support UTF-16
  8484  7.2.050  compiler warnings for not using return value of fwrite()
 15179  7.2.051  can't avoid 'wig' and 'suffixes' for glob() and globpath()
  2611  7.2.052  synIDattr() doesn't support "sp" for special color
  1754  7.2.053  crash when using WorkShop command ":ws foo"
  2006  7.2.054  compilation warnings for fprintf format
 34319  7.2.055  various compiler warnings with strict checking
  1635  7.2.056  (after 7.2.050) tests 58 and 59 fail
  3210  7.2.057  (after 7.2.056) trying to put size_t in int variable
  2338  7.2.058  can't add a feature name in the :version output
  1847  7.2.059  diff is not always displayed properly
 34772  7.2.060  spell checking doesn't work well for compound words
  1886  7.2.061  creating funcref requires loading the autoload script first
  1657  7.2.062  "[Scratch]" is not translated
  3558  7.2.063  warning for NULL argument of Perl_sys_init3()
  1942  7.2.064  repeating "~" on a Visual block doesn't always update screen
  5149  7.2.065  GTK GUI: cursor disappears doing ":vsp" when maximized
  2759  7.2.066  not easy to check if 'encoding' is a multi-byte encoding
  1683  7.2.067  can't load sesison extra file when it contains special chars
  2598  7.2.068  error when Emacs tags file line is too long
  1726  7.2.069  (after 7.2.060) compiler warning for putting size_t in int
 17606  7.2.070  crash when a function returns a:000
  2353  7.2.071  (extra) Win32: Handling netbeans events may cause a crash
  1615  7.2.072  (extra, fixed patch) compiler warning in Sniff code
  4121  7.2.073  ":set <xHome>" has the same output as ":set <Home>"
  1832  7.2.074  (extra, after 7.2.073) extra part of 7.2.073
  2218  7.2.075  (after 7.2.058) unclear comment about making a diff
  2666  7.2.076  rename(from, to) deletes file if names refer to the same file
  4745  7.2.077  (after 7.2.076) rename() fails if names differ only in case
  3298  7.2.078  problems with deleting folds
  6947  7.2.079  "killed" netbeans events are not handled correctly
  9942  7.2.080  accessing wrong memory with completion and composing char
  1728  7.2.081  compiler warning for float overflow on VAX
  2134  7.2.082  if 'ff' is "mac" then "ga" on a ^J shows 0x0d instead of 0x0a
  1733  7.2.083  ":tag" doesn't return to the right tag entry in the tag stack
  4331  7.2.084  Python: vim.eval() is wrong for recursive structures 
  1862  7.2.085  ":set <M-b>=<Esc>b" does not work when 'encoding' is utf-8
  3045  7.2.086  using ":diffget 1" in buffer 1 corrupts the text
  1570  7.2.087  adding URL to 'path' doesn't work to edit a file
  2895  7.2.088  (extra) Win32: Using the clipboard sometimes fails
  2473  7.2.089  (extra) Win32: crash when using Ultramon buttons
  3286  7.2.090  user command containing 0x80 does not work properly
  2113  7.2.091  ":cs help" output is not aligned for some languages
  4538  7.2.092  some error messages are not translated
  7287  7.2.093  (extra) dialogs can't always handle multi-byte text
  3430  7.2.094  compiler warning for signed/unsigned compare, typos
  1902  7.2.095  using "r" and then CTRL-C Visual highlighting is not removed
  1464  7.2.096  after ":number" "Press Enter" msg may be on the wrong screen
  1692  7.2.097  "!xterm&" doesn't work when 'shell' is "bash"
  1864  7.2.098  warning for signed/unsigned pointer
  3498  7.2.099  unnecessary redraw when changing GUI options in terminal
  3846  7.2.100  missing first three bytes on sourced FIFO
  1362  7.2.101  (extra) MSVC version not recognized
  1496  7.2.102  (after 7.2.100) BOM at start of Vim script not removed
  5153  7.2.103  tab page line isn't always updated, e.g. when 'bomb' is set
  1523  7.2.104  after ":saveas foo" the tab label isn't updated right away
  2159  7.2.105  modeline setting for 'foldmethod' overrules diff options
  3422  7.2.106  endless loop for "]s" in HTML when there are no misspellings
  1825  7.2.107  After a GUI dialog ":echo" messages are deleted
  1622  7.2.108  (after 7.2.105) can't compile without the diff feature
 11901  7.2.109  'langmap' does not work for multi-byte characters
  1407  7.2.110  compiler warning for unused variable
  2724  7.2.111  selection unclear for Visual block mode with 'cursorcolumn'
  1509  7.2.112  cursor invisible in first col in Visual mode if 'number' set
  2700  7.2.113  crash when using submatch() in substitute()
  2531  7.2.114  using wrong printf format: %d instead of %ld
  2716  7.2.115  some debugging code is never used
  1619  7.2.116  not all memory is freed when EXITFREE is defined
  2592  7.2.117  location list incorrectly labelled "Quickfix List"
  2068  7.2.118  <PageUp> at the more prompt only does half a page
  1550  7.2.119  status line is redrawn too often
  8305  7.2.120  location list is copied and then deleted when opening window
  4993  7.2.121  can't stop output of "!grep a *.c" in gvim with CTRL-C
  2472  7.2.122  invalid mem access if VimResized autocmd changes screen size
  1568  7.2.123  ":map" output continues after typing 'q' at more prompt
  3127  7.2.124  ":tselect" output continues after typing 'q' at more prompt
  3936  7.2.125  leaking memory when reading XPM bitmap for a sign
  4326  7.2.126  when EXITFREE is defined signs and keymaps are not freed
  1708  7.2.127  get another more prompt after typing 'q'
  1537  7.2.128  (after 7.2.055) ":lcd" causes invalid session file
  2229  7.2.129  opening command window from input() uses the search history
 12852  7.2.130  Vim may haing until CTRL-C is typed when using CTRL-Z
  2612  7.2.131  using wrong cursor highlighting after clearing 'keymap'
  7823  7.2.132  accessing freed memory when changing dir in SwapExists autocmd
  1665  7.2.133  ":diffoff!" changes settings in windows not in diff mode
  2314  7.2.134  compiler warnings for discarding "const" from pointer
  1991  7.2.135  memory leak when redefining user command with complete arg
  1326  7.2.136  (after 7.2.132) ":cd" still possible in SwapExists autocmd
 11328  7.2.137  wrong left shift of blockwise selection in tab when 've' set
  5428  7.2.138  extra part of 7.2.137
  2229  7.2.139  crash when 'virtualedit' is "all"
  1974  7.2.140  diff highlighting missing if Visual area starts at cursor pos
  6622  7.2.141  fixing bold spill redraws too many characters
  1753  7.2.142  Motif and Athena balloons don't use tooltip colors
  6830  7.2.143  no command line completion for ":cscope" command
  2304  7.2.144  colorscheme is reloaded when 't_Co' is set to the same value
  3379  7.2.145  white space in ":cscope find" is not ignored
  3394  7.2.146  v:warningmsg isn't used for all warnings
  1548  7.2.147  cursor in wrong position after Tab for small version
  4275  7.2.148  highlighting a character after the line doesn't always work
 15646  7.2.149  read uninit memory when using return value that wasn't set
 35686  7.2.150  (extra) VisVim doesn't support tabs
  1533  7.2.151  ":hist a" doesn't work like ":hist all" as the docs suggest
  2963  7.2.152  "silent echo x" inside ":redir" leaves cursor halfway the line
  2908  7.2.153  memory leak for ":recover empty_dir/"
  2390  7.2.154  (after 7.2.132) can still do ":cd" in SwapExists autocmd
  1249  7.2.155  memory leak in ":function /pat"
  5543  7.2.156  no completion for :scscope and :lcscope commands
  4299  7.2.157  illegal memory access when searching in path
  2177  7.2.158  warnings from VisualC compiler
  2478  7.2.159  when $x_includes ends up being "NONE" configure fails
  1353  7.2.160  search pattern not freed on exit when 'rightleft' set
  5400  7.2.161  folds messed up in other tab page
  2363  7.2.162  the quickfix window may get the wrong filetype
  1754  7.2.163  the command line window may get folding
  4089  7.2.164  when 'showbreak' is set wrong Visual block size reported
  1794  7.2.165  FuncUndefined autocmd event argument is expanded like filename
 10538  7.2.166  no completion for ":sign" command
 54715  7.2.167  splint doesn't work well for checking the code (part 1)
  2936  7.2.168  if no ctags program found, "make tags" executes first C file
 35841  7.2.169  fix more splint warnings, define colnr_T to be int
  4481  7.2.170  using b_dev while it was not set
  2261  7.2.171  (after 7.2.169) compiler warnings
  1883  7.2.172  (extra) compiler warning
 17875  7.2.173  use gcc instead of lint to check for unused function arguments
 42277  7.2.174  too many warnings from gcc -Wextra
  1455  7.2.175  compiler warning in OpenBSD
  5956  7.2.176  exceptions for splint are not useful
 57904  7.2.177  more warnings from gcc -Wextra
  3898  7.2.178  using negative value for device number might not always work
  2944  7.2.179  using negative value for device number might not always work
198701  7.2.180  some more compiler warnings when using gcc -Wextra
 49635  7.2.181  some more compiler warnings when using gcc -Wextra
  2128  7.2.182  compilation fails for Motif, gvim with GTK crashes on startup
 52709  7.2.183  configure problem for sys/sysctl.h on OpenBSD
 84846  7.2.184  some more compiler warnings when using gcc -Wextra
  8242  7.2.185  some more compiler warnings when using gcc -Wextra
  7260  7.2.186  some more compiler warnings when using gcc -Wextra
  3334  7.2.187  (after 7.2.186) doesn't compile with older tcl versions
  8531  7.2.188  crash with specific use of function calls
  2889  7.2.189  possible hang for deleting auto-indent
  4827  7.2.190  the register executed by @@ isn't stored in viminfo
106448  7.2.191  Mzscheme interface doesn't work on Ubuntu
  4206  7.2.192  (after 7.2.188) still a crash in the garbage collector
  1545  7.2.193  warning for uninitialized values in struct
  1345  7.2.194  (extra) MSVC: rem commands are echoed
  2229  7.2.195  leaking memory for the command Vim was started with
  3466  7.2.196  remove support for splint, it doesn't work well
  1530  7.2.197  warning for uninitialized values of typebuf
  2006  7.2.198  buffer used for termcap entry may be too small
  1894  7.2.199  strange character in comment
 10318  7.2.200  reading past string end when using menu bar or resizing window
 14460  7.2.201  cannot copy/paste HTML to/from Firefox via the clipboard
  1846  7.2.202  BufWipeout autocmd that edits another buffer causes problems
 40481  7.2.203  using current window to work on hidden buffer has side effects
  4407  7.2.204  (extra) Win32: Can't build with Visual Studio 2010 beta 1
  2852  7.2.205  (extra) Win32: No support for High DPI awarenes
  1485  7.2.206  Win32: Can't build netbeans interface with Visual Studio 2010
  2237  7.2.207  using freed memory when ":redrawstatus" works recursively
  2569  7.2.208  "set novice" gives an error message, it should be ignored
  2532  7.2.209  for xxd setmode() is undefined on Cygwin
  1896  7.2.210  warning for file changed outside of vim even after :checktime
  1639  7.2.211  memory leak when expanding a series of file names
  1727  7.2.212  (extra) warnings for redefining SIG macros
  1521  7.2.213  warning for using vsprintf()
  1983  7.2.214  crash with complete function for user command
  8298  7.2.215  ml_get error when using ":vimgrep"
  4822  7.2.216  two error messages have the same number E812
  2020  7.2.217  running tests with valgrind doesn't work as advertised
  1448  7.2.218  cannot build GTK with hangul_input feature
  2052  7.2.219  (extra) Photon GUI is outdated
  2958  7.2.220  (after 7.2.215) BufEnter "cd" autocommand causes problems
  7103  7.2.221  X cut_buffer0 text may be used in the wrong encoding
  1816  7.2.222  ":mksession" doesn't work properly with 'acd' set
  5132  7.2.223  a script run with ":silent" cannot give any messages
  2542  7.2.224  crash when using 'completefunc'
  2874  7.2.225  when using ":normal" a saved character may be executed
  7470  7.2.226  ml_get error after deleting the last line
  1574  7.2.227  when using ":cd" in a script there is no way to track this
 14946  7.2.228  cscope is limited to 8 connections
  1595  7.2.229  warning for shadowed variable
  2442  7.2.230  a few old lint-style ARGUSED comments
  1473  7.2.231  warning for unreacheable code in Perl interface
  2704  7.2.232  cannot debug problems with being in a wrong directory
  2901  7.2.233  extra part of 7.2.232
  3831  7.2.234  it is not possible to ignore file names without a suffix
  2696  7.2.235  Using CTRL-O z= in Insert mode has a delay before redrawing
  2809  7.2.236  Mac: Compiling with Ruby doesn't always work
  1965  7.2.237  crash on exit when window icon not set
  3941  7.2.238  leaking memory when setting term to "builtin_dumb"
  4151  7.2.239  using :diffpatch twice may cause a crash
  2078  7.2.240  crash when using GUI find/replace dialog repeatedly
  5174  7.2.241  problems with using ":bufdo" and "doautoall" or ":vimgrep"
  2505  7.2.242  setting 'lazyredraw' causes the cursor column to be recomputed
  1918  7.2.243  memory leak when using :vimgrep and resizing
  4757  7.2.244  insufficient info for a conversion error from utf-8 to latin1
  5093  7.2.245  wrong conversion when writing Unicode encoded files
  1848  7.2.246  Cscope home page link is wrong
  2561  7.2.247  Mzscheme interface minor problem
  4408  7.2.248  (extra) Win32: Mzscheme interface building minor problems
  1555  7.2.249  script that checks .po files can't handle '%' in plural forms
  1693  7.2.250  (extra) possible buffer overflow in GvimExt
  2802  7.2.251  compiler adds invalid memory bounds check
  1495  7.2.252  when 'enc' is multi-byte 'iskeyword' can't contain chars > 128
  4223  7.2.253  netbeans interface: getLength always uses current buffer
  1654  7.2.254  compiler warning for assigning size_t to int
  1870  7.2.255  (after 7.2.242) cursor column may be wrong after :set
  1783  7.2.256  GTK font dialog doesn't have a default when 'guifont' not set
  2092  7.2.257  GTK 2.17: lots of assertion error messages
  1989  7.2.258  v:beval_col and b:beval_text are wrong in UTF-8 text
  5393  7.2.259  exists() doesn't work properly for an empty aucmd group
  5431  7.2.260  (extra part of 7.2.259)
  2515  7.2.261  E38 may appear when deleting folded lines
  5652  7.2.262  string passed to user cmd custom completion can be too long
  2634  7.2.263  GTK2: Vim window in wrong position using the -geom argument
  5161  7.2.264  GTK2: When Vim window maximized, set 'columns' doesn't work
  1892  7.2.265  with ":silent broken" inside try/catch silency may persist
  6560  7.2.266  in an expression abbreviation the typed character is unknown
  1461  7.2.267  crash for narrow window and double-width character
  2274  7.2.268  crash when using Python to set cursor beyond end of line
  7128  7.2.269  add --startuptime so that slow startup can be analysed
  2281  7.2.270  ":@c" does not execute everything if the c register has a CR
  2649  7.2.271  Motif GUI: Using freed memory when making a choice
  2582  7.2.272  "_.svz" is not recognized as a swap file
  3404  7.2.273  crash when redirirecting to unknown array
  3749  7.2.274  syntax folding doesn't work properly when adding a comment
  2717  7.2.275  warning for unused argument and comparing signed and unsigned
  1875  7.2.276  crash when setting 'isprint' to a small bullet
  1937  7.2.277  CTRL-Y in a diff'ed window may move cursor outside of window
  2312  7.2.278  using magic number in the folding code
  3413  7.2.279  invalid memory read with visual mode "r"
  6656  7.2.280  a redraw in a custom statusline with %! may cause a crash
  2241  7.2.281  'cursorcolumn' highlighting is wrong in diff mode
  1584  7.2.282  a fold can't be closed
  2030  7.2.283  GTK: changing font doesn't keep the window maximized
  1572  7.2.284  two windows on a buffer + folding: display error after change
  1931  7.2.285  (after 7.2.169) CTRL-U in Insert mode also deletes indent
  7058  7.2.286  (after 7.2.269) --startuptime argument is not consistent
  1733  7.2.287  warning from gcc 3.4 about uninitialized variable
  1680  7.2.288  Python 2.6 pyconfig.h redefines macros
  3979  7.2.289  checking wrong struct member
  5344  7.2.290  not freeing memory from ":lmap", ":xmap" and ":menutranslate"
  1498  7.2.291  reading uninitialised memory in arabic mode
  1518  7.2.292  block right-shift wrong with multibyte encoding and 'list' set
  1954  7.2.293  when setting 'comments' option it may be used in a wrong way
  8992  7.2.294  when using TEMPDIRS dir name could get too long
  4053  7.2.295  in map() on a List the index is not known, set v:key to index
  1809  7.2.296  (after 7.2.286) help message about startuptime is wrong
  1846  7.2.297  reading freed memory when writing ":reg" output to a register
  1608  7.2.298  ":vimgrep" crashes with an autocommand that sets w: variable
  1733  7.2.299  crash when comment middle is longer than start
  5886  7.2.300  file descriptors not closed when executing external command
 14601  7.2.301  formatting is wrong when 'tw' is set to a small value
  4941  7.2.302  (extra, after 7.2.301) extra part of the 7.2.301 tests
  2073  7.2.303  (after 7.2.294) can't build on MS-Windows
  1831  7.2.304  compiler warning for bad pointer cast
  2727  7.2.305  recursively redrawing causes a memory leak
  1541  7.2.306  shellescape("10%%", 1) only escapes first %
  4869  7.2.307  crash with a very long syntax match statement
  5504  7.2.308  submatch() in "\=" of ":s" command returns empty string
  1533  7.2.309  (after 7.2.308) warning for missing function prototype
  1874  7.2.310  ftdetect plugin using ":setf" doesn't work with # comment
  1408  7.2.311  can't compile with FreeMiNT
  9769  7.2.312  iconv() returns invalid char sequence when conversion fails
  3744  7.2.313  command line completion doesn't work after "%:h" and similar
  1620  7.2.314  small build broken after 7.2.313
  4605  7.2.315  Python libs can't be found on 64 bit system
  3370  7.2.316  may get multiple _FORTIFY_SOURCE arguments
  5249  7.2.317  memory leak when adding a highlight group resulting in E669
  2637  7.2.318  wrong locale value breaks floating point numbers for gvim
  1846  7.2.319  Motif: accessing freed memory when cancelling font dialog
  6269  7.2.320  unused function in Mzscheme interface
  1899  7.2.321  histadd() and "*" fail to add entry to empty history
  1517  7.2.322  wrong indenting in virtual replace for CTRL-Y and a short line
  2424  7.2.323  (extra) balloon evaluation crashes on Win64
  1901  7.2.324  a negative column argument in setpos() may cause a crash
  1616  7.2.325  stray "w" in the startup vimrc file makes edited file empty
  1790  7.2.326  Win32: $HOME doesn't work when %HOMEPATH% is not defined
  7899  7.2.327  unused functions in Workshop
  1453  7.2.328  has("win64") does not return 1 on 64 bit MS-Windows version
  1390  7.2.329  cursor pos wrong after "g_" in Visual mode and excl. selection
 45468  7.2.330  tables for Unicode case operators are outdated
  1385  7.2.331  can't interrupt "echo list" for a very long list
  3492  7.2.332  crash if spell correcting triggers autocmd to reload a buffer
 10075  7.2.333  warnings from static code analysis
  9095  7.2.334  postponing keys in Netbeans interface does not work properly
  2802  7.2.335  the CTRL-] command escapes too many characters
 26204  7.2.336  MzScheme interface can't evaluate an expression
  3828  7.2.337  ":compiler" doesn't function properly in a function
  3535  7.2.338  (after 7.2.300) part of FD_CLOEXEC change is missing
  1977  7.2.339  (after 7.2.269) part of --startuptime patch is missing
  1587  7.2.340  gcc warning for condition that can never be true
  2072  7.2.341  popup menu wraps to next line if wide character doesn't fit
  2507  7.2.342  popup menu wrong in 'rightleft' mode with multi-byte chars
  1370  7.2.343  (after 7.2.338) can't compile on Win32
  1728  7.2.344  (after 7.2.338) can't compile on some systems
  1324  7.2.345  tab line is not updated when the value of 'bt' is changed
  2895  7.2.346  repeating a command with @: causes mapping to be applied twice
  3784  7.2.347  crash when executing <expr> mapping redefines that mapping
  7230  7.2.348  (after 7.2.330) Unicode double width table is outdated
  1714  7.2.349  CTRL-W gf puts the new tab in the wrong place
  2766  7.2.350  Win32: When changing font window may jump to another screen
  2195  7.2.351  (after 7.2.347) compilation fails with some compilers
  1825  7.2.352  Win64: Vim doesn't work when cross-compiled with MingW libs
  4764  7.2.353  no command line completion for ":profile"
  2270  7.2.354  Japanese single-width double-byte chars not handled correctly
  2663  7.2.355  popup menu in wrong position when 'number' is set
  2166  7.2.356  not all folds are closed when 'foldmethod' is changed
  1565  7.2.357  CR displayed wrong when changing 'fileformat' from/to "mac"
  2384  7.2.358  compiler warnings on VMS
  1805  7.2.359  crash when using the Netbeans join command
  2839  7.2.360  Ruby on MS-Windows: can't use sockets
 23442  7.2.361  Ruby 1.9 is not supported
  2964  7.2.362  (extra, after 7.2.352) Win64 cross-compile problems
  2521  7.2.363  Perl 5.10 dynamic loading doesn't work
  2958  7.2.364  (extra) can't build gvimext.dll on Win 7 x64 using MinGW
  2390  7.2.365  (extra) MS-Windows with MingW: "File->Save As" does not work
  3802  7.2.366  CTRL-B doesn't go back to the first line of the buffer
  3236  7.2.367  "xxd -r -p" doesn't work as documented
  1623  7.2.368  (after 7.2.361) append line with Ruby interface doesn't work
  1872  7.2.369  error message for :profile is not easy to understand
  4352  7.2.370  (after 7.2.356) a redraw may cause folds to be closed
 10029  7.2.371  build problems on Tandem NonStop
  9674  7.2.372  (extra) cross-compiling GvimExt and xxd doesn't work.
  2901  7.2.373  new messages from gcc 4.5 are not in 'errorformat'
  4434  7.2.374  Ruby eval() doesn't understand Vim types
  1794  7.2.375  ml_get errors when using ":bprevious" in a BufEnter autocmd
  1577  7.2.376  ml_get error when using SiSU syntax
  1983  7.2.377  (extra, after 7.2.372) small mistakes in Ming build file
  2832  7.2.378  C function declaration indented too much
  1758  7.2.379  'eventignore' is set to an invalid value inside ":doau"
  3699  7.2.380  (after 7.2.363) Perl builds with 5.10.1 but not with 5.10.0
  6835  7.2.381  no completion for :behave
  1766  7.2.382  close cmdline window when 'bufhide' is "wipe" uses freed mem
  3021  7.2.383  Vim doesn't build cleanly with MSVC 2010
  1849  7.2.384  (extra) Vim doesn't build properly with MSVC 2010
  2147  7.2.385  can't drag status line when in the command line window
  2051  7.2.386  KDE 3.1 focus hack causes problems for other window managers
  8233  7.2.387  Ruby with MingW still doesn't build all versions
  2486  7.2.388  (extra part of 7.2.387) Ruby with MingW
  4805  7.2.389  synIDattr() cannot return the font
  2302  7.2.390  in some situations the popup menu can be displayed wrong
  3426  7.2.391  internal alloc(0) error when doing "CTRL-V $ c"
  4898  7.2.392  netbeans hangs reading from a socket at the maximum block size
  9605  7.2.393  Mac: Can't build with different Xcode developer tools dir
  4298  7.2.394  .lzma and .xz files are not supported


--- vim72.orig/src/pty.c
+++ vim72/src/pty.c
@@ -268,13 +268,14 @@ OpenPTY(ttyn)
     *ttyn = TtyName;
     return f;
 }
 #endif
 
-#if defined(HAVE_SVR4_PTYS) && !defined(PTY_DONE) && !defined(hpux)
+#if defined(HAVE_SVR4_PTYS) && !defined(PTY_DONE) && !defined(hpux) && !defined(MACOS_X)
 
-/* NOTE: Even though HPUX can have /dev/ptmx, the code below doesn't work! */
+/* NOTE: Even though HPUX can have /dev/ptmx, the code below doesn't work!
+ * Same for Mac OS X Leopard. */
 #define PTY_DONE
     int
 OpenPTY(ttyn)
     char **ttyn;
 {
--- vim72.orig/src/version.c
+++ vim72/src/version.c
@@ -492,10 +492,15 @@ static char *(features[]) =
 #ifdef FEAT_SNIFF
 	"+sniff",
 #else
 	"-sniff",
 #endif
+#ifdef STARTUPTIME
+	"+startuptime",
+#else
+	"-startuptime",
+#endif
 #ifdef FEAT_STL_OPT
 	"+statusline",
 #else
 	"-statusline",
 #endif
@@ -675,13 +680,814 @@ static char *(features[]) =
 };
 
 static int included_patches[] =
 {   /* Add new patch number below this line */
 /**/
+    394,
+/**/
+    393,
+/**/
+    392,
+/**/
+    391,
+/**/
+    390,
+/**/
+    389,
+/**/
+    388,
+/**/
+    387,
+/**/
+    386,
+/**/
+    385,
+/**/
+    384,
+/**/
+    383,
+/**/
+    382,
+/**/
+    381,
+/**/
+    380,
+/**/
+    379,
+/**/
+    378,
+/**/
+    377,
+/**/
+    376,
+/**/
+    375,
+/**/
+    374,
+/**/
+    373,
+/**/
+    372,
+/**/
+    371,
+/**/
+    370,
+/**/
+    369,
+/**/
+    368,
+/**/
+    367,
+/**/
+    366,
+/**/
+    365,
+/**/
+    364,
+/**/
+    363,
+/**/
+    362,
+/**/
+    361,
+/**/
+    360,
+/**/
+    359,
+/**/
+    358,
+/**/
+    357,
+/**/
+    356,
+/**/
+    355,
+/**/
+    354,
+/**/
+    353,
+/**/
+    352,
+/**/
+    351,
+/**/
+    350,
+/**/
+    349,
+/**/
+    348,
+/**/
+    347,
+/**/
+    346,
+/**/
+    345,
+/**/
+    344,
+/**/
+    343,
+/**/
+    342,
+/**/
+    341,
+/**/
+    340,
+/**/
+    339,
+/**/
+    338,
+/**/
+    337,
+/**/
+    336,
+/**/
+    335,
+/**/
+    334,
+/**/
+    333,
+/**/
+    332,
+/**/
+    331,
+/**/
+    330,
+/**/
+    329,
+/**/
+    328,
+/**/
+    327,
+/**/
+    326,
+/**/
+    325,
+/**/
+    324,
+/**/
+    323,
+/**/
+    322,
+/**/
+    321,
+/**/
+    320,
+/**/
+    319,
+/**/
+    318,
+/**/
+    317,
+/**/
+    316,
+/**/
+    315,
+/**/
+    314,
+/**/
+    313,
+/**/
+    312,
+/**/
+    311,
+/**/
+    310,
+/**/
+    309,
+/**/
+    308,
+/**/
+    307,
+/**/
+    306,
+/**/
+    305,
+/**/
+    304,
+/**/
+    303,
+/**/
+    302,
+/**/
+    301,
+/**/
+    300,
+/**/
+    299,
+/**/
+    298,
+/**/
+    297,
+/**/
+    296,
+/**/
+    295,
+/**/
+    294,
+/**/
+    293,
+/**/
+    292,
+/**/
+    291,
+/**/
+    290,
+/**/
+    289,
+/**/
+    288,
+/**/
+    287,
+/**/
+    286,
+/**/
+    285,
+/**/
+    284,
+/**/
+    283,
+/**/
+    282,
+/**/
+    281,
+/**/
+    280,
+/**/
+    279,
+/**/
+    278,
+/**/
+    277,
+/**/
+    276,
+/**/
+    275,
+/**/
+    274,
+/**/
+    273,
+/**/
+    272,
+/**/
+    271,
+/**/
+    270,
+/**/
+    269,
+/**/
+    268,
+/**/
+    267,
+/**/
+    266,
+/**/
+    265,
+/**/
+    264,
+/**/
+    263,
+/**/
+    262,
+/**/
+    261,
+/**/
+    260,
+/**/
+    259,
+/**/
+    258,
+/**/
+    257,
+/**/
+    256,
+/**/
+    255,
+/**/
+    254,
+/**/
+    253,
+/**/
+    252,
+/**/
+    251,
+/**/
+    250,
+/**/
+    249,
+/**/
+    248,
+/**/
+    247,
+/**/
+    246,
+/**/
+    245,
+/**/
+    244,
+/**/
+    243,
+/**/
+    242,
+/**/
+    241,
+/**/
+    240,
+/**/
+    239,
+/**/
+    238,
+/**/
+    237,
+/**/
+    236,
+/**/
+    235,
+/**/
+    234,
+/**/
+    233,
+/**/
+    232,
+/**/
+    231,
+/**/
+    230,
+/**/
+    229,
+/**/
+    228,
+/**/
+    227,
+/**/
+    226,
+/**/
+    225,
+/**/
+    224,
+/**/
+    223,
+/**/
+    222,
+/**/
+    221,
+/**/
+    220,
+/**/
+    219,
+/**/
+    218,
+/**/
+    217,
+/**/
+    216,
+/**/
+    215,
+/**/
+    214,
+/**/
+    213,
+/**/
+    212,
+/**/
+    211,
+/**/
+    210,
+/**/
+    209,
+/**/
+    208,
+/**/
+    207,
+/**/
+    206,
+/**/
+    205,
+/**/
+    204,
+/**/
+    203,
+/**/
+    202,
+/**/
+    201,
+/**/
+    200,
+/**/
+    199,
+/**/
+    198,
+/**/
+    197,
+/**/
+    196,
+/**/
+    195,
+/**/
+    194,
+/**/
+    193,
+/**/
+    192,
+/**/
+    191,
+/**/
+    190,
+/**/
+    189,
+/**/
+    188,
+/**/
+    187,
+/**/
+    186,
+/**/
+    185,
+/**/
+    184,
+/**/
+    183,
+/**/
+    182,
+/**/
+    181,
+/**/
+    180,
+/**/
+    179,
+/**/
+    178,
+/**/
+    177,
+/**/
+    176,
+/**/
+    175,
+/**/
+    174,
+/**/
+    173,
+/**/
+    172,
+/**/
+    171,
+/**/
+    170,
+/**/
+    169,
+/**/
+    168,
+/**/
+    167,
+/**/
+    166,
+/**/
+    165,
+/**/
+    164,
+/**/
+    163,
+/**/
+    162,
+/**/
+    161,
+/**/
+    160,
+/**/
+    159,
+/**/
+    158,
+/**/
+    157,
+/**/
+    156,
+/**/
+    155,
+/**/
+    154,
+/**/
+    153,
+/**/
+    152,
+/**/
+    151,
+/**/
+    150,
+/**/
+    149,
+/**/
+    148,
+/**/
+    147,
+/**/
+    146,
+/**/
+    145,
+/**/
+    144,
+/**/
+    143,
+/**/
+    142,
+/**/
+    141,
+/**/
+    140,
+/**/
+    139,
+/**/
+    138,
+/**/
+    137,
+/**/
+    136,
+/**/
+    135,
+/**/
+    134,
+/**/
+    133,
+/**/
+    132,
+/**/
+    131,
+/**/
+    130,
+/**/
+    129,
+/**/
+    128,
+/**/
+    127,
+/**/
+    126,
+/**/
+    125,
+/**/
+    124,
+/**/
+    123,
+/**/
+    122,
+/**/
+    121,
+/**/
+    120,
+/**/
+    119,
+/**/
+    118,
+/**/
+    117,
+/**/
+    116,
+/**/
+    115,
+/**/
+    114,
+/**/
+    113,
+/**/
+    112,
+/**/
+    111,
+/**/
+    110,
+/**/
+    109,
+/**/
+    108,
+/**/
+    107,
+/**/
+    106,
+/**/
+    105,
+/**/
+    104,
+/**/
+    103,
+/**/
+    102,
+/**/
+    101,
+/**/
+    100,
+/**/
+    99,
+/**/
+    98,
+/**/
+    97,
+/**/
+    96,
+/**/
+    95,
+/**/
+    94,
+/**/
+    93,
+/**/
+    92,
+/**/
+    91,
+/**/
+    90,
+/**/
+    89,
+/**/
+    88,
+/**/
+    87,
+/**/
+    86,
+/**/
+    85,
+/**/
+    84,
+/**/
+    83,
+/**/
+    82,
+/**/
+    81,
+/**/
+    80,
+/**/
+    79,
+/**/
+    78,
+/**/
+    77,
+/**/
+    76,
+/**/
+    75,
+/**/
+    74,
+/**/
+    73,
+/**/
+    72,
+/**/
+    71,
+/**/
+    70,
+/**/
+    69,
+/**/
+    68,
+/**/
+    67,
+/**/
+    66,
+/**/
+    65,
+/**/
+    64,
+/**/
+    63,
+/**/
+    62,
+/**/
+    61,
+/**/
+    60,
+/**/
+    59,
+/**/
+    58,
+/**/
+    57,
+/**/
+    56,
+/**/
+    55,
+/**/
+    54,
+/**/
+    53,
+/**/
+    52,
+/**/
+    51,
+/**/
+    50,
+/**/
+    49,
+/**/
+    48,
+/**/
+    47,
+/**/
+    46,
+/**/
+    45,
+/**/
+    44,
+/**/
+    43,
+/**/
+    42,
+/**/
+    41,
+/**/
+    40,
+/**/
+    39,
+/**/
+    38,
+/**/
+    37,
+/**/
+    36,
+/**/
+    35,
+/**/
+    34,
+/**/
+    33,
+/**/
+    32,
+/**/
+    31,
+/**/
+    30,
+/**/
+    29,
+/**/
+    28,
+/**/
+    27,
+/**/
+    26,
+/**/
+    25,
+/**/
+    24,
+/**/
+    23,
+/**/
+    22,
+/**/
+    21,
+/**/
+    20,
+/**/
+    19,
+/**/
+    18,
+/**/
+    17,
+/**/
+    16,
+/**/
+    15,
+/**/
+    14,
+/**/
+    13,
+/**/
+    12,
+/**/
+    11,
+/**/
+    10,
+/**/
+    9,
+/**/
+    8,
+/**/
+    7,
+/**/
+    6,
+/**/
+    5,
+/**/
+    4,
+/**/
+    3,
+/**/
+    2,
+/**/
+    1,
+/**/
     0
 };
 
+/*
+ * Place to put a short description when adding a feature with a patch.
+ * Keep it short, e.g.,: "relative numbers", "persistent undo".
+ * Also add a comment marker to separate the lines.
+ * See the official Vim patches for the diff format: It must use a context of
+ * one line only.  Create it by hand or use "diff -C2" and edit the patch.
+ */
+static char *(extra_patches[]) =
+{   /* Add your patch description below this line */
+/**/
+    NULL
+};
+
     int
 highest_patch()
 {
     int		i;
     int		h = 0;
@@ -784,11 +1590,11 @@ list_version()
 
 #ifdef RISCOS
     MSG_PUTS(_("\nRISC OS version"));
 #endif
 #ifdef VMS
-    MSG_PUTS("\nOpenVMS version");
+    MSG_PUTS(_("\nOpenVMS version"));
 # ifdef HAVE_PATHDEF
     if (*compiled_arch != NUL)
     {
 	MSG_PUTS(" - ");
 	MSG_PUTS(compiled_arch);
@@ -823,10 +1629,23 @@ list_version()
 		first = -1;
 	    }
 	}
     }
 
+    /* Print the list of extra patch descriptions if there is at least one. */
+    if (extra_patches[0] != NULL)
+    {
+	MSG_PUTS(_("\nExtra patches: "));
+	s = "";
+	for (i = 0; extra_patches[i] != NULL; ++i)
+	{
+	    MSG_PUTS(s);
+	    s = ", ";
+	    MSG_PUTS(extra_patches[i]);
+	}
+    }
+
 #ifdef MODIFIED_BY
     MSG_PUTS("\n");
     MSG_PUTS(_("Modified by "));
     MSG_PUTS(MODIFIED_BY);
 #endif
@@ -1251,14 +2070,13 @@ do_intro_line(row, mesg, add_version, at
 }
 
 /*
  * ":intro": clear screen, display intro screen and wait for return.
  */
-/*ARGSUSED*/
     void
 ex_intro(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     screenclear();
     intro_message(TRUE);
     wait_return(TRUE);
 }
--- vim72.orig/src/menu.c
+++ vim72/src/menu.c
@@ -229,19 +229,19 @@ ex_menu(eap)
 	    if (STRNCMP(menu_path, "BuiltIn", 7) == 0)
 	    {
 		if (skipdigits(menu_path + 7) == p)
 		{
 		    menuarg.iconidx = atoi((char *)menu_path + 7);
-		    if (menuarg.iconidx >= TOOLBAR_NAME_COUNT)
+		    if (menuarg.iconidx >= (int)TOOLBAR_NAME_COUNT)
 			menuarg.iconidx = -1;
 		    else
 			menuarg.icon_builtin = TRUE;
 		}
 	    }
 	    else
 	    {
-		for (i = 0; i < TOOLBAR_NAME_COUNT; ++i)
+		for (i = 0; i < (int)TOOLBAR_NAME_COUNT; ++i)
 		    if (STRNCMP(toolbar_names[i], menu_path, p - menu_path)
 									 == 0)
 		    {
 			menuarg.iconidx = i;
 			break;
@@ -1118,10 +1118,11 @@ show_menus(path_name, modes)
 	}
 	name = p;
 	parent = menu;
 	menu = menu->children;
     }
+    vim_free(path_name);
 
     /* Now we have found the matching menu, and we list the mappings */
 						    /* Highlight title */
     MSG_PUTS_TITLE(_("\n--- Menus ---"));
 
@@ -1338,14 +1339,13 @@ set_context_in_menu_cmd(xp, cmd, arg, fo
 
 /*
  * Function given to ExpandGeneric() to obtain the list of (sub)menus (not
  * entries).
  */
-/*ARGSUSED*/
     char_u *
 get_menu_name(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     static vimmenu_T	*menu = NULL;
     char_u		*str;
 
@@ -1375,14 +1375,13 @@ get_menu_name(xp, idx)
 
 /*
  * Function given to ExpandGeneric() to obtain the list of menus and menu
  * entries.
  */
-/*ARGSUSED*/
     char_u *
 get_menu_names(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     static vimmenu_T	*menu = NULL;
     static char_u	tbuffer[256]; /*hack*/
     char_u		*str;
@@ -1736,14 +1735,13 @@ menu_is_hidden(name)
 #if defined(FEAT_CMDL_COMPL) \
 	|| (defined(FEAT_GUI_W32) && defined(FEAT_TEAROFF))
 /*
  * Return TRUE if the menu is the tearoff menu.
  */
-/*ARGSUSED*/
     static int
 menu_is_tearoff(name)
-    char_u *name;
+    char_u *name UNUSED;
 {
 #ifdef FEAT_GUI
     return (STRCMP(name, TEAR_STRING) == 0);
 #else
     return FALSE;
@@ -2340,14 +2338,13 @@ static garray_T menutrans_ga = {0, 0, 0,
 /*
  * ":menutrans".
  * This function is also defined without the +multi_lang feature, in which
  * case the commands are ignored.
  */
-/*ARGSUSED*/
     void
 ex_menutranslate(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
 #ifdef FEAT_MULTI_LANG
     char_u		*arg = eap->arg;
     menutrans_T		*tp;
     int			i;
--- vim72.orig/src/spell.c
+++ vim72/src/spell.c
@@ -75,11 +75,11 @@
  */
 #define RESCORE(word_score, sound_score) ((3 * word_score + sound_score) / 4)
 
 /*
  * Do the opposite: based on a maximum end score and a known sound score,
- * compute the the maximum word score that can be used.
+ * compute the maximum word score that can be used.
  */
 #define MAXSCORE(word_score, sound_score) ((4 * word_score - sound_score) / 3)
 
 /*
  * Vim spell file format: <HEADER>
@@ -467,10 +467,11 @@ struct slang_S
     int		sl_compsylmax;	/* COMPOUNDSYLMAX (default: MAXWLEN) */
     int		sl_compoptions;	/* COMP_* flags */
     garray_T	sl_comppat;	/* CHECKCOMPOUNDPATTERN items */
     regprog_T	*sl_compprog;	/* COMPOUNDRULE turned into a regexp progrm
 				 * (NULL when no compounding) */
+    char_u	*sl_comprules;	/* all COMPOUNDRULE concatenated (or NULL) */
     char_u	*sl_compstartflags; /* flags for first compound word */
     char_u	*sl_compallflags; /* all flags for compound words */
     char_u	sl_nobreak;	/* When TRUE: no spaces between words */
     char_u	*sl_syllable;	/* SYLLABLE repeatable chars or NULL */
     garray_T	sl_syl_items;	/* syllable items */
@@ -623,11 +624,11 @@ typedef struct suggest_S
 #define SUG(ga, i) (((suggest_T *)(ga).ga_data)[i])
 
 /* TRUE if a word appears in the list of banned words.  */
 #define WAS_BANNED(su, word) (!HASHITEM_EMPTY(hash_find(&su->su_banned, word)))
 
-/* Number of suggestions kept when cleaning up.  we need to keep more than
+/* Number of suggestions kept when cleaning up.  We need to keep more than
  * what is displayed, because when rescore_suggestions() is called the score
  * may change and wrong suggestions may be removed later. */
 #define SUG_CLEAN_COUNT(su)    ((su)->su_maxcount < 130 ? 150 : (su)->su_maxcount + 20)
 
 /* Threshold for sorting and cleaning up suggestions.  Don't want to keep lots
@@ -837,11 +838,14 @@ typedef struct trystate_S
 static slang_T *slang_alloc __ARGS((char_u *lang));
 static void slang_free __ARGS((slang_T *lp));
 static void slang_clear __ARGS((slang_T *lp));
 static void slang_clear_sug __ARGS((slang_T *lp));
 static void find_word __ARGS((matchinf_T *mip, int mode));
+static int match_checkcompoundpattern __ARGS((char_u *ptr, int wlen, garray_T *gap));
 static int can_compound __ARGS((slang_T *slang, char_u *word, char_u *flags));
+static int can_be_compound __ARGS((trystate_T *sp, slang_T *slang, char_u *compflags, int flag));
+static int match_compoundrule __ARGS((slang_T *slang, char_u *compflags));
 static int valid_word_prefix __ARGS((int totprefcnt, int arridx, int flags, char_u *word, slang_T *slang, int cond_req));
 static void find_prefix __ARGS((matchinf_T *mip, int mode));
 static int fold_more __ARGS((matchinf_T *mip));
 static int spell_valid_case __ARGS((int wordflags, int treeflags));
 static int no_spell_checking __ARGS((win_T *wp));
@@ -944,34 +948,34 @@ static void close_spellbuf __ARGS((buf_T
  * differ from what the .spl file uses.
  * These must not be called with negative number!
  */
 #ifndef FEAT_MBYTE
 /* Non-multi-byte implementation. */
-# define SPELL_TOFOLD(c) ((c) < 256 ? spelltab.st_fold[c] : (c))
-# define SPELL_TOUPPER(c) ((c) < 256 ? spelltab.st_upper[c] : (c))
+# define SPELL_TOFOLD(c) ((c) < 256 ? (int)spelltab.st_fold[c] : (c))
+# define SPELL_TOUPPER(c) ((c) < 256 ? (int)spelltab.st_upper[c] : (c))
 # define SPELL_ISUPPER(c) ((c) < 256 ? spelltab.st_isu[c] : FALSE)
 #else
 # if defined(HAVE_WCHAR_H)
 #  include <wchar.h>	    /* for towupper() and towlower() */
 # endif
 /* Multi-byte implementation.  For Unicode we can call utf_*(), but don't do
  * that for ASCII, because we don't want to use 'casemap' here.  Otherwise use
  * the "w" library function for characters above 255 if available. */
 # ifdef HAVE_TOWLOWER
 #  define SPELL_TOFOLD(c) (enc_utf8 && (c) >= 128 ? utf_fold(c) \
-	    : (c) < 256 ? spelltab.st_fold[c] : towlower(c))
+	    : (c) < 256 ? (int)spelltab.st_fold[c] : (int)towlower(c))
 # else
 #  define SPELL_TOFOLD(c) (enc_utf8 && (c) >= 128 ? utf_fold(c) \
-	    : (c) < 256 ? spelltab.st_fold[c] : (c))
+	    : (c) < 256 ? (int)spelltab.st_fold[c] : (c))
 # endif
 
 # ifdef HAVE_TOWUPPER
 #  define SPELL_TOUPPER(c) (enc_utf8 && (c) >= 128 ? utf_toupper(c) \
-	    : (c) < 256 ? spelltab.st_upper[c] : towupper(c))
+	    : (c) < 256 ? (int)spelltab.st_upper[c] : (int)towupper(c))
 # else
 #  define SPELL_TOUPPER(c) (enc_utf8 && (c) >= 128 ? utf_toupper(c) \
-	    : (c) < 256 ? spelltab.st_upper[c] : (c))
+	    : (c) < 256 ? (int)spelltab.st_upper[c] : (c))
 # endif
 
 # ifdef HAVE_ISWUPPER
 #  define SPELL_ISUPPER(c) (enc_utf8 && (c) >= 128 ? utf_isupper(c) \
 	    : (c) < 256 ? spelltab.st_isu[c] : iswupper(c))
@@ -1517,10 +1521,15 @@ find_word(mip, mode)
 					? slang->sl_compstartflags
 					: slang->sl_compallflags,
 					    ((unsigned)flags >> 24)))
 		    continue;
 
+		/* If there is a match with a CHECKCOMPOUNDPATTERN rule
+		 * discard the compound word. */
+		if (match_checkcompoundpattern(ptr, wlen, &slang->sl_comppat))
+		    continue;
+
 		if (mode == FIND_COMPOUND)
 		{
 		    int	    capflags;
 
 		    /* Need to check the caps type of the appended compound
@@ -1575,10 +1584,15 @@ find_word(mip, mode)
 			    vim_strncpy(fword, ptr, endlen[endidxcnt]);
 		    }
 		    if (!can_compound(slang, fword, mip->mi_compflags))
 			continue;
 		}
+		else if (slang->sl_comprules != NULL
+			     && !match_compoundrule(slang, mip->mi_compflags))
+		    /* The compound flags collected so far do not match any
+		     * COMPOUNDRULE, discard the compounded word. */
+		    continue;
 	    }
 
 	    /* Check NEEDCOMPOUND: can't use word without compounding. */
 	    else if (flags & WF_NEEDCOMP)
 		continue;
@@ -1725,10 +1739,43 @@ find_word(mip, mode)
 	    break;
     }
 }
 
 /*
+ * Return TRUE if there is a match between the word ptr[wlen] and
+ * CHECKCOMPOUNDPATTERN rules, assuming that we will concatenate with another
+ * word.
+ * A match means that the first part of CHECKCOMPOUNDPATTERN matches at the
+ * end of ptr[wlen] and the second part matches after it.
+ */
+    static int
+match_checkcompoundpattern(ptr, wlen, gap)
+    char_u	*ptr;
+    int		wlen;
+    garray_T	*gap;  /* &sl_comppat */
+{
+    int		i;
+    char_u	*p;
+    int		len;
+
+    for (i = 0; i + 1 < gap->ga_len; i += 2)
+    {
+	p = ((char_u **)gap->ga_data)[i + 1];
+	if (STRNCMP(ptr + wlen, p, STRLEN(p)) == 0)
+	{
+	    /* Second part matches at start of following compound word, now
+	     * check if first part matches at end of previous word. */
+	    p = ((char_u **)gap->ga_data)[i];
+	    len = (int)STRLEN(p);
+	    if (len <= wlen && STRNCMP(ptr + wlen - len, p, len) == 0)
+		return TRUE;
+	}
+    }
+    return FALSE;
+}
+
+/*
  * Return TRUE if "flags" is a valid sequence of compound flags and "word"
  * does not have too many syllables.
  */
     static int
 can_compound(slang, word, flags)
@@ -1771,10 +1818,102 @@ can_compound(slang, word, flags)
 	return (int)STRLEN(flags) < slang->sl_compmax;
     return TRUE;
 }
 
 /*
+ * Return TRUE when the sequence of flags in "compflags" plus "flag" can
+ * possibly form a valid compounded word.  This also checks the COMPOUNDRULE
+ * lines if they don't contain wildcards.
+ */
+    static int
+can_be_compound(sp, slang, compflags, flag)
+    trystate_T	*sp;
+    slang_T	*slang;
+    char_u	*compflags;
+    int		flag;
+{
+    /* If the flag doesn't appear in sl_compstartflags or sl_compallflags
+     * then it can't possibly compound. */
+    if (!byte_in_str(sp->ts_complen == sp->ts_compsplit
+		? slang->sl_compstartflags : slang->sl_compallflags, flag))
+	return FALSE;
+
+    /* If there are no wildcards, we can check if the flags collected so far
+     * possibly can form a match with COMPOUNDRULE patterns.  This only
+     * makes sense when we have two or more words. */
+    if (slang->sl_comprules != NULL && sp->ts_complen > sp->ts_compsplit)
+    {
+	int v;
+
+	compflags[sp->ts_complen] = flag;
+	compflags[sp->ts_complen + 1] = NUL;
+	v = match_compoundrule(slang, compflags + sp->ts_compsplit);
+	compflags[sp->ts_complen] = NUL;
+	return v;
+    }
+
+    return TRUE;
+}
+
+
+/*
+ * Return TRUE if the compound flags in compflags[] match the start of any
+ * compound rule.  This is used to stop trying a compound if the flags
+ * collected so far can't possibly match any compound rule.
+ * Caller must check that slang->sl_comprules is not NULL.
+ */
+    static int
+match_compoundrule(slang, compflags)
+    slang_T	*slang;
+    char_u	*compflags;
+{
+    char_u	*p;
+    int		i;
+    int		c;
+
+    /* loop over all the COMPOUNDRULE entries */
+    for (p = slang->sl_comprules; *p != NUL; ++p)
+    {
+	/* loop over the flags in the compound word we have made, match
+	 * them against the current rule entry */
+	for (i = 0; ; ++i)
+	{
+	    c = compflags[i];
+	    if (c == NUL)
+		/* found a rule that matches for the flags we have so far */
+		return TRUE;
+	    if (*p == '/' || *p == NUL)
+		break;  /* end of rule, it's too short */
+	    if (*p == '[')
+	    {
+		int match = FALSE;
+
+		/* compare against all the flags in [] */
+		++p;
+		while (*p != ']' && *p != NUL)
+		    if (*p++ == c)
+			match = TRUE;
+		if (!match)
+		    break;  /* none matches */
+	    }
+	    else if (*p != c)
+		break;  /* flag of word doesn't match flag in pattern */
+	    ++p;
+	}
+
+	/* Skip to the next "/", where the next pattern starts. */
+	p = vim_strchr(p, '/');
+	if (p == NULL)
+	    break;
+    }
+
+    /* Checked all the rules and none of them match the flags, so there
+     * can't possibly be a compound starting with these flags. */
+    return FALSE;
+}
+
+/*
  * Return non-zero if the prefix indicated by "arridx" matches with the prefix
  * ID in "flags" for the word "word".
  * The WF_RAREPFX flag is included in the return value for a rare prefix.
  */
     static int
@@ -2235,11 +2374,11 @@ spell_move_to(wp, dir, allwords, curline
 		    give_warning((char_u *)_(bot_top_msg), TRUE);
 	    }
 
 	    /* If we are back at the starting line and there is no match then
 	     * give up. */
-	    if (lnum == wp->w_cursor.lnum && !found_one)
+	    if (lnum == wp->w_cursor.lnum && (!found_one || wrapped))
 		break;
 
 	    /* Skip the characters at the start of the next line that were
 	     * included in a match crossing line boundaries. */
 	    if (attr == HLF_COUNT)
@@ -2511,13 +2650,15 @@ slang_clear(lp)
 
     vim_free(lp->sl_midword);
     lp->sl_midword = NULL;
 
     vim_free(lp->sl_compprog);
+    vim_free(lp->sl_comprules);
     vim_free(lp->sl_compstartflags);
     vim_free(lp->sl_compallflags);
     lp->sl_compprog = NULL;
+    lp->sl_comprules = NULL;
     lp->sl_compstartflags = NULL;
     lp->sl_compallflags = NULL;
 
     vim_free(lp->sl_syllable);
     lp->sl_syllable = NULL;
@@ -3458,10 +3599,11 @@ read_compound(fd, slang, len)
     int		atstart;
     char_u	*pat;
     char_u	*pp;
     char_u	*cp;
     char_u	*ap;
+    char_u	*crp;
     int		cnt;
     garray_T	*gap;
 
     if (todo < 2)
 	return SP_FORMERROR;	/* need at least two bytes */
@@ -3543,10 +3685,16 @@ read_compound(fd, slang, len)
 	return SP_OTHERERROR;
     }
     slang->sl_compallflags = ap;
     *ap = NUL;
 
+    /* And a list of all patterns in their original form, for checking whether
+     * compounding may work in match_compoundrule().  This is freed when we
+     * encounter a wildcard, the check doesn't work then. */
+    crp = alloc(todo + 1);
+    slang->sl_comprules = crp;
+
     pp = pat;
     *pp++ = '^';
     *pp++ = '\\';
     *pp++ = '(';
 
@@ -3585,10 +3733,24 @@ read_compound(fd, slang, len)
 		}
 		if (atstart == 1)
 		    atstart = 0;
 	    }
 	}
+
+	/* Copy flag to "sl_comprules", unless we run into a wildcard. */
+	if (crp != NULL)
+	{
+	    if (c == '+' || c == '*')
+	    {
+		vim_free(slang->sl_comprules);
+		slang->sl_comprules = NULL;
+		crp = NULL;
+	    }
+	    else
+		*crp++ = c;
+	}
+
 	if (c == '/')	    /* slash separates two items */
 	{
 	    *pp++ = '\\';
 	    *pp++ = '|';
 	    atstart = 1;
@@ -3609,10 +3771,13 @@ read_compound(fd, slang, len)
     *pp++ = '\\';
     *pp++ = ')';
     *pp++ = '$';
     *pp = NUL;
 
+    if (crp != NULL)
+	*crp = NUL;
+
     slang->sl_compprog = vim_regcomp(pat, RE_MAGIC + RE_STRING + RE_STRICT);
     vim_free(pat);
     if (slang->sl_compprog == NULL)
 	return SP_FORMERROR;
 
@@ -4789,17 +4954,20 @@ typedef struct compitem_S
 
 /*
  * Structure that is used to store the items in the word tree.  This avoids
  * the need to keep track of each allocated thing, everything is freed all at
  * once after ":mkspell" is done.
+ * Note: "sb_next" must be just before "sb_data" to make sure the alignment of
+ * "sb_data" is correct for systems where pointers must be aligned on
+ * pointer-size boundaries and sizeof(pointer) > sizeof(int) (e.g., Sparc).
  */
 #define  SBLOCKSIZE 16000	/* size of sb_data */
 typedef struct sblock_S sblock_T;
 struct sblock_S
 {
-    sblock_T	*sb_next;	/* next block in list */
     int		sb_used;	/* nr of bytes already in use */
+    sblock_T	*sb_next;	/* next block in list */
     char_u	sb_data[1];	/* data, actually longer */
 };
 
 /*
  * A node in the tree.
@@ -4913,10 +5081,11 @@ typedef struct spellinfo_S
     int		si_newprefID;	/* current value for ah_newID */
     int		si_newcompID;	/* current value for compound ID */
 } spellinfo_T;
 
 static afffile_T *spell_read_aff __ARGS((spellinfo_T *spin, char_u *fname));
+static int is_aff_rule __ARGS((char_u **items, int itemcnt, char *rulename, int	 mincount));
 static void aff_process_flags __ARGS((afffile_T *affile, affentry_T *entry));
 static int spell_info_item __ARGS((char_u *s));
 static unsigned affitem2flag __ARGS((int flagtype, char_u *item, char_u	*fname, int lnum));
 static unsigned get_affitem __ARGS((int flagtype, char_u **pp));
 static void process_compflags __ARGS((spellinfo_T *spin, afffile_T *aff, char_u *compflags));
@@ -4948,11 +5117,11 @@ static void wordtree_compress __ARGS((sp
 static int node_compress __ARGS((spellinfo_T *spin, wordnode_T *node, hashtab_T *ht, int *tot));
 static int node_equal __ARGS((wordnode_T *n1, wordnode_T *n2));
 static void put_sugtime __ARGS((spellinfo_T *spin, FILE *fd));
 static int write_vim_spell __ARGS((spellinfo_T *spin, char_u *fname));
 static void clear_node __ARGS((wordnode_T *node));
-static int put_node __ARGS((FILE *fd, wordnode_T *node, int index, int regionmask, int prefixtree));
+static int put_node __ARGS((FILE *fd, wordnode_T *node, int idx, int regionmask, int prefixtree));
 static void spell_make_sugfile __ARGS((spellinfo_T *spin, char_u *wfname));
 static int sug_filltree __ARGS((spellinfo_T *spin, slang_T *slang));
 static int sug_maketable __ARGS((spellinfo_T *spin));
 static int sug_filltable __ARGS((spellinfo_T *spin, wordnode_T *node, int startwordnr, garray_T *gap));
 static int offset2bytes __ARGS((int nr, char_u *buf));
@@ -5221,12 +5390,11 @@ spell_read_aff(spin, fname)
 	}
 
 	/* Handle non-empty lines. */
 	if (itemcnt > 0)
 	{
-	    if (STRCMP(items[0], "SET") == 0 && itemcnt == 2
-						       && aff->af_enc == NULL)
+	    if (is_aff_rule(items, itemcnt, "SET", 2) && aff->af_enc == NULL)
 	    {
 #ifdef FEAT_MBYTE
 		/* Setup for conversion from "ENC" to 'encoding'. */
 		aff->af_enc = enc_canonize(items[1]);
 		if (aff->af_enc != NULL && !spin->si_ascii
@@ -5237,11 +5405,11 @@ spell_read_aff(spin, fname)
 		spin->si_conv.vc_fail = TRUE;
 #else
 		    smsg((char_u *)_("Conversion in %s not supported"), fname);
 #endif
 	    }
-	    else if (STRCMP(items[0], "FLAG") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "FLAG", 2)
 					      && aff->af_flagtype == AFT_CHAR)
 	    {
 		if (STRCMP(items[1], "long") == 0)
 		    aff->af_flagtype = AFT_LONG;
 		else if (STRCMP(items[1], "num") == 0)
@@ -5282,90 +5450,92 @@ spell_read_aff(spin, fname)
 			STRCAT(p, " ");
 			STRCAT(p, items[1]);
 			spin->si_info = p;
 		    }
 	    }
-	    else if (STRCMP(items[0], "MIDWORD") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "MIDWORD", 2)
 							   && midword == NULL)
 	    {
 		midword = getroom_save(spin, items[1]);
 	    }
-	    else if (STRCMP(items[0], "TRY") == 0 && itemcnt == 2)
+	    else if (is_aff_rule(items, itemcnt, "TRY", 2))
 	    {
 		/* ignored, we look in the tree for what chars may appear */
 	    }
 	    /* TODO: remove "RAR" later */
-	    else if ((STRCMP(items[0], "RAR") == 0
-			|| STRCMP(items[0], "RARE") == 0) && itemcnt == 2
-						       && aff->af_rare == 0)
+	    else if ((is_aff_rule(items, itemcnt, "RAR", 2)
+			|| is_aff_rule(items, itemcnt, "RARE", 2))
+							 && aff->af_rare == 0)
 	    {
 		aff->af_rare = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
 	    /* TODO: remove "KEP" later */
-	    else if ((STRCMP(items[0], "KEP") == 0
-		    || STRCMP(items[0], "KEEPCASE") == 0) && itemcnt == 2
+	    else if ((is_aff_rule(items, itemcnt, "KEP", 2)
+			|| is_aff_rule(items, itemcnt, "KEEPCASE", 2))
 						     && aff->af_keepcase == 0)
 	    {
 		aff->af_keepcase = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "BAD") == 0 && itemcnt == 2
-						       && aff->af_bad == 0)
+	    else if ((is_aff_rule(items, itemcnt, "BAD", 2)
+			|| is_aff_rule(items, itemcnt, "FORBIDDENWORD", 2))
+							  && aff->af_bad == 0)
 	    {
 		aff->af_bad = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "NEEDAFFIX") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "NEEDAFFIX", 2)
 						    && aff->af_needaffix == 0)
 	    {
 		aff->af_needaffix = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "CIRCUMFIX") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "CIRCUMFIX", 2)
 						    && aff->af_circumfix == 0)
 	    {
 		aff->af_circumfix = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "NOSUGGEST") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "NOSUGGEST", 2)
 						    && aff->af_nosuggest == 0)
 	    {
 		aff->af_nosuggest = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "NEEDCOMPOUND") == 0 && itemcnt == 2
+	    else if ((is_aff_rule(items, itemcnt, "NEEDCOMPOUND", 2)
+			|| is_aff_rule(items, itemcnt, "ONLYINCOMPOUND", 2))
 						     && aff->af_needcomp == 0)
 	    {
 		aff->af_needcomp = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDROOT") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDROOT", 2)
 						     && aff->af_comproot == 0)
 	    {
 		aff->af_comproot = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDFORBIDFLAG") == 0
-				   && itemcnt == 2 && aff->af_compforbid == 0)
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDFORBIDFLAG", 2)
+						   && aff->af_compforbid == 0)
 	    {
 		aff->af_compforbid = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 		if (aff->af_pref.ht_used > 0)
 		    smsg((char_u *)_("Defining COMPOUNDFORBIDFLAG after PFX item may give wrong results in %s line %d"),
 			    fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDPERMITFLAG") == 0
-				   && itemcnt == 2 && aff->af_comppermit == 0)
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDPERMITFLAG", 2)
+						   && aff->af_comppermit == 0)
 	    {
 		aff->af_comppermit = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 		if (aff->af_pref.ht_used > 0)
 		    smsg((char_u *)_("Defining COMPOUNDPERMITFLAG after PFX item may give wrong results in %s line %d"),
 			    fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDFLAG") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDFLAG", 2)
 							 && compflags == NULL)
 	    {
 		/* Turn flag "c" into COMPOUNDRULE compatible string "c+",
 		 * "Na" into "Na+", "1234" into "1234+". */
 		p = getroom(spin, STRLEN(items[1]) + 2, FALSE);
@@ -5374,11 +5544,19 @@ spell_read_aff(spin, fname)
 		    STRCPY(p, items[1]);
 		    STRCAT(p, "+");
 		    compflags = p;
 		}
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDRULE") == 0 && itemcnt == 2)
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDRULES", 2))
+	    {
+		/* We don't use the count, but do check that it's a number and
+		 * not COMPOUNDRULE mistyped. */
+		if (atoi((char *)items[1]) == 0)
+		    smsg((char_u *)_("Wrong COMPOUNDRULES value in %s line %d: %s"),
+						       fname, lnum, items[1]);
+	    }
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDRULE", 2))
 	    {
 		/* Concatenate this string to previously defined ones, using a
 		 * slash to separate them. */
 		l = (int)STRLEN(items[1]) + 1;
 		if (compflags != NULL)
@@ -5393,60 +5571,57 @@ spell_read_aff(spin, fname)
 		    }
 		    STRCAT(p, items[1]);
 		    compflags = p;
 		}
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDWORDMAX") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDWORDMAX", 2)
 							      && compmax == 0)
 	    {
 		compmax = atoi((char *)items[1]);
 		if (compmax == 0)
 		    smsg((char_u *)_("Wrong COMPOUNDWORDMAX value in %s line %d: %s"),
 						       fname, lnum, items[1]);
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDMIN") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDMIN", 2)
 							   && compminlen == 0)
 	    {
 		compminlen = atoi((char *)items[1]);
 		if (compminlen == 0)
 		    smsg((char_u *)_("Wrong COMPOUNDMIN value in %s line %d: %s"),
 						       fname, lnum, items[1]);
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDSYLMAX") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDSYLMAX", 2)
 							   && compsylmax == 0)
 	    {
 		compsylmax = atoi((char *)items[1]);
 		if (compsylmax == 0)
 		    smsg((char_u *)_("Wrong COMPOUNDSYLMAX value in %s line %d: %s"),
 						       fname, lnum, items[1]);
 	    }
-	    else if (STRCMP(items[0], "CHECKCOMPOUNDDUP") == 0 && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDDUP", 1))
 	    {
 		compoptions |= COMP_CHECKDUP;
 	    }
-	    else if (STRCMP(items[0], "CHECKCOMPOUNDREP") == 0 && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDREP", 1))
 	    {
 		compoptions |= COMP_CHECKREP;
 	    }
-	    else if (STRCMP(items[0], "CHECKCOMPOUNDCASE") == 0 && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDCASE", 1))
 	    {
 		compoptions |= COMP_CHECKCASE;
 	    }
-	    else if (STRCMP(items[0], "CHECKCOMPOUNDTRIPLE") == 0
-							      && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDTRIPLE", 1))
 	    {
 		compoptions |= COMP_CHECKTRIPLE;
 	    }
-	    else if (STRCMP(items[0], "CHECKCOMPOUNDPATTERN") == 0
-							      && itemcnt == 2)
+	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDPATTERN", 2))
 	    {
 		if (atoi((char *)items[1]) == 0)
 		    smsg((char_u *)_("Wrong CHECKCOMPOUNDPATTERN value in %s line %d: %s"),
 						       fname, lnum, items[1]);
 	    }
-	    else if (STRCMP(items[0], "CHECKCOMPOUNDPATTERN") == 0
-							      && itemcnt == 3)
+	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDPATTERN", 3))
 	    {
 		garray_T    *gap = &spin->si_comppat;
 		int	    i;
 
 		/* Only add the couple if it isn't already there. */
@@ -5461,28 +5636,28 @@ spell_read_aff(spin, fname)
 					       = getroom_save(spin, items[1]);
 		    ((char_u **)(gap->ga_data))[gap->ga_len++]
 					       = getroom_save(spin, items[2]);
 		}
 	    }
-	    else if (STRCMP(items[0], "SYLLABLE") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "SYLLABLE", 2)
 							  && syllable == NULL)
 	    {
 		syllable = getroom_save(spin, items[1]);
 	    }
-	    else if (STRCMP(items[0], "NOBREAK") == 0 && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "NOBREAK", 1))
 	    {
 		spin->si_nobreak = TRUE;
 	    }
-	    else if (STRCMP(items[0], "NOSPLITSUGS") == 0 && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "NOSPLITSUGS", 1))
 	    {
 		spin->si_nosplitsugs = TRUE;
 	    }
-	    else if (STRCMP(items[0], "NOSUGFILE") == 0 && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "NOSUGFILE", 1))
 	    {
 		spin->si_nosugfile = TRUE;
 	    }
-	    else if (STRCMP(items[0], "PFXPOSTPONE") == 0 && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "PFXPOSTPONE", 1))
 	    {
 		aff->af_pfxpostpone = TRUE;
 	    }
 	    else if ((STRCMP(items[0], "PFX") == 0
 					      || STRCMP(items[0], "SFX") == 0)
@@ -5769,28 +5944,24 @@ spell_read_aff(spin, fname)
 			    cur_aff->ah_newID = 0;
 			}
 		    }
 		}
 	    }
-	    else if (STRCMP(items[0], "FOL") == 0 && itemcnt == 2
-							       && fol == NULL)
+	    else if (is_aff_rule(items, itemcnt, "FOL", 2) && fol == NULL)
 	    {
 		fol = vim_strsave(items[1]);
 	    }
-	    else if (STRCMP(items[0], "LOW") == 0 && itemcnt == 2
-							       && low == NULL)
+	    else if (is_aff_rule(items, itemcnt, "LOW", 2) && low == NULL)
 	    {
 		low = vim_strsave(items[1]);
 	    }
-	    else if (STRCMP(items[0], "UPP") == 0 && itemcnt == 2
-							       && upp == NULL)
+	    else if (is_aff_rule(items, itemcnt, "UPP", 2) && upp == NULL)
 	    {
 		upp = vim_strsave(items[1]);
 	    }
-	    else if ((STRCMP(items[0], "REP") == 0
-			|| STRCMP(items[0], "REPSAL") == 0)
-		    && itemcnt == 2)
+	    else if (is_aff_rule(items, itemcnt, "REP", 2)
+		     || is_aff_rule(items, itemcnt, "REPSAL", 2))
 	    {
 		/* Ignore REP/REPSAL count */;
 		if (!isdigit(*items[1]))
 		    smsg((char_u *)_("Expected REP(SAL) count in %s line %d"),
 								 fname, lnum);
@@ -5817,11 +5988,11 @@ spell_read_aff(spin, fname)
 		    add_fromto(spin, items[0][3] == 'S'
 					 ? &spin->si_repsal
 					 : &spin->si_rep, items[1], items[2]);
 		}
 	    }
-	    else if (STRCMP(items[0], "MAP") == 0 && itemcnt == 2)
+	    else if (is_aff_rule(items, itemcnt, "MAP", 2))
 	    {
 		/* MAP item or count */
 		if (!found_map)
 		{
 		    /* First line contains the count. */
@@ -5854,13 +6025,12 @@ spell_read_aff(spin, fname)
 		     * slashes. */
 		    ga_concat(&spin->si_map, items[1]);
 		    ga_append(&spin->si_map, '/');
 		}
 	    }
-	    /* Accept "SAL from to" and "SAL from to # comment". */
-	    else if (STRCMP(items[0], "SAL") == 0
-		    && (itemcnt == 3 || (itemcnt > 3 && items[3][0] == '#')))
+	    /* Accept "SAL from to" and "SAL from to  #comment". */
+	    else if (is_aff_rule(items, itemcnt, "SAL", 3))
 	    {
 		if (do_sal)
 		{
 		    /* SAL item (sounds-a-like)
 		     * Either one of the known keys or a from-to pair. */
@@ -5875,16 +6045,16 @@ spell_read_aff(spin, fname)
 			add_fromto(spin, &spin->si_sal, items[1],
 				     STRCMP(items[2], "_") == 0 ? (char_u *)""
 								: items[2]);
 		}
 	    }
-	    else if (STRCMP(items[0], "SOFOFROM") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "SOFOFROM", 2)
 							  && sofofrom == NULL)
 	    {
 		sofofrom = getroom_save(spin, items[1]);
 	    }
-	    else if (STRCMP(items[0], "SOFOTO") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "SOFOTO", 2)
 							    && sofoto == NULL)
 	    {
 		sofoto = getroom_save(spin, items[1]);
 	    }
 	    else if (STRCMP(items[0], "COMMON") == 0)
@@ -5978,11 +6148,11 @@ spell_read_aff(spin, fname)
 	if (spin->si_newcompID == 127 || spin->si_newcompID == 255)
 	    MSG(_("Too many postponed prefixes"));
 	else if (spin->si_newprefID == 0 || spin->si_newprefID == 127)
 	    MSG(_("Too many compound flags"));
 	else
-	    MSG(_("Too many posponed prefixes and/or compound flags"));
+	    MSG(_("Too many postponed prefixes and/or compound flags"));
     }
 
     if (syllable != NULL)
     {
 	aff_check_string(spin->si_syllable, syllable, "SYLLABLE");
@@ -6015,10 +6185,26 @@ spell_read_aff(spin, fname)
     fclose(fd);
     return aff;
 }
 
 /*
+ * Return TRUE when items[0] equals "rulename", there are "mincount" items or
+ * a comment is following after item "mincount".
+ */
+    static int
+is_aff_rule(items, itemcnt, rulename, mincount)
+    char_u	**items;
+    int		itemcnt;
+    char	*rulename;
+    int		mincount;
+{
+    return (STRCMP(items[0], rulename) == 0
+	    && (itemcnt == mincount
+		|| (itemcnt > mincount && items[mincount][0] == '#')));
+}
+
+/*
  * For affix "entry" move COMPOUNDFORBIDFLAG and COMPOUNDPERMITFLAG from
  * ae_flags to ae_comppermit and ae_compforbid.
  */
     static void
 aff_process_flags(affile, entry)
@@ -7864,11 +8050,11 @@ put_sugtime(spin, fd)
     int		i;
 
     /* time_t can be up to 8 bytes in size, more than long_u, thus we
      * can't use put_bytes() here. */
     for (i = 7; i >= 0; --i)
-	if (i + 1 > sizeof(time_t))
+	if (i + 1 > (int)sizeof(time_t))
 	    /* ">>" doesn't work well when shifting more bits than avail */
 	    putc(0, fd);
 	else
 	{
 	    c = (unsigned)spin->si_sugtime >> (i * 8);
@@ -7924,25 +8110,27 @@ write_vim_spell(spin, fname)
     garray_T	*gap;
     fromto_T	*ftp;
     char_u	*p;
     int		rr;
     int		retval = OK;
+    size_t	fwv = 1;  /* collect return value of fwrite() to avoid
+			     warnings from picky compiler */
 
     fd = mch_fopen((char *)fname, "w");
     if (fd == NULL)
     {
 	EMSG2(_(e_notopen), fname);
 	return FAIL;
     }
 
     /* <HEADER>: <fileID> <versionnr> */
 							    /* <fileID> */
-    if (fwrite(VIMSPELLMAGIC, VIMSPELLMAGICL, (size_t)1, fd) != 1)
-    {
-	EMSG(_(e_write));
-	retval = FAIL;
-    }
+    fwv &= fwrite(VIMSPELLMAGIC, VIMSPELLMAGICL, (size_t)1, fd);
+    if (fwv != (size_t)1)
+	/* Catch first write error, don't try writing more. */
+	goto theend;
+
     putc(VIMSPELLVERSION, fd);				    /* <versionnr> */
 
     /*
      * <SECTIONS>: <section> ... <sectionend>
      */
@@ -7953,22 +8141,22 @@ write_vim_spell(spin, fname)
 	putc(SN_INFO, fd);				/* <sectionID> */
 	putc(0, fd);					/* <sectionflags> */
 
 	i = (int)STRLEN(spin->si_info);
 	put_bytes(fd, (long_u)i, 4);			/* <sectionlen> */
-	fwrite(spin->si_info, (size_t)i, (size_t)1, fd); /* <infotext> */
+	fwv &= fwrite(spin->si_info, (size_t)i, (size_t)1, fd); /* <infotext> */
     }
 
     /* SN_REGION: <regionname> ...
      * Write the region names only if there is more than one. */
     if (spin->si_region_count > 1)
     {
 	putc(SN_REGION, fd);				/* <sectionID> */
 	putc(SNF_REQUIRED, fd);				/* <sectionflags> */
 	l = spin->si_region_count * 2;
 	put_bytes(fd, (long_u)l, 4);			/* <sectionlen> */
-	fwrite(spin->si_region_name, (size_t)l, (size_t)1, fd);
+	fwv &= fwrite(spin->si_region_name, (size_t)l, (size_t)1, fd);
 							/* <regionname> ... */
 	regionmask = (1 << spin->si_region_count) - 1;
     }
     else
 	regionmask = 0;
@@ -8014,22 +8202,23 @@ write_vim_spell(spin, fname)
 		flags |= CF_UPPER;
 	    fputc(flags, fd);				/* <charflags> */
 	}
 
 	put_bytes(fd, (long_u)l, 2);			/* <folcharslen> */
-	fwrite(folchars, (size_t)l, (size_t)1, fd);	/* <folchars> */
+	fwv &= fwrite(folchars, (size_t)l, (size_t)1, fd); /* <folchars> */
     }
 
     /* SN_MIDWORD: <midword> */
     if (spin->si_midword != NULL)
     {
 	putc(SN_MIDWORD, fd);				/* <sectionID> */
 	putc(SNF_REQUIRED, fd);				/* <sectionflags> */
 
 	i = (int)STRLEN(spin->si_midword);
 	put_bytes(fd, (long_u)i, 4);			/* <sectionlen> */
-	fwrite(spin->si_midword, (size_t)i, (size_t)1, fd); /* <midword> */
+	fwv &= fwrite(spin->si_midword, (size_t)i, (size_t)1, fd);
+							/* <midword> */
     }
 
     /* SN_PREFCOND: <prefcondcnt> <prefcond> ... */
     if (spin->si_prefcond.ga_len > 0)
     {
@@ -8111,11 +8300,12 @@ write_vim_spell(spin, fname)
 	    for (rr = 1; rr <= 2; ++rr)
 	    {
 		p = rr == 1 ? ftp->ft_from : ftp->ft_to;
 		l = (int)STRLEN(p);
 		putc(l, fd);
-		fwrite(p, l, (size_t)1, fd);
+		if (l > 0)
+		    fwv &= fwrite(p, l, (size_t)1, fd);
 	    }
 	}
 
     }
 
@@ -8129,15 +8319,15 @@ write_vim_spell(spin, fname)
 	l = (int)STRLEN(spin->si_sofofr);
 	put_bytes(fd, (long_u)(l + STRLEN(spin->si_sofoto) + 4), 4);
 							/* <sectionlen> */
 
 	put_bytes(fd, (long_u)l, 2);			/* <sofofromlen> */
-	fwrite(spin->si_sofofr, l, (size_t)1, fd);	/* <sofofrom> */
+	fwv &= fwrite(spin->si_sofofr, l, (size_t)1, fd); /* <sofofrom> */
 
 	l = (int)STRLEN(spin->si_sofoto);
 	put_bytes(fd, (long_u)l, 2);			/* <sofotolen> */
-	fwrite(spin->si_sofoto, l, (size_t)1, fd);	/* <sofoto> */
+	fwv &= fwrite(spin->si_sofoto, l, (size_t)1, fd); /* <sofoto> */
     }
 
     /* SN_WORDS: <word> ...
      * This is for making suggestions, section is not required. */
     if (spin->si_commonwords.ht_used > 0)
@@ -8158,11 +8348,11 @@ write_vim_spell(spin, fname)
 		if (!HASHITEM_EMPTY(hi))
 		{
 		    l = (int)STRLEN(hi->hi_key) + 1;
 		    len += l;
 		    if (round == 2)			/* <word> */
-			fwrite(hi->hi_key, (size_t)l, (size_t)1, fd);
+			fwv &= fwrite(hi->hi_key, (size_t)l, (size_t)1, fd);
 		    --todo;
 		}
 	    if (round == 1)
 		put_bytes(fd, (long_u)len, 4);		/* <sectionlen> */
 	}
@@ -8174,11 +8364,11 @@ write_vim_spell(spin, fname)
     {
 	putc(SN_MAP, fd);				/* <sectionID> */
 	putc(0, fd);					/* <sectionflags> */
 	l = spin->si_map.ga_len;
 	put_bytes(fd, (long_u)l, 4);			/* <sectionlen> */
-	fwrite(spin->si_map.ga_data, (size_t)l, (size_t)1, fd);
+	fwv &= fwrite(spin->si_map.ga_data, (size_t)l, (size_t)1, fd);
 							/* <mapstr> */
     }
 
     /* SN_SUGFILE: <timestamp>
      * This is used to notify that a .sug file may be available and at the
@@ -8230,14 +8420,15 @@ write_vim_spell(spin, fname)
 							/* <comppatcount> */
 	for (i = 0; i < spin->si_comppat.ga_len; ++i)
 	{
 	    p = ((char_u **)(spin->si_comppat.ga_data))[i];
 	    putc((int)STRLEN(p), fd);			/* <comppatlen> */
-	    fwrite(p, (size_t)STRLEN(p), (size_t)1, fd);/* <comppattext> */
+	    fwv &= fwrite(p, (size_t)STRLEN(p), (size_t)1, fd);
+							/* <comppattext> */
 	}
 							/* <compflags> */
-	fwrite(spin->si_compflags, (size_t)STRLEN(spin->si_compflags),
+	fwv &= fwrite(spin->si_compflags, (size_t)STRLEN(spin->si_compflags),
 							       (size_t)1, fd);
     }
 
     /* SN_NOBREAK: NOBREAK flag */
     if (spin->si_nobreak)
@@ -8257,11 +8448,12 @@ write_vim_spell(spin, fname)
 	putc(SN_SYLLABLE, fd);				/* <sectionID> */
 	putc(0, fd);					/* <sectionflags> */
 
 	l = (int)STRLEN(spin->si_syllable);
 	put_bytes(fd, (long_u)l, 4);			/* <sectionlen> */
-	fwrite(spin->si_syllable, (size_t)l, (size_t)1, fd); /* <syllable> */
+	fwv &= fwrite(spin->si_syllable, (size_t)l, (size_t)1, fd);
+							/* <syllable> */
     }
 
     /* end of <SECTIONS> */
     putc(SN_END, fd);					/* <sectionend> */
 
@@ -8293,17 +8485,22 @@ write_vim_spell(spin, fname)
 
 	/* Write the nodes. */
 	(void)put_node(fd, tree, 0, regionmask, round == 3);
     }
 
-    /* Write another byte to check for errors. */
+    /* Write another byte to check for errors (file system full). */
     if (putc(0, fd) == EOF)
 	retval = FAIL;
-
+theend:
     if (fclose(fd) == EOF)
 	retval = FAIL;
 
+    if (fwv != (size_t)1)
+	retval = FAIL;
+    if (retval == FAIL)
+	EMSG(_(e_write));
+
     return retval;
 }
 
 /*
  * Clear the index and wnode fields of "node", it siblings and its
@@ -9888,10 +10085,11 @@ write_spell_prefcond(fd, gap)
 {
     int		i;
     char_u	*p;
     int		len;
     int		totlen;
+    size_t	x = 1;  /* collect return value of fwrite() */
 
     if (fd != NULL)
 	put_bytes(fd, (long_u)gap->ga_len, 2);	    /* <prefcondcnt> */
 
     totlen = 2 + gap->ga_len; /* length of <prefcondcnt> and <condlen> bytes */
@@ -9904,11 +10102,11 @@ write_spell_prefcond(fd, gap)
 	{
 	    len = (int)STRLEN(p);
 	    if (fd != NULL)
 	    {
 		fputc(len, fd);
-		fwrite(p, (size_t)len, (size_t)1, fd);
+		x &= fwrite(p, (size_t)len, (size_t)1, fd);
 	    }
 	    totlen += len;
 	}
 	else if (fd != NULL)
 	    fputc(0, fd);
@@ -10052,10 +10250,11 @@ spell_suggest(count)
     int		mouse_used;
     int		need_cap;
     int		limit;
     int		selected = count;
     int		badlen = 0;
+    int		msg_scroll_save = msg_scroll;
 
     if (no_spell_checking(curwin))
 	return;
 
 #ifdef FEAT_VISUAL
@@ -10105,11 +10304,14 @@ spell_suggest(count)
     /* Get the word and its length. */
 
     /* Figure out if the word should be capitalised. */
     need_cap = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col);
 
-    line = ml_get_curline();
+    /* Make a copy of current line since autocommands may free the line. */
+    line = vim_strsave(ml_get_curline());
+    if (line == NULL)
+	goto skip;
 
     /* Get the list of suggestions.  Limit to 'lines' - 2 or the number in
      * 'spellsuggest', whatever is smaller. */
     if (sps_limit > (int)Rows - 2)
 	limit = (int)Rows - 2;
@@ -10216,11 +10418,13 @@ spell_suggest(count)
 #endif
 	/* Ask for choice. */
 	selected = prompt_for_number(&mouse_used);
 	if (mouse_used)
 	    selected -= lines_left;
-	lines_left = Rows;	/* avoid more prompt */
+	lines_left = Rows;		/* avoid more prompt */
+	/* don't delay for 'smd' in normal_cmd() */
+	msg_scroll = msg_scroll_save;
     }
 
     if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor() == OK)
     {
 	/* Save the from and to text for :spellrepall. */
@@ -10241,11 +10445,12 @@ spell_suggest(count)
 	    repl_from = vim_strnsave(sug.su_badptr, stp->st_orglen);
 	    repl_to = vim_strsave(stp->st_word);
 	}
 
 	/* Replace the word. */
-	p = alloc((unsigned)STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1);
+	p = alloc((unsigned)STRLEN(line) - stp->st_orglen
+						       + stp->st_wordlen + 1);
 	if (p != NULL)
 	{
 	    c = (int)(sug.su_badptr - line);
 	    mch_memmove(p, line, c);
 	    STRCPY(p + c, stp->st_word);
@@ -10266,10 +10471,12 @@ spell_suggest(count)
     }
     else
 	curwin->w_cursor = prev_cursor;
 
     spell_find_cleanup(&sug);
+skip:
+    vim_free(line);
 }
 
 /*
  * Check if the word at line "lnum" column "col" is required to start with a
  * capital.  This uses 'spellcapcheck' of the current buffer.
@@ -10341,14 +10548,13 @@ check_need_cap(lnum, col)
 
 
 /*
  * ":spellrepall"
  */
-/*ARGSUSED*/
     void
 ex_spellrepall(eap)
-    exarg_T *eap;
+    exarg_T *eap UNUSED;
 {
     pos_T	pos = curwin->w_cursor;
     char_u	*frompat;
     int		addlen;
     char_u	*line;
@@ -10728,11 +10934,11 @@ spell_suggest_intern(su, interactive)
 	    /* Adjust the word score for the suggestions found so far for how
 	     * they sounds like. */
 	    rescore_suggestions(su);
 
 	/*
-	 * While going throught the soundfold tree "su_maxscore" is the score
+	 * While going through the soundfold tree "su_maxscore" is the score
 	 * for the soundfold word, limits the changes that are being tried,
 	 * and "su_sfmaxscore" the rescored score, which is set by
 	 * cleanup_suggestions().
 	 * First find words with a small edit distance, because this is much
 	 * faster and often already finds the top-N suggestions.  If we didn't
@@ -11212,11 +11418,11 @@ suggest_trie_walk(su, lp, fword, soundfo
     int		soundfold;
 {
     char_u	tword[MAXWLEN];	    /* good word collected so far */
     trystate_T	stack[MAXWLEN];
     char_u	preword[MAXWLEN * 3]; /* word found with proper case;
-				       * concatanation of prefix compound
+				       * concatenation of prefix compound
 				       * words and split word.  NUL terminated
 				       * when going deeper but not when coming
 				       * back. */
     char_u	compflags[MAXWLEN];	/* compound flags, one for each word */
     trystate_T	*sp;
@@ -11478,19 +11684,28 @@ suggest_trie_walk(su, lp, fword, soundfo
 		    compflags[sp->ts_complen] = ((unsigned)flags >> 24);
 		    compflags[sp->ts_complen + 1] = NUL;
 		    vim_strncpy(preword + sp->ts_prewordlen,
 			    tword + sp->ts_splitoff,
 			    sp->ts_twordlen - sp->ts_splitoff);
-		    p = preword;
-		    while (*skiptowhite(p) != NUL)
-			p = skipwhite(skiptowhite(p));
-		    if (fword_ends && !can_compound(slang, p,
-						compflags + sp->ts_compsplit))
-			/* Compound is not allowed.  But it may still be
-			 * possible if we add another (short) word. */
+
+		    /* Verify CHECKCOMPOUNDPATTERN  rules. */
+		    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,
+							  &slang->sl_comppat))
 			compound_ok = FALSE;
 
+		    if (compound_ok)
+		    {
+			p = preword;
+			while (*skiptowhite(p) != NUL)
+			    p = skipwhite(skiptowhite(p));
+			if (fword_ends && !can_compound(slang, p,
+						compflags + sp->ts_compsplit))
+			    /* Compound is not allowed.  But it may still be
+			     * possible if we add another (short) word. */
+			    compound_ok = FALSE;
+		    }
+
 		    /* Get pointer to last char of previous word. */
 		    p = preword + sp->ts_prewordlen;
 		    mb_ptr_back(preword, p);
 		}
 	    }
@@ -11683,14 +11898,13 @@ suggest_trie_walk(su, lp, fword, soundfo
 						      >= slang->sl_compminlen)
 #endif
 			&& (slang->sl_compsylmax < MAXWLEN
 			    || sp->ts_complen + 1 - sp->ts_compsplit
 							  < slang->sl_compmax)
-			&& (byte_in_str(sp->ts_complen == sp->ts_compsplit
-					    ? slang->sl_compstartflags
-					    : slang->sl_compallflags,
-						    ((unsigned)flags >> 24))))
+			&& (can_be_compound(sp, slang,
+					 compflags, ((unsigned)flags >> 24))))
+
 		{
 		    try_compound = TRUE;
 		    compflags[sp->ts_complen] = ((unsigned)flags >> 24);
 		    compflags[sp->ts_complen + 1] = NUL;
 		}
@@ -14806,11 +15020,11 @@ soundalike_score(goodstart, badstart)
 	    /* Failed to compare. */
 	    break;
 
 	case 0:
 	    /*
-	     * Lenghts are equal, thus changes must result in same length: An
+	     * Lengths are equal, thus changes must result in same length: An
 	     * insert is only possible in combination with a delete.
 	     * 1: check if for identical strings
 	     */
 	    if (*pl == NUL)
 		return score;
@@ -15396,14 +15610,13 @@ pop:
 #endif
 
 /*
  * ":spellinfo"
  */
-/*ARGSUSED*/
     void
 ex_spellinfo(eap)
-    exarg_T *eap;
+    exarg_T *eap UNUSED;
 {
     int		lpi;
     langp_T	*lp;
     char_u	*p;
 
@@ -15943,15 +16156,13 @@ spell_expand_check_cap(col)
  * Get list of spelling suggestions.
  * Used for Insert mode completion CTRL-X ?.
  * Returns the number of matches.  The matches are in "matchp[]", array of
  * allocated strings.
  */
-/*ARGSUSED*/
     int
-expand_spelling(lnum, col, pat, matchp)
-    linenr_T	lnum;
-    int		col;
+expand_spelling(lnum, pat, matchp)
+    linenr_T	lnum UNUSED;
     char_u	*pat;
     char_u	***matchp;
 {
     garray_T	ga;
 
--- vim72.orig/src/if_cscope.c
+++ vim72/src/if_cscope.c
@@ -44,11 +44,10 @@ static void	    cs_file_results __ARGS((
 static void	    cs_fill_results __ARGS((char *, int , int *, char ***,
 			char ***, int *));
 static int	    cs_find __ARGS((exarg_T *eap));
 static int	    cs_find_common __ARGS((char *opt, char *pat, int, int, int));
 static int	    cs_help __ARGS((exarg_T *eap));
-static void	    cs_init __ARGS((void));
 static void	    clear_csinfo __ARGS((int i));
 static int	    cs_insert_filelist __ARGS((char *, char *, char *,
 			struct stat *));
 static int	    cs_kill __ARGS((exarg_T *eap));
 static void	    cs_kill_execute __ARGS((int, char *));
@@ -64,52 +63,167 @@ static void	    cs_release_csp __ARGS((i
 static int	    cs_reset __ARGS((exarg_T *eap));
 static char *	    cs_resolve_file __ARGS((int, char *));
 static int	    cs_show __ARGS((exarg_T *eap));
 
 
-static csinfo_T	    csinfo[CSCOPE_MAX_CONNECTIONS];
+static csinfo_T *   csinfo = NULL;
+static int	    csinfo_size = 0;	/* number of items allocated in
+					   csinfo[] */
+
 static int	    eap_arg_len;    /* length of eap->arg, set in
 				       cs_lookup_cmd() */
 static cscmd_T	    cs_cmds[] =
 {
     { "add",	cs_add,
 		N_("Add a new database"),     "add file|dir [pre-path] [flags]", 0 },
     { "find",	cs_find,
-		N_("Query for a pattern"),    FIND_USAGE, 1 },
+		N_("Query for a pattern"),    "find c|d|e|f|g|i|s|t name", 1 },
     { "help",	cs_help,
 		N_("Show this message"),      "help", 0 },
     { "kill",	cs_kill,
 		N_("Kill a connection"),      "kill #", 0 },
     { "reset",	cs_reset,
 		N_("Reinit all connections"), "reset", 0 },
     { "show",	cs_show,
 		N_("Show connections"),       "show", 0 },
-    { NULL }
+    { NULL, NULL, NULL, NULL, 0 }
 };
 
     static void
 cs_usage_msg(x)
     csid_e x;
 {
     (void)EMSG2(_("E560: Usage: cs[cope] %s"), cs_cmds[(int)x].usage);
 }
 
+#if defined(FEAT_CMDL_COMPL) || defined(PROTO)
+
+static enum
+{
+    EXP_CSCOPE_SUBCMD,	/* expand ":cscope" sub-commands */
+    EXP_SCSCOPE_SUBCMD,	/* expand ":scscope" sub-commands */
+    EXP_CSCOPE_FIND,	/* expand ":cscope find" arguments */
+    EXP_CSCOPE_KILL	/* expand ":cscope kill" arguments */
+} expand_what;
+
+/*
+ * Function given to ExpandGeneric() to obtain the cscope command
+ * expansion.
+ */
+    char_u *
+get_cscope_name(xp, idx)
+    expand_T	*xp UNUSED;
+    int		idx;
+{
+    int		current_idx;
+    int		i;
+
+    switch (expand_what)
+    {
+    case EXP_CSCOPE_SUBCMD:
+	/* Complete with sub-commands of ":cscope":
+	 * add, find, help, kill, reset, show */
+	return (char_u *)cs_cmds[idx].name;
+    case EXP_SCSCOPE_SUBCMD:
+	/* Complete with sub-commands of ":scscope": same sub-commands as
+	 * ":cscope" but skip commands which don't support split windows */
+	for (i = 0, current_idx = 0; cs_cmds[i].name != NULL; i++)
+	    if (cs_cmds[i].cansplit)
+		if (current_idx++ == idx)
+		    break;
+	return (char_u *)cs_cmds[i].name;
+    case EXP_CSCOPE_FIND:
+	{
+	    const char *query_type[] =
+	    {
+		"c", "d", "e", "f", "g", "i", "s", "t", NULL
+	    };
+
+	    /* Complete with query type of ":cscope find {query_type}".
+	     * {query_type} can be letters (c, d, ... t) or numbers (0, 1,
+	     * ..., 8) but only complete with letters, since numbers are
+	     * redundant. */
+	    return (char_u *)query_type[idx];
+	}
+    case EXP_CSCOPE_KILL:
+	{
+	    static char	connection[5];
+
+	    /* ":cscope kill" accepts connection numbers or partial names of
+	     * the pathname of the cscope database as argument.  Only complete
+	     * with connection numbers. -1 can also be used to kill all
+	     * connections. */
+	    for (i = 0, current_idx = 0; i < csinfo_size; i++)
+	    {
+		if (csinfo[i].fname == NULL)
+		    continue;
+		if (current_idx++ == idx)
+		{
+		    vim_snprintf(connection, sizeof(connection), "%d", i);
+		    return (char_u *)connection;
+		}
+	    }
+	    return (current_idx == idx && idx > 0) ? (char_u *)"-1" : NULL;
+	}
+    default:
+	return NULL;
+    }
+}
+
+/*
+ * Handle command line completion for :cscope command.
+ */
+    void
+set_context_in_cscope_cmd(xp, arg, cmdidx)
+    expand_T	*xp;
+    char_u	*arg;
+    cmdidx_T	cmdidx;
+{
+    char_u	*p;
+
+    /* Default: expand subcommands */
+    xp->xp_context = EXPAND_CSCOPE;
+    xp->xp_pattern = arg;
+    expand_what = (cmdidx == CMD_scscope)
+			? EXP_SCSCOPE_SUBCMD : EXP_CSCOPE_SUBCMD;
+
+    /* (part of) subcommand already typed */
+    if (*arg != NUL)
+    {
+	p = skiptowhite(arg);
+	if (*p != NUL)		    /* past first word */
+	{
+	    xp->xp_pattern = skipwhite(p);
+	    if (*skiptowhite(xp->xp_pattern) != NUL)
+		xp->xp_context = EXPAND_NOTHING;
+	    else if (STRNICMP(arg, "add", p - arg) == 0)
+		xp->xp_context = EXPAND_FILES;
+	    else if (STRNICMP(arg, "kill", p - arg) == 0)
+		expand_what = EXP_CSCOPE_KILL;
+	    else if (STRNICMP(arg, "find", p - arg) == 0)
+		expand_what = EXP_CSCOPE_FIND;
+	    else
+		xp->xp_context = EXPAND_NOTHING;
+	}
+    }
+}
+
+#endif /* FEAT_CMDL_COMPL */
+
 /*
  * PRIVATE: do_cscope_general
  *
- * find the command, print help if invalid, and the then call the
- * corresponding command function,
- * called from do_cscope and do_scscope
+ * Find the command, print help if invalid, and then call the corresponding
+ * command function.
  */
     static void
 do_cscope_general(eap, make_split)
     exarg_T	*eap;
     int		make_split; /* whether to split window */
 {
     cscmd_T *cmdp;
 
-    cs_init();
     if ((cmdp = cs_lookup_cmd(eap)) == NULL)
     {
 	cs_help(eap);
 	return;
     }
@@ -166,12 +280,10 @@ do_scscope(eap)
 do_cstag(eap)
     exarg_T *eap;
 {
     int ret = FALSE;
 
-    cs_init();
-
     if (*eap->arg == NUL)
     {
 	(void)EMSG(_("E562: Usage: cstag <ident>"));
 	return;
     }
@@ -323,11 +435,11 @@ cs_connection(num, dbpath, ppath)
     int i;
 
     if (num < 0 || num > 4 || (num > 0 && !dbpath))
 	return FALSE;
 
-    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+    for (i = 0; i < csinfo_size; i++)
     {
 	if (!csinfo[i].fname)
 	    continue;
 
 	if (num == 0)
@@ -377,14 +489,13 @@ cs_connection(num, dbpath, ppath)
  * add cscope database or a directory name (to look for cscope.out)
  * to the cscope connection list
  *
  * MAXPATHL 256
  */
-/* ARGSUSED */
     static int
 cs_add(eap)
-    exarg_T *eap;
+    exarg_T *eap UNUSED;
 {
     char *fname, *ppath, *flags = NULL;
 
     if ((fname = strtok((char *)NULL, (const char *)" ")) == NULL)
     {
@@ -567,11 +678,11 @@ cs_check_for_tags()
 cs_cnt_connections()
 {
     short i;
     short cnt = 0;
 
-    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+    for (i = 0; i < csinfo_size; i++)
     {
 	if (csinfo[i].fname != NULL)
 	    cnt++;
     }
     return cnt;
@@ -657,10 +768,11 @@ cs_create_cmd(csoption, pattern)
     char *csoption;
     char *pattern;
 {
     char *cmd;
     short search;
+    char *pat;
 
     switch (csoption[0])
     {
     case '0' : case 's' :
 	search = 0;
@@ -690,14 +802,21 @@ cs_create_cmd(csoption, pattern)
 	(void)EMSG(_("E561: unknown cscope search type"));
 	cs_usage_msg(Find);
 	return NULL;
     }
 
-    if ((cmd = (char *)alloc((unsigned)(strlen(pattern) + 2))) == NULL)
+    /* Skip white space before the patter, except for text and pattern search,
+     * they may want to use the leading white space. */
+    pat = pattern;
+    if (search != 4 && search != 6)
+	while vim_iswhite(*pat)
+	    ++pat;
+
+    if ((cmd = (char *)alloc((unsigned)(strlen(pat) + 2))) == NULL)
 	return NULL;
 
-    (void)sprintf(cmd, "%d%s", search, pattern);
+    (void)sprintf(cmd, "%d%s", search, pat);
 
     return cmd;
 } /* cs_create_cmd */
 
 
@@ -867,11 +986,11 @@ err_closing:
 	vim_free(prog);
 # endif
 	vim_free(ppath);
 
 #if defined(UNIX)
-	if (execl("/bin/sh", "sh", "-c", cmd, NULL) == -1)
+	if (execl("/bin/sh", "sh", "-c", cmd, (char *)NULL) == -1)
 	    PERROR(_("cs_create_connection exec failed"));
 
 	exit(127);
 	/* NOTREACHED */
     default:	/* parent. */
@@ -987,28 +1106,33 @@ cs_find_common(opt, pat, forceit, verbos
     int verbose;
     int	use_ll;
 {
     int i;
     char *cmd;
-    int nummatches[CSCOPE_MAX_CONNECTIONS], totmatches;
+    int *nummatches;
+    int totmatches;
 #ifdef FEAT_QUICKFIX
     char cmdletter;
     char *qfpos;
 #endif
 
     /* create the actual command to send to cscope */
     cmd = cs_create_cmd(opt, pat);
     if (cmd == NULL)
 	return FALSE;
 
+    nummatches = (int *)alloc(sizeof(int)*csinfo_size);
+    if (nummatches == NULL)
+	return FALSE;
+
     /* send query to all open connections, then count the total number
      * of matches so we can alloc matchesp all in one swell foop
      */
-    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+    for (i = 0; i < csinfo_size; i++)
 	nummatches[i] = 0;
     totmatches = 0;
-    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+    for (i = 0; i < csinfo_size; i++)
     {
 	if (csinfo[i].fname == NULL || csinfo[i].to_fp == NULL)
 	    continue;
 
 	/* send cmd to cscope */
@@ -1029,21 +1153,25 @@ cs_find_common(opt, pat, forceit, verbos
     {
 	char *nf = _("E259: no matches found for cscope query %s of %s");
 	char *buf;
 
 	if (!verbose)
+	{
+	    vim_free(nummatches);
 	    return FALSE;
+	}
 
 	buf = (char *)alloc((unsigned)(strlen(opt) + strlen(pat) + strlen(nf)));
 	if (buf == NULL)
 	    (void)EMSG(nf);
 	else
 	{
 	    sprintf(buf, nf, opt, pat);
 	    (void)EMSG(buf);
 	    vim_free(buf);
 	}
+	vim_free(nummatches);
 	return FALSE;
     }
 
 #ifdef FEAT_QUICKFIX
     /* get cmd letter */
@@ -1092,10 +1220,11 @@ cs_find_common(opt, pat, forceit, verbos
 	    {
 		sprintf(buf, nf, *qfpos, *(qfpos-1));
 		(void)EMSG(buf);
 		vim_free(buf);
 	    }
+	    vim_free(nummatches);
 	    return FALSE;
 	}
     }
     if (qfpos != NULL && *qfpos != '0' && totmatches > 0)
     {
@@ -1139,10 +1268,11 @@ cs_find_common(opt, pat, forceit, verbos
 		qf_jump(qi, 0, 0, forceit);
 	    }
 	}
 	mch_remove(tmp);
 	vim_free(tmp);
+	vim_free(nummatches);
 	return TRUE;
     }
     else
 #endif /* FEAT_QUICKFIX */
     {
@@ -1150,10 +1280,11 @@ cs_find_common(opt, pat, forceit, verbos
 	int matched = 0;
 
 	/* read output */
 	cs_fill_results((char *)pat, totmatches, nummatches, &matches,
 							 &contexts, &matched);
+	vim_free(nummatches);
 	if (matches == NULL)
 	    return FALSE;
 
 	(void)cs_manage_matches(matches, contexts, matched, Store);
 
@@ -1165,52 +1296,48 @@ cs_find_common(opt, pat, forceit, verbos
 /*
  * PRIVATE: cs_help
  *
  * print help
  */
-/* ARGSUSED */
     static int
 cs_help(eap)
-    exarg_T *eap;
+    exarg_T *eap UNUSED;
 {
     cscmd_T *cmdp = cs_cmds;
 
     (void)MSG_PUTS(_("cscope commands:\n"));
     while (cmdp->name != NULL)
     {
-	(void)smsg((char_u *)_("%-5s: %-30s (Usage: %s)"),
-				      cmdp->name, _(cmdp->help), cmdp->usage);
+	char *help = _(cmdp->help);
+	int  space_cnt = 30 - vim_strsize((char_u *)help);
+
+	/* Use %*s rather than %30s to ensure proper alignment in utf-8 */
+	if (space_cnt < 0)
+	    space_cnt = 0;
+	(void)smsg((char_u *)_("%-5s: %s%*s (Usage: %s)"),
+				      cmdp->name,
+				      help, space_cnt, " ",
+				      cmdp->usage);
 	if (strcmp(cmdp->name, "find") == 0)
-	    MSG_PUTS(FIND_HELP);
+	    MSG_PUTS(_("\n"
+		       "       c: Find functions calling this function\n"
+		       "       d: Find functions called by this function\n"
+		       "       e: Find this egrep pattern\n"
+		       "       f: Find this file\n"
+		       "       g: Find this definition\n"
+		       "       i: Find files #including this file\n"
+		       "       s: Find this C symbol\n"
+		       "       t: Find assignments to\n"));
+
 	cmdp++;
     }
 
     wait_return(TRUE);
     return 0;
 } /* cs_help */
 
 
-/*
- * PRIVATE: cs_init
- *
- * initialize cscope structure if not already
- */
-    static void
-cs_init()
-{
-    short i;
-    static int init_already = FALSE;
-
-    if (init_already)
-	return;
-
-    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
-	clear_csinfo(i);
-
-    init_already = TRUE;
-} /* cs_init */
-
     static void
 clear_csinfo(i)
     int	    i;
 {
     csinfo[i].fname  = NULL;
@@ -1255,17 +1382,16 @@ GetWin32Error()
 /*
  * PRIVATE: cs_insert_filelist
  *
  * insert a new cscope database filename into the filelist
  */
-/*ARGSUSED*/
     static int
 cs_insert_filelist(fname, ppath, flags, sb)
     char *fname;
     char *ppath;
     char *flags;
-    struct stat *sb;
+    struct stat *sb UNUSED;
 {
     short	i, j;
 #ifndef UNIX
     HANDLE	hFile;
     BY_HANDLE_FILE_INFORMATION bhfi;
@@ -1304,11 +1430,11 @@ cs_insert_filelist(fname, ppath, flags,
 	CloseHandle(hFile);
     }
 #endif
 
     i = -1; /* can be set to the index of an empty item in csinfo */
-    for (j = 0; j < CSCOPE_MAX_CONNECTIONS; j++)
+    for (j = 0; j < csinfo_size; j++)
     {
 	if (csinfo[j].fname != NULL
 #if defined(UNIX)
 	    && csinfo[j].st_dev == sb->st_dev && csinfo[j].st_ino == sb->st_ino
 #else
@@ -1331,13 +1457,29 @@ cs_insert_filelist(fname, ppath, flags,
 	    i = j; /* remember first empty entry */
     }
 
     if (i == -1)
     {
-	if (p_csverbose)
-	    (void)EMSG(_("E569: maximum number of cscope connections reached"));
-	return -1;
+	i = csinfo_size;
+	if (csinfo_size == 0)
+	{
+	    /* First time allocation: allocate only 1 connection. It should
+	     * be enough for most users.  If more is needed, csinfo will be
+	     * reallocated. */
+	    csinfo_size = 1;
+	    csinfo = (csinfo_T *)alloc_clear(sizeof(csinfo_T));
+	}
+	else
+	{
+	    /* Reallocate space for more connections. */
+	    csinfo_size *= 2;
+	    csinfo = vim_realloc(csinfo, sizeof(csinfo_T)*csinfo_size);
+	}
+	if (csinfo == NULL)
+	    return -1;
+	for (j = csinfo_size/2; j < csinfo_size; j++)
+	    clear_csinfo(j);
     }
 
     if ((csinfo[i].fname = (char *)alloc((unsigned)strlen(fname)+1)) == NULL)
 	return -1;
 
@@ -1417,14 +1559,13 @@ cs_lookup_cmd(eap)
 /*
  * PRIVATE: cs_kill
  *
  * nuke em
  */
-/* ARGSUSED */
     static int
 cs_kill(eap)
-    exarg_T *eap;
+    exarg_T *eap UNUSED;
 {
     char *stok;
     short i;
 
     if ((stok = strtok((char *)NULL, (const char *)" ")) == NULL)
@@ -1441,28 +1582,27 @@ cs_kill(eap)
     else
     {
 	/* It must be part of a name.  We will try to find a match
 	 * within all the names in the csinfo data structure
 	 */
-	for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+	for (i = 0; i < csinfo_size; i++)
 	{
 	    if (csinfo[i].fname != NULL && strstr(csinfo[i].fname, stok))
 		break;
 	}
     }
 
-    if ((i >= CSCOPE_MAX_CONNECTIONS || i < -1 || csinfo[i].fname == NULL)
-	    && i != -1)
+    if ((i != -1) && (i >= csinfo_size || i < -1 || csinfo[i].fname == NULL))
     {
 	if (p_csverbose)
 	    (void)EMSG2(_("E261: cscope connection %s not found"), stok);
     }
     else
     {
 	if (i == -1)
 	{
-	    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+	    for (i = 0; i < csinfo_size; i++)
 	    {
 		if (csinfo[i].fname)
 		    cs_kill_execute(i, csinfo[i].fname);
 	    }
 	}
@@ -1718,11 +1858,11 @@ cs_file_results(f, nummatches_a)
 
     buf = (char *)alloc(CSREAD_BUFSIZE);
     if (buf == NULL)
 	return;
 
-    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+    for (i = 0; i < csinfo_size; i++)
     {
 	if (nummatches_a[i] < 1)
 	    continue;
 
 	for (j = 0; j < nummatches_a[i]; j++)
@@ -1790,11 +1930,11 @@ cs_fill_results(tagstr, totmatches, numm
     if ((matches = (char **)alloc(sizeof(char *) * totmatches)) == NULL)
 	goto parse_out;
     if ((cntxts = (char **)alloc(sizeof(char *) * totmatches)) == NULL)
 	goto parse_out;
 
-    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+    for (i = 0; i < csinfo_size; i++)
     {
 	if (nummatches_a[i] < 1)
 	    continue;
 
 	for (j = 0; j < nummatches_a[i]; j++)
@@ -1927,11 +2067,11 @@ cs_print_tags_priv(matches, cntxts, num_
 	 */
 	if ((tbuf = (char *)alloc((unsigned)strlen(matches[idx]) + 1)) == NULL)
 	    continue;
 	(void)strcpy(tbuf, matches[idx]);
 
-	if ((fname = strtok(tbuf, (const char *)"\t")) == NULL)
+	if (strtok(tbuf, (const char *)"\t") == NULL)
 	    continue;
 	if ((fname = strtok(NULL, (const char *)"\t")) == NULL)
 	    continue;
 	if ((lno = strtok(NULL, (const char *)"\t")) == NULL)
 	    continue;
@@ -2097,11 +2237,10 @@ cs_read_prompt(i)
 
 #if defined(UNIX) && defined(SIGALRM)
 /*
  * Used to catch and ignore SIGALRM below.
  */
-/* ARGSUSED */
     static RETSIGTYPE
 sig_handler SIGDEFARG(sigarg)
 {
     /* do nothing */
     SIGRETURN;
@@ -2137,11 +2276,15 @@ cs_release_csp(i, freefnpp)
 	struct sigaction sa, old;
 
 	/* Use sigaction() to limit the waiting time to two seconds. */
 	sigemptyset(&sa.sa_mask);
 	sa.sa_handler = sig_handler;
+#  ifdef SA_NODEFER
 	sa.sa_flags = SA_NODEFER;
+#  else
+	sa.sa_flags = 0;
+#  endif
 	sigaction(SIGALRM, &sa, &old);
 	alarm(2); /* 2 sec timeout */
 
 	/* Block until cscope exits or until timer expires */
 	pid = waitpid(csinfo[i].pid, &pstat, 0);
@@ -2237,42 +2380,44 @@ cs_release_csp(i, freefnpp)
 /*
  * PRIVATE: cs_reset
  *
  * calls cs_kill on all cscope connections then reinits
  */
-/* ARGSUSED */
     static int
 cs_reset(eap)
-    exarg_T *eap;
+    exarg_T *eap UNUSED;
 {
     char	**dblist = NULL, **pplist = NULL, **fllist = NULL;
     int	i;
     char buf[20]; /* for sprintf " (#%d)" */
 
+    if (csinfo_size == 0)
+	return CSCOPE_SUCCESS;
+
     /* malloc our db and ppath list */
-    dblist = (char **)alloc(CSCOPE_MAX_CONNECTIONS * sizeof(char *));
-    pplist = (char **)alloc(CSCOPE_MAX_CONNECTIONS * sizeof(char *));
-    fllist = (char **)alloc(CSCOPE_MAX_CONNECTIONS * sizeof(char *));
+    dblist = (char **)alloc(csinfo_size * sizeof(char *));
+    pplist = (char **)alloc(csinfo_size * sizeof(char *));
+    fllist = (char **)alloc(csinfo_size * sizeof(char *));
     if (dblist == NULL || pplist == NULL || fllist == NULL)
     {
 	vim_free(dblist);
 	vim_free(pplist);
 	vim_free(fllist);
 	return CSCOPE_FAILURE;
     }
 
-    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+    for (i = 0; i < csinfo_size; i++)
     {
 	dblist[i] = csinfo[i].fname;
 	pplist[i] = csinfo[i].ppath;
 	fllist[i] = csinfo[i].flags;
 	if (csinfo[i].fname != NULL)
 	    cs_release_csp(i, FALSE);
     }
 
     /* rebuild the cscope connection list */
-    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+    for (i = 0; i < csinfo_size; i++)
     {
 	if (dblist[i] != NULL)
 	{
 	    cs_add_common(dblist[i], pplist[i], fllist[i]);
 	    if (p_csverbose)
@@ -2353,24 +2498,23 @@ cs_resolve_file(i, name)
 /*
  * PRIVATE: cs_show
  *
  * show all cscope connections
  */
-/* ARGSUSED */
     static int
 cs_show(eap)
-    exarg_T *eap;
+    exarg_T *eap UNUSED;
 {
     short i;
     if (cs_cnt_connections() == 0)
 	MSG_PUTS(_("no cscope connections\n"));
     else
     {
 	MSG_PUTS_ATTR(
 	    _(" # pid    database name                       prepend path\n"),
 	    hl_attr(HLF_T));
-	for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+	for (i = 0; i < csinfo_size; i++)
 	{
 	    if (csinfo[i].fname == NULL)
 		continue;
 
 	    if (csinfo[i].ppath != NULL)
@@ -2395,12 +2539,14 @@ cs_show(eap)
     void
 cs_end()
 {
     int i;
 
-    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+    for (i = 0; i < csinfo_size; i++)
 	cs_release_csp(i, TRUE);
+    vim_free(csinfo);
+    csinfo_size = 0;
 }
 
 #endif	/* FEAT_CSCOPE */
 
 /* the end */
--- vim72.orig/src/if_cscope.h
+++ vim72/src/if_cscope.h
@@ -23,11 +23,10 @@
 # endif
 #endif
 
 #define CSCOPE_SUCCESS		0
 #define CSCOPE_FAILURE		-1
-#define CSCOPE_MAX_CONNECTIONS	8   /* you actually need more? */
 
 #define	CSCOPE_DBFILE		"cscope.out"
 #define	CSCOPE_PROMPT		">> "
 
 /*
@@ -40,21 +39,10 @@
  *   5pattern	change pattern -- NOT USED
  * e 6pattern	Find this egrep pattern
  * f 7name	Find this file
  * i 8name	Find files #including this file
  */
-#define	FIND_USAGE "find c|d|e|f|g|i|s|t name"
-#define FIND_HELP "\n\
-       c: Find functions calling this function\n\
-       d: Find functions called by this function\n\
-       e: Find this egrep pattern\n\
-       f: Find this file\n\
-       g: Find this definition\n\
-       i: Find files #including this file\n\
-       s: Find this C symbol\n\
-       t: Find assignments to\n"
-
 
 typedef struct {
     char *  name;
     int     (*func) __ARGS((exarg_T *eap));
     char *  help;
--- vim72.orig/src/eval.c
+++ vim72/src/eval.c
@@ -30,10 +30,13 @@
 # include <math.h>
 #endif
 
 #define DICT_MAXNEST 100	/* maximum nesting of lists and dicts */
 
+#define DO_NOT_FREE_CNT 99999	/* refcount for dict or list that should not
+				   be freed. */
+
 /*
  * In a hashtab item "hi_key" points to "di_key" in a dictitem.
  * This avoids adding a pointer to the hashtab item.
  * DI2HIKEY() converts a dictitem pointer to a hashitem key pointer.
  * HIKEY2DI() converts a hashitem key pointer to a dictitem pointer.
@@ -124,12 +127,15 @@ static dictitem_T	globvars_var;
 static hashtab_T	compat_hashtab;
 
 /*
  * When recursively copying lists and dicts we need to remember which ones we
  * have done to avoid endless recursiveness.  This unique ID is used for that.
+ * The last bit is used for previous_funccal, ignored when comparing.
  */
 static int current_copyID = 0;
+#define COPYID_INC 2
+#define COPYID_MASK (~0x1)
 
 /*
  * Array to hold the hashtab with variables local to each sourced script.
  * Each item holds a variable (nameless) that points to the dict_T.
  */
@@ -278,11 +284,11 @@ typedef struct
 /* values for vv_flags: */
 #define VV_COMPAT	1	/* compatible, also used without "v:" */
 #define VV_RO		2	/* read-only */
 #define VV_RO_SBX	4	/* read-only in the sandbox */
 
-#define VV_NAME(s, t)	s, {{t}}, {0}
+#define VV_NAME(s, t)	s, {{t, 0, {0}}, 0, {0}}, {0}
 
 static struct vimvar
 {
     char	*vv_name;	/* name of variable, without v: */
     dictitem_T	vv_di;		/* value and name for key */
@@ -346,17 +352,19 @@ static struct vimvar
     {VV_NAME("mouse_win",	 VAR_NUMBER), 0},
     {VV_NAME("mouse_lnum",	 VAR_NUMBER), 0},
     {VV_NAME("mouse_col",	 VAR_NUMBER), 0},
     {VV_NAME("operator",	 VAR_STRING), VV_RO},
     {VV_NAME("searchforward",	 VAR_NUMBER), 0},
+    {VV_NAME("oldfiles",	 VAR_LIST), 0},
 };
 
 /* shorthand */
 #define vv_type		vv_di.di_tv.v_type
 #define vv_nr		vv_di.di_tv.vval.v_number
 #define vv_float	vv_di.di_tv.vval.v_float
 #define vv_str		vv_di.di_tv.vval.v_string
+#define vv_list		vv_di.di_tv.vval.v_list
 #define vv_tv		vv_di.di_tv
 
 /*
  * The v: variables are stored in dictionary "vimvardict".
  * "vimvars_var" is the variable that is used for the "l:" scope.
@@ -423,31 +431,27 @@ static int dict_equal __ARGS((dict_T *d1
 static int tv_equal __ARGS((typval_T *tv1, typval_T *tv2, int ic));
 static listitem_T *list_find __ARGS((list_T *l, long n));
 static long list_find_nr __ARGS((list_T *l, long idx, int *errorp));
 static long list_idx_of_item __ARGS((list_T *l, listitem_T *item));
 static void list_append __ARGS((list_T *l, listitem_T *item));
-static int list_append_tv __ARGS((list_T *l, typval_T *tv));
-static int list_append_string __ARGS((list_T *l, char_u *str, int len));
 static int list_append_number __ARGS((list_T *l, varnumber_T n));
 static int list_insert_tv __ARGS((list_T *l, typval_T *tv, listitem_T *item));
 static int list_extend __ARGS((list_T	*l1, list_T *l2, listitem_T *bef));
 static int list_concat __ARGS((list_T *l1, list_T *l2, typval_T *tv));
 static list_T *list_copy __ARGS((list_T *orig, int deep, int copyID));
 static void list_remove __ARGS((list_T *l, listitem_T *item, listitem_T *item2));
 static char_u *list2string __ARGS((typval_T *tv, int copyID));
 static int list_join __ARGS((garray_T *gap, list_T *l, char_u *sep, int echo, int copyID));
+static int free_unref_items __ARGS((int copyID));
 static void set_ref_in_ht __ARGS((hashtab_T *ht, int copyID));
 static void set_ref_in_list __ARGS((list_T *l, int copyID));
 static void set_ref_in_item __ARGS((typval_T *tv, int copyID));
 static void dict_unref __ARGS((dict_T *d));
 static void dict_free __ARGS((dict_T *d, int recurse));
-static dictitem_T *dictitem_alloc __ARGS((char_u *key));
 static dictitem_T *dictitem_copy __ARGS((dictitem_T *org));
 static void dictitem_remove __ARGS((dict_T *dict, dictitem_T *item));
-static void dictitem_free __ARGS((dictitem_T *item));
 static dict_T *dict_copy __ARGS((dict_T *orig, int deep, int copyID));
-static int dict_add __ARGS((dict_T *d, dictitem_T *item));
 static long dict_len __ARGS((dict_T *d));
 static dictitem_T *dict_find __ARGS((dict_T *d, char_u *key, int len));
 static char_u *dict2string __ARGS((typval_T *tv, int copyID));
 static int get_dict_tv __ARGS((char_u **arg, typval_T *rettv, int evaluate));
 static char_u *echo_string __ARGS((typval_T *tv, char_u **tofree, char_u *numbuf, int copyID));
@@ -618,10 +622,13 @@ static void f_max __ARGS((typval_T *argv
 static void f_min __ARGS((typval_T *argvars, typval_T *rettv));
 #ifdef vim_mkdir
 static void f_mkdir __ARGS((typval_T *argvars, typval_T *rettv));
 #endif
 static void f_mode __ARGS((typval_T *argvars, typval_T *rettv));
+#ifdef FEAT_MZSCHEME
+static void f_mzeval __ARGS((typval_T *argvars, typval_T *rettv));
+#endif
 static void f_nextnonblank __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_nr2char __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_pathshorten __ARGS((typval_T *argvars, typval_T *rettv));
 #ifdef FEAT_FLOAT
 static void f_pow __ARGS((typval_T *argvars, typval_T *rettv));
@@ -754,11 +761,10 @@ static void list_one_var __ARGS((dictite
 static void list_one_var_a __ARGS((char_u *prefix, char_u *name, int type, char_u *string, int *first));
 static void set_var __ARGS((char_u *name, typval_T *varp, int copy));
 static int var_check_ro __ARGS((int flags, char_u *name));
 static int var_check_fixed __ARGS((int flags, char_u *name));
 static int tv_check_lock __ARGS((int lock, char_u *name));
-static void copy_tv __ARGS((typval_T *from, typval_T *to));
 static int item_copy __ARGS((typval_T *from, typval_T *to, int deep, int copyID));
 static char_u *find_option_end __ARGS((char_u **arg, int *opt_flags));
 static char_u *trans_function_name __ARGS((char_u **pp, int skip, int flags, funcdict_T *fd));
 static int eval_fname_script __ARGS((char_u *p));
 static int eval_fname_sid __ARGS((char_u *p));
@@ -786,10 +792,12 @@ static char_u *autoload_name __ARGS((cha
 static void cat_func_name __ARGS((char_u *buf, ufunc_T *fp));
 static void func_free __ARGS((ufunc_T *fp));
 static void func_unref __ARGS((char_u *name));
 static void func_ref __ARGS((char_u *name));
 static void call_user_func __ARGS((ufunc_T *fp, int argcount, typval_T *argvars, typval_T *rettv, linenr_T firstline, linenr_T lastline, dict_T *selfdict));
+static int can_free_funccal __ARGS((funccall_T *fc, int copyID)) ;
+static void free_funccal __ARGS((funccall_T *fc, int free_val));
 static void add_nr_var __ARGS((dict_T *dp, dictitem_T *v, char *name, varnumber_T nr));
 static win_T *find_win_by_nr __ARGS((typval_T *vp, tabpage_T *tp));
 static void getwinvar __ARGS((typval_T *argvars, typval_T *rettv, int off));
 static int searchpair_cmn __ARGS((typval_T *argvars, pos_T *match_pos));
 static int search_cmn __ARGS((typval_T *argvars, pos_T *match_pos, int *flagsp));
@@ -843,15 +851,21 @@ eval_clear()
     for (i = 0; i < VV_LEN; ++i)
     {
 	p = &vimvars[i];
 	if (p->vv_di.di_tv.v_type == VAR_STRING)
 	{
-	    vim_free(p->vv_di.di_tv.vval.v_string);
-	    p->vv_di.di_tv.vval.v_string = NULL;
+	    vim_free(p->vv_str);
+	    p->vv_str = NULL;
+	}
+	else if (p->vv_di.di_tv.v_type == VAR_LIST)
+	{
+	    list_unref(p->vv_list);
+	    p->vv_list = NULL;
 	}
     }
     hash_clear(&vimvarht);
+    hash_init(&vimvarht);  /* garbage_collect() will access it */
     hash_clear(&compat_hashtab);
 
     /* script-local variables */
     for (i = 1; i <= ga_scripts.ga_len; ++i)
 	vars_clear(&SCRIPT_VARS(i));
@@ -914,10 +928,14 @@ func_level(cookie)
 }
 
 /* pointer to funccal for currently active function */
 funccall_T *current_funccal = NULL;
 
+/* pointer to list of previously used funccal, still around because some
+ * item in it is still being used. */
+funccall_T *previous_funccal = NULL;
+
 /*
  * Return TRUE when a function was ended by a ":return" command.
  */
     int
 current_func_returned()
@@ -966,17 +984,18 @@ var_redir_start(name, append)
 {
     int		save_emsg;
     int		err;
     typval_T	tv;
 
-    /* Make sure a valid variable name is specified */
+    /* Catch a bad name early. */
     if (!eval_isnamec1(*name))
     {
 	EMSG(_(e_invarg));
 	return FAIL;
     }
 
+    /* Make a copy of the name, it is used in redir_lval until redir ends. */
     redir_varname = vim_strsave(name);
     if (redir_varname == NULL)
 	return FAIL;
 
     redir_lval = (lval_T *)alloc_clear((unsigned)sizeof(lval_T));
@@ -997,10 +1016,11 @@ var_redir_start(name, append)
 	if (redir_endp != NULL && *redir_endp != NUL)
 	    /* Trailing characters are present after the variable name */
 	    EMSG(_(e_trailing));
 	else
 	    EMSG(_(e_invarg));
+	redir_endp = NULL;  /* don't store a value, only cleanup */
 	var_redir_stop();
 	return FAIL;
     }
 
     /* check if we can write to the variable: set it to or append an empty
@@ -1015,10 +1035,11 @@ var_redir_start(name, append)
 	set_var_lval(redir_lval, redir_endp, &tv, TRUE, (char_u *)"=");
     err = did_emsg;
     did_emsg |= save_emsg;
     if (err)
     {
+	redir_endp = NULL;  /* don't store a value, only cleanup */
 	var_redir_stop();
 	return FAIL;
     }
     if (redir_lval->ll_newkey != NULL)
     {
@@ -1063,26 +1084,31 @@ var_redir_str(value, value_len)
 	var_redir_stop();
 }
 
 /*
  * Stop redirecting command output to a variable.
+ * Frees the allocated memory.
  */
     void
 var_redir_stop()
 {
     typval_T	tv;
 
     if (redir_lval != NULL)
     {
-	/* Append the trailing NUL. */
-	ga_append(&redir_ga, NUL);
+	/* If there was no error: assign the text to the variable. */
+	if (redir_endp != NULL)
+	{
+	    ga_append(&redir_ga, NUL);  /* Append the trailing NUL. */
+	    tv.v_type = VAR_STRING;
+	    tv.vval.v_string = redir_ga.ga_data;
+	    set_var_lval(redir_lval, redir_endp, &tv, FALSE, (char_u *)".");
+	}
 
-	/* Assign the text to the variable. */
-	tv.v_type = VAR_STRING;
-	tv.vval.v_string = redir_ga.ga_data;
-	set_var_lval(redir_lval, redir_endp, &tv, FALSE, (char_u *)".");
-	vim_free(tv.vval.v_string);
+	/* free the collected output */
+	vim_free(redir_ga.ga_data);
+	redir_ga.ga_data = NULL;
 
 	clear_lval(redir_lval);
 	vim_free(redir_lval);
 	redir_lval = NULL;
     }
@@ -1254,34 +1280,46 @@ skip_expr(pp)
     return eval1(pp, &rettv, FALSE);
 }
 
 /*
  * Top level evaluation function, returning a string.
+ * When "convert" is TRUE convert a List into a sequence of lines and convert
+ * a Float to a String.
  * Return pointer to allocated memory, or NULL for failure.
  */
     char_u *
-eval_to_string(arg, nextcmd, dolist)
+eval_to_string(arg, nextcmd, convert)
     char_u	*arg;
     char_u	**nextcmd;
-    int		dolist;		/* turn List into sequence of lines */
+    int		convert;
 {
     typval_T	tv;
     char_u	*retval;
     garray_T	ga;
+#ifdef FEAT_FLOAT
+    char_u	numbuf[NUMBUFLEN];
+#endif
 
     if (eval0(arg, &tv, nextcmd, TRUE) == FAIL)
 	retval = NULL;
     else
     {
-	if (dolist && tv.v_type == VAR_LIST)
+	if (convert && tv.v_type == VAR_LIST)
 	{
 	    ga_init2(&ga, (int)sizeof(char), 80);
 	    if (tv.vval.v_list != NULL)
 		list_join(&ga, tv.vval.v_list, (char_u *)"\n", TRUE, 0);
 	    ga_append(&ga, NUL);
 	    retval = (char_u *)ga.ga_data;
 	}
+#ifdef FEAT_FLOAT
+	else if (convert && tv.v_type == VAR_FLOAT)
+	{
+	    vim_snprintf((char *)numbuf, NUMBUFLEN, "%g", tv.vval.v_float);
+	    retval = vim_strsave(numbuf);
+	}
+#endif
 	else
 	    retval = vim_strsave(get_tv_string(&tv));
 	clear_tv(&tv);
     }
 
@@ -3275,11 +3313,11 @@ ex_call(eap)
     startarg = skipwhite(arg);
     rettv.v_type = VAR_UNKNOWN;	/* clear_tv() uses this */
 
     if (*startarg != '(')
     {
-	EMSG2(_("E107: Missing braces: %s"), eap->arg);
+	EMSG2(_("E107: Missing parentheses: %s"), eap->arg);
 	goto end;
     }
 
     /*
      * When skipping, evaluate the function once, to find the end of the
@@ -3655,12 +3693,12 @@ item_lock(tv, deep, lock)
     }
     --recurse;
 }
 
 /*
- * Return TRUE if typeval "tv" is locked: Either tha value is locked itself or
- * it refers to a List or Dictionary that is locked.
+ * Return TRUE if typeval "tv" is locked: Either that value is locked itself
+ * or it refers to a List or Dictionary that is locked.
  */
     static int
 tv_islocked(tv)
     typval_T	*tv;
 {
@@ -3742,11 +3780,10 @@ cat_prefix_varname(prefix, name)
 
 /*
  * Function given to ExpandGeneric() to obtain the list of user defined
  * (global/buffer/window/built-in) variable names.
  */
-/*ARGSUSED*/
     char_u *
 get_user_var_name(xp, idx)
     expand_T	*xp;
     int		idx;
 {
@@ -3900,11 +3937,11 @@ eval0(arg, rettv, nextcmd, evaluate)
     return ret;
 }
 
 /*
  * Handle top level expression:
- *	expr1 ? expr0 : expr0
+ *	expr2 ? expr1 : expr1
  *
  * "arg" must point to the first non-white of the expression.
  * "arg" is advanced to the next non-white after the recognized expression.
  *
  * Note: "rettv.v_lock" is not set.
@@ -5833,11 +5870,12 @@ list_equal(l1, l2, ic)
 	if (!tv_equal(&item1->li_tv, &item2->li_tv, ic))
 	    return FALSE;
     return item1 == NULL && item2 == NULL;
 }
 
-#if defined(FEAT_PYTHON) || defined(PROTO)
+#if defined(FEAT_RUBY) || defined(FEAT_PYTHON) || defined(FEAT_MZSCHEME) \
+	|| defined(PROTO)
 /*
  * Return the dictitem that an entry in a hashtable points to.
  */
     dictitem_T *
 dict_lookup(hi)
@@ -6045,10 +6083,29 @@ list_find_nr(l, idx, errorp)
     }
     return get_tv_number_chk(&li->li_tv, errorp);
 }
 
 /*
+ * Get list item "l[idx - 1]" as a string.  Returns NULL for failure.
+ */
+    char_u *
+list_find_str(l, idx)
+    list_T	*l;
+    long	idx;
+{
+    listitem_T	*li;
+
+    li = list_find(l, idx - 1);
+    if (li == NULL)
+    {
+	EMSGN(_(e_listidx), idx);
+	return NULL;
+    }
+    return get_tv_string(&li->li_tv);
+}
+
+/*
  * Locate "item" list "l" and return its index.
  * Returns -1 when "item" is not in the list.
  */
     static long
 list_idx_of_item(l, item)
@@ -6095,11 +6152,11 @@ list_append(l, item)
 
 /*
  * Append typval_T "tv" to the end of list "l".
  * Return FAIL when out of memory.
  */
-    static int
+    int
 list_append_tv(l, tv)
     list_T	*l;
     typval_T	*tv;
 {
     listitem_T	*li = listitem_alloc();
@@ -6135,11 +6192,11 @@ list_append_dict(list, dict)
 /*
  * Make a copy of "str" and append it as an item to list "l".
  * When "len" >= 0 use "str[len]".
  * Returns FAIL when out of memory.
  */
-    static int
+    int
 list_append_string(l, str, len)
     list_T	*l;
     char_u	*str;
     int		len;
 {
@@ -6415,10 +6472,11 @@ list_join(gap, l, sep, echo, copyID)
 	if (s != NULL)
 	    ga_concat(gap, s);
 	vim_free(tofree);
 	if (s == NULL)
 	    return FAIL;
+	line_breakcheck();
     }
     return OK;
 }
 
 /*
@@ -6446,31 +6504,45 @@ list_join(gap, l, sep, echo, copyID)
  * Return TRUE if some memory was freed.
  */
     int
 garbage_collect()
 {
-    dict_T	*dd;
-    list_T	*ll;
-    int		copyID = ++current_copyID;
+    int		copyID;
     buf_T	*buf;
     win_T	*wp;
     int		i;
-    funccall_T	*fc;
-    int		did_free = FALSE;
+    funccall_T	*fc, **pfc;
+    int		did_free;
+    int		did_free_funccal = FALSE;
 #ifdef FEAT_WINDOWS
     tabpage_T	*tp;
 #endif
 
     /* Only do this once. */
     want_garbage_collect = FALSE;
     may_garbage_collect = FALSE;
     garbage_collect_at_exit = FALSE;
 
+    /* We advance by two because we add one for items referenced through
+     * previous_funccal. */
+    current_copyID += COPYID_INC;
+    copyID = current_copyID;
+
     /*
      * 1. Go through all accessible variables and mark all lists and dicts
      *    with copyID.
      */
+
+    /* Don't free variables in the previous_funccal list unless they are only
+     * referenced through previous_funccal.  This must be first, because if
+     * the item is referenced elsewhere the funccal must not be freed. */
+    for (fc = previous_funccal; fc != NULL; fc = fc->caller)
+    {
+	set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID + 1);
+	set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID + 1);
+    }
+
     /* script-local variables */
     for (i = 1; i <= ga_scripts.ga_len; ++i)
 	set_ref_in_ht(&SCRIPT_VARS(i), copyID);
 
     /* buffer-local variables */
@@ -6495,15 +6567,58 @@ garbage_collect()
     {
 	set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID);
 	set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID);
     }
 
+    /* v: vars */
+    set_ref_in_ht(&vimvarht, copyID);
+
+    /*
+     * 2. Free lists and dictionaries that are not referenced.
+     */
+    did_free = free_unref_items(copyID);
+
     /*
-     * 2. Go through the list of dicts and free items without the copyID.
+     * 3. Check if any funccal can be freed now.
+     */
+    for (pfc = &previous_funccal; *pfc != NULL; )
+    {
+	if (can_free_funccal(*pfc, copyID))
+	{
+	    fc = *pfc;
+	    *pfc = fc->caller;
+	    free_funccal(fc, TRUE);
+	    did_free = TRUE;
+	    did_free_funccal = TRUE;
+	}
+	else
+	    pfc = &(*pfc)->caller;
+    }
+    if (did_free_funccal)
+	/* When a funccal was freed some more items might be garbage
+	 * collected, so run again. */
+	(void)garbage_collect();
+
+    return did_free;
+}
+
+/*
+ * Free lists and dictionaries that are no longer referenced.
+ */
+    static int
+free_unref_items(copyID)
+    int copyID;
+{
+    dict_T	*dd;
+    list_T	*ll;
+    int		did_free = FALSE;
+
+    /*
+     * Go through the list of dicts and free items without the copyID.
      */
     for (dd = first_dict; dd != NULL; )
-	if (dd->dv_copyID != copyID)
+	if ((dd->dv_copyID & COPYID_MASK) != (copyID & COPYID_MASK))
 	{
 	    /* Free the Dictionary and ordinary items it contains, but don't
 	     * recurse into Lists and Dictionaries, they will be in the list
 	     * of dicts or list of lists. */
 	    dict_free(dd, FALSE);
@@ -6514,16 +6629,17 @@ garbage_collect()
 	}
 	else
 	    dd = dd->dv_used_next;
 
     /*
-     * 3. Go through the list of lists and free items without the copyID.
-     *    But don't free a list that has a watcher (used in a for loop), these
-     *    are not referenced anywhere.
+     * Go through the list of lists and free items without the copyID.
+     * But don't free a list that has a watcher (used in a for loop), these
+     * are not referenced anywhere.
      */
     for (ll = first_list; ll != NULL; )
-	if (ll->lv_copyID != copyID && ll->lv_watch == NULL)
+	if ((ll->lv_copyID & COPYID_MASK) != (copyID & COPYID_MASK)
+						      && ll->lv_watch == NULL)
 	{
 	    /* Free the List and ordinary items it contains, but don't recurse
 	     * into Lists and Dictionaries, they will be in the list of dicts
 	     * or list of lists. */
 	    list_free(ll, FALSE);
@@ -6585,21 +6701,21 @@ set_ref_in_item(tv, copyID)
 
     switch (tv->v_type)
     {
 	case VAR_DICT:
 	    dd = tv->vval.v_dict;
-	    if (dd->dv_copyID != copyID)
+	    if (dd != NULL && dd->dv_copyID != copyID)
 	    {
 		/* Didn't see this dict yet. */
 		dd->dv_copyID = copyID;
 		set_ref_in_ht(&dd->dv_hashtab, copyID);
 	    }
 	    break;
 
 	case VAR_LIST:
 	    ll = tv->vval.v_list;
-	    if (ll->lv_copyID != copyID)
+	    if (ll != NULL && ll->lv_copyID != copyID)
 	    {
 		/* Didn't see this list yet. */
 		ll->lv_copyID = copyID;
 		set_ref_in_list(ll, copyID);
 	    }
@@ -6693,11 +6809,11 @@ dict_free(d, recurse)
  * Allocate a Dictionary item.
  * The "key" is copied to the new item.
  * Note that the value of the item "di_tv" still needs to be initialized!
  * Returns NULL when out of memory.
  */
-    static dictitem_T *
+    dictitem_T *
 dictitem_alloc(key)
     char_u	*key;
 {
     dictitem_T *di;
 
@@ -6749,11 +6865,11 @@ dictitem_remove(dict, item)
 }
 
 /*
  * Free a dict item.  Also clears the value.
  */
-    static void
+    void
 dictitem_free(item)
     dictitem_T *item;
 {
     clear_tv(&item->di_tv);
     vim_free(item);
@@ -6829,11 +6945,11 @@ dict_copy(orig, deep, copyID)
 
 /*
  * Add item "item" to Dictionary "d".
  * Returns FAIL when out of memory and when key already existed.
  */
-    static int
+    int
 dict_add(d, item)
     dict_T	*d;
     dictitem_T	*item;
 {
     return hash_add(&d->dv_hashtab, item->di_key);
@@ -7523,12 +7639,12 @@ static struct fst
     {"getregtype",	0, 1, f_getregtype},
     {"gettabwinvar",	3, 3, f_gettabwinvar},
     {"getwinposx",	0, 0, f_getwinposx},
     {"getwinposy",	0, 0, f_getwinposy},
     {"getwinvar",	2, 2, f_getwinvar},
-    {"glob",		1, 1, f_glob},
-    {"globpath",	2, 2, f_globpath},
+    {"glob",		1, 2, f_glob},
+    {"globpath",	2, 3, f_globpath},
     {"has",		1, 1, f_has},
     {"has_key",		2, 2, f_has_key},
     {"haslocaldir",	0, 0, f_haslocaldir},
     {"hasmapto",	1, 3, f_hasmapto},
     {"highlightID",	1, 1, f_hlID},		/* obsolete */
@@ -7580,10 +7696,13 @@ static struct fst
     {"min",		1, 1, f_min},
 #ifdef vim_mkdir
     {"mkdir",		1, 3, f_mkdir},
 #endif
     {"mode",		0, 1, f_mode},
+#ifdef FEAT_MZSCHEME
+    {"mzeval",		1, 1, f_mzeval},
+#endif
     {"nextnonblank",	1, 1, f_nextnonblank},
     {"nr2char",		1, 1, f_nr2char},
     {"pathshorten",	1, 1, f_pathshorten},
 #ifdef FEAT_FLOAT
     {"pow",		2, 2, f_pow},
@@ -7721,11 +7840,10 @@ get_function_name(xp, idx)
 
 /*
  * Function given to ExpandGeneric() to obtain the list of internal or
  * user defined variable or function names.
  */
-/*ARGSUSED*/
     char_u *
 get_expr_name(xp, idx)
     expand_T	*xp;
     int		idx;
 {
@@ -7854,13 +7972,13 @@ get_func_tv(name, len, rettv, arg, first
 	ret = call_func(name, len, rettv, argcount, argvars,
 			  firstline, lastline, doesrange, evaluate, selfdict);
     else if (!aborting())
     {
 	if (argcount == MAX_FUNC_ARGS)
-	    emsg_funcname("E740: Too many arguments for function %s", name);
+	    emsg_funcname(N_("E740: Too many arguments for function %s"), name);
 	else
-	    emsg_funcname("E116: Invalid arguments for function %s", name);
+	    emsg_funcname(N_("E116: Invalid arguments for function %s"), name);
     }
 
     while (--argcount >= 0)
 	clear_tv(&argvars[argcount]);
 
@@ -7954,11 +8072,12 @@ call_func(name, len, rettv, argcount, ar
 
 
     /* execute the function if no errors detected and executing */
     if (evaluate && error == ERROR_NONE)
     {
-	rettv->v_type = VAR_NUMBER;	/* default is number rettv */
+	rettv->v_type = VAR_NUMBER;	/* default rettv is number zero */
+	rettv->vval.v_number = 0;
 	error = ERROR_UNKNOWN;
 
 	if (!builtin_function(fname))
 	{
 	    /*
@@ -8089,10 +8208,11 @@ call_func(name, len, rettv, argcount, ar
     return ret;
 }
 
 /*
  * Give an error message with a function name.  Handle <SNR> things.
+ * "ermsg" is to be passed without translation, use N_() instead of _().
  */
     static void
 emsg_funcname(ermsg, name)
     char	*ermsg;
     char_u	*name;
@@ -8203,11 +8323,10 @@ f_append(argvars, rettv)
 	    l = argvars[1].vval.v_list;
 	    if (l == NULL)
 		return;
 	    li = l->lv_first;
 	}
-	rettv->vval.v_number = 0;	/* Default: Success */
 	for (;;)
 	{
 	    if (l == NULL)
 		tv = &argvars[1];	/* append a string */
 	    else if (li == NULL)
@@ -8236,26 +8355,24 @@ f_append(argvars, rettv)
 }
 
 /*
  * "argc()" function
  */
-/* ARGSUSED */
     static void
 f_argc(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = ARGCOUNT;
 }
 
 /*
  * "argidx()" function
  */
-/* ARGSUSED */
     static void
 f_argidx(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = curwin->w_arg_idx;
 }
 
@@ -8329,14 +8446,13 @@ f_atan(argvars, rettv)
 #endif
 
 /*
  * "browse(save, title, initdir, default)" function
  */
-/* ARGSUSED */
     static void
 f_browse(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_BROWSE
     int		save;
     char_u	*title;
@@ -8364,14 +8480,13 @@ f_browse(argvars, rettv)
 }
 
 /*
  * "browsedir(title, initdir)" function
  */
-/* ARGSUSED */
     static void
 f_browsedir(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_BROWSE
     char_u	*title;
     char_u	*initdir;
@@ -8592,14 +8707,13 @@ f_bufwinnr(argvars, rettv)
 }
 
 /*
  * "byte2line(byte)" function
  */
-/*ARGSUSED*/
     static void
 f_byte2line(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifndef FEAT_BYTEOFF
     rettv->vval.v_number = -1;
 #else
@@ -8615,11 +8729,10 @@ f_byte2line(argvars, rettv)
 }
 
 /*
  * "byteidx()" function
  */
-/*ARGSUSED*/
     static void
 f_byteidx(argvars, rettv)
     typval_T	*argvars;
     typval_T	*rettv;
 {
@@ -8663,11 +8776,10 @@ f_call(argvars, rettv)
     int		argc = 0;
     listitem_T	*item;
     int		dummy;
     dict_T	*selfdict = NULL;
 
-    rettv->vval.v_number = 0;
     if (argvars[1].v_type != VAR_LIST)
     {
 	EMSG(_(e_listreq));
 	return;
     }
@@ -8735,14 +8847,13 @@ f_ceil(argvars, rettv)
 #endif
 
 /*
  * "changenr()" function
  */
-/*ARGSUSED*/
     static void
 f_changenr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = curbuf->b_u_seq_cur;
 }
 
@@ -8788,15 +8899,14 @@ f_cindent(argvars, rettv)
 }
 
 /*
  * "clearmatches()" function
  */
-/*ARGSUSED*/
     static void
 f_clearmatches(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_SEARCH_EXTRA
     clear_matches(curwin);
 #endif
 }
@@ -8856,15 +8966,14 @@ f_col(argvars, rettv)
 
 #if defined(FEAT_INS_EXPAND)
 /*
  * "complete()" function
  */
-/*ARGSUSED*/
     static void
 f_complete(argvars, rettv)
     typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*rettv UNUSED;
 {
     int	    startcol;
 
     if ((State & INSERT) == 0)
     {
@@ -8891,11 +9000,10 @@ f_complete(argvars, rettv)
 }
 
 /*
  * "complete_add()" function
  */
-/*ARGSUSED*/
     static void
 f_complete_add(argvars, rettv)
     typval_T	*argvars;
     typval_T	*rettv;
 {
@@ -8903,14 +9011,13 @@ f_complete_add(argvars, rettv)
 }
 
 /*
  * "complete_check()" function
  */
-/*ARGSUSED*/
     static void
 f_complete_check(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		saved = RedrawingDisabled;
 
     RedrawingDisabled = 0;
@@ -8921,15 +9028,14 @@ f_complete_check(argvars, rettv)
 #endif
 
 /*
  * "confirm(message, buttons[, default [, type]])" function
  */
-/*ARGSUSED*/
     static void
 f_confirm(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
     char_u	*message;
     char_u	*buttons = NULL;
     char_u	buf[NUMBUFLEN];
@@ -8971,17 +9077,13 @@ f_confirm(argvars, rettv)
     }
 
     if (buttons == NULL || *buttons == NUL)
 	buttons = (char_u *)_("&Ok");
 
-    if (error)
-	rettv->vval.v_number = 0;
-    else
+    if (!error)
 	rettv->vval.v_number = do_dialog(type, NULL, message, buttons,
 								   def, NULL);
-#else
-    rettv->vval.v_number = 0;
 #endif
 }
 
 /*
  * "copy()" function
@@ -9094,15 +9196,14 @@ f_count(argvars, rettv)
 /*
  * "cscope_connection([{num} , {dbpath} [, {prepend}]])" function
  *
  * Checks the existence of a cscope connection.
  */
-/*ARGSUSED*/
     static void
 f_cscope_connection(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_CSCOPE
     int		num = 0;
     char_u	*dbpath = NULL;
     char_u	*prepend = NULL;
@@ -9116,31 +9217,30 @@ f_cscope_connection(argvars, rettv)
 	if (argvars[2].v_type != VAR_UNKNOWN)
 	    prepend = get_tv_string_buf(&argvars[2], buf);
     }
 
     rettv->vval.v_number = cs_connection(num, dbpath, prepend);
-#else
-    rettv->vval.v_number = 0;
 #endif
 }
 
 /*
  * "cursor(lnum, col)" function
  *
- * Moves the cursor to the specified line and column
+ * Moves the cursor to the specified line and column.
+ * Returns 0 when the position could be set, -1 otherwise.
  */
-/*ARGSUSED*/
     static void
 f_cursor(argvars, rettv)
     typval_T	*argvars;
     typval_T	*rettv;
 {
     long	line, col;
 #ifdef FEAT_VIRTUALEDIT
     long	coladd = 0;
 #endif
 
+    rettv->vval.v_number = -1;
     if (argvars[1].v_type == VAR_UNKNOWN)
     {
 	pos_T	    pos;
 
 	if (list2fpos(argvars, &pos, NULL) == FAIL)
@@ -9181,10 +9281,11 @@ f_cursor(argvars, rettv)
     if (has_mbyte)
 	mb_adjust_cursor();
 #endif
 
     curwin->w_set_curswant = TRUE;
+    rettv->vval.v_number = 0;
 }
 
 /*
  * "deepcopy()" function
  */
@@ -9198,11 +9299,14 @@ f_deepcopy(argvars, rettv)
     if (argvars[1].v_type != VAR_UNKNOWN)
 	noref = get_tv_number_chk(&argvars[1], NULL);
     if (noref < 0 || noref > 1)
 	EMSG(_(e_invarg));
     else
-	item_copy(&argvars[0], rettv, TRUE, noref == 0 ? ++current_copyID : 0);
+    {
+	current_copyID += COPYID_INC;
+	item_copy(&argvars[0], rettv, TRUE, noref == 0 ? current_copyID : 0);
+    }
 }
 
 /*
  * "delete()" function
  */
@@ -9218,45 +9322,40 @@ f_delete(argvars, rettv)
 }
 
 /*
  * "did_filetype()" function
  */
-/*ARGSUSED*/
     static void
 f_did_filetype(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_AUTOCMD
     rettv->vval.v_number = did_filetype;
-#else
-    rettv->vval.v_number = 0;
 #endif
 }
 
 /*
  * "diff_filler()" function
  */
-/*ARGSUSED*/
     static void
 f_diff_filler(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_DIFF
     rettv->vval.v_number = diff_check_fill(curwin, get_tv_lnum(argvars));
 #endif
 }
 
 /*
  * "diff_hlID()" function
  */
-/*ARGSUSED*/
     static void
 f_diff_hlID(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_DIFF
     linenr_T		lnum = get_tv_lnum(argvars);
     static linenr_T	prev_lnum = 0;
     static int		changedtick = 0;
@@ -9365,11 +9464,10 @@ f_escape(argvars, rettv)
 }
 
 /*
  * "eval()" function
  */
-/*ARGSUSED*/
     static void
 f_eval(argvars, rettv)
     typval_T	*argvars;
     typval_T	*rettv;
 {
@@ -9389,14 +9487,13 @@ f_eval(argvars, rettv)
 }
 
 /*
  * "eventhandler()" function
  */
-/*ARGSUSED*/
     static void
 f_eventhandler(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = vgetc_busy;
 }
 
@@ -9516,11 +9613,11 @@ f_expand(argvars, rettv)
 	--emsg_off;
     }
     else
     {
 	/* When the optional second argument is non-zero, don't remove matches
-	 * for 'suffixes' and 'wildignore' */
+	 * for 'wildignore' and don't put matches for 'suffixes' at the end. */
 	if (argvars[1].v_type != VAR_UNKNOWN
 				    && get_tv_number_chk(&argvars[1], &error))
 	    flags |= WILD_KEEP_ALL;
 	if (!error)
 	{
@@ -9540,11 +9637,10 @@ f_expand(argvars, rettv)
     static void
 f_extend(argvars, rettv)
     typval_T	*argvars;
     typval_T	*rettv;
 {
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type == VAR_LIST && argvars[1].v_type == VAR_LIST)
     {
 	list_T		*l1, *l2;
 	listitem_T	*item;
 	long		before;
@@ -9650,15 +9746,14 @@ f_extend(argvars, rettv)
 }
 
 /*
  * "feedkeys()" function
  */
-/*ARGSUSED*/
     static void
 f_feedkeys(argvars, rettv)
     typval_T    *argvars;
-    typval_T    *rettv;
+    typval_T    *rettv UNUSED;
 {
     int		remap = TRUE;
     char_u	*keys, *flags;
     char_u	nbuf[NUMBUFLEN];
     int		typed = FALSE;
@@ -9668,11 +9763,10 @@ f_feedkeys(argvars, rettv)
      * executed in the sandbox it would be OK, but it probably happens later,
      * when "sandbox" is no longer set. */
     if (check_secure())
 	return;
 
-    rettv->vval.v_number = 0;
     keys = get_tv_string(&argvars[0]);
     if (*keys != NUL)
     {
 	if (argvars[1].v_type != VAR_UNKNOWN)
 	{
@@ -9835,12 +9929,12 @@ filter_map(argvars, rettv, map)
     typval_T	save_key;
     int		rem;
     int		todo;
     char_u	*ermsg = map ? (char_u *)"map()" : (char_u *)"filter()";
     int		save_did_emsg;
+    int		index = 0;
 
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type == VAR_LIST)
     {
 	if ((l = argvars[0].vval.v_list) == NULL
 		|| (map && tv_check_lock(l->lv_lock, ermsg)))
 	    return;
@@ -9869,13 +9963,13 @@ filter_map(argvars, rettv, map)
 	/* We reset "did_emsg" to be able to detect whether an error
 	 * occurred during evaluation of the expression. */
 	save_did_emsg = did_emsg;
 	did_emsg = FALSE;
 
+	prepare_vimvar(VV_KEY, &save_key);
 	if (argvars[0].v_type == VAR_DICT)
 	{
-	    prepare_vimvar(VV_KEY, &save_key);
 	    vimvars[VV_KEY].vv_type = VAR_STRING;
 
 	    ht = &d->dv_hashtab;
 	    hash_lock(ht);
 	    todo = (int)ht->ht_used;
@@ -9895,28 +9989,31 @@ filter_map(argvars, rettv, map)
 			dictitem_remove(d, di);
 		    clear_tv(&vimvars[VV_KEY].vv_tv);
 		}
 	    }
 	    hash_unlock(ht);
-
-	    restore_vimvar(VV_KEY, &save_key);
 	}
 	else
 	{
+	    vimvars[VV_KEY].vv_type = VAR_NUMBER;
+
 	    for (li = l->lv_first; li != NULL; li = nli)
 	    {
 		if (tv_check_lock(li->li_tv.v_lock, ermsg))
 		    break;
 		nli = li->li_next;
+		vimvars[VV_KEY].vv_nr = index;
 		if (filter_map_one(&li->li_tv, expr, map, &rem) == FAIL
 								  || did_emsg)
 		    break;
 		if (!map && rem)
 		    listitem_remove(l, li);
+		++index;
 	    }
 	}
 
+	restore_vimvar(VV_KEY, &save_key);
 	restore_vimvar(VV_VAL, &save_val);
 
 	did_emsg |= save_did_emsg;
     }
 
@@ -10019,12 +10116,10 @@ f_float2nr(argvars, rettv)
 	else if (f > 0x7fffffff)
 	    rettv->vval.v_number = 0x7fffffff;
 	else
 	    rettv->vval.v_number = (varnumber_T)f;
     }
-    else
-	rettv->vval.v_number = 0;
 }
 
 /*
  * "floor({float})" function
  */
@@ -10154,22 +10249,19 @@ f_foldlevel(argvars, rettv)
     linenr_T	lnum;
 
     lnum = get_tv_lnum(argvars);
     if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)
 	rettv->vval.v_number = foldLevel(lnum);
-    else
 #endif
-	rettv->vval.v_number = 0;
 }
 
 /*
  * "foldtext()" function
  */
-/*ARGSUSED*/
     static void
 f_foldtext(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_FOLDING
     linenr_T	lnum;
     char_u	*s;
@@ -10230,14 +10322,13 @@ f_foldtext(argvars, rettv)
 }
 
 /*
  * "foldtextresult(lnum)" function
  */
-/*ARGSUSED*/
     static void
 f_foldtextresult(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_FOLDING
     linenr_T	lnum;
     char_u	*text;
@@ -10266,17 +10357,15 @@ f_foldtextresult(argvars, rettv)
 }
 
 /*
  * "foreground()" function
  */
-/*ARGSUSED*/
     static void
 f_foreground(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
-    rettv->vval.v_number = 0;
 #ifdef FEAT_GUI
     if (gui.in_use)
 	gui_mch_set_foreground();
 #else
 # ifdef WIN32
@@ -10286,23 +10375,22 @@ f_foreground(argvars, rettv)
 }
 
 /*
  * "function()" function
  */
-/*ARGSUSED*/
     static void
 f_function(argvars, rettv)
     typval_T	*argvars;
     typval_T	*rettv;
 {
     char_u	*s;
 
-    rettv->vval.v_number = 0;
     s = get_tv_string(&argvars[0]);
     if (s == NULL || *s == NUL || VIM_ISDIGIT(*s))
 	EMSG2(_(e_invarg2), s);
-    else if (!function_exists(s))
+    /* Don't check an autoload name for existence here. */
+    else if (vim_strchr(s, AUTOLOAD_CHAR) == NULL && !function_exists(s))
 	EMSG2(_("E700: Unknown function: %s"), s);
     else
     {
 	rettv->vval.v_string = vim_strsave(s);
 	rettv->v_type = VAR_FUNC;
@@ -10310,15 +10398,14 @@ f_function(argvars, rettv)
 }
 
 /*
  * "garbagecollect()" function
  */
-/*ARGSUSED*/
     static void
 f_garbagecollect(argvars, rettv)
     typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*rettv UNUSED;
 {
     /* This is postponed until we are back at the toplevel, because we may be
      * using Lists and Dicts internally.  E.g.: ":echo [garbagecollect()]". */
     want_garbage_collect = TRUE;
 
@@ -10363,13 +10450,11 @@ f_get(argvars, rettv)
     else
 	EMSG2(_(e_listdictarg), "get()");
 
     if (tv == NULL)
     {
-	if (argvars[2].v_type == VAR_UNKNOWN)
-	    rettv->vval.v_number = 0;
-	else
+	if (argvars[2].v_type != VAR_UNKNOWN)
 	    copy_tv(&argvars[2], rettv);
     }
     else
 	copy_tv(tv, rettv);
 }
@@ -10390,17 +10475,12 @@ get_buffer_lines(buf, start, end, retlis
     int		retlist;
     typval_T	*rettv;
 {
     char_u	*p;
 
-    if (retlist)
-    {
-	if (rettv_list_alloc(rettv) == FAIL)
-	    return;
-    }
-    else
-	rettv->vval.v_number = 0;
+    if (retlist && rettv_list_alloc(rettv) == FAIL)
+	return;
 
     if (buf == NULL || buf->b_ml.ml_mfp == NULL || start < 0)
 	return;
 
     if (!retlist)
@@ -10600,23 +10680,23 @@ f_getchar(argvars, rettv)
 	    win_T	*win;
 	    linenr_T	lnum;
 # ifdef FEAT_WINDOWS
 	    win_T	*wp;
 # endif
-	    int		n = 1;
+	    int		winnr = 1;
 
 	    if (row >= 0 && col >= 0)
 	    {
 		/* Find the window at the mouse coordinates and compute the
 		 * text position. */
 		win = mouse_find_win(&row, &col);
 		(void)mouse_comp_pos(win, &row, &col, &lnum);
 # ifdef FEAT_WINDOWS
 		for (wp = firstwin; wp != win; wp = wp->w_next)
-		    ++n;
+		    ++winnr;
 # endif
-		vimvars[VV_MOUSE_WIN].vv_nr = n;
+		vimvars[VV_MOUSE_WIN].vv_nr = winnr;
 		vimvars[VV_MOUSE_LNUM].vv_nr = lnum;
 		vimvars[VV_MOUSE_COL].vv_nr = col + 1;
 	    }
 	}
 #endif
@@ -10624,51 +10704,47 @@ f_getchar(argvars, rettv)
 }
 
 /*
  * "getcharmod()" function
  */
-/*ARGSUSED*/
     static void
 f_getcharmod(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = mod_mask;
 }
 
 /*
  * "getcmdline()" function
  */
-/*ARGSUSED*/
     static void
 f_getcmdline(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->v_type = VAR_STRING;
     rettv->vval.v_string = get_cmdline_str();
 }
 
 /*
  * "getcmdpos()" function
  */
-/*ARGSUSED*/
     static void
 f_getcmdpos(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = get_cmdline_pos() + 1;
 }
 
 /*
  * "getcmdtype()" function
  */
-/*ARGSUSED*/
     static void
 f_getcmdtype(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->v_type = VAR_STRING;
     rettv->vval.v_string = alloc(2);
     if (rettv->vval.v_string != NULL)
@@ -10679,14 +10755,13 @@ f_getcmdtype(argvars, rettv)
 }
 
 /*
  * "getcwd()" function
  */
-/*ARGSUSED*/
     static void
 f_getcwd(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     char_u	cwd[MAXPATHL];
 
     rettv->v_type = VAR_STRING;
@@ -10703,14 +10778,13 @@ f_getcwd(argvars, rettv)
 }
 
 /*
  * "getfontname()" function
  */
-/*ARGSUSED*/
     static void
 f_getfontname(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->v_type = VAR_STRING;
     rettv->vval.v_string = NULL;
 #ifdef FEAT_GUI
@@ -10933,22 +11007,19 @@ f_getline(argvars, rettv)
 }
 
 /*
  * "getmatches()" function
  */
-/*ARGSUSED*/
     static void
 f_getmatches(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_SEARCH_EXTRA
     dict_T	*dict;
     matchitem_T	*cur = curwin->w_match_head;
 
-    rettv->vval.v_number = 0;
-
     if (rettv_list_alloc(rettv) == OK)
     {
 	while (cur != NULL)
 	{
 	    dict = dict_alloc();
@@ -10966,14 +11037,13 @@ f_getmatches(argvars, rettv)
 }
 
 /*
  * "getpid()" function
  */
-/*ARGSUSED*/
     static void
 f_getpid(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = mch_get_pid();
 }
 
@@ -11013,21 +11083,19 @@ f_getpos(argvars, rettv)
 }
 
 /*
  * "getqflist()" and "getloclist()" functions
  */
-/*ARGSUSED*/
     static void
 f_getqflist(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_QUICKFIX
     win_T	*wp;
 #endif
 
-    rettv->vval.v_number = 0;
 #ifdef FEAT_QUICKFIX
     if (rettv_list_alloc(rettv) == OK)
     {
 	wp = NULL;
 	if (argvars[0].v_type != VAR_UNKNOWN)	/* getloclist() */
@@ -11133,14 +11201,13 @@ f_gettabwinvar(argvars, rettv)
 }
 
 /*
  * "getwinposx()" function
  */
-/*ARGSUSED*/
     static void
 f_getwinposx(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = -1;
 #ifdef FEAT_GUI
     if (gui.in_use)
@@ -11154,14 +11221,13 @@ f_getwinposx(argvars, rettv)
 }
 
 /*
  * "getwinposy()" function
  */
-/*ARGSUSED*/
     static void
 f_getwinposy(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = -1;
 #ifdef FEAT_GUI
     if (gui.in_use)
@@ -11282,35 +11348,55 @@ getwinvar(argvars, rettv, off)
     static void
 f_glob(argvars, rettv)
     typval_T	*argvars;
     typval_T	*rettv;
 {
+    int		flags = WILD_SILENT|WILD_USE_NL;
     expand_T	xpc;
+    int		error = FALSE;
 
-    ExpandInit(&xpc);
-    xpc.xp_context = EXPAND_FILES;
+    /* When the optional second argument is non-zero, don't remove matches
+    * for 'wildignore' and don't put matches for 'suffixes' at the end. */
+    if (argvars[1].v_type != VAR_UNKNOWN
+				&& get_tv_number_chk(&argvars[1], &error))
+	flags |= WILD_KEEP_ALL;
     rettv->v_type = VAR_STRING;
-    rettv->vval.v_string = ExpandOne(&xpc, get_tv_string(&argvars[0]),
-				     NULL, WILD_USE_NL|WILD_SILENT, WILD_ALL);
+    if (!error)
+    {
+	ExpandInit(&xpc);
+	xpc.xp_context = EXPAND_FILES;
+	rettv->vval.v_string = ExpandOne(&xpc, get_tv_string(&argvars[0]),
+						       NULL, flags, WILD_ALL);
+    }
+    else
+	rettv->vval.v_string = NULL;
 }
 
 /*
  * "globpath()" function
  */
     static void
 f_globpath(argvars, rettv)
     typval_T	*argvars;
     typval_T	*rettv;
 {
+    int		flags = 0;
     char_u	buf1[NUMBUFLEN];
     char_u	*file = get_tv_string_buf_chk(&argvars[1], buf1);
+    int		error = FALSE;
 
+    /* When the optional second argument is non-zero, don't remove matches
+    * for 'wildignore' and don't put matches for 'suffixes' at the end. */
+    if (argvars[2].v_type != VAR_UNKNOWN
+				&& get_tv_number_chk(&argvars[2], &error))
+	flags |= WILD_KEEP_ALL;
     rettv->v_type = VAR_STRING;
-    if (file == NULL)
+    if (file == NULL || error)
 	rettv->vval.v_string = NULL;
     else
-	rettv->vval.v_string = globpath(get_tv_string(&argvars[0]), file);
+	rettv->vval.v_string = globpath(get_tv_string(&argvars[0]), file,
+								       flags);
 }
 
 /*
  * "has()" function
  */
@@ -11368,11 +11454,11 @@ f_has(argvars, rettv)
 	"win32",
 #endif
 #if defined(UNIX) && (defined(__CYGWIN32__) || defined(__CYGWIN__))
 	"win32unix",
 #endif
-#ifdef WIN64
+#if defined(WIN64) || defined(_WIN64)
 	"win64",
 #endif
 #ifdef EBCDIC
 	"ebcdic",
 #endif
@@ -11655,10 +11741,13 @@ f_has(argvars, rettv)
 	"smartindent",
 #endif
 #ifdef FEAT_SNIFF
 	"sniff",
 #endif
+#ifdef STARTUPTIME
+	"startuptime",
+#endif
 #ifdef FEAT_STL_OPT
 	"statusline",
 #endif
 #ifdef FEAT_SUN_WORKSHOP
 	"sun_workshop",
@@ -11780,10 +11869,14 @@ f_has(argvars, rettv)
     {
 	if (STRNICMP(name, "patch", 5) == 0)
 	    n = has_patch(atoi((char *)name + 5));
 	else if (STRICMP(name, "vim_starting") == 0)
 	    n = (starting != 0);
+#ifdef FEAT_MBYTE
+	else if (STRICMP(name, "multi_byte_encoding") == 0)
+	    n = has_mbyte;
+#endif
 #if defined(FEAT_BEVAL) && defined(FEAT_GUI_W32)
 	else if (STRICMP(name, "balloon_multiline") == 0)
 	    n = multiline_balloon_available();
 #endif
 #ifdef DYNAMIC_TCL
@@ -11845,11 +11938,10 @@ f_has(argvars, rettv)
     static void
 f_has_key(argvars, rettv)
     typval_T	*argvars;
     typval_T	*rettv;
 {
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type != VAR_DICT)
     {
 	EMSG(_(e_dictreq));
 	return;
     }
@@ -11861,14 +11953,13 @@ f_has_key(argvars, rettv)
 }
 
 /*
  * "haslocaldir()" function
  */
-/*ARGSUSED*/
     static void
 f_haslocaldir(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = (curwin->w_localdir != NULL);
 }
 
@@ -11902,14 +11993,13 @@ f_hasmapto(argvars, rettv)
 }
 
 /*
  * "histadd()" function
  */
-/*ARGSUSED*/
     static void
 f_histadd(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_CMDHIST
     int		histype;
     char_u	*str;
@@ -11925,10 +12015,11 @@ f_histadd(argvars, rettv)
     if (histype >= 0)
     {
 	str = get_tv_string_buf(&argvars[1], buf);
 	if (*str != NUL)
 	{
+	    init_history();
 	    add_to_history(histype, str, FALSE, NUL);
 	    rettv->vval.v_number = TRUE;
 	    return;
 	}
     }
@@ -11936,15 +12027,14 @@ f_histadd(argvars, rettv)
 }
 
 /*
  * "histdel()" function
  */
-/*ARGSUSED*/
     static void
 f_histdel(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_CMDHIST
     int		n;
     char_u	buf[NUMBUFLEN];
     char_u	*str;
@@ -11962,22 +12052,19 @@ f_histdel(argvars, rettv)
     else
 	/* string given: remove all matching entries */
 	n = del_history_entry(get_histtype(str),
 				      get_tv_string_buf(&argvars[1], buf));
     rettv->vval.v_number = n;
-#else
-    rettv->vval.v_number = 0;
 #endif
 }
 
 /*
  * "histget()" function
  */
-/*ARGSUSED*/
     static void
 f_histget(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_CMDHIST
     int		type;
     int		idx;
@@ -12003,14 +12090,13 @@ f_histget(argvars, rettv)
 }
 
 /*
  * "histnr()" function
  */
-/*ARGSUSED*/
     static void
 f_histnr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		i;
 
 #ifdef FEAT_CMDHIST
@@ -12048,14 +12134,13 @@ f_hlexists(argvars, rettv)
 }
 
 /*
  * "hostname()" function
  */
-/*ARGSUSED*/
     static void
 f_hostname(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     char_u hostname[256];
 
     mch_get_host_name(hostname, 256);
@@ -12064,14 +12149,13 @@ f_hostname(argvars, rettv)
 }
 
 /*
  * iconv() function
  */
-/*ARGSUSED*/
     static void
 f_iconv(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_MBYTE
     char_u	buf1[NUMBUFLEN];
     char_u	buf2[NUMBUFLEN];
@@ -12325,11 +12409,10 @@ f_inputlist(argvars, rettv)
 {
     listitem_T	*li;
     int		selected;
     int		mouse_used;
 
-    rettv->vval.v_number = 0;
 #ifdef NO_CONSOLE_INPUT
     /* While starting up, there is no place to enter text. */
     if (no_console_input())
 	return;
 #endif
@@ -12363,22 +12446,21 @@ f_inputlist(argvars, rettv)
 static garray_T	    ga_userinput = {0, 0, sizeof(tasave_T), 4, NULL};
 
 /*
  * "inputrestore()" function
  */
-/*ARGSUSED*/
     static void
 f_inputrestore(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     if (ga_userinput.ga_len > 0)
     {
 	--ga_userinput.ga_len;
 	restore_typeahead((tasave_T *)(ga_userinput.ga_data)
 						       + ga_userinput.ga_len);
-	rettv->vval.v_number = 0; /* OK */
+	/* default return is zero == OK */
     }
     else if (p_verbose > 1)
     {
 	verb_msg((char_u *)_("called inputrestore() more often than inputsave()"));
 	rettv->vval.v_number = 1; /* Failed */
@@ -12386,23 +12468,22 @@ f_inputrestore(argvars, rettv)
 }
 
 /*
  * "inputsave()" function
  */
-/*ARGSUSED*/
     static void
 f_inputsave(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     /* Add an entry to the stack of typeahead storage. */
     if (ga_grow(&ga_userinput, 1) == OK)
     {
 	save_typeahead((tasave_T *)(ga_userinput.ga_data)
 						       + ga_userinput.ga_len);
 	++ga_userinput.ga_len;
-	rettv->vval.v_number = 0; /* OK */
+	/* default return is zero == OK */
     }
     else
 	rettv->vval.v_number = 1; /* Failed */
 }
 
@@ -12432,11 +12513,10 @@ f_insert(argvars, rettv)
     long	before = 0;
     listitem_T	*item;
     list_T	*l;
     int		error = FALSE;
 
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type != VAR_LIST)
 	EMSG2(_(e_listarg), "insert()");
     else if ((l = argvars[0].vval.v_list) != NULL
 	    && !tv_check_lock(l->lv_lock, (char_u *)"insert()"))
     {
@@ -12551,11 +12631,10 @@ dict_list(argvars, rettv, what)
     listitem_T	*li;
     listitem_T	*li2;
     dict_T	*d;
     int		todo;
 
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type != VAR_DICT)
     {
 	EMSG(_(e_dictreq));
 	return;
     }
@@ -12639,11 +12718,10 @@ f_join(argvars, rettv)
     typval_T	*rettv;
 {
     garray_T	ga;
     char_u	*sep;
 
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type != VAR_LIST)
     {
 	EMSG(_(e_listreq));
 	return;
     }
@@ -12679,14 +12757,13 @@ f_keys(argvars, rettv)
 }
 
 /*
  * "last_buffer_nr()" function.
  */
-/*ARGSUSED*/
     static void
 f_last_buffer_nr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		n = 0;
     buf_T	*buf;
 
@@ -12737,13 +12814,11 @@ libcall_common(argvars, rettv, type)
     char_u		**string_result;
     int			nr_result;
 #endif
 
     rettv->v_type = type;
-    if (type == VAR_NUMBER)
-	rettv->vval.v_number = 0;
-    else
+    if (type != VAR_NUMBER)
 	rettv->vval.v_string = NULL;
 
     if (check_restricted() || check_secure())
 	return;
 
@@ -12811,14 +12886,13 @@ f_line(argvars, rettv)
 }
 
 /*
  * "line2byte(lnum)" function
  */
-/*ARGSUSED*/
     static void
 f_line2byte(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifndef FEAT_BYTEOFF
     rettv->vval.v_number = -1;
 #else
@@ -12860,14 +12934,13 @@ f_lispindent(argvars, rettv)
 }
 
 /*
  * "localtime()" function
  */
-/*ARGSUSED*/
     static void
 f_localtime(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = (varnumber_T)time(NULL);
 }
 
@@ -13445,11 +13518,10 @@ f_mkdir(argvars, rettv)
 #endif
 
 /*
  * "mode()" function
  */
-/*ARGSUSED*/
     static void
 f_mode(argvars, rettv)
     typval_T	*argvars;
     typval_T	*rettv;
 {
@@ -13519,10 +13591,27 @@ f_mode(argvars, rettv)
 
     rettv->vval.v_string = vim_strsave(buf);
     rettv->v_type = VAR_STRING;
 }
 
+#ifdef FEAT_MZSCHEME
+/*
+ * "mzeval()" function
+ */
+    static void
+f_mzeval(argvars, rettv)
+    typval_T	*argvars;
+    typval_T	*rettv;
+{
+    char_u	*str;
+    char_u	buf[NUMBUFLEN];
+
+    str = get_tv_string_buf(&argvars[0], buf);
+    do_mzeval(str, rettv);
+}
+#endif
+
 /*
  * "nextnonblank()" function
  */
     static void
 f_nextnonblank(argvars, rettv)
@@ -13674,17 +13763,15 @@ f_printf(argvars, rettv)
 }
 
 /*
  * "pumvisible()" function
  */
-/*ARGSUSED*/
     static void
 f_pumvisible(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
-    rettv->vval.v_number = 0;
 #ifdef FEAT_INS_EXPAND
     if (pum_visible())
 	rettv->vval.v_number = 1;
 #endif
 }
@@ -13714,11 +13801,10 @@ f_range(argvars, rettv)
 	end = get_tv_number_chk(&argvars[1], &error);
 	if (argvars[2].v_type != VAR_UNKNOWN)
 	    stride = get_tv_number_chk(&argvars[2], &error);
     }
 
-    rettv->vval.v_number = 0;
     if (error)
 	return;		/* type error; errmsg already given */
     if (stride == 0)
 	EMSG(_("E726: Stride is zero"));
     else if (stride > 0 ? end + 1 < start : end - 1 > start)
@@ -14081,14 +14167,13 @@ remote_common(argvars, rettv, expr)
 #endif
 
 /*
  * "remote_expr()" function
  */
-/*ARGSUSED*/
     static void
 f_remote_expr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->v_type = VAR_STRING;
     rettv->vval.v_string = NULL;
 #ifdef FEAT_CLIENTSERVER
@@ -14097,17 +14182,15 @@ f_remote_expr(argvars, rettv)
 }
 
 /*
  * "remote_foreground()" function
  */
-/*ARGSUSED*/
     static void
 f_remote_foreground(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
-    rettv->vval.v_number = 0;
 #ifdef FEAT_CLIENTSERVER
 # ifdef WIN32
     /* On Win32 it's done in this application. */
     {
 	char_u	*server_name = get_tv_string_chk(&argvars[0]);
@@ -14124,14 +14207,13 @@ f_remote_foreground(argvars, rettv)
     vim_free(argvars[1].vval.v_string);
 # endif
 #endif
 }
 
-/*ARGSUSED*/
     static void
 f_remote_peek(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_CLIENTSERVER
     dictitem_T	v;
     char_u	*s = NULL;
@@ -14159,11 +14241,10 @@ f_remote_peek(argvars, rettv)
     {
 	s = serverGetReply((HWND)n, FALSE, FALSE, FALSE);
 	rettv->vval.v_number = (s != NULL);
     }
 # else
-    rettv->vval.v_number = 0;
     if (check_connection() == FAIL)
 	return;
 
     rettv->vval.v_number = serverPeekReply(X_DISPLAY,
 						serverStrToWin(serverid), &s);
@@ -14183,14 +14264,13 @@ f_remote_peek(argvars, rettv)
 #else
     rettv->vval.v_number = -1;
 #endif
 }
 
-/*ARGSUSED*/
     static void
 f_remote_read(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     char_u	*r = NULL;
 
 #ifdef FEAT_CLIENTSERVER
@@ -14218,14 +14298,13 @@ f_remote_read(argvars, rettv)
 }
 
 /*
  * "remote_send()" function
  */
-/*ARGSUSED*/
     static void
 f_remote_send(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->v_type = VAR_STRING;
     rettv->vval.v_string = NULL;
 #ifdef FEAT_CLIENTSERVER
@@ -14248,11 +14327,10 @@ f_remove(argvars, rettv)
     long	end;
     char_u	*key;
     dict_T	*d;
     dictitem_T	*di;
 
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type == VAR_DICT)
     {
 	if (argvars[2].v_type != VAR_UNKNOWN)
 	    EMSG2(_(e_toomanyarg), "remove()");
 	else if ((d = argvars[0].vval.v_dict) != NULL
@@ -14351,11 +14429,10 @@ f_rename(argvars, rettv)
 }
 
 /*
  * "repeat()" function
  */
-/*ARGSUSED*/
     static void
 f_repeat(argvars, rettv)
     typval_T	*argvars;
     typval_T	*rettv;
 {
@@ -14606,11 +14683,10 @@ f_reverse(argvars, rettv)
     typval_T	*rettv;
 {
     list_T	*l;
     listitem_T	*li, *ni;
 
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type != VAR_LIST)
 	EMSG2(_(e_listarg), "reverse()");
     else if ((l = argvars[0].vval.v_list) != NULL
 	    && !tv_check_lock(l->lv_lock, (char_u *)"reverse()"))
     {
@@ -14958,12 +15034,10 @@ f_searchpairpos(argvars, rettv)
 {
     pos_T	match_pos;
     int		lnum = 0;
     int		col = 0;
 
-    rettv->vval.v_number = 0;
-
     if (rettv_list_alloc(rettv) == FAIL)
 	return;
 
     if (searchpair_cmn(argvars, &match_pos) > 0)
     {
@@ -15146,12 +15220,10 @@ f_searchpos(argvars, rettv)
     int		lnum = 0;
     int		col = 0;
     int		n;
     int		flags = 0;
 
-    rettv->vval.v_number = 0;
-
     if (rettv_list_alloc(rettv) == FAIL)
 	return;
 
     n = search_cmn(argvars, &match_pos, &flags);
     if (n > 0)
@@ -15165,14 +15237,13 @@ f_searchpos(argvars, rettv)
     if (flags & SP_SUBPAT)
 	list_append_number(rettv->vval.v_list, (varnumber_T)n);
 }
 
 
-/*ARGSUSED*/
     static void
 f_server2client(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_CLIENTSERVER
     char_u	buf[NUMBUFLEN];
     char_u	*server = get_tv_string_chk(&argvars[0]);
@@ -15197,14 +15268,13 @@ f_server2client(argvars, rettv)
 #else
     rettv->vval.v_number = -1;
 #endif
 }
 
-/*ARGSUSED*/
     static void
 f_serverlist(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     char_u	*r = NULL;
 
 #ifdef FEAT_CLIENTSERVER
@@ -15221,24 +15291,21 @@ f_serverlist(argvars, rettv)
 }
 
 /*
  * "setbufvar()" function
  */
-/*ARGSUSED*/
     static void
 f_setbufvar(argvars, rettv)
     typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*rettv UNUSED;
 {
     buf_T	*buf;
     aco_save_T	aco;
     char_u	*varname, *bufvarname;
     typval_T	*varp;
     char_u	nbuf[NUMBUFLEN];
 
-    rettv->vval.v_number = 0;
-
     if (check_restricted() || check_secure())
 	return;
     (void)get_tv_number(&argvars[0]);	    /* issue errmsg if type error */
     varname = get_tv_string_chk(&argvars[1]);
     buf = get_buf_tv(&argvars[0]);
@@ -15314,11 +15381,11 @@ f_setline(argvars, rettv)
 	li = l->lv_first;
     }
     else
 	line = get_tv_string_chk(&argvars[1]);
 
-    rettv->vval.v_number = 0;		/* OK */
+    /* default result is zero == OK */
     for (;;)
     {
 	if (l != NULL)
 	{
 	    /* list argument, get next string */
@@ -15362,16 +15429,15 @@ f_setline(argvars, rettv)
 static void set_qf_ll_list __ARGS((win_T *wp, typval_T *list_arg, typval_T *action_arg, typval_T *rettv));
 
 /*
  * Used by "setqflist()" and "setloclist()" functions
  */
-/*ARGSUSED*/
     static void
 set_qf_ll_list(wp, list_arg, action_arg, rettv)
-    win_T	*wp;
-    typval_T	*list_arg;
-    typval_T	*action_arg;
+    win_T	*wp UNUSED;
+    typval_T	*list_arg UNUSED;
+    typval_T	*action_arg UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_QUICKFIX
     char_u	*act;
     int		action = ' ';
@@ -15402,11 +15468,10 @@ set_qf_ll_list(wp, list_arg, action_arg,
 }
 
 /*
  * "setloclist()" function
  */
-/*ARGSUSED*/
     static void
 f_setloclist(argvars, rettv)
     typval_T	*argvars;
     typval_T	*rettv;
 {
@@ -15480,11 +15545,10 @@ f_setmatches(argvars, rettv)
 }
 
 /*
  * "setpos()" function
  */
-/*ARGSUSED*/
     static void
 f_setpos(argvars, rettv)
     typval_T	*argvars;
     typval_T	*rettv;
 {
@@ -15496,11 +15560,12 @@ f_setpos(argvars, rettv)
     name = get_tv_string_chk(argvars);
     if (name != NULL)
     {
 	if (list2fpos(&argvars[1], &pos, &fnum) == OK)
 	{
-	    --pos.col;
+	    if (--pos.col < 0)
+		pos.col = 0;
 	    if (name[0] == '.' && name[1] == NUL)
 	    {
 		/* set cursor */
 		if (fnum == curbuf->b_fnum)
 		{
@@ -15524,11 +15589,10 @@ f_setpos(argvars, rettv)
 }
 
 /*
  * "setqflist()" function
  */
-/*ARGSUSED*/
     static void
 f_setqflist(argvars, rettv)
     typval_T	*argvars;
     typval_T	*rettv;
 {
@@ -15630,11 +15694,11 @@ f_setwinvar(argvars, rettv)
  * "setwinvar()" and "settabwinvar()" functions
  */
     static void
 setwinvar(argvars, rettv, off)
     typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*rettv UNUSED;
     int		off;
 {
     win_T	*win;
 #ifdef FEAT_WINDOWS
     win_T	*save_curwin;
@@ -15643,12 +15707,10 @@ setwinvar(argvars, rettv, off)
     char_u	*varname, *winvarname;
     typval_T	*varp;
     char_u	nbuf[NUMBUFLEN];
     tabpage_T	*tp;
 
-    rettv->vval.v_number = 0;
-
     if (check_restricted() || check_secure())
 	return;
 
 #ifdef FEAT_WINDOWS
     if (off == 1)
@@ -15836,14 +15898,13 @@ item_compare2(s1, s2)
     clear_tv(&argv[1]);
 
     if (res == FAIL)
 	res = ITEM_COMPARE_FAIL;
     else
-	/* return value has wrong type */
 	res = get_tv_number_chk(&rettv, &item_compare_func_err);
     if (item_compare_func_err)
-	res = ITEM_COMPARE_FAIL;
+	res = ITEM_COMPARE_FAIL;  /* return value has wrong type */
     clear_tv(&rettv);
     return res;
 }
 
 /*
@@ -15858,11 +15919,10 @@ f_sort(argvars, rettv)
     listitem_T	*li;
     listitem_T	**ptrs;
     long	len;
     long	i;
 
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type != VAR_LIST)
 	EMSG2(_(e_listarg), "sort()");
     else
     {
 	l = argvars[0].vval.v_list;
@@ -15950,14 +16010,13 @@ f_soundfold(argvars, rettv)
 }
 
 /*
  * "spellbadword()" function
  */
-/* ARGSUSED */
     static void
 f_spellbadword(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     char_u	*word = (char_u *)"";
     hlf_T	attr = HLF_COUNT;
     int		len = 0;
@@ -16005,14 +16064,13 @@ f_spellbadword(argvars, rettv)
 }
 
 /*
  * "spellsuggest()" function
  */
-/*ARGSUSED*/
     static void
 f_spellsuggest(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_SPELL
     char_u	*str;
     int		typeerr = FALSE;
@@ -16491,14 +16549,13 @@ f_substitute(argvars, rettv)
 }
 
 /*
  * "synID(lnum, col, trans)" function
  */
-/*ARGSUSED*/
     static void
 f_synID(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		id = 0;
 #ifdef FEAT_SYN_HL
     long	lnum;
@@ -16519,14 +16576,13 @@ f_synID(argvars, rettv)
 }
 
 /*
  * "synIDattr(id, what [, mode])" function
  */
-/*ARGSUSED*/
     static void
 f_synIDattr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     char_u	*p = NULL;
 #ifdef FEAT_SYN_HL
     int		id;
@@ -16569,11 +16625,11 @@ f_synIDattr(argvars, rettv)
 		    p = highlight_color(id, what, modec);
 		else					/* bold */
 		    p = highlight_has_attr(id, HL_BOLD, modec);
 		break;
 
-	case 'f':					/* fg[#] */
+	case 'f':					/* fg[#] or font */
 		p = highlight_color(id, what, modec);
 		break;
 
 	case 'i':
 		if (TOLOWER_ASC(what[1]) == 'n')	/* inverse */
@@ -16588,12 +16644,15 @@ f_synIDattr(argvars, rettv)
 
 	case 'r':					/* reverse */
 		p = highlight_has_attr(id, HL_INVERSE, modec);
 		break;
 
-	case 's':					/* standout */
-		p = highlight_has_attr(id, HL_STANDOUT, modec);
+	case 's':
+		if (TOLOWER_ASC(what[1]) == 'p')	/* sp[#] */
+		    p = highlight_color(id, what, modec);
+		else					/* standout */
+		    p = highlight_has_attr(id, HL_STANDOUT, modec);
 		break;
 
 	case 'u':
 		if (STRLEN(what) <= 5 || TOLOWER_ASC(what[5]) != 'c')
 							/* underline */
@@ -16612,14 +16671,13 @@ f_synIDattr(argvars, rettv)
 }
 
 /*
  * "synIDtrans(id)" function
  */
-/*ARGSUSED*/
     static void
 f_synIDtrans(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		id;
 
 #ifdef FEAT_SYN_HL
@@ -16635,14 +16693,13 @@ f_synIDtrans(argvars, rettv)
 }
 
 /*
  * "synstack(lnum, col)" function
  */
-/*ARGSUSED*/
     static void
 f_synstack(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_SYN_HL
     long	lnum;
     long	col;
@@ -16656,11 +16713,11 @@ f_synstack(argvars, rettv)
 #ifdef FEAT_SYN_HL
     lnum = get_tv_lnum(argvars);		/* -1 on type error */
     col = get_tv_number(&argvars[1]) - 1;	/* -1 on type error */
 
     if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count
-	    && col >= 0 && col < (long)STRLEN(ml_get(lnum))
+	    && col >= 0 && (col == 0 || col < (long)STRLEN(ml_get(lnum)))
 	    && rettv_list_alloc(rettv) != FAIL)
     {
 	(void)syn_get_id(curwin, lnum, (colnr_T)col, FALSE, NULL, TRUE);
 	for (i = 0; ; ++i)
 	{
@@ -16772,19 +16829,16 @@ done:
 }
 
 /*
  * "tabpagebuflist()" function
  */
-/* ARGSUSED */
     static void
 f_tabpagebuflist(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
-#ifndef FEAT_WINDOWS
-    rettv->vval.v_number = 0;
-#else
+#ifdef FEAT_WINDOWS
     tabpage_T	*tp;
     win_T	*wp = NULL;
 
     if (argvars[0].v_type == VAR_UNKNOWN)
 	wp = firstwin;
@@ -16792,35 +16846,27 @@ f_tabpagebuflist(argvars, rettv)
     {
 	tp = find_tabpage((int)get_tv_number(&argvars[0]));
 	if (tp != NULL)
 	    wp = (tp == curtab) ? firstwin : tp->tp_firstwin;
     }
-    if (wp == NULL)
-	rettv->vval.v_number = 0;
-    else
+    if (wp != NULL && rettv_list_alloc(rettv) != FAIL)
     {
-	if (rettv_list_alloc(rettv) == FAIL)
-	    rettv->vval.v_number = 0;
-	else
-	{
-	    for (; wp != NULL; wp = wp->w_next)
-		if (list_append_number(rettv->vval.v_list,
+	for (; wp != NULL; wp = wp->w_next)
+	    if (list_append_number(rettv->vval.v_list,
 						wp->w_buffer->b_fnum) == FAIL)
-		    break;
-	}
+		break;
     }
 #endif
 }
 
 
 /*
  * "tabpagenr()" function
  */
-/* ARGSUSED */
     static void
 f_tabpagenr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		nr = 1;
 #ifdef FEAT_WINDOWS
     char_u	*arg;
@@ -16898,14 +16944,13 @@ get_winnr(tp, argvar)
 #endif
 
 /*
  * "tabpagewinnr()" function
  */
-/* ARGSUSED */
     static void
 f_tabpagewinnr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		nr = 1;
 #ifdef FEAT_WINDOWS
     tabpage_T	*tp;
@@ -16921,25 +16966,21 @@ f_tabpagewinnr(argvars, rettv)
 
 
 /*
  * "tagfiles()" function
  */
-/*ARGSUSED*/
     static void
 f_tagfiles(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     char_u	fname[MAXPATHL + 1];
     tagname_T	tn;
     int		first;
 
     if (rettv_list_alloc(rettv) == FAIL)
-    {
-	rettv->vval.v_number = 0;
 	return;
-    }
 
     for (first = TRUE; ; first = FALSE)
 	if (get_tagfname(&tn, first, fname) == FAIL
 		|| list_append_string(rettv->vval.v_list, fname, -1) == FAIL)
 	    break;
@@ -16967,14 +17008,13 @@ f_taglist(argvars, rettv)
 }
 
 /*
  * "tempname()" function
  */
-/*ARGSUSED*/
     static void
 f_tempname(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     static int	x = 'A';
 
     rettv->v_type = VAR_STRING;
@@ -17003,15 +17043,14 @@ f_tempname(argvars, rettv)
 }
 
 /*
  * "test(list)" function: Just checking the walls...
  */
-/*ARGSUSED*/
     static void
 f_test(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
     /* Used for unit testing.  Change the code below to your liking. */
 #if 0
     listitem_T	*li;
     list_T	*l;
@@ -17292,15 +17331,14 @@ f_virtcol(argvars, rettv)
 }
 
 /*
  * "visualmode()" function
  */
-/*ARGSUSED*/
     static void
 f_visualmode(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_VISUAL
     char_u	str[2];
 
     rettv->v_type = VAR_STRING;
@@ -17309,12 +17347,10 @@ f_visualmode(argvars, rettv)
     rettv->vval.v_string = vim_strsave(str);
 
     /* A non-zero number or non-empty string argument: reset mode. */
     if (non_zero_arg(&argvars[0]))
 	curbuf->b_visual_mode_eval = NUL;
-#else
-    rettv->vval.v_number = 0; /* return anything, it won't work anyway */
 #endif
 }
 
 /*
  * "winbufnr(nr)" function
@@ -17334,14 +17370,13 @@ f_winbufnr(argvars, rettv)
 }
 
 /*
  * "wincol()" function
  */
-/*ARGSUSED*/
     static void
 f_wincol(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     validate_cursor();
     rettv->vval.v_number = curwin->w_wcol + 1;
 }
@@ -17364,27 +17399,25 @@ f_winheight(argvars, rettv)
 }
 
 /*
  * "winline()" function
  */
-/*ARGSUSED*/
     static void
 f_winline(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     validate_cursor();
     rettv->vval.v_number = curwin->w_wrow + 1;
 }
 
 /*
  * "winnr()" function
  */
-/* ARGSUSED */
     static void
 f_winnr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		nr = 1;
 
 #ifdef FEAT_WINDOWS
@@ -17394,14 +17427,13 @@ f_winnr(argvars, rettv)
 }
 
 /*
  * "winrestcmd()" function
  */
-/* ARGSUSED */
     static void
 f_winrestcmd(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_WINDOWS
     win_T	*wp;
     int		winnr = 1;
@@ -17429,15 +17461,14 @@ f_winrestcmd(argvars, rettv)
 }
 
 /*
  * "winrestview()" function
  */
-/* ARGSUSED */
     static void
 f_winrestview(argvars, rettv)
     typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*rettv UNUSED;
 {
     dict_T	*dict;
 
     if (argvars[0].v_type != VAR_DICT
 	    || (dict = argvars[0].vval.v_dict) == NULL)
@@ -17475,14 +17506,13 @@ f_winrestview(argvars, rettv)
 }
 
 /*
  * "winsaveview()" function
  */
-/* ARGSUSED */
     static void
 f_winsaveview(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     dict_T	*dict;
 
     dict = dict_alloc();
@@ -18095,18 +18125,57 @@ get_vim_var_str(idx)
 {
     return get_tv_string(&vimvars[idx].vv_tv);
 }
 
 /*
- * Set v:count, v:count1 and v:prevcount.
+ * Get List v: variable value.  Caller must take care of reference count when
+ * needed.
+ */
+    list_T *
+get_vim_var_list(idx)
+    int		idx;
+{
+    return vimvars[idx].vv_list;
+}
+
+/*
+ * Set v:char to character "c".
  */
     void
-set_vcount(count, count1)
+set_vim_var_char(c)
+    int c;
+{
+#ifdef FEAT_MBYTE
+    char_u	buf[MB_MAXBYTES];
+#else
+    char_u	buf[2];
+#endif
+
+#ifdef FEAT_MBYTE
+    if (has_mbyte)
+	buf[(*mb_char2bytes)(c, buf)] = NUL;
+    else
+#endif
+    {
+	buf[0] = c;
+	buf[1] = NUL;
+    }
+    set_vim_var_string(VV_CHAR, buf, -1);
+}
+
+/*
+ * Set v:count to "count" and v:count1 to "count1".
+ * When "set_prevcount" is TRUE first set v:prevcount from v:count.
+ */
+    void
+set_vcount(count, count1, set_prevcount)
     long	count;
     long	count1;
+    int		set_prevcount;
 {
-    vimvars[VV_PREVCOUNT].vv_nr = vimvars[VV_COUNT].vv_nr;
+    if (set_prevcount)
+	vimvars[VV_PREVCOUNT].vv_nr = vimvars[VV_COUNT].vv_nr;
     vimvars[VV_COUNT].vv_nr = count;
     vimvars[VV_COUNT1].vv_nr = count1;
 }
 
 /*
@@ -18130,10 +18199,24 @@ set_vim_var_string(idx, val, len)
     else
 	vimvars[idx].vv_str = vim_strnsave(val, len);
 }
 
 /*
+ * Set List v: variable to "val".
+ */
+    void
+set_vim_var_list(idx, val)
+    int		idx;
+    list_T	*val;
+{
+    list_unref(vimvars[idx].vv_list);
+    vimvars[idx].vv_list = val;
+    if (val != NULL)
+	++val->lv_refcount;
+}
+
+/*
  * Set v:register if needed.
  */
     void
 set_reg_var(c)
     int		c;
@@ -18866,11 +18949,12 @@ new_script_vars(id)
 init_var_dict(dict, dict_var)
     dict_T	*dict;
     dictitem_T	*dict_var;
 {
     hash_init(&dict->dv_hashtab);
-    dict->dv_refcount = 99999;
+    dict->dv_refcount = DO_NOT_FREE_CNT;
+    dict->dv_copyID = 0;
     dict_var->di_tv.vval.v_dict = dict;
     dict_var->di_tv.v_type = VAR_DICT;
     dict_var->di_tv.v_lock = VAR_FIXED;
     dict_var->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;
     dict_var->di_key[0] = NUL;
@@ -18949,11 +19033,12 @@ list_one_var(v, prefix, first)
 {
     char_u	*tofree;
     char_u	*s;
     char_u	numbuf[NUMBUFLEN];
 
-    s = echo_string(&v->di_tv, &tofree, numbuf, ++current_copyID);
+    current_copyID += COPYID_INC;
+    s = echo_string(&v->di_tv, &tofree, numbuf, current_copyID);
     list_one_var_a(prefix, v->di_key, v->di_tv.v_type,
 					 s == NULL ? (char_u *)"" : s, first);
     vim_free(tofree);
 }
 
@@ -19203,12 +19288,14 @@ tv_check_lock(lock, name)
 
 /*
  * Copy the values from typval_T "from" to typval_T "to".
  * When needed allocates string or increases reference count.
  * Does not make a copy of a list or dict but copies the reference!
+ * It is OK for "from" and "to" to point to the same item.  This is used to
+ * make a copy later.
  */
-    static void
+    void
 copy_tv(from, to)
     typval_T *from;
     typval_T *to;
 {
     to->v_type = from->v_type;
@@ -19382,11 +19469,12 @@ ex_echo(eap)
 		if (eap->cmdidx == CMD_echo)
 		    msg_start();
 	    }
 	    else if (eap->cmdidx == CMD_echo)
 		msg_puts_attr((char_u *)" ", echo_attr);
-	    p = echo_string(&rettv, &tofree, numbuf, ++current_copyID);
+	    current_copyID += COPYID_INC;
+	    p = echo_string(&rettv, &tofree, numbuf, current_copyID);
 	    if (p != NULL)
 		for ( ; *p != NUL && !got_int; ++p)
 		{
 		    if (*p == '\n' || *p == '\r' || *p == TAB)
 		    {
@@ -19658,10 +19746,11 @@ ex_function(eap)
 			if (!isdigit(*fp->uf_name)
 				    && vim_regexec(&regmatch, fp->uf_name, 0))
 			    list_func_head(fp, FALSE);
 		    }
 		}
+		vim_free(regmatch.regprog);
 	    }
 	}
 	if (*p == '/')
 	    ++p;
 	eap->nextcmd = check_nextcmd(p);
@@ -19746,11 +19835,11 @@ ex_function(eap)
 		    msg_putchar('\n');
 		    msg_puts((char_u *)"   endfunction");
 		}
 	    }
 	    else
-		emsg_funcname("E123: Undefined function: %s", name);
+		emsg_funcname(N_("E123: Undefined function: %s"), name);
 	}
 	goto ret_free;
     }
 
     /*
@@ -19790,11 +19879,11 @@ ex_function(eap)
 		j = 0;
 	    while (arg[j] != NUL && (j == 0 ? eval_isnamec1(arg[j])
 						      : eval_isnamec(arg[j])))
 		++j;
 	    if (arg[j] != NUL)
-		emsg_funcname(_(e_invarg2), arg);
+		emsg_funcname((char *)e_invarg2, arg);
 	}
     }
 
     /*
      * Isolate the arguments: "arg1, arg2, ...)"
@@ -20062,11 +20151,11 @@ ex_function(eap)
     if (fudi.fd_dict == NULL)
     {
 	v = find_var(name, &ht);
 	if (v != NULL && v->di_tv.v_type == VAR_FUNC)
 	{
-	    emsg_funcname("E707: Function name conflicts with variable: %s",
+	    emsg_funcname(N_("E707: Function name conflicts with variable: %s"),
 									name);
 	    goto erret;
 	}
 
 	fp = find_func(name);
@@ -20077,11 +20166,11 @@ ex_function(eap)
 		emsg_funcname(e_funcexts, name);
 		goto erret;
 	    }
 	    if (fp->uf_calls > 0)
 	    {
-		emsg_funcname("E127: Cannot redefine function %s: It is in use",
+		emsg_funcname(N_("E127: Cannot redefine function %s: It is in use"),
 									name);
 		goto erret;
 	    }
 	    /* redefine existing function */
 	    ga_clear_strings(&(fp->uf_args));
@@ -20588,10 +20677,13 @@ func_dump_profile(fd)
     int		i;
     ufunc_T	**sorttab;
     int		st_len = 0;
 
     todo = (int)func_hashtab.ht_used;
+    if (todo == 0)
+	return;     /* nothing to dump */
+
     sorttab = (ufunc_T **)alloc((unsigned)(sizeof(ufunc_T) * todo));
 
     for (hi = func_hashtab.ht_array; todo > 0; ++hi)
     {
 	if (!HASHITEM_EMPTY(hi))
@@ -20636,10 +20728,12 @@ func_dump_profile(fd)
 	prof_sort_list(fd, sorttab, st_len, "TOTAL", FALSE);
 	qsort((void *)sorttab, (size_t)st_len, sizeof(ufunc_T *),
 							      prof_self_cmp);
 	prof_sort_list(fd, sorttab, st_len, "SELF", TRUE);
     }
+
+    vim_free(sorttab);
 }
 
     static void
 prof_sort_list(fd, sorttab, st_len, title, prefer_self)
     FILE	*fd;
@@ -21010,11 +21104,11 @@ call_user_func(fp, argcount, argvars, re
     dict_T	*selfdict;	/* Dictionary for "self" */
 {
     char_u	*save_sourcing_name;
     linenr_T	save_sourcing_lnum;
     scid_T	save_current_SID;
-    funccall_T	fc;
+    funccall_T	*fc;
     int		save_did_emsg;
     static int	depth = 0;
     dictitem_T	*v;
     int		fixvar_idx = 0;	/* index in fixvar[] */
     int		i;
@@ -21036,40 +21130,41 @@ call_user_func(fp, argcount, argvars, re
     }
     ++depth;
 
     line_breakcheck();		/* check for CTRL-C hit */
 
-    fc.caller = current_funccal;
-    current_funccal = &fc;
-    fc.func = fp;
-    fc.rettv = rettv;
+    fc = (funccall_T *)alloc(sizeof(funccall_T));
+    fc->caller = current_funccal;
+    current_funccal = fc;
+    fc->func = fp;
+    fc->rettv = rettv;
     rettv->vval.v_number = 0;
-    fc.linenr = 0;
-    fc.returned = FALSE;
-    fc.level = ex_nesting_level;
+    fc->linenr = 0;
+    fc->returned = FALSE;
+    fc->level = ex_nesting_level;
     /* Check if this function has a breakpoint. */
-    fc.breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name, (linenr_T)0);
-    fc.dbg_tick = debug_tick;
+    fc->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name, (linenr_T)0);
+    fc->dbg_tick = debug_tick;
 
     /*
-     * Note about using fc.fixvar[]: This is an array of FIXVAR_CNT variables
+     * Note about using fc->fixvar[]: This is an array of FIXVAR_CNT variables
      * with names up to VAR_SHORT_LEN long.  This avoids having to alloc/free
      * each argument variable and saves a lot of time.
      */
     /*
      * Init l: variables.
      */
-    init_var_dict(&fc.l_vars, &fc.l_vars_var);
+    init_var_dict(&fc->l_vars, &fc->l_vars_var);
     if (selfdict != NULL)
     {
 	/* Set l:self to "selfdict".  Use "name" to avoid a warning from
 	 * some compiler that checks the destination size. */
-	v = &fc.fixvar[fixvar_idx++].var;
+	v = &fc->fixvar[fixvar_idx++].var;
 	name = v->di_key;
 	STRCPY(name, "self");
 	v->di_flags = DI_FLAGS_RO + DI_FLAGS_FIX;
-	hash_add(&fc.l_vars.dv_hashtab, DI2HIKEY(v));
+	hash_add(&fc->l_vars.dv_hashtab, DI2HIKEY(v));
 	v->di_tv.v_type = VAR_DICT;
 	v->di_tv.v_lock = 0;
 	v->di_tv.vval.v_dict = selfdict;
 	++selfdict->dv_refcount;
     }
@@ -21077,32 +21172,35 @@ call_user_func(fp, argcount, argvars, re
     /*
      * Init a: variables.
      * Set a:0 to "argcount".
      * Set a:000 to a list with room for the "..." arguments.
      */
-    init_var_dict(&fc.l_avars, &fc.l_avars_var);
-    add_nr_var(&fc.l_avars, &fc.fixvar[fixvar_idx++].var, "0",
+    init_var_dict(&fc->l_avars, &fc->l_avars_var);
+    add_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, "0",
 				(varnumber_T)(argcount - fp->uf_args.ga_len));
-    v = &fc.fixvar[fixvar_idx++].var;
-    STRCPY(v->di_key, "000");
+    /* Use "name" to avoid a warning from some compiler that checks the
+     * destination size. */
+    v = &fc->fixvar[fixvar_idx++].var;
+    name = v->di_key;
+    STRCPY(name, "000");
     v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;
-    hash_add(&fc.l_avars.dv_hashtab, DI2HIKEY(v));
+    hash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));
     v->di_tv.v_type = VAR_LIST;
     v->di_tv.v_lock = VAR_FIXED;
-    v->di_tv.vval.v_list = &fc.l_varlist;
-    vim_memset(&fc.l_varlist, 0, sizeof(list_T));
-    fc.l_varlist.lv_refcount = 99999;
-    fc.l_varlist.lv_lock = VAR_FIXED;
+    v->di_tv.vval.v_list = &fc->l_varlist;
+    vim_memset(&fc->l_varlist, 0, sizeof(list_T));
+    fc->l_varlist.lv_refcount = DO_NOT_FREE_CNT;
+    fc->l_varlist.lv_lock = VAR_FIXED;
 
     /*
      * Set a:firstline to "firstline" and a:lastline to "lastline".
      * Set a:name to named arguments.
      * Set a:N to the "..." arguments.
      */
-    add_nr_var(&fc.l_avars, &fc.fixvar[fixvar_idx++].var, "firstline",
+    add_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, "firstline",
 						      (varnumber_T)firstline);
-    add_nr_var(&fc.l_avars, &fc.fixvar[fixvar_idx++].var, "lastline",
+    add_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, "lastline",
 						       (varnumber_T)lastline);
     for (i = 0; i < argcount; ++i)
     {
 	ai = i - fp->uf_args.ga_len;
 	if (ai < 0)
@@ -21114,11 +21212,11 @@ call_user_func(fp, argcount, argvars, re
 	    sprintf((char *)numbuf, "%d", ai + 1);
 	    name = numbuf;
 	}
 	if (fixvar_idx < FIXVAR_CNT && STRLEN(name) <= VAR_SHORT_LEN)
 	{
-	    v = &fc.fixvar[fixvar_idx++].var;
+	    v = &fc->fixvar[fixvar_idx++].var;
 	    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;
 	}
 	else
 	{
 	    v = (dictitem_T *)alloc((unsigned)(sizeof(dictitem_T)
@@ -21126,22 +21224,22 @@ call_user_func(fp, argcount, argvars, re
 	    if (v == NULL)
 		break;
 	    v->di_flags = DI_FLAGS_RO;
 	}
 	STRCPY(v->di_key, name);
-	hash_add(&fc.l_avars.dv_hashtab, DI2HIKEY(v));
+	hash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));
 
 	/* Note: the values are copied directly to avoid alloc/free.
 	 * "argvars" must have VAR_FIXED for v_lock. */
 	v->di_tv = argvars[i];
 	v->di_tv.v_lock = VAR_FIXED;
 
 	if (ai >= 0 && ai < MAX_FUNC_ARGS)
 	{
-	    list_append(&fc.l_varlist, &fc.l_listitems[ai]);
-	    fc.l_listitems[ai].li_tv = argvars[i];
-	    fc.l_listitems[ai].li_tv.v_lock = VAR_FIXED;
+	    list_append(&fc->l_varlist, &fc->l_listitems[ai]);
+	    fc->l_listitems[ai].li_tv = argvars[i];
+	    fc->l_listitems[ai].li_tv.v_lock = VAR_FIXED;
 	}
     }
 
     /* Don't redraw while executing the function. */
     ++RedrawingDisabled;
@@ -21202,11 +21300,11 @@ call_user_func(fp, argcount, argvars, re
     if (do_profiling == PROF_YES)
     {
 	if (!fp->uf_profiling && has_profiling(FALSE, fp->uf_name, NULL))
 	    func_do_profile(fp);
 	if (fp->uf_profiling
-		       || (fc.caller != NULL && &fc.caller->func->uf_profiling))
+		    || (fc->caller != NULL && fc->caller->func->uf_profiling))
 	{
 	    ++fp->uf_tm_count;
 	    profile_start(&call_start);
 	    profile_zero(&fp->uf_tm_children);
 	}
@@ -21218,11 +21316,11 @@ call_user_func(fp, argcount, argvars, re
     current_SID = fp->uf_script_ID;
     save_did_emsg = did_emsg;
     did_emsg = FALSE;
 
     /* call do_cmdline() to execute the lines */
-    do_cmdline(NULL, get_func_line, (void *)&fc,
+    do_cmdline(NULL, get_func_line, (void *)fc,
 				     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);
 
     --RedrawingDisabled;
 
     /* when the function was aborted because of an error, return -1 */
@@ -21233,20 +21331,20 @@ call_user_func(fp, argcount, argvars, re
 	rettv->vval.v_number = -1;
     }
 
 #ifdef FEAT_PROFILE
     if (do_profiling == PROF_YES && (fp->uf_profiling
-		    || (fc.caller != NULL && &fc.caller->func->uf_profiling)))
+		    || (fc->caller != NULL && fc->caller->func->uf_profiling)))
     {
 	profile_end(&call_start);
 	profile_sub_wait(&wait_start, &call_start);
 	profile_add(&fp->uf_tm_total, &call_start);
 	profile_self(&fp->uf_tm_self, &call_start, &fp->uf_tm_children);
-	if (fc.caller != NULL && &fc.caller->func->uf_profiling)
+	if (fc->caller != NULL && fc->caller->func->uf_profiling)
 	{
-	    profile_add(&fc.caller->func->uf_tm_children, &call_start);
-	    profile_add(&fc.caller->func->uf_tml_children, &call_start);
+	    profile_add(&fc->caller->func->uf_tm_children, &call_start);
+	    profile_add(&fc->caller->func->uf_tml_children, &call_start);
 	}
     }
 #endif
 
     /* when being verbose, mention the return value */
@@ -21255,24 +21353,24 @@ call_user_func(fp, argcount, argvars, re
 	++no_wait_return;
 	verbose_enter_scroll();
 
 	if (aborting())
 	    smsg((char_u *)_("%s aborted"), sourcing_name);
-	else if (fc.rettv->v_type == VAR_NUMBER)
+	else if (fc->rettv->v_type == VAR_NUMBER)
 	    smsg((char_u *)_("%s returning #%ld"), sourcing_name,
-					       (long)fc.rettv->vval.v_number);
+					       (long)fc->rettv->vval.v_number);
 	else
 	{
 	    char_u	buf[MSG_BUF_LEN];
 	    char_u	numbuf2[NUMBUFLEN];
 	    char_u	*tofree;
 	    char_u	*s;
 
 	    /* The value may be very long.  Skip the middle part, so that we
 	     * have some idea how it starts and ends. smsg() would always
 	     * truncate it at the end. */
-	    s = tv2string(fc.rettv, &tofree, numbuf2, 0);
+	    s = tv2string(fc->rettv, &tofree, numbuf2, 0);
 	    if (s != NULL)
 	    {
 		trunc_string(s, buf, MSG_BUF_CLEN);
 		smsg((char_u *)_("%s returning %s"), sourcing_name, buf);
 		vim_free(tofree);
@@ -21304,18 +21402,88 @@ call_user_func(fp, argcount, argvars, re
 	verbose_leave_scroll();
 	--no_wait_return;
     }
 
     did_emsg |= save_did_emsg;
-    current_funccal = fc.caller;
+    current_funccal = fc->caller;
+    --depth;
 
-    /* The a: variables typevals were not allocated, only free the allocated
-     * variables. */
-    vars_clear_ext(&fc.l_avars.dv_hashtab, FALSE);
+    /* If the a:000 list and the l: and a: dicts are not referenced we can
+     * free the funccall_T and what's in it. */
+    if (fc->l_varlist.lv_refcount == DO_NOT_FREE_CNT
+	    && fc->l_vars.dv_refcount == DO_NOT_FREE_CNT
+	    && fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)
+    {
+	free_funccal(fc, FALSE);
+    }
+    else
+    {
+	hashitem_T	*hi;
+	listitem_T	*li;
+	int		todo;
 
-    vars_clear(&fc.l_vars.dv_hashtab);		/* free all l: variables */
-    --depth;
+	/* "fc" is still in use.  This can happen when returning "a:000" or
+	 * assigning "l:" to a global variable.
+	 * Link "fc" in the list for garbage collection later. */
+	fc->caller = previous_funccal;
+	previous_funccal = fc;
+
+	/* Make a copy of the a: variables, since we didn't do that above. */
+	todo = (int)fc->l_avars.dv_hashtab.ht_used;
+	for (hi = fc->l_avars.dv_hashtab.ht_array; todo > 0; ++hi)
+	{
+	    if (!HASHITEM_EMPTY(hi))
+	    {
+		--todo;
+		v = HI2DI(hi);
+		copy_tv(&v->di_tv, &v->di_tv);
+	    }
+	}
+
+	/* Make a copy of the a:000 items, since we didn't do that above. */
+	for (li = fc->l_varlist.lv_first; li != NULL; li = li->li_next)
+	    copy_tv(&li->li_tv, &li->li_tv);
+    }
+}
+
+/*
+ * Return TRUE if items in "fc" do not have "copyID".  That means they are not
+ * referenced from anywhere that is in use.
+ */
+    static int
+can_free_funccal(fc, copyID)
+    funccall_T	*fc;
+    int		copyID;
+{
+    return (fc->l_varlist.lv_copyID != copyID
+	    && fc->l_vars.dv_copyID != copyID
+	    && fc->l_avars.dv_copyID != copyID);
+}
+
+/*
+ * Free "fc" and what it contains.
+ */
+   static void
+free_funccal(fc, free_val)
+    funccall_T	*fc;
+    int		free_val;  /* a: vars were allocated */
+{
+    listitem_T	*li;
+
+    /* The a: variables typevals may not have been allocated, only free the
+     * allocated variables. */
+    vars_clear_ext(&fc->l_avars.dv_hashtab, free_val);
+
+    /* free all l: variables */
+    vars_clear(&fc->l_vars.dv_hashtab);
+
+    /* Free the a:000 variables if they were allocated. */
+    if (free_val)
+	for (li = fc->l_varlist.lv_first; li != NULL; li = li->li_next)
+	    clear_tv(&li->li_tv);
+
+    vim_free(fc);
 }
 
 /*
  * Add a number variable "name" to dict "dp" with value "nr".
  */
@@ -21510,16 +21678,15 @@ get_return_cmd(rettv)
 /*
  * Get next function line.
  * Called by do_cmdline() to get the next line.
  * Returns allocated string, or NULL for end of function.
  */
-/* ARGSUSED */
     char_u *
 get_func_line(c, cookie, indent)
-    int	    c;		    /* not used */
+    int	    c UNUSED;
     void    *cookie;
-    int	    indent;	    /* not used */
+    int	    indent UNUSED;
 {
     funccall_T	*fcp = (funccall_T *)cookie;
     ufunc_T	*fp = fcp->func;
     char_u	*retval;
     garray_T	*gap;  /* growarray with function lines */
@@ -21884,10 +22051,65 @@ last_set_msg(scriptID)
 	    verbose_leave();
 	}
     }
 }
 
+/*
+ * List v:oldfiles in a nice way.
+ */
+    void
+ex_oldfiles(eap)
+    exarg_T	*eap UNUSED;
+{
+    list_T	*l = vimvars[VV_OLDFILES].vv_list;
+    listitem_T	*li;
+    int		nr = 0;
+
+    if (l == NULL)
+	msg((char_u *)_("No old files"));
+    else
+    {
+	msg_start();
+	msg_scroll = TRUE;
+	for (li = l->lv_first; li != NULL && !got_int; li = li->li_next)
+	{
+	    msg_outnum((long)++nr);
+	    MSG_PUTS(": ");
+	    msg_outtrans(get_tv_string(&li->li_tv));
+	    msg_putchar('\n');
+	    out_flush();	    /* output one line at a time */
+	    ui_breakcheck();
+	}
+	/* Assume "got_int" was set to truncate the listing. */
+	got_int = FALSE;
+
+#ifdef FEAT_BROWSE_CMD
+	if (cmdmod.browse)
+	{
+	    quit_more = FALSE;
+	    nr = prompt_for_number(FALSE);
+	    msg_starthere();
+	    if (nr > 0)
+	    {
+		char_u *p = list_find_str(get_vim_var_list(VV_OLDFILES),
+								    (long)nr);
+
+		if (p != NULL)
+		{
+		    p = expand_env_save(p);
+		    eap->arg = p;
+		    eap->cmdidx = CMD_edit;
+		    cmdmod.browse = FALSE;
+		    do_exedit(eap, NULL);
+		    vim_free(p);
+		}
+	    }
+	}
+#endif
+    }
+}
+
 #endif /* FEAT_EVAL */
 
 
 #if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) || defined(PROTO)
 
--- vim72.orig/runtime/scripts.vim
+++ vim72/runtime/scripts.vim
@@ -232,10 +232,14 @@ else
 
     " XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
   elseif s:line1 =~ '\<DTD\s\+XHTML\s'
     set ft=xhtml
 
+    " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
+  elseif s:line1 =~? '\<DOCTYPE\s\+html\>'
+    set ft=html
+
     " PDF
   elseif s:line1 =~ '^%PDF-'
     set ft=pdf
 
     " XXD output
--- vim72.orig/runtime/doc/os_vms.txt
+++ vim72/runtime/doc/os_vms.txt
@@ -1,6 +1,6 @@
-*os_vms.txt*    For Vim version 7.2.  Last change: 2006 Nov 18
+*os_vms.txt*    For Vim version 7.2.  Last change: 2008 Aug 19
 
 
 		  VIM REFERENCE MANUAL
 
 
@@ -310,11 +310,11 @@ features, it is worth to choose non GUI
 
 ==============================================================================
 
 8. Useful notes						*vms-notes*
 
-8.1 backspace/delete
+8.1 Backspace/delete
 8.2 Filters
 8.3 VMS file version numbers
 8.4 Directory conversion
 8.5 Remote host invocation
 8.6 Terminal problems
@@ -324,12 +324,14 @@ features, it is worth to choose non GUI
 8.10 Setting up the symbols
 8.11 diff and other GNU programs
 8.12 diff-mode
 8.13 Allow '$' in C keywords
 8.14 VIMTUTOR for beginners
+8.15 Slow start in console mode issue
+8.16 Common VIM directory - different architectures
 
-8.1 backspace/delete
+8.1 Backspace/delete
 
 There are backspace/delete key inconsistencies with VMS.
 :fixdel doesn't do the trick, but the solution is: >
 
 	:inoremap ^? ^H		" for terminal mode
@@ -661,16 +663,134 @@ start it with: >
 
 	@vim:vimtutor
 
 (Thomas.R.Wyant III, Vim 6.1)
 
+8.14 Slow start in console mode issue
+
+As GUI/GTK Vim works equally well in console mode, many administartors
+deploy those executables system wide.
+Unfortunately, on a remote slow connections GUI/GTK executables behave rather
+slow when user wants to run Vim just in the console mode - because of X environment detection timeout.
+
+Luckily, there is a simple solution for that. Administrators need to deploy
+both GUI/GTK build and just console build executables, like below: >
+
+    |- vim72
+    |----- doc
+    |----- syntax
+       vimrc    (system rc files)
+       gvimrc
+       gvim.exe (the remaned GUI or GTK built vim.exe)
+       vim.exe  (the console only executable)
+
+Define system symbols like below in for ex in LOGIN.COM or SYLOGIN.COM: >
+
+	$ define/nolog VIM RF10:[UTIL.VIM72] ! where you VIM directory is
+	$ vi*m  :== mcr VIM:VIM.EXE
+	$ gvi*m :== mcr VIM:GVIM.EXE
+	$ ! or you can try to spawn with
+	$ gv*im :== spawn/nowait/input=NLA0 mcr VIM:GVIM.EXE -g -GEOMETRY 80x40
+
+
+Like this, users that do not have X environment and want to use Vim just in
+console mode can avoid performance problems.
+
+(Zoltan Arpadffy, Vim 7.2)
+
+8.15 Common VIM directory - different architectures
+
+In a cluster that contains nodes with different architectures like below:
+
+$show cluster
+View of Cluster from system ID 11655  node: TOR                                                                     18-AUG-2008 11:58:31
++---------------------------------+
+        SYSTEMS         MEMBERS 
++-----------------------+---------
+  NODE     SOFTWARE     STATUS 
++--------+--------------+---------
+ TOR     VMS V7.3-2    MEMBER  
+ TITAN2  VMS V8.3      MEMBER  
+ ODIN    VMS V7.3-2    MEMBER  
++---------------------------------+
+
+It is convinient to have a common VIM directory but execute different
+executables.
+There are more solutions for this problem:
+
+solution 1. all executables in the same directory with different names
+This is easily done with the following script that can be added
+to the login.com or sylogin.com: >
+
+	$ if f$getsyi("NODE_HWTYPE") .eqs. "VAX"
+	$ then
+	$       say "VAX platform"
+	$       vi*m:== mcr vim:VIM.EXE_VAX
+	$ endif
+	$ if f$getsyi("NODE_HWTYPE") .eqs. "ALPH"
+	$ then
+	$       say "ALPHA platform"
+	$       vi*m :== mcr vim:VIM.EXE_AXP
+	$ endif
+	$ if f$getsyi("ARCH_NAME") .eqs. "IA64"
+	$ then
+	$      say "IA64 platform"
+	$      vi*m :== mcr vim:VIM.EXE_IA64
+	$ endif
+
+solution 2. different directories: >
+
+	$ if f$getsyi("NODE_HWTYPE") .eqs. "VAX"
+	$ then
+	$       say "VAX platform"
+	$       define/nolog VIM RF10:[UTIL.VAX_EXE] ! VAX executables
+	$ endif
+	$ if f$getsyi("NODE_HWTYPE") .eqs. "ALPH"
+	$ then
+	$       say "ALPHA platform"
+	$       define/nolog VIM RF10:[UTIL.AXP_EXE] ! AXP executables
+	$ endif
+	$ if f$getsyi("ARCH_NAME") .eqs. "IA64"
+	$ then
+	$      say "IA64 platform"
+	$      define/nolog VIM RF10:[UTIL.IA64_EXE] ! IA64 executables
+	$ endif
+        $! VIMRUNTIME must be defined in order to find runtime files
+	$ define/nolog VIMRUNTIME RF10:[UTIL.VIM72]
+
+A good examle for this approach is the [GNU]gnu_tools.com script from GNU_TOOLS.ZIP
+package downloadable from http://www.polarhome.com/vim/
+
+(Zoltan Arpadffy, Vim 7.2)
+
 ==============================================================================
 
 9. VMS related changes					*vms-changes*
 
-Version 7
+Recent changes
+- The following plugins are included into VMS runtime:
+  genutils 2.4, multiselect 2.2, multvals 3.1, selectbuf 4.3,
+  bufexplorer 7.1.7, taglist 4.5
+- minor changes in vimrc (just in VMS runtime)
+- make_vms.mms - HUGE model is the default
+- [TESTDIR]make_vms.mms include as many tests possible
+- modify test30 and test54 for VMS
+- enable FLOAT feature in VMS port
+- os_vms.txt updated
+
+Version 7.2 (2008 Aug 9)
+- VCF files write corrected
+- CTAGS 5.7 included
+- corrected make_vms.mms (on VAX gave syntax error)
+
+Version 7.1 (2007 Jun 15)
+- create TAGS file from menu
+
+Version 7 (2006 May 8)
 - Improved low level char input (affects just console mode)
+- Fixed plugin bug
+- CTAGS 5.6 included
 
 Version 6.4 (2005 Oct 15)
 - GTKLIB and Vim build on IA64
 - colors in terminal mode
 - syntax highlighting in terminal mode
@@ -804,10 +924,11 @@ Version 4.5 (1996 Dec 16)
 
 10. Authors						*vms-authors*
 
 OpenVMS documentation and executables are maintained by:
 Zoltan Arpadffy <arpadffy@polarhome.com>
+OpenVMS Vim page: http://www.polarhome.com/vim/
 
 This document uses parts and remarks from earlier authors and contributors
 of OS_VMS.TXT:
 	Charles E. Campbell, Jr. <cec@gryphon.gsfc.nasa.gov>
 	Bruce Hunsaker <BNHunsaker@chq.byu.edu>
--- vim72.orig/src/Make_vms.mms
+++ vim72/src/Make_vms.mms
@@ -1,10 +1,10 @@
 #
 # Makefile for Vim on OpenVMS
 #
 # Maintainer:   Zoltan Arpadffy <arpadffy@polarhome.com>
-# Last change:  2007 Oct 22
+# Last change:  2008 Aug 16
 #
 # This has script been tested on VMS 6.2 to 8.2 on DEC Alpha, VAX and IA64
 # with MMS and MMK
 #
 # The following could be built:
@@ -34,11 +34,11 @@ DECC = YES
 # SMALL  - Few features enabled, as basic as possible
 # NORMAL - A default selection of features enabled
 # BIG    - Many features enabled, as rich as possible. (default)
 # HUGE   - All possible featues enabled.
 # Please select one of these alternatives above.
-MODEL = BIG
+MODEL = HUGE
 
 # GUI or terminal mode executable.
 # Comment out if you want just the character terminal mode only.
 # GUI with Motif
 GUI = YES
--- vim72.orig/src/os_vms_conf.h
+++ vim72/src/os_vms_conf.h
@@ -112,10 +112,12 @@
 #define	HAVE_ERRNO_H
 #define HAVE_OPENDIR
 #define HAVE_PUTENV
 #define HAVE_SETENV
 #define HAVE_SETJMP_H
+#define HAVE_MATH_H
+#define HAVE_FLOAT_FUNCS
 
 #undef	HAVE_DIRENT_H
 #undef	HAVE_SYS_NDIR_H
 #undef	HAVE_SYS_DIR_H
 #undef	HAVE_NDIR_H
--- vim72.orig/src/testdir/Make_vms.mms
+++ vim72/src/testdir/Make_vms.mms
@@ -2,13 +2,13 @@
 # Makefile to run all tests for Vim on VMS
 #
 # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
 #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
 #
-# Last change:  2008 Jun 19
+# Last change:  2009 Sep 11
 #
-# This has been tested on VMS 6.2 to 7.2 on DEC Alpha and VAX.
+# This has been tested on VMS 6.2 to 8.3 on DEC Alpha, VAX and IA64.
 # Edit the lines in the Configuration section below to select.
 #
 # Execute with:
 #		mms/descrip=Make_vms.mms
 # Cleanup with:
@@ -30,10 +30,19 @@
 # Comment out if you want to run Unix specific tests as well, but please
 # be aware, that on OpenVMS will fail, because of cat, rm, etc commands
 # and directory handling.
 # WANT_UNIX = YES
 
+# Comment out if you want to run Win32 specific tests as well, but please
+# be aware, that on OpenVMS will fail, because of cat, rm, etc commands
+# and directory handling.
+# WANT_WIN = YES
+
+# Comment out if you want to run spell checker tests.
+# They fail because VMS does not support file names.
+# WANT_SPELL = YES
+
 # Comment out if you have gzip on your system
 # HAVE_GZIP = YES
 
 # Comment out if you have GNU compatible diff on your system
 # HAVE_GDIFF = YES
@@ -51,25 +60,34 @@ VIMPROG = <->vim.exe
 SCRIPT = test1.out  test2.out  test3.out  test4.out  test5.out  \
 	 test6.out  test7.out  test8.out  test9.out  test10a.out\
 	 test13.out test14.out test15.out test17.out \
 	 test18.out test19.out test20.out test21.out test22.out \
 	 test23.out test24.out test26.out \
-	 test28.out test29.out test31.out test32.out \
+	 test28.out test29.out test30.out test31.out test32.out \
 	 test33.out test34.out test35.out test36.out test37.out \
 	 test38.out test39.out test40.out test41.out test42.out \
 	 test43.out test44.out test45.out test46.out \
 	 test48.out test51.out test53.out test54.out test55.out \
-	 test56.out test57.out test58.out test59.out test60.out \
-	 test61.out test62.out test63.out test64.out test65.out
+	 test56.out test57.out test60.out \
+	 test61.out test62.out test63.out test64.out test65.out \
+	 test66.out test67.out test68.out test69.out
 
 .IFDEF WANT_GUI
 SCRIPT_GUI = test16.out
 GUI_OPTION = -g
 .ENDIF
 
 .IFDEF WANT_UNIX
-SCRIPT_UNIX = test10.out test12.out test25.out test27.out test30.out test49.out
+SCRIPT_UNIX = test10.out test12.out test25.out test27.out test49.out
+.ENDIF
+
+.IFDEF WANT_WIN
+SCRIPT_WIN = test50.out test52.out
+.ENDIF
+
+.IFDEF WANT_SPELL
+SCRIPT_SPELL = test58.out test59.out
 .ENDIF
 
 .IFDEF HAVE_GZIP
 SCRIPT_GZIP = test11.out
 .ENDIF
@@ -82,15 +100,15 @@ SCRIPT_GDIFF = test47.out
 	-@ write sys$output " "
 	-@ write sys$output "-----------------------------------------------"
 	-@ write sys$output "                "$*" "
 	-@ write sys$output "-----------------------------------------------"
 	-@ create/term/wait mcr $(VIMPROG) $(GUI_OPTION) -u vms.vim --noplugin -s dotest.in $*.in
-	-@ if "''F$SEARCH("test.out.*")'" .NES. "" then differences test.out $*.ok;
+	-@ if "''F$SEARCH("test.out.*")'" .NES. "" then differences /par test.out $*.ok;
 	-@ if "''F$SEARCH("test.out.*")'" .NES. "" then rename test.out $*.out
 	-@ if "''F$SEARCH("Xdotest.*")'"  .NES. "" then delete/noconfirm/nolog Xdotest.*.*
 
-all : clean nolog $(SCRIPT) $(SCRIPT_GUI) $(SCRIPT_UNIX) $(SCRIPT_GZIP) $(SCRIPT_GDIFF)
+all : clean nolog $(SCRIPT) $(SCRIPT_GUI) $(SCRIPT_UNIX) $(SCRIPT_WIN) $(SCRIPT_SPELL) $(SCRIPT_GZIP) $(SCRIPT_GDIFF)
 	-@ write sys$output " "
 	-@ write sys$output "-----------------------------------------------"
 	-@ write sys$output "                All done"
 	-@ write sys$output "-----------------------------------------------"
 	-@ deassign sys$output
@@ -111,16 +129,26 @@ nolog :
 	-@ write sys$output "                Test results:"
 	-@ write sys$output "-----------------------------------------------"
 	-@ write sys$output "MAKE_VMS.MMS options:"
 	-@ write sys$output "   WANT_GUI  = ""$(WANT_GUI)"" "
 	-@ write sys$output "   WANT_UNIX = ""$(WANT_UNIX)"" "
+	-@ write sys$output "   WANT_WIN  = ""$(WANT_WIN)"" "
+	-@ write sys$output "   WANT_SPELL= ""$(WANT_SPELL)"" "
 	-@ write sys$output "   HAVE_GZIP = ""$(HAVE_GZIP)"" "
 	-@ write sys$output "   HAVE_GDIFF= ""$(HAVE_GDIFF)"" "
 	-@ write sys$output "Default vimrc file is VMS.VIM:
 	-@ write sys$output "-----------------------------------------------"
 	-@ type VMS.VIM
 
 clean :
 	-@ if "''F$SEARCH("*.out")'"     .NES. "" then delete/noconfirm/nolog *.out.*
 	-@ if "''F$SEARCH("test.log")'"  .NES. "" then delete/noconfirm/nolog test.log.*
+	-@ if "''F$SEARCH("test.ok")'"   .NES. "" then delete/noconfirm/nolog test.ok.*
 	-@ if "''F$SEARCH("Xdotest.*")'" .NES. "" then delete/noconfirm/nolog Xdotest.*.*
 	-@ if "''F$SEARCH("*.*_sw*")'"   .NES. "" then delete/noconfirm/nolog *.*_sw*.*
+	-@ if "''F$SEARCH("*.failed")'"  .NES. "" then delete/noconfirm/nolog *.failed.*
+	-@ if "''F$SEARCH("*.rej")'"     .NES. "" then delete/noconfirm/nolog *.rej.*
+	-@ if "''F$SEARCH("tiny.vim")'"  .NES. "" then delete/noconfirm/nolog tiny.vim.*
+	-@ if "''F$SEARCH("small.vim")'" .NES. "" then delete/noconfirm/nolog small.vim.*
+	-@ if "''F$SEARCH("mbyte.vim")'" .NES. "" then delete/noconfirm/nolog mbyte.vim.*
+	-@ if "''F$SEARCH("viminfo.*")'" .NES. "" then delete/noconfirm/nolog viminfo.*.*
+
--- vim72.orig/src/testdir/test30.in
+++ vim72/src/testdir/test30.in
@@ -22,14 +22,21 @@ STARTTEST
 :set bin noeol
 :$w! XXMac
 :set nobin eol
 :bwipe XXUnix XXDos XXMac
 :" create mixed format files
-:!cat XXUnix XXDos >XXUxDs
-:!cat XXUnix XXMac >XXUxMac
-:!cat XXDos XXMac >XXDosMac
-:!cat XXUnix XXDos XXMac >XXUxDsMc
+:if has("vms")
+: !copy XXUnix,XXDos XXUxDs.
+: !copy XXUnix,XXMac XXUxMac.
+: !copy XXDos,XXMac  XXDosMac.
+: !copy XXUnix,XXDos,XXMac XXUxDsMc.
+:else
+: !cat XXUnix XXDos >XXUxDs
+: !cat XXUnix XXMac >XXUxMac
+: !cat XXDos XXMac >XXDosMac
+: !cat XXUnix XXDos XXMac >XXUxDsMc
+:endif
 :"
 :" try reading and writing with 'fileformats' empty
 :set fileformat=unix
 :e! XXUnix
 :w! test.out
--- vim72.orig/src/testdir/test54.in
+++ vim72/src/testdir/test54.in
@@ -1,12 +1,17 @@
 Some tests for buffer-local autocommands
 
 STARTTEST
 :so small.vim
 :e xx
-:!rm -f test.out
-:au BufLeave <buffer> :!echo buffer-local autommand in %>> test.out
+:if has("vms")
+: !del test.out.*
+: au BufLeave <buffer> :!write sys$output "buffer-local autommand in %" > test.out
+:else
+: !rm -f test.out
+: au BufLeave <buffer> :!echo buffer-local autommand in %>> test.out
+:endif
 :e somefile           " here, autocommand for xx shall write test.out 
 :                     " but autocommand shall not apply to buffer named <buffer>
 :bwipe xx             " here, autocommand shall be auto-deleted
 :e xx                 " nothing shall be written
 :e somefile           " nothing shall be written
--- vim72.orig/src/buffer.c
+++ vim72/src/buffer.c
@@ -31,21 +31,22 @@
 static char_u	*buflist_match __ARGS((regprog_T *prog, buf_T *buf));
 # define HAVE_BUFLIST_MATCH
 static char_u	*fname_match __ARGS((regprog_T *prog, char_u *name));
 #endif
 static void	buflist_setfpos __ARGS((buf_T *buf, win_T *win, linenr_T lnum, colnr_T col, int copy_options));
-static wininfo_T *find_wininfo __ARGS((buf_T *buf));
+static wininfo_T *find_wininfo __ARGS((buf_T *buf, int skip_diff_buffer));
 #ifdef UNIX
 static buf_T	*buflist_findname_stat __ARGS((char_u *ffname, struct stat *st));
 static int	otherfile_buf __ARGS((buf_T *buf, char_u *ffname, struct stat *stp));
 static int	buf_same_ino __ARGS((buf_T *buf, struct stat *stp));
 #else
 static int	otherfile_buf __ARGS((buf_T *buf, char_u *ffname));
 #endif
 #ifdef FEAT_TITLE
 static int	ti_change __ARGS((char_u *str, char_u **last));
 #endif
+static int	append_arg_number __ARGS((win_T *wp, char_u *buf, int buflen, int add_file));
 static void	free_buffer __ARGS((buf_T *));
 static void	free_buffer_stuff __ARGS((buf_T *buf, int free_options));
 static void	clear_wininfo __ARGS((buf_T *buf));
 
 #ifdef UNIX
@@ -112,11 +113,11 @@ open_buffer(read_stdin, eap)
     old_curbuf = curbuf;
     modified_was_set = FALSE;
 #endif
 
     /* mark cursor position as being invalid */
-    changed_line_abv_curs();
+    curwin->w_valid = 0;
 
     if (curbuf->b_ffname != NULL
 #ifdef FEAT_NETBEANS_INTG
 	    && netbeansReadFile
 #endif
@@ -312,11 +313,11 @@ close_buffer(win, buf, action)
     buf_T	*buf;
     int		action;
 {
 #ifdef FEAT_AUTOCMD
     int		is_curbuf;
-    int		nwindows = buf->b_nwindows;
+    int		nwindows;
 #endif
     int		unload_buf = (action != 0);
     int		del_buf = (action == DOBUF_DEL || action == DOBUF_WIPE);
     int		wipe_buf = (action == DOBUF_WIPE);
 
@@ -435,14 +436,10 @@ close_buffer(win, buf, action)
      */
     if (buf == curbuf && !is_curbuf)
 	return;
 #endif
 
-#ifdef FEAT_NETBEANS_INTG
-    if (usingNetbeans)
-	netbeans_file_closed(buf);
-#endif
     /* Change directories when the 'acd' option is set. */
     DO_AUTOCHDIR
 
     /*
      * Remove the buffer from the list.
@@ -513,16 +510,15 @@ buf_clear_file(buf)
 
 /*
  * buf_freeall() - free all things allocated for a buffer that are related to
  * the file.
  */
-/*ARGSUSED*/
     void
 buf_freeall(buf, del_buf, wipe_buf)
     buf_T	*buf;
-    int		del_buf;	/* buffer is going to be deleted */
-    int		wipe_buf;	/* buffer is going to be wiped out */
+    int		del_buf UNUSED;	    /* buffer is going to be deleted */
+    int		wipe_buf UNUSED;    /* buffer is going to be wiped out */
 {
 #ifdef FEAT_AUTOCMD
     int		is_curbuf = (buf == curbuf);
 
     apply_autocmds(EVENT_BUFUNLOAD, buf->b_fname, buf->b_fname, FALSE, buf);
@@ -637,18 +633,25 @@ free_buffer_stuff(buf, free_options)
     uc_clear(&buf->b_ucmds);		/* clear local user commands */
 #endif
 #ifdef FEAT_SIGNS
     buf_delete_signs(buf);		/* delete any signs */
 #endif
+#ifdef FEAT_NETBEANS_INTG
+    if (usingNetbeans)
+        netbeans_file_killed(buf);
+#endif
 #ifdef FEAT_LOCALMAP
     map_clear_int(buf, MAP_ALL_MODES, TRUE, FALSE);  /* clear local mappings */
     map_clear_int(buf, MAP_ALL_MODES, TRUE, TRUE);   /* clear local abbrevs */
 #endif
 #ifdef FEAT_MBYTE
     vim_free(buf->b_start_fenc);
     buf->b_start_fenc = NULL;
 #endif
+#ifdef FEAT_SPELL
+    ga_clear(&buf->b_langp);
+#endif
 }
 
 /*
  * Free the b_wininfo list for buffer "buf".
  */
@@ -810,13 +813,10 @@ do_bufdel(command, arg, addr_count, star
     int		deleted = 0;	/* number of buffers deleted */
     char_u	*errormsg = NULL; /* return value */
     int		bnr;		/* buffer number */
     char_u	*p;
 
-#ifdef FEAT_NETBEANS_INTG
-    netbeansCloseFile = 1;
-#endif
     if (addr_count == 0)
     {
 	(void)do_buffer(command, DOBUF_CURRENT, FORWARD, 0, forceit);
     }
     else
@@ -907,13 +907,10 @@ do_bufdel(command, arg, addr_count, star
 		    smsg((char_u *)_("%d buffers wiped out"), deleted);
 	    }
 	}
     }
 
-#ifdef FEAT_NETBEANS_INTG
-    netbeansCloseFile = 0;
-#endif
 
     return errormsg;
 }
 
 /*
@@ -1088,11 +1085,11 @@ do_buffer(action, start, dir, count, for
 #ifdef FEAT_WINDOWS
 	    close_windows(buf, TRUE);
 #endif
 	    setpcmark();
 	    retval = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE,
-						  forceit ? ECMD_FORCEIT : 0);
+					  forceit ? ECMD_FORCEIT : 0, curwin);
 
 	    /*
 	     * do_ecmd() may create a new buffer, then we have to delete
 	     * the old one.  But do_ecmd() may have done that already, check
 	     * if the buffer still exists.
@@ -1235,11 +1232,11 @@ do_buffer(action, start, dir, count, for
 # ifdef FEAT_WINDOWS
 	/* If 'switchbuf' contains "useopen": jump to first window containing
 	 * "buf" if one exists */
 	if ((swb_flags & SWB_USEOPEN) && buf_jump_open_win(buf))
 	    return OK;
-	/* If 'switchbuf' contians "usetab": jump to first window in any tab
+	/* If 'switchbuf' contains "usetab": jump to first window in any tab
 	 * page containing "buf" if one exists */
 	if ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf))
 	    return OK;
 	if (win_split(0, 0) == FAIL)
 # endif
@@ -1311,11 +1308,11 @@ set_curbuf(buf, action)
 						     || action == DOBUF_WIPE);
 
     setpcmark();
     if (!cmdmod.keepalt)
 	curwin->w_alt_fnum = curbuf->b_fnum; /* remember alternate file */
-    buflist_altfpos();			 /* remember curpos */
+    buflist_altfpos(curwin);			 /* remember curpos */
 
 #ifdef FEAT_VISUAL
     /* Don't restart Select mode after switching to another buffer. */
     VIsual_reselect = FALSE;
 #endif
@@ -1349,15 +1346,16 @@ set_curbuf(buf, action)
 			&& !P_HID(prevbuf)
 			&& !bufIsChanged(prevbuf)) ? DOBUF_UNLOAD : 0);
 	}
     }
 #ifdef FEAT_AUTOCMD
+    /* An autocommand may have deleted "buf", already entered it (e.g., when
+     * it did ":bunload") or aborted the script processing! */
 # ifdef FEAT_EVAL
-    /* An autocommand may have deleted buf or aborted the script processing! */
-    if (buf_valid(buf) && !aborting())
+    if (buf_valid(buf) && buf != curbuf && !aborting())
 # else
-    if (buf_valid(buf))	    /* an autocommand may have deleted buf! */
+    if (buf_valid(buf) && buf != curbuf)
 # endif
 #endif
 	enter_buffer(buf);
 }
 
@@ -1395,10 +1393,16 @@ enter_buffer(buf)
     curwin->w_cursor.col = 0;
 #ifdef FEAT_VIRTUALEDIT
     curwin->w_cursor.coladd = 0;
 #endif
     curwin->w_set_curswant = TRUE;
+#ifdef FEAT_AUTOCMD
+    curwin->w_topline_was_set = FALSE;
+#endif
+
+    /* mark cursor position as being invalid */
+    curwin->w_valid = 0;
 
     /* Make sure the buffer is loaded. */
     if (curbuf->b_ml.ml_mfp == NULL)	/* need to load the file */
     {
 #ifdef FEAT_AUTOCMD
@@ -1434,11 +1438,12 @@ enter_buffer(buf)
     check_arg_idx(curwin);		/* check for valid arg_idx */
 #ifdef FEAT_TITLE
     maketitle();
 #endif
 #ifdef FEAT_AUTOCMD
-    if (curwin->w_topline == 1)		/* when autocmds didn't change it */
+	/* when autocmds didn't change it */
+    if (curwin->w_topline == 1 && !curwin->w_topline_was_set)
 #endif
 	scroll_cursor_halfway(FALSE);	/* redisplay at correct position */
 
 #ifdef FEAT_NETBEANS_INTG
     /* Send fileOpened event because we've changed buffers. */
@@ -1449,17 +1454,17 @@ enter_buffer(buf)
     /* Change directories when the 'acd' option is set. */
     DO_AUTOCHDIR
 
 #ifdef FEAT_KEYMAP
     if (curbuf->b_kmap_state & KEYMAP_INIT)
-	keymap_init();
+	(void)keymap_init();
 #endif
 #ifdef FEAT_SPELL
     /* May need to set the spell language.  Can only do this after the buffer
      * has been properly setup. */
     if (!curbuf->b_help && curwin->w_p_spell && *curbuf->b_p_spl != NUL)
-	did_set_spelllang(curbuf);
+	(void)did_set_spelllang(curbuf);
 #endif
 
     redraw_later(NOT_VALID);
 }
 
@@ -1673,13 +1678,14 @@ buflist_new(ffname, sfname, lnum, flags)
 #endif
 
     buf->b_fname = buf->b_sfname;
 #ifdef UNIX
     if (st.st_dev == (dev_T)-1)
-	buf->b_dev = -1;
+	buf->b_dev_valid = FALSE;
     else
     {
+	buf->b_dev_valid = TRUE;
 	buf->b_dev = st.st_dev;
 	buf->b_ino = st.st_ino;
     }
 #endif
     buf->b_u_synced = TRUE;
@@ -2020,17 +2026,16 @@ buflist_findname_stat(ffname, stp)
 /*
  * Find file in buffer list by a regexp pattern.
  * Return fnum of the found buffer.
  * Return < 0 for error.
  */
-/*ARGSUSED*/
     int
 buflist_findpat(pattern, pattern_end, unlisted, diffmode)
     char_u	*pattern;
     char_u	*pattern_end;	/* pointer to first char after pattern */
     int		unlisted;	/* find unlisted buffers */
-    int		diffmode;	/* find diff-mode buffers only */
+    int		diffmode UNUSED; /* find diff-mode buffers only */
 {
     buf_T	*buf;
     regprog_T	*prog;
     int		match = -1;
     int		find_listed;
@@ -2398,26 +2403,73 @@ buflist_setfpos(buf, win, lnum, col, cop
 	wip->wi_next->wi_prev = wip;
 
     return;
 }
 
+#ifdef FEAT_DIFF
+static int wininfo_other_tab_diff __ARGS((wininfo_T *wip));
+
+/*
+ * Return TRUE when "wip" has 'diff' set and the diff is only for another tab
+ * page.  That's because a diff is local to a tab page.
+ */
+    static int
+wininfo_other_tab_diff(wip)
+    wininfo_T	*wip;
+{
+    win_T	*wp;
+
+    if (wip->wi_opt.wo_diff)
+    {
+	for (wp = firstwin; wp != NULL; wp = wp->w_next)
+	    /* return FALSE when it's a window in the current tab page, thus
+	     * the buffer was in diff mode here */
+	    if (wip->wi_win == wp)
+		return FALSE;
+	return TRUE;
+    }
+    return FALSE;
+}
+#endif
+
 /*
  * Find info for the current window in buffer "buf".
  * If not found, return the info for the most recently used window.
+ * When "skip_diff_buffer" is TRUE avoid windows with 'diff' set that is in
+ * another tab page.
  * Returns NULL when there isn't any info.
  */
     static wininfo_T *
-find_wininfo(buf)
+find_wininfo(buf, skip_diff_buffer)
     buf_T	*buf;
+    int		skip_diff_buffer UNUSED;
 {
     wininfo_T	*wip;
 
     for (wip = buf->b_wininfo; wip != NULL; wip = wip->wi_next)
-	if (wip->wi_win == curwin)
+	if (wip->wi_win == curwin
+#ifdef FEAT_DIFF
+		&& (!skip_diff_buffer || !wininfo_other_tab_diff(wip))
+#endif
+	   )
 	    break;
-    if (wip == NULL)	/* if no fpos for curwin, use the first in the list */
-	wip = buf->b_wininfo;
+
+    /* If no wininfo for curwin, use the first in the list (that doesn't have
+     * 'diff' set and is in another tab page). */
+    if (wip == NULL)
+    {
+#ifdef FEAT_DIFF
+	if (skip_diff_buffer)
+	{
+	    for (wip = buf->b_wininfo; wip != NULL; wip = wip->wi_next)
+		if (!wininfo_other_tab_diff(wip))
+		    break;
+	}
+	else
+#endif
+	    wip = buf->b_wininfo;
+    }
     return wip;
 }
 
 /*
  * Reset the local window options to the values last used in this window.
@@ -2434,11 +2486,11 @@ get_winopts(buf)
     clear_winopt(&curwin->w_onebuf_opt);
 #ifdef FEAT_FOLDING
     clearFolding(curwin);
 #endif
 
-    wip = find_wininfo(buf);
+    wip = find_wininfo(buf, TRUE);
     if (wip != NULL && wip->wi_optset)
     {
 	copy_winopt(&wip->wi_opt, &curwin->w_onebuf_opt);
 #ifdef FEAT_FOLDING
 	curwin->w_fold_manual = wip->wi_fold_manual;
@@ -2464,13 +2516,13 @@ get_winopts(buf)
     pos_T *
 buflist_findfpos(buf)
     buf_T	*buf;
 {
     wininfo_T	*wip;
-    static pos_T no_position = {1, 0};
+    static pos_T no_position = INIT_POS_T(1, 0, 0);
 
-    wip = find_wininfo(buf);
+    wip = find_wininfo(buf, FALSE);
     if (wip != NULL)
 	return &(wip->wi_fpos);
     else
 	return &no_position;
 }
@@ -2487,11 +2539,10 @@ buflist_findlnum(buf)
 
 #if defined(FEAT_LISTCMDS) || defined(PROTO)
 /*
  * List all know file names (for :files and :buffers command).
  */
-/*ARGSUSED*/
     void
 buflist_list(eap)
     exarg_T	*eap;
 {
     buf_T	*buf;
@@ -2525,12 +2576,12 @@ buflist_list(eap)
 	i = 40 - vim_strsize(IObuff);
 	do
 	{
 	    IObuff[len++] = ' ';
 	} while (--i > 0 && len < IOSIZE - 18);
-	vim_snprintf((char *)IObuff + len, IOSIZE - len, _("line %ld"),
-		buf == curbuf ? curwin->w_cursor.lnum
+	vim_snprintf((char *)IObuff + len, (size_t)(IOSIZE - len),
+		_("line %ld"), buf == curbuf ? curwin->w_cursor.lnum
 					       : (long)buflist_findlnum(buf));
 	msg_outtrans(IObuff);
 	out_flush();	    /* output one line at a time */
 	ui_breakcheck();
     }
@@ -2640,13 +2691,14 @@ setfname(buf, ffname, sfname, message)
 	buf->b_sfname = sfname;
     }
     buf->b_fname = buf->b_sfname;
 #ifdef UNIX
     if (st.st_dev == (dev_T)-1)
-	buf->b_dev = -1;
+	buf->b_dev_valid = FALSE;
     else
     {
+	buf->b_dev_valid = TRUE;
 	buf->b_dev = st.st_dev;
 	buf->b_ino = st.st_ino;
     }
 #endif
 
@@ -2787,18 +2839,18 @@ buflist_slash_adjust()
     }
 }
 #endif
 
 /*
- * Set alternate cursor position for current window.
+ * Set alternate cursor position for the current buffer and window "win".
  * Also save the local window option values.
  */
     void
-buflist_altfpos()
+buflist_altfpos(win)
+    win_T *win;
 {
-    buflist_setfpos(curbuf, curwin, curwin->w_cursor.lnum,
-						  curwin->w_cursor.col, TRUE);
+    buflist_setfpos(curbuf, win, win->w_cursor.lnum, win->w_cursor.col, TRUE);
 }
 
 /*
  * Return TRUE if 'ffname' is not the same file as current file.
  * Fname must have a full path (expanded by mch_FullName()).
@@ -2836,11 +2888,11 @@ otherfile_buf(buf, ffname
 	struct stat	st;
 
 	/* If no struct stat given, get it now */
 	if (stp == NULL)
 	{
-	    if (buf->b_dev < 0 || mch_stat((char *)ffname, &st) < 0)
+	    if (!buf->b_dev_valid || mch_stat((char *)ffname, &st) < 0)
 		st.st_dev = (dev_T)-1;
 	    stp = &st;
 	}
 	/* Use dev/ino to check if the files are the same, even when the names
 	 * are different (possible with links).  Still need to compare the
@@ -2873,26 +2925,27 @@ buf_setino(buf)
 {
     struct stat	st;
 
     if (buf->b_fname != NULL && mch_stat((char *)buf->b_fname, &st) >= 0)
     {
+	buf->b_dev_valid = TRUE;
 	buf->b_dev = st.st_dev;
 	buf->b_ino = st.st_ino;
     }
     else
-	buf->b_dev = -1;
+	buf->b_dev_valid = FALSE;
 }
 
 /*
  * Return TRUE if dev/ino in buffer "buf" matches with "stp".
  */
     static int
 buf_same_ino(buf, stp)
     buf_T	*buf;
     struct stat *stp;
 {
-    return (buf->b_dev >= 0
+    return (buf->b_dev_valid
 	    && stp->st_dev == buf->b_dev
 	    && stp->st_ino == buf->b_ino);
 }
 #endif
 
@@ -2915,11 +2968,11 @@ fileinfo(fullname, shorthelp, dont_trunc
     if (buffer == NULL)
 	return;
 
     if (fullname > 1)	    /* 2 CTRL-G: include buffer number */
     {
-	sprintf((char *)buffer, "buf %d: ", curbuf->b_fnum);
+	vim_snprintf((char *)buffer, IOSIZE, "buf %d: ", curbuf->b_fnum);
 	p = buffer + STRLEN(buffer);
     }
     else
 	p = buffer;
 
@@ -2989,15 +3042,16 @@ fileinfo(fullname, shorthelp, dont_trunc
 		_("line %ld of %ld --%d%%-- col "),
 		(long)curwin->w_cursor.lnum,
 		(long)curbuf->b_ml.ml_line_count,
 		n);
 	validate_virtcol();
-	col_print(buffer + STRLEN(buffer),
+	len = STRLEN(buffer);
+	col_print(buffer + len, IOSIZE - len,
 		   (int)curwin->w_cursor.col + 1, (int)curwin->w_virtcol + 1);
     }
 
-    (void)append_arg_number(curwin, buffer, !shortmess(SHM_FILE), IOSIZE);
+    (void)append_arg_number(curwin, buffer, IOSIZE, !shortmess(SHM_FILE));
 
     if (dont_truncate)
     {
 	/* Temporarily set msg_scroll to avoid the message being truncated.
 	 * First call msg_start() to get the message in the right place. */
@@ -3021,19 +3075,20 @@ fileinfo(fullname, shorthelp, dont_trunc
 
     vim_free(buffer);
 }
 
     void
-col_print(buf, col, vcol)
+col_print(buf, buflen, col, vcol)
     char_u  *buf;
+    size_t  buflen;
     int	    col;
     int	    vcol;
 {
     if (col == vcol)
-	sprintf((char *)buf, "%d", col);
+	vim_snprintf((char *)buf, buflen, "%d", col);
     else
-	sprintf((char *)buf, "%d-%d", col, vcol);
+	vim_snprintf((char *)buf, buflen, "%d-%d", col, vcol);
 }
 
 #if defined(FEAT_TITLE) || defined(PROTO)
 /*
  * put file name in title bar of window and in icon title
@@ -3142,22 +3197,22 @@ maketitle()
 		/* remove the file name */
 		p = gettail_sep(buf + off);
 		if (p == buf + off)
 		    /* must be a help buffer */
 		    vim_strncpy(buf + off, (char_u *)_("help"),
-							    IOSIZE - off - 1);
+						  (size_t)(IOSIZE - off - 1));
 		else
 		    *p = NUL;
 
 		/* translate unprintable chars */
 		p = transstr(buf + off);
-		vim_strncpy(buf + off, p, IOSIZE - off - 1);
+		vim_strncpy(buf + off, p, (size_t)(IOSIZE - off - 1));
 		vim_free(p);
 		STRCAT(buf, ")");
 	    }
 
-	    append_arg_number(curwin, buf, FALSE, IOSIZE);
+	    append_arg_number(curwin, buf, IOSIZE, FALSE);
 
 #if defined(FEAT_CLIENTSERVER)
 	    if (serverName != NULL)
 	    {
 		STRCAT(buf, " - ");
@@ -3290,18 +3345,17 @@ free_titles()
  * Item: %-<minwid>.<maxwid><itemch> All but <itemch> are optional
  *
  * If maxwidth is not zero, the string will be filled at any middle marker
  * or truncated if too long, fillchar is used for all whitespace.
  */
-/*ARGSUSED*/
     int
 build_stl_str_hl(wp, out, outlen, fmt, use_sandbox, fillchar, maxwidth, hltab, tabtab)
     win_T	*wp;
     char_u	*out;		/* buffer to write into != NameBuff */
     size_t	outlen;		/* length of out[] */
     char_u	*fmt;
-    int		use_sandbox;	/* "fmt" was set insecurely, use sandbox */
+    int		use_sandbox UNUSED; /* "fmt" was set insecurely, use sandbox */
     int		fillchar;
     int		maxwidth;
     struct stl_hlrec *hltab;	/* return: HL attributes (can be NULL) */
     struct stl_hlrec *tabtab;	/* return: tab page nrs (can be NULL) */
 {
@@ -3468,11 +3522,11 @@ build_stl_str_hl(wp, out, outlen, fmt, u
 		else
 #endif
 		    n = (long)(p - t) - item[groupitem[groupdepth]].maxwid + 1;
 
 		*t = '<';
-		mch_memmove(t + 1, t + n, p - (t + n));
+		mch_memmove(t + 1, t + n, (size_t)(p - (t + n)));
 		p = p - n + 1;
 #ifdef FEAT_MBYTE
 		/* Fill up space left over by half a double-wide char. */
 		while (++l < item[groupitem[groupdepth]].minwid)
 		    *p++ = fillchar;
@@ -3498,11 +3552,11 @@ build_stl_str_hl(wp, out, outlen, fmt, u
 			*p++ = fillchar;
 		}
 		else
 		{
 		    /* fill by inserting characters */
-		    mch_memmove(t + n - l, t, p - t);
+		    mch_memmove(t + n - l, t, (size_t)(p - t));
 		    l = n - l;
 		    if (p + l >= out + outlen)
 			l = (long)((out + outlen) - p - 1);
 		    p += l;
 		    for (n = groupitem[groupdepth] + 1; n < curitem; n++)
@@ -3634,11 +3688,11 @@ build_stl_str_hl(wp, out, outlen, fmt, u
 	    s++;
 	    *p = 0;
 	    p = t;
 
 #ifdef FEAT_EVAL
-	    sprintf((char *)tmp, "%d", curbuf->b_fnum);
+	    vim_snprintf((char *)tmp, sizeof(tmp), "%d", curbuf->b_fnum);
 	    set_internal_string_var((char_u *)"actual_curbuf", tmp);
 
 	    o_curbuf = curbuf;
 	    o_curwin = curwin;
 	    curwin = wp;
@@ -3701,17 +3755,17 @@ build_stl_str_hl(wp, out, outlen, fmt, u
 			(long)wp->w_buffer->b_ml.ml_line_count);
 	    break;
 
 	case STL_ALTPERCENT:
 	    str = tmp;
-	    get_rel_pos(wp, str);
+	    get_rel_pos(wp, str, TMPLEN);
 	    break;
 
 	case STL_ARGLISTSTAT:
 	    fillable = FALSE;
 	    tmp[0] = 0;
-	    if (append_arg_number(wp, tmp, FALSE, (int)sizeof(tmp)))
+	    if (append_arg_number(wp, tmp, (int)sizeof(tmp), FALSE))
 		str = tmp;
 	    break;
 
 	case STL_KEYMAP:
 	    fillable = FALSE;
@@ -3742,11 +3796,11 @@ build_stl_str_hl(wp, out, outlen, fmt, u
 	    break;
 
 	case STL_BYTEVAL_X:
 	    base = 'X';
 	case STL_BYTEVAL:
-	    if (wp->w_cursor.col > STRLEN(linecont))
+	    if (wp->w_cursor.col > (colnr_T)STRLEN(linecont))
 		num = 0;
 	    else
 	    {
 #ifdef FEAT_MBYTE
 		num = (*mb_ptr2char)(linecont + wp->w_cursor.col);
@@ -3915,11 +3969,11 @@ build_stl_str_hl(wp, out, outlen, fmt, u
 	    }
 	    *t++ = '%';
 	    if (zeropad)
 		*t++ = '0';
 	    *t++ = '*';
-	    *t++ = nbase == 16 ? base : (nbase == 8 ? 'o' : 'd');
+	    *t++ = nbase == 16 ? base : (char_u)(nbase == 8 ? 'o' : 'd');
 	    *t = 0;
 
 	    for (n = num, l = 1; n >= nbase; n /= nbase)
 		l++;
 	    if (opt == STL_VIRTCOL_ALT)
@@ -3961,11 +4015,11 @@ build_stl_str_hl(wp, out, outlen, fmt, u
 #endif
 
     width = vim_strsize(out);
     if (maxwidth > 0 && width > maxwidth)
     {
-	/* Result is too long, must trunctate somewhere. */
+	/* Result is too long, must truncate somewhere. */
 	l = 0;
 	if (itemcnt == 0)
 	    s = out;
 	else
 	{
@@ -4108,64 +4162,67 @@ build_stl_str_hl(wp, out, outlen, fmt, u
 #endif /* FEAT_STL_OPT */
 
 #if defined(FEAT_STL_OPT) || defined(FEAT_CMDL_INFO) \
 	    || defined(FEAT_GUI_TABLINE) || defined(PROTO)
 /*
- * Get relative cursor position in window into "str[]", in the form 99%, using
- * "Top", "Bot" or "All" when appropriate.
+ * Get relative cursor position in window into "buf[buflen]", in the form 99%,
+ * using "Top", "Bot" or "All" when appropriate.
  */
     void
-get_rel_pos(wp, str)
+get_rel_pos(wp, buf, buflen)
     win_T	*wp;
-    char_u	*str;
+    char_u	*buf;
+    int		buflen;
 {
     long	above; /* number of lines above window */
     long	below; /* number of lines below window */
 
     above = wp->w_topline - 1;
 #ifdef FEAT_DIFF
     above += diff_check_fill(wp, wp->w_topline) - wp->w_topfill;
 #endif
     below = wp->w_buffer->b_ml.ml_line_count - wp->w_botline + 1;
     if (below <= 0)
-	STRCPY(str, above == 0 ? _("All") : _("Bot"));
+	vim_strncpy(buf, (char_u *)(above == 0 ? _("All") : _("Bot")),
+							(size_t)(buflen - 1));
     else if (above <= 0)
-	STRCPY(str, _("Top"));
+	vim_strncpy(buf, (char_u *)_("Top"), (size_t)(buflen - 1));
     else
-	sprintf((char *)str, "%2d%%", above > 1000000L
+	vim_snprintf((char *)buf, (size_t)buflen, "%2d%%", above > 1000000L
 				    ? (int)(above / ((above + below) / 100L))
 				    : (int)(above * 100L / (above + below)));
 }
 #endif
 
 /*
- * Append (file 2 of 8) to 'buf', if editing more than one file.
+ * Append (file 2 of 8) to "buf[buflen]", if editing more than one file.
  * Return TRUE if it was appended.
  */
-    int
-append_arg_number(wp, buf, add_file, maxlen)
+    static int
+append_arg_number(wp, buf, buflen, add_file)
     win_T	*wp;
     char_u	*buf;
+    int		buflen;
     int		add_file;	/* Add "file" before the arg number */
-    int		maxlen;		/* maximum nr of chars in buf or zero*/
 {
     char_u	*p;
 
     if (ARGCOUNT <= 1)		/* nothing to do */
 	return FALSE;
 
-    p = buf + STRLEN(buf);		/* go to the end of the buffer */
-    if (maxlen && p - buf + 35 >= maxlen) /* getting too long */
+    p = buf + STRLEN(buf);	/* go to the end of the buffer */
+    if (p - buf + 35 >= buflen)	/* getting too long */
 	return FALSE;
     *p++ = ' ';
     *p++ = '(';
     if (add_file)
     {
 	STRCPY(p, "file ");
 	p += 5;
     }
-    sprintf((char *)p, wp->w_arg_idx_invalid ? "(%d) of %d)"
+    vim_snprintf((char *)p, (size_t)(buflen - (p - buf)),
+		wp->w_arg_idx_invalid ? "(%d) of %d)"
 				  : "%d of %d)", wp->w_arg_idx + 1, ARGCOUNT);
     return TRUE;
 }
 
 /*
@@ -4217,14 +4274,13 @@ fix_fname(fname)
 
 /*
  * Make "ffname" a full file name, set "sfname" to "ffname" if not NULL.
  * "ffname" becomes a pointer to allocated memory (or NULL).
  */
-/*ARGSUSED*/
     void
 fname_expand(buf, ffname, sfname)
-    buf_T	*buf;
+    buf_T	*buf UNUSED;
     char_u	**ffname;
     char_u	**sfname;
 {
     if (*ffname == NULL)	/* if no file name given, nothing to do */
 	return;
@@ -4486,11 +4542,11 @@ do_arg_all(count, forceit, keep_tabs)
 	    }
 	    (void)do_ecmd(0, alist_name(&AARGLIST(alist)[i]), NULL, NULL,
 		      ECMD_ONE,
 		      ((P_HID(curwin->w_buffer)
 			   || bufIsChanged(curwin->w_buffer)) ? ECMD_HIDE : 0)
-							       + ECMD_OLDBUF);
+						       + ECMD_OLDBUF, curwin);
 #ifdef FEAT_AUTOCMD
 	    if (use_firstwin)
 		++autocmd_no_leave;
 #endif
 	    use_firstwin = FALSE;
@@ -4944,11 +5000,11 @@ read_viminfo_bufferlist(virp, writing)
 	col = 0;
 	tab = vim_strrchr(xline, '\t');
 	if (tab != NULL)
 	{
 	    *tab++ = '\0';
-	    col = atoi((char *)tab);
+	    col = (colnr_T)atoi((char *)tab);
 	    tab = vim_strrchr(xline, '\t');
 	    if (tab != NULL)
 	    {
 		*tab++ = '\0';
 		lnum = atol((char *)tab);
@@ -4982,19 +5038,21 @@ write_viminfo_bufferlist(fp)
     win_T	*win;
     tabpage_T	*tp;
 #endif
     char_u	*line;
     int		max_buffers;
+    size_t	len;
 
     if (find_viminfo_parameter('%') == NULL)
 	return;
 
     /* Without a number -1 is returned: do all buffers. */
     max_buffers = get_viminfo_parameter('%');
 
     /* Allocate room for the file name, lnum and col. */
-    line = alloc(MAXPATHL + 40);
+#define LINE_BUF_LEN (MAXPATHL + 40)
+    line = alloc(LINE_BUF_LEN);
     if (line == NULL)
 	return;
 
 #ifdef FEAT_WINDOWS
     FOR_ALL_TAB_WINDOWS(tp, win)
@@ -5016,11 +5074,12 @@ write_viminfo_bufferlist(fp)
 
 	if (max_buffers-- == 0)
 	    break;
 	putc('%', fp);
 	home_replace(NULL, buf->b_ffname, line, MAXPATHL, TRUE);
-	sprintf((char *)line + STRLEN(line), "\t%ld\t%d",
+	len = STRLEN(line);
+	vim_snprintf((char *)line + len, len - LINE_BUF_LEN, "\t%ld\t%d",
 			(long)buf->b_last_cursor.lnum,
 			buf->b_last_cursor.col);
 	viminfo_writestring(fp, line);
     }
     vim_free(line);
@@ -5046,11 +5105,12 @@ buf_spname(buf)
 	 * For location list window, w_llist_ref points to the location list.
 	 * For quickfix window, w_llist_ref is NULL.
 	 */
 	FOR_ALL_TAB_WINDOWS(tp, win)
 	    if (win->w_buffer == buf)
-		break;
+		goto win_found;
+win_found:
 	if (win != NULL && win->w_llist_ref != NULL)
 	    return _("[Location List]");
 	else
 	    return _("[Quickfix List]");
     }
@@ -5060,11 +5120,11 @@ buf_spname(buf)
      * contains the name as specified by the user */
     if (bt_nofile(buf))
     {
 	if (buf->b_sfname != NULL)
 	    return (char *)buf->b_sfname;
-	return "[Scratch]";
+	return _("[Scratch]");
     }
 #endif
     if (buf->b_fname == NULL)
 	return _("[No Name]");
     return NULL;
@@ -5173,11 +5233,11 @@ buf_addsign(buf, id, lnum, typenr)
     insert_sign(buf, prev, sign, id, lnum, typenr);
 
     return;
 }
 
-    int
+    linenr_T
 buf_change_sign_type(buf, markId, typenr)
     buf_T	*buf;		/* buffer to store sign in */
     int		markId;		/* sign ID */
     int		typenr;		/* typenr of sign we are adding */
 {
@@ -5190,14 +5250,14 @@ buf_change_sign_type(buf, markId, typenr
 	    sign->typenr = typenr;
 	    return sign->lnum;
 	}
     }
 
-    return 0;
+    return (linenr_T)0;
 }
 
-    int_u
+    int
 buf_getsigntype(buf, lnum, type)
     buf_T	*buf;
     linenr_T	lnum;
     int		type;	/* SIGN_ICON, SIGN_TEXT, SIGN_ANY, SIGN_LINEHL */
 {
@@ -5512,15 +5572,14 @@ buf_contents_changed(buf)
 /*
  * Wipe out a buffer and decrement the last buffer number if it was used for
  * this buffer.  Call this to wipe out a temp buffer that does not contain any
  * marks.
  */
-/*ARGSUSED*/
     void
 wipe_buffer(buf, aucmd)
     buf_T	*buf;
-    int		aucmd;	    /* When TRUE trigger autocommands. */
+    int		aucmd UNUSED;	    /* When TRUE trigger autocommands. */
 {
     if (buf->b_fnum == top_file_num - 1)
 	--top_file_num;
 
 #ifdef FEAT_AUTOCMD
--- vim72.orig/src/if_perl.xs
+++ vim72/src/if_perl.xs
@@ -60,10 +60,15 @@
 #endif
 #if (PERL_REVISION == 5) && (PERL_VERSION >= 9)
 # define PERL589_OR_LATER
 #endif
 
+#if (PERL_REVISION == 5) && ((PERL_VERSION > 10) || \
+    (PERL_VERSION == 10) && (PERL_SUBVERSION >= 1))
+# define PERL5101_OR_LATER
+#endif
+
 #ifndef pTHX
 #    define pTHX void
 #    define pTHX_
 #endif
 
@@ -91,10 +96,13 @@ EXTERN_C void boot_DynaLoader __ARGS((pT
 # define perl_run dll_perl_run
 # define perl_destruct dll_perl_destruct
 # define perl_free dll_perl_free
 # define Perl_get_context dll_Perl_get_context
 # define Perl_croak dll_Perl_croak
+# ifdef PERL5101_OR_LATER
+#  define Perl_croak_xs_usage dll_Perl_croak_xs_usage
+# endif
 # ifndef PROTO
 #  define Perl_croak_nocontext dll_Perl_croak_nocontext
 #  define Perl_call_argv dll_Perl_call_argv
 #  define Perl_call_pv dll_Perl_call_pv
 #  define Perl_eval_sv dll_Perl_eval_sv
@@ -134,10 +142,13 @@ EXTERN_C void boot_DynaLoader __ARGS((pT
 #ifdef PERL589_OR_LATER
 #  define Perl_sv_2iv_flags dll_Perl_sv_2iv_flags
 #  define Perl_newXS_flags dll_Perl_newXS_flags
 #endif
 # define Perl_sv_free dll_Perl_sv_free
+# if (PERL_REVISION == 5) && (PERL_VERSION >= 10)
+#  define Perl_sv_free2 dll_Perl_sv_free2
+# endif
 # define Perl_sv_isa dll_Perl_sv_isa
 # define Perl_sv_magic dll_Perl_sv_magic
 # define Perl_sv_setiv dll_Perl_sv_setiv
 # define Perl_sv_setpv dll_Perl_sv_setpv
 # define Perl_sv_setpvn dll_Perl_sv_setpvn
@@ -161,11 +172,11 @@ EXTERN_C void boot_DynaLoader __ARGS((pT
 # define Perl_Idefgv_ptr dll_Perl_Idefgv_ptr
 # define Perl_Ierrgv_ptr dll_Perl_Ierrgv_ptr
 # define Perl_Isv_yes_ptr dll_Perl_Isv_yes_ptr
 # define boot_DynaLoader dll_boot_DynaLoader
 
-# define Perl_sys_init3 dll_Perl_sys_init3
+# define Perl_sys_init dll_Perl_sys_init
 # define Perl_sys_term dll_Perl_sys_term
 # define Perl_ISv_ptr dll_Perl_ISv_ptr
 # define Perl_Istack_max_ptr dll_Perl_Istack_max_ptr
 # define Perl_Istack_base_ptr dll_Perl_Istack_base_ptr
 # define Perl_Itmps_ix_ptr dll_Perl_Itmps_ix_ptr
@@ -197,10 +208,13 @@ static void (*perl_destruct)(PerlInterpr
 static void (*perl_free)(PerlInterpreter*);
 static int (*perl_run)(PerlInterpreter*);
 static int (*perl_parse)(PerlInterpreter*, XSINIT_t, int, char**, char**);
 static void* (*Perl_get_context)(void);
 static void (*Perl_croak)(pTHX_ const char*, ...);
+#ifdef PERL5101_OR_LATER
+static void (*Perl_croak_xs_usage)(pTHX_ const CV *const, const char *const params);
+#endif
 static void (*Perl_croak_nocontext)(const char*, ...);
 static I32 (*Perl_dowantarray)(pTHX);
 static void (*Perl_free_tmps)(pTHX);
 static HV* (*Perl_gv_stashpv)(pTHX_ const char*, I32);
 static void (*Perl_markstack_grow)(pTHX);
@@ -266,11 +280,12 @@ static GV** (*Perl_Idefgv_ptr)(register
 static GV** (*Perl_Ierrgv_ptr)(register PerlInterpreter*);
 static SV* (*Perl_Isv_yes_ptr)(register PerlInterpreter*);
 static void (*boot_DynaLoader)_((pTHX_ CV*));
 
 #if (PERL_REVISION == 5) && (PERL_VERSION >= 10)
-static void (*Perl_sys_init3)(int* argc, char*** argv, char*** env);
+static void (*Perl_sv_free2)(pTHX_ SV*);
+static void (*Perl_sys_init)(int* argc, char*** argv);
 static void (*Perl_sys_term)(void);
 static SV** (*Perl_ISv_ptr)(register PerlInterpreter*);
 static SV*** (*Perl_Istack_max_ptr)(register PerlInterpreter*);
 static SV*** (*Perl_Istack_base_ptr)(register PerlInterpreter*);
 static XPV** (*Perl_IXpv_ptr)(register PerlInterpreter*);
@@ -300,10 +315,13 @@ static struct {
     {"perl_free", (PERL_PROC*)&perl_free},
     {"perl_run", (PERL_PROC*)&perl_run},
     {"perl_parse", (PERL_PROC*)&perl_parse},
     {"Perl_get_context", (PERL_PROC*)&Perl_get_context},
     {"Perl_croak", (PERL_PROC*)&Perl_croak},
+#ifdef PERL5101_OR_LATER
+    {"Perl_croak_xs_usage", (PERL_PROC*)&Perl_croak_xs_usage},
+#endif
     {"Perl_croak_nocontext", (PERL_PROC*)&Perl_croak_nocontext},
     {"Perl_dowantarray", (PERL_PROC*)&Perl_dowantarray},
     {"Perl_free_tmps", (PERL_PROC*)&Perl_free_tmps},
     {"Perl_gv_stashpv", (PERL_PROC*)&Perl_gv_stashpv},
     {"Perl_markstack_grow", (PERL_PROC*)&Perl_markstack_grow},
@@ -365,11 +383,12 @@ static struct {
     {"Perl_Tmarkstack_max_ptr", (PERL_PROC*)&Perl_Tmarkstack_max_ptr},
     {"Perl_TSv_ptr", (PERL_PROC*)&Perl_TSv_ptr},
     {"Perl_TXpv_ptr", (PERL_PROC*)&Perl_TXpv_ptr},
     {"Perl_Tna_ptr", (PERL_PROC*)&Perl_Tna_ptr},
 #else
-    {"Perl_sys_init3", (PERL_PROC*)&Perl_sys_init3},
+    {"Perl_sv_free2", (PERL_PROC*)&Perl_sv_free2},
+    {"Perl_sys_init", (PERL_PROC*)&Perl_sys_init},
     {"Perl_sys_term", (PERL_PROC*)&Perl_sys_term},
     {"Perl_ISv_ptr", (PERL_PROC*)&Perl_ISv_ptr},
     {"Perl_Istack_sp_ptr", (PERL_PROC*)&Perl_Istack_sp_ptr},
     {"Perl_Iop_ptr", (PERL_PROC*)&Perl_Iop_ptr},
     {"Perl_Istack_base_ptr", (PERL_PROC*)&Perl_Istack_base_ptr},
@@ -453,11 +472,11 @@ perl_init()
     char *bootargs[] = { "VI", NULL };
     int argc = 3;
     static char *argv[] = { "", "-e", "" };
 
 #if (PERL_REVISION == 5) && (PERL_VERSION >= 10)
-    Perl_sys_init3(&argc, (char***)&argv, NULL);
+    Perl_sys_init(&argc, (char***)&argv);
 #endif
     perl_interp = perl_alloc();
     perl_construct(perl_interp);
     perl_parse(perl_interp, xs_init, argc, argv, 0);
     perl_call_argv("VIM::bootstrap", (long)G_DISCARD, bootargs);
@@ -713,13 +732,16 @@ ex_perl(eap)
     }
 
 #ifdef HAVE_SANDBOX
     if (sandbox)
     {
-	if ((safe = perl_get_sv( "VIM::safe", FALSE )) == NULL || !SvTRUE(safe))
+	safe = perl_get_sv( "VIM::safe", FALSE );
+# ifndef MAKE_TEST  /* avoid a warning for unreachable code */
+	if (safe == NULL || !SvTRUE(safe))
 	    EMSG(_("E299: Perl evaluation forbidden in sandbox without the Safe module"));
 	else
+# endif
 	{
 	    PUSHMARK(SP);
 	    XPUSHs(safe);
 	    XPUSHs(sv);
 	    PUTBACK;
@@ -1226,13 +1248,12 @@ Delete(vimbuf, ...)
 		    aucmd_prepbuf(&aco, vimbuf);
 
 		    if (u_savedel(lnum, 1) == OK)
 		    {
 			ml_delete(lnum, 0);
+			check_cursor();
 			deleted_lines_mark(lnum, 1L);
-			if (aco.save_buf == curbuf)
-			    check_cursor();
 		    }
 
 		    /* restore curwin/curbuf and a few other things */
 		    aucmd_restbuf(&aco);
 		    /* Careful: autocommands may have made "vimbuf" invalid! */
--- vim72.orig/src/mbyte.c
+++ vim72/src/mbyte.c
@@ -24,11 +24,11 @@
  *		    The cell width on the display needs to be determined from
  *		    the character value.
  *		    Recognizing bytes is easy: 0xxx.xxxx is a single-byte
  *		    char, 10xx.xxxx is a trailing byte, 11xx.xxxx is a leading
  *		    byte of a multi-byte character.
- *		    To make things complicated, up to two composing characters
+ *		    To make things complicated, up to six composing characters
  *		    are allowed.  These are drawn on top of the first char.
  *		    For most editing the sequence of bytes with composing
  *		    characters included is considered to be one character.
  * "enc_unicode"    When 2 use 16-bit Unicode characters (or UTF-16).
  *		    When 4 use 32-but Unicode characters.
@@ -125,29 +125,50 @@
 
 static int enc_canon_search __ARGS((char_u *name));
 static int dbcs_char2len __ARGS((int c));
 static int dbcs_char2bytes __ARGS((int c, char_u *buf));
 static int dbcs_ptr2len __ARGS((char_u *p));
+static int dbcs_ptr2len_len __ARGS((char_u *p, int size));
+static int utf_ptr2cells_len __ARGS((char_u *p, int size));
 static int dbcs_char2cells __ARGS((int c));
+static int dbcs_ptr2cells_len __ARGS((char_u *p, int size));
 static int dbcs_ptr2char __ARGS((char_u *p));
 
-/* Lookup table to quickly get the length in bytes of a UTF-8 character from
- * the first byte of a UTF-8 string.  Bytes which are illegal when used as the
- * first byte have a one, because these will be used separately. */
+/*
+ * Lookup table to quickly get the length in bytes of a UTF-8 character from
+ * the first byte of a UTF-8 string.
+ * Bytes which are illegal when used as the first byte have a 1.
+ * The NUL byte has length 1.
+ */
 static char utf8len_tab[256] =
 {
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /*bogus*/
-    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /*bogus*/
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
     2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
     3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,1,1,
 };
 
 /*
+ * Like utf8len_tab above, but using a zero for illegal lead bytes.
+ */
+static char utf8len_tab_zero[256] =
+{
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+    3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,0,0,
+};
+
+/*
  * XIM often causes trouble.  Define XIM_DEBUG to get a log of XIM callbacks
  * in the "xim.log" file.
  */
 /* #define XIM_DEBUG */
 #ifdef XIM_DEBUG
@@ -604,35 +625,41 @@ codepage_invalid:
      * Set the function pointers.
      */
     if (enc_utf8)
     {
 	mb_ptr2len = utfc_ptr2len;
+	mb_ptr2len_len = utfc_ptr2len_len;
 	mb_char2len = utf_char2len;
 	mb_char2bytes = utf_char2bytes;
 	mb_ptr2cells = utf_ptr2cells;
+	mb_ptr2cells_len = utf_ptr2cells_len;
 	mb_char2cells = utf_char2cells;
 	mb_off2cells = utf_off2cells;
 	mb_ptr2char = utf_ptr2char;
 	mb_head_off = utf_head_off;
     }
     else if (enc_dbcs != 0)
     {
 	mb_ptr2len = dbcs_ptr2len;
+	mb_ptr2len_len = dbcs_ptr2len_len;
 	mb_char2len = dbcs_char2len;
 	mb_char2bytes = dbcs_char2bytes;
 	mb_ptr2cells = dbcs_ptr2cells;
+	mb_ptr2cells_len = dbcs_ptr2cells_len;
 	mb_char2cells = dbcs_char2cells;
 	mb_off2cells = dbcs_off2cells;
 	mb_ptr2char = dbcs_ptr2char;
 	mb_head_off = dbcs_head_off;
     }
     else
     {
 	mb_ptr2len = latin_ptr2len;
+	mb_ptr2len_len = latin_ptr2len_len;
 	mb_char2len = latin_char2len;
 	mb_char2bytes = latin_char2bytes;
 	mb_ptr2cells = latin_ptr2cells;
+	mb_ptr2cells_len = latin_ptr2cells_len;
 	mb_char2cells = latin_char2cells;
 	mb_off2cells = latin_off2cells;
 	mb_ptr2char = latin_ptr2char;
 	mb_head_off = latin_head_off;
     }
@@ -715,11 +742,11 @@ codepage_invalid:
 		     * mblen() should return -1 for invalid (means the leading
 		     * multibyte) character.  However there are some platforms
 		     * where mblen() returns 0 for invalid character.
 		     * Therefore, following condition includes 0.
 		     */
-		    (void)mblen(NULL, 0);	/* First reset the state. */
+		    ignored = mblen(NULL, 0);	/* First reset the state. */
 		    if (mblen(buf, (size_t)1) <= 0)
 			n = 2;
 		    else
 			n = 1;
 		}
@@ -1013,14 +1040,13 @@ dbcs_class(lead, trail)
 /*
  * mb_char2len() function pointer.
  * Return length in bytes of character "c".
  * Returns 1 for a single-byte character.
  */
-/* ARGSUSED */
     int
 latin_char2len(c)
-    int		c;
+    int		c UNUSED;
 {
     return 1;
 }
 
     static int
@@ -1068,11 +1094,10 @@ dbcs_char2bytes(c, buf)
 /*
  * mb_ptr2len() function pointer.
  * Get byte length of character at "*p" but stop at a NUL.
  * For UTF-8 this includes following composing characters.
  * Returns 0 when *p is NUL.
- *
  */
     int
 latin_ptr2len(p)
     char_u	*p;
 {
@@ -1090,14 +1115,48 @@ dbcs_ptr2len(p)
     if (len == 2 && p[1] == NUL)
 	len = 1;
     return len;
 }
 
+/*
+ * mb_ptr2len_len() function pointer.
+ * Like mb_ptr2len(), but limit to read "size" bytes.
+ * Returns 0 for an empty string.
+ * Returns 1 for an illegal char or an incomplete byte sequence.
+ */
+    int
+latin_ptr2len_len(p, size)
+    char_u	*p;
+    int		size;
+{
+    if (size < 1 || *p == NUL)
+	return 0;
+    return 1;
+}
+
+    static int
+dbcs_ptr2len_len(p, size)
+    char_u	*p;
+    int		size;
+{
+    int		len;
+
+    if (size < 1 || *p == NUL)
+	return 0;
+    if (size == 1)
+	return 1;
+    /* Check that second byte is not missing. */
+    len = MB_BYTE2LEN(*p);
+    if (len == 2 && p[1] == NUL)
+	len = 1;
+    return len;
+}
+
 struct interval
 {
-    unsigned short first;
-    unsigned short last;
+    long first;
+    long last;
 };
 static int intable __ARGS((struct interval *table, size_t size, int c));
 
 /*
  * Return TRUE if "c" is in "table[size / sizeof(struct interval)]".
@@ -1139,66 +1198,238 @@ intable(table, size, c)
  */
     int
 utf_char2cells(c)
     int		c;
 {
-    /* sorted list of non-overlapping intervals of East Asian Ambiguous
-     * characters, generated with:
-     * "uniset +WIDTH-A -cat=Me -cat=Mn -cat=Cf c" */
-    static struct interval ambiguous[] = {
-	{0x00A1, 0x00A1}, {0x00A4, 0x00A4}, {0x00A7, 0x00A8},
-	{0x00AA, 0x00AA}, {0x00AE, 0x00AE}, {0x00B0, 0x00B4},
-	{0x00B6, 0x00BA}, {0x00BC, 0x00BF}, {0x00C6, 0x00C6},
-	{0x00D0, 0x00D0}, {0x00D7, 0x00D8}, {0x00DE, 0x00E1},
-	{0x00E6, 0x00E6}, {0x00E8, 0x00EA}, {0x00EC, 0x00ED},
-	{0x00F0, 0x00F0}, {0x00F2, 0x00F3}, {0x00F7, 0x00FA},
-	{0x00FC, 0x00FC}, {0x00FE, 0x00FE}, {0x0101, 0x0101},
-	{0x0111, 0x0111}, {0x0113, 0x0113}, {0x011B, 0x011B},
-	{0x0126, 0x0127}, {0x012B, 0x012B}, {0x0131, 0x0133},
-	{0x0138, 0x0138}, {0x013F, 0x0142}, {0x0144, 0x0144},
-	{0x0148, 0x014B}, {0x014D, 0x014D}, {0x0152, 0x0153},
-	{0x0166, 0x0167}, {0x016B, 0x016B}, {0x01CE, 0x01CE},
-	{0x01D0, 0x01D0}, {0x01D2, 0x01D2}, {0x01D4, 0x01D4},
-	{0x01D6, 0x01D6}, {0x01D8, 0x01D8}, {0x01DA, 0x01DA},
-	{0x01DC, 0x01DC}, {0x0251, 0x0251}, {0x0261, 0x0261},
-	{0x02C4, 0x02C4}, {0x02C7, 0x02C7}, {0x02C9, 0x02CB},
-	{0x02CD, 0x02CD}, {0x02D0, 0x02D0}, {0x02D8, 0x02DB},
-	{0x02DD, 0x02DD}, {0x02DF, 0x02DF}, {0x0391, 0x03A1},
-	{0x03A3, 0x03A9}, {0x03B1, 0x03C1}, {0x03C3, 0x03C9},
-	{0x0401, 0x0401}, {0x0410, 0x044F}, {0x0451, 0x0451},
-	{0x2010, 0x2010}, {0x2013, 0x2016}, {0x2018, 0x2019},
-	{0x201C, 0x201D}, {0x2020, 0x2022}, {0x2024, 0x2027},
-	{0x2030, 0x2030}, {0x2032, 0x2033}, {0x2035, 0x2035},
-	{0x203B, 0x203B}, {0x203E, 0x203E}, {0x2074, 0x2074},
-	{0x207F, 0x207F}, {0x2081, 0x2084}, {0x20AC, 0x20AC},
-	{0x2103, 0x2103}, {0x2105, 0x2105}, {0x2109, 0x2109},
-	{0x2113, 0x2113}, {0x2116, 0x2116}, {0x2121, 0x2122},
-	{0x2126, 0x2126}, {0x212B, 0x212B}, {0x2153, 0x2154},
-	{0x215B, 0x215E}, {0x2160, 0x216B}, {0x2170, 0x2179},
-	{0x2190, 0x2199}, {0x21B8, 0x21B9}, {0x21D2, 0x21D2},
-	{0x21D4, 0x21D4}, {0x21E7, 0x21E7}, {0x2200, 0x2200},
-	{0x2202, 0x2203}, {0x2207, 0x2208}, {0x220B, 0x220B},
-	{0x220F, 0x220F}, {0x2211, 0x2211}, {0x2215, 0x2215},
-	{0x221A, 0x221A}, {0x221D, 0x2220}, {0x2223, 0x2223},
-	{0x2225, 0x2225}, {0x2227, 0x222C}, {0x222E, 0x222E},
-	{0x2234, 0x2237}, {0x223C, 0x223D}, {0x2248, 0x2248},
-	{0x224C, 0x224C}, {0x2252, 0x2252}, {0x2260, 0x2261},
-	{0x2264, 0x2267}, {0x226A, 0x226B}, {0x226E, 0x226F},
-	{0x2282, 0x2283}, {0x2286, 0x2287}, {0x2295, 0x2295},
-	{0x2299, 0x2299}, {0x22A5, 0x22A5}, {0x22BF, 0x22BF},
-	{0x2312, 0x2312}, {0x2460, 0x24E9}, {0x24EB, 0x254B},
-	{0x2550, 0x2573}, {0x2580, 0x258F}, {0x2592, 0x2595},
-	{0x25A0, 0x25A1}, {0x25A3, 0x25A9}, {0x25B2, 0x25B3},
-	{0x25B6, 0x25B7}, {0x25BC, 0x25BD}, {0x25C0, 0x25C1},
-	{0x25C6, 0x25C8}, {0x25CB, 0x25CB}, {0x25CE, 0x25D1},
-	{0x25E2, 0x25E5}, {0x25EF, 0x25EF}, {0x2605, 0x2606},
-	{0x2609, 0x2609}, {0x260E, 0x260F}, {0x2614, 0x2615},
-	{0x261C, 0x261C}, {0x261E, 0x261E}, {0x2640, 0x2640},
-	{0x2642, 0x2642}, {0x2660, 0x2661}, {0x2663, 0x2665},
-	{0x2667, 0x266A}, {0x266C, 0x266D}, {0x266F, 0x266F},
-	{0x273D, 0x273D}, {0x2776, 0x277F}, {0xE000, 0xF8FF},
-	{0xFFFD, 0xFFFD}, /* {0xF0000, 0xFFFFD}, {0x100000, 0x10FFFD} */
+    /* Sorted list of non-overlapping intervals of East Asian double width
+     * characters, generated with ../runtime/tools/unicode.vim. */
+    static struct interval doublewidth[] =
+    {
+	{0x1100, 0x115f},
+	{0x11a3, 0x11a7},
+	{0x11fa, 0x11ff},
+	{0x2329, 0x232a},
+	{0x2e80, 0x2e99},
+	{0x2e9b, 0x2ef3},
+	{0x2f00, 0x2fd5},
+	{0x2ff0, 0x2ffb},
+	{0x3000, 0x3029},
+	{0x3030, 0x303e},
+	{0x3041, 0x3096},
+	{0x309b, 0x30ff},
+	{0x3105, 0x312d},
+	{0x3131, 0x318e},
+	{0x3190, 0x31b7},
+	{0x31c0, 0x31e3},
+	{0x31f0, 0x321e},
+	{0x3220, 0x3247},
+	{0x3250, 0x32fe},
+	{0x3300, 0x4dbf},
+	{0x4e00, 0xa48c},
+	{0xa490, 0xa4c6},
+	{0xa960, 0xa97c},
+	{0xac00, 0xd7a3},
+	{0xd7b0, 0xd7c6},
+	{0xd7cb, 0xd7fb},
+	{0xf900, 0xfaff},
+	{0xfe10, 0xfe19},
+	{0xfe30, 0xfe52},
+	{0xfe54, 0xfe66},
+	{0xfe68, 0xfe6b},
+	{0xff01, 0xff60},
+	{0xffe0, 0xffe6},
+	{0x1f200, 0x1f200},
+	{0x1f210, 0x1f231},
+	{0x1f240, 0x1f248},
+	{0x20000, 0x2fffd},
+	{0x30000, 0x3fffd}
+    };
+    /* Sorted list of non-overlapping intervals of East Asian Ambiguous
+     * characters, generated with ../runtime/tools/unicode.vim. */
+    static struct interval ambiguous[] =
+    {
+	{0x00a1, 0x00a1},
+	{0x00a4, 0x00a4},
+	{0x00a7, 0x00a8},
+	{0x00aa, 0x00aa},
+	{0x00ad, 0x00ae},
+	{0x00b0, 0x00b4},
+	{0x00b6, 0x00ba},
+	{0x00bc, 0x00bf},
+	{0x00c6, 0x00c6},
+	{0x00d0, 0x00d0},
+	{0x00d7, 0x00d8},
+	{0x00de, 0x00e1},
+	{0x00e6, 0x00e6},
+	{0x00e8, 0x00ea},
+	{0x00ec, 0x00ed},
+	{0x00f0, 0x00f0},
+	{0x00f2, 0x00f3},
+	{0x00f7, 0x00fa},
+	{0x00fc, 0x00fc},
+	{0x00fe, 0x00fe},
+	{0x0101, 0x0101},
+	{0x0111, 0x0111},
+	{0x0113, 0x0113},
+	{0x011b, 0x011b},
+	{0x0126, 0x0127},
+	{0x012b, 0x012b},
+	{0x0131, 0x0133},
+	{0x0138, 0x0138},
+	{0x013f, 0x0142},
+	{0x0144, 0x0144},
+	{0x0148, 0x014b},
+	{0x014d, 0x014d},
+	{0x0152, 0x0153},
+	{0x0166, 0x0167},
+	{0x016b, 0x016b},
+	{0x01ce, 0x01ce},
+	{0x01d0, 0x01d0},
+	{0x01d2, 0x01d2},
+	{0x01d4, 0x01d4},
+	{0x01d6, 0x01d6},
+	{0x01d8, 0x01d8},
+	{0x01da, 0x01da},
+	{0x01dc, 0x01dc},
+	{0x0251, 0x0251},
+	{0x0261, 0x0261},
+	{0x02c4, 0x02c4},
+	{0x02c7, 0x02c7},
+	{0x02c9, 0x02cb},
+	{0x02cd, 0x02cd},
+	{0x02d0, 0x02d0},
+	{0x02d8, 0x02db},
+	{0x02dd, 0x02dd},
+	{0x02df, 0x02df},
+	{0x0391, 0x03a1},
+	{0x03a3, 0x03a9},
+	{0x03b1, 0x03c1},
+	{0x03c3, 0x03c9},
+	{0x0401, 0x0401},
+	{0x0410, 0x044f},
+	{0x0451, 0x0451},
+	{0x2010, 0x2010},
+	{0x2013, 0x2016},
+	{0x2018, 0x2019},
+	{0x201c, 0x201d},
+	{0x2020, 0x2022},
+	{0x2024, 0x2027},
+	{0x2030, 0x2030},
+	{0x2032, 0x2033},
+	{0x2035, 0x2035},
+	{0x203b, 0x203b},
+	{0x203e, 0x203e},
+	{0x2074, 0x2074},
+	{0x207f, 0x207f},
+	{0x2081, 0x2084},
+	{0x20ac, 0x20ac},
+	{0x2103, 0x2103},
+	{0x2105, 0x2105},
+	{0x2109, 0x2109},
+	{0x2113, 0x2113},
+	{0x2116, 0x2116},
+	{0x2121, 0x2122},
+	{0x2126, 0x2126},
+	{0x212b, 0x212b},
+	{0x2153, 0x2154},
+	{0x215b, 0x215e},
+	{0x2160, 0x216b},
+	{0x2170, 0x2179},
+	{0x2189, 0x2189},
+	{0x2190, 0x2199},
+	{0x21b8, 0x21b9},
+	{0x21d2, 0x21d2},
+	{0x21d4, 0x21d4},
+	{0x21e7, 0x21e7},
+	{0x2200, 0x2200},
+	{0x2202, 0x2203},
+	{0x2207, 0x2208},
+	{0x220b, 0x220b},
+	{0x220f, 0x220f},
+	{0x2211, 0x2211},
+	{0x2215, 0x2215},
+	{0x221a, 0x221a},
+	{0x221d, 0x2220},
+	{0x2223, 0x2223},
+	{0x2225, 0x2225},
+	{0x2227, 0x222c},
+	{0x222e, 0x222e},
+	{0x2234, 0x2237},
+	{0x223c, 0x223d},
+	{0x2248, 0x2248},
+	{0x224c, 0x224c},
+	{0x2252, 0x2252},
+	{0x2260, 0x2261},
+	{0x2264, 0x2267},
+	{0x226a, 0x226b},
+	{0x226e, 0x226f},
+	{0x2282, 0x2283},
+	{0x2286, 0x2287},
+	{0x2295, 0x2295},
+	{0x2299, 0x2299},
+	{0x22a5, 0x22a5},
+	{0x22bf, 0x22bf},
+	{0x2312, 0x2312},
+	{0x2460, 0x24e9},
+	{0x24eb, 0x254b},
+	{0x2550, 0x2573},
+	{0x2580, 0x258f},
+	{0x2592, 0x2595},
+	{0x25a0, 0x25a1},
+	{0x25a3, 0x25a9},
+	{0x25b2, 0x25b3},
+	{0x25b6, 0x25b7},
+	{0x25bc, 0x25bd},
+	{0x25c0, 0x25c1},
+	{0x25c6, 0x25c8},
+	{0x25cb, 0x25cb},
+	{0x25ce, 0x25d1},
+	{0x25e2, 0x25e5},
+	{0x25ef, 0x25ef},
+	{0x2605, 0x2606},
+	{0x2609, 0x2609},
+	{0x260e, 0x260f},
+	{0x2614, 0x2615},
+	{0x261c, 0x261c},
+	{0x261e, 0x261e},
+	{0x2640, 0x2640},
+	{0x2642, 0x2642},
+	{0x2660, 0x2661},
+	{0x2663, 0x2665},
+	{0x2667, 0x266a},
+	{0x266c, 0x266d},
+	{0x266f, 0x266f},
+	{0x269e, 0x269f},
+	{0x26be, 0x26bf},
+	{0x26c4, 0x26cd},
+	{0x26cf, 0x26e1},
+	{0x26e3, 0x26e3},
+	{0x26e8, 0x26ff},
+	{0x273d, 0x273d},
+	{0x2757, 0x2757},
+	{0x2776, 0x277f},
+	{0x2b55, 0x2b59},
+	{0x3248, 0x324f},
+	{0xe000, 0xf8ff},
+	{0xfffd, 0xfffd},
+	{0x1f100, 0x1f10a},
+	{0x1f110, 0x1f12d},
+	{0x1f131, 0x1f131},
+	{0x1f13d, 0x1f13d},
+	{0x1f13f, 0x1f13f},
+	{0x1f142, 0x1f142},
+	{0x1f146, 0x1f146},
+	{0x1f14a, 0x1f14e},
+	{0x1f157, 0x1f157},
+	{0x1f15f, 0x1f15f},
+	{0x1f179, 0x1f179},
+	{0x1f17b, 0x1f17c},
+	{0x1f17f, 0x1f17f},
+	{0x1f18a, 0x1f18d},
+	{0x1f190, 0x1f190},
+	{0xf0000, 0xffffd},
+	{0x100000, 0x10fffd}
     };
 
     if (c >= 0x100)
     {
 #ifdef USE_WCHAR_FUNCTIONS
@@ -1213,24 +1444,11 @@ utf_char2cells(c)
 	if (n > 1)
 	    return n;
 #else
 	if (!utf_printable(c))
 	    return 6;		/* unprintable, displays <xxxx> */
-	if (c >= 0x1100
-	    && (c <= 0x115f			/* Hangul Jamo */
-		|| c == 0x2329
-		|| c == 0x232a
-		|| (c >= 0x2e80 && c <= 0xa4cf
-		    && c != 0x303f)		/* CJK ... Yi */
-		|| (c >= 0xac00 && c <= 0xd7a3)	/* Hangul Syllables */
-		|| (c >= 0xf900 && c <= 0xfaff)	/* CJK Compatibility
-						   Ideographs */
-		|| (c >= 0xfe30 && c <= 0xfe6f)	/* CJK Compatibility Forms */
-		|| (c >= 0xff00 && c <= 0xff60)	/* Fullwidth Forms */
-		|| (c >= 0xffe0 && c <= 0xffe6)
-		|| (c >= 0x20000 && c <= 0x2fffd)
-		|| (c >= 0x30000 && c <= 0x3fffd)))
+	if (intable(doublewidth, sizeof(doublewidth), c))
 	    return 2;
 #endif
     }
 
     /* Characters below 0x100 are influenced by 'isprint' option */
@@ -1246,14 +1464,13 @@ utf_char2cells(c)
 /*
  * mb_ptr2cells() function pointer.
  * Return the number of display cells character at "*p" occupies.
  * This doesn't take care of unprintable characters, use ptr2cells() for that.
  */
-/*ARGSUSED*/
     int
 latin_ptr2cells(p)
-    char_u	*p;
+    char_u	*p UNUSED;
 {
     return 1;
 }
 
     int
@@ -1287,18 +1504,66 @@ dbcs_ptr2cells(p)
 	return 1;
     return MB_BYTE2LEN(*p);
 }
 
 /*
+ * mb_ptr2cells_len() function pointer.
+ * Like mb_ptr2cells(), but limit string length to "size".
+ * For an empty string or truncated character returns 1.
+ */
+    int
+latin_ptr2cells_len(p, size)
+    char_u	*p UNUSED;
+    int		size UNUSED;
+{
+    return 1;
+}
+
+    static int
+utf_ptr2cells_len(p, size)
+    char_u	*p;
+    int		size;
+{
+    int		c;
+
+    /* Need to convert to a wide character. */
+    if (size > 0 && *p >= 0x80)
+    {
+	if (utf_ptr2len_len(p, size) < utf8len_tab[*p])
+	    return 1;  /* truncated */
+	c = utf_ptr2char(p);
+	/* An illegal byte is displayed as <xx>. */
+	if (utf_ptr2len(p) == 1 || c == NUL)
+	    return 4;
+	/* If the char is ASCII it must be an overlong sequence. */
+	if (c < 0x80)
+	    return char2cells(c);
+	return utf_char2cells(c);
+    }
+    return 1;
+}
+
+    static int
+dbcs_ptr2cells_len(p, size)
+    char_u	*p;
+    int		size;
+{
+    /* Number of cells is equal to number of bytes, except for euc-jp when
+     * the first byte is 0x8e. */
+    if (size <= 1 || (enc_dbcs == DBCS_JPNU && *p == 0x8e))
+	return 1;
+    return MB_BYTE2LEN(*p);
+}
+
+/*
  * mb_char2cells() function pointer.
  * Return the number of display cells character "c" occupies.
  * Only takes care of multi-byte chars, not "^C" and such.
  */
-/*ARGSUSED*/
     int
 latin_char2cells(c)
-    int		c;
+    int		c UNUSED;
 {
     return 1;
 }
 
     static int
@@ -1316,15 +1581,14 @@ dbcs_char2cells(c)
 /*
  * mb_off2cells() function pointer.
  * Return number of display cells for char at ScreenLines[off].
  * We make sure that the offset used is less than "max_off".
  */
-/*ARGSUSED*/
     int
 latin_off2cells(off, max_off)
-    unsigned	off;
-    unsigned	max_off;
+    unsigned	off UNUSED;
+    unsigned	max_off UNUSED;
 {
     return 1;
 }
 
     int
@@ -1384,11 +1648,11 @@ utf_ptr2char(p)
     int		len;
 
     if (p[0] < 0x80)	/* be quick for ASCII */
 	return p[0];
 
-    len = utf8len_tab[p[0]];
+    len = utf8len_tab_zero[p[0]];
     if (len > 1 && (p[1] & 0xc0) == 0x80)
     {
 	if (len == 2)
 	    return ((p[0] & 0x1f) << 6) + (p[1] & 0x3f);
 	if ((p[2] & 0xc0) == 0x80)
@@ -1634,10 +1898,11 @@ utf_ptr2len(p)
 }
 
 /*
  * Return length of UTF-8 character, obtained from the first byte.
  * "b" must be between 0 and 255!
+ * Returns 1 for an invalid first byte value.
  */
     int
 utf_byte2len(b)
     int		b;
 {
@@ -1648,25 +1913,28 @@ utf_byte2len(b)
  * Get the length of UTF-8 byte sequence "p[size]".  Does not include any
  * following composing characters.
  * Returns 1 for "".
  * Returns 1 for an illegal byte sequence (also in incomplete byte seq.).
  * Returns number > "size" for an incomplete byte sequence.
+ * Never returns zero.
  */
     int
 utf_ptr2len_len(p, size)
     char_u	*p;
     int		size;
 {
     int		len;
     int		i;
     int		m;
 
-    if (*p == NUL)
-	return 1;
-    m = len = utf8len_tab[*p];
+    len = utf8len_tab[*p];
+    if (len == 1)
+	return 1;	/* NUL, ascii or illegal lead byte */
     if (len > size)
 	m = size;	/* incomplete byte sequence. */
+    else
+	m = len;
     for (i = 1; i < m; ++i)
 	if ((p[i] & 0xc0) != 0x80)
 	    return 1;
     return len;
 }
@@ -1696,11 +1964,11 @@ utfc_ptr2len(p)
     /* Check for illegal byte. */
     if (len == 1 && b0 >= 0x80)
 	return 1;
 
     /*
-     * Check for composing characters.  We can handle only the first two, but
+     * Check for composing characters.  We can handle only the first six, but
      * skip all of them (otherwise the cursor would get stuck).
      */
 #ifdef FEAT_ARABIC
     prevlen = 0;
 #endif
@@ -1718,10 +1986,11 @@ utfc_ptr2len(p)
 }
 
 /*
  * Return the number of bytes the UTF-8 encoding of the character at "p[size]"
  * takes.  This includes following composing characters.
+ * Returns 0 for an empty string.
  * Returns 1 for an illegal char or an incomplete byte sequence.
  */
     int
 utfc_ptr2len_len(p, size)
     char_u	*p;
@@ -1730,11 +1999,11 @@ utfc_ptr2len_len(p, size)
     int		len;
 #ifdef FEAT_ARABIC
     int		prevlen;
 #endif
 
-    if (*p == NUL)
+    if (size < 1 || *p == NUL)
 	return 0;
     if (p[0] < 0x80 && (size == 1 || p[1] < 0x80)) /* be quick for ASCII */
 	return 1;
 
     /* Skip over first UTF-8 char, stopping at a NUL byte. */
@@ -1743,11 +2012,11 @@ utfc_ptr2len_len(p, size)
     /* Check for illegal byte and incomplete byte sequence. */
     if ((len == 1 && p[0] >= 0x80) || len > size)
 	return 1;
 
     /*
-     * Check for composing characters.  We can handle only the first two, but
+     * Check for composing characters.  We can handle only the first six, but
      * skip all of them (otherwise the cursor would get stuck).
      */
 #ifdef FEAT_ARABIC
     prevlen = 0;
 #endif
@@ -1861,42 +2130,202 @@ utf_char2bytes(c, buf)
  */
     int
 utf_iscomposing(c)
     int		c;
 {
-    /* sorted list of non-overlapping intervals */
+    /* Sorted list of non-overlapping intervals.
+     * Generated by ../runtime/tools/unicode.vim. */
     static struct interval combining[] =
     {
-	{0x0300, 0x034f}, {0x0360, 0x036f}, {0x0483, 0x0486}, {0x0488, 0x0489},
-	{0x0591, 0x05a1}, {0x05a3, 0x05b9}, {0x05bb, 0x05bd}, {0x05bf, 0x05bf},
-	{0x05c1, 0x05c2}, {0x05c4, 0x05c4}, {0x0610, 0x0615}, {0x064b, 0x0658},
-	{0x0670, 0x0670}, {0x06d6, 0x06dc}, {0x06de, 0x06e4}, {0x06e7, 0x06e8},
-	{0x06ea, 0x06ed}, {0x0711, 0x0711}, {0x0730, 0x074a}, {0x07a6, 0x07b0},
-	{0x0901, 0x0903}, {0x093c, 0x093c}, {0x093e, 0x094d}, {0x0951, 0x0954},
-	{0x0962, 0x0963}, {0x0981, 0x0983}, {0x09bc, 0x09bc}, {0x09be, 0x09c4},
-	{0x09c7, 0x09c8}, {0x09cb, 0x09cd}, {0x09d7, 0x09d7}, {0x09e2, 0x09e3},
-	{0x0a01, 0x0a03}, {0x0a3c, 0x0a3c}, {0x0a3e, 0x0a42}, {0x0a47, 0x0a48},
-	{0x0a4b, 0x0a4d}, {0x0a70, 0x0a71}, {0x0a81, 0x0a83}, {0x0abc, 0x0abc},
-	{0x0abe, 0x0ac5}, {0x0ac7, 0x0ac9}, {0x0acb, 0x0acd}, {0x0ae2, 0x0ae3},
-	{0x0b01, 0x0b03}, {0x0b3c, 0x0b3c}, {0x0b3e, 0x0b43}, {0x0b47, 0x0b48},
-	{0x0b4b, 0x0b4d}, {0x0b56, 0x0b57}, {0x0b82, 0x0b82}, {0x0bbe, 0x0bc2},
-	{0x0bc6, 0x0bc8}, {0x0bca, 0x0bcd}, {0x0bd7, 0x0bd7}, {0x0c01, 0x0c03},
-	{0x0c3e, 0x0c44}, {0x0c46, 0x0c48}, {0x0c4a, 0x0c4d}, {0x0c55, 0x0c56},
-	{0x0c82, 0x0c83}, {0x0cbc, 0x0cbc}, {0x0cbe, 0x0cc4}, {0x0cc6, 0x0cc8},
-	{0x0cca, 0x0ccd}, {0x0cd5, 0x0cd6}, {0x0d02, 0x0d03}, {0x0d3e, 0x0d43},
-	{0x0d46, 0x0d48}, {0x0d4a, 0x0d4d}, {0x0d57, 0x0d57}, {0x0d82, 0x0d83},
-	{0x0dca, 0x0dca}, {0x0dcf, 0x0dd4}, {0x0dd6, 0x0dd6}, {0x0dd8, 0x0ddf},
-	{0x0df2, 0x0df3}, {0x0e31, 0x0e31}, {0x0e34, 0x0e3a}, {0x0e47, 0x0e4e},
-	{0x0eb1, 0x0eb1}, {0x0eb4, 0x0eb9}, {0x0ebb, 0x0ebc}, {0x0ec8, 0x0ecd},
-	{0x0f18, 0x0f19}, {0x0f35, 0x0f35}, {0x0f37, 0x0f37}, {0x0f39, 0x0f39},
-	{0x0f3e, 0x0f3f}, {0x0f71, 0x0f84}, {0x0f86, 0x0f87}, {0x0f90, 0x0f97},
-	{0x0f99, 0x0fbc}, {0x0fc6, 0x0fc6}, {0x102c, 0x1032}, {0x1036, 0x1039},
-	{0x1056, 0x1059}, {0x1712, 0x1714}, {0x1732, 0x1734}, {0x1752, 0x1753},
-	{0x1772, 0x1773}, {0x17b6, 0x17d3}, {0x17dd, 0x17dd}, {0x180b, 0x180d},
-	{0x18a9, 0x18a9}, {0x1920, 0x192b}, {0x1930, 0x193b}, {0x20d0, 0x20ea},
-	{0x302a, 0x302f}, {0x3099, 0x309a}, {0xfb1e, 0xfb1e}, {0xfe00, 0xfe0f},
-	{0xfe20, 0xfe23},
+	{0x0300, 0x036f},
+	{0x0483, 0x0489},
+	{0x0591, 0x05bd},
+	{0x05bf, 0x05bf},
+	{0x05c1, 0x05c2},
+	{0x05c4, 0x05c5},
+	{0x05c7, 0x05c7},
+	{0x0610, 0x061a},
+	{0x064b, 0x065e},
+	{0x0670, 0x0670},
+	{0x06d6, 0x06dc},
+	{0x06de, 0x06e4},
+	{0x06e7, 0x06e8},
+	{0x06ea, 0x06ed},
+	{0x0711, 0x0711},
+	{0x0730, 0x074a},
+	{0x07a6, 0x07b0},
+	{0x07eb, 0x07f3},
+	{0x0816, 0x0819},
+	{0x081b, 0x0823},
+	{0x0825, 0x0827},
+	{0x0829, 0x082d},
+	{0x0900, 0x0903},
+	{0x093c, 0x093c},
+	{0x093e, 0x094e},
+	{0x0951, 0x0955},
+	{0x0962, 0x0963},
+	{0x0981, 0x0983},
+	{0x09bc, 0x09bc},
+	{0x09be, 0x09c4},
+	{0x09c7, 0x09c8},
+	{0x09cb, 0x09cd},
+	{0x09d7, 0x09d7},
+	{0x09e2, 0x09e3},
+	{0x0a01, 0x0a03},
+	{0x0a3c, 0x0a3c},
+	{0x0a3e, 0x0a42},
+	{0x0a47, 0x0a48},
+	{0x0a4b, 0x0a4d},
+	{0x0a51, 0x0a51},
+	{0x0a70, 0x0a71},
+	{0x0a75, 0x0a75},
+	{0x0a81, 0x0a83},
+	{0x0abc, 0x0abc},
+	{0x0abe, 0x0ac5},
+	{0x0ac7, 0x0ac9},
+	{0x0acb, 0x0acd},
+	{0x0ae2, 0x0ae3},
+	{0x0b01, 0x0b03},
+	{0x0b3c, 0x0b3c},
+	{0x0b3e, 0x0b44},
+	{0x0b47, 0x0b48},
+	{0x0b4b, 0x0b4d},
+	{0x0b56, 0x0b57},
+	{0x0b62, 0x0b63},
+	{0x0b82, 0x0b82},
+	{0x0bbe, 0x0bc2},
+	{0x0bc6, 0x0bc8},
+	{0x0bca, 0x0bcd},
+	{0x0bd7, 0x0bd7},
+	{0x0c01, 0x0c03},
+	{0x0c3e, 0x0c44},
+	{0x0c46, 0x0c48},
+	{0x0c4a, 0x0c4d},
+	{0x0c55, 0x0c56},
+	{0x0c62, 0x0c63},
+	{0x0c82, 0x0c83},
+	{0x0cbc, 0x0cbc},
+	{0x0cbe, 0x0cc4},
+	{0x0cc6, 0x0cc8},
+	{0x0cca, 0x0ccd},
+	{0x0cd5, 0x0cd6},
+	{0x0ce2, 0x0ce3},
+	{0x0d02, 0x0d03},
+	{0x0d3e, 0x0d44},
+	{0x0d46, 0x0d48},
+	{0x0d4a, 0x0d4d},
+	{0x0d57, 0x0d57},
+	{0x0d62, 0x0d63},
+	{0x0d82, 0x0d83},
+	{0x0dca, 0x0dca},
+	{0x0dcf, 0x0dd4},
+	{0x0dd6, 0x0dd6},
+	{0x0dd8, 0x0ddf},
+	{0x0df2, 0x0df3},
+	{0x0e31, 0x0e31},
+	{0x0e34, 0x0e3a},
+	{0x0e47, 0x0e4e},
+	{0x0eb1, 0x0eb1},
+	{0x0eb4, 0x0eb9},
+	{0x0ebb, 0x0ebc},
+	{0x0ec8, 0x0ecd},
+	{0x0f18, 0x0f19},
+	{0x0f35, 0x0f35},
+	{0x0f37, 0x0f37},
+	{0x0f39, 0x0f39},
+	{0x0f3e, 0x0f3f},
+	{0x0f71, 0x0f84},
+	{0x0f86, 0x0f87},
+	{0x0f90, 0x0f97},
+	{0x0f99, 0x0fbc},
+	{0x0fc6, 0x0fc6},
+	{0x102b, 0x103e},
+	{0x1056, 0x1059},
+	{0x105e, 0x1060},
+	{0x1062, 0x1064},
+	{0x1067, 0x106d},
+	{0x1071, 0x1074},
+	{0x1082, 0x108d},
+	{0x108f, 0x108f},
+	{0x109a, 0x109d},
+	{0x135f, 0x135f},
+	{0x1712, 0x1714},
+	{0x1732, 0x1734},
+	{0x1752, 0x1753},
+	{0x1772, 0x1773},
+	{0x17b6, 0x17d3},
+	{0x17dd, 0x17dd},
+	{0x180b, 0x180d},
+	{0x18a9, 0x18a9},
+	{0x1920, 0x192b},
+	{0x1930, 0x193b},
+	{0x19b0, 0x19c0},
+	{0x19c8, 0x19c9},
+	{0x1a17, 0x1a1b},
+	{0x1a55, 0x1a5e},
+	{0x1a60, 0x1a7c},
+	{0x1a7f, 0x1a7f},
+	{0x1b00, 0x1b04},
+	{0x1b34, 0x1b44},
+	{0x1b6b, 0x1b73},
+	{0x1b80, 0x1b82},
+	{0x1ba1, 0x1baa},
+	{0x1c24, 0x1c37},
+	{0x1cd0, 0x1cd2},
+	{0x1cd4, 0x1ce8},
+	{0x1ced, 0x1ced},
+	{0x1cf2, 0x1cf2},
+	{0x1dc0, 0x1de6},
+	{0x1dfd, 0x1dff},
+	{0x20d0, 0x20f0},
+	{0x2cef, 0x2cf1},
+	{0x2de0, 0x2dff},
+	{0x302a, 0x302f},
+	{0x3099, 0x309a},
+	{0xa66f, 0xa672},
+	{0xa67c, 0xa67d},
+	{0xa6f0, 0xa6f1},
+	{0xa802, 0xa802},
+	{0xa806, 0xa806},
+	{0xa80b, 0xa80b},
+	{0xa823, 0xa827},
+	{0xa880, 0xa881},
+	{0xa8b4, 0xa8c4},
+	{0xa8e0, 0xa8f1},
+	{0xa926, 0xa92d},
+	{0xa947, 0xa953},
+	{0xa980, 0xa983},
+	{0xa9b3, 0xa9c0},
+	{0xaa29, 0xaa36},
+	{0xaa43, 0xaa43},
+	{0xaa4c, 0xaa4d},
+	{0xaa7b, 0xaa7b},
+	{0xaab0, 0xaab0},
+	{0xaab2, 0xaab4},
+	{0xaab7, 0xaab8},
+	{0xaabe, 0xaabf},
+	{0xaac1, 0xaac1},
+	{0xabe3, 0xabea},
+	{0xabec, 0xabed},
+	{0xfb1e, 0xfb1e},
+	{0xfe00, 0xfe0f},
+	{0xfe20, 0xfe26},
+	{0x101fd, 0x101fd},
+	{0x10a01, 0x10a03},
+	{0x10a05, 0x10a06},
+	{0x10a0c, 0x10a0f},
+	{0x10a38, 0x10a3a},
+	{0x10a3f, 0x10a3f},
+	{0x11080, 0x11082},
+	{0x110b0, 0x110ba},
+	{0x1d165, 0x1d169},
+	{0x1d16d, 0x1d172},
+	{0x1d17b, 0x1d182},
+	{0x1d185, 0x1d18b},
+	{0x1d1aa, 0x1d1ad},
+	{0x1d242, 0x1d244},
+	{0xe0100, 0xe01ef}
     };
 
     return intable(combining, sizeof(combining), c);
 }
 
@@ -2040,64 +2469,185 @@ utf_class(c)
 
 /*
  * Code for Unicode case-dependent operations.  Based on notes in
  * http://www.unicode.org/Public/UNIDATA/CaseFolding.txt
  * This code uses simple case folding, not full case folding.
+ * Last updated for Unicode 5.2.
  */
 
 /*
- * The following table is built by foldExtract.pl < CaseFolding.txt .
- * It must be in numeric order, because we use binary search on it.
- * An entry such as {0x41,0x5a,1,32} means that UCS-4 characters in the range
- * from 0x41 to 0x5a inclusive, stepping by 1, are folded by adding 32.
+ * The following tables are built by ../runtime/tools/unicode.vim.
+ * They must be in numeric order, because we use binary search.
+ * An entry such as {0x41,0x5a,1,32} means that Unicode characters in the
+ * range from 0x41 to 0x5a inclusive, stepping by 1, are changed to
+ * folded/upper/lower by adding 32.
  */
-
 typedef struct
 {
     int rangeStart;
     int rangeEnd;
     int step;
     int offset;
 } convertStruct;
 
 static convertStruct foldCase[] =
 {
-	{0x41,0x5a,1,32}, {0xc0,0xd6,1,32}, {0xd8,0xde,1,32},
-	{0x100,0x12e,2,1}, {0x130,0x130,-1,-199}, {0x132,0x136,2,1},
-	{0x139,0x147,2,1}, {0x14a,0x176,2,1}, {0x178,0x178,-1,-121},
-	{0x179,0x17d,2,1}, {0x181,0x181,-1,210}, {0x182,0x184,2,1},
-	{0x186,0x186,-1,206}, {0x187,0x187,-1,1}, {0x189,0x18a,1,205},
-	{0x18b,0x18b,-1,1}, {0x18e,0x18e,-1,79}, {0x18f,0x18f,-1,202},
-	{0x190,0x190,-1,203}, {0x191,0x191,-1,1}, {0x193,0x193,-1,205},
-	{0x194,0x194,-1,207}, {0x196,0x196,-1,211}, {0x197,0x197,-1,209},
-	{0x198,0x198,-1,1}, {0x19c,0x19c,-1,211}, {0x19d,0x19d,-1,213},
-	{0x19f,0x19f,-1,214}, {0x1a0,0x1a4,2,1}, {0x1a6,0x1a6,-1,218},
-	{0x1a7,0x1a7,-1,1}, {0x1a9,0x1a9,-1,218}, {0x1ac,0x1ac,-1,1},
-	{0x1ae,0x1ae,-1,218}, {0x1af,0x1af,-1,1}, {0x1b1,0x1b2,1,217},
-	{0x1b3,0x1b5,2,1}, {0x1b7,0x1b7,-1,219}, {0x1b8,0x1bc,4,1},
-	{0x1c4,0x1c4,-1,2}, {0x1c5,0x1c5,-1,1}, {0x1c7,0x1c7,-1,2},
-	{0x1c8,0x1c8,-1,1}, {0x1ca,0x1ca,-1,2}, {0x1cb,0x1db,2,1},
-	{0x1de,0x1ee,2,1}, {0x1f1,0x1f1,-1,2}, {0x1f2,0x1f4,2,1},
-	{0x1f6,0x1f6,-1,-97}, {0x1f7,0x1f7,-1,-56}, {0x1f8,0x21e,2,1},
-	{0x220,0x220,-1,-130}, {0x222,0x232,2,1}, {0x386,0x386,-1,38},
-	{0x388,0x38a,1,37}, {0x38c,0x38c,-1,64}, {0x38e,0x38f,1,63},
-	{0x391,0x3a1,1,32}, {0x3a3,0x3ab,1,32}, {0x3d8,0x3ee,2,1},
-	{0x3f4,0x3f4,-1,-60}, {0x3f7,0x3f7,-1,1}, {0x3f9,0x3f9,-1,-7},
-	{0x3fa,0x3fa,-1,1}, {0x400,0x40f,1,80}, {0x410,0x42f,1,32},
-	{0x460,0x480,2,1}, {0x48a,0x4be,2,1}, {0x4c1,0x4cd,2,1},
-	{0x4d0,0x4f4,2,1}, {0x4f8,0x500,8,1}, {0x502,0x50e,2,1},
-	{0x531,0x556,1,48}, {0x1e00,0x1e94,2,1}, {0x1ea0,0x1ef8,2,1},
-	{0x1f08,0x1f0f,1,-8}, {0x1f18,0x1f1d,1,-8}, {0x1f28,0x1f2f,1,-8},
-	{0x1f38,0x1f3f,1,-8}, {0x1f48,0x1f4d,1,-8}, {0x1f59,0x1f5f,2,-8},
-	{0x1f68,0x1f6f,1,-8}, {0x1f88,0x1f8f,1,-8}, {0x1f98,0x1f9f,1,-8},
-	{0x1fa8,0x1faf,1,-8}, {0x1fb8,0x1fb9,1,-8}, {0x1fba,0x1fbb,1,-74},
-	{0x1fbc,0x1fbc,-1,-9}, {0x1fc8,0x1fcb,1,-86}, {0x1fcc,0x1fcc,-1,-9},
-	{0x1fd8,0x1fd9,1,-8}, {0x1fda,0x1fdb,1,-100}, {0x1fe8,0x1fe9,1,-8},
-	{0x1fea,0x1feb,1,-112}, {0x1fec,0x1fec,-1,-7}, {0x1ff8,0x1ff9,1,-128},
-	{0x1ffa,0x1ffb,1,-126}, {0x1ffc,0x1ffc,-1,-9}, {0x2126,0x2126,-1,-7517},
-	{0x212a,0x212a,-1,-8383}, {0x212b,0x212b,-1,-8262},
-	{0x2160,0x216f,1,16}, {0x24b6,0x24cf,1,26}, {0xff21,0xff3a,1,32},
+	{0x41,0x5a,1,32},
+	{0xb5,0xb5,-1,775},
+	{0xc0,0xd6,1,32},
+	{0xd8,0xde,1,32},
+	{0x100,0x12e,2,1},
+	{0x132,0x136,2,1},
+	{0x139,0x147,2,1},
+	{0x14a,0x176,2,1},
+	{0x178,0x178,-1,-121},
+	{0x179,0x17d,2,1},
+	{0x17f,0x17f,-1,-268},
+	{0x181,0x181,-1,210},
+	{0x182,0x184,2,1},
+	{0x186,0x186,-1,206},
+	{0x187,0x187,-1,1},
+	{0x189,0x18a,1,205},
+	{0x18b,0x18b,-1,1},
+	{0x18e,0x18e,-1,79},
+	{0x18f,0x18f,-1,202},
+	{0x190,0x190,-1,203},
+	{0x191,0x191,-1,1},
+	{0x193,0x193,-1,205},
+	{0x194,0x194,-1,207},
+	{0x196,0x196,-1,211},
+	{0x197,0x197,-1,209},
+	{0x198,0x198,-1,1},
+	{0x19c,0x19c,-1,211},
+	{0x19d,0x19d,-1,213},
+	{0x19f,0x19f,-1,214},
+	{0x1a0,0x1a4,2,1},
+	{0x1a6,0x1a6,-1,218},
+	{0x1a7,0x1a7,-1,1},
+	{0x1a9,0x1a9,-1,218},
+	{0x1ac,0x1ac,-1,1},
+	{0x1ae,0x1ae,-1,218},
+	{0x1af,0x1af,-1,1},
+	{0x1b1,0x1b2,1,217},
+	{0x1b3,0x1b5,2,1},
+	{0x1b7,0x1b7,-1,219},
+	{0x1b8,0x1bc,4,1},
+	{0x1c4,0x1c4,-1,2},
+	{0x1c5,0x1c5,-1,1},
+	{0x1c7,0x1c7,-1,2},
+	{0x1c8,0x1c8,-1,1},
+	{0x1ca,0x1ca,-1,2},
+	{0x1cb,0x1db,2,1},
+	{0x1de,0x1ee,2,1},
+	{0x1f1,0x1f1,-1,2},
+	{0x1f2,0x1f4,2,1},
+	{0x1f6,0x1f6,-1,-97},
+	{0x1f7,0x1f7,-1,-56},
+	{0x1f8,0x21e,2,1},
+	{0x220,0x220,-1,-130},
+	{0x222,0x232,2,1},
+	{0x23a,0x23a,-1,10795},
+	{0x23b,0x23b,-1,1},
+	{0x23d,0x23d,-1,-163},
+	{0x23e,0x23e,-1,10792},
+	{0x241,0x241,-1,1},
+	{0x243,0x243,-1,-195},
+	{0x244,0x244,-1,69},
+	{0x245,0x245,-1,71},
+	{0x246,0x24e,2,1},
+	{0x345,0x345,-1,116},
+	{0x370,0x372,2,1},
+	{0x376,0x376,-1,1},
+	{0x386,0x386,-1,38},
+	{0x388,0x38a,1,37},
+	{0x38c,0x38c,-1,64},
+	{0x38e,0x38f,1,63},
+	{0x391,0x3a1,1,32},
+	{0x3a3,0x3ab,1,32},
+	{0x3c2,0x3c2,-1,1},
+	{0x3cf,0x3cf,-1,8},
+	{0x3d0,0x3d0,-1,-30},
+	{0x3d1,0x3d1,-1,-25},
+	{0x3d5,0x3d5,-1,-15},
+	{0x3d6,0x3d6,-1,-22},
+	{0x3d8,0x3ee,2,1},
+	{0x3f0,0x3f0,-1,-54},
+	{0x3f1,0x3f1,-1,-48},
+	{0x3f4,0x3f4,-1,-60},
+	{0x3f5,0x3f5,-1,-64},
+	{0x3f7,0x3f7,-1,1},
+	{0x3f9,0x3f9,-1,-7},
+	{0x3fa,0x3fa,-1,1},
+	{0x3fd,0x3ff,1,-130},
+	{0x400,0x40f,1,80},
+	{0x410,0x42f,1,32},
+	{0x460,0x480,2,1},
+	{0x48a,0x4be,2,1},
+	{0x4c0,0x4c0,-1,15},
+	{0x4c1,0x4cd,2,1},
+	{0x4d0,0x524,2,1},
+	{0x531,0x556,1,48},
+	{0x10a0,0x10c5,1,7264},
+	{0x1e00,0x1e94,2,1},
+	{0x1e9b,0x1e9b,-1,-58},
+	{0x1e9e,0x1e9e,-1,-7615},
+	{0x1ea0,0x1efe,2,1},
+	{0x1f08,0x1f0f,1,-8},
+	{0x1f18,0x1f1d,1,-8},
+	{0x1f28,0x1f2f,1,-8},
+	{0x1f38,0x1f3f,1,-8},
+	{0x1f48,0x1f4d,1,-8},
+	{0x1f59,0x1f5f,2,-8},
+	{0x1f68,0x1f6f,1,-8},
+	{0x1f88,0x1f8f,1,-8},
+	{0x1f98,0x1f9f,1,-8},
+	{0x1fa8,0x1faf,1,-8},
+	{0x1fb8,0x1fb9,1,-8},
+	{0x1fba,0x1fbb,1,-74},
+	{0x1fbc,0x1fbc,-1,-9},
+	{0x1fbe,0x1fbe,-1,-7173},
+	{0x1fc8,0x1fcb,1,-86},
+	{0x1fcc,0x1fcc,-1,-9},
+	{0x1fd8,0x1fd9,1,-8},
+	{0x1fda,0x1fdb,1,-100},
+	{0x1fe8,0x1fe9,1,-8},
+	{0x1fea,0x1feb,1,-112},
+	{0x1fec,0x1fec,-1,-7},
+	{0x1ff8,0x1ff9,1,-128},
+	{0x1ffa,0x1ffb,1,-126},
+	{0x1ffc,0x1ffc,-1,-9},
+	{0x2126,0x2126,-1,-7517},
+	{0x212a,0x212a,-1,-8383},
+	{0x212b,0x212b,-1,-8262},
+	{0x2132,0x2132,-1,28},
+	{0x2160,0x216f,1,16},
+	{0x2183,0x2183,-1,1},
+	{0x24b6,0x24cf,1,26},
+	{0x2c00,0x2c2e,1,48},
+	{0x2c60,0x2c60,-1,1},
+	{0x2c62,0x2c62,-1,-10743},
+	{0x2c63,0x2c63,-1,-3814},
+	{0x2c64,0x2c64,-1,-10727},
+	{0x2c67,0x2c6b,2,1},
+	{0x2c6d,0x2c6d,-1,-10780},
+	{0x2c6e,0x2c6e,-1,-10749},
+	{0x2c6f,0x2c6f,-1,-10783},
+	{0x2c70,0x2c70,-1,-10782},
+	{0x2c72,0x2c75,3,1},
+	{0x2c7e,0x2c7f,1,-10815},
+	{0x2c80,0x2ce2,2,1},
+	{0x2ceb,0x2ced,2,1},
+	{0xa640,0xa65e,2,1},
+	{0xa662,0xa66c,2,1},
+	{0xa680,0xa696,2,1},
+	{0xa722,0xa72e,2,1},
+	{0xa732,0xa76e,2,1},
+	{0xa779,0xa77b,2,1},
+	{0xa77d,0xa77d,-1,-35332},
+	{0xa77e,0xa786,2,1},
+	{0xa78b,0xa78b,-1,1},
+	{0xff21,0xff3a,1,32},
 	{0x10400,0x10427,1,40}
 };
 
 static int utf_convert(int a, convertStruct table[], int tableSize);
 
@@ -2141,89 +2691,310 @@ utf_fold(a)
     int		a;
 {
     return utf_convert(a, foldCase, sizeof(foldCase));
 }
 
-/*
- * The following tables are built by upperLowerExtract.pl < UnicodeData.txt .
- * They must be in numeric order, because we use binary search on them.
- * An entry such as {0x41,0x5a,1,32} means that UCS-4 characters in the range
- * from 0x41 to 0x5a inclusive, stepping by 1, are switched to lower (for
- * example) by adding 32.
- */
 static convertStruct toLower[] =
 {
-	{0x41,0x5a,1,32}, {0xc0,0xd6,1,32}, {0xd8,0xde,1,32},
-	{0x100,0x12e,2,1}, {0x130,0x130,-1,-199}, {0x132,0x136,2,1},
-	{0x139,0x147,2,1}, {0x14a,0x176,2,1}, {0x178,0x178,-1,-121},
-	{0x179,0x17d,2,1}, {0x181,0x181,-1,210}, {0x182,0x184,2,1},
-	{0x186,0x186,-1,206}, {0x187,0x187,-1,1}, {0x189,0x18a,1,205},
-	{0x18b,0x18b,-1,1}, {0x18e,0x18e,-1,79}, {0x18f,0x18f,-1,202},
-	{0x190,0x190,-1,203}, {0x191,0x191,-1,1}, {0x193,0x193,-1,205},
-	{0x194,0x194,-1,207}, {0x196,0x196,-1,211}, {0x197,0x197,-1,209},
-	{0x198,0x198,-1,1}, {0x19c,0x19c,-1,211}, {0x19d,0x19d,-1,213},
-	{0x19f,0x19f,-1,214}, {0x1a0,0x1a4,2,1}, {0x1a6,0x1a6,-1,218},
-	{0x1a7,0x1a7,-1,1}, {0x1a9,0x1a9,-1,218}, {0x1ac,0x1ac,-1,1},
-	{0x1ae,0x1ae,-1,218}, {0x1af,0x1af,-1,1}, {0x1b1,0x1b2,1,217},
-	{0x1b3,0x1b5,2,1}, {0x1b7,0x1b7,-1,219}, {0x1b8,0x1bc,4,1},
-	{0x1c4,0x1ca,3,2}, {0x1cd,0x1db,2,1}, {0x1de,0x1ee,2,1},
-	{0x1f1,0x1f1,-1,2}, {0x1f4,0x1f4,-1,1}, {0x1f6,0x1f6,-1,-97},
-	{0x1f7,0x1f7,-1,-56}, {0x1f8,0x21e,2,1}, {0x220,0x220,-1,-130},
-	{0x222,0x232,2,1}, {0x386,0x386,-1,38}, {0x388,0x38a,1,37},
-	{0x38c,0x38c,-1,64}, {0x38e,0x38f,1,63}, {0x391,0x3a1,1,32},
-	{0x3a3,0x3ab,1,32}, {0x3d8,0x3ee,2,1}, {0x3f4,0x3f4,-1,-60},
-	{0x3f7,0x3f7,-1,1}, {0x3f9,0x3f9,-1,-7}, {0x3fa,0x3fa,-1,1},
-	{0x400,0x40f,1,80}, {0x410,0x42f,1,32}, {0x460,0x480,2,1},
-	{0x48a,0x4be,2,1}, {0x4c1,0x4cd,2,1}, {0x4d0,0x4f4,2,1},
-	{0x4f8,0x500,8,1}, {0x502,0x50e,2,1}, {0x531,0x556,1,48},
-	{0x1e00,0x1e94,2,1}, {0x1ea0,0x1ef8,2,1}, {0x1f08,0x1f0f,1,-8},
-	{0x1f18,0x1f1d,1,-8}, {0x1f28,0x1f2f,1,-8}, {0x1f38,0x1f3f,1,-8},
-	{0x1f48,0x1f4d,1,-8}, {0x1f59,0x1f5f,2,-8}, {0x1f68,0x1f6f,1,-8},
-	{0x1fb8,0x1fb9,1,-8}, {0x1fba,0x1fbb,1,-74}, {0x1fc8,0x1fcb,1,-86},
-	{0x1fd8,0x1fd9,1,-8}, {0x1fda,0x1fdb,1,-100}, {0x1fe8,0x1fe9,1,-8},
-	{0x1fea,0x1feb,1,-112}, {0x1fec,0x1fec,-1,-7}, {0x1ff8,0x1ff9,1,-128},
-	{0x1ffa,0x1ffb,1,-126}, {0x2126,0x2126,-1,-7517}, {0x212a,0x212a,-1,-8383},
-	{0x212b,0x212b,-1,-8262}, {0xff21,0xff3a,1,32}, {0x10400,0x10427,1,40}
+	{0x41,0x5a,1,32},
+	{0xc0,0xd6,1,32},
+	{0xd8,0xde,1,32},
+	{0x100,0x12e,2,1},
+	{0x130,0x130,-1,-199},
+	{0x132,0x136,2,1},
+	{0x139,0x147,2,1},
+	{0x14a,0x176,2,1},
+	{0x178,0x178,-1,-121},
+	{0x179,0x17d,2,1},
+	{0x181,0x181,-1,210},
+	{0x182,0x184,2,1},
+	{0x186,0x186,-1,206},
+	{0x187,0x187,-1,1},
+	{0x189,0x18a,1,205},
+	{0x18b,0x18b,-1,1},
+	{0x18e,0x18e,-1,79},
+	{0x18f,0x18f,-1,202},
+	{0x190,0x190,-1,203},
+	{0x191,0x191,-1,1},
+	{0x193,0x193,-1,205},
+	{0x194,0x194,-1,207},
+	{0x196,0x196,-1,211},
+	{0x197,0x197,-1,209},
+	{0x198,0x198,-1,1},
+	{0x19c,0x19c,-1,211},
+	{0x19d,0x19d,-1,213},
+	{0x19f,0x19f,-1,214},
+	{0x1a0,0x1a4,2,1},
+	{0x1a6,0x1a6,-1,218},
+	{0x1a7,0x1a7,-1,1},
+	{0x1a9,0x1a9,-1,218},
+	{0x1ac,0x1ac,-1,1},
+	{0x1ae,0x1ae,-1,218},
+	{0x1af,0x1af,-1,1},
+	{0x1b1,0x1b2,1,217},
+	{0x1b3,0x1b5,2,1},
+	{0x1b7,0x1b7,-1,219},
+	{0x1b8,0x1bc,4,1},
+	{0x1c4,0x1c4,-1,2},
+	{0x1c5,0x1c5,-1,1},
+	{0x1c7,0x1c7,-1,2},
+	{0x1c8,0x1c8,-1,1},
+	{0x1ca,0x1ca,-1,2},
+	{0x1cb,0x1db,2,1},
+	{0x1de,0x1ee,2,1},
+	{0x1f1,0x1f1,-1,2},
+	{0x1f2,0x1f4,2,1},
+	{0x1f6,0x1f6,-1,-97},
+	{0x1f7,0x1f7,-1,-56},
+	{0x1f8,0x21e,2,1},
+	{0x220,0x220,-1,-130},
+	{0x222,0x232,2,1},
+	{0x23a,0x23a,-1,10795},
+	{0x23b,0x23b,-1,1},
+	{0x23d,0x23d,-1,-163},
+	{0x23e,0x23e,-1,10792},
+	{0x241,0x241,-1,1},
+	{0x243,0x243,-1,-195},
+	{0x244,0x244,-1,69},
+	{0x245,0x245,-1,71},
+	{0x246,0x24e,2,1},
+	{0x370,0x372,2,1},
+	{0x376,0x376,-1,1},
+	{0x386,0x386,-1,38},
+	{0x388,0x38a,1,37},
+	{0x38c,0x38c,-1,64},
+	{0x38e,0x38f,1,63},
+	{0x391,0x3a1,1,32},
+	{0x3a3,0x3ab,1,32},
+	{0x3cf,0x3cf,-1,8},
+	{0x3d8,0x3ee,2,1},
+	{0x3f4,0x3f4,-1,-60},
+	{0x3f7,0x3f7,-1,1},
+	{0x3f9,0x3f9,-1,-7},
+	{0x3fa,0x3fa,-1,1},
+	{0x3fd,0x3ff,1,-130},
+	{0x400,0x40f,1,80},
+	{0x410,0x42f,1,32},
+	{0x460,0x480,2,1},
+	{0x48a,0x4be,2,1},
+	{0x4c0,0x4c0,-1,15},
+	{0x4c1,0x4cd,2,1},
+	{0x4d0,0x524,2,1},
+	{0x531,0x556,1,48},
+	{0x10a0,0x10c5,1,7264},
+	{0x1e00,0x1e94,2,1},
+	{0x1e9e,0x1e9e,-1,-7615},
+	{0x1ea0,0x1efe,2,1},
+	{0x1f08,0x1f0f,1,-8},
+	{0x1f18,0x1f1d,1,-8},
+	{0x1f28,0x1f2f,1,-8},
+	{0x1f38,0x1f3f,1,-8},
+	{0x1f48,0x1f4d,1,-8},
+	{0x1f59,0x1f5f,2,-8},
+	{0x1f68,0x1f6f,1,-8},
+	{0x1f88,0x1f8f,1,-8},
+	{0x1f98,0x1f9f,1,-8},
+	{0x1fa8,0x1faf,1,-8},
+	{0x1fb8,0x1fb9,1,-8},
+	{0x1fba,0x1fbb,1,-74},
+	{0x1fbc,0x1fbc,-1,-9},
+	{0x1fc8,0x1fcb,1,-86},
+	{0x1fcc,0x1fcc,-1,-9},
+	{0x1fd8,0x1fd9,1,-8},
+	{0x1fda,0x1fdb,1,-100},
+	{0x1fe8,0x1fe9,1,-8},
+	{0x1fea,0x1feb,1,-112},
+	{0x1fec,0x1fec,-1,-7},
+	{0x1ff8,0x1ff9,1,-128},
+	{0x1ffa,0x1ffb,1,-126},
+	{0x1ffc,0x1ffc,-1,-9},
+	{0x2126,0x2126,-1,-7517},
+	{0x212a,0x212a,-1,-8383},
+	{0x212b,0x212b,-1,-8262},
+	{0x2132,0x2132,-1,28},
+	{0x2160,0x216f,1,16},
+	{0x2183,0x2183,-1,1},
+	{0x24b6,0x24cf,1,26},
+	{0x2c00,0x2c2e,1,48},
+	{0x2c60,0x2c60,-1,1},
+	{0x2c62,0x2c62,-1,-10743},
+	{0x2c63,0x2c63,-1,-3814},
+	{0x2c64,0x2c64,-1,-10727},
+	{0x2c67,0x2c6b,2,1},
+	{0x2c6d,0x2c6d,-1,-10780},
+	{0x2c6e,0x2c6e,-1,-10749},
+	{0x2c6f,0x2c6f,-1,-10783},
+	{0x2c70,0x2c70,-1,-10782},
+	{0x2c72,0x2c75,3,1},
+	{0x2c7e,0x2c7f,1,-10815},
+	{0x2c80,0x2ce2,2,1},
+	{0x2ceb,0x2ced,2,1},
+	{0xa640,0xa65e,2,1},
+	{0xa662,0xa66c,2,1},
+	{0xa680,0xa696,2,1},
+	{0xa722,0xa72e,2,1},
+	{0xa732,0xa76e,2,1},
+	{0xa779,0xa77b,2,1},
+	{0xa77d,0xa77d,-1,-35332},
+	{0xa77e,0xa786,2,1},
+	{0xa78b,0xa78b,-1,1},
+	{0xff21,0xff3a,1,32},
+	{0x10400,0x10427,1,40}
 };
 
 static convertStruct toUpper[] =
 {
-	{0x61,0x7a,1,-32}, {0xb5,0xb5,-1,743}, {0xe0,0xf6,1,-32},
-	{0xf8,0xfe,1,-32}, {0xff,0xff,-1,121}, {0x101,0x12f,2,-1},
-	{0x131,0x131,-1,-232}, {0x133,0x137,2,-1}, {0x13a,0x148,2,-1},
-	{0x14b,0x177,2,-1}, {0x17a,0x17e,2,-1}, {0x17f,0x17f,-1,-300},
-	{0x183,0x185,2,-1}, {0x188,0x18c,4,-1}, {0x192,0x192,-1,-1},
-	{0x195,0x195,-1,97}, {0x199,0x199,-1,-1}, {0x19e,0x19e,-1,130},
-	{0x1a1,0x1a5,2,-1}, {0x1a8,0x1ad,5,-1}, {0x1b0,0x1b4,4,-1},
-	{0x1b6,0x1b9,3,-1}, {0x1bd,0x1bd,-1,-1}, {0x1bf,0x1bf,-1,56},
-	{0x1c5,0x1c6,1,-1}, {0x1c8,0x1c9,1,-1}, {0x1cb,0x1cc,1,-1},
-	{0x1ce,0x1dc,2,-1}, {0x1dd,0x1dd,-1,-79}, {0x1df,0x1ef,2,-1},
-	{0x1f2,0x1f3,1,-1}, {0x1f5,0x1f9,4,-1}, {0x1fb,0x21f,2,-1},
-	{0x223,0x233,2,-1}, {0x253,0x253,-1,-210}, {0x254,0x254,-1,-206},
-	{0x256,0x257,1,-205}, {0x259,0x259,-1,-202}, {0x25b,0x25b,-1,-203},
-	{0x260,0x260,-1,-205}, {0x263,0x263,-1,-207}, {0x268,0x268,-1,-209},
-	{0x269,0x26f,6,-211}, {0x272,0x272,-1,-213}, {0x275,0x275,-1,-214},
-	{0x280,0x283,3,-218}, {0x288,0x288,-1,-218}, {0x28a,0x28b,1,-217},
-	{0x292,0x292,-1,-219}, {0x3ac,0x3ac,-1,-38}, {0x3ad,0x3af,1,-37},
-	{0x3b1,0x3c1,1,-32}, {0x3c2,0x3c2,-1,-31}, {0x3c3,0x3cb,1,-32},
-	{0x3cc,0x3cc,-1,-64}, {0x3cd,0x3ce,1,-63}, {0x3d0,0x3d0,-1,-62},
-	{0x3d1,0x3d1,-1,-57}, {0x3d5,0x3d5,-1,-47}, {0x3d6,0x3d6,-1,-54},
-	{0x3d9,0x3ef,2,-1}, {0x3f0,0x3f0,-1,-86}, {0x3f1,0x3f1,-1,-80},
-	{0x3f2,0x3f2,-1,7}, {0x3f5,0x3f5,-1,-96}, {0x3f8,0x3fb,3,-1},
-	{0x430,0x44f,1,-32}, {0x450,0x45f,1,-80}, {0x461,0x481,2,-1},
-	{0x48b,0x4bf,2,-1}, {0x4c2,0x4ce,2,-1}, {0x4d1,0x4f5,2,-1},
-	{0x4f9,0x501,8,-1}, {0x503,0x50f,2,-1}, {0x561,0x586,1,-48},
-	{0x1e01,0x1e95,2,-1}, {0x1e9b,0x1e9b,-1,-59}, {0x1ea1,0x1ef9,2,-1},
-	{0x1f00,0x1f07,1,8}, {0x1f10,0x1f15,1,8}, {0x1f20,0x1f27,1,8},
-	{0x1f30,0x1f37,1,8}, {0x1f40,0x1f45,1,8}, {0x1f51,0x1f57,2,8},
-	{0x1f60,0x1f67,1,8}, {0x1f70,0x1f71,1,74}, {0x1f72,0x1f75,1,86},
-	{0x1f76,0x1f77,1,100}, {0x1f78,0x1f79,1,128}, {0x1f7a,0x1f7b,1,112},
-	{0x1f7c,0x1f7d,1,126}, {0x1f80,0x1f87,1,8}, {0x1f90,0x1f97,1,8},
-	{0x1fa0,0x1fa7,1,8}, {0x1fb0,0x1fb1,1,8}, {0x1fb3,0x1fb3,-1,9},
-	{0x1fbe,0x1fbe,-1,-7205}, {0x1fc3,0x1fc3,-1,9}, {0x1fd0,0x1fd1,1,8},
-	{0x1fe0,0x1fe1,1,8}, {0x1fe5,0x1fe5,-1,7}, {0x1ff3,0x1ff3,-1,9},
-	{0xff41,0xff5a,1,-32}, {0x10428,0x1044f,1,-40}
+	{0x61,0x7a,1,-32},
+	{0xb5,0xb5,-1,743},
+	{0xe0,0xf6,1,-32},
+	{0xf8,0xfe,1,-32},
+	{0xff,0xff,-1,121},
+	{0x101,0x12f,2,-1},
+	{0x131,0x131,-1,-232},
+	{0x133,0x137,2,-1},
+	{0x13a,0x148,2,-1},
+	{0x14b,0x177,2,-1},
+	{0x17a,0x17e,2,-1},
+	{0x17f,0x17f,-1,-300},
+	{0x180,0x180,-1,195},
+	{0x183,0x185,2,-1},
+	{0x188,0x18c,4,-1},
+	{0x192,0x192,-1,-1},
+	{0x195,0x195,-1,97},
+	{0x199,0x199,-1,-1},
+	{0x19a,0x19a,-1,163},
+	{0x19e,0x19e,-1,130},
+	{0x1a1,0x1a5,2,-1},
+	{0x1a8,0x1ad,5,-1},
+	{0x1b0,0x1b4,4,-1},
+	{0x1b6,0x1b9,3,-1},
+	{0x1bd,0x1bd,-1,-1},
+	{0x1bf,0x1bf,-1,56},
+	{0x1c5,0x1c5,-1,-1},
+	{0x1c6,0x1c6,-1,-2},
+	{0x1c8,0x1c8,-1,-1},
+	{0x1c9,0x1c9,-1,-2},
+	{0x1cb,0x1cb,-1,-1},
+	{0x1cc,0x1cc,-1,-2},
+	{0x1ce,0x1dc,2,-1},
+	{0x1dd,0x1dd,-1,-79},
+	{0x1df,0x1ef,2,-1},
+	{0x1f2,0x1f2,-1,-1},
+	{0x1f3,0x1f3,-1,-2},
+	{0x1f5,0x1f9,4,-1},
+	{0x1fb,0x21f,2,-1},
+	{0x223,0x233,2,-1},
+	{0x23c,0x23c,-1,-1},
+	{0x23f,0x240,1,10815},
+	{0x242,0x247,5,-1},
+	{0x249,0x24f,2,-1},
+	{0x250,0x250,-1,10783},
+	{0x251,0x251,-1,10780},
+	{0x252,0x252,-1,10782},
+	{0x253,0x253,-1,-210},
+	{0x254,0x254,-1,-206},
+	{0x256,0x257,1,-205},
+	{0x259,0x259,-1,-202},
+	{0x25b,0x25b,-1,-203},
+	{0x260,0x260,-1,-205},
+	{0x263,0x263,-1,-207},
+	{0x268,0x268,-1,-209},
+	{0x269,0x269,-1,-211},
+	{0x26b,0x26b,-1,10743},
+	{0x26f,0x26f,-1,-211},
+	{0x271,0x271,-1,10749},
+	{0x272,0x272,-1,-213},
+	{0x275,0x275,-1,-214},
+	{0x27d,0x27d,-1,10727},
+	{0x280,0x283,3,-218},
+	{0x288,0x288,-1,-218},
+	{0x289,0x289,-1,-69},
+	{0x28a,0x28b,1,-217},
+	{0x28c,0x28c,-1,-71},
+	{0x292,0x292,-1,-219},
+	{0x345,0x345,-1,84},
+	{0x371,0x373,2,-1},
+	{0x377,0x377,-1,-1},
+	{0x37b,0x37d,1,130},
+	{0x3ac,0x3ac,-1,-38},
+	{0x3ad,0x3af,1,-37},
+	{0x3b1,0x3c1,1,-32},
+	{0x3c2,0x3c2,-1,-31},
+	{0x3c3,0x3cb,1,-32},
+	{0x3cc,0x3cc,-1,-64},
+	{0x3cd,0x3ce,1,-63},
+	{0x3d0,0x3d0,-1,-62},
+	{0x3d1,0x3d1,-1,-57},
+	{0x3d5,0x3d5,-1,-47},
+	{0x3d6,0x3d6,-1,-54},
+	{0x3d7,0x3d7,-1,-8},
+	{0x3d9,0x3ef,2,-1},
+	{0x3f0,0x3f0,-1,-86},
+	{0x3f1,0x3f1,-1,-80},
+	{0x3f2,0x3f2,-1,7},
+	{0x3f5,0x3f5,-1,-96},
+	{0x3f8,0x3fb,3,-1},
+	{0x430,0x44f,1,-32},
+	{0x450,0x45f,1,-80},
+	{0x461,0x481,2,-1},
+	{0x48b,0x4bf,2,-1},
+	{0x4c2,0x4ce,2,-1},
+	{0x4cf,0x4cf,-1,-15},
+	{0x4d1,0x525,2,-1},
+	{0x561,0x586,1,-48},
+	{0x1d79,0x1d79,-1,35332},
+	{0x1d7d,0x1d7d,-1,3814},
+	{0x1e01,0x1e95,2,-1},
+	{0x1e9b,0x1e9b,-1,-59},
+	{0x1ea1,0x1eff,2,-1},
+	{0x1f00,0x1f07,1,8},
+	{0x1f10,0x1f15,1,8},
+	{0x1f20,0x1f27,1,8},
+	{0x1f30,0x1f37,1,8},
+	{0x1f40,0x1f45,1,8},
+	{0x1f51,0x1f57,2,8},
+	{0x1f60,0x1f67,1,8},
+	{0x1f70,0x1f71,1,74},
+	{0x1f72,0x1f75,1,86},
+	{0x1f76,0x1f77,1,100},
+	{0x1f78,0x1f79,1,128},
+	{0x1f7a,0x1f7b,1,112},
+	{0x1f7c,0x1f7d,1,126},
+	{0x1f80,0x1f87,1,8},
+	{0x1f90,0x1f97,1,8},
+	{0x1fa0,0x1fa7,1,8},
+	{0x1fb0,0x1fb1,1,8},
+	{0x1fb3,0x1fb3,-1,9},
+	{0x1fbe,0x1fbe,-1,-7205},
+	{0x1fc3,0x1fc3,-1,9},
+	{0x1fd0,0x1fd1,1,8},
+	{0x1fe0,0x1fe1,1,8},
+	{0x1fe5,0x1fe5,-1,7},
+	{0x1ff3,0x1ff3,-1,9},
+	{0x214e,0x214e,-1,-28},
+	{0x2170,0x217f,1,-16},
+	{0x2184,0x2184,-1,-1},
+	{0x24d0,0x24e9,1,-26},
+	{0x2c30,0x2c5e,1,-48},
+	{0x2c61,0x2c61,-1,-1},
+	{0x2c65,0x2c65,-1,-10795},
+	{0x2c66,0x2c66,-1,-10792},
+	{0x2c68,0x2c6c,2,-1},
+	{0x2c73,0x2c76,3,-1},
+	{0x2c81,0x2ce3,2,-1},
+	{0x2cec,0x2cee,2,-1},
+	{0x2d00,0x2d25,1,-7264},
+	{0xa641,0xa65f,2,-1},
+	{0xa663,0xa66d,2,-1},
+	{0xa681,0xa697,2,-1},
+	{0xa723,0xa72f,2,-1},
+	{0xa733,0xa76f,2,-1},
+	{0xa77a,0xa77c,2,-1},
+	{0xa77f,0xa787,2,-1},
+	{0xa78c,0xa78c,-1,-1},
+	{0xff41,0xff5a,1,-32},
+	{0x10428,0x1044f,1,-40}
 };
 
 /*
  * Return the upper-case equivalent of "a", which is a UCS-4 character.  Use
  * simple case folding.
@@ -2415,17 +3186,17 @@ show_utf8()
 }
 
 /*
  * mb_head_off() function pointer.
  * Return offset from "p" to the first byte of the character it points into.
+ * If "p" points to the NUL at the end of the string return 0.
  * Returns 0 when already at the first byte of a character.
  */
-/*ARGSUSED*/
     int
 latin_head_off(base, p)
-    char_u	*base;
-    char_u	*p;
+    char_u	*base UNUSED;
+    char_u	*p UNUSED;
 {
     return 0;
 }
 
     int
@@ -2435,11 +3206,11 @@ dbcs_head_off(base, p)
 {
     char_u	*q;
 
     /* It can't be a trailing byte when not using DBCS, at the start of the
      * string or the previous byte can't start a double-byte. */
-    if (p <= base || MB_BYTE2LEN(p[-1]) == 1)
+    if (p <= base || MB_BYTE2LEN(p[-1]) == 1 || *p == NUL)
 	return 0;
 
     /* This is slow: need to start at the base and go forward until the
      * byte we are looking for.  Return 1 when we went past it, 0 otherwise. */
     q = base;
@@ -2463,11 +3234,12 @@ dbcs_screen_head_off(base, p)
      * string or the previous byte can't start a double-byte.
      * For euc-jp an 0x8e byte in the previous cell always means we have a
      * lead byte in the current cell. */
     if (p <= base
 	    || (enc_dbcs == DBCS_JPNU && p[-1] == 0x8e)
-	    || MB_BYTE2LEN(p[-1]) == 1)
+	    || MB_BYTE2LEN(p[-1]) == 1
+	    || *p == NUL)
 	return 0;
 
     /* This is slow: need to start at the base and go forward until the
      * byte we are looking for.  Return 1 when we went past it, 0 otherwise.
      * For DBCS_JPNU look out for 0x8e, which means the second byte is not
@@ -2489,10 +3261,11 @@ utf_head_off(base, p)
     char_u	*p;
 {
     char_u	*q;
     char_u	*s;
     int		c;
+    int		len;
 #ifdef FEAT_ARABIC
     char_u	*j;
 #endif
 
     if (*p < 0x80)		/* be quick for ASCII */
@@ -2508,12 +3281,12 @@ utf_head_off(base, p)
 	/* Move q to the first byte of this char. */
 	while (q > base && (*q & 0xc0) == 0x80)
 	    --q;
 	/* Check for illegal sequence. Do allow an illegal byte after where we
 	 * started. */
-	if (utf8len_tab[*q] != (int)(s - q + 1)
-				       && utf8len_tab[*q] != (int)(p - q + 1))
+	len = utf8len_tab[*q];
+	if (len != (int)(s - q + 1) && len != (int)(p - q + 1))
 	    return 0;
 
 	if (q <= base)
 	    break;
 
@@ -2538,11 +3311,10 @@ utf_head_off(base, p)
     }
 
     return (int)(p - q);
 }
 
-#if defined(FEAT_EVAL) || defined(PROTO)
 /*
  * Copy a character from "*fp" to "*tp" and advance the pointers.
  */
     void
 mb_copy_char(fp, tp)
@@ -2553,11 +3325,10 @@ mb_copy_char(fp, tp)
 
     mch_memmove(*tp, *fp, (size_t)l);
     *tp += l;
     *fp += l;
 }
-#endif
 
 /*
  * Return the offset from "p" to the first byte of a character.  When "p" is
  * at the start of a character 0 is returned, otherwise the offset to the next
  * character.  Can start anywhere in a stream of bytes.
@@ -2723,13 +3494,13 @@ utf_valid_string(s, end)
     int		l;
     char_u	*p = s;
 
     while (end == NULL ? *p != NUL : p < end)
     {
-	if ((*p & 0xc0) == 0x80)
+	l = utf8len_tab_zero[*p];
+	if (l == 0)
 	    return FALSE;	/* invalid lead byte */
-	l = utf8len_tab[*p];
 	if (end != NULL && p + l > end)
 	    return FALSE;	/* incomplete byte sequence */
 	++p;
 	while (--l > 0)
 	    if ((*p++ & 0xc0) != 0x80)
@@ -3131,11 +3902,11 @@ enc_locale()
 	    s = buf + 10;
 	}
 	else
 	    s = p + 1;
     }
-    for (i = 0; s[i] != NUL && s + i < buf + sizeof(buf) - 1; ++i)
+    for (i = 0; s[i] != NUL && i < (int)sizeof(buf) - 1; ++i)
     {
 	if (s[i] == '_' || s[i] == '-')
 	    buf[i] = '-';
 	else if (isalnum((int)s[i]))
 	    buf[i] = TOLOWER_ASC(s[i]);
@@ -3178,11 +3949,11 @@ encname2codepage(name)
 }
 #endif
 
 # if defined(USE_ICONV) || defined(PROTO)
 
-static char_u *iconv_string __ARGS((vimconv_T *vcp, char_u *str, int slen, int *unconvlenp));
+static char_u *iconv_string __ARGS((vimconv_T *vcp, char_u *str, int slen, int *unconvlenp, int *resultlenp));
 
 /*
  * Call iconv_open() with a check if iconv() works properly (there are broken
  * versions).
  * Returns (void *)-1 if failed.
@@ -3239,17 +4010,19 @@ my_iconv_open(to, from)
 /*
  * Convert the string "str[slen]" with iconv().
  * If "unconvlenp" is not NULL handle the string ending in an incomplete
  * sequence and set "*unconvlenp" to the length of it.
  * Returns the converted string in allocated memory.  NULL for an error.
+ * If resultlenp is not NULL, sets it to the result length in bytes.
  */
     static char_u *
-iconv_string(vcp, str, slen, unconvlenp)
+iconv_string(vcp, str, slen, unconvlenp, resultlenp)
     vimconv_T	*vcp;
     char_u	*str;
     int		slen;
     int		*unconvlenp;
+    int		*resultlenp;
 {
     const char	*from;
     size_t	fromlen;
     char	*to;
     size_t	tolen;
@@ -3331,10 +4104,13 @@ iconv_string(vcp, str, slen, unconvlenp)
 	    break;
 	}
 	/* Not enough room or skipping illegal sequence. */
 	done = to - (char *)result;
     }
+
+    if (resultlenp != NULL)
+	*resultlenp = (int)(to - (char *)result);
     return result;
 }
 
 #  if defined(DYNAMIC_ICONV) || defined(PROTO)
 /*
@@ -3582,13 +4358,14 @@ im_show_info(void)
 
 /*
  * Callback invoked when the user finished preediting.
  * Put the final string into the input buffer.
  */
-/*ARGSUSED0*/
     static void
-im_commit_cb(GtkIMContext *context, const gchar *str, gpointer data)
+im_commit_cb(GtkIMContext *context UNUSED,
+	     const gchar *str,
+	     gpointer data UNUSED)
 {
     int	slen = (int)STRLEN(str);
     int	add_to_input = TRUE;
     int	clen;
     int	len = slen;
@@ -3670,13 +4447,12 @@ im_commit_cb(GtkIMContext *context, cons
 }
 
 /*
  * Callback invoked after start to the preedit.
  */
-/*ARGSUSED*/
     static void
-im_preedit_start_cb(GtkIMContext *context, gpointer data)
+im_preedit_start_cb(GtkIMContext *context UNUSED, gpointer data UNUSED)
 {
 #ifdef XIM_DEBUG
     xim_log("im_preedit_start_cb()\n");
 #endif
 
@@ -3687,13 +4463,12 @@ im_preedit_start_cb(GtkIMContext *contex
 }
 
 /*
  * Callback invoked after end to the preedit.
  */
-/*ARGSUSED*/
     static void
-im_preedit_end_cb(GtkIMContext *context, gpointer data)
+im_preedit_end_cb(GtkIMContext *context UNUSED, gpointer data UNUSED)
 {
 #ifdef XIM_DEBUG
     xim_log("im_preedit_end_cb()\n");
 #endif
     im_delete_preedit();
@@ -3748,13 +4523,12 @@ im_preedit_end_cb(GtkIMContext *context,
  * at the receiving end of the queue.  This, however, would have a rather large
  * impact on the code base.  If there is an easy way to force processing of all
  * remaining input from within the "retrieve_surrounding" signal handler, this
  * might not be necessary.  Gotta ask on vim-dev for opinions.
  */
-/*ARGSUSED1*/
     static void
-im_preedit_changed_cb(GtkIMContext *context, gpointer data)
+im_preedit_changed_cb(GtkIMContext *context, gpointer data UNUSED)
 {
     char    *preedit_string = NULL;
     int	    cursor_index    = 0;
     int	    num_move_back   = 0;
     char_u  *str;
@@ -4616,15 +5390,14 @@ xim_set_focus(focus)
 #endif
 	}
     }
 }
 
-/*ARGSUSED*/
     void
 im_set_position(row, col)
-    int		row;
-    int		col;
+    int		row UNUSED;
+    int		col UNUSED;
 {
     xim_set_preedit();
 }
 
 /*
@@ -4927,16 +5700,15 @@ static int xim_real_init __ARGS((Window
 
 #ifdef USE_X11R6_XIM
 static void xim_instantiate_cb __ARGS((Display *display, XPointer client_data, XPointer	call_data));
 static void xim_destroy_cb __ARGS((XIM im, XPointer client_data, XPointer call_data));
 
-/*ARGSUSED*/
     static void
 xim_instantiate_cb(display, client_data, call_data)
     Display	*display;
-    XPointer	client_data;
-    XPointer	call_data;
+    XPointer	client_data UNUSED;
+    XPointer	call_data UNUSED;
 {
     Window	x11_window;
     Display	*x11_display;
 
 #ifdef XIM_DEBUG
@@ -4952,16 +5724,15 @@ xim_instantiate_cb(display, client_data,
     if (xic != NULL)
 	XUnregisterIMInstantiateCallback(x11_display, NULL, NULL, NULL,
 					 xim_instantiate_cb, NULL);
 }
 
-/*ARGSUSED*/
     static void
 xim_destroy_cb(im, client_data, call_data)
-    XIM		im;
-    XPointer	client_data;
-    XPointer	call_data;
+    XIM		im UNUSED;
+    XPointer	client_data UNUSED;
+    XPointer	call_data UNUSED;
 {
     Window	x11_window;
     Display	*x11_display;
 
 #ifdef XIM_DEBUG
@@ -5276,13 +6047,14 @@ xim_decide_input_style()
 	    supported_style &= ~(int)GDK_IM_STATUS_AREA;
 	xim_input_style = (int)gdk_im_decide_style((GdkIMStyle)supported_style);
     }
 }
 
-/*ARGSUSED*/
     static void
-preedit_start_cbproc(XIC xic, XPointer client_data, XPointer call_data)
+preedit_start_cbproc(XIC thexic UNUSED,
+	             XPointer client_data UNUSED,
+		     XPointer call_data UNUSED)
 {
 #ifdef XIM_DEBUG
     xim_log("xim_decide_input_style()\n");
 #endif
 
@@ -5310,13 +6082,14 @@ xim_back_delete(int n)
 }
 
 static GSList *key_press_event_queue = NULL;
 static gboolean processing_queued_event = FALSE;
 
-/*ARGSUSED*/
     static void
-preedit_draw_cbproc(XIC xic, XPointer client_data, XPointer call_data)
+preedit_draw_cbproc(XIC thexic UNUSED,
+		    XPointer client_data UNUSED,
+		    XPointer call_data)
 {
     XIMPreeditDrawCallbackStruct *draw_data;
     XIMText	*text;
     char	*src;
     GSList	*event_queue;
@@ -5384,11 +6157,11 @@ preedit_draw_cbproc(XIC xic, XPointer cl
 		{
 		    if (draw_feedback == NULL)
 			draw_feedback = (char *)alloc(draw_data->chg_first
 							      + text->length);
 		    else
-			draw_feedback = realloc(draw_feedback,
+			draw_feedback = vim_realloc(draw_feedback,
 					 draw_data->chg_first + text->length);
 		    if (draw_feedback != NULL)
 		    {
 			draw_feedback[nfeedback + draw_data->chg_first]
 				       = draw_data->text->feedback[nfeedback];
@@ -5451,22 +6224,24 @@ im_get_feedback_attr(int col)
     }
 
     return -1;
 }
 
-/*ARGSUSED*/
     static void
-preedit_caret_cbproc(XIC xic, XPointer client_data, XPointer call_data)
+preedit_caret_cbproc(XIC thexic UNUSED,
+		     XPointer client_data UNUSED,
+		     XPointer call_data UNUSED)
 {
 #ifdef XIM_DEBUG
     xim_log("preedit_caret_cbproc()\n");
 #endif
 }
 
-/*ARGSUSED*/
     static void
-preedit_done_cbproc(XIC xic, XPointer client_data, XPointer call_data)
+preedit_done_cbproc(XIC thexic UNUSED,
+		    XPointer client_data UNUSED,
+		    XPointer call_data UNUSED)
 {
 #ifdef XIM_DEBUG
     xim_log("preedit_done_cbproc()\n");
 #endif
 
@@ -5501,13 +6276,12 @@ xim_reset(void)
 	if (text != NULL)
 	    XFree(text);
     }
 }
 
-/*ARGSUSED*/
     int
-xim_queue_key_press_event(GdkEventKey *event, int down)
+xim_queue_key_press_event(GdkEventKey *event, int down UNUSED)
 {
 #ifdef XIM_DEBUG
     xim_log("xim_queue_key_press_event()\n");
 #endif
 
@@ -5519,13 +6293,12 @@ xim_queue_key_press_event(GdkEventKey *e
     key_press_event_queue = g_slist_append(key_press_event_queue,
 					   gdk_event_copy((GdkEvent *)event));
     return TRUE;
 }
 
-/*ARGSUSED*/
     static void
-preedit_callback_setup(GdkIC *ic)
+preedit_callback_setup(GdkIC *ic UNUSED)
 {
     XIC xxic;
     XVaNestedList preedit_attr;
     XIMCallback preedit_start_cb;
     XIMCallback preedit_draw_cb;
@@ -5546,13 +6319,12 @@ preedit_callback_setup(GdkIC *ic)
 			       NULL);
     XSetICValues(xxic, XNPreeditAttributes, preedit_attr, NULL);
     XFree(preedit_attr);
 }
 
-/*ARGSUSED*/
     static void
-reset_state_setup(GdkIC *ic)
+reset_state_setup(GdkIC *ic UNUSED)
 {
 #ifdef USE_X11R6_XIM
     /* don't change the input context when we call reset */
     XSetICValues(((GdkICPrivate *)ic)->xic, XNResetState, XIMPreserveState,
 									NULL);
@@ -5754,12 +6526,29 @@ im_is_preediting()
 convert_setup(vcp, from, to)
     vimconv_T	*vcp;
     char_u	*from;
     char_u	*to;
 {
+    return convert_setup_ext(vcp, from, TRUE, to, TRUE);
+}
+
+/*
+ * As convert_setup(), but only when from_unicode_is_utf8 is TRUE will all
+ * "from" unicode charsets be considered utf-8.  Same for "to".
+ */
+    int
+convert_setup_ext(vcp, from, from_unicode_is_utf8, to, to_unicode_is_utf8)
+    vimconv_T	*vcp;
+    char_u	*from;
+    int		from_unicode_is_utf8;
+    char_u	*to;
+    int		to_unicode_is_utf8;
+{
     int		from_prop;
     int		to_prop;
+    int		from_is_utf8;
+    int		to_is_utf8;
 
     /* Reset to no conversion. */
 # ifdef USE_ICONV
     if (vcp->vc_type == CONV_ICONV && vcp->vc_fd != (iconv_t)-1)
 	iconv_close(vcp->vc_fd);
@@ -5773,69 +6562,78 @@ convert_setup(vcp, from, to)
 						     || STRCMP(from, to) == 0)
 	return OK;
 
     from_prop = enc_canon_props(from);
     to_prop = enc_canon_props(to);
-    if ((from_prop & ENC_LATIN1) && (to_prop & ENC_UNICODE))
+    if (from_unicode_is_utf8)
+	from_is_utf8 = from_prop & ENC_UNICODE;
+    else
+	from_is_utf8 = from_prop == ENC_UNICODE;
+    if (to_unicode_is_utf8)
+	to_is_utf8 = to_prop & ENC_UNICODE;
+    else
+	to_is_utf8 = to_prop == ENC_UNICODE;
+
+    if ((from_prop & ENC_LATIN1) && to_is_utf8)
     {
 	/* Internal latin1 -> utf-8 conversion. */
 	vcp->vc_type = CONV_TO_UTF8;
 	vcp->vc_factor = 2;	/* up to twice as long */
     }
-    else if ((from_prop & ENC_LATIN9) && (to_prop & ENC_UNICODE))
+    else if ((from_prop & ENC_LATIN9) && to_is_utf8)
     {
 	/* Internal latin9 -> utf-8 conversion. */
 	vcp->vc_type = CONV_9_TO_UTF8;
 	vcp->vc_factor = 3;	/* up to three as long (euro sign) */
     }
-    else if ((from_prop & ENC_UNICODE) && (to_prop & ENC_LATIN1))
+    else if (from_is_utf8 && (to_prop & ENC_LATIN1))
     {
 	/* Internal utf-8 -> latin1 conversion. */
 	vcp->vc_type = CONV_TO_LATIN1;
     }
-    else if ((from_prop & ENC_UNICODE) && (to_prop & ENC_LATIN9))
+    else if (from_is_utf8 && (to_prop & ENC_LATIN9))
     {
 	/* Internal utf-8 -> latin9 conversion. */
 	vcp->vc_type = CONV_TO_LATIN9;
     }
 #ifdef WIN3264
     /* Win32-specific codepage <-> codepage conversion without iconv. */
-    else if (((from_prop & ENC_UNICODE) || encname2codepage(from) > 0)
-	    && ((to_prop & ENC_UNICODE) || encname2codepage(to) > 0))
+    else if ((from_is_utf8 || encname2codepage(from) > 0)
+	    && (to_is_utf8 || encname2codepage(to) > 0))
     {
 	vcp->vc_type = CONV_CODEPAGE;
 	vcp->vc_factor = 2;	/* up to twice as long */
-	vcp->vc_cpfrom = (from_prop & ENC_UNICODE) ? 0 : encname2codepage(from);
-	vcp->vc_cpto = (to_prop & ENC_UNICODE) ? 0 : encname2codepage(to);
+	vcp->vc_cpfrom = from_is_utf8 ? 0 : encname2codepage(from);
+	vcp->vc_cpto = to_is_utf8 ? 0 : encname2codepage(to);
     }
 #endif
 #ifdef MACOS_X
     else if ((from_prop & ENC_MACROMAN) && (to_prop & ENC_LATIN1))
     {
 	vcp->vc_type = CONV_MAC_LATIN1;
     }
-    else if ((from_prop & ENC_MACROMAN) && (to_prop & ENC_UNICODE))
+    else if ((from_prop & ENC_MACROMAN) && to_is_utf8)
     {
 	vcp->vc_type = CONV_MAC_UTF8;
 	vcp->vc_factor = 2;	/* up to twice as long */
     }
     else if ((from_prop & ENC_LATIN1) && (to_prop & ENC_MACROMAN))
     {
 	vcp->vc_type = CONV_LATIN1_MAC;
     }
-    else if ((from_prop & ENC_UNICODE) && (to_prop & ENC_MACROMAN))
+    else if (from_is_utf8 && (to_prop & ENC_MACROMAN))
     {
 	vcp->vc_type = CONV_UTF8_MAC;
     }
 #endif
 # ifdef USE_ICONV
     else
     {
 	/* Use iconv() for conversion. */
 	vcp->vc_fd = (iconv_t)my_iconv_open(
-		(to_prop & ENC_UNICODE) ? (char_u *)"utf-8" : to,
-		(from_prop & ENC_UNICODE) ? (char_u *)"utf-8" : from);
+		to_is_utf8 ? (char_u *)"utf-8" : to,
+		from_is_utf8 ? (char_u *)"utf-8" : from);
 	if (vcp->vc_fd != (iconv_t)-1)
 	{
 	    vcp->vc_type = CONV_ICONV;
 	    vcp->vc_factor = 4;	/* could be longer too... */
 	}
@@ -6003,16 +6801,24 @@ string_convert_ext(vcp, ptr, lenp, uncon
 	    if (retval == NULL)
 		break;
 	    d = retval;
 	    for (i = 0; i < len; ++i)
 	    {
-		l = utf_ptr2len(ptr + i);
+		l = utf_ptr2len_len(ptr + i, len - i);
 		if (l == 0)
 		    *d++ = NUL;
 		else if (l == 1)
 		{
-		    if (unconvlenp != NULL && utf8len_tab[ptr[i]] > len - i)
+		    int l_w = utf8len_tab_zero[ptr[i]];
+
+		    if (l_w == 0)
+		    {
+			/* Illegal utf-8 byte cannot be converted */
+			vim_free(retval);
+			return NULL;
+		    }
+		    if (unconvlenp != NULL && l_w > len - i)
 		    {
 			/* Incomplete sequence at the end. */
 			*unconvlenp = len - i;
 			break;
 		    }
@@ -6087,13 +6893,11 @@ string_convert_ext(vcp, ptr, lenp, uncon
 	    break;
 # endif
 
 # ifdef USE_ICONV
 	case CONV_ICONV:	/* conversion with output_conv.vc_fd */
-	    retval = iconv_string(vcp, ptr, len, unconvlenp);
-	    if (retval != NULL && lenp != NULL)
-		*lenp = (int)STRLEN(retval);
+	    retval = iconv_string(vcp, ptr, len, unconvlenp, lenp);
 	    break;
 # endif
 # ifdef WIN3264
 	case CONV_CODEPAGE:		/* codepage -> codepage */
 	{
@@ -6101,33 +6905,33 @@ string_convert_ext(vcp, ptr, lenp, uncon
 	    int		tmp_len;
 	    short_u	*tmp;
 
 	    /* 1. codepage/UTF-8  ->  ucs-2. */
 	    if (vcp->vc_cpfrom == 0)
-		tmp_len = utf8_to_ucs2(ptr, len, NULL, NULL);
+		tmp_len = utf8_to_utf16(ptr, len, NULL, NULL);
 	    else
 		tmp_len = MultiByteToWideChar(vcp->vc_cpfrom, 0,
 							      ptr, len, 0, 0);
 	    tmp = (short_u *)alloc(sizeof(short_u) * tmp_len);
 	    if (tmp == NULL)
 		break;
 	    if (vcp->vc_cpfrom == 0)
-		utf8_to_ucs2(ptr, len, tmp, unconvlenp);
+		utf8_to_utf16(ptr, len, tmp, unconvlenp);
 	    else
 		MultiByteToWideChar(vcp->vc_cpfrom, 0, ptr, len, tmp, tmp_len);
 
 	    /* 2. ucs-2  ->  codepage/UTF-8. */
 	    if (vcp->vc_cpto == 0)
-		retlen = ucs2_to_utf8(tmp, tmp_len, NULL);
+		retlen = utf16_to_utf8(tmp, tmp_len, NULL);
 	    else
 		retlen = WideCharToMultiByte(vcp->vc_cpto, 0,
 						    tmp, tmp_len, 0, 0, 0, 0);
 	    retval = alloc(retlen + 1);
 	    if (retval != NULL)
 	    {
 		if (vcp->vc_cpto == 0)
-		    ucs2_to_utf8(tmp, tmp_len, retval);
+		    utf16_to_utf8(tmp, tmp_len, retval);
 		else
 		    WideCharToMultiByte(vcp->vc_cpto, 0,
 					  tmp, tmp_len, retval, retlen, 0, 0);
 		retval[retlen] = NUL;
 		if (lenp != NULL)
--- vim72.orig/src/misc2.c
+++ vim72/src/misc2.c
@@ -154,11 +154,11 @@ coladvance2(pos, addspaces, finetune, wc
 #endif
 #ifdef FEAT_VIRTUALEDIT
 		    || ((ve_flags & VE_ONEMORE) && wcol < MAXCOL)
 #endif
 		    ;
-    line = ml_get_curline();
+    line = ml_get_buf(curbuf, pos->lnum, FALSE);
 
     if (wcol >= MAXCOL)
     {
 	    idx = (int)STRLEN(line) - 1 + one_more;
 	    col = wcol;
@@ -330,13 +330,13 @@ coladvance2(pos, addspaces, finetune, wc
 	}
     }
 #endif
 
 #ifdef FEAT_MBYTE
-    /* prevent cursor from moving on the trail byte */
+    /* prevent from moving onto a trail byte */
     if (has_mbyte)
-	mb_adjust_cursor();
+	mb_adjustpos(pos);
 #endif
 
     if (col < wcol)
 	return FAIL;
     return OK;
@@ -494,11 +494,12 @@ check_cursor_lnum()
     void
 check_cursor_col()
 {
     colnr_T len;
 #ifdef FEAT_VIRTUALEDIT
-    colnr_T oldcol = curwin->w_cursor.col + curwin->w_cursor.coladd;
+    colnr_T oldcol = curwin->w_cursor.col;
+    colnr_T oldcoladd = curwin->w_cursor.col + curwin->w_cursor.coladd;
 #endif
 
     len = (colnr_T)STRLEN(ml_get_curline());
     if (len == 0)
 	curwin->w_cursor.col = 0;
@@ -525,19 +526,27 @@ check_cursor_col()
 	    if (has_mbyte)
 		mb_adjust_cursor();
 #endif
 	}
     }
+    else if (curwin->w_cursor.col < 0)
+	curwin->w_cursor.col = 0;
 
 #ifdef FEAT_VIRTUALEDIT
     /* If virtual editing is on, we can leave the cursor on the old position,
      * only we must set it to virtual.  But don't do it when at the end of the
      * line. */
     if (oldcol == MAXCOL)
 	curwin->w_cursor.coladd = 0;
     else if (ve_flags == VE_ALL)
-	curwin->w_cursor.coladd = oldcol - curwin->w_cursor.col;
+    {
+	if (oldcoladd > curwin->w_cursor.col)
+	    curwin->w_cursor.coladd = oldcoladd - curwin->w_cursor.col;
+	else
+	    /* avoid weird number when there is a miscalculation or overflow */
+	    curwin->w_cursor.coladd = 0;
+    }
 #endif
 }
 
 /*
  * make sure curwin->w_cursor in on a valid character
@@ -871,11 +880,11 @@ lalloc(size, message)
 	    allocated = 0;
 # endif
 	    /* 3. check for available memory: call mch_avail_mem() */
 	    if (mch_avail_mem(TRUE) < KEEP_ROOM && !releasing)
 	    {
-		vim_free((char *)p);	/* System is low... no go! */
+		free((char *)p);	/* System is low... no go! */
 		p = NULL;
 	    }
 	    else
 		goto theend;
 #endif
@@ -996,22 +1005,30 @@ free_all_mem()
 # endif
 
 # ifdef FEAT_MENU
     /* Clear menus. */
     do_cmdline_cmd((char_u *)"aunmenu *");
+#  ifdef FEAT_MULTI_LANG
+    do_cmdline_cmd((char_u *)"menutranslate clear");
+#  endif
 # endif
 
     /* Clear mappings, abbreviations, breakpoints. */
+    do_cmdline_cmd((char_u *)"lmapclear");
+    do_cmdline_cmd((char_u *)"xmapclear");
     do_cmdline_cmd((char_u *)"mapclear");
     do_cmdline_cmd((char_u *)"mapclear!");
     do_cmdline_cmd((char_u *)"abclear");
 # if defined(FEAT_EVAL)
     do_cmdline_cmd((char_u *)"breakdel *");
 # endif
 # if defined(FEAT_PROFILE)
     do_cmdline_cmd((char_u *)"profdel *");
 # endif
+# if defined(FEAT_KEYMAP)
+    do_cmdline_cmd((char_u *)"set keymap=");
+#endif
 
 # ifdef FEAT_TITLE
     free_titles();
 # endif
 # if defined(FEAT_SEARCHPATH)
@@ -1032,10 +1049,13 @@ free_all_mem()
     free_last_insert();
     free_prev_shellcmd();
     free_regexp_stuff();
     free_tag_stuff();
     free_cd_dir();
+# ifdef FEAT_SIGNS
+    free_signs();
+# endif
 # ifdef FEAT_EVAL
     set_expr_line(NULL);
 # endif
 # ifdef FEAT_DIFF
     diff_clear(curtab);
@@ -1060,15 +1080,16 @@ free_all_mem()
     init_history();
 # endif
 
 #ifdef FEAT_QUICKFIX
     {
-	win_T	*win;
+	win_T	    *win;
+	tabpage_T   *tab;
 
 	qf_free_all(NULL);
 	/* Free all location lists */
-	FOR_ALL_WINDOWS(win)
+	FOR_ALL_TAB_WINDOWS(tab, win)
 	    qf_free_all(win);
     }
 #endif
 
     /* Close all script inputs. */
@@ -1255,25 +1276,22 @@ vim_strsave_escaped_ext(string, esc_char
 	*p2 = NUL;
     }
     return escaped_string;
 }
 
-#if !defined(BACKSLASH_IN_FILENAME) || defined(FEAT_EVAL) || defined(PROTO)
 /*
  * Return TRUE when 'shell' has "csh" in the tail.
  */
     int
 csh_like_shell()
 {
     return (strstr((char *)gettail(p_sh), "csh") != NULL);
 }
-#endif
 
-#if defined(FEAT_EVAL) || defined(PROTO)
 /*
  * Escape "string" for use as a shell argument with system().
- * This uses single quotes, except when we know we need to use double qoutes
+ * This uses single quotes, except when we know we need to use double quotes
  * (MS-DOS and MS-Windows without 'shellslash' set).
  * Escape a newline, depending on the 'shell' option.
  * When "do_special" is TRUE also replace "!", "%", "#" and things starting
  * with "<" like "<cfile>".
  * Returns the result in allocated memory, NULL if we have run out.
@@ -1372,10 +1390,11 @@ vim_strsave_shellescape(string, do_speci
 	    if (do_special && find_cmdline_var(p, &l) >= 0)
 	    {
 		*d++ = '\\';		/* insert backslash */
 		while (--l >= 0)	/* copy the var */
 		    *d++ = *p++;
+		continue;
 	    }
 
 	    MB_COPY_CHAR(p, d);
 	}
 
@@ -1389,11 +1408,10 @@ vim_strsave_shellescape(string, do_speci
 	*d = NUL;
     }
 
     return escaped_string;
 }
-#endif
 
 /*
  * Like vim_strsave(), but make all characters uppercase.
  * This uses ASCII lower-to-upper case translation, language independent.
  */
@@ -1525,11 +1543,11 @@ copy_spaces(ptr, count)
 }
 
 #if defined(FEAT_VISUALEXTRA) || defined(PROTO)
 /*
  * Copy a character a number of times.
- * Does not work for multi-byte charactes!
+ * Does not work for multi-byte characters!
  */
     void
 copy_chars(ptr, count, c)
     char_u	*ptr;
     size_t	count;
@@ -2563,11 +2581,11 @@ trans_special(srcp, dst, keycode)
 {
     int		modifiers = 0;
     int		key;
     int		dlen = 0;
 
-    key = find_special_key(srcp, &modifiers, keycode);
+    key = find_special_key(srcp, &modifiers, keycode, FALSE);
     if (key == 0)
 	return 0;
 
     /* Put the appropriate modifier in a string */
     if (modifiers != 0)
@@ -2599,14 +2617,15 @@ trans_special(srcp, dst, keycode)
  * Try translating a <> name at (*srcp)[], return the key and modifiers.
  * srcp is advanced to after the <> name.
  * returns 0 if there is no match.
  */
     int
-find_special_key(srcp, modp, keycode)
+find_special_key(srcp, modp, keycode, keep_x_key)
     char_u	**srcp;
     int		*modp;
-    int		keycode; /* prefer key code, e.g. K_DEL instead of DEL */
+    int		keycode;     /* prefer key code, e.g. K_DEL instead of DEL */
+    int		keep_x_key;  /* don't translate xHome to Home key */
 {
     char_u	*last_dash;
     char_u	*end_of_name;
     char_u	*src;
     char_u	*bp;
@@ -2670,11 +2689,12 @@ find_special_key(srcp, modp, keycode)
 	    if (modifiers != 0 && last_dash[2] == '>')
 		key = last_dash[1];
 	    else
 	    {
 		key = get_special_key_code(last_dash + 1);
-		key = handle_x_keys(key);
+		if (!keep_x_key)
+		    key = handle_x_keys(key);
 	    }
 
 	    /*
 	     * get_special_key_code() may return NUL for invalid
 	     * special key name.
@@ -2827,11 +2847,11 @@ get_special_key_code(name)
 #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
     char_u *
 get_key_name(i)
     int	    i;
 {
-    if (i >= KEY_NAMES_TABLE_LEN)
+    if (i >= (int)KEY_NAMES_TABLE_LEN)
 	return NULL;
     return  key_names_table[i].name;
 }
 #endif
 
@@ -3855,11 +3875,12 @@ typedef struct ff_visited
 #endif
     /* for unix use inode etc for comparison (needed because of links), else
      * use filename.
      */
 #ifdef UNIX
-    int			ffv_dev;	/* device number (-1 if not set) */
+    int			ffv_dev_valid;	/* ffv_dev and ffv_ino were set */
+    dev_t		ffv_dev;	/* device number */
     ino_t		ffv_ino;	/* inode number */
 #endif
     /* The memory for this struct is allocated according to the length of
      * ffv_fname.
      */
@@ -4045,17 +4066,16 @@ vim_findnext()
  * must be NULL.
  *
  * This function silently ignores a few errors, vim_findfile() will have
  * limited functionality then.
  */
-/*ARGSUSED*/
     void *
 vim_findfile_init(path, filename, stopdirs, level, free_visited, find_what,
 					   search_ctx_arg, tagfile, rel_fname)
     char_u	*path;
     char_u	*filename;
-    char_u	*stopdirs;
+    char_u	*stopdirs UNUSED;
     int		level;
     int		free_visited;
     int		find_what;
     void	*search_ctx_arg;
     int		tagfile;
@@ -4246,11 +4266,11 @@ vim_findfile_init(path, filename, stopdi
 	 * The octet after a '**' is used as a (binary) counter.
 	 * So '**3' is transposed to '**^C' ('^C' is ASCII value 3)
 	 * or '**76' is transposed to '**N'( 'N' is ASCII value 76).
 	 * For EBCDIC you get different character values.
 	 * If no restrict is given after '**' the default is used.
-	 * Due to this technic the path looks awful if you print it as a
+	 * Due to this technique the path looks awful if you print it as a
 	 * string.
 	 */
 	len = 0;
 	while (*wc_part != NUL)
 	{
@@ -4635,11 +4655,11 @@ vim_findfile(search_ctx_arg)
 		    {
 			if (!path_with_url(stackp->ffs_filearray[i])
 				      && !mch_isdir(stackp->ffs_filearray[i]))
 			    continue;   /* not a directory */
 
-			/* prepare the filename to be checked for existance
+			/* prepare the filename to be checked for existence
 			 * below */
 			STRCPY(file_path, stackp->ffs_filearray[i]);
 			add_pathsep(file_path);
 			STRCAT(file_path, search_ctx->ffsc_file_to_search);
 
@@ -4696,11 +4716,12 @@ vim_findfile(search_ctx_arg)
 
 				/* push dir to examine rest of subdirs later */
 				stackp->ffs_filearray_cur = i + 1;
 				ff_push(search_ctx, stackp);
 
-				simplify_filename(file_path);
+				if (!path_with_url(file_path))
+				    simplify_filename(file_path);
 				if (mch_dirname(ff_expand_buffer, MAXPATHL)
 									== OK)
 				{
 				    p = shorten_fname(file_path,
 							    ff_expand_buffer);
@@ -5048,14 +5069,13 @@ ff_check_visited(visited_list, fname
     /* check against list of already visited files */
     for (vp = *visited_list; vp != NULL; vp = vp->ffv_next)
     {
 	if (
 #ifdef UNIX
-		!url
-		    ? (vp->ffv_dev == st.st_dev
-			&& vp->ffv_ino == st.st_ino)
-		    :
+		!url ? (vp->ffv_dev_valid && vp->ffv_dev == st.st_dev
+						  && vp->ffv_ino == st.st_ino)
+		     :
 #endif
 		fnamecmp(vp->ffv_fname, ff_expand_buffer) == 0
 	   )
 	{
 #ifdef FEAT_PATH_EXTRA
@@ -5076,18 +5096,18 @@ ff_check_visited(visited_list, fname
     if (vp != NULL)
     {
 #ifdef UNIX
 	if (!url)
 	{
+	    vp->ffv_dev_valid = TRUE;
 	    vp->ffv_ino = st.st_ino;
 	    vp->ffv_dev = st.st_dev;
 	    vp->ffv_fname[0] = NUL;
 	}
 	else
 	{
-	    vp->ffv_ino = 0;
-	    vp->ffv_dev = -1;
+	    vp->ffv_dev_valid = FALSE;
 #endif
 	    STRCPY(vp->ffv_fname, ff_expand_buffer);
 #ifdef UNIX
 	}
 #endif
@@ -5424,11 +5444,11 @@ find_file_in_path_option(ptr, len, optio
 	    /* "..", "../path", "." and "./path": don't use the path_option */
 	    || rel_to_curdir
 #if defined(MSWIN) || defined(MSDOS) || defined(OS2)
 	    /* handle "\tmp" as absolute path */
 	    || vim_ispathsep(ff_file_to_find[0])
-	    /* handle "c:name" as absulute path */
+	    /* handle "c:name" as absolute path */
 	    || (ff_file_to_find[0] != NUL && ff_file_to_find[1] == ':')
 #endif
 #ifdef AMIGA
 	    /* handle ":tmp" as absolute path */
 	    || ff_file_to_find[0] == ':'
@@ -5667,11 +5687,11 @@ qsort(base, elm_count, elm_size, cmp)
 		/* Compare the elements. */
 		p1 = (char_u *)base + j * elm_size;
 		p2 = (char_u *)base + (j + gap) * elm_size;
 		if ((*cmp)((void *)p1, (void *)p2) <= 0)
 		    break;
-		/* Exchange the elemets. */
+		/* Exchange the elements. */
 		mch_memmove(buf, p1, elm_size);
 		mch_memmove(p1, p2, elm_size);
 		mch_memmove(p2, buf, elm_size);
 	    }
 
--- vim72.orig/src/normal.c
+++ vim72/src/normal.c
@@ -181,10 +181,12 @@ static void	nv_drop __ARGS((cmdarg_T *ca
 #endif
 #ifdef FEAT_AUTOCMD
 static void	nv_cursorhold __ARGS((cmdarg_T *cap));
 #endif
 
+static char *e_noident = N_("E349: No identifier under cursor");
+
 /*
  * Function to be called for a Normal or Visual mode command.
  * The argument is a cmdarg_T.
  */
 typedef void (*nv_func_T) __ARGS((cmdarg_T *cap));
@@ -489,18 +491,18 @@ nv_compare(s1, s2)
 init_normal_cmds()
 {
     int		i;
 
     /* Fill the index table with a one to one relation. */
-    for (i = 0; i < NV_CMDS_SIZE; ++i)
+    for (i = 0; i < (int)NV_CMDS_SIZE; ++i)
 	nv_cmd_idx[i] = i;
 
     /* Sort the commands by the command character.  */
     qsort((void *)&nv_cmd_idx, (size_t)NV_CMDS_SIZE, sizeof(short), nv_compare);
 
     /* Find the first entry that can't be indexed by the command character. */
-    for (i = 0; i < NV_CMDS_SIZE; ++i)
+    for (i = 0; i < (int)NV_CMDS_SIZE; ++i)
 	if (i != nv_cmds[nv_cmd_idx[i]].cmd_char)
 	    break;
     nv_max_linear = i - 1;
 }
 
@@ -557,15 +559,14 @@ find_command(cmdchar)
 }
 
 /*
  * Execute a command in Normal mode.
  */
-/*ARGSUSED*/
     void
 normal_cmd(oap, toplevel)
     oparg_T	*oap;
-    int		toplevel;		/* TRUE when called from main() */
+    int		toplevel UNUSED;	/* TRUE when called from main() */
 {
     cmdarg_T	ca;			/* command arguments */
     int		c;
     int		ctrl_w = FALSE;		/* got CTRL-W command */
     int		old_col = curwin->w_curswant;
@@ -576,10 +577,13 @@ normal_cmd(oap, toplevel)
     pos_T	old_pos;		/* cursor position before command */
     int		mapped_len;
     static int	old_mapped_len = 0;
 #endif
     int		idx;
+#ifdef FEAT_EVAL
+    int		set_prevcount = FALSE;
+#endif
 
     vim_memset(&ca, 0, sizeof(ca));	/* also resets ca.retval */
     ca.oap = oap;
 
     /* Use a count remembered from before entering an operator.  After typing
@@ -611,11 +615,16 @@ normal_cmd(oap, toplevel)
 #endif
 
     /* When not finishing an operator and no register name typed, reset the
      * count. */
     if (!finish_op && !oap->regname)
+    {
 	ca.opcount = 0;
+#ifdef FEAT_EVAL
+	set_prevcount = TRUE;
+#endif
+    }
 
 #ifdef FEAT_AUTOCMD
     /* Restore counts from before receiving K_CURSORHOLD.  This means after
      * typing "3", handling K_CURSORHOLD and then typing "2" we get "32", not
      * "3 * 2". */
@@ -639,14 +648,11 @@ normal_cmd(oap, toplevel)
 
     /*
      * Get the command character from the user.
      */
     c = safe_vgetc();
-
-#ifdef FEAT_LANGMAP
     LANGMAP_ADJUST(c, TRUE);
-#endif
 
 #ifdef FEAT_VISUAL
     /*
      * If a mapping was started in Visual or Select mode, remember the length
      * of the mapping.  This is used below to not return to Insert mode for as
@@ -715,22 +721,28 @@ getcount:
 #ifdef FEAT_EVAL
 	    /* Set v:count here, when called from main() and not a stuffed
 	     * command, so that v:count can be used in an expression mapping
 	     * right after the count. */
 	    if (toplevel && stuff_empty())
-		set_vcount(ca.count0, ca.count0 == 0 ? 1 : ca.count0);
+	    {
+		long count = ca.count0;
+
+		/* multiply with ca.opcount the same way as below */
+		if (ca.opcount != 0)
+		    count = ca.opcount * (count == 0 ? 1 : count);
+		set_vcount(count, count == 0 ? 1 : count, set_prevcount);
+		set_prevcount = FALSE;  /* only set v:prevcount once */
+	    }
 #endif
 	    if (ctrl_w)
 	    {
 		++no_mapping;
 		++allow_keys;		/* no mapping for nchar, but keys */
 	    }
 	    ++no_zero_mapping;		/* don't map zero here */
 	    c = plain_vgetc();
-#ifdef FEAT_LANGMAP
 	    LANGMAP_ADJUST(c, TRUE);
-#endif
 	    --no_zero_mapping;
 	    if (ctrl_w)
 	    {
 		--no_mapping;
 		--allow_keys;
@@ -749,13 +761,11 @@ getcount:
 	    ca.opcount = ca.count0;	/* remember first count */
 	    ca.count0 = 0;
 	    ++no_mapping;
 	    ++allow_keys;		/* no mapping for nchar, but keys */
 	    c = plain_vgetc();		/* get next character */
-#ifdef FEAT_LANGMAP
 	    LANGMAP_ADJUST(c, TRUE);
-#endif
 	    --no_mapping;
 	    --allow_keys;
 #ifdef FEAT_CMDL_INFO
 	    need_flushbuf |= add_to_showcmd(c);
 #endif
@@ -802,11 +812,11 @@ getcount:
 #ifdef FEAT_EVAL
     /*
      * Only set v:count when called from main() and not a stuffed command.
      */
     if (toplevel && stuff_empty())
-	set_vcount(ca.count0, ca.count1);
+	set_vcount(ca.count0, ca.count1, set_prevcount);
 #endif
 
     /*
      * Find the command character in the table of commands.
      * For CTRL-W we already got nchar when looking for a count.
@@ -939,13 +949,11 @@ getcount:
 	    /*
 	     * For 'g' get the next character now, so that we can check for
 	     * "gr", "g'" and "g`".
 	     */
 	    ca.nchar = plain_vgetc();
-#ifdef FEAT_LANGMAP
 	    LANGMAP_ADJUST(ca.nchar, TRUE);
-#endif
 #ifdef FEAT_CMDL_INFO
 	    need_flushbuf |= add_to_showcmd(ca.nchar);
 #endif
 	    if (ca.nchar == 'r' || ca.nchar == '\'' || ca.nchar == '`'
 						      || ca.nchar == Ctrl_BSL)
@@ -1042,14 +1050,12 @@ getcount:
 # endif
 		    }
 		}
 #endif
 
-#ifdef FEAT_LANGMAP
 		/* adjust chars > 127, except after "tTfFr" commands */
 		LANGMAP_ADJUST(*cp, !lang);
-#endif
 #ifdef FEAT_RIGHTLEFT
 		/* adjust Hebrew mapped char */
 		if (p_hkmap && lang && KeyTyped)
 		    *cp = hkmap(*cp);
 # ifdef FEAT_FKMAP
@@ -1130,11 +1136,12 @@ getcount:
      */
     if (need_flushbuf)
 	out_flush();
 #endif
 #ifdef FEAT_AUTOCMD
-    did_cursorhold = FALSE;
+    if (ca.cmdchar != K_IGNORE)
+	did_cursorhold = FALSE;
 #endif
 
     State = NORMAL;
 
     if (ca.nchar == ESC)
@@ -2178,14 +2185,13 @@ op_colon(oap)
 }
 
 /*
  * Handle the "g@" operator: call 'operatorfunc'.
  */
-/*ARGSUSED*/
     static void
 op_function(oap)
-    oparg_T	*oap;
+    oparg_T	*oap UNUSED;
 {
 #ifdef FEAT_EVAL
     char_u	*(argv[1]);
 
     if (*p_opfunc == NUL)
@@ -3507,11 +3513,11 @@ find_ident_at_pos(wp, lnum, startcol, st
 	 * didn't find an identifier or string
 	 */
 	if (find_type & FIND_STRING)
 	    EMSG(_("E348: No string under cursor"));
 	else
-	    EMSG(_("E349: No identifier under cursor"));
+	    EMSG(_(e_noident));
 	return 0;
     }
     ptr += col;
     *string = ptr;
 
@@ -3699,17 +3705,17 @@ clear_showcmd()
 	return;
 
 #ifdef FEAT_VISUAL
     if (VIsual_active && !char_avail())
     {
-	int		i = lt(VIsual, curwin->w_cursor);
+	int		cursor_bot = lt(VIsual, curwin->w_cursor);
 	long		lines;
 	colnr_T		leftcol, rightcol;
 	linenr_T	top, bot;
 
 	/* Show the size of the Visual area. */
-	if (i)
+	if (cursor_bot)
 	{
 	    top = VIsual.lnum;
 	    bot = curwin->w_cursor.lnum;
 	}
 	else
@@ -3724,18 +3730,27 @@ clear_showcmd()
 # endif
 	lines = bot - top + 1;
 
 	if (VIsual_mode == Ctrl_V)
 	{
+#ifdef FEAT_LINEBREAK
+	    char_u *saved_sbr = p_sbr;
+
+	    /* Make 'sbr' empty for a moment to get the correct size. */
+	    p_sbr = empty_option;
+#endif
 	    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);
+#ifdef FEAT_LINEBREAK
+	    p_sbr = saved_sbr;
+#endif
 	    sprintf((char *)showcmd_buf, "%ldx%ld", lines,
 					      (long)(rightcol - leftcol + 1));
 	}
 	else if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)
 	    sprintf((char *)showcmd_buf, "%ld", lines);
 	else
-	    sprintf((char *)showcmd_buf, "%ld", (long)(i
+	    sprintf((char *)showcmd_buf, "%ld", (long)(cursor_bot
 		    ? curwin->w_cursor.col - VIsual.col
 		    : VIsual.col - curwin->w_cursor.col) + (*p_sel != 'e'));
 	showcmd_buf[SHOWCMD_COLS] = NUL;	/* truncate */
 	showcmd_visual = TRUE;
     }
@@ -4081,14 +4096,13 @@ nv_ignore(cap)
 
 /*
  * Command character that doesn't do anything, but unlike nv_ignore() does
  * start edit().  Used for "startinsert" executed while starting up.
  */
-/*ARGSUSED */
     static void
 nv_nop(cap)
-    cmdarg_T	*cap;
+    cmdarg_T	*cap UNUSED;
 {
 }
 
 /*
  * Command character doesn't exist.
@@ -4609,13 +4623,11 @@ nv_zet(cap)
 	    dont_scroll = TRUE;		/* disallow scrolling here */
 #endif
 	    ++no_mapping;
 	    ++allow_keys;   /* no mapping for nchar, but allow key codes */
 	    nchar = plain_vgetc();
-#ifdef FEAT_LANGMAP
 	    LANGMAP_ADJUST(nchar, TRUE);
-#endif
 	    --no_mapping;
 	    --allow_keys;
 #ifdef FEAT_CMDL_INFO
 	    (void)add_to_showcmd(nchar);
 #endif
@@ -4967,13 +4979,11 @@ dozet:
 #ifdef FEAT_SPELL
     case 'u':	/* "zug" and "zuw": undo "zg" and "zw" */
 		++no_mapping;
 		++allow_keys;   /* no mapping for nchar, but allow key codes */
 		nchar = plain_vgetc();
-#ifdef FEAT_LANGMAP
 		LANGMAP_ADJUST(nchar, TRUE);
-#endif
 		--no_mapping;
 		--allow_keys;
 #ifdef FEAT_CMDL_INFO
 		(void)add_to_showcmd(nchar);
 #endif
@@ -5226,11 +5236,11 @@ nv_colon(cap)
 	/* The start of the operator may have become invalid by the Ex
 	 * command. */
 	if (cap->oap->op_type != OP_NOP
 		&& (cap->oap->start.lnum > curbuf->b_ml.ml_line_count
 		    || cap->oap->start.col >
-					 STRLEN(ml_get(cap->oap->start.lnum))))
+			       (colnr_T)STRLEN(ml_get(cap->oap->start.lnum))))
 	    clearopbeep(cap->oap);
     }
 }
 
 /*
@@ -5394,10 +5404,11 @@ nv_ident(cap)
     char_u	*kp;		/* value of 'keywordprg' */
     int		kp_help;	/* 'keywordprg' is ":help" */
     int		n = 0;		/* init for GCC */
     int		cmdchar;
     int		g_cmd;		/* "g" command */
+    int		tag_cmd = FALSE;
     char_u	*aux_ptr;
     int		isman;
     int		isman_s;
 
     if (cap->cmdchar == 'g')	/* "g*", "g#", "g]" and "gCTRL-]" */
@@ -5467,10 +5478,24 @@ nv_ident(cap)
 	case 'K':
 	    if (kp_help)
 		STRCPY(buf, "he! ");
 	    else
 	    {
+		/* An external command will probably use an argument starting
+		 * with "-" as an option.  To avoid trouble we skip the "-". */
+		while (*ptr == '-' && n > 0)
+		{
+		    ++ptr;
+		    --n;
+		}
+		if (n == 0)
+		{
+		    EMSG(_(e_noident));	 /* found dashes only */
+		    vim_free(buf);
+		    return;
+		}
+
 		/* When a count is given, turn it into a range.  Is this
 		 * really what we want? */
 		isman = (STRCMP(kp, "man") == 0);
 		isman_s = (STRCMP(kp, "man -s") == 0);
 		if (cap->count0 != 0 && !(isman || isman_s))
@@ -5489,10 +5514,11 @@ nv_ident(cap)
 		}
 	    }
 	    break;
 
 	case ']':
+	    tag_cmd = TRUE;
 #ifdef FEAT_CSCOPE
 	    if (p_cst)
 		STRCPY(buf, "cstag ");
 	    else
 #endif
@@ -5500,50 +5526,78 @@ nv_ident(cap)
 	    break;
 
 	default:
 	    if (curbuf->b_help)
 		STRCPY(buf, "he! ");
-	    else if (g_cmd)
-		STRCPY(buf, "tj ");
 	    else
-		sprintf((char *)buf, "%ldta ", cap->count0);
+	    {
+		tag_cmd = TRUE;
+		if (g_cmd)
+		    STRCPY(buf, "tj ");
+		else
+		    sprintf((char *)buf, "%ldta ", cap->count0);
+	    }
     }
 
     /*
      * Now grab the chars in the identifier
      */
-    if (cmdchar == '*')
-	aux_ptr = (char_u *)(p_magic ? "/.*~[^$\\" : "/^$\\");
-    else if (cmdchar == '#')
-	aux_ptr = (char_u *)(p_magic ? "/?.*~[^$\\" : "/?^$\\");
-    else if (cmdchar == 'K' && !kp_help)
-	aux_ptr = (char_u *)" \t\\\"|!";
-    else
-	/* Don't escape spaces and Tabs in a tag with a backslash */
-	aux_ptr = (char_u *)"\\|\"";
-
-    p = buf + STRLEN(buf);
-    while (n-- > 0)
-    {
-	/* put a backslash before \ and some others */
-	if (vim_strchr(aux_ptr, *ptr) != NULL)
-	    *p++ = '\\';
-#ifdef FEAT_MBYTE
-	/* When current byte is a part of multibyte character, copy all bytes
-	 * of that character. */
-	if (has_mbyte)
+    if (cmdchar == 'K' && !kp_help)
+    {
+	/* Escape the argument properly for a shell command */
+	ptr = vim_strnsave(ptr, n);
+	p = vim_strsave_shellescape(ptr, TRUE);
+	vim_free(ptr);
+	if (p == NULL)
 	{
-	    int i;
-	    int len = (*mb_ptr2len)(ptr) - 1;
-
-	    for (i = 0; i < len && n >= 1; ++i, --n)
-		*p++ = *ptr++;
+	    vim_free(buf);
+	    return;
+	}
+	buf = (char_u *)vim_realloc(buf, STRLEN(buf) + STRLEN(p) + 1);
+	if (buf == NULL)
+	{
+	    vim_free(buf);
+	    vim_free(p);
+	    return;
 	}
+	STRCAT(buf, p);
+	vim_free(p);
+    }
+    else
+    {
+	if (cmdchar == '*')
+	    aux_ptr = (char_u *)(p_magic ? "/.*~[^$\\" : "/^$\\");
+	else if (cmdchar == '#')
+	    aux_ptr = (char_u *)(p_magic ? "/?.*~[^$\\" : "/?^$\\");
+	else if (tag_cmd)
+	    /* Don't escape spaces and Tabs in a tag with a backslash */
+	    aux_ptr = (char_u *)"\\|\"\n[";
+	else
+	    aux_ptr = (char_u *)"\\|\"\n*?[";
+
+	p = buf + STRLEN(buf);
+	while (n-- > 0)
+	{
+	    /* put a backslash before \ and some others */
+	    if (vim_strchr(aux_ptr, *ptr) != NULL)
+		*p++ = '\\';
+#ifdef FEAT_MBYTE
+	    /* When current byte is a part of multibyte character, copy all
+	     * bytes of that character. */
+	    if (has_mbyte)
+	    {
+		int i;
+		int len = (*mb_ptr2len)(ptr) - 1;
+
+		for (i = 0; i < len && n >= 1; ++i, --n)
+		    *p++ = *ptr++;
+	    }
 #endif
-	*p++ = *ptr++;
+	    *p++ = *ptr++;
+	}
+	*p = NUL;
     }
-    *p = NUL;
 
     /*
      * Execute the command.
      */
     if (cmdchar == '*' || cmdchar == '#')
@@ -5554,10 +5608,11 @@ nv_ident(cap)
 #endif
 		vim_iswordc(ptr[-1])))
 	    STRCAT(buf, "\\>");
 #ifdef FEAT_CMDHIST
 	/* put pattern in search history */
+	init_history();
 	add_to_history(HIST_SEARCH, buf, TRUE, NUL);
 #endif
 	normal_search(cap, cmdchar == '*' ? '/' : '?', buf, 0);
     }
     else
@@ -5765,11 +5820,14 @@ nv_right(cap)
 #endif
 
     for (n = cap->count1; n > 0; --n)
     {
 	if ((!PAST_LINE && oneright() == FAIL)
-		|| (PAST_LINE && *ml_get_cursor() == NUL))
+#ifdef FEAT_VISUAL
+		|| (PAST_LINE && *ml_get_cursor() == NUL)
+#endif
+		)
 	{
 	    /*
 	     *	  <Space> wraps to next line if 'whichwrap' has 's'.
 	     *	      'l' wraps to next line if 'whichwrap' has 'l'.
 	     * CURS_RIGHT wraps to next line if 'whichwrap' has '>'.
@@ -6009,11 +6067,11 @@ nv_gotofile(cap)
 	/* do autowrite if necessary */
 	if (curbufIsChanged() && curbuf->b_nwindows <= 1 && !P_HID(curbuf))
 	    autowrite(curbuf, FALSE);
 	setpcmark();
 	(void)do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,
-					       P_HID(curbuf) ? ECMD_HIDE : 0);
+				       P_HID(curbuf) ? ECMD_HIDE : 0, curwin);
 	if (cap->nchar == 'F' && lnum >= 0)
 	{
 	    curwin->w_cursor.lnum = lnum;
 	    check_cursor_lnum();
 	    beginline(BL_SOL | BL_FIX);
@@ -6726,10 +6784,12 @@ nv_replace(cap)
 
 #ifdef FEAT_VISUAL
     /* Visual mode "r" */
     if (VIsual_active)
     {
+	if (got_int)
+	    reset_VIsual();
 	nv_operator(cap);
 	return;
     }
 #endif
 
@@ -7782,11 +7842,11 @@ nv_g_cmd(cap)
 		i = (curwin->w_virtcol - width1) / width2 * width2 + width1;
 	}
 	else
 	    i = curwin->w_leftcol;
 	/* Go to the middle of the screen line.  When 'number' is on and lines
-	 * are wrapping the middle can be more to the left.*/
+	 * are wrapping the middle can be more to the left. */
 	if (cap->nchar == 'm')
 	    i += (W_WIDTH(curwin) - curwin_col_off()
 		    + ((curwin->w_p_wrap && i > 0)
 			? curwin_col_off2() : 0)) / 2;
 	coladvance((colnr_T)i);
@@ -7819,10 +7879,13 @@ nv_g_cmd(cap)
 	    /* Decrease the cursor column until it's on a non-blank. */
 	    while (curwin->w_cursor.col > 0
 				    && vim_iswhite(ptr[curwin->w_cursor.col]))
 		--curwin->w_cursor.col;
 	    curwin->w_set_curswant = TRUE;
+#ifdef FEAT_VISUAL
+	    adjust_for_sel(cap);
+#endif
 	}
 	break;
 
     case '$':
     case K_END:
@@ -9190,14 +9253,13 @@ nv_open(cap)
 #endif
 	n_opencmd(cap);
 }
 
 #ifdef FEAT_SNIFF
-/*ARGSUSED*/
     static void
 nv_sniff(cap)
-    cmdarg_T	*cap;
+    cmdarg_T	*cap UNUSED;
 {
     ProcessSniffRequests();
 }
 #endif
 
@@ -9209,14 +9271,13 @@ nv_nbcmd(cap)
     netbeans_keycommand(cap->nchar);
 }
 #endif
 
 #ifdef FEAT_DND
-/*ARGSUSED*/
     static void
 nv_drop(cap)
-    cmdarg_T	*cap;
+    cmdarg_T	*cap UNUSED;
 {
     do_put('~', BACKWARD, 1L, PUT_CURSEND);
 }
 #endif
 
@@ -9224,11 +9285,10 @@ nv_drop(cap)
 /*
  * Trigger CursorHold event.
  * When waiting for a character for 'updatetime' K_CURSORHOLD is put in the
  * input buffer.  "did_cursorhold" is set to avoid retriggering.
  */
-/*ARGSUSED*/
     static void
 nv_cursorhold(cap)
     cmdarg_T	*cap;
 {
     apply_autocmds(EVENT_CURSORHOLD, NULL, NULL, FALSE, curbuf);
--- vim72.orig/src/ex_cmds2.c
+++ vim72/src/ex_cmds2.c
@@ -26,11 +26,12 @@ static void	cmd_source __ARGS((char_u *f
  * script when going through the list. */
 typedef struct scriptitem_S
 {
     char_u	*sn_name;
 # ifdef UNIX
-    int		sn_dev;
+    int		sn_dev_valid;
+    dev_t	sn_dev;
     ino_t	sn_ino;
 # endif
 # ifdef FEAT_PROFILE
     int		sn_prof_on;	/* TRUE when script is/was profiled */
     int		sn_pr_force;	/* forceit: profile functions in this script */
@@ -678,14 +679,13 @@ ex_breakdel(eap)
 }
 
 /*
  * ":breaklist".
  */
-/*ARGSUSED*/
     void
 ex_breaklist(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     struct debuggy *bp;
     int		i;
 
     if (dbg_breakp.ga_len == 0)
@@ -1090,11 +1090,11 @@ ex_profile(eap)
 	do_profiling = PROF_YES;
 	profile_zero(&prof_wait_time);
 	set_vim_var_nr(VV_PROFILING, 1L);
     }
     else if (do_profiling == PROF_NONE)
-	EMSG(_("E750: First use :profile start <fname>"));
+	EMSG(_("E750: First use \":profile start {fname}\""));
     else if (STRCMP(eap->arg, "pause") == 0)
     {
 	if (do_profiling == PROF_YES)
 	    profile_start(&pause_time);
 	do_profiling = PROF_PAUSED;
@@ -1113,10 +1113,81 @@ ex_profile(eap)
 	/* The rest is similar to ":breakadd". */
 	ex_breakadd(eap);
     }
 }
 
+/* Command line expansion for :profile. */
+static enum
+{
+    PEXP_SUBCMD,	/* expand :profile sub-commands */
+    PEXP_FUNC,		/* expand :profile func {funcname} */
+} pexpand_what;
+
+static char *pexpand_cmds[] = {
+			"start",
+#define PROFCMD_START	0
+			"pause",
+#define PROFCMD_PAUSE	1
+			"continue",
+#define PROFCMD_CONTINUE 2
+			"func",
+#define PROFCMD_FUNC	3
+			"file",
+#define PROFCMD_FILE	4
+			NULL
+#define PROFCMD_LAST	5
+};
+
+/*
+ * Function given to ExpandGeneric() to obtain the profile command
+ * specific expansion.
+ */
+    char_u *
+get_profile_name(xp, idx)
+    expand_T	*xp UNUSED;
+    int		idx;
+{
+    switch (pexpand_what)
+    {
+    case PEXP_SUBCMD:
+	return (char_u *)pexpand_cmds[idx];
+    /* case PEXP_FUNC: TODO */
+    default:
+	return NULL;
+    }
+}
+
+/*
+ * Handle command line completion for :profile command.
+ */
+    void
+set_context_in_profile_cmd(xp, arg)
+    expand_T	*xp;
+    char_u	*arg;
+{
+    char_u	*end_subcmd;
+
+    /* Default: expand subcommands. */
+    xp->xp_context = EXPAND_PROFILE;
+    pexpand_what = PEXP_SUBCMD;
+    xp->xp_pattern = arg;
+
+    end_subcmd = skiptowhite(arg);
+    if (*end_subcmd == NUL)
+	return;
+
+    if (end_subcmd - arg == 5 && STRNCMP(arg, "start", 5) == 0)
+    {
+	xp->xp_context = EXPAND_FILES;
+	xp->xp_pattern = skipwhite(end_subcmd);
+	return;
+    }
+
+    /* TODO: expand function names after "func" */
+    xp->xp_context = EXPAND_NOTHING;
+}
+
 /*
  * Dump the profiling info.
  */
     void
 profile_dump()
@@ -1340,18 +1411,17 @@ autowrite_all()
 }
 
 /*
  * return TRUE if buffer was changed and cannot be abandoned.
  */
-/*ARGSUSED*/
     int
 check_changed(buf, checkaw, mult_win, forceit, allbuf)
     buf_T	*buf;
     int		checkaw;	/* do autowrite if buffer was changed */
     int		mult_win;	/* check also when several wins for the buf */
     int		forceit;
-    int		allbuf;		/* may write all buffers */
+    int		allbuf UNUSED;	/* may write all buffers */
 {
     if (       !forceit
 	    && bufIsChanged(buf)
 	    && (mult_win || buf->b_nwindows <= 1)
 	    && (!checkaw || autowrite(buf, forceit) == FAIL))
@@ -1757,16 +1827,15 @@ set_arglist(str)
  * "what" == AL_ADD: add files in 'str' to the argument list after "after".
  * "what" == AL_DEL: remove files in 'str' from the argument list.
  *
  * Return FAIL for failure, OK otherwise.
  */
-/*ARGSUSED*/
     static int
 do_arglist(str, what, after)
     char_u	*str;
-    int		what;
-    int		after;		/* 0 means before first one */
+    int		what UNUSED;
+    int		after UNUSED;		/* 0 means before first one */
 {
     garray_T	new_ga;
     int		exp_count;
     char_u	**exp_files;
     int		i;
@@ -2130,12 +2199,12 @@ do_argfile(eap, argn)
 	/* Edit the file; always use the last known line number.
 	 * When it fails (e.g. Abort for already edited file) restore the
 	 * argument index. */
 	if (do_ecmd(0, alist_name(&ARGLIST[curwin->w_arg_idx]), NULL,
 		      eap, ECMD_LAST,
-		      (P_HID(curwin->w_buffer) ? ECMD_HIDE : 0) +
-				   (eap->forceit ? ECMD_FORCEIT : 0)) == FAIL)
+		      (P_HID(curwin->w_buffer) ? ECMD_HIDE : 0)
+			 + (eap->forceit ? ECMD_FORCEIT : 0), curwin) == FAIL)
 	    curwin->w_arg_idx = old_arg_idx;
 	/* like Vi: set the mark where the cursor is in the file. */
 	else if (eap->cmdidx != CMD_argdo)
 	    setmark('\'');
     }
@@ -2496,43 +2565,44 @@ ex_compiler(eap)
 	    {
 		/* ":compiler! {name}" sets local options.
 		 * To remain backwards compatible "current_compiler" is always
 		 * used.  A user's compiler plugin may set it, the distributed
 		 * plugin will then skip the settings.  Afterwards set
-		 * "b:current_compiler" and restore "current_compiler". */
-		old_cur_comp = get_var_value((char_u *)"current_compiler");
+		 * "b:current_compiler" and restore "current_compiler".
+		 * Explicitly prepend "g:" to make it work in a function. */
+		old_cur_comp = get_var_value((char_u *)"g:current_compiler");
 		if (old_cur_comp != NULL)
 		    old_cur_comp = vim_strsave(old_cur_comp);
 		do_cmdline_cmd((char_u *)
 			      "command -nargs=* CompilerSet setlocal <args>");
 	    }
-	    do_unlet((char_u *)"current_compiler", TRUE);
+	    do_unlet((char_u *)"g:current_compiler", TRUE);
 	    do_unlet((char_u *)"b:current_compiler", TRUE);
 
 	    sprintf((char *)buf, "compiler/%s.vim", eap->arg);
 	    if (source_runtime(buf, TRUE) == FAIL)
 		EMSG2(_("E666: compiler not supported: %s"), eap->arg);
 	    vim_free(buf);
 
 	    do_cmdline_cmd((char_u *)":delcommand CompilerSet");
 
 	    /* Set "b:current_compiler" from "current_compiler". */
-	    p = get_var_value((char_u *)"current_compiler");
+	    p = get_var_value((char_u *)"g:current_compiler");
 	    if (p != NULL)
 		set_internal_string_var((char_u *)"b:current_compiler", p);
 
 	    /* Restore "current_compiler" for ":compiler {name}". */
 	    if (!eap->forceit)
 	    {
 		if (old_cur_comp != NULL)
 		{
-		    set_internal_string_var((char_u *)"current_compiler",
+		    set_internal_string_var((char_u *)"g:current_compiler",
 								old_cur_comp);
 		    vim_free(old_cur_comp);
 		}
 		else
-		    do_unlet((char_u *)"current_compiler", TRUE);
+		    do_unlet((char_u *)"g:current_compiler", TRUE);
 	    }
 	}
     }
 }
 #endif
@@ -2547,15 +2617,14 @@ ex_runtime(eap)
     source_runtime(eap->arg, eap->forceit);
 }
 
 static void source_callback __ARGS((char_u *fname, void *cookie));
 
-/*ARGSUSED*/
     static void
 source_callback(fname, cookie)
     char_u	*fname;
-    void	*cookie;
+    void	*cookie UNUSED;
 {
     (void)do_source(fname, FALSE, DOSO_NONE);
 }
 
 /*
@@ -2678,14 +2747,13 @@ do_in_runtimepath(name, all, callback, c
 
 #if defined(FEAT_EVAL) && defined(FEAT_AUTOCMD)
 /*
  * ":options"
  */
-/*ARGSUSED*/
     void
 ex_options(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     cmd_source((char_u *)SYS_OPTWIN_FILE, NULL);
 }
 #endif
 
@@ -2803,24 +2871,39 @@ source_level(cookie)
 }
 #endif
 
 static char_u *get_one_sourceline __ARGS((struct source_cookie *sp));
 
-#if defined(WIN32) && defined(FEAT_CSCOPE)
+#if (defined(WIN32) && defined(FEAT_CSCOPE)) || defined(HAVE_FD_CLOEXEC)
+# define USE_FOPEN_NOINH
 static FILE *fopen_noinh_readbin __ARGS((char *filename));
 
 /*
  * Special function to open a file without handle inheritance.
+ * When possible the handle is closed on exec().
  */
     static FILE *
 fopen_noinh_readbin(filename)
     char    *filename;
 {
+# ifdef WIN32
     int	fd_tmp = mch_open(filename, O_RDONLY | O_BINARY | O_NOINHERIT, 0);
+# else
+    int	fd_tmp = mch_open(filename, O_RDONLY, 0);
+# endif
 
     if (fd_tmp == -1)
 	return NULL;
+
+# ifdef HAVE_FD_CLOEXEC
+    {
+	int fdflags = fcntl(fd_tmp, F_GETFD);
+	if (fdflags >= 0 && (fdflags & FD_CLOEXEC) == 0)
+	    fcntl(fd_tmp, F_SETFD, fdflags | FD_CLOEXEC);
+    }
+# endif
+
     return fdopen(fd_tmp, READBIN);
 }
 #endif
 
 
@@ -2840,10 +2923,11 @@ do_source(fname, check_other, is_vimrc)
     struct source_cookie    cookie;
     char_u		    *save_sourcing_name;
     linenr_T		    save_sourcing_lnum;
     char_u		    *p;
     char_u		    *fname_exp;
+    char_u		    *firstline = NULL;
     int			    retval = FAIL;
 #ifdef FEAT_EVAL
     scid_T		    save_current_SID;
     static scid_T	    last_current_SID = 0;
     void		    *save_funccalp;
@@ -2895,11 +2979,11 @@ do_source(fname, check_other, is_vimrc)
 
     /* Apply SourcePre autocommands, they may get the file. */
     apply_autocmds(EVENT_SOURCEPRE, fname_exp, fname_exp, FALSE, curbuf);
 #endif
 
-#if defined(WIN32) && defined(FEAT_CSCOPE)
+#ifdef USE_FOPEN_NOINH
     cookie.fp = fopen_noinh_readbin((char *)fname_exp);
 #else
     cookie.fp = mch_fopen((char *)fname_exp, READBIN);
 #endif
     if (cookie.fp == NULL && check_other)
@@ -2916,11 +3000,11 @@ do_source(fname, check_other, is_vimrc)
 	{
 	    if (*p == '_')
 		*p = '.';
 	    else
 		*p = '_';
-#if defined(WIN32) && defined(FEAT_CSCOPE)
+#ifdef USE_FOPEN_NOINH
 	    cookie.fp = fopen_noinh_readbin((char *)fname_exp);
 #else
 	    cookie.fp = mch_fopen((char *)fname_exp, READBIN);
 #endif
 	}
@@ -2990,38 +3074,43 @@ do_source(fname, check_other, is_vimrc)
     cookie.fname = fname_exp;
     cookie.dbg_tick = debug_tick;
 
     cookie.level = ex_nesting_level;
 #endif
-#ifdef FEAT_MBYTE
-    cookie.conv.vc_type = CONV_NONE;		/* no conversion */
-
-    /* Try reading the first few bytes to check for a UTF-8 BOM. */
-    {
-	char_u	    buf[3];
-
-	if (fread((char *)buf, sizeof(char_u), (size_t)3, cookie.fp)
-								  == (size_t)3
-		&& buf[0] == 0xef && buf[1] == 0xbb && buf[2] == 0xbf)
-	    /* Found BOM, setup conversion and skip over it. */
-	    convert_setup(&cookie.conv, (char_u *)"utf-8", p_enc);
-	else
-	    /* No BOM found, rewind. */
-	    fseek(cookie.fp, 0L, SEEK_SET);
-    }
-#endif
 
     /*
      * Keep the sourcing name/lnum, for recursive calls.
      */
     save_sourcing_name = sourcing_name;
     sourcing_name = fname_exp;
     save_sourcing_lnum = sourcing_lnum;
     sourcing_lnum = 0;
 
+#ifdef FEAT_MBYTE
+    cookie.conv.vc_type = CONV_NONE;		/* no conversion */
+
+    /* Read the first line so we can check for a UTF-8 BOM. */
+    firstline = getsourceline(0, (void *)&cookie, 0);
+    if (firstline != NULL && STRLEN(firstline) >= 3 && firstline[0] == 0xef
+			      && firstline[1] == 0xbb && firstline[2] == 0xbf)
+    {
+	/* Found BOM; setup conversion, skip over BOM and recode the line. */
+	convert_setup(&cookie.conv, (char_u *)"utf-8", p_enc);
+	p = string_convert(&cookie.conv, firstline + 3, NULL);
+	if (p == NULL)
+	    p = vim_strsave(firstline + 3);
+	if (p != NULL)
+	{
+	    vim_free(firstline);
+	    firstline = p;
+	}
+    }
+#endif
+
 #ifdef STARTUPTIME
-    time_push(&tv_rel, &tv_start);
+    if (time_fd != NULL)
+	time_push(&tv_rel, &tv_start);
 #endif
 
 #ifdef FEAT_EVAL
 # ifdef FEAT_PROFILE
     if (do_profiling == PROF_YES)
@@ -3047,11 +3136,11 @@ do_source(fname, check_other, is_vimrc)
 		&& (
 # ifdef UNIX
 		    /* Compare dev/ino when possible, it catches symbolic
 		     * links.  Also compare file names, the inode may change
 		     * when the file was edited. */
-		    ((stat_ok && si->sn_dev != -1)
+		    ((stat_ok && si->sn_dev_valid)
 			&& (si->sn_dev == st.st_dev
 			    && si->sn_ino == st.st_ino)) ||
 # endif
 		fnamecmp(si->sn_name, fname_exp) == 0))
 	    break;
@@ -3074,15 +3163,16 @@ do_source(fname, check_other, is_vimrc)
 	si->sn_name = fname_exp;
 	fname_exp = NULL;
 # ifdef UNIX
 	if (stat_ok)
 	{
+	    si->sn_dev_valid = TRUE;
 	    si->sn_dev = st.st_dev;
 	    si->sn_ino = st.st_ino;
 	}
 	else
-	    si->sn_dev = -1;
+	    si->sn_dev_valid = FALSE;
 # endif
 
 	/* Allocate the local script variables to use for this script. */
 	new_script_vars(current_SID);
     }
@@ -3109,13 +3199,12 @@ do_source(fname, check_other, is_vimrc)
 #endif
 
     /*
      * Call do_cmdline, which will call getsourceline() to get the lines.
      */
-    do_cmdline(NULL, getsourceline, (void *)&cookie,
+    do_cmdline(firstline, getsourceline, (void *)&cookie,
 				     DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_REPEAT);
-
     retval = OK;
 
 #ifdef FEAT_PROFILE
     if (do_profiling == PROF_YES)
     {
@@ -3143,13 +3232,16 @@ do_source(fname, check_other, is_vimrc)
 	if (sourcing_name != NULL)
 	    smsg((char_u *)_("continuing in %s"), sourcing_name);
 	verbose_leave();
     }
 #ifdef STARTUPTIME
-    vim_snprintf(IObuff, IOSIZE, "sourcing %s", fname);
-    time_msg(IObuff, &tv_start);
-    time_pop(&tv_rel);
+    if (time_fd != NULL)
+    {
+	vim_snprintf((char *)IObuff, IOSIZE, "sourcing %s", fname);
+	time_msg((char *)IObuff, &tv_start);
+	time_pop(&tv_rel);
+    }
 #endif
 
 #ifdef FEAT_EVAL
     /*
      * After a "finish" in debug mode, need to break at first command of next
@@ -3169,10 +3261,11 @@ almosttheend:
 	prof_child_exit(&wait_start);		/* leaving a child now */
 # endif
 #endif
     fclose(cookie.fp);
     vim_free(cookie.nextline);
+    vim_free(firstline);
 #ifdef FEAT_MBYTE
     convert_setup(&cookie.conv, NULL, NULL);
 #endif
 
 theend:
@@ -3183,14 +3276,13 @@ theend:
 #if defined(FEAT_EVAL) || defined(PROTO)
 
 /*
  * ":scriptnames"
  */
-/*ARGSUSED*/
     void
 ex_scriptnames(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     int i;
 
     for (i = 1; i <= script_items.ga_len && !got_int; ++i)
 	if (SCRIPT_ITEM(i).sn_name != NULL)
@@ -3310,16 +3402,15 @@ fgets_cr(s, n, stream)
  * Called by do_cmdline() when it's called from do_source().
  *
  * Return a pointer to the line in allocated memory.
  * Return NULL for end-of-file or some error.
  */
-/* ARGSUSED */
     char_u *
 getsourceline(c, cookie, indent)
-    int		c;		/* not used */
+    int		c UNUSED;
     void	*cookie;
-    int		indent;		/* not used */
+    int		indent UNUSED;
 {
     struct source_cookie *sp = (struct source_cookie *)cookie;
     char_u		*line;
     char_u		*p, *s;
 
@@ -3366,11 +3457,11 @@ getsourceline(c, cookie, indent)
 	    if (sp->nextline == NULL)
 		break;
 	    p = skipwhite(sp->nextline);
 	    if (*p != '\\')
 		break;
-	    s = alloc((int)(STRLEN(line) + STRLEN(p)));
+	    s = alloc((unsigned)(STRLEN(line) + STRLEN(p)));
 	    if (s == NULL)	/* out of memory */
 		break;
 	    STRCPY(s, line);
 	    STRCAT(s, p + 1);
 	    vim_free(line);
@@ -3642,14 +3733,13 @@ script_line_end()
 
 /*
  * ":scriptencoding": Set encoding conversion for a sourced script.
  * Without the multi-byte feature it's simply ignored.
  */
-/*ARGSUSED*/
     void
 ex_scriptencoding(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
 #ifdef FEAT_MBYTE
     struct source_cookie	*sp;
     char_u			*name;
 
@@ -4094,14 +4184,13 @@ ex_language(eap)
 # if defined(FEAT_CMDL_COMPL) || defined(PROTO)
 /*
  * Function given to ExpandGeneric() to obtain the possible arguments of the
  * ":language" command.
  */
-/*ARGSUSED*/
     char_u *
 get_lang_arg(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     if (idx == 0)
 	return (char_u *)"messages";
     if (idx == 1)
--- vim72.orig/src/ui.c
+++ vim72/src/ui.c
@@ -318,14 +318,13 @@ ui_get_shellsize()
 /*
  * Set the size of the Vim shell according to Rows and Columns, if possible.
  * The gui_set_shellsize() or mch_set_shellsize() function will try to set the
  * new size.  If this is not possible, it will adjust Rows and Columns.
  */
-/*ARGSUSED*/
     void
 ui_set_shellsize(mustset)
-    int		mustset;	/* set by the user */
+    int		mustset UNUSED;	/* set by the user */
 {
 #ifdef FEAT_GUI
     if (gui.in_use)
 	gui_set_shellsize(mustset,
 # ifdef WIN3264
@@ -1125,14 +1124,13 @@ clip_invert_rectangle(row, col, height,
 /*
  * Copy the currently selected area into the '*' register so it will be
  * available for pasting.
  * When "both" is TRUE also copy to the '+' register.
  */
-/*ARGSUSED*/
     void
 clip_copy_modeless_selection(both)
-    int		both;
+    int		both UNUSED;
 {
     char_u	*buffer;
     char_u	*bufp;
     int		row;
     int		start_col;
@@ -1699,14 +1697,13 @@ read_from_input_buf(buf, maxlen)
     if (inbufcount)
 	mch_memmove(inbuf, inbuf + maxlen, (size_t)inbufcount);
     return (int)maxlen;
 }
 
-/*ARGSUSED*/
     void
 fill_input_buf(exit_on_error)
-    int	exit_on_error;
+    int	exit_on_error UNUSED;
 {
 #if defined(UNIX) || defined(OS2) || defined(VMS) || defined(MACOS_X_UNIX)
     int		len;
     int		try;
     static int	did_read_something = FALSE;
@@ -1818,11 +1815,11 @@ fill_input_buf(exit_on_error)
 	     * what it was. */
 	    settmode(TMODE_COOK);
 #ifdef HAVE_DUP
 	    /* Use stderr for stdin, also works for shell commands. */
 	    close(0);
-	    dup(2);
+	    ignored = dup(2);
 #else
 	    read_cmd_fd = 2;	/* read from stderr instead of stdin */
 #endif
 	    settmode(m);
 	}
@@ -1990,15 +1987,14 @@ x11_setup_atoms(dpy)
  * X Selection stuff, for cutting and pasting text to other windows.
  */
 
 static void  clip_x11_request_selection_cb __ARGS((Widget, XtPointer, Atom *, Atom *, XtPointer, long_u *, int *));
 
-/* ARGSUSED */
     static void
 clip_x11_request_selection_cb(w, success, sel_atom, type, value, length,
 			      format)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	success;
     Atom	*sel_atom;
     Atom	*type;
     XtPointer	value;
     long_u	*length;
@@ -2018,11 +2014,11 @@ clip_x11_request_selection_cb(w, success
     else
 	cbd = &clip_star;
 
     if (value == NULL || *length == 0)
     {
-	clip_free_selection(cbd);	/* ???  [what's the query?] */
+	clip_free_selection(cbd);	/* nothing received, clear register */
 	*(int *)success = FALSE;
 	return;
     }
     motion_type = MCHAR;
     p = (char_u *)value;
@@ -2074,11 +2070,11 @@ clip_x11_request_selection_cb(w, success
 	int		status;
 
 	text_prop.value = (unsigned char *)value;
 	text_prop.encoding = *type;
 	text_prop.format = *format;
-	text_prop.nitems = STRLEN(value);
+	text_prop.nitems = len;
 	status = XmbTextPropertyToTextList(X_DISPLAY, &text_prop,
 							 &text_list, &n_text);
 	if (status != Success || n_text < 1)
 	{
 	    *(int *)success = FALSE;
@@ -2106,12 +2102,12 @@ clip_x11_request_selection(myShell, dpy,
 {
     XEvent	event;
     Atom	type;
     static int	success;
     int		i;
-    int		nbytes = 0;
-    char_u	*buffer;
+    time_t	start_time;
+    int		timed_out = FALSE;
 
     for (i =
 #ifdef FEAT_MBYTE
 	    0
 #else
@@ -2127,10 +2123,11 @@ clip_x11_request_selection(myShell, dpy,
 	    case 1:  type = vim_atom;		break;
 	    case 2:  type = compound_text_atom; break;
 	    case 3:  type = text_atom;		break;
 	    default: type = XA_STRING;
 	}
+	success = MAYBE;
 	XtGetSelectionValue(myShell, cbd->sel_atom, type,
 	    clip_x11_request_selection_cb, (XtPointer)&success, CurrentTime);
 
 	/* Make sure the request for the selection goes out before waiting for
 	 * a response. */
@@ -2139,51 +2136,63 @@ clip_x11_request_selection(myShell, dpy,
 	/*
 	 * Wait for result of selection request, otherwise if we type more
 	 * characters, then they will appear before the one that requested the
 	 * paste!  Don't worry, we will catch up with any other events later.
 	 */
-	for (;;)
+	start_time = time(NULL);
+	while (success == MAYBE)
 	{
-	    if (XCheckTypedEvent(dpy, SelectionNotify, &event))
-		break;
-	    if (XCheckTypedEvent(dpy, SelectionRequest, &event))
-		/* We may get a SelectionRequest here and if we don't handle
-		 * it we hang.  KDE klipper does this, for example. */
+	    if (XCheckTypedEvent(dpy, SelectionNotify, &event)
+		    || XCheckTypedEvent(dpy, SelectionRequest, &event)
+		    || XCheckTypedEvent(dpy, PropertyNotify, &event))
+	    {
+		/* This is where clip_x11_request_selection_cb() should be
+		 * called.  It may actually happen a bit later, so we loop
+		 * until "success" changes.
+		 * We may get a SelectionRequest here and if we don't handle
+		 * it we hang.  KDE klipper does this, for example.
+		 * We need to handle a PropertyNotify for large selections. */
 		XtDispatchEvent(&event);
+		continue;
+	    }
+
+	    /* Time out after 2 to 3 seconds to avoid that we hang when the
+	     * other process doesn't respond.  Note that the SelectionNotify
+	     * event may still come later when the selection owner comes back
+	     * to life and the text gets inserted unexpectedly.  Don't know
+	     * why that happens or how to avoid that :-(. */
+	    if (time(NULL) > start_time + 2)
+	    {
+		timed_out = TRUE;
+		break;
+	    }
 
 	    /* Do we need this?  Probably not. */
 	    XSync(dpy, False);
 
-	    /* Bernhard Walle solved a slow paste response in an X terminal by
-	     * adding: usleep(10000); here. */
+	    /* Wait for 1 msec to avoid that we eat up all CPU time. */
+	    ui_delay(1L, TRUE);
 	}
 
-	/* this is where clip_x11_request_selection_cb() is actually called */
-	XtDispatchEvent(&event);
-
-	if (success)
+	if (success == TRUE)
 	    return;
+
+	/* don't do a retry with another type after timing out, otherwise we
+	 * hang for 15 seconds. */
+	if (timed_out)
+	    break;
     }
 
     /* Final fallback position - use the X CUT_BUFFER0 store */
-    buffer = (char_u *)XFetchBuffer(dpy, &nbytes, 0);
-    if (nbytes > 0)
-    {
-	/* Got something */
-	clip_yank_selection(MCHAR, buffer, (long)nbytes, cbd);
-	XFree((void *)buffer);
-	if (p_verbose > 0)
-	    verb_msg((char_u *)_("Used CUT_BUFFER0 instead of empty selection"));
-    }
+    yank_cut_buffer0(dpy, cbd);
 }
 
 static Boolean	clip_x11_convert_selection_cb __ARGS((Widget, Atom *, Atom *, Atom *, XtPointer *, long_u *, int *));
 
-/* ARGSUSED */
     static Boolean
 clip_x11_convert_selection_cb(w, sel_atom, target, type, value, length, format)
-    Widget	w;
+    Widget	w UNUSED;
     Atom	*sel_atom;
     Atom	*target;
     Atom	*type;
     XtPointer	*value;
     long_u	*length;
@@ -2306,14 +2315,13 @@ clip_x11_convert_selection_cb(w, sel_ato
     return True;
 }
 
 static void  clip_x11_lose_ownership_cb __ARGS((Widget, Atom *));
 
-/* ARGSUSED */
     static void
 clip_x11_lose_ownership_cb(w, sel_atom)
-    Widget  w;
+    Widget  w UNUSED;
     Atom    *sel_atom;
 {
     if (*sel_atom == clip_plus.sel_atom)
 	clip_lose_selection(&clip_plus);
     else
@@ -2342,18 +2350,71 @@ clip_x11_own_selection(myShell, cbd)
 
 /*
  * Send the current selection to the clipboard.  Do nothing for X because we
  * will fill in the selection only when requested by another app.
  */
-/*ARGSUSED*/
     void
 clip_x11_set_selection(cbd)
-    VimClipboard *cbd;
+    VimClipboard *cbd UNUSED;
 {
 }
 #endif
 
+#if defined(FEAT_XCLIPBOARD) || defined(FEAT_GUI_X11) \
+    || defined(FEAT_GUI_GTK) || defined(PROTO)
+/*
+ * Get the contents of the X CUT_BUFFER0 and put it in "cbd".
+ */
+    void
+yank_cut_buffer0(dpy, cbd)
+    Display		*dpy;
+    VimClipboard	*cbd;
+{
+    int		nbytes = 0;
+    char_u	*buffer = (char_u *)XFetchBuffer(dpy, &nbytes, 0);
+
+    if (nbytes > 0)
+    {
+#ifdef FEAT_MBYTE
+	int  done = FALSE;
+
+	/* CUT_BUFFER0 is supposed to be always latin1.  Convert to 'enc' when
+	 * using a multi-byte encoding.  Conversion between two 8-bit
+	 * character sets usually fails and the text might actually be in
+	 * 'enc' anyway. */
+	if (has_mbyte)
+	{
+	    char_u	*conv_buf;
+	    vimconv_T	vc;
+
+	    vc.vc_type = CONV_NONE;
+	    if (convert_setup(&vc, (char_u *)"latin1", p_enc) == OK)
+	    {
+		conv_buf = string_convert(&vc, buffer, &nbytes);
+		if (conv_buf != NULL)
+		{
+		    clip_yank_selection(MCHAR, conv_buf, (long)nbytes, cbd);
+		    vim_free(conv_buf);
+		    done = TRUE;
+		}
+		convert_setup(&vc, NULL, NULL);
+	    }
+	}
+	if (!done)  /* use the text without conversion */
+#endif
+	    clip_yank_selection(MCHAR, buffer, (long)nbytes, cbd);
+	XFree((void *)buffer);
+	if (p_verbose > 0)
+	{
+	    verbose_enter();
+	    verb_msg((char_u *)_("Used CUT_BUFFER0 instead of empty selection"));
+	    verbose_leave();
+	}
+    }
+}
+#endif
+
 #if defined(FEAT_MOUSE) || defined(PROTO)
 
 /*
  * Move the cursor to the specified row and column on the screen.
  * Change current window if necessary.	Returns an integer with the
@@ -2535,18 +2596,11 @@ retnomove:
 #endif
 #ifdef FEAT_CMDWIN
 	if (cmdwin_type != 0 && wp != curwin)
 	{
 	    /* A click outside the command-line window: Use modeless
-	     * selection if possible.  Allow dragging the status line of
-	     * windows just above the command-line window. */
-	    if (wp->w_winrow + wp->w_height
-		       != curwin->w_prev->w_winrow + curwin->w_prev->w_height)
-	    {
-		on_status_line = 0;
-		dragwin = NULL;
-	    }
+	     * selection if possible.  Allow dragging the status lines. */
 # ifdef FEAT_VERTSPLIT
 	    on_sep_line = 0;
 # endif
 # ifdef FEAT_CLIPBOARD
 	    if (on_status_line)
@@ -2896,15 +2950,14 @@ mouse_comp_pos(win, rowp, colp, lnump)
 #if defined(FEAT_WINDOWS) || defined(PROTO)
 /*
  * Find the window at screen position "*rowp" and "*colp".  The positions are
  * updated to become relative to the top-left of the window.
  */
-/*ARGSUSED*/
     win_T *
 mouse_find_win(rowp, colp)
     int		*rowp;
-    int		*colp;
+    int		*colp UNUSED;
 {
     frame_T	*fp;
 
     fp = topframe;
     *rowp -= firstwin->w_winrow;
@@ -2993,22 +3046,21 @@ vcol2col(wp, lnum, vcol)
     win_T	*wp;
     linenr_T	lnum;
     int		vcol;
 {
     /* try to advance to the specified column */
-    int		col = 0;
     int		count = 0;
     char_u	*ptr;
+    char_u	*start;
 
-    ptr = ml_get_buf(wp->w_buffer, lnum, FALSE);
+    start = ptr = ml_get_buf(wp->w_buffer, lnum, FALSE);
     while (count <= vcol && *ptr != NUL)
     {
-	++col;
 	count += win_lbr_chartabsize(wp, ptr, count, NULL);
 	mb_ptr_adv(ptr);
     }
-    return col;
+    return (int)(ptr - start);
 }
 #endif
 
 #endif /* FEAT_MOUSE */
 
--- vim72.orig/src/testdir/Makefile
+++ vim72/src/testdir/Makefile
@@ -2,13 +2,15 @@
 # Makefile to run all tests for Vim
 #
 
 VIMPROG = ../vim
 
-# Uncomment this line for using valgrind.
-# The output goes into a file "valgrind.$PID" (sorry, no test number).
-# VALGRIND = valgrind --tool=memcheck --leak-check=yes --num-callers=15 --logfile=valgrind
+# Uncomment this line to use valgrind for memory leaks and extra warnings.
+#   The output goes into a file "valgrind.testN"
+#   Vim should be compiled with EXITFREE to avoid false warnings.
+#   This will make testing about 10 times as slow.
+# VALGRIND = valgrind --tool=memcheck --leak-check=yes --num-callers=15 --log-file=valgrind.$*
 
 SCRIPTS = test1.out test2.out test3.out test4.out test5.out test6.out \
 		test7.out test8.out test9.out test10.out test11.out \
 		test12.out  test13.out test14.out test15.out test17.out \
 		test18.out test19.out test20.out test21.out test22.out \
@@ -18,33 +20,36 @@ SCRIPTS = test1.out test2.out test3.out
 		test38.out test39.out test40.out test41.out test42.out \
 		test43.out test44.out test45.out test46.out test47.out \
 		test48.out test49.out test51.out test52.out test53.out \
 		test54.out test55.out test56.out test57.out test58.out \
 		test59.out test60.out test61.out test62.out test63.out \
-		test64.out test65.out
+		test64.out test65.out test66.out test67.out test68.out \
+		test69.out test70.out
 
 SCRIPTS_GUI = test16.out
 
 .SUFFIXES: .in .out
 
-nongui:	nolog $(SCRIPTS)
-	@echo
-	@cat test.log
-	@echo ALL DONE
+nongui:	nolog $(SCRIPTS) report
+
+gui:	nolog $(SCRIPTS) $(SCRIPTS_GUI) report
 
-gui:	nolog $(SCRIPTS) $(SCRIPTS_GUI)
+report:
 	@echo
-	@cat test.log
-	@echo ALL DONE
+	@echo 'Test results:'
+	@/bin/sh -c "if test -f test.log; \
+		then cat test.log; echo TEST FAILURE; exit 1; \
+		else echo ALL DONE; \
+		fi"
 
 $(SCRIPTS) $(SCRIPTS_GUI): $(VIMPROG)
 
 clean:
-	-rm -rf *.out *.failed *.rej *.orig test.log tiny.vim small.vim mbyte.vim test.ok X* valgrind.pid* viminfo
+	-rm -rf *.out *.failed *.rej *.orig test.log tiny.vim small.vim mbyte.vim mzscheme.vim test.ok X* valgrind.pid* viminfo
 
 test1.out: test1.in
-	-rm -f $*.failed tiny.vim small.vim mbyte.vim test.ok X* viminfo
+	-rm -f $*.failed tiny.vim small.vim mbyte.vim mzscheme.vim test.ok X* viminfo
 	$(VALGRIND) $(VIMPROG) -u unix.vim -U NONE --noplugin -s dotest.in $*.in
 	@/bin/sh -c "if diff test.out $*.ok; \
 		then mv -f test.out $*.out; \
 		else echo; \
 		echo test1 FAILED - Something basic is wrong; \
@@ -69,6 +74,6 @@ test1.out: test1.in
 test49.out: test49.vim
 
 test60.out: test60.vim
 
 nolog:
-	-echo Test results: >test.log
+	-rm -f test.log
--- vim72.orig/src/ex_getln.c
+++ vim72/src/ex_getln.c
@@ -29,18 +29,24 @@ struct cmdline_info
     int		cmdindent;	/* number of spaces before cmdline */
     char_u	*cmdprompt;	/* message in front of cmdline */
     int		cmdattr;	/* attributes for prompt */
     int		overstrike;	/* Typing mode on the command line.  Shared by
 				   getcmdline() and put_on_cmdline(). */
+    expand_T	*xpc;		/* struct being used for expansion, xp_pattern
+				   may point into cmdbuff */
     int		xp_context;	/* type of expansion */
 # ifdef FEAT_EVAL
     char_u	*xp_arg;	/* user-defined expansion arg */
     int		input_fn;	/* when TRUE Invoked for input() function */
 # endif
 };
 
-static struct cmdline_info ccline;	/* current cmdline_info */
+/* The current cmdline_info.  It is initialized in getcmdline() and after that
+ * used by other functions.  When invoking getcmdline() recursively it needs
+ * to be saved with save_cmdline() and restored with restore_cmdline().
+ * TODO: make it local to getcmdline() and pass it around. */
+static struct cmdline_info ccline;
 
 static int	cmd_showtail;		/* Only show path tail in lists ? */
 
 #ifdef FEAT_EVAL
 static int	new_cmdpos;	/* position set by set_cmdline_pos() */
@@ -132,15 +138,14 @@ static int	ex_window __ARGS((void));
  * Careful: getcmdline() can be called recursively!
  *
  * Return pointer to allocated string if there is a commandline, NULL
  * otherwise.
  */
-/*ARGSUSED*/
     char_u *
 getcmdline(firstc, count, indent)
     int		firstc;
-    long	count;		/* only used for incremental search */
+    long	count UNUSED;	/* only used for incremental search */
     int		indent;		/* indent for inside conditionals */
 {
     int		c;
     int		i;
     int		j;
@@ -236,10 +241,11 @@ getcmdline(firstc, count, indent)
 	ccline.cmdspos = indent;
 	ccline.cmdlen = indent;
     }
 
     ExpandInit(&xpc);
+    ccline.xpc = &xpc;
 
 #ifdef FEAT_RIGHTLEFT
     if (curwin->w_p_rl && *curwin->w_p_rlc == 's'
 					  && (firstc == '/' || firstc == '?'))
 	cmdmsg_rl = TRUE;
@@ -316,11 +322,11 @@ getcmdline(firstc, count, indent)
     hiscnt = hislen;		/* set hiscnt to impossible history value */
     histype = hist_char2type(firstc);
 #endif
 
 #ifdef FEAT_DIGRAPHS
-    do_digraph(-1);		/* init digraph typahead */
+    do_digraph(-1);		/* init digraph typeahead */
 #endif
 
     /*
      * Collect the command string, handling editing keys.
      */
@@ -406,13 +412,14 @@ getcmdline(firstc, count, indent)
 	    lookfor = NULL;
 	}
 #endif
 
 	/*
-	 * <S-Tab> works like CTRL-P (unless 'wc' is <S-Tab>).
+	 * When there are matching completions to select <S-Tab> works like
+	 * CTRL-P (unless 'wc' is <S-Tab>).
 	 */
-	if (c != p_wc && c == K_S_TAB && xpc.xp_numfiles != -1)
+	if (c != p_wc && c == K_S_TAB && xpc.xp_numfiles > 0)
 	    c = Ctrl_P;
 
 #ifdef FEAT_WILDMENU
 	/* Special translations for 'wildmenu' */
 	if (did_wild_list && p_wmnu)
@@ -1511,10 +1518,11 @@ getcmdline(firstc, count, indent)
 		    char_u	*p;
 		    int		len;
 		    int		old_firstc;
 
 		    vim_free(ccline.cmdbuff);
+		    xpc.xp_context = EXPAND_NOTHING;
 		    if (hiscnt == hislen)
 			p = lookfor;	/* back to the old one */
 		    else
 			p = history[histype][hiscnt].hisstr;
 
@@ -1837,10 +1845,11 @@ returncmd:
 #ifdef FEAT_FKMAP
     cmd_fkmap = 0;
 #endif
 
     ExpandCleanup(&xpc);
+    ccline.xpc = NULL;
 
 #ifdef FEAT_SEARCH_EXTRA
     if (did_incsearch)
     {
 	curwin->w_cursor = old_cursor;
@@ -1988,21 +1997,36 @@ text_locked_msg()
 	EMSG(_(e_secure));
 }
 
 #if defined(FEAT_AUTOCMD) || defined(PROTO)
 /*
- * Check if "curbuf_lock" is set and return TRUE when it is and give an error
- * message.
+ * Check if "curbuf_lock" or "allbuf_lock" is set and return TRUE when it is
+ * and give an error message.
  */
     int
 curbuf_locked()
 {
     if (curbuf_lock > 0)
     {
 	EMSG(_("E788: Not allowed to edit another buffer now"));
 	return TRUE;
     }
+    return allbuf_locked();
+}
+
+/*
+ * Check if "allbuf_lock" is set and return TRUE when it is and give an error
+ * message.
+ */
+    int
+allbuf_locked()
+{
+    if (allbuf_lock > 0)
+    {
+	EMSG(_("E811: Not allowed to change buffer information now"));
+	return TRUE;
+    }
     return FALSE;
 }
 #endif
 
     static int
@@ -2086,15 +2110,14 @@ correct_cmdspos(idx, cells)
 #endif
 
 /*
  * Get an Ex command line for the ":" command.
  */
-/* ARGSUSED */
     char_u *
-getexline(c, dummy, indent)
+getexline(c, cookie, indent)
     int		c;		/* normally ':', NUL for ":append" */
-    void	*dummy;		/* cookie not used */
+    void	*cookie UNUSED;
     int		indent;		/* indent for inside conditionals */
 {
     /* When executing a register, remove ':' that's in front of each line. */
     if (exec_from_reg && vpeekc() == ':')
 	(void)vgetc();
@@ -2105,16 +2128,15 @@ getexline(c, dummy, indent)
  * Get an Ex command line for Ex mode.
  * In Ex mode we only use the OS supplied line editing features and no
  * mappings or abbreviations.
  * Returns a string in allocated memory or NULL.
  */
-/* ARGSUSED */
     char_u *
-getexmodeline(promptc, dummy, indent)
+getexmodeline(promptc, cookie, indent)
     int		promptc;	/* normally ':', NUL for ":append" and '?' for
 				   :s prompt */
-    void	*dummy;		/* cookie not used */
+    void	*cookie UNUSED;
     int		indent;		/* indent for inside conditionals */
 {
     garray_T	line_ga;
     char_u	*pend;
     int		startcol = 0;
@@ -2169,11 +2191,10 @@ getexmodeline(promptc, dummy, indent)
     got_int = FALSE;
     while (!got_int)
     {
 	if (ga_grow(&line_ga, 40) == FAIL)
 	    break;
-	pend = (char_u *)line_ga.ga_data + line_ga.ga_len;
 
 	/* Get one character at a time.  Don't use inchar(), it can't handle
 	 * special characters. */
 	prev_char = c1;
 	c1 = vgetc();
@@ -2506,10 +2527,24 @@ realloc_cmdbuff(len)
 	ccline.cmdbuff = p;		/* keep the old one */
 	return FAIL;
     }
     mch_memmove(ccline.cmdbuff, p, (size_t)ccline.cmdlen + 1);
     vim_free(p);
+
+    if (ccline.xpc != NULL
+	    && ccline.xpc->xp_pattern != NULL
+	    && ccline.xpc->xp_context != EXPAND_NOTHING
+	    && ccline.xpc->xp_context != EXPAND_UNSUCCESSFUL)
+    {
+	int i = (int)(ccline.xpc->xp_pattern - p);
+
+	/* If xp_pattern points inside the old cmdbuff it needs to be adjusted
+	 * to point into the newly allocated memory. */
+	if (i >= 0 && i <= ccline.cmdlen)
+	    ccline.xpc->xp_pattern = ccline.cmdbuff + i;
+    }
+
     return OK;
 }
 
 #if defined(FEAT_ARABIC) || defined(PROTO)
 static char_u	*arshape_buf = NULL;
@@ -2873,10 +2908,11 @@ save_cmdline(ccp)
     }
     *ccp = prev_ccline;
     prev_ccline = ccline;
     ccline.cmdbuff = NULL;
     ccline.cmdprompt = NULL;
+    ccline.xpc = NULL;
 }
 
 /*
  * Restore ccline after it has been saved with save_cmdline().
  */
@@ -3227,11 +3263,10 @@ nextwild(xp, type, options)
     int		options;	/* extra options for ExpandOne() */
 {
     int		i, j;
     char_u	*p1;
     char_u	*p2;
-    int		oldlen;
     int		difflen;
     int		v;
 
     if (xp->xp_numfiles == -1)
     {
@@ -3252,11 +3287,11 @@ nextwild(xp, type, options)
 
     MSG_PUTS("...");	    /* show that we are busy */
     out_flush();
 
     i = (int)(xp->xp_pattern - ccline.cmdbuff);
-    oldlen = ccline.cmdpos - i;
+    xp->xp_pattern_len = ccline.cmdpos - i;
 
     if (type == WILD_NEXT || type == WILD_PREV)
     {
 	/*
 	 * Get next/previous match for a previous expanded pattern.
@@ -3266,22 +3301,24 @@ nextwild(xp, type, options)
     else
     {
 	/*
 	 * Translate string into pattern and expand it.
 	 */
-	if ((p1 = addstar(&ccline.cmdbuff[i], oldlen, xp->xp_context)) == NULL)
+	if ((p1 = addstar(xp->xp_pattern, xp->xp_pattern_len,
+						     xp->xp_context)) == NULL)
 	    p2 = NULL;
 	else
 	{
-	    p2 = ExpandOne(xp, p1, vim_strnsave(&ccline.cmdbuff[i], oldlen),
+	    p2 = ExpandOne(xp, p1,
+			 vim_strnsave(&ccline.cmdbuff[i], xp->xp_pattern_len),
 		    WILD_HOME_REPLACE|WILD_ADD_SLASH|WILD_SILENT|WILD_ESCAPE
 							      |options, type);
 	    vim_free(p1);
-	    /* longest match: make sure it is not shorter (happens with :help */
+	    /* longest match: make sure it is not shorter, happens with :help */
 	    if (p2 != NULL && type == WILD_LONGEST)
 	    {
-		for (j = 0; j < oldlen; ++j)
+		for (j = 0; j < xp->xp_pattern_len; ++j)
 		     if (ccline.cmdbuff[i + j] == '*'
 			     || ccline.cmdbuff[i + j] == '?')
 			 break;
 		if ((int)STRLEN(p2) < j)
 		{
@@ -3292,11 +3329,11 @@ nextwild(xp, type, options)
 	}
     }
 
     if (p2 != NULL && !got_int)
     {
-	difflen = (int)STRLEN(p2) - oldlen;
+	difflen = (int)STRLEN(p2) - xp->xp_pattern_len;
 	if (ccline.cmdlen + difflen > ccline.cmdbufflen - 4)
 	{
 	    v = realloc_cmdbuff(ccline.cmdlen + difflen);
 	    xp->xp_pattern = ccline.cmdbuff + i;
 	}
@@ -3580,10 +3617,12 @@ ExpandOne(xp, str, orig, options, mode)
  */
     void
 ExpandInit(xp)
     expand_T	*xp;
 {
+    xp->xp_pattern = NULL;
+    xp->xp_pattern_len = 0;
     xp->xp_backslash = XP_BS_NONE;
 #ifndef BACKSLASH_IN_FILENAME
     xp->xp_shell = FALSE;
 #endif
     xp->xp_numfiles = -1;
@@ -3789,15 +3828,14 @@ tilde_replace(orig_pat, num_files, files
 /*
  * Show all matches for completion on the command line.
  * Returns EXPAND_NOTHING when the character that triggered expansion should
  * be inserted like a normal character.
  */
-/*ARGSUSED*/
     static int
 showmatches(xp, wildmenu)
     expand_T	*xp;
-    int		wildmenu;
+    int		wildmenu UNUSED;
 {
 #define L_SHOWFILE(m) (showtail ? sm_gettail(files_found[m]) : files_found[m])
     int		num_files;
     char_u	**files_found;
     int		i, j, k;
@@ -4272,12 +4310,12 @@ expand_cmdline(xp, str, col, matchcount,
 	/* Caller can use the character as a normal char instead */
 	return EXPAND_NOTHING;
     }
 
     /* add star to file name, or convert to regexp if not exp. files. */
-    file_str = addstar(xp->xp_pattern,
-			   (int)(str + col - xp->xp_pattern), xp->xp_context);
+    xp->xp_pattern_len = (int)(str + col - xp->xp_pattern);
+    file_str = addstar(xp->xp_pattern, xp->xp_pattern_len, xp->xp_context);
     if (file_str == NULL)
 	return EXPAND_UNSUCCESSFUL;
 
     /* find all files that match the description */
     if (ExpandFromContext(xp, file_str, matchcount, matches,
@@ -4381,11 +4419,12 @@ ExpandFromContext(xp, pat, num_file, fil
 
 	if (xp->xp_context == EXPAND_FILES)
 	    flags |= EW_FILE;
 	else
 	    flags = (flags | EW_DIR) & ~EW_FILE;
-	ret = expand_wildcards(1, &pat, num_file, file, flags);
+	/* Expand wildcards, supporting %:h and the like. */
+	ret = expand_wildcards_eval(&pat, num_file, file, flags);
 	if (free_pat)
 	    vim_free(pat);
 	return ret;
     }
 
@@ -4451,10 +4490,11 @@ ExpandFromContext(xp, pat, num_file, fil
 	    char_u	*((*func)__ARGS((expand_T *, int)));
 	    int		ic;
 	} tab[] =
 	{
 	    {EXPAND_COMMANDS, get_command_name, FALSE},
+	    {EXPAND_BEHAVE, get_behave_arg, TRUE},
 #ifdef FEAT_USR_CMDS
 	    {EXPAND_USER_COMMANDS, get_user_commands, FALSE},
 	    {EXPAND_USER_CMD_FLAGS, get_user_cmd_flags, FALSE},
 	    {EXPAND_USER_NARGS, get_user_cmd_nargs, FALSE},
 	    {EXPAND_USER_COMPLETE, get_user_cmd_complete, FALSE},
@@ -4475,10 +4515,19 @@ ExpandFromContext(xp, pat, num_file, fil
 	    {EXPAND_HIGHLIGHT, get_highlight_name, TRUE},
 #ifdef FEAT_AUTOCMD
 	    {EXPAND_EVENTS, get_event_name, TRUE},
 	    {EXPAND_AUGROUP, get_augroup_name, TRUE},
 #endif
+#ifdef FEAT_CSCOPE
+	    {EXPAND_CSCOPE, get_cscope_name, TRUE},
+#endif
+#ifdef FEAT_SIGNS
+	    {EXPAND_SIGN, get_sign_name, TRUE},
+#endif
+#ifdef FEAT_PROFILE
+	    {EXPAND_PROFILE, get_profile_name, TRUE},
+#endif
 #if (defined(HAVE_LOCALE_H) || defined(X_LOCALE)) \
 	&& (defined(FEAT_GETTEXT) || defined(FEAT_MBYTE))
 	    {EXPAND_LANGUAGE, get_lang_arg, TRUE},
 #endif
 	    {EXPAND_ENV_VARS, get_env_name, TRUE},
@@ -4488,11 +4537,11 @@ ExpandFromContext(xp, pat, num_file, fil
 	/*
 	 * Find a context in the table and call the ExpandGeneric() with the
 	 * right function to do the expansion.
 	 */
 	ret = FAIL;
-	for (i = 0; i < sizeof(tab) / sizeof(struct expgen); ++i)
+	for (i = 0; i < (int)(sizeof(tab) / sizeof(struct expgen)); ++i)
 	    if (xp->xp_context == tab[i].context)
 	    {
 		if (tab[i].ic)
 		    regmatch.rm_ic = TRUE;
 		ret = ExpandGeneric(xp, &regmatch, num_file, file, tab[i].func);
@@ -4736,11 +4785,11 @@ call_user_expand_func(user_expand_func,
 	keep = ccline.cmdbuff[ccline.cmdlen];
 	ccline.cmdbuff[ccline.cmdlen] = 0;
 	sprintf((char *)num, "%d", ccline.cmdpos);
 	args[1] = ccline.cmdbuff;
     }
-    args[0] = xp->xp_pattern;
+    args[0] = vim_strnsave(xp->xp_pattern, xp->xp_pattern_len);
     args[2] = num;
 
     /* Save the cmdline, we don't know what the function may do. */
     save_ccline = ccline;
     ccline.cmdbuff = NULL;
@@ -4752,10 +4801,11 @@ call_user_expand_func(user_expand_func,
     ccline = save_ccline;
     current_SID = save_current_SID;
     if (ccline.cmdbuff != NULL)
 	ccline.cmdbuff[ccline.cmdlen] = keep;
 
+    vim_free(args[0]);
     return ret;
 }
 
 /*
  * Expand names with a function defined by the user.
@@ -4829,18 +4879,18 @@ ExpandUserList(xp, num_file, file)
 
     ga_init2(&ga, (int)sizeof(char *), 3);
     /* Loop over the items in the list. */
     for (li = retlist->lv_first; li != NULL; li = li->li_next)
     {
-	if (li->li_tv.v_type != VAR_STRING)
-	    continue;  /* Skip non-string items */
+	if (li->li_tv.v_type != VAR_STRING || li->li_tv.vval.v_string == NULL)
+	    continue;  /* Skip non-string items and empty strings */
 
 	if (ga_grow(&ga, 1) == FAIL)
 	    break;
 
 	((char_u **)ga.ga_data)[ga.ga_len] =
-	    vim_strsave(li->li_tv.vval.v_string);
+					 vim_strsave(li->li_tv.vval.v_string);
 	++ga.ga_len;
     }
     list_unref(retlist);
 
     *file = ga.ga_data;
@@ -4869,11 +4919,11 @@ ExpandRTDir(pat, num_file, file, dirname
     *file = NULL;
     s = alloc((unsigned)(STRLEN(pat) + STRLEN(dirname) + 7));
     if (s == NULL)
 	return FAIL;
     sprintf((char *)s, "%s/%s*.vim", dirname, pat);
-    all = globpath(p_rtp, s);
+    all = globpath(p_rtp, s, 0);
     vim_free(s);
     if (all == NULL)
 	return FAIL;
 
     ga_init2(&ga, (int)sizeof(char *), 3);
@@ -4910,13 +4960,14 @@ ExpandRTDir(pat, num_file, file, dirname
  * Expand "file" for all comma-separated directories in "path".
  * Returns an allocated string with all matches concatenated, separated by
  * newlines.  Returns NULL for an error or no matches.
  */
     char_u *
-globpath(path, file)
+globpath(path, file, expand_options)
     char_u	*path;
     char_u	*file;
+    int		expand_options;
 {
     expand_T	xpc;
     char_u	*buf;
     garray_T	ga;
     int		i;
@@ -4941,14 +4992,14 @@ globpath(path, file)
 	copy_option_part(&path, buf, MAXPATHL, ",");
 	if (STRLEN(buf) + STRLEN(file) + 2 < MAXPATHL)
 	{
 	    add_pathsep(buf);
 	    STRCAT(buf, file);
-	    if (ExpandFromContext(&xpc, buf, &num_p, &p, WILD_SILENT) != FAIL
-								 && num_p > 0)
+	    if (ExpandFromContext(&xpc, buf, &num_p, &p,
+			     WILD_SILENT|expand_options) != FAIL && num_p > 0)
 	    {
-		ExpandEscape(&xpc, buf, num_p, p, WILD_SILENT);
+		ExpandEscape(&xpc, buf, num_p, p, WILD_SILENT|expand_options);
 		for (len = 0, i = 0; i < num_p; ++i)
 		    len += (int)STRLEN(p[i]) + 1;
 
 		/* Concatenate new results to previous ones. */
 		if (ga_grow(&ga, len) == OK)
@@ -5639,11 +5690,11 @@ ex_history(eap)
 	i = *end;
 	*end = NUL;
 	histype1 = get_histtype(arg);
 	if (histype1 == -1)
 	{
-	    if (STRICMP(arg, "all") == 0)
+	    if (STRNICMP(arg, "all", STRLEN(arg)) == 0)
 	    {
 		histype1 = 0;
 		histype2 = HIST_COUNT-1;
 	    }
 	    else
@@ -6018,20 +6069,21 @@ ex_window()
 # ifdef FEAT_AUTOCMD
 	unblock_autocmds();
 # endif
 	return K_IGNORE;
     }
-    cmdwin_type = ccline.cmdfirstc;
-    if (cmdwin_type == NUL)
-	cmdwin_type = '-';
+    cmdwin_type = get_cmdline_type();
 
     /* Create the command-line buffer empty. */
-    (void)do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE);
+    (void)do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL);
     (void)setfname(curbuf, (char_u *)"[Command Line]", NULL, TRUE);
     set_option_value((char_u *)"bt", 0L, (char_u *)"nofile", OPT_LOCAL);
     set_option_value((char_u *)"swf", 0L, NULL, OPT_LOCAL);
     curbuf->b_p_ma = TRUE;
+#ifdef FEAT_FOLDING
+    curwin->w_p_fen = FALSE;
+#endif
 # ifdef FEAT_RIGHTLEFT
     curwin->w_p_rl = cmdmsg_rl;
     cmdmsg_rl = FALSE;
 # endif
 # ifdef FEAT_SCROLLBIND
@@ -6044,11 +6096,11 @@ ex_window()
 # endif
 
     /* Showing the prompt may have set need_wait_return, reset it. */
     need_wait_return = FALSE;
 
-    histtype = hist_char2type(ccline.cmdfirstc);
+    histtype = hist_char2type(cmdwin_type);
     if (histtype == HIST_CMD || histtype == HIST_DEBUG)
     {
 	if (p_wc == TAB)
 	{
 	    add_map((char_u *)"<buffer> <Tab> <C-X><C-V>", INSERT);
@@ -6198,11 +6250,15 @@ ex_window()
 # endif
 	wp = curwin;
 	bp = curbuf;
 	win_goto(old_curwin);
 	win_close(wp, TRUE);
-	close_buffer(NULL, bp, DOBUF_WIPE);
+
+	/* win_close() may have already wiped the buffer when 'bh' is
+	 * set to 'wipe' */
+	if (buf_valid(bp))
+	    close_buffer(NULL, bp, DOBUF_WIPE);
 
 	/* Restore window sizes. */
 	win_size_restore(&winsizes);
 
 # ifdef FEAT_AUTOCMD
--- vim72.orig/src/ex_cmds.c
+++ vim72/src/ex_cmds.c
@@ -22,11 +22,11 @@
 static int linelen __ARGS((int *has_tab));
 #endif
 static void do_filter __ARGS((linenr_T line1, linenr_T line2, exarg_T *eap, char_u *cmd, int do_in, int do_out));
 #ifdef FEAT_VIMINFO
 static char_u *viminfo_filename __ARGS((char_u	*));
-static void do_viminfo __ARGS((FILE *fp_in, FILE *fp_out, int want_info, int want_marks, int force_read));
+static void do_viminfo __ARGS((FILE *fp_in, FILE *fp_out, int flags));
 static int viminfo_encoding __ARGS((vir_T *virp));
 static int read_viminfo_up_to_marks __ARGS((vir_T *virp, int forceit, int writing));
 #endif
 
 static int check_overwrite __ARGS((exarg_T *eap, buf_T *buf, char_u *fname, char_u *ffname, int other));
@@ -41,16 +41,16 @@ static int
 	help_compare __ARGS((const void *s1, const void *s2));
 
 /*
  * ":ascii" and "ga".
  */
-/*ARGSUSED*/
     void
 do_ascii(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     int		c;
+    int		cval;
     char	buf1[20];
     char	buf2[20];
     char_u	buf3[7];
 #ifdef FEAT_MBYTE
     int		cc[MAX_MCO];
@@ -73,30 +73,35 @@ do_ascii(eap)
     if (!has_mbyte || (enc_dbcs != 0 && c < 0x100) || c < 0x80)
 #endif
     {
 	if (c == NL)	    /* NUL is stored as NL */
 	    c = NUL;
+	if (c == CAR && get_fileformat(curbuf) == EOL_MAC)
+	    cval = NL;	    /* NL is stored as CR */
+	else
+	    cval = c;
 	if (vim_isprintc_strict(c) && (c < ' '
 #ifndef EBCDIC
 		    || c > '~'
 #endif
 			       ))
 	{
 	    transchar_nonprint(buf3, c);
-	    sprintf(buf1, "  <%s>", (char *)buf3);
+	    vim_snprintf(buf1, sizeof(buf1), "  <%s>", (char *)buf3);
 	}
 	else
 	    buf1[0] = NUL;
 #ifndef EBCDIC
 	if (c >= 0x80)
-	    sprintf(buf2, "  <M-%s>", transchar(c & 0x7f));
+	    vim_snprintf(buf2, sizeof(buf2), "  <M-%s>",
+						 (char *)transchar(c & 0x7f));
 	else
 #endif
 	    buf2[0] = NUL;
 	vim_snprintf((char *)IObuff, IOSIZE,
 		_("<%s>%s%s  %d,  Hex %02x,  Octal %03o"),
-					   transchar(c), buf1, buf2, c, c, c);
+				  transchar(c), buf1, buf2, cval, cval, cval);
 #ifdef FEAT_MBYTE
 	if (enc_utf8)
 	    c = cc[ci++];
 	else
 	    c = 0;
@@ -351,11 +356,11 @@ ex_sort(eap)
     regmatch_T	regmatch;
     int		len;
     linenr_T	lnum;
     long	maxlen = 0;
     sorti_T	*nrs;
-    size_t	count = eap->line2 - eap->line1 + 1;
+    size_t	count = (size_t)(eap->line2 - eap->line1 + 1);
     size_t	i;
     char_u	*p;
     char_u	*s;
     char_u	*s2;
     char_u	c;			/* temporary character storage */
@@ -950,11 +955,11 @@ do_bang(addr_count, eap, forceit, do_in,
 		vim_free(newcmd);
 		return;
 	    }
 	    len += (int)STRLEN(prevcmd);
 	}
-	if ((t = alloc(len)) == NULL)
+	if ((t = alloc((unsigned)len)) == NULL)
 	{
 	    vim_free(newcmd);
 	    return;
 	}
 	*t = NUL;
@@ -1541,11 +1546,11 @@ make_filter_cmd(cmd, itmp, otmp)
     /*
      * Put braces around the command (for concatenated commands) when
      * redirecting input and/or output.
      */
     if (itmp != NULL || otmp != NULL)
-	sprintf((char *)buf, "(%s)", (char *)cmd);
+	vim_snprintf((char *)buf, len, "(%s)", (char *)cmd);
     else
 	STRCPY(buf, cmd);
     if (itmp != NULL)
     {
 	STRCAT(buf, " < ");
@@ -1590,41 +1595,45 @@ make_filter_cmd(cmd, itmp, otmp)
 	    }
 	}
     }
 #endif
     if (otmp != NULL)
-	append_redir(buf, p_srr, otmp);
+	append_redir(buf, (int)len, p_srr, otmp);
 
     return buf;
 }
 
 /*
- * Append output redirection for file "fname" to the end of string buffer "buf"
+ * Append output redirection for file "fname" to the end of string buffer
+ * "buf[buflen]"
  * Works with the 'shellredir' and 'shellpipe' options.
  * The caller should make sure that there is enough room:
  *	STRLEN(opt) + STRLEN(fname) + 3
  */
     void
-append_redir(buf, opt, fname)
+append_redir(buf, buflen, opt, fname)
     char_u	*buf;
+    int		buflen;
     char_u	*opt;
     char_u	*fname;
 {
     char_u	*p;
+    char_u	*end;
 
-    buf += STRLEN(buf);
+    end = buf + STRLEN(buf);
     /* find "%s", skipping "%%" */
     for (p = opt; (p = vim_strchr(p, '%')) != NULL; ++p)
 	if (p[1] == 's')
 	    break;
     if (p != NULL)
     {
-	*buf = ' '; /* not really needed? Not with sh, ksh or bash */
-	sprintf((char *)buf + 1, (char *)opt, (char *)fname);
+	*end = ' '; /* not really needed? Not with sh, ksh or bash */
+	vim_snprintf((char *)end + 1, (size_t)(buflen - (end + 1 - buf)),
+						  (char *)opt, (char *)fname);
     }
     else
-	sprintf((char *)buf,
+	vim_snprintf((char *)end, (size_t)(buflen - (end - buf)),
 #ifdef FEAT_QUICKFIX
 # ifndef RISCOS
 		opt != p_sp ? " %s%s" :
 # endif
 		" %s %s",
@@ -1674,50 +1683,48 @@ viminfo_error(errnum, message, line)
     return FALSE;
 }
 
 /*
  * read_viminfo() -- Read the viminfo file.  Registers etc. which are already
- * set are not over-written unless force is TRUE. -- webb
+ * set are not over-written unless "flags" includes VIF_FORCEIT. -- webb
  */
     int
-read_viminfo(file, want_info, want_marks, forceit)
-    char_u	*file;
-    int		want_info;
-    int		want_marks;
-    int		forceit;
+read_viminfo(file, flags)
+    char_u	*file;	    /* file name or NULL to use default name */
+    int		flags;	    /* VIF_WANT_INFO et al. */
 {
     FILE	*fp;
     char_u	*fname;
 
     if (no_viminfo())
 	return FAIL;
 
-    fname = viminfo_filename(file);	    /* may set to default if NULL */
+    fname = viminfo_filename(file);	/* get file name in allocated buffer */
     if (fname == NULL)
 	return FAIL;
     fp = mch_fopen((char *)fname, READBIN);
 
     if (p_verbose > 0)
     {
 	verbose_enter();
 	smsg((char_u *)_("Reading viminfo file \"%s\"%s%s%s"),
 		fname,
-		want_info ? _(" info") : "",
-		want_marks ? _(" marks") : "",
+		(flags & VIF_WANT_INFO) ? _(" info") : "",
+		(flags & VIF_WANT_MARKS) ? _(" marks") : "",
+		(flags & VIF_GET_OLDFILES) ? _(" oldfiles") : "",
 		fp == NULL ? _(" FAILED") : "");
 	verbose_leave();
     }
 
     vim_free(fname);
     if (fp == NULL)
 	return FAIL;
 
     viminfo_errcnt = 0;
-    do_viminfo(fp, NULL, want_info, want_marks, forceit);
+    do_viminfo(fp, NULL, flags);
 
     fclose(fp);
-
     return OK;
 }
 
 /*
  * write_viminfo() -- Write the viminfo file.  The old one is read in first so
@@ -1784,11 +1791,11 @@ write_viminfo(file, forceit)
 	/*
 	 * For Unix we check the owner of the file.  It's not very nice to
 	 * overwrite a user's viminfo file after a "su root", with a
 	 * viminfo file that the user can't read.
 	 */
-	st_old.st_dev = 0;
+	st_old.st_dev = (dev_t)0;
 	st_old.st_ino = 0;
 	st_old.st_mode = 0600;
 	if (mch_stat((char *)fname, &st_old) == 0
 		&& getuid() != ROOT_UID
 		&& !(st_old.st_uid == getuid()
@@ -1941,11 +1948,11 @@ write_viminfo(file, forceit)
 	    /*
 	     * Make sure the owner can read/write it.  This only works for
 	     * root.
 	     */
 	    if (fp_out != NULL)
-		(void)fchown(fileno(fp_out), st_old.st_uid, st_old.st_gid);
+		ignored = fchown(fileno(fp_out), st_old.st_uid, st_old.st_gid);
 #endif
 	}
     }
 
     /*
@@ -1966,11 +1973,11 @@ write_viminfo(file, forceit)
 	smsg((char_u *)_("Writing viminfo file \"%s\""), fname);
 	verbose_leave();
     }
 
     viminfo_errcnt = 0;
-    do_viminfo(fp_in, fp_out, !forceit, !forceit, FALSE);
+    do_viminfo(fp_in, fp_out, forceit ? 0 : (VIF_WANT_INFO | VIF_WANT_MARKS));
 
     fclose(fp_out);	    /* errors are ignored !? */
     if (fp_in != NULL)
     {
 	fclose(fp_in);
@@ -2039,16 +2046,14 @@ viminfo_filename(file)
 
 /*
  * do_viminfo() -- Should only be called from read_viminfo() & write_viminfo().
  */
     static void
-do_viminfo(fp_in, fp_out, want_info, want_marks, force_read)
+do_viminfo(fp_in, fp_out, flags)
     FILE	*fp_in;
     FILE	*fp_out;
-    int		want_info;
-    int		want_marks;
-    int		force_read;
+    int		flags;
 {
     int		count = 0;
     int		eof = FALSE;
     vir_T	vir;
 
@@ -2059,12 +2064,13 @@ do_viminfo(fp_in, fp_out, want_info, wan
     vir.vir_conv.vc_type = CONV_NONE;
 #endif
 
     if (fp_in != NULL)
     {
-	if (want_info)
-	    eof = read_viminfo_up_to_marks(&vir, force_read, fp_out != NULL);
+	if (flags & VIF_WANT_INFO)
+	    eof = read_viminfo_up_to_marks(&vir,
+					 flags & VIF_FORCEIT, fp_out != NULL);
 	else
 	    /* Skip info, find start of marks */
 	    while (!(eof = viminfo_readline(&vir))
 		    && vir.vir_line[0] != '>')
 		;
@@ -2090,12 +2096,13 @@ do_viminfo(fp_in, fp_out, want_info, wan
 #endif
 	write_viminfo_filemarks(fp_out);
 	write_viminfo_bufferlist(fp_out);
 	count = write_viminfo_marks(fp_out);
     }
-    if (fp_in != NULL && want_marks)
-	copy_viminfo_marks(&vir, fp_out, count, eof);
+    if (fp_in != NULL
+	    && (flags & (VIF_WANT_MARKS | VIF_GET_OLDFILES | VIF_FORCEIT)))
+	copy_viminfo_marks(&vir, fp_out, count, eof, flags);
 
     vim_free(vir.vir_line);
 #ifdef FEAT_MBYTE
     if (vir.vir_conv.vc_type != CONV_NONE)
 	convert_setup(&vir.vir_conv, NULL, NULL);
@@ -2246,16 +2253,15 @@ viminfo_readline(virp)
  *
  * Check for a long line as written by viminfo_writestring().
  *
  * Return the string in allocated memory (NULL when out of memory).
  */
-/*ARGSUSED*/
     char_u *
 viminfo_readstring(virp, off, convert)
     vir_T	*virp;
     int		off;		    /* offset for virp->vir_line */
-    int		convert;	    /* convert the string */
+    int		convert UNUSED;	    /* convert the string */
 {
     char_u	*retval;
     char_u	*s, *d;
     long	len;
 
@@ -2363,14 +2369,13 @@ viminfo_writestring(fd, p)
  * Implementation of ":fixdel", also used by get_stty().
  *  <BS>    resulting <Del>
  *   ^?		^H
  * not ^?	^?
  */
-/*ARGSUSED*/
     void
 do_fixdel(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     char_u  *p;
 
     p = find_termcode((char_u *)"kb");
     add_termcode((char_u *)"kD", p != NULL
@@ -2385,11 +2390,12 @@ print_line_no_prefix(lnum, use_number, l
 {
     char_u	numbuf[30];
 
     if (curwin->w_p_nu || use_number)
     {
-	sprintf((char *)numbuf, "%*ld ", number_width(curwin), (long)lnum);
+	vim_snprintf((char *)numbuf, sizeof(numbuf),
+				   "%*ld ", number_width(curwin), (long)lnum);
 	msg_puts_attr(numbuf, hl_attr(HLF_N));	/* Highlight line nrs */
     }
     msg_prt_line(ml_get(lnum), list);
 }
 
@@ -2412,12 +2418,12 @@ print_line(lnum, use_number, list)
     {
 	msg_putchar('\n');
 	cursor_on();		/* msg_start() switches it off */
 	out_flush();
 	silent_mode = save_silent;
-	info_message = FALSE;
     }
+    info_message = FALSE;
 }
 
 /*
  * ":file[!] [fname]".
  */
@@ -2702,11 +2708,16 @@ do_write(eap)
 
 	/* After ":saveas fname" reset 'readonly'. */
 	if (eap->cmdidx == CMD_saveas)
 	{
 	    if (retval == OK)
+	    {
 		curbuf->b_p_ro = FALSE;
+#ifdef FEAT_WINDOWS
+		redraw_tabline = TRUE;
+#endif
+	    }
 	    /* Change directories when the 'acd' option is set. */
 	    DO_AUTOCHDIR
 	}
     }
 
@@ -2722,11 +2733,10 @@ theend:
  * Check if it is allowed to overwrite a file.  If b_flags has BF_NOTEDITED,
  * BF_NEW or BF_READERR, check for overwriting current file.
  * May set eap->forceit if a dialog says it's OK to overwrite.
  * Return OK if it's OK, FAIL if it is not.
  */
-/*ARGSUSED*/
     static int
 check_overwrite(eap, buf, fname, ffname, other)
     exarg_T	*eap;
     buf_T	*buf;
     char_u	*fname;	    /* file name to be used (can differ from
@@ -3052,11 +3062,12 @@ getfile(fnum, ffname, sfname, setpm, lnu
 	check_cursor_lnum();
 	beginline(BL_SOL | BL_FIX);
 	retval = 0;	/* it's in the same file */
     }
     else if (do_ecmd(fnum, ffname, sfname, NULL, lnum,
-		(P_HID(curbuf) ? ECMD_HIDE : 0) + (forceit ? ECMD_FORCEIT : 0)) == OK)
+		(P_HID(curbuf) ? ECMD_HIDE : 0) + (forceit ? ECMD_FORCEIT : 0),
+		curwin) == OK)
 	retval = -1;	/* opened another file */
     else
 	retval = 1;	/* error encountered */
 
 theend:
@@ -3085,21 +3096,25 @@ theend:
  *	   ECMD_HIDE: if TRUE don't free the current buffer
  *     ECMD_SET_HELP: set b_help flag of (new) buffer before opening file
  *	 ECMD_OLDBUF: use existing buffer if it exists
  *	ECMD_FORCEIT: ! used for Ex command
  *	 ECMD_ADDBUF: don't edit, just add to buffer list
+ *   oldwin: Should be "curwin" when editing a new buffer in the current
+ *           window, NULL when splitting the window first.  When not NULL info
+ *           of the previous buffer for "oldwin" is stored.
  *
  * return FAIL for failure, OK otherwise
  */
     int
-do_ecmd(fnum, ffname, sfname, eap, newlnum, flags)
+do_ecmd(fnum, ffname, sfname, eap, newlnum, flags, oldwin)
     int		fnum;
     char_u	*ffname;
     char_u	*sfname;
     exarg_T	*eap;			/* can be NULL! */
     linenr_T	newlnum;
     int		flags;
+    win_T	*oldwin;
 {
     int		other_file;		/* TRUE if editing another file */
     int		oldbuf;			/* TRUE if using existing buffer */
 #ifdef FEAT_AUTOCMD
     int		auto_buf = FALSE;	/* TRUE if autocommands brought us
@@ -3267,11 +3282,12 @@ do_ecmd(fnum, ffname, sfname, eap, newln
 	if (!(flags & ECMD_ADDBUF))
 #endif
 	{
 	    if (!cmdmod.keepalt)
 		curwin->w_alt_fnum = curbuf->b_fnum;
-	    buflist_altfpos();
+	    if (oldwin != NULL)
+		buflist_altfpos(oldwin);
 	}
 
 	if (fnum)
 	    buf = buflist_findnr(fnum);
 	else
@@ -3371,11 +3387,11 @@ do_ecmd(fnum, ffname, sfname, eap, newln
 #endif
 		    buf_copy_options(buf, BCO_ENTER);
 
 		/* close the link to the current buffer */
 		u_sync(FALSE);
-		close_buffer(curwin, curbuf,
+		close_buffer(oldwin, curbuf,
 				      (flags & ECMD_HIDE) ? 0 : DOBUF_UNLOAD);
 
 #ifdef FEAT_AUTOCMD
 # ifdef FEAT_EVAL
 		if (aborting())	    /* autocmds may abort script processing */
@@ -3699,11 +3715,11 @@ do_ecmd(fnum, ffname, sfname, eap, newln
 
 #ifdef FEAT_SPELL
     /* If the window options were changed may need to set the spell language.
      * Can only do this after the buffer has been properly setup. */
     if (did_get_winopts && curwin->w_p_spell && *curbuf->b_p_spl != NUL)
-	did_set_spelllang(curbuf);
+	(void)did_set_spelllang(curbuf);
 #endif
 
     if (command == NULL)
     {
 	if (newcol >= 0)	/* position set by autocommands */
@@ -3772,11 +3788,11 @@ do_ecmd(fnum, ffname, sfname, eap, newln
     if (command != NULL)
 	do_cmdline(command, NULL, NULL, DOCMD_VERBOSE);
 
 #ifdef FEAT_KEYMAP
     if (curbuf->b_kmap_state & KEYMAP_INIT)
-	keymap_init();
+	(void)keymap_init();
 #endif
 
     --RedrawingDisabled;
     if (!skip_redraw)
     {
@@ -3995,10 +4011,13 @@ ex_change(eap)
     {
 	if (curbuf->b_ml.ml_flags & ML_EMPTY)	    /* nothing to delete */
 	    break;
 	ml_delete(eap->line1, FALSE);
     }
+
+    /* make sure the cursor is not beyond the end of the file now */
+    check_cursor_lnum();
     deleted_lines_mark(eap->line1, (long)(eap->line2 - lnum));
 
     /* ":append" on the line above the deleted lines. */
     eap->line2 = eap->line1;
     ex_append(eap);
@@ -4020,12 +4039,14 @@ ex_z(eap)
      * 'scroll' */
     if (eap->forceit)
 	bigness = curwin->w_height;
     else if (firstwin == lastwin)
 	bigness = curwin->w_p_scr * 2;
+#ifdef FEAT_WINDOWS
     else
 	bigness = curwin->w_height - 3;
+#endif
     if (bigness < 1)
 	bigness = 1;
 
     x = eap->arg;
     kind = x;
@@ -4470,11 +4491,11 @@ do_sub(eap)
 	    char_u	*new_end, *new_start = NULL;
 	    unsigned	new_start_len = 0;
 	    char_u	*p1;
 	    int		did_sub = FALSE;
 	    int		lastone;
-	    unsigned	len, needed_len;
+	    int		len, copy_len, needed_len;
 	    long	nmatch_tl = 0;	/* nr of lines matched below lnum */
 	    int		do_again;	/* do it again after joining lines */
 	    int		skip_match = FALSE;
 	    linenr_T	sub_firstlnum;	/* nr of first sub line */
 
@@ -4615,10 +4636,12 @@ do_sub(eap)
 		    goto skip;
 		}
 
 		if (do_ask)
 		{
+		    int typed = 0;
+
 		    /* change State to CONFIRM, so that the mouse works
 		     * properly */
 		    save_State = State;
 		    State = CONFIRM;
 #ifdef FEAT_MOUSE
@@ -4653,11 +4676,11 @@ do_sub(eap)
 				msg_putchar('^');
 
 			    resp = getexmodeline('?', NULL, 0);
 			    if (resp != NULL)
 			    {
-				i = *resp;
+				typed = *resp;
 				vim_free(resp);
 			    }
 			}
 			else
 			{
@@ -4705,61 +4728,61 @@ do_sub(eap)
 #ifdef USE_ON_FLY_SCROLL
 			    dont_scroll = FALSE; /* allow scrolling here */
 #endif
 			    ++no_mapping;	/* don't map this key */
 			    ++allow_keys;	/* allow special keys */
-			    i = plain_vgetc();
+			    typed = plain_vgetc();
 			    --allow_keys;
 			    --no_mapping;
 
 			    /* clear the question */
 			    msg_didout = FALSE;	/* don't scroll up */
 			    msg_col = 0;
 			    gotocmdline(TRUE);
 			}
 
 			need_wait_return = FALSE; /* no hit-return prompt */
-			if (i == 'q' || i == ESC || i == Ctrl_C
+			if (typed == 'q' || typed == ESC || typed == Ctrl_C
 #ifdef UNIX
-				|| i == intr_char
+				|| typed == intr_char
 #endif
 				)
 			{
 			    got_quit = TRUE;
 			    break;
 			}
-			if (i == 'n')
+			if (typed == 'n')
 			    break;
-			if (i == 'y')
+			if (typed == 'y')
 			    break;
-			if (i == 'l')
+			if (typed == 'l')
 			{
 			    /* last: replace and then stop */
 			    do_all = FALSE;
 			    line2 = lnum;
 			    break;
 			}
-			if (i == 'a')
+			if (typed == 'a')
 			{
 			    do_ask = FALSE;
 			    break;
 			}
 #ifdef FEAT_INS_EXPAND
-			if (i == Ctrl_E)
+			if (typed == Ctrl_E)
 			    scrollup_clamp();
-			else if (i == Ctrl_Y)
+			else if (typed == Ctrl_Y)
 			    scrolldown_clamp();
 #endif
 		    }
 		    State = save_State;
 #ifdef FEAT_MOUSE
 		    setmouse();
 #endif
 		    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)
 			--no_u_sync;
 
-		    if (i == 'n')
+		    if (typed == 'n')
 		    {
 			/* For a multi-line match, put matchcol at the NUL at
 			 * the end of the line and set nmatch to one, so that
 			 * we continue looking for a match on the next line.
 			 * Avoids that ":%s/\nB\@=//gc" and ":%s/\n/,\r/gc"
@@ -4806,13 +4829,13 @@ do_sub(eap)
 		else
 		{
 		    p1 = ml_get(sub_firstlnum + nmatch - 1);
 		    nmatch_tl += nmatch - 1;
 		}
-		i = regmatch.startpos[0].col - copycol;
-		needed_len = i + ((unsigned)STRLEN(p1) - regmatch.endpos[0].col)
-								 + sublen + 1;
+		copy_len = regmatch.startpos[0].col - copycol;
+		needed_len = copy_len + ((unsigned)STRLEN(p1)
+				       - regmatch.endpos[0].col) + sublen + 1;
 		if (new_start == NULL)
 		{
 		    /*
 		     * Get some space for a temporary buffer to do the
 		     * substitution into (and some extra space to avoid
@@ -4831,11 +4854,11 @@ do_sub(eap)
 		     * substitution into.  If not, make it larger (with a bit
 		     * extra to avoid too many calls to alloc()/free()).
 		     */
 		    len = (unsigned)STRLEN(new_start);
 		    needed_len += len;
-		    if (needed_len > new_start_len)
+		    if (needed_len > (int)new_start_len)
 		    {
 			new_start_len = needed_len + 50;
 			if ((p1 = alloc_check(new_start_len)) == NULL)
 			{
 			    vim_free(new_start);
@@ -4849,12 +4872,12 @@ do_sub(eap)
 		}
 
 		/*
 		 * copy the text up to the part that matched
 		 */
-		mch_memmove(new_end, sub_firstline + copycol, (size_t)i);
-		new_end += i;
+		mch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);
+		new_end += copy_len;
 
 		(void)vim_regsub_multi(&regmatch,
 				    sub_firstlnum - regmatch.startpos[0].lnum,
 					   sub, new_end, TRUE, p_magic, TRUE);
 		sub_nsubs++;
@@ -5057,10 +5080,11 @@ skip:
 		line_breakcheck();
 	    }
 
 	    if (did_sub)
 		++sub_nlines;
+	    vim_free(new_start);	/* for when substitute was cancelled */
 	    vim_free(sub_firstline);	/* free the copy of the original line */
 	    sub_firstline = NULL;
 	}
 
 	line_breakcheck();
@@ -5608,11 +5632,17 @@ ex_help(eap)
 	     * set b_p_ro flag).
 	     * Set the alternate file to the previously edited file.
 	     */
 	    alt_fnum = curbuf->b_fnum;
 	    (void)do_ecmd(0, NULL, NULL, NULL, ECMD_LASTL,
-						   ECMD_HIDE + ECMD_SET_HELP);
+			  ECMD_HIDE + ECMD_SET_HELP,
+#ifdef FEAT_WINDOWS
+			  NULL  /* buffer is still open, don't store info */
+#else
+			  curwin
+#endif
+		    );
 	    if (!cmdmod.keepalt)
 		curwin->w_alt_fnum = alt_fnum;
 	    empty_fnum = curbuf->b_fnum;
 	}
     }
@@ -5767,11 +5797,11 @@ find_help_tags(arg, num_matches, matches
 
     /*
      * Recognize a few exceptions to the rule.	Some strings that contain '*'
      * with "star".  Otherwise '*' is recognized as a wildcard.
      */
-    for (i = sizeof(mtable) / sizeof(char *); --i >= 0; )
+    for (i = (int)(sizeof(mtable) / sizeof(char *)); --i >= 0; )
 	if (STRCMP(arg, mtable[i]) == 0)
 	{
 	    STRCPY(d, rtable[i]);
 	    break;
 	}
@@ -6091,25 +6121,23 @@ fix_help_buffer()
 }
 
 /*
  * ":exusage"
  */
-/*ARGSUSED*/
     void
 ex_exusage(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     do_cmdline_cmd((char_u *)"help ex-cmd-index");
 }
 
 /*
  * ":viusage"
  */
-/*ARGSUSED*/
     void
 ex_viusage(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     do_cmdline_cmd((char_u *)"help normal-index");
 }
 
 #if defined(FEAT_EX_EXTRA) || defined(PROTO)
@@ -6517,26 +6545,15 @@ struct sign
 };
 
 static sign_T	*first_sign = NULL;
 static int	last_sign_typenr = MAX_TYPENR;	/* is decremented */
 
+static int sign_cmd_idx __ARGS((char_u *begin_cmd, char_u *end_cmd));
 static void sign_list_defined __ARGS((sign_T *sp));
+static void sign_undefine __ARGS((sign_T *sp, sign_T *sp_prev));
 
-/*
- * ":sign" command
- */
-    void
-ex_sign(eap)
-    exarg_T	*eap;
-{
-    char_u	*arg = eap->arg;
-    char_u	*p;
-    int		idx;
-    sign_T	*sp;
-    sign_T	*sp_prev;
-    buf_T	*buf;
-    static char	*cmds[] = {
+static char *cmds[] = {
 			"define",
 #define SIGNCMD_DEFINE	0
 			"undefine",
 #define SIGNCMD_UNDEFINE 1
 			"list",
@@ -6545,26 +6562,55 @@ ex_sign(eap)
 #define SIGNCMD_PLACE	3
 			"unplace",
 #define SIGNCMD_UNPLACE	4
 			"jump",
 #define SIGNCMD_JUMP	5
+			NULL
 #define SIGNCMD_LAST	6
-    };
+};
+
+/*
+ * Find index of a ":sign" subcmd from its name.
+ * "*end_cmd" must be writable.
+ */
+    static int
+sign_cmd_idx(begin_cmd, end_cmd)
+    char_u	*begin_cmd;	/* begin of sign subcmd */
+    char_u	*end_cmd;	/* just after sign subcmd */
+{
+    int		idx;
+    char	save = *end_cmd;
+
+    *end_cmd = NUL;
+    for (idx = 0; ; ++idx)
+	if (cmds[idx] == NULL || STRCMP(begin_cmd, cmds[idx]) == 0)
+	    break;
+    *end_cmd = save;
+    return idx;
+}
+
+/*
+ * ":sign" command
+ */
+    void
+ex_sign(eap)
+    exarg_T	*eap;
+{
+    char_u	*arg = eap->arg;
+    char_u	*p;
+    int		idx;
+    sign_T	*sp;
+    sign_T	*sp_prev;
+    buf_T	*buf;
 
     /* Parse the subcommand. */
     p = skiptowhite(arg);
-    if (*p != NUL)
-	*p++ = NUL;
-    for (idx = 0; ; ++idx)
+    idx = sign_cmd_idx(arg, p);
+    if (idx == SIGNCMD_LAST)
     {
-	if (idx == SIGNCMD_LAST)
-	{
-	    EMSG2(_("E160: Unknown sign command: %s"), arg);
-	    return;
-	}
-	if (STRCMP(arg, cmds[idx]) == 0)
-	    break;
+	EMSG2(_("E160: Unknown sign command: %s"), arg);
+	return;
     }
     arg = skipwhite(p);
 
     if (idx <= SIGNCMD_LIST)
     {
@@ -6726,28 +6772,12 @@ ex_sign(eap)
 		EMSG2(_("E155: Unknown sign: %s"), arg);
 	    else if (idx == SIGNCMD_LIST)
 		/* ":sign list {name}" */
 		sign_list_defined(sp);
 	    else
-	    {
 		/* ":sign undefine {name}" */
-		vim_free(sp->sn_name);
-		vim_free(sp->sn_icon);
-#ifdef FEAT_SIGN_ICONS
-		if (sp->sn_image != NULL)
-		{
-		    out_flush();
-		    gui_mch_destroy_sign(sp->sn_image);
-		}
-#endif
-		vim_free(sp->sn_text);
-		if (sp_prev == NULL)
-		    first_sign = sp->sn_next;
-		else
-		    sp_prev->sn_next = sp->sn_next;
-		vim_free(sp);
-	    }
+		sign_undefine(sp, sp_prev);
 	}
     }
     else
     {
 	int		id = -1;
@@ -6992,10 +7022,35 @@ sign_list_defined(sp)
 	    msg_puts(p);
     }
 }
 
 /*
+ * Undefine a sign and free its memory.
+ */
+    static void
+sign_undefine(sp, sp_prev)
+    sign_T	*sp;
+    sign_T	*sp_prev;
+{
+    vim_free(sp->sn_name);
+    vim_free(sp->sn_icon);
+#ifdef FEAT_SIGN_ICONS
+    if (sp->sn_image != NULL)
+    {
+	out_flush();
+	gui_mch_destroy_sign(sp->sn_image);
+    }
+#endif
+    vim_free(sp->sn_text);
+    if (sp_prev == NULL)
+	first_sign = sp->sn_next;
+    else
+	sp_prev->sn_next = sp->sn_next;
+    vim_free(sp);
+}
+
+/*
  * Get highlighting attribute for sign "typenr".
  * If "line" is TRUE: line highl, if FALSE: text highl.
  */
     int
 sign_get_attr(typenr, line)
@@ -7065,10 +7120,201 @@ sign_typenr2name(typenr)
 	if (sp->sn_typenr == typenr)
 	    return sp->sn_name;
     return (char_u *)_("[Deleted]");
 }
 
+#if defined(EXITFREE) || defined(PROTO)
+/*
+ * Undefine/free all signs.
+ */
+    void
+free_signs()
+{
+    while (first_sign != NULL)
+	sign_undefine(first_sign, NULL);
+}
+#endif
+
+#if defined(FEAT_CMDL_COMPL) || defined(PROTO)
+static enum
+{
+    EXP_SUBCMD,		/* expand :sign sub-commands */
+    EXP_DEFINE,		/* expand :sign define {name} args */
+    EXP_PLACE,		/* expand :sign place {id} args */
+    EXP_UNPLACE,	/* expand :sign unplace" */
+    EXP_SIGN_NAMES	/* expand with name of placed signs */
+} expand_what;
+
+/*
+ * Function given to ExpandGeneric() to obtain the sign command
+ * expansion.
+ */
+    char_u *
+get_sign_name(xp, idx)
+    expand_T	*xp UNUSED;
+    int		idx;
+{
+    sign_T	*sp;
+    int		current_idx;
+
+    switch (expand_what)
+    {
+    case EXP_SUBCMD:
+	return (char_u *)cmds[idx];
+    case EXP_DEFINE:
+	{
+	    char *define_arg[] =
+	    {
+		"icon=", "linehl=", "text=", "texthl=", NULL
+	    };
+	    return (char_u *)define_arg[idx];
+	}
+    case EXP_PLACE:
+	{
+	    char *place_arg[] =
+	    {
+		"line=", "name=", "file=", "buffer=", NULL
+	    };
+	    return (char_u *)place_arg[idx];
+	}
+    case EXP_UNPLACE:
+	{
+	    char *unplace_arg[] = { "file=", "buffer=", NULL };
+	    return (char_u *)unplace_arg[idx];
+	}
+    case EXP_SIGN_NAMES:
+	/* Complete with name of signs already defined */
+	current_idx = 0;
+	for (sp = first_sign; sp != NULL; sp = sp->sn_next)
+	    if (current_idx++ == idx)
+		return sp->sn_name;
+	return NULL;
+    default:
+	return NULL;
+    }
+}
+
+/*
+ * Handle command line completion for :sign command.
+ */
+    void
+set_context_in_sign_cmd(xp, arg)
+    expand_T	*xp;
+    char_u	*arg;
+{
+    char_u	*p;
+    char_u	*end_subcmd;
+    char_u	*last;
+    int		cmd_idx;
+    char_u	*begin_subcmd_args;
+
+    /* Default: expand subcommands. */
+    xp->xp_context = EXPAND_SIGN;
+    expand_what = EXP_SUBCMD;
+    xp->xp_pattern = arg;
+
+    end_subcmd = skiptowhite(arg);
+    if (*end_subcmd == NUL)
+	/* expand subcmd name
+	 * :sign {subcmd}<CTRL-D>*/
+	return;
+
+    cmd_idx = sign_cmd_idx(arg, end_subcmd);
+
+    /* :sign {subcmd} {subcmd_args}
+     *                |
+     *                begin_subcmd_args */
+    begin_subcmd_args = skipwhite(end_subcmd);
+    p = skiptowhite(begin_subcmd_args);
+    if (*p == NUL)
+    {
+	/*
+	 * Expand first argument of subcmd when possible.
+	 * For ":jump {id}" and ":unplace {id}", we could
+	 * possibly expand the ids of all signs already placed.
+	 */
+	xp->xp_pattern = begin_subcmd_args;
+	switch (cmd_idx)
+	{
+	    case SIGNCMD_LIST:
+	    case SIGNCMD_UNDEFINE:
+		/* :sign list <CTRL-D>
+		 * :sign undefine <CTRL-D> */
+		expand_what = EXP_SIGN_NAMES;
+		break;
+	    default:
+		xp->xp_context = EXPAND_NOTHING;
+	}
+	return;
+    }
+
+    /* expand last argument of subcmd */
+
+    /* :sign define {name} {args}...
+     *              |
+     *              p */
+
+    /* Loop until reaching last argument. */
+    do
+    {
+	p = skipwhite(p);
+	last = p;
+	p = skiptowhite(p);
+    } while (*p != NUL);
+
+    p = vim_strchr(last, '=');
+
+    /* :sign define {name} {args}... {last}=
+     *                               |     |
+     *                            last     p */
+    if (p == NUL)
+    {
+	/* Expand last argument name (before equal sign). */
+	xp->xp_pattern = last;
+	switch (cmd_idx)
+	{
+	    case SIGNCMD_DEFINE:
+		expand_what = EXP_DEFINE;
+		break;
+	    case SIGNCMD_PLACE:
+		expand_what = EXP_PLACE;
+		break;
+	    case SIGNCMD_JUMP:
+	    case SIGNCMD_UNPLACE:
+		expand_what = EXP_UNPLACE;
+		break;
+	    default:
+		xp->xp_context = EXPAND_NOTHING;
+	}
+    }
+    else
+    {
+	/* Expand last argument value (after equal sign). */
+	xp->xp_pattern = p + 1;
+	switch (cmd_idx)
+	{
+	    case SIGNCMD_DEFINE:
+		if (STRNCMP(last, "texthl", p - last) == 0 ||
+		    STRNCMP(last, "linehl", p - last) == 0)
+		    xp->xp_context = EXPAND_HIGHLIGHT;
+		else if (STRNCMP(last, "icon", p - last) == 0)
+		    xp->xp_context = EXPAND_FILES;
+		else
+		    xp->xp_context = EXPAND_NOTHING;
+		break;
+	    case SIGNCMD_PLACE:
+		if (STRNCMP(last, "name", p - last) == 0)
+		    expand_what = EXP_SIGN_NAMES;
+		else
+		    xp->xp_context = EXPAND_NOTHING;
+		break;
+	    default:
+		xp->xp_context = EXPAND_NOTHING;
+	}
+    }
+}
+#endif
 #endif
 
 #if defined(FEAT_GUI) || defined(FEAT_CLIENTSERVER) || defined(PROTO)
 /*
  * ":drop"
--- vim72.orig/src/ex_cmds.h
+++ vim72/src/ex_cmds.h
@@ -276,11 +276,11 @@ EX(CMD_cpfile,		"cpfile",	ex_cnext,
 EX(CMD_cquit,		"cquit",	ex_cquit,
 			TRLBAR|BANG),
 EX(CMD_crewind,		"crewind",	ex_cc,
 			RANGE|NOTADR|COUNT|TRLBAR|BANG),
 EX(CMD_cscope,		"cscope",	do_cscope,
-			EXTRA|NOTRLCOM|SBOXOK|XFILE),
+			EXTRA|NOTRLCOM|XFILE),
 EX(CMD_cstag,		"cstag",	do_cstag,
 			BANG|TRLBAR|WORD1),
 EX(CMD_cunmap,		"cunmap",	ex_unmap,
 			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
 EX(CMD_cunabbrev,	"cunabbrev",	ex_abbreviate,
@@ -504,11 +504,11 @@ EX(CMD_lcd,		"lcd",		ex_cd,
 EX(CMD_lchdir,		"lchdir",	ex_cd,
 			BANG|FILE1|TRLBAR|CMDWIN),
 EX(CMD_lclose,		"lclose",	ex_cclose,
 			RANGE|NOTADR|COUNT|TRLBAR),
 EX(CMD_lcscope,		"lcscope",	do_cscope,
-			EXTRA|NOTRLCOM|SBOXOK|XFILE),
+			EXTRA|NOTRLCOM|XFILE),
 EX(CMD_left,		"left",		ex_align,
 			TRLBAR|RANGE|WHOLEFOLD|EXTRA|CMDWIN|MODIFY),
 EX(CMD_leftabove,	"leftabove",	ex_wrongmodifier,
 			NEEDARG|EXTRA|NOTRLCOM),
 EX(CMD_let,		"let",		ex_let,
@@ -633,10 +633,12 @@ EX(CMD_nnoremap,	"nnoremap",	ex_map,
 			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
 EX(CMD_nnoremenu,	"nnoremenu",	ex_menu,
 			RANGE|NOTADR|ZEROR|EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
 EX(CMD_noremap,		"noremap",	ex_map,
 			BANG|EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
+EX(CMD_noautocmd,	"noautocmd",	ex_wrongmodifier,
+			NEEDARG|EXTRA|NOTRLCOM),
 EX(CMD_nohlsearch,	"nohlsearch",	ex_nohlsearch,
 			TRLBAR|SBOXOK|CMDWIN),
 EX(CMD_noreabbrev,	"noreabbrev",	ex_abbreviate,
 			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
 EX(CMD_noremenu,	"noremenu",	ex_menu,
@@ -649,10 +651,12 @@ EX(CMD_nunmap,		"nunmap",	ex_unmap,
 			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
 EX(CMD_nunmenu,		"nunmenu",	ex_menu,
 			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
 EX(CMD_open,		"open",		ex_open,
 			RANGE|EXTRA),
+EX(CMD_oldfiles,	"oldfiles",	ex_oldfiles,
+			BANG|TRLBAR|SBOXOK|CMDWIN),
 EX(CMD_omap,		"omap",		ex_map,
 			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
 EX(CMD_omapclear,	"omapclear",	ex_mapclear,
 			EXTRA|TRLBAR|CMDWIN),
 EX(CMD_omenu,		"omenu",	ex_menu,
@@ -800,11 +804,11 @@ EX(CMD_sbrewind,	"sbrewind",	ex_brewind,
 EX(CMD_scriptnames,	"scriptnames",	ex_scriptnames,
 			TRLBAR|CMDWIN),
 EX(CMD_scriptencoding,	"scriptencoding", ex_scriptencoding,
 			WORD1|TRLBAR|CMDWIN),
 EX(CMD_scscope,		"scscope",	do_scscope,
-			EXTRA|NOTRLCOM|SBOXOK),
+			EXTRA|NOTRLCOM),
 EX(CMD_set,		"set",		ex_set,
 			TRLBAR|EXTRA|CMDWIN|SBOXOK),
 EX(CMD_setfiletype,	"setfiletype",	ex_setfiletype,
 			TRLBAR|EXTRA|NEEDARG|CMDWIN),
 EX(CMD_setglobal,	"setglobal",	ex_set,
@@ -985,10 +989,12 @@ EX(CMD_unlockvar,	"unlockvar",	ex_lockva
 			BANG|EXTRA|NEEDARG|SBOXOK|CMDWIN),
 EX(CMD_unmap,		"unmap",	ex_unmap,
 			BANG|EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
 EX(CMD_unmenu,		"unmenu",	ex_menu,
 			BANG|EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
+EX(CMD_unsilent,	"unsilent",	ex_wrongmodifier,
+			NEEDARG|EXTRA|NOTRLCOM|SBOXOK|CMDWIN),
 EX(CMD_update,		"update",	ex_update,
 			RANGE|WHOLEFOLD|BANG|FILE1|ARGOPT|DFLALL|TRLBAR),
 EX(CMD_vglobal,		"vglobal",	ex_global,
 			RANGE|WHOLEFOLD|EXTRA|DFLALL|CMDWIN),
 EX(CMD_version,		"version",	ex_version,
--- vim72.orig/src/ex_docmd.c
+++ vim72/src/ex_docmd.c
@@ -24,14 +24,16 @@ typedef struct ucmd
 {
     char_u	*uc_name;	/* The command name */
     long_u	uc_argt;	/* The argument type */
     char_u	*uc_rep;	/* The command's replacement string */
     long	uc_def;		/* The default value for a range/count */
-    scid_T	uc_scriptID;	/* SID where the command was defined */
     int		uc_compl;	/* completion type */
-# if defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
+# ifdef FEAT_EVAL
+    scid_T	uc_scriptID;	/* SID where the command was defined */
+#  ifdef FEAT_CMDL_COMPL
     char_u	*uc_compl_arg;	/* completion argument if any */
+#  endif
 # endif
 } ucmd_T;
 
 #define UC_BUFFER	1	/* -buffer: local to current buffer */
 
@@ -362,10 +364,11 @@ static void	ex_tag_cmd __ARGS((exarg_T *
 # define ex_lockvar		ex_ni
 # define ex_unlockvar		ex_ni
 # define ex_function		ex_ni
 # define ex_delfunction		ex_ni
 # define ex_return		ex_ni
+# define ex_oldfiles		ex_ni
 #endif
 static char_u	*arg_all __ARGS((void));
 #ifdef FEAT_SESSION
 static int	makeopens __ARGS((FILE *fd, char_u *dirnow));
 static int	put_view __ARGS((FILE *fd, win_T *wp, int add_edit, unsigned *flagp, int current_arg_idx));
@@ -1575,15 +1578,14 @@ free_cmdlines(gap)
 
 /*
  * If "fgetline" is get_loop_line(), return TRUE if the getline it uses equals
  * "func".  * Otherwise return TRUE when "fgetline" equals "func".
  */
-/*ARGSUSED*/
     int
 getline_equal(fgetline, cookie, func)
     char_u	*(*fgetline) __ARGS((int, void *, int));
-    void	*cookie;		/* argument for fgetline() */
+    void	*cookie UNUSED;		/* argument for fgetline() */
     char_u	*(*func) __ARGS((int, void *, int));
 {
 #ifdef FEAT_EVAL
     char_u		*(*gp) __ARGS((int, void *, int));
     struct loop_cookie *cp;
@@ -1607,14 +1609,13 @@ getline_equal(fgetline, cookie, func)
 #if defined(FEAT_EVAL) || defined(FEAT_MBYTE) || defined(PROTO)
 /*
  * If "fgetline" is get_loop_line(), return the cookie used by the original
  * getline function.  Otherwise return "cookie".
  */
-/*ARGSUSED*/
     void *
 getline_cookie(fgetline, cookie)
-    char_u	*(*fgetline) __ARGS((int, void *, int));
+    char_u	*(*fgetline) __ARGS((int, void *, int)) UNUSED;
     void	*cookie;		/* argument for fgetline() */
 {
 # ifdef FEAT_EVAL
     char_u		*(*gp) __ARGS((int, void *, int));
     struct loop_cookie *cp;
@@ -1676,12 +1677,12 @@ do_one_cmd(cmdlinep, sourcing,
     linenr_T		lnum;
     long		n;
     char_u		*errormsg = NULL;	/* error message */
     exarg_T		ea;			/* Ex command arguments */
     long		verbose_save = -1;
-    int			save_msg_scroll = 0;
-    int			did_silent = 0;
+    int			save_msg_scroll = msg_scroll;
+    int			save_msg_silent = -1;
     int			did_esilent = 0;
 #ifdef HAVE_SANDBOX
     int			did_sandbox = FALSE;
 #endif
     cmdmod_T		save_cmdmod;
@@ -1768,11 +1769,11 @@ do_one_cmd(cmdlinep, sourcing,
 #endif
 			    continue;
 			}
 			if (checkforcmd(&ea.cmd, "browse", 3))
 			{
-#ifdef FEAT_BROWSE
+#ifdef FEAT_BROWSE_CMD
 			    cmdmod.browse = TRUE;
 #endif
 			    continue;
 			}
 			if (!checkforcmd(&ea.cmd, "botright", 2))
@@ -1855,13 +1856,13 @@ do_one_cmd(cmdlinep, sourcing,
 #endif
 			    continue;
 			}
 			if (!checkforcmd(&ea.cmd, "silent", 3))
 			    break;
-			++did_silent;
+			if (save_msg_silent == -1)
+			    save_msg_silent = msg_silent;
 			++msg_silent;
-			save_msg_scroll = msg_scroll;
 			if (*ea.cmd == '!' && !vim_iswhite(ea.cmd[-1]))
 			{
 			    /* ":silent!", but not "silent !cmd" */
 			    ea.cmd = skipwhite(ea.cmd + 1);
 			    ++emsg_silent;
@@ -1885,10 +1886,17 @@ do_one_cmd(cmdlinep, sourcing,
 #ifdef FEAT_WINDOWS
 			cmdmod.split |= WSP_TOP;
 #endif
 			continue;
 
+	    case 'u':	if (!checkforcmd(&ea.cmd, "unsilent", 3))
+			    break;
+			if (save_msg_silent == -1)
+			    save_msg_silent = msg_silent;
+			msg_silent = 0;
+			continue;
+
 	    case 'v':	if (checkforcmd(&ea.cmd, "vertical", 4))
 			{
 #ifdef FEAT_VERTSPLIT
 			    cmdmod.split |= WSP_VERT;
 #endif
@@ -2683,23 +2691,27 @@ doend:
     }
 #endif
 
     cmdmod = save_cmdmod;
 
-    if (did_silent > 0)
+    if (save_msg_silent != -1)
     {
 	/* messages could be enabled for a serious error, need to check if the
 	 * counters don't become negative */
-	msg_silent -= did_silent;
-	if (msg_silent < 0)
-	    msg_silent = 0;
+	if (!did_emsg || msg_silent > save_msg_silent)
+	    msg_silent = save_msg_silent;
 	emsg_silent -= did_esilent;
 	if (emsg_silent < 0)
 	    emsg_silent = 0;
 	/* Restore msg_scroll, it's set by file I/O commands, even when no
 	 * message is actually displayed. */
 	msg_scroll = save_msg_scroll;
+
+	/* "silent reg" or "silent echo x" inside "redir" leaves msg_col
+	 * somewhere in the line.  Put it back in the first column. */
+	if (redirecting())
+	    msg_col = 0;
     }
 
 #ifdef HAVE_SANDBOX
     if (did_sandbox)
 	--sandbox;
@@ -2729,11 +2741,11 @@ checkforcmd(pp, cmd, len)
     int		len;		/* required length */
 {
     int		i;
 
     for (i = 0; cmd[i] != NUL; ++i)
-	if (cmd[i] != (*pp)[i])
+	if (((char_u *)cmd)[i] != (*pp)[i])
 	    break;
     if (i >= len && !isalpha((*pp)[i]))
     {
 	*pp = skipwhite(*pp + i);
 	return TRUE;
@@ -2746,15 +2758,14 @@ checkforcmd(pp, cmd, len)
  * Start of the name can be found at eap->cmd.
  * Returns pointer to char after the command name.
  * "full" is set to TRUE if the whole command name matched.
  * Returns NULL for an ambiguous user command.
  */
-/*ARGSUSED*/
     static char_u *
 find_command(eap, full)
     exarg_T	*eap;
-    int		*full;
+    int		*full UNUSED;
 {
     int		len;
     char_u	*p;
     int		i;
 
@@ -2795,11 +2806,11 @@ find_command(eap, full)
 	if (*eap->cmd == 'd' && (p[-1] == 'l' || p[-1] == 'p'))
 	{
 	    /* Check for ":dl", ":dell", etc. to ":deletel": that's
 	     * :delete with the 'l' flag.  Same for 'p'. */
 	    for (i = 0; i < len; ++i)
-		if (eap->cmd[i] != "delete"[i])
+		if (eap->cmd[i] != ((char_u *)"delete")[i])
 		    break;
 	    if (i == len - 1)
 	    {
 		--len;
 		if (p[-1] == 'l')
@@ -2976,15 +2987,17 @@ static struct cmdmod
     {"keepalt", 5, FALSE},
     {"keepjumps", 5, FALSE},
     {"keepmarks", 3, FALSE},
     {"leftabove", 5, FALSE},
     {"lockmarks", 3, FALSE},
+    {"noautocmd", 3, FALSE},
     {"rightbelow", 6, FALSE},
     {"sandbox", 3, FALSE},
     {"silent", 3, FALSE},
     {"tab", 3, TRUE},
     {"topleft", 2, FALSE},
+    {"unsilent", 3, FALSE},
     {"verbose", 4, TRUE},
     {"vertical", 4, FALSE},
 };
 
 /*
@@ -2998,11 +3011,11 @@ modifier_len(cmd)
     int		i, j;
     char_u	*p = cmd;
 
     if (VIM_ISDIGIT(*cmd))
 	p = skipwhite(skipdigits(cmd));
-    for (i = 0; i < sizeof(cmdmods) / sizeof(struct cmdmod); ++i)
+    for (i = 0; i < (int)(sizeof(cmdmods) / sizeof(struct cmdmod)); ++i)
     {
 	for (j = 0; p[j] != NUL; ++j)
 	    if (p[j] != cmdmods[i].name[j])
 		break;
 	if (!isalpha(p[j]) && j >= cmdmods[i].minlen
@@ -3026,11 +3039,11 @@ cmd_exists(name)
     int		i;
     int		j;
     char_u	*p;
 
     /* Check command modifiers. */
-    for (i = 0; i < sizeof(cmdmods) / sizeof(struct cmdmod); ++i)
+    for (i = 0; i < (int)(sizeof(cmdmods) / sizeof(struct cmdmod)); ++i)
     {
 	for (j = 0; name[j] != NUL; ++j)
 	    if (name[j] != cmdmods[i].name[j])
 		break;
 	if (name[j] == NUL && j >= cmdmods[i].minlen)
@@ -3143,21 +3156,19 @@ set_one_cmd_context(xp, buff)
 	{
 	    xp->xp_context = EXPAND_UNSUCCESSFUL;
 	    return NULL;
 	}
 	for (ea.cmdidx = (cmdidx_T)0; (int)ea.cmdidx < (int)CMD_SIZE;
-					 ea.cmdidx = (cmdidx_T)((int)ea.cmdidx + 1))
-	    if (STRNCMP(cmdnames[(int)ea.cmdidx].cmd_name, cmd, (size_t)len) == 0)
+				   ea.cmdidx = (cmdidx_T)((int)ea.cmdidx + 1))
+	    if (STRNCMP(cmdnames[(int)ea.cmdidx].cmd_name, cmd,
+							    (size_t)len) == 0)
 		break;
 
 #ifdef FEAT_USR_CMDS
 	if (cmd[0] >= 'A' && cmd[0] <= 'Z')
-	{
 	    while (ASCII_ISALNUM(*p) || *p == '*')	/* Allow * wild card */
 		++p;
-	    len = (int)(p - cmd);
-	}
 #endif
     }
 
     /*
      * If the cursor is touching the command, and it ends in an alpha-numeric
@@ -3606,10 +3617,11 @@ set_one_cmd_context(xp, buff)
 #ifdef FEAT_AUTOCMD
 	case CMD_autocmd:
 	    return set_context_in_autocmd(xp, arg, FALSE);
 
 	case CMD_doautocmd:
+	case CMD_doautoall:
 	    return set_context_in_autocmd(xp, arg, TRUE);
 #endif
 	case CMD_set:
 	    set_context_in_set_cmd(xp, arg, 0);
 	    break;
@@ -3678,10 +3690,22 @@ set_one_cmd_context(xp, buff)
 	    break;
 #endif
 	case CMD_highlight:
 	    set_context_in_highlight_cmd(xp, arg);
 	    break;
+#ifdef FEAT_CSCOPE
+	case CMD_cscope:
+	case CMD_lcscope:
+	case CMD_scscope:
+	    set_context_in_cscope_cmd(xp, arg, ea.cmdidx);
+	    break;
+#endif
+#ifdef FEAT_SIGNS
+	case CMD_sign:
+	    set_context_in_sign_cmd(xp, arg);
+	    break;
+#endif
 #ifdef FEAT_LISTCMDS
 	case CMD_bdelete:
 	case CMD_bwipeout:
 	case CMD_bunload:
 	    while ((xp->xp_pattern = vim_strchr(arg, ' ')) != NULL)
@@ -3778,10 +3802,18 @@ set_one_cmd_context(xp, buff)
 	    }
 	    else
 		xp->xp_context = EXPAND_NOTHING;
 	    break;
 #endif
+#if defined(FEAT_PROFILE)
+	case CMD_profile:
+	    set_context_in_profile_cmd(xp, arg);
+	    break;
+#endif
+	case CMD_behave:
+	    xp->xp_context = EXPAND_BEHAVE;
+	    break;
 
 #endif /* FEAT_CMDL_COMPL */
 
 	default:
 	    break;
@@ -3801,11 +3833,11 @@ set_one_cmd_context(xp, buff)
     char_u *
 skip_range(cmd, ctx)
     char_u	*cmd;
     int		*ctx;	/* pointer to xp_context or NULL */
 {
-    int		delim;
+    unsigned	delim;
 
     while (vim_strchr((char_u *)" \t0123456789.$%'/?-+,;", *cmd) != NULL)
     {
 	if (*cmd == '\'')
 	{
@@ -5031,14 +5063,13 @@ check_more(message, forceit)
 
 #ifdef FEAT_CMDL_COMPL
 /*
  * Function given to ExpandGeneric() to obtain the list of command names.
  */
-/*ARGSUSED*/
     char_u *
 get_command_name(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     if (idx >= (int)CMD_SIZE)
 # ifdef FEAT_USR_CMDS
 	return get_user_command_name(idx);
@@ -5119,11 +5150,15 @@ uc_add_command(name, name_len, rep, argt
 		EMSG(_("E174: Command already exists: add ! to replace it"));
 		goto fail;
 	    }
 
 	    vim_free(cmd->uc_rep);
-	    cmd->uc_rep = 0;
+	    cmd->uc_rep = NULL;
+#if defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
+	    vim_free(cmd->uc_compl_arg);
+	    cmd->uc_compl_arg = NULL;
+#endif
 	    break;
 	}
 
 	/* Stop as soon as we pass the name to add */
 	if (cmp < 0)
@@ -5178,10 +5213,13 @@ static struct
 } command_complete[] =
 {
     {EXPAND_AUGROUP, "augroup"},
     {EXPAND_BUFFERS, "buffer"},
     {EXPAND_COMMANDS, "command"},
+#if defined(FEAT_CSCOPE)
+    {EXPAND_CSCOPE, "cscope"},
+#endif
 #if defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
     {EXPAND_USER_DEFINED, "custom"},
     {EXPAND_USER_LIST, "customlist"},
 #endif
     {EXPAND_DIRECTORIES, "dir"},
@@ -5194,10 +5232,13 @@ static struct
     {EXPAND_HIGHLIGHT, "highlight"},
     {EXPAND_MAPPINGS, "mapping"},
     {EXPAND_MENUS, "menu"},
     {EXPAND_SETTINGS, "option"},
     {EXPAND_SHELLCMD, "shellcmd"},
+#if defined(FEAT_SIGNS)
+    {EXPAND_SIGN, "sign"},
+#endif
     {EXPAND_TAGS, "tag"},
     {EXPAND_TAGS_LISTFILES, "tag_listfiles"},
     {EXPAND_USER_VARS, "var"},
     {0, NULL}
 };
@@ -5477,10 +5518,13 @@ invalid_count:
     }
 
     return OK;
 }
 
+/*
+ * ":command ..."
+ */
     static void
 ex_command(eap)
     exarg_T   *eap;
 {
     char_u  *name;
@@ -5538,14 +5582,13 @@ ex_command(eap)
 
 /*
  * ":comclear"
  * Clear all user commands, global and for current buffer.
  */
-/*ARGSUSED*/
     void
 ex_comclear(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     uc_clear(&ucmds);
     uc_clear(&curbuf->b_ucmds);
 }
 
@@ -5908,11 +5951,12 @@ do_ucmd(eap)
     char_u	*buf;
     char_u	*p;
     char_u	*q;
 
     char_u	*start;
-    char_u	*end;
+    char_u	*end = NULL;
+    char_u	*ksp;
     size_t	len, totlen;
 
     size_t	split_len = 0;
     char_u	*split_buf = NULL;
     ucmd_T	*cmd;
@@ -5925,20 +5969,55 @@ do_ucmd(eap)
     else
 	cmd = USER_CMD_GA(&curbuf->b_ucmds, eap->useridx);
 
     /*
      * Replace <> in the command by the arguments.
+     * First round: "buf" is NULL, compute length, allocate "buf".
+     * Second round: copy result into "buf".
      */
     buf = NULL;
     for (;;)
     {
-	p = cmd->uc_rep;
-	q = buf;
+	p = cmd->uc_rep;    /* source */
+	q = buf;	    /* destination */
 	totlen = 0;
-	while ((start = vim_strchr(p, '<')) != NULL
-	       && (end = vim_strchr(start + 1, '>')) != NULL)
+
+	for (;;)
 	{
+	    start = vim_strchr(p, '<');
+	    if (start != NULL)
+		end = vim_strchr(start + 1, '>');
+	    if (buf != NULL)
+	    {
+		ksp = vim_strchr(p, K_SPECIAL);
+		if (ksp != NULL && (start == NULL || ksp < start || end == NULL)
+			&& ((ksp[1] == KS_SPECIAL && ksp[2] == KE_FILLER)
+# ifdef FEAT_GUI
+			    || (ksp[1] == KS_EXTRA && ksp[2] == (int)KE_CSI)
+# endif
+			    ))
+		{
+		    /* K_SPECIAL han been put in the buffer as K_SPECIAL
+		     * KS_SPECIAL KE_FILLER, like for mappings, but
+		     * do_cmdline() doesn't handle that, so convert it back.
+		     * Also change K_SPECIAL KS_EXTRA KE_CSI into CSI. */
+		    len = ksp - p;
+		    if (len > 0)
+		    {
+			mch_memmove(q, p, len);
+			q += len;
+		    }
+		    *q++ = ksp[1] == KS_SPECIAL ? K_SPECIAL : CSI;
+		    p = ksp + 3;
+		    continue;
+		}
+	    }
+
+	    /* break if there no <item> is found */
+	    if (start == NULL || end == NULL)
+		break;
+
 	    /* Include the '>' */
 	    ++end;
 
 	    /* Take everything up to the '<' */
 	    len = start - p;
@@ -6001,14 +6080,13 @@ get_user_command_name(idx)
 }
 
 /*
  * Function given to ExpandGeneric() to obtain the list of user command names.
  */
-/*ARGSUSED*/
     char_u *
 get_user_commands(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     if (idx < curbuf->b_ucmds.ga_len)
 	return USER_CMD_GA(&curbuf->b_ucmds, idx)->uc_name;
     idx -= curbuf->b_ucmds.ga_len;
@@ -6019,48 +6097,45 @@ get_user_commands(xp, idx)
 
 /*
  * Function given to ExpandGeneric() to obtain the list of user command
  * attributes.
  */
-/*ARGSUSED*/
     char_u *
 get_user_cmd_flags(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     static char *user_cmd_flags[] =
 	{"bang", "bar", "buffer", "complete", "count",
 	    "nargs", "range", "register"};
 
-    if (idx >= sizeof(user_cmd_flags) / sizeof(user_cmd_flags[0]))
+    if (idx >= (int)(sizeof(user_cmd_flags) / sizeof(user_cmd_flags[0])))
 	return NULL;
     return (char_u *)user_cmd_flags[idx];
 }
 
 /*
  * Function given to ExpandGeneric() to obtain the list of values for -nargs.
  */
-/*ARGSUSED*/
     char_u *
 get_user_cmd_nargs(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     static char *user_cmd_nargs[] = {"0", "1", "*", "?", "+"};
 
-    if (idx >= sizeof(user_cmd_nargs) / sizeof(user_cmd_nargs[0]))
+    if (idx >= (int)(sizeof(user_cmd_nargs) / sizeof(user_cmd_nargs[0])))
 	return NULL;
     return (char_u *)user_cmd_nargs[idx];
 }
 
 /*
  * Function given to ExpandGeneric() to obtain the list of values for -complete.
  */
-/*ARGSUSED*/
     char_u *
 get_user_cmd_complete(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     return (char_u *)command_complete[idx].name;
 }
 # endif /* FEAT_CMDL_COMPL */
@@ -6234,14 +6309,13 @@ ex_quit(eap)
 }
 
 /*
  * ":cquit".
  */
-/*ARGSUSED*/
     static void
 ex_cquit(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     getout(1);	/* this does not always pass on the exit code to the Manx
 		   compiler. why? */
 }
 
@@ -6679,14 +6753,13 @@ ex_goto(eap)
 #endif
 
 /*
  * ":shell".
  */
-/*ARGSUSED*/
     static void
 ex_shell(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     do_shell(NULL, 0);
 }
 
 #if (defined(FEAT_WINDOWS) && defined(HAVE_DROP_FILE)) \
@@ -6986,14 +7059,13 @@ alist_slash_adjust()
 #endif
 
 /*
  * ":preserve".
  */
-/*ARGSUSED*/
     static void
 ex_preserve(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     curbuf->b_flags |= BF_PRESERVED;
     ml_preserve(curbuf, TRUE);
 }
 
@@ -7221,14 +7293,13 @@ ex_tabmove(eap)
 }
 
 /*
  * :tabs command: List tabs and their contents.
  */
-/*ARGSUSED*/
     static void
 ex_tabs(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     tabpage_T	*tp;
     win_T	*wp;
     int		tabcount = 1;
 
@@ -7411,11 +7482,10 @@ ex_edit(eap)
 }
 
 /*
  * ":edit <file>" command and alikes.
  */
-/*ARGSUSED*/
     void
 do_exedit(eap, old_curwin)
     exarg_T	*eap;
     win_T	*old_curwin;	    /* curwin before doing a split or NULL */
 {
@@ -7483,11 +7553,12 @@ do_exedit(eap, old_curwin)
 		) && *eap->arg == NUL)
     {
 	/* ":new" or ":tabnew" without argument: edit an new empty buffer */
 	setpcmark();
 	(void)do_ecmd(0, NULL, NULL, eap, ECMD_ONE,
-			       ECMD_HIDE + (eap->forceit ? ECMD_FORCEIT : 0));
+		      ECMD_HIDE + (eap->forceit ? ECMD_FORCEIT : 0),
+		      old_curwin == NULL ? curwin : NULL);
     }
     else if ((eap->cmdidx != CMD_split
 #ifdef FEAT_VERTSPLIT
 		&& eap->cmdidx != CMD_vsplit
 #endif
@@ -7520,11 +7591,11 @@ do_exedit(eap, old_curwin)
 		    (P_HID(curbuf) ? ECMD_HIDE : 0)
 		    + (eap->forceit ? ECMD_FORCEIT : 0)
 #ifdef FEAT_LISTCMDS
 		    + (eap->cmdidx == CMD_badd ? ECMD_ADDBUF : 0 )
 #endif
-		    ) == FAIL)
+		    , old_curwin == NULL ? curwin : NULL) == FAIL)
 	{
 	    /* Editing the file failed.  If the window was split, close it. */
 #ifdef FEAT_WINDOWS
 	    if (old_curwin != NULL)
 	    {
@@ -7622,14 +7693,13 @@ ex_popup(eap)
 {
     gui_make_popup(eap->arg, eap->forceit);
 }
 #endif
 
-/*ARGSUSED*/
     static void
 ex_swapname(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     if (curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_mfp->mf_fname == NULL)
 	MSG(_("No swap file"));
     else
 	msg(curbuf->b_ml.ml_mfp->mf_fname);
@@ -7638,14 +7708,13 @@ ex_swapname(eap)
 /*
  * ":syncbind" forces all 'scrollbind' windows to have the same relative
  * offset.
  * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)
  */
-/*ARGSUSED*/
     static void
 ex_syncbind(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
 #ifdef FEAT_SCROLLBIND
     win_T	*wp;
     long	topline;
     long	y;
@@ -7782,14 +7851,14 @@ ex_read(eap)
 		else
 		    lnum = 1;
 		if (*ml_get(lnum) == NUL && u_savedel(lnum, 1L) == OK)
 		{
 		    ml_delete(lnum, FALSE);
-		    deleted_lines_mark(lnum, 1L);
 		    if (curwin->w_cursor.lnum > 1
 					     && curwin->w_cursor.lnum >= lnum)
 			--curwin->w_cursor.lnum;
+		    deleted_lines_mark(lnum, 1L);
 		}
 	    }
 	    redraw_curbuf_later(VALID);
 	}
     }
@@ -7801,10 +7870,13 @@ static char_u	*prev_dir = NULL;
     void
 free_cd_dir()
 {
     vim_free(prev_dir);
     prev_dir = NULL;
+
+    vim_free(globaldir);
+    globaldir = NULL;
 }
 #endif
 
 
 /*
@@ -7823,10 +7895,14 @@ ex_cd(eap)
     if (*new_dir == NUL)
 	ex_pwd(NULL);
     else
 #endif
     {
+#ifdef FEAT_AUTOCMD
+	if (allbuf_locked())
+	    return;
+#endif
 	if (vim_strchr(p_cpo, CPO_CHDIR) != NULL && curbufIsChanged()
 							     && !eap->forceit)
 	{
 	    EMSG(_("E747: Cannot change directory, buffer is modified (add ! to override)"));
 	    return;
@@ -7894,24 +7970,23 @@ ex_cd(eap)
 	    }
 
 	    shorten_fnames(TRUE);
 
 	    /* Echo the new current directory if the command was typed. */
-	    if (KeyTyped)
+	    if (KeyTyped || p_verbose >= 5)
 		ex_pwd(eap);
 	}
 	vim_free(tofree);
     }
 }
 
 /*
  * ":pwd".
  */
-/*ARGSUSED*/
     static void
 ex_pwd(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     if (mch_dirname(NameBuff, MAXPATHL) == OK)
     {
 #ifdef BACKSLASH_IN_FILENAME
 	slash_adjust(NameBuff);
@@ -8289,10 +8364,11 @@ ex_join(eap)
     static void
 ex_at(eap)
     exarg_T	*eap;
 {
     int		c;
+    int		prev_len = typebuf.tb_len;
 
     curwin->w_cursor.lnum = eap->line2;
 
 #ifdef USE_ON_FLY_SCROLL
     dont_scroll = TRUE;		/* disallow scrolling here */
@@ -8314,15 +8390,14 @@ ex_at(eap)
 
 	exec_from_reg = TRUE;
 
 	/*
 	 * Execute from the typeahead buffer.
-	 * Originally this didn't check for the typeahead buffer to be empty,
-	 * thus could read more Ex commands from stdin.  It's not clear why,
-	 * it is certainly unexpected.
+	 * Continue until the stuff buffer is empty and all added characters
+	 * have been consumed.
 	 */
-	while ((!stuff_empty() || typebuf.tb_len > 0) && vpeekc() == ':')
+	while (!stuff_empty() || typebuf.tb_len > prev_len)
 	    (void)do_cmdline(NULL, getexline, NULL, DOCMD_NOWAIT|DOCMD_VERBOSE);
 
 	exec_from_reg = save_efr;
     }
 }
@@ -8338,36 +8413,33 @@ ex_bang(eap)
 }
 
 /*
  * ":undo".
  */
-/*ARGSUSED*/
     static void
 ex_undo(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     if (eap->addr_count == 1)	    /* :undo 123 */
 	undo_time(eap->line2, FALSE, TRUE);
     else
 	u_undo(1);
 }
 
 /*
  * ":redo".
  */
-/*ARGSUSED*/
     static void
 ex_redo(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     u_redo(1);
 }
 
 /*
  * ":earlier" and ":later".
  */
-/*ARGSUSED*/
     static void
 ex_later(eap)
     exarg_T	*eap;
 {
     long	count = 0;
@@ -8548,14 +8620,13 @@ ex_redraw(eap)
 }
 
 /*
  * ":redrawstatus": force redraw of status line(s)
  */
-/*ARGSUSED*/
     static void
 ex_redrawstatus(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
 #if defined(FEAT_WINDOWS)
     int		r = RedrawingDisabled;
     int		p = p_lz;
 
@@ -8628,10 +8699,12 @@ ex_mkrc(eap)
 	return;
 #endif
     }
 
 #ifdef FEAT_SESSION
+    /* Use the short file name until ":lcd" is used.  We also don't use the
+     * short file name when 'acd' is set, that is checked later. */
     did_lcd = FALSE;
 
     /* ":mkview" or ":mkview 9": generate file name with 'viewdir' */
     if (eap->cmdidx == CMD_mkview
 	    && (*eap->arg == NUL
@@ -8747,12 +8820,12 @@ ex_mkrc(eap)
 			shorten_fnames(TRUE);
 		}
 		else if (*dirnow != NUL
 			&& (ssop_flags & SSOP_CURDIR) && globaldir != NULL)
 		{
-		    (void)mch_chdir((char *)globaldir);
-		    shorten_fnames(TRUE);
+		    if (mch_chdir((char *)globaldir) == 0)
+			shorten_fnames(TRUE);
 		}
 
 		failed |= (makeopens(fd, dirnow) == FAIL);
 
 		/* restore original dir */
@@ -8812,15 +8885,14 @@ theend:
 #endif
 }
 
 #if ((defined(FEAT_SESSION) || defined(FEAT_EVAL)) && defined(vim_mkdir)) \
 	|| defined(PROTO)
-/*ARGSUSED*/
     int
 vim_mkdir_emsg(name, prot)
     char_u	*name;
-    int		prot;
+    int		prot UNUSED;
 {
     if (vim_mkdir(name, prot) != 0)
     {
 	EMSG2(_("E739: Cannot create directory: %s"), name);
 	return FAIL;
@@ -9087,14 +9159,13 @@ ex_startinsert(eap)
 }
 
 /*
  * ":stopinsert"
  */
-/*ARGSUSED*/
     static void
 ex_stopinsert(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     restart_edit = 0;
     stop_insert_mode = TRUE;
 }
 #endif
@@ -9364,13 +9435,12 @@ find_cmdline_var(src, usedlen)
 #ifdef FEAT_CLIENTSERVER
 		    "<client>"
 # define SPEC_CLIENT 9
 #endif
     };
-#define SPEC_COUNT  (sizeof(spec_str) / sizeof(char *))
 
-    for (i = 0; i < SPEC_COUNT; ++i)
+    for (i = 0; i < (int)(sizeof(spec_str) / sizeof(char *)); ++i)
     {
 	len = (int)STRLEN(spec_str[i]);
 	if (STRNCMP(src, spec_str[i], len) == 0)
 	{
 	    *usedlen = len;
@@ -9504,28 +9574,54 @@ eval_vars(src, srcstart, usedlen, lnump,
 		    skip_mod = TRUE;
 #endif
 		    break;
 		}
 		s = src + 1;
+		if (*s == '<')		/* "#<99" uses v:oldfiles */
+		    ++s;
 		i = (int)getdigits(&s);
 		*usedlen = (int)(s - src); /* length of what we expand */
 
-		buf = buflist_findnr(i);
-		if (buf == NULL)
+		if (src[1] == '<')
 		{
-		    *errormsg = (char_u *)_("E194: No alternate file name to substitute for '#'");
+		    if (*usedlen < 2)
+		    {
+			/* Should we give an error message for #<text? */
+			*usedlen = 1;
+			return NULL;
+		    }
+#ifdef FEAT_EVAL
+		    result = list_find_str(get_vim_var_list(VV_OLDFILES),
+								     (long)i);
+		    if (result == NULL)
+		    {
+			*errormsg = (char_u *)"";
+			return NULL;
+		    }
+#else
+		    *errormsg = (char_u *)_("E809: #< is not available without the +eval feature");
 		    return NULL;
+#endif
 		}
-		if (lnump != NULL)
-		    *lnump = ECMD_LAST;
-		if (buf->b_fname == NULL)
+		else
 		{
-		    result = (char_u *)"";
-		    valid = 0;	    /* Must have ":p:h" to be valid */
+		    buf = buflist_findnr(i);
+		    if (buf == NULL)
+		    {
+			*errormsg = (char_u *)_("E194: No alternate file name to substitute for '#'");
+			return NULL;
+		    }
+		    if (lnump != NULL)
+			*lnump = ECMD_LAST;
+		    if (buf->b_fname == NULL)
+		    {
+			result = (char_u *)"";
+			valid = 0;	    /* Must have ":p:h" to be valid */
+		    }
+		    else
+			result = buf->b_fname;
 		}
-		else
-		    result = buf->b_fname;
 		break;
 
 #ifdef FEAT_SEARCHPATH
 	case SPEC_CFILE:	/* file name under cursor */
 		result = file_name_at_cursor(FNAME_MESS|FNAME_HYP, 1L, NULL);
@@ -9539,10 +9635,19 @@ eval_vars(src, srcstart, usedlen, lnump,
 #endif
 
 #ifdef FEAT_AUTOCMD
 	case SPEC_AFILE:	/* file name for autocommand */
 		result = autocmd_fname;
+		if (result != NULL && !autocmd_fname_full)
+		{
+		    /* Still need to turn the fname into a full path.  It is
+		     * postponed to avoid a delay when <afile> is not used. */
+		    autocmd_fname_full = TRUE;
+		    result = FullName_save(autocmd_fname, FALSE);
+		    vim_free(autocmd_fname);
+		    autocmd_fname = result;
+		}
 		if (result == NULL)
 		{
 		    *errormsg = (char_u *)_("E495: no autocommand file name to substitute for \"<afile>\"");
 		    return NULL;
 		}
@@ -9682,11 +9787,11 @@ arg_all()
 	    retval[len] = NUL;
 	    break;
 	}
 
 	/* allocate memory */
-	retval = alloc(len + 1);
+	retval = alloc((unsigned)len + 1);
 	if (retval == NULL)
 	    break;
     }
 
     return retval;
@@ -10065,11 +10170,11 @@ makeopens(fd, dirnow)
     /*
      * Lastly, execute the x.vim file if it exists.
      */
     if (put_line(fd, "let s:sx = expand(\"<sfile>:p:r\").\"x.vim\"") == FAIL
 	    || put_line(fd, "if file_readable(s:sx)") == FAIL
-	    || put_line(fd, "  exe \"source \" . s:sx") == FAIL
+	    || put_line(fd, "  exe \"source \" . fnameescape(s:sx)") == FAIL
 	    || put_line(fd, "endif") == FAIL)
 	return FAIL;
 
     return OK;
 }
@@ -10483,10 +10588,13 @@ ses_fname(fd, buf, flagp)
      * Don't do this after ":lcd", we don't keep track of what the current
      * directory is. */
     if (buf->b_sfname != NULL
 	    && flagp == &ssop_flags
 	    && (ssop_flags & (SSOP_CURDIR | SSOP_SESDIR))
+#ifdef FEAT_AUTOCHDIR
+	    && !p_acd
+#endif
 	    && !did_lcd)
 	name = buf->b_sfname;
     else
 	name = buf->b_ffname;
     if (ses_put_fname(fd, name, flagp) == FAIL || put_eol(fd) == FAIL)
@@ -10687,11 +10795,12 @@ ex_viminfo(eap)
     save_viminfo = p_viminfo;
     if (*p_viminfo == NUL)
 	p_viminfo = (char_u *)"'100";
     if (eap->cmdidx == CMD_rviminfo)
     {
-	if (read_viminfo(eap->arg, TRUE, TRUE, eap->forceit) == FAIL)
+	if (read_viminfo(eap->arg, VIF_WANT_INFO | VIF_WANT_MARKS
+				  | (eap->forceit ? VIF_FORCEIT : 0)) == FAIL)
 	    EMSG(_("E195: Cannot open viminfo file for reading"));
     }
     else
 	write_viminfo(eap->arg, eap->forceit);
     p_viminfo = save_viminfo;
@@ -10739,10 +10848,28 @@ ex_behave(eap)
     }
     else
 	EMSG2(_(e_invarg2), eap->arg);
 }
 
+#if defined(FEAT_CMDL_COMPL) || defined(PROTO)
+/*
+ * Function given to ExpandGeneric() to obtain the possible arguments of the
+ * ":behave {mswin,xterm}" command.
+ */
+    char_u *
+get_behave_arg(xp, idx)
+    expand_T	*xp UNUSED;
+    int		idx;
+{
+    if (idx == 0)
+	return (char_u *)"mswin";
+    if (idx == 1)
+	return (char_u *)"xterm";
+    return NULL;
+}
+#endif
+
 #ifdef FEAT_AUTOCMD
 static int filetype_detect = FALSE;
 static int filetype_plugin = FALSE;
 static int filetype_indent = FALSE;
 
@@ -10848,14 +10975,13 @@ ex_setfiletype(eap)
     if (!did_filetype)
 	set_option_value((char_u *)"filetype", 0L, eap->arg, OPT_LOCAL);
 }
 #endif
 
-/*ARGSUSED*/
     static void
 ex_digraphs(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
 #ifdef FEAT_DIGRAPHS
     if (*eap->arg != NUL)
 	putdigraph(eap->arg);
     else
@@ -10885,14 +11011,13 @@ ex_set(eap)
 
 #ifdef FEAT_SEARCH_EXTRA
 /*
  * ":nohlsearch"
  */
-/*ARGSUSED*/
     static void
 ex_nohlsearch(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     no_hlsearch = TRUE;
     redraw_all_later(SOME_VALID);
 }
 
@@ -10967,14 +11092,13 @@ ex_match(eap)
 
 #ifdef FEAT_CRYPT
 /*
  * ":X": Get crypt key
  */
-/*ARGSUSED*/
     static void
 ex_X(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     (void)get_crypt_key(TRUE, TRUE);
 }
 #endif
 
--- vim72.orig/src/main.c
+++ vim72/src/main.c
@@ -128,14 +128,10 @@ static void prepare_server __ARGS((mparm
 static void cmdsrv_main __ARGS((int *argc, char **argv, char_u *serverName_arg, char_u **serverStr));
 static char_u *serverMakeName __ARGS((char_u *arg, char *cmd));
 #endif
 
 
-#ifdef STARTUPTIME
-static FILE *time_fd = NULL;
-#endif
-
 /*
  * Different types of error messages.
  */
 static char *(main_errors[]) =
 {
@@ -171,10 +167,13 @@ main
     char	**argv;
 {
     char_u	*fname = NULL;		/* file name from command line */
     mparm_T	params;			/* various parameters passed between
 					 * main() and other functions. */
+#ifdef STARTUPTIME
+    int		i;
+#endif
 
     /*
      * Do any system-specific initialisations.  These can NOT use IObuff or
      * NameBuff.  Thus emsg2() cannot be called!
      */
@@ -201,12 +200,19 @@ main
 #ifdef MEM_PROFILE
     atexit(vim_mem_profile_dump);
 #endif
 
 #ifdef STARTUPTIME
-    time_fd = mch_fopen(STARTUPTIME, "a");
-    TIME_MSG("--- VIM STARTING ---");
+    for (i = 1; i < argc; ++i)
+    {
+	if (STRICMP(argv[i], "--startuptime") == 0 && i + 1 < argc)
+	{
+	    time_fd = mch_fopen(argv[i + 1], "a");
+	    TIME_MSG("--- VIM STARTING ---");
+	    break;
+	}
+    }
 #endif
     starttime = time(NULL);
 
 #ifdef __EMX__
     _wildcard(&params.argc, &params.argv);
@@ -358,18 +364,25 @@ main
 # if defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK)
     /*
      * Check if the GUI can be started.  Reset gui.starting if not.
      * Don't know about other systems, stay on the safe side and don't check.
      */
-    if (gui.starting && gui_init_check() == FAIL)
+    if (gui.starting)
     {
-	gui.starting = FALSE;
+	if (gui_init_check() == FAIL)
+	{
+	    gui.starting = FALSE;
 
-	/* When running "evim" or "gvim -y" we need the menus, exit if we
-	 * don't have them. */
-	if (params.evim_mode)
-	    mch_exit(1);
+	    /* When running "evim" or "gvim -y" we need the menus, exit if we
+	     * don't have them. */
+	    if (params.evim_mode)
+		mch_exit(1);
+	}
+#  if defined(HAVE_LOCALE_H) || defined(X_LOCALE)
+	/* Re-initialize locale, it may have been altered by gui_init_check() */
+	init_locale();
+#  endif
     }
 # endif
 #endif
 
     if (GARGCOUNT > 0)
@@ -643,15 +656,16 @@ main
     init_SPAWNO("", SWAP_ANY);
 #endif
 
 #ifdef FEAT_VIMINFO
     /*
-     * Read in registers, history etc, but not marks, from the viminfo file
+     * Read in registers, history etc, but not marks, from the viminfo file.
+     * This is where v:oldfiles gets filled.
      */
     if (*p_viminfo != NUL)
     {
-	read_viminfo(NULL, TRUE, FALSE, FALSE);
+	read_viminfo(NULL, VIF_WANT_INFO | VIF_GET_OLDFILES);
 	TIME_MSG("reading viminfo");
     }
 #endif
 
 #ifdef FEAT_QUICKFIX
@@ -932,12 +946,18 @@ main
 
     TIME_MSG("before starting main loop");
 
     /*
      * Call the main command loop.  This never returns.
+     * For embedded MzScheme the main_loop will be called by Scheme
+     * for proper stack tracking
      */
+#ifndef FEAT_MZSCHEME
     main_loop(FALSE, FALSE);
+#else
+    mzscheme_main();
+#endif
 
     return 0;
 }
 #endif /* PROTO */
 
@@ -1141,10 +1161,22 @@ main_loop(cmdwin, noexmode)
 
 	    setcursor();
 	    cursor_on();
 
 	    do_redraw = FALSE;
+
+#ifdef STARTUPTIME
+	    /* Now that we have drawn the first screen all the startup stuff
+	     * has been done, close any file for startup messages. */
+	    if (time_fd != NULL)
+	    {
+		TIME_MSG("first screen update");
+		TIME_MSG("--- VIM STARTED ---");
+		fclose(time_fd);
+		time_fd = NULL;
+	    }
+#endif
 	}
 #ifdef FEAT_GUI
 	if (need_mouse_correct)
 	    gui_mouse_correct();
 #endif
@@ -1455,11 +1487,12 @@ parse_command_name(parmp)
 #endif
 	parmp->evim_mode = TRUE;
 	++initstr;
     }
 
-    if (TOLOWER_ASC(initstr[0]) == 'g' || initstr[0] == 'k')
+    /* "gvim" starts the GUI.  Also accept "Gvim" for MS-Windows. */
+    if (TOLOWER_ASC(initstr[0]) == 'g')
     {
 	main_start_gui();
 #ifdef FEAT_GUI
 	++initstr;
 #endif
@@ -1501,16 +1534,16 @@ parse_command_name(parmp)
  * Get the name of the display, before gui_prepare() removes it from
  * argv[].  Used for the xterm-clipboard display.
  *
  * Also find the --server... arguments and --socketid and --windowid
  */
-/*ARGSUSED*/
     static void
 early_arg_scan(parmp)
-    mparm_T	*parmp;
+    mparm_T	*parmp UNUSED;
 {
-#if defined(FEAT_XCLIPBOARD) || defined(FEAT_CLIENTSERVER)
+#if defined(FEAT_XCLIPBOARD) || defined(FEAT_CLIENTSERVER) \
+	|| !defined(FEAT_NETBEANS_INTG)
     int		argc = parmp->argc;
     char	**argv = parmp->argv;
     int		i;
 
     for (i = 1; i < argc; i++)
@@ -1578,10 +1611,18 @@ early_arg_scan(parmp)
 # endif
 # ifdef FEAT_GUI_GTK
 	else if (STRICMP(argv[i], "--echo-wid") == 0)
 	    echo_wid_arg = TRUE;
 # endif
+# ifndef FEAT_NETBEANS_INTG
+	else if (strncmp(argv[i], "-nb", (size_t)3) == 0)
+        {
+            mch_errmsg(_("'-nb' cannot be used: not enabled at compile time\n"));
+            mch_exit(2);
+        }
+# endif
+
     }
 #endif
 }
 
 /*
@@ -1690,10 +1731,15 @@ command_line_scan(parmp)
 		else if (STRNICMP(argv[0] + argv_idx, "cmd", 3) == 0)
 		{
 		    want_argument = TRUE;
 		    argv_idx += 3;
 		}
+		else if (STRNICMP(argv[0] + argv_idx, "startuptime", 11) == 0)
+		{
+		    want_argument = TRUE;
+		    argv_idx += 11;
+		}
 #ifdef FEAT_CLIENTSERVER
 		else if (STRNICMP(argv[0] + argv_idx, "serverlist", 10) == 0)
 		    ; /* already processed -- no arg */
 		else if (STRNICMP(argv[0] + argv_idx, "servername", 10) == 0
 		       || STRNICMP(argv[0] + argv_idx, "serversend", 10) == 0)
@@ -2021,11 +2067,11 @@ command_line_scan(parmp)
 		 */
 		if (argv[0][argv_idx] != NUL)
 		    mainerr(ME_GARBAGE, (char_u *)argv[0]);
 
 		--argc;
-		if (argc < 1 && c != 'S')
+		if (argc < 1 && c != 'S')  /* -S has an optional argument */
 		    mainerr_arg_missing((char_u *)argv[0]);
 		++argv;
 		argv_idx = -1;
 
 		switch (c)
@@ -2062,15 +2108,20 @@ command_line_scan(parmp)
 		    else
 			parmp->commands[parmp->n_commands++] =
 							    (char_u *)argv[0];
 		    break;
 
-		case '-':	/* "--cmd {command}" execute command */
-		    if (parmp->n_pre_commands >= MAX_ARG_CMDS)
-			mainerr(ME_EXTRA_CMD, NULL);
-		    parmp->pre_commands[parmp->n_pre_commands++] =
+		case '-':
+		    if (argv[-1][2] == 'c')
+		    {
+			/* "--cmd {command}" execute command */
+			if (parmp->n_pre_commands >= MAX_ARG_CMDS)
+			    mainerr(ME_EXTRA_CMD, NULL);
+			parmp->pre_commands[parmp->n_pre_commands++] =
 							    (char_u *)argv[0];
+		    }
+		    /* "--startuptime <file>" already handled */
 		    break;
 
 	    /*	case 'd':   -d {device} is handled in mch_check_win() for the
 	     *		    Amiga */
 
@@ -2359,22 +2410,21 @@ read_stdin()
      * Close stdin and dup it from stderr.  Required for GPM to work
      * properly, and for running external commands.
      * Is there any other system that cannot do this?
      */
     close(0);
-    dup(2);
+    ignored = dup(2);
 #endif
 }
 
 /*
  * Create the requested number of windows and edit buffers in them.
  * Also does recovery if "recoverymode" set.
  */
-/*ARGSUSED*/
     static void
 create_windows(parmp)
-    mparm_T	*parmp;
+    mparm_T	*parmp UNUSED;
 {
 #ifdef FEAT_WINDOWS
     int		dorewind;
     int		done = 0;
 
@@ -2584,11 +2634,11 @@ edit_buffers(parmp)
 # ifdef HAS_SWAP_EXISTS_ACTION
 	    swap_exists_did_quit = FALSE;
 # endif
 	    (void)do_ecmd(0, arg_idx < GARGCOUNT
 			  ? alist_name(&GARGLIST[arg_idx]) : NULL,
-			  NULL, NULL, ECMD_LASTL, ECMD_HIDE);
+			  NULL, NULL, ECMD_LASTL, ECMD_HIDE, curwin);
 # ifdef HAS_SWAP_EXISTS_ACTION
 	    if (swap_exists_did_quit)
 	    {
 		/* abort or quit selected */
 		if (got_int || only_one_window())
@@ -3105,10 +3155,13 @@ usage()
     main_msg(_("--remote-send <keys>\tSend <keys> to a Vim server and exit"));
     main_msg(_("--remote-expr <expr>\tEvaluate <expr> in a Vim server and print result"));
     main_msg(_("--serverlist\t\tList available Vim server names and exit"));
     main_msg(_("--servername <name>\tSend to/become the Vim server <name>"));
 #endif
+#ifdef STARTUPTIME
+    main_msg(_("--startuptime <file>\tWrite startup timing messages to <file>"));
+#endif
 #ifdef FEAT_VIMINFO
     main_msg(_("-i <viminfo>\t\tUse <viminfo> instead of .viminfo"));
 #endif
     main_msg(_("-h  or  --help\tPrint Help (this message) and exit"));
     main_msg(_("--version\t\tPrint version information and exit"));
@@ -3194,10 +3247,24 @@ check_swap_exists_action()
 #if defined(STARTUPTIME) || defined(PROTO)
 static void time_diff __ARGS((struct timeval *then, struct timeval *now));
 
 static struct timeval	prev_timeval;
 
+# ifdef WIN3264
+/*
+ * Windows doesn't have gettimeofday(), although it does have struct timeval.
+ */
+    static int
+gettimeofday(struct timeval *tv, char *dummy)
+{
+    long t = clock();
+    tv->tv_sec = t / CLOCKS_PER_SEC;
+    tv->tv_usec = (t - tv->tv_sec * CLOCKS_PER_SEC) * 1000000 / CLOCKS_PER_SEC;
+    return 0;
+}
+# endif
+
 /*
  * Save the previous time before doing something that could nest.
  * set "*tv_rel" to the time elapsed so far.
  */
     void
@@ -3282,24 +3349,10 @@ time_msg(msg, tv_start)
 	prev_timeval = now;
 	fprintf(time_fd, ": %s\n", msg);
     }
 }
 
-# ifdef WIN3264
-/*
- * Windows doesn't have gettimeofday(), although it does have struct timeval.
- */
-    int
-gettimeofday(struct timeval *tv, char *dummy)
-{
-    long t = clock();
-    tv->tv_sec = t / CLOCKS_PER_SEC;
-    tv->tv_usec = (t - tv->tv_sec * CLOCKS_PER_SEC) * 1000000 / CLOCKS_PER_SEC;
-    return 0;
-}
-# endif
-
 #endif
 
 #if defined(FEAT_CLIENTSERVER) || defined(PROTO)
 
 /*
@@ -3637,11 +3690,11 @@ cmdsrv_main(argc, argv, serverName_arg,
 	    if (called_emsg)
 		mch_errmsg("\n");
 	}
 	else if (STRICMP(argv[i], "--servername") == 0)
 	{
-	    /* Alredy processed. Take it out of the command line */
+	    /* Already processed. Take it out of the command line */
 	    i++;
 	    continue;
 	}
 	else
 	{
@@ -3838,14 +3891,13 @@ eval_client_expr_to_string(expr)
 /*
  * If conversion is needed, convert "data" from "client_enc" to 'encoding' and
  * return an allocated string.  Otherwise return "data".
  * "*tofree" is set to the result when it needs to be freed later.
  */
-/*ARGSUSED*/
     char_u *
 serverConvert(client_enc, data, tofree)
-    char_u *client_enc;
+    char_u *client_enc UNUSED;
     char_u *data;
     char_u **tofree;
 {
     char_u	*res = data;
 
--- vim72.orig/src/fileio.c
+++ vim72/src/fileio.c
@@ -19,11 +19,11 @@
 # include "vimio.h"	/* for mktemp(), CJW 1997-12-03 */
 #endif
 
 #include "vim.h"
 
-#ifdef __TANDEM
+#if defined(__TANDEM) || defined(__MINT__)
 # include <limits.h>		/* for SSIZE_MAX */
 #endif
 
 #if defined(HAVE_UTIME) && defined(HAVE_UTIME_H)
 # include <utime.h>		/* for struct utimbuf */
@@ -67,11 +67,11 @@ static int time_differs __ARGS((long t1,
 #ifdef FEAT_AUTOCMD
 static int apply_autocmds_exarg __ARGS((event_T event, char_u *fname, char_u *fname_io, int force, buf_T *buf, exarg_T *eap));
 static int au_find_group __ARGS((char_u *name));
 
 # define AUGROUP_DEFAULT    -1	    /* default autocmd group */
-# define AUGROUP_ERROR	    -2	    /* errornouse autocmd group */
+# define AUGROUP_ERROR	    -2	    /* erroneous autocmd group */
 # define AUGROUP_ALL	    -3	    /* all autocmd groups */
 #endif
 
 #if defined(FEAT_CRYPT) || defined(FEAT_MBYTE)
 # define HAS_BW_FLAGS
@@ -119,10 +119,12 @@ struct bw_info
     int		bw_restlen;	/* nr of bytes in bw_rest[] */
     int		bw_first;	/* first write call */
     char_u	*bw_conv_buf;	/* buffer for writing converted chars */
     int		bw_conv_buflen; /* size of bw_conv_buf */
     int		bw_conv_error;	/* set for conversion error */
+    linenr_T	bw_conv_error_lnum;  /* first line with error or zero */
+    linenr_T	bw_start_lnum;  /* line number at start of buffer */
 # ifdef USE_ICONV
     iconv_t	bw_iconv_fd;	/* descriptor for iconv() or -1 */
 # endif
 #endif
 };
@@ -130,11 +132,11 @@ struct bw_info
 static int  buf_write_bytes __ARGS((struct bw_info *ip));
 
 #ifdef FEAT_MBYTE
 static linenr_T readfile_linenr __ARGS((linenr_T linecnt, char_u *p, char_u *endp));
 static int ucs2bytes __ARGS((unsigned c, char_u **pp, int flags));
-static int same_encoding __ARGS((char_u *a, char_u *b));
+static int need_conversion __ARGS((char_u *fenc));
 static int get_fio_flags __ARGS((char_u *ptr));
 static char_u *check_for_bom __ARGS((char_u *p, long size, int *lenp, int flags));
 static int make_bom __ARGS((char_u *buf, char_u *name));
 # ifdef WIN3264
 static int get_win_fio_flags __ARGS((char_u *ptr));
@@ -142,11 +144,16 @@ static int get_win_fio_flags __ARGS((cha
 # ifdef MACOS_X
 static int get_mac_fio_flags __ARGS((char_u *ptr));
 # endif
 #endif
 static int move_lines __ARGS((buf_T *frombuf, buf_T *tobuf));
-
+#ifdef TEMPDIRNAMES
+static void vim_settempdir __ARGS((char_u *tempdir));
+#endif
+#ifdef FEAT_AUTOCMD
+static char *e_auchangedbuf = N_("E812: Autocommands changed buffer or buffer name");
+#endif
 
     void
 filemess(buf, name, s, attr)
     buf_T	*buf;
     char_u	*name;
@@ -293,10 +300,23 @@ readfile(fname, sfname, from, lines_to_s
 					   wasn't possible */
     char_u	conv_rest[CONV_RESTLEN];
     int		conv_restlen = 0;	/* nr of bytes in conv_rest[] */
 #endif
 
+#ifdef FEAT_AUTOCMD
+    /* Remember the initial values of curbuf, curbuf->b_ffname and
+     * curbuf->b_fname to detect whether they are altered as a result of
+     * executing nasty autocommands.  Also check if "fname" and "sfname"
+     * point to one of these values. */
+    buf_T   *old_curbuf = curbuf;
+    char_u  *old_b_ffname = curbuf->b_ffname;
+    char_u  *old_b_fname = curbuf->b_fname;
+    int     using_b_ffname = (fname == curbuf->b_ffname)
+					      || (sfname == curbuf->b_ffname);
+    int     using_b_fname = (fname == curbuf->b_fname)
+					       || (sfname == curbuf->b_fname);
+#endif
     write_no_eol_lnum = 0;	/* in case it was set by the previous read */
 
     /*
      * If there is no file name yet, use the one for the read file.
      * BF_NOTEDITED is set to reflect this.
@@ -587,11 +607,25 @@ readfile(fname, sfname, from, lines_to_s
 		     * that we are editing this file.  Don't do this for a
 		     * "nofile" or "nowrite" buffer type. */
 #ifdef FEAT_QUICKFIX
 		    if (!bt_dontwrite(curbuf))
 #endif
+		    {
 			check_need_swap(newfile);
+#ifdef FEAT_AUTOCMD
+			/* SwapExists autocommand may mess things up */
+			if (curbuf != old_curbuf
+				|| (using_b_ffname
+					&& (old_b_ffname != curbuf->b_ffname))
+				|| (using_b_fname
+					 && (old_b_fname != curbuf->b_fname)))
+			{
+			    EMSG(_(e_auchangedbuf));
+			    return FAIL;
+			}
+#endif
+		    }
 		    if (dir_of_file_exists(fname))
 			filemess(curbuf, sfname, (char_u *)_("[New File]"), 0);
 		    else
 			filemess(curbuf, sfname,
 					   (char_u *)_("[New DIRECTORY]"), 0);
@@ -666,13 +700,25 @@ readfile(fname, sfname, from, lines_to_s
 #ifdef FEAT_QUICKFIX
     if (!bt_dontwrite(curbuf))
 #endif
     {
 	check_need_swap(newfile);
+#ifdef FEAT_AUTOCMD
+	if (!read_stdin && (curbuf != old_curbuf
+		|| (using_b_ffname && (old_b_ffname != curbuf->b_ffname))
+		|| (using_b_fname && (old_b_fname != curbuf->b_fname))))
+	{
+	    EMSG(_(e_auchangedbuf));
+	    if (!read_buffer)
+		close(fd);
+	    return FAIL;
+	}
+#endif
 #ifdef UNIX
 	/* Set swap file protection bits after creating it. */
-	if (swap_mode > 0 && curbuf->b_ml.ml_mfp->mf_fname != NULL)
+	if (swap_mode > 0 && curbuf->b_ml.ml_mfp != NULL
+			  && curbuf->b_ml.ml_mfp->mf_fname != NULL)
 	    (void)mch_setperm(curbuf->b_ml.ml_mfp->mf_fname, (long)swap_mode);
 #endif
     }
 
 #if defined(HAS_SWAP_EXISTS_ACTION)
@@ -696,11 +742,10 @@ readfile(fname, sfname, from, lines_to_s
 #ifdef FEAT_AUTOCMD
     if (!read_buffer)
     {
 	int	m = msg_scroll;
 	int	n = msg_scrolled;
-	buf_T	*old_curbuf = curbuf;
 
 	/*
 	 * The file must be closed again, the autocommands may want to change
 	 * the file before reading it.
 	 */
@@ -738,12 +783,17 @@ readfile(fname, sfname, from, lines_to_s
 	}
 #endif
 	/*
 	 * Don't allow the autocommands to change the current buffer.
 	 * Try to re-open the file.
+	 *
+	 * Don't allow the autocommands to change the buffer name either
+	 * (cd for example) if it invalidates fname or sfname.
 	 */
 	if (!read_stdin && (curbuf != old_curbuf
+		|| (using_b_ffname && (old_b_ffname != curbuf->b_ffname))
+		|| (using_b_fname && (old_b_fname != curbuf->b_fname))
 		|| (fd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0)) < 0))
 	{
 	    --no_wait_return;
 	    msg_scroll = msg_save;
 	    if (fd < 0)
@@ -930,11 +980,14 @@ retry:
     if (keep_fileformat)
 	keep_fileformat = FALSE;
     else
     {
 	if (eap != NULL && eap->force_ff != 0)
+	{
 	    fileformat = get_fileformat_force(curbuf, eap);
+	    try_unix = try_dos = try_mac = FALSE;
+	}
 	else if (curbuf->b_p_bin)
 	    fileformat = EOL_UNIX;		/* binary: use Unix format */
 	else if (*p_ffs == NUL)
 	    fileformat = get_fileformat(curbuf);/* use format from buffer */
 	else
@@ -991,17 +1044,16 @@ retry:
 	    tmpname = NULL;
 	}
     }
 
     /*
-     * Conversion is required when the encoding of the file is different
-     * from 'encoding' or 'encoding' is UTF-16, UCS-2 or UCS-4 (requires
-     * conversion to UTF-8).
+     * Conversion may be required when the encoding of the file is different
+     * from 'encoding' or 'encoding' is UTF-16, UCS-2 or UCS-4.
      */
     fio_flags = 0;
-    converted = (*fenc != NUL && !same_encoding(p_enc, fenc));
-    if (converted || enc_unicode != 0)
+    converted = need_conversion(fenc);
+    if (converted)
     {
 
 	/* "ucs-bom" means we need to check the first bytes of the file
 	 * for a BOM. */
 	if (STRCMP(fenc, ENC_UCSBOM) == 0)
@@ -2202,18 +2254,26 @@ failed:
 # endif
 #endif
 
     if (!read_buffer && !read_stdin)
 	close(fd);				/* errors are ignored */
+#ifdef HAVE_FD_CLOEXEC
+    else
+    {
+	int fdflags = fcntl(fd, F_GETFD);
+	if (fdflags >= 0 && (fdflags & FD_CLOEXEC) == 0)
+	    fcntl(fd, F_SETFD, fdflags | FD_CLOEXEC);
+    }
+#endif
     vim_free(buffer);
 
 #ifdef HAVE_DUP
     if (read_stdin)
     {
 	/* Use stderr for stdin, makes shell commands work. */
 	close(0);
-	dup(2);
+	ignored = dup(2);
     }
 #endif
 
 #ifdef FEAT_MBYTE
     if (tmpname != NULL)
@@ -2339,15 +2399,10 @@ failed:
 	    if (ff_error == EOL_DOS)
 	    {
 		STRCAT(IObuff, _("[CR missing]"));
 		c = TRUE;
 	    }
-	    if (ff_error == EOL_MAC)
-	    {
-		STRCAT(IObuff, _("[NL found]"));
-		c = TRUE;
-	    }
 	    if (split)
 	    {
 		STRCAT(IObuff, _("[long lines split]"));
 		c = TRUE;
 	    }
@@ -2709,11 +2764,11 @@ readfile_charconvert(fname, fenc, fdp)
     static void
 check_marks_read()
 {
     if (!curbuf->b_marks_read && get_viminfo_parameter('\'') > 0
 						  && curbuf->b_ffname != NULL)
-	read_viminfo(NULL, FALSE, TRUE, FALSE);
+	read_viminfo(NULL, VIF_WANT_MARKS);
 
     /* Always set b_marks_read; needed when 'viminfo' is changed to include
      * the ' parameter after opening a buffer. */
     curbuf->b_marks_read = TRUE;
 }
@@ -2879,10 +2934,11 @@ buf_write(buf, fname, sfname, start, end
     char_u	    c;
     int		    len;
     linenr_T	    lnum;
     long	    nchars;
     char_u	    *errmsg = NULL;
+    int		    errmsg_allocated = FALSE;
     char_u	    *errnum = NULL;
     char_u	    *buffer;
     char_u	    smallbuf[SMBUFSIZE];
     char_u	    *backup_ext;
     int		    bufsize;
@@ -2923,10 +2979,17 @@ buf_write(buf, fname, sfname, start, end
 					   backup or new file */
 #endif
 
     if (fname == NULL || *fname == NUL)	/* safety check */
 	return FAIL;
+    if (buf->b_ml.ml_mfp == NULL)
+    {
+	/* This can happen during startup when there is a stray "w" in the
+	 * vimrc file. */
+	EMSG(_(e_emptybuf));
+	return FAIL;
+    }
 
     /*
      * Disallow writing from .exrc and .vimrc in current directory for
      * security reasons.
      */
@@ -2942,10 +3005,11 @@ buf_write(buf, fname, sfname, start, end
 
 #ifdef FEAT_MBYTE
     /* must init bw_conv_buf and bw_iconv_fd before jumping to "fail" */
     write_info.bw_conv_buf = NULL;
     write_info.bw_conv_error = FALSE;
+    write_info.bw_conv_error_lnum = 0;
     write_info.bw_restlen = 0;
 # ifdef USE_ICONV
     write_info.bw_iconv_fd = (iconv_t)-1;
 # endif
 #endif
@@ -3449,16 +3513,16 @@ buf_write(buf, fname, sfname, start, end
 		    backup_copy = TRUE;
 		else
 		{
 # ifdef UNIX
 #  ifdef HAVE_FCHOWN
-		    fchown(fd, st_old.st_uid, st_old.st_gid);
+		    ignored = fchown(fd, st_old.st_uid, st_old.st_gid);
 #  endif
 		    if (mch_stat((char *)IObuff, &st) < 0
 			    || st.st_uid != st_old.st_uid
 			    || st.st_gid != st_old.st_gid
-			    || st.st_mode != perm)
+			    || (long)st.st_mode != perm)
 			backup_copy = TRUE;
 # endif
 		    /* Close the file before removing it, on MS-Windows we
 		     * can't delete an open file. */
 		    close(fd);
@@ -3920,14 +3984,13 @@ buf_write(buf, fname, sfname, start, end
     }
     else
 	fenc = buf->b_p_fenc;
 
     /*
-     * The file needs to be converted when 'fileencoding' is set and
-     * 'fileencoding' differs from 'encoding'.
+     * Check if the file needs to be converted.
      */
-    converted = (*fenc != NUL && !same_encoding(p_enc, fenc));
+    converted = need_conversion(fenc);
 
     /*
      * Check if UTF-8 to UCS-2/4 or Latin1 conversion needs to be done.  Or
      * Latin1 to Unicode conversion.  This is handled in buf_write_bytes().
      * Prepare the flags for it and allocate bw_conv_buf when needed.
@@ -4198,10 +4261,11 @@ restore_backup:
 		end = 0;
 	    else
 		nchars += write_info.bw_len;
 	}
     }
+    write_info.bw_start_lnum = start;
 #endif
 
     write_info.bw_len = bufsize;
 #ifdef HAS_BW_FLAGS
     write_info.bw_flags = wb_flags;
@@ -4233,10 +4297,13 @@ restore_backup:
 		break;
 	    }
 	    nchars += bufsize;
 	    s = buffer;
 	    len = 0;
+#ifdef FEAT_MBYTE
+	    write_info.bw_start_lnum = lnum;
+#endif
 	}
 	/* write failed or last line has no EOL: stop here */
 	if (end == 0
 		|| (lnum == end
 		    && write_bin
@@ -4365,18 +4432,18 @@ restore_backup:
 	 * permission or ACL stuff */
 	if (mch_stat((char *)wfname, &st) < 0
 		|| st.st_uid != st_old.st_uid
 		|| st.st_gid != st_old.st_gid)
 	{
-	    fchown(fd, st_old.st_uid, st_old.st_gid);
+	    ignored = fchown(fd, st_old.st_uid, st_old.st_gid);
 	    if (perm >= 0)	/* set permission again, may have changed */
 		(void)mch_setperm(wfname, perm);
 	}
 # endif
 	buf_setino(buf);
     }
-    else if (buf->b_dev < 0)
+    else if (!buf->b_dev_valid)
 	/* Set the inode when creating a new file. */
 	buf_setino(buf);
 #endif
 
     if (close(fd) != 0)
@@ -4429,11 +4496,21 @@ restore_backup:
     {
 	if (errmsg == NULL)
 	{
 #ifdef FEAT_MBYTE
 	    if (write_info.bw_conv_error)
-		errmsg = (char_u *)_("E513: write error, conversion failed (make 'fenc' empty to override)");
+	    {
+		if (write_info.bw_conv_error_lnum == 0)
+		    errmsg = (char_u *)_("E513: write error, conversion failed (make 'fenc' empty to override)");
+		else
+		{
+		    errmsg_allocated = TRUE;
+		    errmsg = alloc(300);
+		    vim_snprintf((char *)errmsg, 300, _("E513: write error, conversion failed in line %ld (make 'fenc' empty to override)"),
+					 (long)write_info.bw_conv_error_lnum);
+		}
+	    }
 	    else
 #endif
 		if (got_int)
 		    errmsg = (char_u *)_(e_interr);
 		else
@@ -4505,10 +4582,16 @@ restore_backup:
 #ifdef FEAT_MBYTE
 	if (write_info.bw_conv_error)
 	{
 	    STRCAT(IObuff, _(" CONVERSION ERROR"));
 	    c = TRUE;
+	    if (write_info.bw_conv_error_lnum != 0)
+	    {
+		size_t l = STRLEN(IObuff);
+		vim_snprintf((char *)IObuff + l, IOSIZE - l, _(" in line %ld;"),
+			(long)write_info.bw_conv_error_lnum);
+	    }
 	}
 	else if (notconverted)
 	{
 	    STRCAT(IObuff, _("[NOT converted]"));
 	    c = TRUE;
@@ -4701,10 +4784,12 @@ nofail:
 	    STRMOVE(IObuff + numlen, IObuff);
 	    mch_memmove(IObuff, errnum, (size_t)numlen);
 	}
 	STRCAT(IObuff, errmsg);
 	emsg(IObuff);
+	if (errmsg_allocated)
+	    vim_free(errmsg);
 
 	retval = FAIL;
 	if (end == 0)
 	{
 	    MSG_PUTS_ATTR(_("\nWARNING: Original file may be lost or damaged\n"),
@@ -4780,18 +4865,26 @@ nofail:
 set_rw_fname(fname, sfname)
     char_u	*fname;
     char_u	*sfname;
 {
 #ifdef FEAT_AUTOCMD
+    buf_T	*buf = curbuf;
+
     /* It's like the unnamed buffer is deleted.... */
     if (curbuf->b_p_bl)
 	apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);
     apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, FALSE, curbuf);
 # ifdef FEAT_EVAL
     if (aborting())	    /* autocmds may abort script processing */
 	return FAIL;
 # endif
+    if (curbuf != buf)
+    {
+	/* We are in another buffer now, don't do the renaming. */
+	EMSG(_(e_auchangedbuf));
+	return FAIL;
+    }
 #endif
 
     if (setfname(curbuf, fname, sfname, FALSE) == OK)
 	curbuf->b_flags |= BF_NOTEDITED;
 
@@ -5052,11 +5145,17 @@ buf_write_bytes(ip)
 			c = utf_ptr2char(buf + wlen);
 		    else
 			c = buf[wlen];
 		}
 
-		ip->bw_conv_error |= ucs2bytes(c, &p, flags);
+		if (ucs2bytes(c, &p, flags) && !ip->bw_conv_error)
+		{
+		    ip->bw_conv_error = TRUE;
+		    ip->bw_conv_error_lnum = ip->bw_start_lnum;
+		}
+		if (c == NL)
+		    ++ip->bw_start_lnum;
 	    }
 	    if (flags & FIO_LATIN1)
 		len = (int)(p - buf);
 	    else
 	    {
@@ -5244,17 +5343,20 @@ buf_write_bytes(ip)
 	    size_t	tolen;
 
 	    /* Convert with iconv(). */
 	    if (ip->bw_restlen > 0)
 	    {
+		char *fp;
+
 		/* Need to concatenate the remainder of the previous call and
 		 * the bytes of the current call.  Use the end of the
 		 * conversion buffer for this. */
 		fromlen = len + ip->bw_restlen;
-		from = (char *)ip->bw_conv_buf + ip->bw_conv_buflen - fromlen;
-		mch_memmove((void *)from, ip->bw_rest, (size_t)ip->bw_restlen);
-		mch_memmove((void *)(from + ip->bw_restlen), buf, (size_t)len);
+		fp = (char *)ip->bw_conv_buf + ip->bw_conv_buflen - fromlen;
+		mch_memmove(fp, ip->bw_rest, (size_t)ip->bw_restlen);
+		mch_memmove(fp + ip->bw_restlen, buf, (size_t)len);
+		from = fp;
 		tolen = ip->bw_conv_buflen - fromlen;
 	    }
 	    else
 	    {
 		from = (const char *)buf;
@@ -5330,10 +5432,11 @@ buf_write_bytes(ip)
 }
 
 #ifdef FEAT_MBYTE
 /*
  * Convert a Unicode character to bytes.
+ * Return TRUE for an error, FALSE when it's OK.
  */
     static int
 ucs2bytes(c, pp, flags)
     unsigned	c;		/* in: character */
     char_u	**pp;		/* in/out: pointer to result */
@@ -5413,24 +5516,41 @@ ucs2bytes(c, pp, flags)
     *pp = p;
     return error;
 }
 
 /*
- * Return TRUE if "a" and "b" are the same 'encoding'.
- * Ignores difference between "ansi" and "latin1", "ucs-4" and "ucs-4be", etc.
+ * Return TRUE if file encoding "fenc" requires conversion from or to
+ * 'encoding'.
  */
     static int
-same_encoding(a, b)
-    char_u	*a;
-    char_u	*b;
+need_conversion(fenc)
+    char_u	*fenc;
 {
-    int		f;
+    int		same_encoding;
+    int		enc_flags;
+    int		fenc_flags;
 
-    if (STRCMP(a, b) == 0)
-	return TRUE;
-    f = get_fio_flags(a);
-    return (f != 0 && get_fio_flags(b) == f);
+    if (*fenc == NUL || STRCMP(p_enc, fenc) == 0)
+	same_encoding = TRUE;
+    else
+    {
+	/* Ignore difference between "ansi" and "latin1", "ucs-4" and
+	 * "ucs-4be", etc. */
+	enc_flags = get_fio_flags(p_enc);
+	fenc_flags = get_fio_flags(fenc);
+	same_encoding = (enc_flags != 0 && fenc_flags == enc_flags);
+    }
+    if (same_encoding)
+    {
+	/* Specified encoding matches with 'encoding'.  This requires
+	 * conversion when 'encoding' is Unicode but not UTF-8. */
+	return enc_unicode != 0;
+    }
+
+    /* Encodings differ.  However, conversion is not needed when 'enc' is any
+     * Unicode encoding and the file is UTF-8. */
+    return !(enc_utf8 && fenc_flags == FIO_UTF8);
 }
 
 /*
  * Check "ptr" for a unicode encoding and return the FIO_ flags needed for the
  * internal conversion.
@@ -5548,13 +5668,14 @@ check_for_bom(p, size, lenp, flags)
 	    && (flags == FIO_ALL || flags == (FIO_UCS4 | FIO_ENDIAN_L)))
 	{
 	    name = "ucs-4le";	/* FF FE 00 00 */
 	    len = 4;
 	}
-	else if (flags == FIO_ALL || flags == (FIO_UCS2 | FIO_ENDIAN_L))
+	else if (flags == (FIO_UCS2 | FIO_ENDIAN_L))
 	    name = "ucs-2le";	/* FF FE */
-	else if (flags == (FIO_UTF16 | FIO_ENDIAN_L))
+	else if (flags == FIO_ALL || flags == (FIO_UTF16 | FIO_ENDIAN_L))
+	    /* utf-16le is preferred, it also works for ucs-2le text */
 	    name = "utf-16le";	/* FF FE */
     }
     else if (p[0] == 0xfe && p[1] == 0xff
 	    && (flags == FIO_ALL || flags == FIO_UCS2 || flags == FIO_UTF16))
     {
@@ -5915,11 +6036,11 @@ buf_modname(shortname, fname, ext, prepe
 	else if (*ext == '/' || *ext == '_')
 #else
 	else if (*ext == '.')
 #endif
 	{
-	    if (s - ptr > (size_t)8)
+	    if ((size_t)(s - ptr) > (size_t)8)
 	    {
 		s = ptr + 8;
 		*s = '\0';
 	    }
 	}
@@ -6029,13 +6150,13 @@ vim_fgets(buf, size, fp)
 	/* Now throw away the rest of the line: */
 	do
 	{
 	    tbuf[FGETS_SIZE - 2] = NUL;
 #ifdef USE_CR
-	    fgets_cr((char *)tbuf, FGETS_SIZE, fp);
+	    ignoredp = fgets_cr((char *)tbuf, FGETS_SIZE, fp);
 #else
-	    fgets((char *)tbuf, FGETS_SIZE, fp);
+	    ignoredp = fgets((char *)tbuf, FGETS_SIZE, fp);
 #endif
 	} while (tbuf[FGETS_SIZE - 2] != NUL && tbuf[FGETS_SIZE - 2] != '\n');
     }
     return (eof == NULL);
 }
@@ -6105,23 +6226,84 @@ vim_rename(from, to)
     struct stat	st;
     long	perm;
 #ifdef HAVE_ACL
     vim_acl_T	acl;		/* ACL from original file */
 #endif
+#if defined(UNIX) || defined(CASE_INSENSITIVE_FILENAME)
+    int		use_tmp_file = FALSE;
+#endif
 
     /*
-     * When the names are identical, there is nothing to do.
+     * When the names are identical, there is nothing to do.  When they refer
+     * to the same file (ignoring case and slash/backslash differences) but
+     * the file name differs we need to go through a temp file.
      */
     if (fnamecmp(from, to) == 0)
-	return 0;
+    {
+#ifdef CASE_INSENSITIVE_FILENAME
+	if (STRCMP(gettail(from), gettail(to)) != 0)
+	    use_tmp_file = TRUE;
+	else
+#endif
+	    return 0;
+    }
 
     /*
      * Fail if the "from" file doesn't exist.  Avoids that "to" is deleted.
      */
     if (mch_stat((char *)from, &st) < 0)
 	return -1;
 
+#ifdef UNIX
+    {
+	struct stat	st_to;
+
+	/* It's possible for the source and destination to be the same file.
+	 * This happens when "from" and "to" differ in case and are on a FAT32
+	 * filesystem.  In that case go through a temp file name. */
+	if (mch_stat((char *)to, &st_to) >= 0
+		&& st.st_dev == st_to.st_dev
+		&& st.st_ino == st_to.st_ino)
+	    use_tmp_file = TRUE;
+    }
+#endif
+
+#if defined(UNIX) || defined(CASE_INSENSITIVE_FILENAME)
+    if (use_tmp_file)
+    {
+	char	tempname[MAXPATHL + 1];
+
+	/*
+	 * Find a name that doesn't exist and is in the same directory.
+	 * Rename "from" to "tempname" and then rename "tempname" to "to".
+	 */
+	if (STRLEN(from) >= MAXPATHL - 5)
+	    return -1;
+	STRCPY(tempname, from);
+	for (n = 123; n < 99999; ++n)
+	{
+	    sprintf((char *)gettail((char_u *)tempname), "%d", n);
+	    if (mch_stat(tempname, &st) < 0)
+	    {
+		if (mch_rename((char *)from, tempname) == 0)
+		{
+		    if (mch_rename(tempname, (char *)to) == 0)
+			return 0;
+		    /* Strange, the second step failed.  Try moving the
+		     * file back and return failure. */
+		    mch_rename(tempname, (char *)from);
+		    return -1;
+		}
+		/* If it fails for one temp name it will most likely fail
+		 * for any temp name, give up. */
+		return -1;
+	    }
+	}
+	return -1;
+    }
+#endif
+
     /*
      * Delete the "to" file, this is required on some systems to make the
      * mch_rename() work, on other systems it makes sure that we don't have
      * two files when the mch_rename() fails.
      */
@@ -6258,11 +6440,11 @@ check_timestamps(focus)
 	return FALSE;
     }
 
     if (!stuff_empty() || global_busy || !typebuf_typed()
 #ifdef FEAT_AUTOCMD
-			|| autocmd_busy || curbuf_lock > 0
+			|| autocmd_busy || curbuf_lock > 0 || allbuf_lock > 0
 #endif
 					)
 	need_check_timestamps = TRUE;		/* check later */
     else
     {
@@ -6351,15 +6533,14 @@ move_lines(frombuf, tobuf)
  * Also check if the file for a new buffer unexpectedly appeared.
  * return 1 if a changed buffer was found.
  * return 2 if a message has been displayed.
  * return 0 otherwise.
  */
-/*ARGSUSED*/
     int
 buf_check_timestamp(buf, focus)
     buf_T	*buf;
-    int		focus;		/* called for GUI focus event */
+    int		focus UNUSED;	/* called for GUI focus event */
 {
     struct stat	st;
     int		stat_res;
     int		retval = 0;
     char_u	*path;
@@ -6460,12 +6641,14 @@ buf_check_timestamp(buf, focus)
 	    busy = TRUE;
 # ifdef FEAT_EVAL
 	    set_vim_var_string(VV_FCS_REASON, (char_u *)reason, -1);
 	    set_vim_var_string(VV_FCS_CHOICE, (char_u *)"", -1);
 # endif
+	    ++allbuf_lock;
 	    n = apply_autocmds(EVENT_FILECHANGEDSHELL,
 				      buf->b_fname, buf->b_fname, FALSE, buf);
+	    --allbuf_lock;
 	    busy = FALSE;
 	    if (n)
 	    {
 		if (!buf_valid(buf))
 		    EMSG(_("E246: FileChangedShell autocommand deleted buffer"));
@@ -6509,11 +6692,14 @@ buf_check_timestamp(buf, focus)
 		    else if (*reason == 'm')
 		    {
 			mesg = _("W16: Warning: Mode of file \"%s\" has changed since editing started");
 			mesg2 = _("See \":help W16\" for more info.");
 		    }
-		    /* Else: only timestamp changed, ignored */
+		    else
+			/* Only timestamp changed, store it to avoid a warning
+			 * in check_mtime() later. */
+			buf->b_mtime_read = buf->b_mtime;
 		}
 	    }
 	}
 
     }
@@ -6536,10 +6722,15 @@ buf_check_timestamp(buf, focus)
 	    if (!helpmesg)
 		mesg2 = "";
 	    tbuf = alloc((unsigned)(STRLEN(path) + STRLEN(mesg)
 							+ STRLEN(mesg2) + 2));
 	    sprintf((char *)tbuf, mesg, path);
+#ifdef FEAT_EVAL
+	    /* Set warningmsg here, before the unimportant and output-specific
+	     * mesg2 has been appended. */
+	    set_vim_var_string(VV_WARNINGMSG, tbuf, -1);
+#endif
 #if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)
 	    if (can_reload)
 	    {
 		if (*mesg2 != NUL)
 		{
@@ -6730,14 +6921,15 @@ buf_reload(buf, orig_mode)
 #ifdef FEAT_AUTOCMD
 	keep_filetype = FALSE;
 #endif
 #ifdef FEAT_FOLDING
 	{
-	    win_T *wp;
+	    win_T	*wp;
+	    tabpage_T	*tp;
 
 	    /* Update folds unless they are defined manually. */
-	    FOR_ALL_WINDOWS(wp)
+	    FOR_ALL_TAB_WINDOWS(tp, wp)
 		if (wp->w_buffer == curwin->w_buffer
 			&& !foldmethodIsManual(wp))
 		    foldUpdateAll(wp);
 	}
 #endif
@@ -6751,16 +6943,15 @@ buf_reload(buf, orig_mode)
     /* restore curwin/curbuf and a few other things */
     aucmd_restbuf(&aco);
     /* Careful: autocommands may have made "buf" invalid! */
 }
 
-/*ARGSUSED*/
     void
 buf_store_time(buf, st, fname)
     buf_T	*buf;
     struct stat	*st;
-    char_u	*fname;
+    char_u	*fname UNUSED;
 {
     buf->b_mtime = (long)st->st_mtime;
     buf->b_orig_size = (size_t)st->st_size;
 #ifdef HAVE_ST_MODE
     buf->b_orig_mode = (int)st->st_mode;
@@ -6811,34 +7002,60 @@ vim_deltempdir()
 	vim_tempdir = NULL;
     }
 }
 #endif
 
+#ifdef TEMPDIRNAMES
+/*
+ * Directory "tempdir" was created.  Expand this name to a full path and put
+ * it in "vim_tempdir".  This avoids that using ":cd" would confuse us.
+ * "tempdir" must be no longer than MAXPATHL.
+ */
+    static void
+vim_settempdir(tempdir)
+    char_u	*tempdir;
+{
+    char_u	*buf;
+
+    buf = alloc((unsigned)MAXPATHL + 2);
+    if (buf != NULL)
+    {
+	if (vim_FullName(tempdir, buf, MAXPATHL, FALSE) == FAIL)
+	    STRCPY(buf, tempdir);
+# ifdef __EMX__
+	if (vim_strchr(buf, '/') != NULL)
+	    STRCAT(buf, "/");
+	else
+# endif
+	    add_pathsep(buf);
+	vim_tempdir = vim_strsave(buf);
+	vim_free(buf);
+    }
+}
+#endif
+
 /*
  * vim_tempname(): Return a unique name that can be used for a temp file.
  *
  * The temp file is NOT created.
  *
  * The returned pointer is to allocated memory.
  * The returned pointer is NULL if no valid name was found.
  */
-/*ARGSUSED*/
     char_u  *
 vim_tempname(extra_char)
-    int	    extra_char;	    /* character to use in the name instead of '?' */
+    int	    extra_char UNUSED;  /* char to use in the name instead of '?' */
 {
 #ifdef USE_TMPNAM
     char_u	itmp[L_tmpnam];	/* use tmpnam() */
 #else
     char_u	itmp[TEMPNAMELEN];
 #endif
 
 #ifdef TEMPDIRNAMES
     static char	*(tempdirs[]) = {TEMPDIRNAMES};
     int		i;
-    long	nr;
-    long	off;
 # ifndef EEXIST
     struct stat	st;
 # endif
 
     /*
@@ -6851,12 +7068,18 @@ vim_tempname(extra_char)
     if (vim_tempdir == NULL)
     {
 	/*
 	 * Try the entries in TEMPDIRNAMES to create the temp directory.
 	 */
-	for (i = 0; i < sizeof(tempdirs) / sizeof(char *); ++i)
+	for (i = 0; i < (int)(sizeof(tempdirs) / sizeof(char *)); ++i)
 	{
+# ifndef HAVE_MKDTEMP
+	    size_t	itmplen;
+	    long	nr;
+	    long	off;
+# endif
+
 	    /* expand $TMP, leave room for "/v1100000/999999999" */
 	    expand_env((char_u *)tempdirs[i], itmp, TEMPNAMELEN - 20);
 	    if (mch_isdir(itmp))		/* directory exists */
 	    {
 # ifdef __EMX__
@@ -6867,74 +7090,63 @@ vim_tempname(extra_char)
 		    STRCAT(itmp, "/");
 		else
 # endif
 		    add_pathsep(itmp);
 
+# ifdef HAVE_MKDTEMP
+		/* Leave room for filename */
+		STRCAT(itmp, "vXXXXXX");
+		if (mkdtemp((char *)itmp) != NULL)
+		    vim_settempdir(itmp);
+# else
 		/* Get an arbitrary number of up to 6 digits.  When it's
 		 * unlikely that it already exists it will be faster,
 		 * otherwise it doesn't matter.  The use of mkdir() avoids any
 		 * security problems because of the predictable number. */
 		nr = (mch_get_pid() + (long)time(NULL)) % 1000000L;
+		itmplen = STRLEN(itmp);
 
 		/* Try up to 10000 different values until we find a name that
 		 * doesn't exist. */
 		for (off = 0; off < 10000L; ++off)
 		{
 		    int		r;
-#if defined(UNIX) || defined(VMS)
+#  if defined(UNIX) || defined(VMS)
 		    mode_t	umask_save;
-#endif
+#  endif
 
-		    sprintf((char *)itmp + STRLEN(itmp), "v%ld", nr + off);
-# ifndef EEXIST
+		    sprintf((char *)itmp + itmplen, "v%ld", nr + off);
+#  ifndef EEXIST
 		    /* If mkdir() does not set errno to EEXIST, check for
 		     * existing file here.  There is a race condition then,
 		     * although it's fail-safe. */
 		    if (mch_stat((char *)itmp, &st) >= 0)
 			continue;
-# endif
-#if defined(UNIX) || defined(VMS)
+#  endif
+#  if defined(UNIX) || defined(VMS)
 		    /* Make sure the umask doesn't remove the executable bit.
 		     * "repl" has been reported to use "177". */
 		    umask_save = umask(077);
-#endif
+#  endif
 		    r = vim_mkdir(itmp, 0700);
-#if defined(UNIX) || defined(VMS)
+#  if defined(UNIX) || defined(VMS)
 		    (void)umask(umask_save);
-#endif
+#  endif
 		    if (r == 0)
 		    {
-			char_u	*buf;
-
-			/* Directory was created, use this name.
-			 * Expand to full path; When using the current
-			 * directory a ":cd" would confuse us. */
-			buf = alloc((unsigned)MAXPATHL + 1);
-			if (buf != NULL)
-			{
-			    if (vim_FullName(itmp, buf, MAXPATHL, FALSE)
-								      == FAIL)
-				STRCPY(buf, itmp);
-# ifdef __EMX__
-			    if (vim_strchr(buf, '/') != NULL)
-				STRCAT(buf, "/");
-			    else
-# endif
-				add_pathsep(buf);
-			    vim_tempdir = vim_strsave(buf);
-			    vim_free(buf);
-			}
+			vim_settempdir(itmp);
 			break;
 		    }
-# ifdef EEXIST
+#  ifdef EEXIST
 		    /* If the mkdir() didn't fail because the file/dir exists,
 		     * we probably can't create any dir here, try another
 		     * place. */
 		    if (errno != EEXIST)
-# endif
+#  endif
 			break;
 		}
+# endif /* HAVE_MKDTEMP */
 		if (vim_tempdir != NULL)
 		    break;
 	    }
 	}
     }
@@ -7711,11 +7923,14 @@ au_event_disable(what)
     if (save_ei != NULL)
     {
 	new_ei = vim_strnsave(p_ei, (int)(STRLEN(p_ei) + STRLEN(what)));
 	if (new_ei != NULL)
 	{
-	    STRCAT(new_ei, what);
+	    if (*what == ',' && *p_ei == NUL)
+		STRCPY(new_ei, what + 1);
+	    else
+		STRCAT(new_ei, what);
 	    set_string_option_direct((char_u *)"ei", -1, new_ei,
 							  OPT_FREE, SID_NONE);
 	    vim_free(new_ei);
 	}
     }
@@ -8243,11 +8458,11 @@ ex_doautoall(eap)
 	    /* execute the autocommands for this buffer */
 	    retval = do_doautocmd(eap->arg, FALSE);
 
 	    /* Execute the modeline settings, but don't set window-local
 	     * options if we are using the current window for another buffer. */
-	    do_modelines(aco.save_curwin == NULL ? OPT_NOWIN : 0);
+	    do_modelines(curwin == aucmd_win ? OPT_NOWIN : 0);
 
 	    /* restore the current window */
 	    aucmd_restbuf(&aco);
 
 	    /* stop if there is some error or buffer was deleted */
@@ -8259,23 +8474,24 @@ ex_doautoall(eap)
     check_cursor();	    /* just in case lines got deleted */
 }
 
 /*
  * Prepare for executing autocommands for (hidden) buffer "buf".
- * Search a window for the current buffer.  Save the cursor position and
- * screen offset.
+ * Search for a visible window containing the current buffer.  If there isn't
+ * one then use "aucmd_win".
  * Set "curbuf" and "curwin" to match "buf".
  * When FEAT_AUTOCMD is not defined another version is used, see below.
  */
     void
 aucmd_prepbuf(aco, buf)
     aco_save_T	*aco;		/* structure to save values in */
     buf_T	*buf;		/* new curbuf */
 {
     win_T	*win;
-
-    aco->new_curbuf = buf;
+#ifdef FEAT_WINDOWS
+    int		save_ea;
+#endif
 
     /* Find a window that is for the new buffer */
     if (buf == curbuf)		/* be quick when buf is curbuf */
 	win = curwin;
     else
@@ -8285,46 +8501,71 @@ aucmd_prepbuf(aco, buf)
 		break;
 #else
 	win = NULL;
 #endif
 
-    /*
-     * Prefer to use an existing window for the buffer, it has the least side
-     * effects (esp. if "buf" is curbuf).
-     * Otherwise, use curwin for "buf".  It might make some items in the
-     * window invalid.  At least save the cursor and topline.
-     */
+    /* Allocate "aucmd_win" when needed.  If this fails (out of memory) fall
+     * back to using the current window. */
+    if (win == NULL && aucmd_win == NULL)
+    {
+	win_alloc_aucmd_win();
+	if (aucmd_win == NULL)
+	    win = curwin;
+    }
+    if (win == NULL && aucmd_win_used)
+	/* Strange recursive autocommand, fall back to using the current
+	 * window.  Expect a few side effects... */
+	win = curwin;
+
+    aco->save_curwin = curwin;
+    aco->save_curbuf = curbuf;
     if (win != NULL)
     {
-	/* there is a window for "buf", make it the curwin */
-	aco->save_curwin = curwin;
+	/* There is a window for "buf" in the current tab page, make it the
+	 * curwin.  This is preferred, it has the least side effects (esp. if
+	 * "buf" is curbuf). */
+	aco->use_aucmd_win = FALSE;
 	curwin = win;
-	aco->save_buf = win->w_buffer;
-	aco->new_curwin = win;
     }
     else
     {
-	/* there is no window for "buf", use curwin */
-	aco->save_curwin = NULL;
-	aco->save_buf = curbuf;
-	--curbuf->b_nwindows;
-	curwin->w_buffer = buf;
+	/* There is no window for "buf", use "aucmd_win".  To minimize the side
+	 * effects, insert it in a the current tab page.
+	 * Anything related to a window (e.g., setting folds) may have
+	 * unexpected results. */
+	aco->use_aucmd_win = TRUE;
+	aucmd_win_used = TRUE;
+	aucmd_win->w_buffer = buf;
 	++buf->b_nwindows;
+	win_init_empty(aucmd_win); /* set cursor and topline to safe values */
+	vim_free(aucmd_win->w_localdir);
+	aucmd_win->w_localdir = NULL;
+
+	/* Make sure w_localdir and globaldir are NULL to avoid a chdir() in
+	 * win_enter_ext(). */
+	aucmd_win->w_localdir = NULL;
+	aco->globaldir = globaldir;
+	globaldir = NULL;
 
-	/* save cursor and topline, set them to safe values */
-	aco->save_cursor = curwin->w_cursor;
-	curwin->w_cursor.lnum = 1;
-	curwin->w_cursor.col = 0;
-	aco->save_topline = curwin->w_topline;
-	curwin->w_topline = 1;
-#ifdef FEAT_DIFF
-	aco->save_topfill = curwin->w_topfill;
-	curwin->w_topfill = 0;
+
+#ifdef FEAT_WINDOWS
+	/* Split the current window, put the aucmd_win in the upper half.
+	 * We don't want the BufEnter or WinEnter autocommands. */
+	block_autocmds();
+	make_snapshot(SNAP_AUCMD_IDX);
+	save_ea = p_ea;
+	p_ea = FALSE;
+	(void)win_split_ins(0, WSP_TOP, aucmd_win, 0);
+	(void)win_comp_pos();   /* recompute window positions */
+	p_ea = save_ea;
+	unblock_autocmds();
 #endif
+	curwin = aucmd_win;
     }
-
     curbuf = buf;
+    aco->new_curwin = curwin;
+    aco->new_curbuf = curbuf;
 }
 
 /*
  * Cleanup after executing autocommands for a (hidden) buffer.
  * Restore the window as it was (if possible).
@@ -8332,61 +8573,105 @@ aucmd_prepbuf(aco, buf)
  */
     void
 aucmd_restbuf(aco)
     aco_save_T	*aco;		/* structure holding saved values */
 {
-    if (aco->save_curwin != NULL)
+#ifdef FEAT_WINDOWS
+    int dummy;
+#endif
+
+    if (aco->use_aucmd_win)
+    {
+	--curbuf->b_nwindows;
+#ifdef FEAT_WINDOWS
+	/* Find "aucmd_win", it can't be closed, but it may be in another tab
+	 * page. Do not trigger autocommands here. */
+	block_autocmds();
+	if (curwin != aucmd_win)
+	{
+	    tabpage_T	*tp;
+	    win_T	*wp;
+
+	    FOR_ALL_TAB_WINDOWS(tp, wp)
+	    {
+		if (wp == aucmd_win)
+		{
+		    if (tp != curtab)
+			goto_tabpage_tp(tp);
+		    win_goto(aucmd_win);
+		    break;
+		}
+	    }
+	}
+
+	/* Remove the window and frame from the tree of frames. */
+	(void)winframe_remove(curwin, &dummy, NULL);
+	win_remove(curwin, NULL);
+	aucmd_win_used = FALSE;
+	last_status(FALSE);	    /* may need to remove last status line */
+	restore_snapshot(SNAP_AUCMD_IDX, FALSE);
+	(void)win_comp_pos();   /* recompute window positions */
+	unblock_autocmds();
+
+	if (win_valid(aco->save_curwin))
+	    curwin = aco->save_curwin;
+	else
+	    /* Hmm, original window disappeared.  Just use the first one. */
+	    curwin = firstwin;
+# ifdef FEAT_EVAL
+	vars_clear(&aucmd_win->w_vars.dv_hashtab);  /* free all w: variables */
+	hash_init(&aucmd_win->w_vars.dv_hashtab);   /* re-use the hashtab */
+# endif
+#else
+	curwin = aco->save_curwin;
+#endif
+	curbuf = curwin->w_buffer;
+
+	vim_free(globaldir);
+	globaldir = aco->globaldir;
+
+	/* the buffer contents may have changed */
+	check_cursor();
+	if (curwin->w_topline > curbuf->b_ml.ml_line_count)
+	{
+	    curwin->w_topline = curbuf->b_ml.ml_line_count;
+#ifdef FEAT_DIFF
+	    curwin->w_topfill = 0;
+#endif
+	}
+#if defined(FEAT_GUI)
+	/* Hide the scrollbars from the aucmd_win and update. */
+	gui_mch_enable_scrollbar(&aucmd_win->w_scrollbars[SBAR_LEFT], FALSE);
+	gui_mch_enable_scrollbar(&aucmd_win->w_scrollbars[SBAR_RIGHT], FALSE);
+	gui_may_update_scrollbars();
+#endif
+    }
+    else
     {
 	/* restore curwin */
 #ifdef FEAT_WINDOWS
 	if (win_valid(aco->save_curwin))
 #endif
 	{
-	    /* restore the buffer which was previously edited by curwin, if
-	     * it's still the same window and it's valid */
+	    /* Restore the buffer which was previously edited by curwin, if
+	     * it was changed, we are still the same window and the buffer is
+	     * valid. */
 	    if (curwin == aco->new_curwin
-		    && buf_valid(aco->save_buf)
-		    && aco->save_buf->b_ml.ml_mfp != NULL)
+		    && curbuf != aco->new_curbuf
+		    && buf_valid(aco->new_curbuf)
+		    && aco->new_curbuf->b_ml.ml_mfp != NULL)
 	    {
 		--curbuf->b_nwindows;
-		curbuf = aco->save_buf;
+		curbuf = aco->new_curbuf;
 		curwin->w_buffer = curbuf;
 		++curbuf->b_nwindows;
 	    }
 
 	    curwin = aco->save_curwin;
 	    curbuf = curwin->w_buffer;
 	}
     }
-    else
-    {
-	/* restore buffer for curwin if it still exists and is loaded */
-	if (buf_valid(aco->save_buf) && aco->save_buf->b_ml.ml_mfp != NULL)
-	{
-	    --curbuf->b_nwindows;
-	    curbuf = aco->save_buf;
-	    curwin->w_buffer = curbuf;
-	    ++curbuf->b_nwindows;
-	    curwin->w_cursor = aco->save_cursor;
-	    check_cursor();
-	    /* check topline < line_count, in case lines got deleted */
-	    if (aco->save_topline <= curbuf->b_ml.ml_line_count)
-	    {
-		curwin->w_topline = aco->save_topline;
-#ifdef FEAT_DIFF
-		curwin->w_topfill = aco->save_topfill;
-#endif
-	    }
-	    else
-	    {
-		curwin->w_topline = curbuf->b_ml.ml_line_count;
-#ifdef FEAT_DIFF
-		curwin->w_topfill = 0;
-#endif
-	    }
-	}
-    }
 }
 
 static int	autocmd_nested = FALSE;
 
 /*
@@ -8521,10 +8806,11 @@ apply_autocmds_group(event, fname, fname
     buf_T	*old_curbuf;
     int		retval = FALSE;
     char_u	*save_sourcing_name;
     linenr_T	save_sourcing_lnum;
     char_u	*save_autocmd_fname;
+    int		save_autocmd_fname_full;
     int		save_autocmd_bufnr;
     char_u	*save_autocmd_match;
     int		save_autocmd_busy;
     int		save_autocmd_nested;
     static int	nesting = 0;
@@ -8599,10 +8885,11 @@ apply_autocmds_group(event, fname, fname
 
     /*
      * Save the autocmd_* variables and info about the current buffer.
      */
     save_autocmd_fname = autocmd_fname;
+    save_autocmd_fname_full = autocmd_fname_full;
     save_autocmd_bufnr = autocmd_bufnr;
     save_autocmd_match = autocmd_match;
     save_autocmd_busy = autocmd_busy;
     save_autocmd_nested = autocmd_nested;
     save_changed = curbuf->b_changed;
@@ -8616,18 +8903,19 @@ apply_autocmds_group(event, fname, fname
     if (fname_io == NULL)
     {
 	if (fname != NULL && *fname != NUL)
 	    autocmd_fname = fname;
 	else if (buf != NULL)
-	    autocmd_fname = buf->b_fname;
+	    autocmd_fname = buf->b_ffname;
 	else
 	    autocmd_fname = NULL;
     }
     else
 	autocmd_fname = fname_io;
     if (autocmd_fname != NULL)
-	autocmd_fname = FullName_save(autocmd_fname, FALSE);
+	autocmd_fname = vim_strsave(autocmd_fname);
+    autocmd_fname_full = FALSE; /* call FullName_save() later */
 
     /*
      * Set the buffer number to be used for <abuf>.
      */
     if (buf == NULL)
@@ -8665,13 +8953,15 @@ apply_autocmds_group(event, fname, fname
 	fname = vim_strsave(fname);	/* make a copy, so we can change it */
     }
     else
     {
 	sfname = vim_strsave(fname);
-	/* Don't try expanding FileType, Syntax, WindowID or QuickFixCmd* */
+	/* Don't try expanding FileType, Syntax, FuncUndefined, WindowID or
+	 * QuickFixCmd* */
 	if (event == EVENT_FILETYPE
 		|| event == EVENT_SYNTAX
+		|| event == EVENT_FUNCUNDEFINED
 		|| event == EVENT_REMOTEREPLY
 		|| event == EVENT_SPELLFILEMISSING
 		|| event == EVENT_QUICKFIXCMDPRE
 		|| event == EVENT_QUICKFIXCMDPOST)
 	    fname = vim_strsave(fname);
@@ -8808,10 +9098,11 @@ apply_autocmds_group(event, fname, fname
     vim_free(sourcing_name);
     sourcing_name = save_sourcing_name;
     sourcing_lnum = save_sourcing_lnum;
     vim_free(autocmd_fname);
     autocmd_fname = save_autocmd_fname;
+    autocmd_fname_full = save_autocmd_fname_full;
     autocmd_bufnr = save_autocmd_bufnr;
     autocmd_match = save_autocmd_match;
 #ifdef FEAT_EVAL
     current_SID = save_current_SID;
     restore_funccal(save_funccalp);
@@ -8916,11 +9207,11 @@ auto_next_pat(apc, stop_at_last)
 
     for (ap = apc->curpat; ap != NULL && !got_int; ap = ap->next)
     {
 	apc->curpat = NULL;
 
-	/* only use a pattern when it has not been removed, has commands and
+	/* Only use a pattern when it has not been removed, has commands and
 	 * the group matches. For buffer-local autocommands only check the
 	 * buffer number. */
 	if (ap->pat != NULL && ap->cmds != NULL
 		&& (apc->group == AUGROUP_ALL || apc->group == ap->group))
 	{
@@ -8965,16 +9256,15 @@ auto_next_pat(apc, stop_at_last)
 /*
  * Get next autocommand command.
  * Called by do_cmdline() to get the next line for ":if".
  * Returns allocated string, or NULL for end of autocommands.
  */
-/* ARGSUSED */
     static char_u *
 getnextac(c, cookie, indent)
-    int	    c;		    /* not used */
+    int	    c UNUSED;
     void    *cookie;
-    int	    indent;	    /* not used */
+    int	    indent UNUSED;
 {
     AutoPatCmd	    *acp = (AutoPatCmd *)cookie;
     char_u	    *retval;
     AutoCmd	    *ac;
 
@@ -9081,14 +9371,13 @@ has_autocmd(event, sfname, buf)
 #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
 /*
  * Function given to ExpandGeneric() to obtain the list of autocommand group
  * names.
  */
-/*ARGSUSED*/
     char_u *
 get_augroup_name(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     if (idx == augroups.ga_len)		/* add "END" add the end */
 	return (char_u *)"END";
     if (idx >= augroups.ga_len)		/* end of list */
@@ -9102,11 +9391,11 @@ static int include_groups = FALSE;
 
     char_u  *
 set_context_in_autocmd(xp, arg, doautocmd)
     expand_T	*xp;
     char_u	*arg;
-    int		doautocmd;	/* TRUE for :doautocmd, FALSE for :autocmd */
+    int		doautocmd;	/* TRUE for :doauto*, FALSE for :autocmd */
 {
     char_u	*p;
     int		group;
 
     /* check for a group name, skip it if present */
@@ -9150,14 +9439,13 @@ set_context_in_autocmd(xp, arg, doautocm
 }
 
 /*
  * Function given to ExpandGeneric() to obtain the list of event names.
  */
-/*ARGSUSED*/
     char_u *
 get_event_name(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     if (idx < augroups.ga_len)		/* First list group names, if wanted */
     {
 	if (!include_groups || AUGROUP_NAME(idx) == NULL)
@@ -9252,30 +9540,26 @@ au_exists(arg)
      * If there isn't any, return FALSE;
      * If there is one and no pattern given, return TRUE; */
     ap = first_autopat[(int)event];
     if (ap == NULL)
 	goto theend;
-    if (pattern == NULL)
-    {
-	retval = TRUE;
-	goto theend;
-    }
 
     /* if pattern is "<buffer>", special handling is needed which uses curbuf */
     /* for pattern "<buffer=N>, fnamecmp() will work fine */
-    if (STRICMP(pattern, "<buffer>") == 0)
+    if (pattern != NULL && STRICMP(pattern, "<buffer>") == 0)
 	buflocal_buf = curbuf;
 
     /* Check if there is an autocommand with the given pattern. */
     for ( ; ap != NULL; ap = ap->next)
 	/* only use a pattern when it has not been removed and has commands. */
 	/* For buffer-local autocommands, fnamecmp() works fine. */
 	if (ap->pat != NULL && ap->cmds != NULL
 	    && (group == AUGROUP_ALL || ap->group == group)
-	    && (buflocal_buf == NULL
-		 ? fnamecmp(ap->pat, pattern) == 0
-		 : ap->buflocal_nr == buflocal_buf->b_fnum))
+	    && (pattern == NULL
+		|| (buflocal_buf == NULL
+		    ? fnamecmp(ap->pat, pattern) == 0
+		    : ap->buflocal_nr == buflocal_buf->b_fnum)))
 	{
 	    retval = TRUE;
 	    break;
 	}
 
@@ -9294,25 +9578,29 @@ theend:
     void
 aucmd_prepbuf(aco, buf)
     aco_save_T	*aco;		/* structure to save values in */
     buf_T	*buf;		/* new curbuf */
 {
-    aco->save_buf = curbuf;
+    aco->save_curbuf = curbuf;
+    --curbuf->b_nwindows;
     curbuf = buf;
     curwin->w_buffer = buf;
+    ++curbuf->b_nwindows;
 }
 
 /*
  * Restore after executing commands for a (hidden) buffer.
  * This is the non-autocommand version.
  */
     void
 aucmd_restbuf(aco)
     aco_save_T	*aco;		/* structure holding saved values */
 {
-    curbuf = aco->save_buf;
+    --curbuf->b_nwindows;
+    curbuf = aco->save_curbuf;
     curwin->w_buffer = curbuf;
+    ++curbuf->b_nwindows;
 }
 
 #endif	/* FEAT_AUTOCMD */
 
 
@@ -9465,17 +9753,16 @@ match_file_list(list, sfname, ffname)
  * If FEAT_OSFILETYPE defined then pass initial <type> through unchanged. Eg:
  * '<html>myfile' becomes '<html>^myfile$' -- leonard.
  *
  * Returns NULL when out of memory.
  */
-/*ARGSUSED*/
     char_u *
 file_pat_to_reg_pat(pat, pat_end, allow_dirs, no_bslash)
     char_u	*pat;
     char_u	*pat_end;	/* first char after pattern or NULL */
     char	*allow_dirs;	/* Result passed back out in here */
-    int		no_bslash;	/* Don't use a backward slash as pathsep */
+    int		no_bslash UNUSED; /* Don't use a backward slash as pathsep */
 {
     int		size;
     char_u	*endp;
     char_u	*reg_pat;
     char_u	*p;
--- vim72.orig/src/globals.h
+++ vim72/src/globals.h
@@ -480,12 +480,14 @@ EXTERN char	*foreground_argument INIT(=
 # endif
 
 /*
  * While executing external commands or in Ex mode, should not insert GUI
  * events in the input buffer: Set hold_gui_events to non-zero.
+ *
+ * volatile because it is used in signal handler sig_sysmouse().
  */
-EXTERN int	hold_gui_events INIT(= 0);
+EXTERN volatile int hold_gui_events INIT(= 0);
 
 /*
  * When resizing the shell is postponed, remember the new size, and call
  * gui_resize_shell() later.
  */
@@ -505,10 +507,11 @@ EXTERN VimClipboard clip_plus;	/* CLIPBO
 #  define clip_plus clip_star	/* there is only one clipboard */
 # endif
 EXTERN int	clip_unnamed INIT(= FALSE);
 EXTERN int	clip_autoselect INIT(= FALSE);
 EXTERN int	clip_autoselectml INIT(= FALSE);
+EXTERN int	clip_html INIT(= FALSE);
 EXTERN regprog_T *clip_exclude_prog INIT(= NULL);
 #endif
 
 /*
  * All windows are linked in a list. firstwin points to the first entry,
@@ -520,11 +523,11 @@ EXTERN regprog_T *clip_exclude_prog INIT
 EXTERN win_T	*firstwin;		/* first window */
 EXTERN win_T	*lastwin;		/* last window */
 EXTERN win_T	*prevwin INIT(= NULL);	/* previous window */
 # define W_NEXT(wp) ((wp)->w_next)
 # define FOR_ALL_WINDOWS(wp) for (wp = firstwin; wp != NULL; wp = wp->w_next)
-#define FOR_ALL_TAB_WINDOWS(tp, wp) \
+# define FOR_ALL_TAB_WINDOWS(tp, wp) \
     for ((tp) = first_tabpage; (tp) != NULL; (tp) = (tp)->tp_next) \
 	for ((wp) = ((tp) == curtab) \
 		? firstwin : (tp)->tp_firstwin; (wp); (wp) = (wp)->w_next)
 #else
 # define firstwin curwin
@@ -534,10 +537,15 @@ EXTERN win_T	*prevwin INIT(= NULL);	/* p
 # define FOR_ALL_TAB_WINDOWS(tp, wp) wp = curwin;
 #endif
 
 EXTERN win_T	*curwin;	/* currently active window */
 
+#ifdef FEAT_AUTOCMD
+EXTERN win_T	*aucmd_win;	/* window used in aucmd_prepbuf() */
+EXTERN int	aucmd_win_used INIT(= FALSE);	/* aucmd_win is being used */
+#endif
+
 /*
  * The window layout is kept in a tree of frames.  topframe points to the top
  * of the tree.
  */
 EXTERN frame_T	*topframe;	/* top of the window frame tree */
@@ -595,11 +603,12 @@ EXTERN int	exiting INIT(= FALSE);
 				 * still keep on running if there is a changed
 				 * buffer. */
 EXTERN int	really_exiting INIT(= FALSE);
 				/* TRUE when we are sure to exit, e.g., after
 				 * a deadly signal */
-EXTERN int	full_screen INIT(= FALSE);
+/* volatile because it is used in signal handler deathtrap(). */
+EXTERN volatile int full_screen INIT(= FALSE);
 				/* TRUE when doing full-screen output
 				 * otherwise only writing some messages */
 
 EXTERN int	restricted INIT(= FALSE);
 				/* TRUE when started as "rvim" */
@@ -614,10 +623,15 @@ EXTERN int	textlock INIT(= 0);
 
 #ifdef FEAT_AUTOCMD
 EXTERN int	curbuf_lock INIT(= 0);
 				/* non-zero when the current buffer can't be
 				 * changed.  Used for FileChangedRO. */
+EXTERN int	allbuf_lock INIT(= 0);
+				/* non-zero when no buffer name can be
+				 * changed, no buffer can be deleted and
+				 * current directory can't be changed.
+				 * Used for SwapExists et al. */
 #endif
 #ifdef FEAT_EVAL
 # define HAVE_SANDBOX
 EXTERN int	sandbox INIT(= 0);
 				/* Non-zero when evaluating an expression in a
@@ -708,11 +722,11 @@ EXTERN int	can_si INIT(= FALSE);
 EXTERN int	can_si_back INIT(= FALSE);
 #endif
 
 EXTERN pos_T	saved_cursor		/* w_cursor before formatting text. */
 # ifdef DO_INIT
-	= INIT_POS_T
+	= INIT_POS_T(0, 0, 0)
 # endif
 	;
 
 /*
  * Stuff for insert mode.
@@ -737,14 +751,16 @@ EXTERN JMP_BUF x_jump_env;
  * Stuff for setjmp() and longjmp().
  * Used to protect areas where we could crash.
  */
 EXTERN JMP_BUF lc_jump_env;	/* argument to SETJMP() */
 # ifdef SIGHASARG
-EXTERN int lc_signal;		/* catched signal number, 0 when no was signal
-				   catched; used for mch_libcall() */
+/* volatile because it is used in signal handlers. */
+EXTERN volatile int lc_signal;	/* caught signal number, 0 when no was signal
+				   caught; used for mch_libcall() */
 # endif
-EXTERN int lc_active INIT(= FALSE); /* TRUE when lc_jump_env is valid. */
+/* volatile because it is used in signal handler deathtrap(). */
+EXTERN volatile int lc_active INIT(= FALSE); /* TRUE when lc_jump_env is valid. */
 #endif
 
 #if defined(FEAT_MBYTE) || defined(FEAT_POSTSCRIPT)
 /*
  * These flags are set based upon 'fileencoding'.
@@ -798,15 +814,18 @@ EXTERN vimconv_T output_conv;			/* type
  * (DBCS).
  * The value is set in mb_init();
  */
 /* length of char in bytes, including following composing chars */
 EXTERN int (*mb_ptr2len) __ARGS((char_u *p)) INIT(= latin_ptr2len);
+/* idem, with limit on string length */
+EXTERN int (*mb_ptr2len_len) __ARGS((char_u *p, int size)) INIT(= latin_ptr2len_len);
 /* byte length of char */
 EXTERN int (*mb_char2len) __ARGS((int c)) INIT(= latin_char2len);
 /* convert char to bytes, return the length */
 EXTERN int (*mb_char2bytes) __ARGS((int c, char_u *buf)) INIT(= latin_char2bytes);
 EXTERN int (*mb_ptr2cells) __ARGS((char_u *p)) INIT(= latin_ptr2cells);
+EXTERN int (*mb_ptr2cells_len) __ARGS((char_u *p, int size)) INIT(= latin_ptr2cells_len);
 EXTERN int (*mb_char2cells) __ARGS((int c)) INIT(= latin_char2cells);
 EXTERN int (*mb_off2cells) __ARGS((unsigned off, unsigned max_off)) INIT(= latin_off2cells);
 EXTERN int (*mb_ptr2char) __ARGS((char_u *p)) INIT(= latin_ptr2char);
 EXTERN int (*mb_head_off) __ARGS((char_u *base, char_u *p)) INIT(= latin_head_off);
 
@@ -948,11 +967,11 @@ EXTERN struct buffheader stuffbuff	/* st
 		    = {{NULL, {NUL}}, NULL, 0, 0}
 #endif
 		    ;
 EXTERN typebuf_T typebuf		/* typeahead buffer */
 #ifdef DO_INIT
-		    = {NULL, NULL}
+		    = {NULL, NULL, 0, 0, 0, 0, 0, 0, 0}
 #endif
 		    ;
 #ifdef FEAT_EX_EXTRA
 EXTERN int	ex_normal_busy INIT(= 0); /* recursiveness of ex_normal() */
 EXTERN int	ex_normal_lock INIT(= 0); /* forbid use of ex_normal() */
@@ -984,11 +1003,12 @@ EXTERN char_u	*use_viminfo INIT(= NULL);
 EXTERN FILE	*scriptin[NSCRIPT];	    /* streams to read script from */
 EXTERN int	curscript INIT(= 0);	    /* index in scriptin[] */
 EXTERN FILE	*scriptout  INIT(= NULL);   /* stream to write script to */
 EXTERN int	read_cmd_fd INIT(= 0);	    /* fd to read commands from */
 
-EXTERN int	got_int INIT(= FALSE);	    /* set to TRUE when interrupt
+/* volatile because it is used in signal handler catch_sigint(). */
+EXTERN volatile int got_int INIT(= FALSE);    /* set to TRUE when interrupt
 						signal occurred */
 #ifdef USE_TERM_CONSOLE
 EXTERN int	term_console INIT(= FALSE); /* set to TRUE when console used */
 #endif
 EXTERN int	termcap_active INIT(= FALSE);	/* set by starttermcap() */
@@ -1020,16 +1040,17 @@ EXTERN char_u	*repeat_cmdline INIT(= NUL
 #ifdef FEAT_CMDHIST
 EXTERN char_u	*new_last_cmdline INIT(= NULL);	/* new value for last_cmdline */
 #endif
 #ifdef FEAT_AUTOCMD
 EXTERN char_u	*autocmd_fname INIT(= NULL); /* fname for <afile> on cmdline */
+EXTERN int	autocmd_fname_full;	     /* autocmd_fname is full path */
 EXTERN int	autocmd_bufnr INIT(= 0);     /* fnum for <abuf> on cmdline */
 EXTERN char_u	*autocmd_match INIT(= NULL); /* name for <amatch> on cmdline */
 EXTERN int	did_cursorhold INIT(= FALSE); /* set when CursorHold t'gerd */
 EXTERN pos_T	last_cursormoved	    /* for CursorMoved event */
 # ifdef DO_INIT
-			= INIT_POS_T
+			= INIT_POS_T(0, 0, 0)
 # endif
 			;
 #endif
 
 EXTERN linenr_T	write_no_eol_lnum INIT(= 0); /* non-zero lnum when last line
@@ -1337,11 +1358,10 @@ EXTERN garray_T error_ga
 	;
 #endif
 
 #ifdef FEAT_NETBEANS_INTG
 EXTERN char *netbeansArg INIT(= NULL);	/* the -nb[:host:port:passwd] arg */
-EXTERN int netbeansCloseFile INIT(= 0);	/* send killed if != 0 */
 EXTERN int netbeansFireChanges INIT(= 1); /* send buffer changes if != 0 */
 EXTERN int netbeansForcedQuit INIT(= 0);/* don't write modified files */
 EXTERN int netbeansReadFile INIT(= 1);	/* OK to read from disk if != 0 */
 EXTERN int netbeansSuppressNoLines INIT(= 0); /* skip "No lines in buffer" */
 EXTERN int usingNetbeans INIT(= 0);	/* set if -nb flag is used */
@@ -1545,10 +1565,22 @@ EXTERN int xsmp_icefd INIT(= -1);   /* T
 #endif
 
 /* For undo we need to know the lowest time possible. */
 EXTERN time_t starttime;
 
+#ifdef STARTUPTIME
+EXTERN FILE *time_fd INIT(= NULL);  /* where to write startup timing */
+#endif
+
+/*
+ * Some compilers warn for not using a return value, but in some situations we
+ * can't do anything useful with the value.  Assign to this variable to avoid
+ * the warning.
+ */
+EXTERN int ignored;
+EXTERN char *ignoredp;
+
 /*
  * Optional Farsi support.  Include it here, so EXTERN and INIT are defined.
  */
 #ifdef FEAT_FKMAP
 # include "farsi.h"
--- vim72.orig/Filelist
+++ vim72/Filelist
@@ -283,10 +283,11 @@ SRC_DOS =	\
 		src/proto/os_msdos.pro \
 		src/proto/os_win16.pro \
 		src/proto/os_win32.pro \
 		src/proto/os_mswin.pro \
 		src/testdir/Make_dos.mak \
+		src/testdir/Make_ming.mak \
 		src/testdir/dos.vim \
 		src/uninstal.c \
 		src/vim.def \
 		src/vim.rc \
 		src/vimio.h \
@@ -680,13 +681,11 @@ LANG_GEN = \
 		runtime/spell/README.txt \
 		runtime/spell/??/*.diff \
 		runtime/spell/??/main.aap \
 		runtime/spell/yi/README.txt \
 		runtime/spell/main.aap \
-		runtime/spell/cleanadd.vim \
 		runtime/spell/*.vim \
-		runtime/spell/fixdup \
 
 # generic language files, binary
 LANG_GEN_BIN = \
 		runtime/spell/README_en.txt \
 		runtime/spell/en.ascii.spl \
--- /dev/null
+++ vim72/src/testdir/Make_ming.mak
@@ -0,0 +1,93 @@
+# Makefile to run tests for Vim, on Dos-like machines
+# with sh.exe or zsh.exe in the path or not.
+#
+# Author: Bill McCarthy
+#
+# Note that test54 has been removed until it is fixed.
+#
+# Requires a set of Unix tools: echo, diff, etc.
+
+ifneq (sh.exe, $(SHELL))
+DEL = rm -f
+MV = mv
+CP = cp
+DIRSLASH = /
+else
+DEL = del
+MV = rename
+CP = copy
+DIRSLASH = \\
+endif
+
+VIMPROG = ..$(DIRSLASH)vim
+
+# Omitted:
+# test2		"\\tmp" doesn't work.
+# test10	'errorformat' is different
+# test12	can't unlink a swap file
+# test25	uses symbolic link
+# test27	can't edit file with "*" in file name
+# test31	16 bit version runs out of memory...
+
+SCRIPTS16 =	test1.out test19.out test20.out test22.out \
+		test23.out test24.out test28.out test29.out \
+		test35.out test36.out test43.out \
+		test44.out test45.out test46.out test47.out \
+		test48.out test51.out test53.out            \
+		test55.out test56.out test57.out test58.out test59.out \
+		test60.out test61.out test62.out test63.out test64.out
+
+# Had to remove test54 which doesn't work yet.
+#		                                 test54.out
+
+SCRIPTS =	test3.out test4.out test5.out test6.out test7.out \
+		test8.out test9.out test11.out test13.out test14.out \
+		test15.out test17.out test18.out test21.out test26.out \
+		test30.out test31.out test32.out test33.out test34.out \
+		test37.out test38.out test39.out test40.out test41.out \
+		test42.out test52.out test65.out test66.out test67.out \
+		test68.out test69.out
+
+SCRIPTS32 =	test50.out test70.out
+
+SCRIPTS_GUI = test16.out
+
+.SUFFIXES: .in .out
+
+vimall:	fixff $(SCRIPTS16) $(SCRIPTS) $(SCRIPTS_GUI) $(SCRIPTS32)
+	echo ALL DONE
+
+nongui:	fixff $(SCRIPTS16) $(SCRIPTS)
+	echo ALL DONE
+
+small:
+	echo ALL DONE
+
+gui:	fixff $(SCRIPTS16) $(SCRIPTS) $(SCRIPTS_GUI)
+	echo ALL DONE
+
+win32:	fixff $(SCRIPTS16) $(SCRIPTS) $(SCRIPTS32)
+	echo ALL DONE
+
+fixff:
+	-$(VIMPROG) -u dos.vim --noplugin "+argdo set ff=dos|upd" +q *.in *.ok
+
+clean:
+	-$(DEL) *.out
+	-$(DEL) test.ok
+	-$(DEL) small.vim
+	-$(DEL) tiny.vim
+	-$(DEL) mbyte.vim
+	-$(DEL) mzscheme.vim
+	-$(DEL) X*
+	-$(DEL) viminfo
+
+.in.out:
+	$(CP) $*.ok test.ok
+	$(VIMPROG) -u dos.vim -U NONE --noplugin -s dotest.in $*.in
+	diff test.out $*.ok
+	-$(DEL) $*.out
+	$(MV) test.out $*.out
+	-$(DEL) X*
+	-$(DEL) test.ok
+	-$(DEL) viminfo
--- vim72.orig/src/screen.c
+++ vim72/src/screen.c
@@ -130,11 +130,11 @@ static void screen_line __ARGS((int row,
 #endif
 #ifdef FEAT_VERTSPLIT
 static void draw_vsep_win __ARGS((win_T *wp, int row));
 #endif
 #ifdef FEAT_STL_OPT
-static void redraw_custum_statusline __ARGS((win_T *wp));
+static void redraw_custom_statusline __ARGS((win_T *wp));
 #endif
 #ifdef FEAT_SEARCH_EXTRA
 #define SEARCH_HL_PRIORITY 0
 static void start_search_hl __ARGS((void));
 static void end_search_hl __ARGS((void));
@@ -268,15 +268,14 @@ redraw_buf_later(buf, type)
  * Used when entering/leaving Insert mode with the cursor on a folded line.
  * Used to remove the "$" from a change command.
  * Note that when also inserting/deleting lines w_redraw_top and w_redraw_bot
  * may become invalid and the whole window will have to be redrawn.
  */
-/*ARGSUSED*/
     void
 redrawWinline(lnum, invalid)
     linenr_T	lnum;
-    int		invalid;	/* window line height is invalid now */
+    int		invalid UNUSED;	/* window line height is invalid now */
 {
 #ifdef FEAT_FOLDING
     int		i;
 #endif
 
@@ -322,10 +321,11 @@ update_screen(type)
     static int	did_intro = FALSE;
 #if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_CLIPBOARD)
     int		did_one;
 #endif
 
+    /* Don't do anything if the screen structures are (not yet) valid. */
     if (!screen_valid(TRUE))
 	return;
 
     if (must_redraw)
     {
@@ -341,11 +341,13 @@ update_screen(type)
 
     /* Need to update w_lines[]. */
     if (curwin->w_lines_valid == 0 && type < NOT_VALID)
 	type = NOT_VALID;
 
-    if (!redrawing())
+    /* Postpone the redrawing when it's not needed and when being called
+     * recursively. */
+    if (!redrawing() || updating_screen)
     {
 	redraw_later(type);		/* remember type for next time */
 	must_redraw = type;
 	if (type > INVERTED_ALL)
 	    curwin->w_lines_valid = 0;	/* don't use w_lines[].wl_size now */
@@ -581,10 +583,11 @@ update_screen(type)
 static void update_prepare __ARGS((void));
 static void update_finish __ARGS((void));
 
 /*
  * Prepare for updating one or more windows.
+ * Caller must check for "updating_screen" already set to avoid recursiveness.
  */
     static void
 update_prepare()
 {
     cursor_off();
@@ -662,11 +665,13 @@ update_debug_sign(buf, lnum)
 	    redraw_win_later(wp, VALID);
 	if (wp->w_redr_type != 0)
 	    doit = TRUE;
     }
 
-    if (!doit)
+    /* Return when there is nothing to do or screen updating already
+     * happening. */
+    if (!doit || updating_screen)
 	return;
 
     /* update all windows that need updating */
     update_prepare();
 
@@ -695,10 +700,14 @@ update_debug_sign(buf, lnum)
  */
     void
 updateWindow(wp)
     win_T	*wp;
 {
+    /* return if already busy updating */
+    if (updating_screen)
+	return;
+
     update_prepare();
 
 #ifdef FEAT_CLIPBOARD
     /* When Visual area changed, may have to update selection. */
     if (clip_star.available && clip_isautosel())
@@ -2324,17 +2333,16 @@ fold_line(wp, fold_count, foldinfo, lnum
 		    }
 		}
 		if (cells > 1)
 		    ScreenLines[idx + 1] = 0;
 	    }
-	    else if (cells > 1)	    /* double-byte character */
-	    {
-		if (enc_dbcs == DBCS_JPNU && *p == 0x8e)
-		    ScreenLines2[idx] = p[1];
-		else
-		    ScreenLines[idx + 1] = p[1];
-	    }
+	    else if (enc_dbcs == DBCS_JPNU && *p == 0x8e)
+		/* double-byte single width character */
+		ScreenLines2[idx] = p[1];
+	    else if (cells > 1)
+		/* double-width character */
+		ScreenLines[idx + 1] = p[1];
 	    col += cells;
 	    idx += cells;
 	    p += c_len;
 	}
     }
@@ -2411,11 +2419,11 @@ fold_line(wp, fold_count, foldinfo, lnum
 			    || (lnum == top->lnum
 				&& top->col == 0))
 			&& (lnume < bot->lnum
 			    || (lnume == bot->lnum
 				&& (bot->col - (*p_sel == 'e'))
-		>= STRLEN(ml_get_buf(wp->w_buffer, lnume, FALSE)))))))
+		>= (colnr_T)STRLEN(ml_get_buf(wp->w_buffer, lnume, FALSE)))))))
 	{
 	    if (VIsual_mode == Ctrl_V)
 	    {
 		/* Visual block mode: highlight the chars part of the block */
 		if (wp->w_old_cursor_fcol + txtcol < (colnr_T)W_WIDTH(wp))
@@ -2437,13 +2445,21 @@ fold_line(wp, fold_count, foldinfo, lnum
     }
 #endif
 
 #ifdef FEAT_SYN_HL
     /* Show 'cursorcolumn' in the fold line. */
-    if (wp->w_p_cuc && (int)wp->w_virtcol + txtcol < W_WIDTH(wp))
-	ScreenAttrs[off + wp->w_virtcol + txtcol] = hl_combine_attr(
-		 ScreenAttrs[off + wp->w_virtcol + txtcol], hl_attr(HLF_CUC));
+    if (wp->w_p_cuc)
+    {
+	txtcol += wp->w_virtcol;
+	if (wp->w_p_wrap)
+	    txtcol -= wp->w_skipcol;
+	else
+	    txtcol -= wp->w_leftcol;
+	if (txtcol >= 0 && txtcol < W_WIDTH(wp))
+	    ScreenAttrs[off + txtcol] = hl_combine_attr(
+				 ScreenAttrs[off + txtcol], hl_attr(HLF_CUC));
+    }
 #endif
 
     SCREEN_LINE(row + W_WINROW(wp), W_WINCOL(wp), (int)W_WIDTH(wp),
 						     (int)W_WIDTH(wp), FALSE);
 
@@ -2539,18 +2555,17 @@ fill_foldcolumn(p, wp, closed, lnum)
  * Start at row "startrow", stop when "endrow" is reached.
  * wp->w_virtcol needs to be valid.
  *
  * Return the number of last row the line occupies.
  */
-/* ARGSUSED */
     static int
 win_line(wp, lnum, startrow, endrow, nochange)
     win_T	*wp;
     linenr_T	lnum;
     int		startrow;
     int		endrow;
-    int		nochange;		/* not updating for changed text */
+    int		nochange UNUSED;	/* not updating for changed text */
 {
     int		col;			/* visual column on screen */
     unsigned	off;			/* offset in ScreenLines/ScreenAttrs */
     int		c = 0;			/* init for GCC */
     long	vcol = 0;		/* virtual column (for tabs) */
@@ -2586,10 +2601,11 @@ win_line(wp, lnum, startrow, endrow, noc
     int		fromcol, tocol;		/* start/end of inverting */
     int		fromcol_prev = -2;	/* start of inverting after cursor */
     int		noinvcur = FALSE;	/* don't invert the cursor */
 #ifdef FEAT_VISUAL
     pos_T	*top, *bot;
+    int		lnum_in_visual_area = FALSE;
 #endif
     pos_T	pos;
     long	v;
 
     int		char_attr = 0;		/* attributes for next character */
@@ -2782,13 +2798,14 @@ win_line(wp, lnum, startrow, endrow, noc
 	else				/* Visual is before curwin->w_cursor */
 	{
 	    top = &VIsual;
 	    bot = &curwin->w_cursor;
 	}
+	lnum_in_visual_area = (lnum >= top->lnum && lnum <= bot->lnum);
 	if (VIsual_mode == Ctrl_V)	/* block mode */
 	{
-	    if (lnum >= top->lnum && lnum <= bot->lnum)
+	    if (lnum_in_visual_area)
 	    {
 		fromcol = wp->w_old_cursor_fcol;
 		tocol = wp->w_old_cursor_lcol;
 	    }
 	}
@@ -2877,12 +2894,13 @@ win_line(wp, lnum, startrow, endrow, noc
 	    pos.col = search_match_endcol;
 	    getvcol(curwin, &pos, (colnr_T *)&tocol, NULL, NULL);
 	}
 	else
 	    tocol = MAXCOL;
-	if (fromcol == tocol)		/* do at least one character */
-	    tocol = fromcol + 1;	/* happens when past end of line */
+	/* do at least one character; happens when past end of line */
+	if (fromcol == tocol)
+	    tocol = fromcol + 1;
 	area_highlighting = TRUE;
 	attr = hl_attr(HLF_I);
     }
 
 #ifdef FEAT_DIFF
@@ -2997,15 +3015,37 @@ win_line(wp, lnum, startrow, endrow, noc
 	    prev_ptr = ptr;
 #endif
 	    mb_ptr_adv(ptr);
 	}
 
-#ifdef FEAT_VIRTUALEDIT
-	/* When 'virtualedit' is set the end of the line may be before the
-	 * start of the displayed part. */
-	if (vcol < v && *ptr == NUL && virtual_active())
+#if defined(FEAT_SYN_HL) || defined(FEAT_VIRTUALEDIT) || defined(FEAT_VISUAL)
+	/* When:
+	 * - 'cuc' is set, or
+	 * - 'virtualedit' is set, or
+	 * - the visual mode is active,
+	 * the end of the line may be before the start of the displayed part.
+	 */
+	if (vcol < v && (
+# ifdef FEAT_SYN_HL
+	     wp->w_p_cuc
+#  if defined(FEAT_VIRTUALEDIT) || defined(FEAT_VISUAL)
+	     ||
+#  endif
+# endif
+# ifdef FEAT_VIRTUALEDIT
+	     virtual_active()
+#  ifdef FEAT_VISUAL
+	     ||
+#  endif
+# endif
+# ifdef FEAT_VISUAL
+	     (VIsual_active && wp->w_buffer == curwin->w_buffer)
+# endif
+	     ))
+	{
 	    vcol = v;
+	}
 #endif
 
 	/* Handle a character that's not completely on the screen: Put ptr at
 	 * that character but skip the first few screen characters. */
 	if (vcol > v)
@@ -3410,10 +3450,11 @@ win_line(wp, lnum, startrow, endrow, noc
 #ifdef FEAT_MBYTE
 		    || (has_mbyte && vcol + 1 == fromcol && n_extra == 0
 			&& (*mb_ptr2cells)(ptr) > 1)
 #endif
 		    || ((int)vcol_prev == fromcol_prev
+			&& vcol_prev < vcol	/* not at margin */
 			&& vcol < tocol))
 		area_attr = attr;		/* start highlighting */
 	    else if (area_attr != 0
 		    && (vcol == tocol
 			|| (noinvcur && (colnr_T)vcol == wp->w_virtcol)))
@@ -3542,11 +3583,12 @@ win_line(wp, lnum, startrow, endrow, noc
 		char_attr = search_attr;
 #ifdef LINE_ATTR
 		/* Use line_attr when not in the Visual or 'incsearch' area
 		 * (area_attr may be 0 when "noinvcur" is set). */
 	    else if (line_attr != 0 && ((fromcol == -10 && tocol == MAXCOL)
-					|| (vcol < fromcol || vcol >= tocol)))
+				|| vcol < fromcol || vcol_prev < fromcol_prev
+				|| vcol >= tocol))
 		char_attr = line_attr;
 #endif
 	    else
 	    {
 		attr_pri = FALSE;
@@ -4104,10 +4146,11 @@ win_line(wp, lnum, startrow, endrow, noc
 # ifdef FEAT_RIGHTLEFT
 				    wp->w_p_rl ? (col >= 0) :
 # endif
 				    (col < W_WIDTH(wp)))
 				&& !(noinvcur
+				    && lnum == wp->w_cursor.lnum
 				    && (colnr_T)vcol == wp->w_virtcol)))
 			&& lcs_eol_one >= 0)
 		{
 		    /* Display a '$' after the line or highlight an extra
 		     * character if the line break is included. */
@@ -4245,20 +4288,20 @@ win_line(wp, lnum, startrow, endrow, noc
 #if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
 	/* XIM don't send preedit_start and preedit_end, but they send
 	 * preedit_changed and commit.  Thus Vim can't set "im_is_active", use
 	 * im_is_preediting() here. */
 	if (xic != NULL
-		&& lnum == curwin->w_cursor.lnum
+		&& lnum == wp->w_cursor.lnum
 		&& (State & INSERT)
 		&& !p_imdisable
 		&& im_is_preediting()
 		&& draw_state == WL_LINE)
 	{
 	    colnr_T tcol;
 
 	    if (preedit_end_col == MAXCOL)
-		getvcol(curwin, &(curwin->w_cursor), &tcol, NULL, NULL);
+		getvcol(curwin, &(wp->w_cursor), &tcol, NULL, NULL);
 	    else
 		tcol = preedit_end_col;
 	    if ((long)preedit_start_col <= vcol && vcol < (long)tcol)
 	    {
 		if (feedback_old_attr < 0)
@@ -4351,11 +4394,17 @@ win_line(wp, lnum, startrow, endrow, noc
 		    cur = cur->next;
 		}
 	    }
 #endif
 	    if (lcs_eol == lcs_eol_one
-		    && ((area_attr != 0 && vcol == fromcol && c == NUL)
+		    && ((area_attr != 0 && vcol == fromcol
+#ifdef FEAT_VISUAL
+			    && (VIsual_mode != Ctrl_V
+				|| lnum == VIsual.lnum
+				|| lnum == curwin->w_cursor.lnum)
+#endif
+			    && c == NUL)
 #ifdef FEAT_SEARCH_EXTRA
 			/* highlight 'hlsearch' match at end of line */
 			|| (prevcol_hl_flag == TRUE
 # if defined(LINE_ATTR)
 			    && did_line_attr <= 1
@@ -4445,11 +4494,12 @@ win_line(wp, lnum, startrow, endrow, noc
 	 * At end of the text line.
 	 */
 	if (c == NUL)
 	{
 #ifdef FEAT_SYN_HL
-	    if (eol_hl_off > 0 && vcol - eol_hl_off == (long)wp->w_virtcol)
+	    if (eol_hl_off > 0 && vcol - eol_hl_off == (long)wp->w_virtcol
+		    && lnum == wp->w_cursor.lnum)
 	    {
 		/* highlight last char after line */
 		--col;
 		--off;
 		--vcol;
@@ -4547,11 +4597,12 @@ win_line(wp, lnum, startrow, endrow, noc
 #ifdef FEAT_SYN_HL
 	/* Highlight the cursor column if 'cursorcolumn' is set.  But don't
 	 * highlight the cursor position itself. */
 	if (wp->w_p_cuc && vcol == (long)wp->w_virtcol
 		&& lnum != wp->w_cursor.lnum
-		&& draw_state == WL_LINE)
+		&& draw_state == WL_LINE
+		&& !lnum_in_visual_area)
 	{
 	    vcol_save_attr = char_attr;
 	    char_attr = hl_combine_attr(char_attr, hl_attr(HLF_CUC));
 	}
 	else
@@ -4577,11 +4628,15 @@ win_line(wp, lnum, startrow, endrow, noc
 	    }
 #endif
 	    ScreenLines[off] = c;
 #ifdef FEAT_MBYTE
 	    if (enc_dbcs == DBCS_JPNU)
+	    {
+		if ((mb_c & 0xff00) == 0x8e00)
+		    ScreenLines[off] = 0x8e;
 		ScreenLines2[off] = mb_c & 0xff;
+	    }
 	    else if (enc_utf8)
 	    {
 		if (mb_utf8)
 		{
 		    int i;
@@ -4650,11 +4705,11 @@ win_line(wp, lnum, startrow, endrow, noc
 	}
 	else
 	    --n_skip;
 
 	/* Only advance the "vcol" when after the 'number' column. */
-	if (draw_state >= WL_SBR
+	if (draw_state > WL_NR
 #ifdef FEAT_DIFF
 		&& filler_todo <= 0
 #endif
 		)
 	    ++vcol;
@@ -5117,12 +5172,12 @@ screen_line(row, coloff, endcol, clear_w
 	    if (char_cells == 2)
 		ScreenLines[off_to + 1] = ScreenLines[off_from + 1];
 #endif
 
 #if defined(FEAT_GUI) || defined(UNIX)
-	    /* The bold trick makes a single row of pixels appear in the next
-	     * character.  When a bold character is removed, the next
+	    /* The bold trick makes a single column of pixels appear in the
+	     * next character.  When a bold character is removed, the next
 	     * character should be redrawn too.  This happens for our own GUI
 	     * and for some xterms. */
 	    if (
 # ifdef FEAT_GUI
 		    gui.in_use
@@ -5721,10 +5776,17 @@ win_redr_status(wp)
     char_u	*p;
     int		len;
     int		fillchar;
     int		attr;
     int		this_ru_col;
+    static int  busy = FALSE;
+
+    /* It's possible to get here recursively when 'statusline' (indirectly)
+     * invokes ":redrawstatus".  Simply ignore the call then. */
+    if (busy)
+	return;
+    busy = TRUE;
 
     wp->w_redr_status = FALSE;
     if (wp->w_status_height == 0)
     {
 	/* no status line, can only be last window */
@@ -5743,11 +5805,11 @@ win_redr_status(wp)
     }
 #ifdef FEAT_STL_OPT
     else if (*p_stl != NUL || *wp->w_p_stl != NUL)
     {
 	/* redraw custom status line */
-	redraw_custum_statusline(wp);
+	redraw_custom_statusline(wp);
     }
 #endif
     else
     {
 	fillchar = fillchar_status(&attr, wp == curwin);
@@ -5859,30 +5921,44 @@ win_redr_status(wp)
 	    fillchar = fillchar_vsep(&attr);
 	screen_putchar(fillchar, W_WINROW(wp) + wp->w_height, W_ENDCOL(wp),
 									attr);
     }
 #endif
+    busy = FALSE;
 }
 
 #ifdef FEAT_STL_OPT
 /*
  * Redraw the status line according to 'statusline' and take care of any
  * errors encountered.
  */
     static void
-redraw_custum_statusline(wp)
+redraw_custom_statusline(wp)
     win_T	    *wp;
 {
-    int	save_called_emsg = called_emsg;
+    static int	    entered = FALSE;
+    int		    save_called_emsg = called_emsg;
+
+    /* When called recursively return.  This can happen when the statusline
+     * contains an expression that triggers a redraw. */
+    if (entered)
+	return;
+    entered = TRUE;
 
     called_emsg = FALSE;
     win_redr_custom(wp, FALSE);
     if (called_emsg)
+    {
+	/* When there is an error disable the statusline, otherwise the
+	 * display is messed up with errors and a redraw triggers the problem
+	 * again and again. */
 	set_string_option_direct((char_u *)"statusline", -1,
 		(char_u *)"", OPT_FREE | (*wp->w_p_stl != NUL
 					? OPT_LOCAL : OPT_GLOBAL), SID_ERROR);
+    }
     called_emsg |= save_called_emsg;
+    entered = FALSE;
 }
 #endif
 
 # ifdef FEAT_VERTSPLIT
 /*
@@ -5986,20 +6062,21 @@ win_redr_custom(wp, draw_ruler)
     int		width;
     int		n;
     int		len;
     int		fillchar;
     char_u	buf[MAXPATHL];
+    char_u	*stl;
     char_u	*p;
     struct	stl_hlrec hltab[STL_MAX_ITEM];
     struct	stl_hlrec tabtab[STL_MAX_ITEM];
     int		use_sandbox = FALSE;
 
     /* setup environment for the task at hand */
     if (wp == NULL)
     {
 	/* Use 'tabline'.  Always at the first line of the screen. */
-	p = p_tal;
+	stl = p_tal;
 	row = 0;
 	fillchar = ' ';
 	attr = hl_attr(HLF_TPF);
 	maxwidth = Columns;
 # ifdef FEAT_EVAL
@@ -6012,21 +6089,21 @@ win_redr_custom(wp, draw_ruler)
 	fillchar = fillchar_status(&attr, wp == curwin);
 	maxwidth = W_WIDTH(wp);
 
 	if (draw_ruler)
 	{
-	    p = p_ruf;
+	    stl = p_ruf;
 	    /* advance past any leading group spec - implicit in ru_col */
-	    if (*p == '%')
+	    if (*stl == '%')
 	    {
-		if (*++p == '-')
-		    p++;
-		if (atoi((char *) p))
-		    while (VIM_ISDIGIT(*p))
-			p++;
-		if (*p++ != '(')
-		    p = p_ruf;
+		if (*++stl == '-')
+		    stl++;
+		if (atoi((char *)stl))
+		    while (VIM_ISDIGIT(*stl))
+			stl++;
+		if (*stl++ != '(')
+		    stl = p_ruf;
 	    }
 #ifdef FEAT_VERTSPLIT
 	    col = ru_col - (Columns - W_WIDTH(wp));
 	    if (col < (W_WIDTH(wp) + 1) / 2)
 		col = (W_WIDTH(wp) + 1) / 2;
@@ -6051,13 +6128,13 @@ win_redr_custom(wp, draw_ruler)
 # endif
 	}
 	else
 	{
 	    if (*wp->w_p_stl != NUL)
-		p = wp->w_p_stl;
+		stl = wp->w_p_stl;
 	    else
-		p = p_stl;
+		stl = p_stl;
 # ifdef FEAT_EVAL
 	    use_sandbox = was_set_insecurely((char_u *)"statusline",
 					 *wp->w_p_stl == NUL ? 0 : OPT_LOCAL);
 # endif
 	}
@@ -6068,17 +6145,21 @@ win_redr_custom(wp, draw_ruler)
     }
 
     if (maxwidth <= 0)
 	return;
 
+    /* Make a copy, because the statusline may include a function call that
+     * might change the option value and free the memory. */
+    stl = vim_strsave(stl);
     width = build_stl_str_hl(wp == NULL ? curwin : wp,
 				buf, sizeof(buf),
-				p, use_sandbox,
+				stl, use_sandbox,
 				fillchar, maxwidth, hltab, tabtab);
+    vim_free(stl);
     len = (int)STRLEN(buf);
 
-    while (width < maxwidth && len < sizeof(buf) - 1)
+    while (width < maxwidth && len < (int)sizeof(buf) - 1)
     {
 #ifdef FEAT_MBYTE
 	len += (*mb_char2bytes)(fillchar, buf + len);
 #else
 	buf[len++] = fillchar;
@@ -6261,26 +6342,43 @@ screen_puts_len(text, len, row, col, att
     int		prev_c = 0;		/* previous Arabic character */
     int		pc, nc, nc1;
     int		pcc[MAX_MCO];
 # endif
 #endif
+#if defined(FEAT_MBYTE) || defined(FEAT_GUI) || defined(UNIX)
+    int		force_redraw_this;
+    int		force_redraw_next = FALSE;
+#endif
+    int		need_redraw;
 
     if (ScreenLines == NULL || row >= screen_Rows)	/* safety check */
 	return;
+    off = LineOffset[row] + col;
 
 #ifdef FEAT_MBYTE
     /* When drawing over the right halve of a double-wide char clear out the
      * left halve.  Only needed in a terminal. */
     if (has_mbyte && col > 0 && col < screen_Columns
 # ifdef FEAT_GUI
 	    && !gui.in_use
 # endif
 	    && mb_fix_col(col, row) != col)
-	screen_puts_len((char_u *)" ", 1, row, col - 1, 0);
+    {
+	ScreenLines[off - 1] = ' ';
+	ScreenAttrs[off - 1] = 0;
+	if (enc_utf8)
+	{
+	    ScreenLinesUC[off - 1] = 0;
+	    ScreenLinesC[0][off - 1] = 0;
+	}
+	/* redraw the previous cell, make it empty */
+	screen_char(off - 1, row, col - 1);
+	/* force the cell at "col" to be redrawn */
+	force_redraw_next = TRUE;
+    }
 #endif
 
-    off = LineOffset[row] + col;
 #ifdef FEAT_MBYTE
     max_off = LineOffset[row] + screen_Columns;
 #endif
     while (col < screen_Columns
 	    && (len < 0 || (int)(ptr - text) < len)
@@ -6326,76 +6424,80 @@ screen_puts_len(text, len, row, col, att
 			nc = NUL;
 			nc1 = NUL;
 		    }
 		    else
 		    {
-			nc = utfc_ptr2char(ptr + mbyte_blen, pcc);
+			nc = utfc_ptr2char_len(ptr + mbyte_blen, pcc,
+				      (int)((text + len) - ptr - mbyte_blen));
 			nc1 = pcc[0];
 		    }
 		    pc = prev_c;
 		    prev_c = u8c;
 		    u8c = arabic_shape(u8c, &c, &u8cc[0], nc, nc1, pc);
 		}
 		else
 		    prev_c = u8c;
 # endif
+		if (col + mbyte_cells > screen_Columns)
+		{
+		    /* Only 1 cell left, but character requires 2 cells:
+		     * display a '>' in the last column to avoid wrapping. */
+		    c = '>';
+		    mbyte_cells = 1;
+		}
 	    }
 	}
 #endif
 
-	if (ScreenLines[off] != c
+#if defined(FEAT_MBYTE) || defined(FEAT_GUI) || defined(UNIX)
+	force_redraw_this = force_redraw_next;
+	force_redraw_next = FALSE;
+#endif
+
+	need_redraw = ScreenLines[off] != c
 #ifdef FEAT_MBYTE
 		|| (mbyte_cells == 2
 		    && ScreenLines[off + 1] != (enc_dbcs ? ptr[1] : 0))
 		|| (enc_dbcs == DBCS_JPNU
 		    && c == 0x8e
 		    && ScreenLines2[off] != ptr[1])
 		|| (enc_utf8
-		    && (ScreenLinesUC[off] != (u8char_T)u8c
+		    && (ScreenLinesUC[off] != (u8char_T)(c >= 0x80 ? u8c : 0)
 			|| screen_comp_differs(off, u8cc)))
 #endif
 		|| ScreenAttrs[off] != attr
-		|| exmode_active
+		|| exmode_active;
+
+	if (need_redraw
+#if defined(FEAT_MBYTE) || defined(FEAT_GUI) || defined(UNIX)
+		|| force_redraw_this
+#endif
 		)
 	{
 #if defined(FEAT_GUI) || defined(UNIX)
 	    /* The bold trick makes a single row of pixels appear in the next
 	     * character.  When a bold character is removed, the next
 	     * character should be redrawn too.  This happens for our own GUI
-	     * and for some xterms.
-	     * Force the redraw by setting the attribute to a different value
-	     * than "attr", the contents of ScreenLines[] may be needed by
-	     * mb_off2cells() further on.
-	     * Don't do this for the last drawn character, because the next
-	     * character may not be redrawn. */
-	    if (
+	     * and for some xterms. */
+	    if (need_redraw && ScreenLines[off] != ' ' && (
 # ifdef FEAT_GUI
 		    gui.in_use
 # endif
 # if defined(FEAT_GUI) && defined(UNIX)
 		    ||
 # endif
 # ifdef UNIX
 		    term_is_xterm
 # endif
-	       )
+		    ))
 	    {
-		int		n;
+		int	n = ScreenAttrs[off];
 
-		n = ScreenAttrs[off];
-# ifdef FEAT_MBYTE
-		if (col + mbyte_cells < screen_Columns
-			&& (n > HL_ALL || (n & HL_BOLD))
-			&& (len < 0 ? ptr[mbyte_blen] != NUL
-					     : ptr + mbyte_blen < text + len))
-		    ScreenAttrs[off + mbyte_cells] = attr + 1;
-# else
-		if (col + 1 < screen_Columns
-			&& (n > HL_ALL || (n & HL_BOLD))
-			&& (len < 0 ? ptr[1] != NUL : ptr + 1 < text + len))
-		    ScreenLines[off + 1] = 0;
-# endif
+		if (n > HL_ALL)
+		    n = syn_attr2attr(n);
+		if (n & HL_BOLD)
+		    force_redraw_next = TRUE;
 	    }
 #endif
 #ifdef FEAT_MBYTE
 	    /* When at the end of the text and overwriting a two-cell
 	     * character with a one-cell character, need to clear the next
@@ -6478,10 +6580,24 @@ screen_puts_len(text, len, row, col, att
 	    ++off;
 	    ++col;
 	    ++ptr;
 	}
     }
+
+#if defined(FEAT_MBYTE) || defined(FEAT_GUI) || defined(UNIX)
+    /* If we detected the next character needs to be redrawn, but the text
+     * doesn't extend up to there, update the character here. */
+    if (force_redraw_next && col < screen_Columns)
+    {
+# ifdef FEAT_MBYTE
+	if (enc_dbcs != 0 && dbcs_off2cells(off, max_off) > 1)
+	    screen_char_2(off, row, col);
+	else
+# endif
+	    screen_char(off, row, col);
+    }
+#endif
 }
 
 #ifdef FEAT_SEARCH_EXTRA
 /*
  * Prepare for 'hlsearch' highlighting.
@@ -7354,11 +7470,15 @@ screenalloc(clear)
     short	    *new_TabPageIdxs;
     tabpage_T	    *tp;
 #endif
     static int	    entered = FALSE;		/* avoid recursiveness */
     static int	    done_outofmem_msg = FALSE;	/* did outofmem message */
+#ifdef FEAT_AUTOCMD
+    int		    retry_count = 0;
 
+retry:
+#endif
     /*
      * Allocation of the screen buffers is done only when the size changes and
      * when Rows and Columns have been set and we have started doing full
      * screen stuff.
      */
@@ -7406,10 +7526,14 @@ screenalloc(clear)
      * Continuing with the old ScreenLines may result in a crash, because the
      * size is wrong.
      */
     FOR_ALL_TAB_WINDOWS(tp, wp)
 	win_free_lsize(wp);
+#ifdef FEAT_AUTOCMD
+    if (aucmd_win != NULL)
+	win_free_lsize(aucmd_win);
+#endif
 
     new_ScreenLines = (schar_T *)lalloc((long_u)(
 			      (Rows + 1) * Columns * sizeof(schar_T)), FALSE);
 #ifdef FEAT_MBYTE
     vim_memset(new_ScreenLinesC, 0, sizeof(u8char_T) * MAX_MCO);
@@ -7438,14 +7562,22 @@ screenalloc(clear)
     {
 	if (win_alloc_lines(wp) == FAIL)
 	{
 	    outofmem = TRUE;
 #ifdef FEAT_WINDOWS
-	    break;
+	    goto give_up;
 #endif
 	}
     }
+#ifdef FEAT_AUTOCMD
+    if (aucmd_win != NULL && aucmd_win->w_lines == NULL
+					&& win_alloc_lines(aucmd_win) == FAIL)
+	outofmem = TRUE;
+#endif
+#ifdef FEAT_WINDOWS
+give_up:
+#endif
 
 #ifdef FEAT_MBYTE
     for (i = 0; i < p_mco; ++i)
 	if (new_ScreenLinesC[i] == NULL)
 	    break;
@@ -7626,12 +7758,21 @@ screenalloc(clear)
 
     entered = FALSE;
     --RedrawingDisabled;
 
 #ifdef FEAT_AUTOCMD
-    if (starting == 0)
+    /*
+     * Do not apply autocommands more than 3 times to avoid an endless loop
+     * in case applying autocommands always changes Rows or Columns.
+     */
+    if (starting == 0 && ++retry_count <= 3)
+    {
 	apply_autocmds(EVENT_VIMRESIZED, NULL, NULL, FALSE, curbuf);
+	/* In rare cases, autocommands may have altered Rows or Columns,
+	 * jump back to check if we need to allocate the screen again. */
+	goto retry;
+    }
 #endif
 }
 
     void
 free_screenlines()
@@ -8588,19 +8729,18 @@ screen_ins_lines(off, row, line_count, e
  * When scrolling region used 'off' is the offset from the top for the region.
  * 'row' and 'end' are relative to the start of the region.
  *
  * Return OK for success, FAIL if the lines are not deleted.
  */
-/*ARGSUSED*/
     int
 screen_del_lines(off, row, line_count, end, force, wp)
     int		off;
     int		row;
     int		line_count;
     int		end;
     int		force;		/* even when line_count > p_ttyscroll */
-    win_T	*wp;		/* NULL or window to use width from */
+    win_T	*wp UNUSED;	/* NULL or window to use width from */
 {
     int		j;
     int		i;
     unsigned	temp;
     int		cursor_row;
@@ -9078,11 +9218,11 @@ msg_pos_mode()
     void
 unshowmode(force)
     int	    force;
 {
     /*
-     * Don't delete it right now, when not redrawing or insided a mapping.
+     * Don't delete it right now, when not redrawing or inside a mapping.
      */
     if (!redrawing() || (!force && char_avail() && !KeyTyped))
 	redraw_cmdline = TRUE;		/* delete mode later */
     else
     {
@@ -9384,11 +9524,11 @@ showruler(always)
     }
 #endif
 #if defined(FEAT_STL_OPT) && defined(FEAT_WINDOWS)
     if ((*p_stl != NUL || *curwin->w_p_stl != NUL) && curwin->w_status_height)
     {
-	redraw_custum_statusline(curwin);
+	redraw_custom_statusline(curwin);
     }
     else
 #endif
 #ifdef FEAT_CMDL_INFO
 	win_redr_ruler(curwin, always);
@@ -9414,17 +9554,19 @@ showruler(always)
     static void
 win_redr_ruler(wp, always)
     win_T	*wp;
     int		always;
 {
-    char_u	buffer[70];
+#define RULER_BUF_LEN 70
+    char_u	buffer[RULER_BUF_LEN];
     int		row;
     int		fillchar;
     int		attr;
     int		empty_line = FALSE;
     colnr_T	virtcol;
     int		i;
+    size_t	len;
     int		o;
 #ifdef FEAT_VERTSPLIT
     int		this_ru_col;
     int		off = 0;
     int		width = Columns;
@@ -9535,25 +9677,26 @@ win_redr_ruler(wp, always)
 
 	/*
 	 * Some sprintfs return the length, some return a pointer.
 	 * To avoid portability problems we use strlen() here.
 	 */
-	sprintf((char *)buffer, "%ld,",
+	vim_snprintf((char *)buffer, RULER_BUF_LEN, "%ld,",
 		(wp->w_buffer->b_ml.ml_flags & ML_EMPTY)
 		    ? 0L
 		    : (long)(wp->w_cursor.lnum));
-	col_print(buffer + STRLEN(buffer),
+	len = STRLEN(buffer);
+	col_print(buffer + len, RULER_BUF_LEN - len,
 			empty_line ? 0 : (int)wp->w_cursor.col + 1,
 			(int)virtcol + 1);
 
 	/*
 	 * Add a "50%" if there is room for it.
 	 * On the last line, don't print in the last column (scrolls the
 	 * screen up on some terminals).
 	 */
 	i = (int)STRLEN(buffer);
-	get_rel_pos(wp, buffer + i + 1);
+	get_rel_pos(wp, buffer + i + 1, RULER_BUF_LEN - i - 1);
 	o = i + vim_strsize(buffer + i + 1);
 #ifdef FEAT_WINDOWS
 	if (wp->w_status_height == 0)	/* can't use last char of screen */
 #endif
 	    ++o;
@@ -9576,11 +9719,11 @@ win_redr_ruler(wp, always)
 		else
 #endif
 		    buffer[i++] = fillchar;
 		++o;
 	    }
-	    get_rel_pos(wp, buffer + i);
+	    get_rel_pos(wp, buffer + i, RULER_BUF_LEN - i);
 	}
 	/* Truncate at window boundary. */
 #ifdef FEAT_MBYTE
 	if (has_mbyte)
 	{
--- vim72.orig/src/option.c
+++ vim72/src/option.c
@@ -385,10 +385,13 @@ struct vimoption
     idopt_T	indir;		/* global option: PV_NONE;
 				 * local option: indirect option index */
     char_u	*def_val[2];	/* default values for variable (vi and vim) */
 #ifdef FEAT_EVAL
     scid_T	scriptID;	/* script in which the option was last set */
+# define SCRIPTID_INIT , 0
+#else
+# define SCRIPTID_INIT
 #endif
 };
 
 #define VI_DEFAULT  0	    /* def_val[VI_DEFAULT] is Vi default value */
 #define VIM_DEFAULT 1	    /* def_val[VIM_DEFAULT] is Vim default value */
@@ -398,12 +401,13 @@ struct vimoption
  */
 #define P_BOOL		0x01	/* the option is boolean */
 #define P_NUM		0x02	/* the option is numeric */
 #define P_STRING	0x04	/* the option is a string */
 #define P_ALLOCED	0x08	/* the string option is in allocated memory,
-				    must use vim_free() when assigning new
-				    value. Not set if default is the same. */
+				   must use free_string_option() when
+				   assigning new value. Not set if default is
+				   the same. */
 #define P_EXPAND	0x10	/* environment expansion.  NOTE: P_EXPAND can
 				   never be used for local or hidden options! */
 #define P_NODEFAULT	0x40	/* don't set to default value */
 #define P_DEF_ALLOCED	0x80	/* default value is in allocated memory, must
 				    use vim_free() when assigning new value */
@@ -475,263 +479,263 @@ static struct vimoption
 #if (defined(MSDOS) || defined(WIN3264) || defined(OS2)) && !defined(FEAT_GUI_W32)
 			    (char_u *)128L,
 #else
 			    (char_u *)224L,
 #endif
-					    (char_u *)0L}},
+					    (char_u *)0L} SCRIPTID_INIT},
     {"antialias",   "anti", P_BOOL|P_VI_DEF|P_VIM|P_RCLR,
 #if defined(FEAT_GUI) && defined(MACOS_X)
 			    (char_u *)&p_antialias, PV_NONE,
 			    {(char_u *)FALSE, (char_u *)FALSE}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)FALSE, (char_u *)FALSE}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"arabic",	    "arab", P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_ARABIC
 			    (char_u *)VAR_WIN, PV_ARAB,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"arabicshape", "arshape", P_BOOL|P_VI_DEF|P_VIM|P_RCLR,
 #ifdef FEAT_ARABIC
 			    (char_u *)&p_arshape, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"allowrevins", "ari",  P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_RIGHTLEFT
 			    (char_u *)&p_ari, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"altkeymap",   "akm",  P_BOOL|P_VI_DEF,
 #ifdef FEAT_FKMAP
 			    (char_u *)&p_altkeymap, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"ambiwidth",  "ambw",  P_STRING|P_VI_DEF|P_RCLR,
 #if defined(FEAT_MBYTE)
 			    (char_u *)&p_ambw, PV_NONE,
 			    {(char_u *)"single", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
 #ifdef FEAT_AUTOCHDIR
     {"autochdir",  "acd",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_acd, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
 #endif
     {"autoindent",  "ai",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_ai, PV_AI,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"autoprint",   "ap",   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"autoread",    "ar",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_ar, PV_AR,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"autowrite",   "aw",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_aw, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"autowriteall","awa",  P_BOOL|P_VI_DEF,
 			    (char_u *)&p_awa, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"background",  "bg",   P_STRING|P_VI_DEF|P_RCLR,
 			    (char_u *)&p_bg, PV_NONE,
 			    {
 #if (defined(MSDOS) || defined(OS2) || defined(WIN3264)) && !defined(FEAT_GUI)
 			    (char_u *)"dark",
 #else
 			    (char_u *)"light",
 #endif
-					    (char_u *)0L}},
+					    (char_u *)0L} SCRIPTID_INIT},
     {"backspace",   "bs",   P_STRING|P_VI_DEF|P_VIM|P_COMMA|P_NODUP,
 			    (char_u *)&p_bs, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"backup",	    "bk",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_bk, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"backupcopy",  "bkc",  P_STRING|P_VIM|P_COMMA|P_NODUP,
 			    (char_u *)&p_bkc, PV_NONE,
 #ifdef UNIX
 			    {(char_u *)"yes", (char_u *)"auto"}
 #else
 			    {(char_u *)"auto", (char_u *)"auto"}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"backupdir",   "bdir", P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP|P_SECURE,
 			    (char_u *)&p_bdir, PV_NONE,
-			    {(char_u *)DFLT_BDIR, (char_u *)0L}},
+			    {(char_u *)DFLT_BDIR, (char_u *)0L} SCRIPTID_INIT},
     {"backupext",   "bex",  P_STRING|P_VI_DEF|P_NFNAME,
 			    (char_u *)&p_bex, PV_NONE,
 			    {
 #ifdef VMS
 			    (char_u *)"_",
 #else
 			    (char_u *)"~",
 #endif
-					    (char_u *)0L}},
+					    (char_u *)0L} SCRIPTID_INIT},
     {"backupskip",  "bsk",  P_STRING|P_VI_DEF|P_COMMA,
 #ifdef FEAT_WILDIGN
 			    (char_u *)&p_bsk, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
 #ifdef FEAT_BEVAL
     {"balloondelay","bdlay",P_NUM|P_VI_DEF,
 			    (char_u *)&p_bdlay, PV_NONE,
-			    {(char_u *)600L, (char_u *)0L}},
+			    {(char_u *)600L, (char_u *)0L} SCRIPTID_INIT},
     {"ballooneval", "beval",P_BOOL|P_VI_DEF|P_NO_MKRC,
 			    (char_u *)&p_beval, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
 # ifdef FEAT_EVAL
     {"balloonexpr", "bexpr", P_STRING|P_ALLOCED|P_VI_DEF|P_VIM,
 			    (char_u *)&p_bexpr, PV_BEXPR,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
 # endif
 #endif
     {"beautify",    "bf",   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"binary",	    "bin",  P_BOOL|P_VI_DEF|P_RSTAT,
 			    (char_u *)&p_bin, PV_BIN,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"bioskey",	    "biosk",P_BOOL|P_VI_DEF,
 #ifdef MSDOS
 			    (char_u *)&p_biosk, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"bomb",	    NULL,   P_BOOL|P_NO_MKRC|P_VI_DEF|P_RSTAT,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_bomb, PV_BOMB,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"breakat",	    "brk",  P_STRING|P_VI_DEF|P_RALL|P_FLAGLIST,
 #ifdef FEAT_LINEBREAK
 			    (char_u *)&p_breakat, PV_NONE,
 			    {(char_u *)" \t!@*-+;:,./?", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"browsedir",   "bsdir",P_STRING|P_VI_DEF,
 #ifdef FEAT_BROWSE
 			    (char_u *)&p_bsdir, PV_NONE,
 			    {(char_u *)"last", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"bufhidden",   "bh",   P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB,
 #if defined(FEAT_QUICKFIX)
 			    (char_u *)&p_bh, PV_BH,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"buflisted",   "bl",   P_BOOL|P_VI_DEF|P_NOGLOB,
 			    (char_u *)&p_bl, PV_BL,
 			    {(char_u *)1L, (char_u *)0L}
-			    },
+			    SCRIPTID_INIT},
     {"buftype",	    "bt",   P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB,
 #if defined(FEAT_QUICKFIX)
 			    (char_u *)&p_bt, PV_BT,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"casemap",	    "cmp",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_cmp, PV_NONE,
 			    {(char_u *)"internal,keepascii", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"cdpath",	    "cd",   P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_SEARCHPATH
 			    (char_u *)&p_cdpath, PV_NONE,
 			    {(char_u *)",,", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"cedit",	    NULL,   P_STRING,
 #ifdef FEAT_CMDWIN
 			    (char_u *)&p_cedit, PV_NONE,
 			    {(char_u *)"", (char_u *)CTRL_F_STR}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"charconvert",  "ccv", P_STRING|P_VI_DEF|P_SECURE,
 #if defined(FEAT_MBYTE) && defined(FEAT_EVAL)
 			    (char_u *)&p_ccv, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"cindent",	    "cin",  P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_CINDENT
 			    (char_u *)&p_cin, PV_CIN,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"cinkeys",	    "cink", P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_CINDENT
 			    (char_u *)&p_cink, PV_CINK,
 			    {(char_u *)"0{,0},0),:,0#,!^F,o,O,e", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"cinoptions",  "cino", P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_CINDENT
 			    (char_u *)&p_cino, PV_CINO,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"cinwords",    "cinw", P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 #if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)
 			    (char_u *)&p_cinw, PV_CINW,
 			    {(char_u *)"if,else,while,do,for,switch",
 				(char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"clipboard",   "cb",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_CLIPBOARD
 			    (char_u *)&p_cb, PV_NONE,
 # ifdef FEAT_XCLIPBOARD
 			    {(char_u *)"autoselect,exclude:cons\\|linux",
@@ -741,435 +745,440 @@ static struct vimoption
 # endif
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"cmdheight",   "ch",   P_NUM|P_VI_DEF|P_RALL,
 			    (char_u *)&p_ch, PV_NONE,
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"cmdwinheight", "cwh", P_NUM|P_VI_DEF,
 #ifdef FEAT_CMDWIN
 			    (char_u *)&p_cwh, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)7L, (char_u *)0L}},
+			    {(char_u *)7L, (char_u *)0L} SCRIPTID_INIT},
     {"columns",	    "co",   P_NUM|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RCLR,
 			    (char_u *)&Columns, PV_NONE,
-			    {(char_u *)80L, (char_u *)0L}},
+			    {(char_u *)80L, (char_u *)0L} SCRIPTID_INIT},
     {"comments",    "com",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_COMMENTS
 			    (char_u *)&p_com, PV_COM,
 			    {(char_u *)"s1:/*,mb:*,ex:*/,://,b:#,:%,:XCOMM,n:>,fb:-",
 				(char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"commentstring", "cms", P_STRING|P_ALLOCED|P_VI_DEF,
 #ifdef FEAT_FOLDING
 			    (char_u *)&p_cms, PV_CMS,
 			    {(char_u *)"/*%s*/", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
 			    /* P_PRI_MKRC isn't needed here, optval_default()
 			     * always returns TRUE for 'compatible' */
     {"compatible",  "cp",   P_BOOL|P_RALL,
 			    (char_u *)&p_cp, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)FALSE}},
+			    {(char_u *)TRUE, (char_u *)FALSE} SCRIPTID_INIT},
     {"complete",    "cpt",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_INS_EXPAND
 			    (char_u *)&p_cpt, PV_CPT,
 			    {(char_u *)".,w,b,u,t,i", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"completefunc", "cfu", P_STRING|P_ALLOCED|P_VI_DEF|P_SECURE,
 #ifdef FEAT_COMPL_FUNC
 			    (char_u *)&p_cfu, PV_CFU,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"completeopt",   "cot",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_INS_EXPAND
 			    (char_u *)&p_cot, PV_NONE,
 			    {(char_u *)"menu,preview", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"confirm",     "cf",   P_BOOL|P_VI_DEF,
 #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
 			    (char_u *)&p_confirm, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"conskey",	    "consk",P_BOOL|P_VI_DEF,
 #ifdef MSDOS
 			    (char_u *)&p_consk, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"copyindent",  "ci",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_ci, PV_CI,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"cpoptions",   "cpo",  P_STRING|P_VIM|P_RALL|P_FLAGLIST,
 			    (char_u *)&p_cpo, PV_NONE,
-			    {(char_u *)CPO_VI, (char_u *)CPO_VIM}},
+			    {(char_u *)CPO_VI, (char_u *)CPO_VIM}
+			    SCRIPTID_INIT},
     {"cscopepathcomp", "cspc", P_NUM|P_VI_DEF|P_VIM,
 #ifdef FEAT_CSCOPE
 			    (char_u *)&p_cspc, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"cscopeprg",   "csprg", P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 #ifdef FEAT_CSCOPE
 			    (char_u *)&p_csprg, PV_NONE,
 			    {(char_u *)"cscope", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"cscopequickfix", "csqf", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #if defined(FEAT_CSCOPE) && defined(FEAT_QUICKFIX)
 			    (char_u *)&p_csqf, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"cscopetag",   "cst",  P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_CSCOPE
 			    (char_u *)&p_cst, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"cscopetagorder", "csto", P_NUM|P_VI_DEF|P_VIM,
 #ifdef FEAT_CSCOPE
 			    (char_u *)&p_csto, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"cscopeverbose", "csverb", P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_CSCOPE
 			    (char_u *)&p_csverbose, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"cursorcolumn", "cuc", P_BOOL|P_VI_DEF|P_RWIN,
 #ifdef FEAT_SYN_HL
 			    (char_u *)VAR_WIN, PV_CUC,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"cursorline",   "cul", P_BOOL|P_VI_DEF|P_RWIN,
 #ifdef FEAT_SYN_HL
 			    (char_u *)VAR_WIN, PV_CUL,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"debug",	    NULL,   P_STRING|P_VI_DEF,
 			    (char_u *)&p_debug, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"define",	    "def",  P_STRING|P_ALLOCED|P_VI_DEF,
 #ifdef FEAT_FIND_ID
 			    (char_u *)&p_def, PV_DEF,
 			    {(char_u *)"^\\s*#\\s*define", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"delcombine", "deco",  P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_deco, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"dictionary",  "dict", P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_INS_EXPAND
 			    (char_u *)&p_dict, PV_DICT,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"diff",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN|P_NOGLOB,
 #ifdef FEAT_DIFF
 			    (char_u *)VAR_WIN, PV_DIFF,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"diffexpr",    "dex",  P_STRING|P_VI_DEF|P_SECURE,
 #if defined(FEAT_DIFF) && defined(FEAT_EVAL)
 			    (char_u *)&p_dex, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"diffopt",	    "dip",  P_STRING|P_ALLOCED|P_VI_DEF|P_RWIN|P_COMMA|P_NODUP,
 #ifdef FEAT_DIFF
 			    (char_u *)&p_dip, PV_NONE,
 			    {(char_u *)"filler", (char_u *)NULL}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)"", (char_u *)NULL}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"digraph",	    "dg",   P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_DIGRAPHS
 			    (char_u *)&p_dg, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"directory",   "dir",  P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP|P_SECURE,
 			    (char_u *)&p_dir, PV_NONE,
-			    {(char_u *)DFLT_DIR, (char_u *)0L}},
+			    {(char_u *)DFLT_DIR, (char_u *)0L} SCRIPTID_INIT},
     {"display",	    "dy",   P_STRING|P_VI_DEF|P_COMMA|P_RALL|P_NODUP,
 			    (char_u *)&p_dy, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"eadirection", "ead",  P_STRING|P_VI_DEF,
 #ifdef FEAT_VERTSPLIT
 			    (char_u *)&p_ead, PV_NONE,
 			    {(char_u *)"both", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"edcompatible","ed",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_ed, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"encoding",    "enc",  P_STRING|P_VI_DEF|P_RCLR,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_enc, PV_NONE,
 			    {(char_u *)ENC_DFLT, (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"endofline",   "eol",  P_BOOL|P_NO_MKRC|P_VI_DEF|P_RSTAT,
 			    (char_u *)&p_eol, PV_EOL,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"equalalways", "ea",   P_BOOL|P_VI_DEF|P_RALL,
 			    (char_u *)&p_ea, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"equalprg",    "ep",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_ep, PV_EP,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"errorbells",  "eb",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_eb, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"errorfile",   "ef",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 #ifdef FEAT_QUICKFIX
 			    (char_u *)&p_ef, PV_NONE,
 			    {(char_u *)DFLT_ERRORFILE, (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"errorformat", "efm",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_QUICKFIX
 			    (char_u *)&p_efm, PV_EFM,
-			    {(char_u *)DFLT_EFM, (char_u *)0L},
+			    {(char_u *)DFLT_EFM, (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"esckeys",	    "ek",   P_BOOL|P_VIM,
 			    (char_u *)&p_ek, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
+			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
     {"eventignore", "ei",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_AUTOCMD
 			    (char_u *)&p_ei, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"expandtab",   "et",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_et, PV_ET,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"exrc",	    "ex",   P_BOOL|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_exrc, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"fileencoding","fenc", P_STRING|P_ALLOCED|P_VI_DEF|P_RSTAT|P_RBUF|P_NO_MKRC,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_fenc, PV_FENC,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"fileencodings","fencs", P_STRING|P_VI_DEF|P_COMMA,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_fencs, PV_NONE,
 			    {(char_u *)"ucs-bom", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"fileformat",  "ff",   P_STRING|P_ALLOCED|P_VI_DEF|P_RSTAT|P_NO_MKRC,
 			    (char_u *)&p_ff, PV_FF,
-			    {(char_u *)DFLT_FF, (char_u *)0L}},
+			    {(char_u *)DFLT_FF, (char_u *)0L} SCRIPTID_INIT},
     {"fileformats", "ffs",  P_STRING|P_VIM|P_COMMA|P_NODUP,
 			    (char_u *)&p_ffs, PV_NONE,
-			    {(char_u *)DFLT_FFS_VI, (char_u *)DFLT_FFS_VIM}},
+			    {(char_u *)DFLT_FFS_VI, (char_u *)DFLT_FFS_VIM}
+			    SCRIPTID_INIT},
     {"filetype",    "ft",   P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB|P_NFNAME,
 #ifdef FEAT_AUTOCMD
 			    (char_u *)&p_ft, PV_FT,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"fillchars",   "fcs",  P_STRING|P_VI_DEF|P_RALL|P_COMMA|P_NODUP,
 #if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
 			    (char_u *)&p_fcs, PV_NONE,
 			    {(char_u *)"vert:|,fold:-", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"fkmap",	    "fk",   P_BOOL|P_VI_DEF,
 #ifdef FEAT_FKMAP
 			    (char_u *)&p_fkmap, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"flash",	    "fl",   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
 #ifdef FEAT_FOLDING
     {"foldclose",   "fcl",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP|P_RWIN,
 			    (char_u *)&p_fcl, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"foldcolumn",  "fdc",  P_NUM|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_FDC,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"foldenable",  "fen",  P_BOOL|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_FEN,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"foldexpr",    "fde",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
 # ifdef FEAT_EVAL
 			    (char_u *)VAR_WIN, PV_FDE,
 			    {(char_u *)"0", (char_u *)NULL}
 # else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 # endif
-			    },
+			    SCRIPTID_INIT},
     {"foldignore",  "fdi",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_FDI,
-			    {(char_u *)"#", (char_u *)NULL}},
+			    {(char_u *)"#", (char_u *)NULL} SCRIPTID_INIT},
     {"foldlevel",   "fdl",  P_NUM|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_FDL,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"foldlevelstart","fdls", P_NUM|P_VI_DEF,
 			    (char_u *)&p_fdls, PV_NONE,
-			    {(char_u *)-1L, (char_u *)0L}},
+			    {(char_u *)-1L, (char_u *)0L} SCRIPTID_INIT},
     {"foldmarker",  "fmr",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|
 						       P_RWIN|P_COMMA|P_NODUP,
 			    (char_u *)VAR_WIN, PV_FMR,
-			    {(char_u *)"{{{,}}}", (char_u *)NULL}},
+			    {(char_u *)"{{{,}}}", (char_u *)NULL}
+			    SCRIPTID_INIT},
     {"foldmethod",  "fdm",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_FDM,
-			    {(char_u *)"manual", (char_u *)NULL}},
+			    {(char_u *)"manual", (char_u *)NULL} SCRIPTID_INIT},
     {"foldminlines","fml",  P_NUM|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_FML,
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"foldnestmax", "fdn",  P_NUM|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_FDN,
-			    {(char_u *)20L, (char_u *)0L}},
+			    {(char_u *)20L, (char_u *)0L} SCRIPTID_INIT},
     {"foldopen",    "fdo",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_fdo, PV_NONE,
 		 {(char_u *)"block,hor,mark,percent,quickfix,search,tag,undo",
-							       (char_u *)0L}},
+						 (char_u *)0L} SCRIPTID_INIT},
     {"foldtext",    "fdt",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
 # ifdef FEAT_EVAL
 			    (char_u *)VAR_WIN, PV_FDT,
 			    {(char_u *)"foldtext()", (char_u *)NULL}
 # else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 # endif
-			    },
+			    SCRIPTID_INIT},
 #endif
     {"formatexpr", "fex",   P_STRING|P_ALLOCED|P_VI_DEF|P_VIM,
 #ifdef FEAT_EVAL
 			    (char_u *)&p_fex, PV_FEX,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"formatoptions","fo",  P_STRING|P_ALLOCED|P_VIM|P_FLAGLIST,
 			    (char_u *)&p_fo, PV_FO,
-			    {(char_u *)DFLT_FO_VI, (char_u *)DFLT_FO_VIM}},
+			    {(char_u *)DFLT_FO_VI, (char_u *)DFLT_FO_VIM}
+			    SCRIPTID_INIT},
     {"formatlistpat","flp", P_STRING|P_ALLOCED|P_VI_DEF,
 			    (char_u *)&p_flp, PV_FLP,
-			    {(char_u *)"^\\s*\\d\\+[\\]:.)}\\t ]\\s*", (char_u *)0L}},
+			    {(char_u *)"^\\s*\\d\\+[\\]:.)}\\t ]\\s*",
+						 (char_u *)0L} SCRIPTID_INIT},
     {"formatprg",   "fp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_fp, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"fsync",       "fs",   P_BOOL|P_SECURE|P_VI_DEF,
 #ifdef HAVE_FSYNC
 			    (char_u *)&p_fs, PV_NONE,
 			    {(char_u *)TRUE, (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)FALSE, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"gdefault",    "gd",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_gd, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"graphic",	    "gr",   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"grepformat",  "gfm",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_QUICKFIX
 			    (char_u *)&p_gefm, PV_NONE,
-			    {(char_u *)DFLT_GREPFORMAT, (char_u *)0L},
+			    {(char_u *)DFLT_GREPFORMAT, (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"grepprg",	    "gp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 #ifdef FEAT_QUICKFIX
 			    (char_u *)&p_gp, PV_GP,
 			    {
 # ifdef WIN3264
@@ -1183,19 +1192,19 @@ static struct vimoption
 #  else
 #   ifdef VMS
 			    (char_u *)"SEARCH/NUMBERS ",
 #   else
 			    (char_u *)"grep -n ",
-#endif
-#endif
+#   endif
+#  endif
 # endif
-			    (char_u *)0L},
+			    (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"guicursor",    "gcr",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef CURSOR_SHAPE
 			    (char_u *)&p_guicursor, PV_NONE,
 			    {
 # ifdef FEAT_GUI
@@ -1206,45 +1215,45 @@ static struct vimoption
 				    (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-				    },
+			    SCRIPTID_INIT},
     {"guifont",	    "gfn",  P_STRING|P_VI_DEF|P_RCLR|P_COMMA|P_NODUP,
 #ifdef FEAT_GUI
 			    (char_u *)&p_guifont, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-				    },
+			    SCRIPTID_INIT},
     {"guifontset",  "gfs",  P_STRING|P_VI_DEF|P_RCLR|P_COMMA,
 #if defined(FEAT_GUI) && defined(FEAT_XFONTSET)
 			    (char_u *)&p_guifontset, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-				    },
+			    SCRIPTID_INIT},
     {"guifontwide", "gfw",  P_STRING|P_VI_DEF|P_RCLR|P_COMMA|P_NODUP,
 #if defined(FEAT_GUI) && defined(FEAT_MBYTE)
 			    (char_u *)&p_guifontwide, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-				    },
+			    SCRIPTID_INIT},
     {"guiheadroom", "ghr",  P_NUM|P_VI_DEF,
 #if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)
 			    (char_u *)&p_ghr, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)50L, (char_u *)0L}},
+			    {(char_u *)50L, (char_u *)0L} SCRIPTID_INIT},
     {"guioptions",  "go",   P_STRING|P_VI_DEF|P_RALL|P_FLAGLIST,
 #if defined(FEAT_GUI)
 			    (char_u *)&p_go, PV_NONE,
 # if defined(UNIX) && !defined(MACOS)
 			    {(char_u *)"aegimrLtT", (char_u *)0L}
@@ -1253,115 +1262,117 @@ static struct vimoption
 # endif
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-				    },
+			    SCRIPTID_INIT},
     {"guipty",	    NULL,   P_BOOL|P_VI_DEF,
 #if defined(FEAT_GUI)
 			    (char_u *)&p_guipty, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"guitablabel",  "gtl", P_STRING|P_VI_DEF|P_RWIN,
 #if defined(FEAT_GUI_TABLINE)
 			    (char_u *)&p_gtl, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-				    },
+			    SCRIPTID_INIT},
     {"guitabtooltip",  "gtt", P_STRING|P_VI_DEF|P_RWIN,
 #if defined(FEAT_GUI_TABLINE)
 			    (char_u *)&p_gtt, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-				    },
+			    SCRIPTID_INIT},
     {"hardtabs",    "ht",   P_NUM|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"helpfile",    "hf",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_hf, PV_NONE,
-			    {(char_u *)DFLT_HELPFILE, (char_u *)0L}},
+			    {(char_u *)DFLT_HELPFILE, (char_u *)0L}
+			    SCRIPTID_INIT},
     {"helpheight",  "hh",   P_NUM|P_VI_DEF,
 #ifdef FEAT_WINDOWS
 			    (char_u *)&p_hh, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)20L, (char_u *)0L}},
+			    {(char_u *)20L, (char_u *)0L} SCRIPTID_INIT},
     {"helplang",    "hlg",  P_STRING|P_VI_DEF|P_COMMA,
 #ifdef FEAT_MULTI_LANG
 			    (char_u *)&p_hlg, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-    },
+			    SCRIPTID_INIT},
     {"hidden",	    "hid",  P_BOOL|P_VI_DEF,
 			    (char_u *)&p_hid, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"highlight",   "hl",   P_STRING|P_VI_DEF|P_RCLR|P_COMMA|P_NODUP,
 			    (char_u *)&p_hl, PV_NONE,
-			    {(char_u *)HIGHLIGHT_INIT, (char_u *)0L}},
+			    {(char_u *)HIGHLIGHT_INIT, (char_u *)0L}
+			    SCRIPTID_INIT},
     {"history",	    "hi",   P_NUM|P_VIM,
 			    (char_u *)&p_hi, PV_NONE,
-			    {(char_u *)0L, (char_u *)20L}},
+			    {(char_u *)0L, (char_u *)20L} SCRIPTID_INIT},
     {"hkmap",	    "hk",   P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_RIGHTLEFT
 			    (char_u *)&p_hkmap, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"hkmapp",	    "hkp",  P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_RIGHTLEFT
 			    (char_u *)&p_hkmapp, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"hlsearch",    "hls",  P_BOOL|P_VI_DEF|P_VIM|P_RALL,
 			    (char_u *)&p_hls, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"icon",	    NULL,   P_BOOL|P_VI_DEF,
 #ifdef FEAT_TITLE
 			    (char_u *)&p_icon, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"iconstring",  NULL,   P_STRING|P_VI_DEF,
 #ifdef FEAT_TITLE
 			    (char_u *)&p_iconstring, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"ignorecase",  "ic",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_ic, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"imactivatekey","imak",P_STRING|P_VI_DEF,
 #if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
 			    (char_u *)&p_imak, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"imcmdline",   "imc",  P_BOOL|P_VI_DEF,
 #ifdef USE_IM_CONTROL
 			    (char_u *)&p_imcmdline, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"imdisable",   "imd",  P_BOOL|P_VI_DEF,
 #ifdef USE_IM_CONTROL
 			    (char_u *)&p_imdisable, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
@@ -1369,72 +1380,72 @@ static struct vimoption
 #ifdef __sgi
 			    {(char_u *)TRUE, (char_u *)0L}
 #else
 			    {(char_u *)FALSE, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"iminsert",    "imi",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_iminsert, PV_IMI,
 #ifdef B_IMODE_IM
 			    {(char_u *)B_IMODE_IM, (char_u *)0L}
 #else
 			    {(char_u *)B_IMODE_NONE, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"imsearch",    "ims",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_imsearch, PV_IMS,
 #ifdef B_IMODE_IM
 			    {(char_u *)B_IMODE_IM, (char_u *)0L}
 #else
 			    {(char_u *)B_IMODE_NONE, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"include",	    "inc",  P_STRING|P_ALLOCED|P_VI_DEF,
 #ifdef FEAT_FIND_ID
 			    (char_u *)&p_inc, PV_INC,
 			    {(char_u *)"^\\s*#\\s*include", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"includeexpr", "inex", P_STRING|P_ALLOCED|P_VI_DEF,
 #if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)
 			    (char_u *)&p_inex, PV_INEX,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"incsearch",   "is",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_is, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"indentexpr", "inde",  P_STRING|P_ALLOCED|P_VI_DEF|P_VIM,
 #if defined(FEAT_CINDENT) && defined(FEAT_EVAL)
 			    (char_u *)&p_inde, PV_INDE,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"indentkeys", "indk",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 #if defined(FEAT_CINDENT) && defined(FEAT_EVAL)
 			    (char_u *)&p_indk, PV_INDK,
 			    {(char_u *)"0{,0},:,0#,!^F,o,O,e", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"infercase",   "inf",  P_BOOL|P_VI_DEF,
 			    (char_u *)&p_inf, PV_INF,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"insertmode",  "im",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_im, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"isfname",	    "isf",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_isf, PV_NONE,
 			    {
 #ifdef BACKSLASH_IN_FILENAME
 				/* Excluded are: & and ^ are special in cmd.exe
@@ -1453,11 +1464,11 @@ static struct vimoption
 			    (char_u *)"@,48-57,/,.,-,_,+,,,#,$,%,~,=",
 #   endif
 #  endif
 # endif
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"isident",	    "isi",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_isi, PV_NONE,
 			    {
 #if defined(MSDOS) || defined(MSWIN) || defined(OS2)
 			    (char_u *)"@,48-57,_,128-167,224-235",
@@ -1470,11 +1481,11 @@ static struct vimoption
 				    "251-254",
 # else
 			    (char_u *)"@,48-57,_,192-255",
 # endif
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"iskeyword",   "isk",  P_STRING|P_ALLOCED|P_VIM|P_COMMA|P_NODUP,
 			    (char_u *)&p_isk, PV_ISK,
 			    {
 #ifdef EBCDIC
 			     (char_u *)"@,240-249,_",
@@ -1489,11 +1500,11 @@ static struct vimoption
 				(char_u *)"@,48-57,_,128-167,224-235"
 # else
 				ISK_LATIN1
 # endif
 #endif
-				}},
+			    } SCRIPTID_INIT},
     {"isprint",	    "isp",  P_STRING|P_VI_DEF|P_RALL|P_COMMA|P_NODUP,
 			    (char_u *)&p_isp, PV_NONE,
 			    {
 #if defined(MSDOS) || defined(MSWIN) || defined(OS2) \
 		|| (defined(MACOS) && !defined(MACOS_X)) \
@@ -1505,39 +1516,39 @@ static struct vimoption
 			    (char_u *)"63-255",
 # else
 			    ISP_LATIN1,
 # endif
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"joinspaces",  "js",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_js, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"key",	    NULL,   P_STRING|P_ALLOCED|P_VI_DEF|P_NO_MKRC,
 #ifdef FEAT_CRYPT
 			    (char_u *)&p_key, PV_KEY,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"keymap",	    "kmp",  P_STRING|P_ALLOCED|P_VI_DEF|P_RBUF|P_RSTAT|P_NFNAME|P_PRI_MKRC,
 #ifdef FEAT_KEYMAP
 			    (char_u *)&p_keymap, PV_KMAP,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #endif
-	},
+			    SCRIPTID_INIT},
     {"keymodel",    "km",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_VISUAL
 			    (char_u *)&p_km, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"keywordprg",  "kp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_kp, PV_KP,
 			    {
 #if defined(MSDOS) || defined(MSWIN)
 			    (char_u *)":help",
@@ -1554,53 +1565,53 @@ static struct vimoption
 			    (char_u *)"man",
 #  endif
 # endif
 #endif
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"langmap",     "lmap", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_LANGMAP
 			    (char_u *)&p_langmap, PV_NONE,
 			    {(char_u *)"",	/* unmatched } */
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL,
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"langmenu",    "lm",   P_STRING|P_VI_DEF|P_NFNAME,
 #if defined(FEAT_MENU) && defined(FEAT_MULTI_LANG)
 			    (char_u *)&p_lm, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"laststatus",  "ls",   P_NUM|P_VI_DEF|P_RALL,
 #ifdef FEAT_WINDOWS
 			    (char_u *)&p_ls, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"lazyredraw",  "lz",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_lz, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"linebreak",   "lbr",  P_BOOL|P_VI_DEF|P_RWIN,
 #ifdef FEAT_LINEBREAK
 			    (char_u *)VAR_WIN, PV_LBR,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"lines",	    NULL,   P_NUM|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RCLR,
 			    (char_u *)&Rows, PV_NONE,
 			    {
 #if defined(MSDOS) || defined(WIN3264) || defined(OS2)
 			    (char_u *)25L,
 #else
 			    (char_u *)24L,
 #endif
-					    (char_u *)0L}},
+					    (char_u *)0L} SCRIPTID_INIT},
     {"linespace",   "lsp",  P_NUM|P_VI_DEF|P_RCLR,
 #ifdef FEAT_GUI
 			    (char_u *)&p_linespace, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
@@ -1608,53 +1619,53 @@ static struct vimoption
 #ifdef FEAT_GUI_W32
 			    {(char_u *)1L, (char_u *)0L}
 #else
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"lisp",	    NULL,   P_BOOL|P_VI_DEF,
 #ifdef FEAT_LISP
 			    (char_u *)&p_lisp, PV_LISP,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"lispwords",   "lw",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_LISP
 			    (char_u *)&p_lispwords, PV_NONE,
 			    {(char_u *)LISPWORD_VALUE, (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"list",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_LIST,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"listchars",   "lcs",  P_STRING|P_VI_DEF|P_RALL|P_COMMA|P_NODUP,
 			    (char_u *)&p_lcs, PV_NONE,
-			    {(char_u *)"eol:$", (char_u *)0L}},
+			    {(char_u *)"eol:$", (char_u *)0L} SCRIPTID_INIT},
     {"loadplugins", "lpl",  P_BOOL|P_VI_DEF,
 			    (char_u *)&p_lpl, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
 #ifdef FEAT_GUI_MAC
     {"macatsui",    NULL,   P_BOOL|P_VI_DEF|P_RCLR,
 			    (char_u *)&p_macatsui, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
 #endif
     {"magic",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_magic, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"makeef",	    "mef",  P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 #ifdef FEAT_QUICKFIX
 			    (char_u *)&p_mef, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"makeprg",	    "mp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 #ifdef FEAT_QUICKFIX
 			    (char_u *)&p_mp, PV_MP,
 # ifdef VMS
 			    {(char_u *)"MMS", (char_u *)0L}
@@ -1663,100 +1674,103 @@ static struct vimoption
 # endif
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"matchpairs",  "mps",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_mps, PV_MPS,
-			    {(char_u *)"(:),{:},[:]", (char_u *)0L}},
+			    {(char_u *)"(:),{:},[:]", (char_u *)0L}
+			    SCRIPTID_INIT},
     {"matchtime",   "mat",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_mat, PV_NONE,
-			    {(char_u *)5L, (char_u *)0L}},
+			    {(char_u *)5L, (char_u *)0L} SCRIPTID_INIT},
     {"maxcombine",  "mco",  P_NUM|P_VI_DEF,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_mco, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)2, (char_u *)0L}},
+			    {(char_u *)2, (char_u *)0L} SCRIPTID_INIT},
     {"maxfuncdepth", "mfd", P_NUM|P_VI_DEF,
 #ifdef FEAT_EVAL
 			    (char_u *)&p_mfd, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)100L, (char_u *)0L}},
+			    {(char_u *)100L, (char_u *)0L} SCRIPTID_INIT},
     {"maxmapdepth", "mmd",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_mmd, PV_NONE,
-			    {(char_u *)1000L, (char_u *)0L}},
+			    {(char_u *)1000L, (char_u *)0L} SCRIPTID_INIT},
     {"maxmem",	    "mm",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_mm, PV_NONE,
-			    {(char_u *)DFLT_MAXMEM, (char_u *)0L}},
+			    {(char_u *)DFLT_MAXMEM, (char_u *)0L}
+			    SCRIPTID_INIT},
     {"maxmempattern","mmp", P_NUM|P_VI_DEF,
 			    (char_u *)&p_mmp, PV_NONE,
-			    {(char_u *)1000L, (char_u *)0L}},
+			    {(char_u *)1000L, (char_u *)0L} SCRIPTID_INIT},
     {"maxmemtot",   "mmt",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_mmt, PV_NONE,
-			    {(char_u *)DFLT_MAXMEMTOT, (char_u *)0L}},
+			    {(char_u *)DFLT_MAXMEMTOT, (char_u *)0L}
+			    SCRIPTID_INIT},
     {"menuitems",   "mis",  P_NUM|P_VI_DEF,
 #ifdef FEAT_MENU
 			    (char_u *)&p_mis, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)25L, (char_u *)0L}},
+			    {(char_u *)25L, (char_u *)0L} SCRIPTID_INIT},
     {"mesg",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"mkspellmem",  "msm",  P_STRING|P_VI_DEF|P_EXPAND|P_SECURE,
 #ifdef FEAT_SPELL
 			    (char_u *)&p_msm, PV_NONE,
 			    {(char_u *)"460000,2000,500", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-    },
+			    SCRIPTID_INIT},
     {"modeline",    "ml",   P_BOOL|P_VIM,
 			    (char_u *)&p_ml, PV_ML,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
+			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
     {"modelines",   "mls",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_mls, PV_NONE,
-			    {(char_u *)5L, (char_u *)0L}},
+			    {(char_u *)5L, (char_u *)0L} SCRIPTID_INIT},
     {"modifiable",  "ma",   P_BOOL|P_VI_DEF|P_NOGLOB,
 			    (char_u *)&p_ma, PV_MA,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"modified",    "mod",  P_BOOL|P_NO_MKRC|P_VI_DEF|P_RSTAT,
 			    (char_u *)&p_mod, PV_MOD,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"more",	    NULL,   P_BOOL|P_VIM,
 			    (char_u *)&p_more, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
+			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
     {"mouse",	    NULL,   P_STRING|P_VI_DEF|P_FLAGLIST,
 			    (char_u *)&p_mouse, PV_NONE,
 			    {
 #if defined(MSDOS) || defined(WIN3264)
 				(char_u *)"a",
 #else
 				(char_u *)"",
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"mousefocus",   "mousef", P_BOOL|P_VI_DEF,
 #ifdef FEAT_GUI
 			    (char_u *)&p_mousef, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"mousehide",   "mh",   P_BOOL|P_VI_DEF,
 #ifdef FEAT_GUI
 			    (char_u *)&p_mh, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"mousemodel",  "mousem", P_STRING|P_VI_DEF,
 			    (char_u *)&p_mousem, PV_NONE,
 			    {
 #if defined(MSDOS) || defined(MSWIN)
 				(char_u *)"popup",
@@ -1765,103 +1779,104 @@ static struct vimoption
 				(char_u *)"popup_setpos",
 # else
 				(char_u *)"extend",
 # endif
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"mouseshape",  "mouses",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_MOUSESHAPE
 			    (char_u *)&p_mouseshape, PV_NONE,
 			    {(char_u *)"i-r:beam,s:updown,sd:udsizing,vs:leftright,vd:lrsizing,m:no,ml:up-arrow,v:rightup-arrow", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"mousetime",   "mouset",	P_NUM|P_VI_DEF,
 			    (char_u *)&p_mouset, PV_NONE,
-			    {(char_u *)500L, (char_u *)0L}},
+			    {(char_u *)500L, (char_u *)0L} SCRIPTID_INIT},
     {"mzquantum",  "mzq",   P_NUM,
 #ifdef FEAT_MZSCHEME
 			    (char_u *)&p_mzq, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)100L, (char_u *)100L}},
+			    {(char_u *)100L, (char_u *)100L} SCRIPTID_INIT},
     {"novice",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"nrformats",   "nf",   P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_nf, PV_NF,
-			    {(char_u *)"octal,hex", (char_u *)0L}},
+			    {(char_u *)"octal,hex", (char_u *)0L}
+			    SCRIPTID_INIT},
     {"number",	    "nu",   P_BOOL|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_NU,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"numberwidth", "nuw",  P_NUM|P_RWIN|P_VIM,
 #ifdef FEAT_LINEBREAK
 			    (char_u *)VAR_WIN, PV_NUW,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)8L, (char_u *)4L}},
+			    {(char_u *)8L, (char_u *)4L} SCRIPTID_INIT},
     {"omnifunc",    "ofu",  P_STRING|P_ALLOCED|P_VI_DEF|P_SECURE,
 #ifdef FEAT_COMPL_FUNC
 			    (char_u *)&p_ofu, PV_OFU,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"open",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"opendevice",  "odev", P_BOOL|P_VI_DEF,
 #if defined(MSDOS) || defined(MSWIN) || defined(OS2)
 			    (char_u *)&p_odev, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
 			    {(char_u *)FALSE, (char_u *)FALSE}
-			    },
+			    SCRIPTID_INIT},
     {"operatorfunc", "opfunc", P_STRING|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_opfunc, PV_NONE,
-			    {(char_u *)"", (char_u *)0L} },
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"optimize",    "opt",  P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"osfiletype",  "oft",  P_STRING|P_ALLOCED|P_VI_DEF,
 #ifdef FEAT_OSFILETYPE
 			    (char_u *)&p_oft, PV_OFT,
 			    {(char_u *)DFLT_OFT, (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"paragraphs",  "para", P_STRING|P_VI_DEF,
 			    (char_u *)&p_para, PV_NONE,
 			    {(char_u *)"IPLPPPQPP TPHPLIPpLpItpplpipbp",
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"paste",	    NULL,   P_BOOL|P_VI_DEF|P_PRI_MKRC,
 			    (char_u *)&p_paste, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"pastetoggle", "pt",   P_STRING|P_VI_DEF,
 			    (char_u *)&p_pt, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"patchexpr",   "pex",  P_STRING|P_VI_DEF|P_SECURE,
 #if defined(FEAT_DIFF) && defined(FEAT_EVAL)
 			    (char_u *)&p_pex, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"patchmode",   "pm",   P_STRING|P_VI_DEF|P_NFNAME,
 			    (char_u *)&p_pm, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"path",	    "pa",   P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_path, PV_PATH,
 			    {
 #if defined AMIGA || defined MSDOS || defined MSWIN
 			    (char_u *)".,,",
@@ -1870,55 +1885,55 @@ static struct vimoption
 			    (char_u *)".,/emx/include,,",
 # else /* Unix, probably */
 			    (char_u *)".,/usr/include,,",
 # endif
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"preserveindent", "pi", P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_pi, PV_PI,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"previewheight", "pvh", P_NUM|P_VI_DEF,
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
 			    (char_u *)&p_pvh, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)12L, (char_u *)0L}},
+			    {(char_u *)12L, (char_u *)0L} SCRIPTID_INIT},
     {"previewwindow", "pvw", P_BOOL|P_VI_DEF|P_RSTAT|P_NOGLOB,
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
 			    (char_u *)VAR_WIN, PV_PVW,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"printdevice", "pdev", P_STRING|P_VI_DEF|P_SECURE,
 #ifdef FEAT_PRINTER
 			    (char_u *)&p_pdev, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"printencoding", "penc", P_STRING|P_VI_DEF,
 #ifdef FEAT_POSTSCRIPT
 			    (char_u *)&p_penc, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"printexpr", "pexpr",  P_STRING|P_VI_DEF,
 #ifdef FEAT_POSTSCRIPT
 			    (char_u *)&p_pexpr, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"printfont", "pfn",    P_STRING|P_VI_DEF,
 #ifdef FEAT_PRINTER
 			    (char_u *)&p_pfn, PV_NONE,
 			    {
 # ifdef MSWIN
@@ -1929,187 +1944,190 @@ static struct vimoption
 				(char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"printheader", "pheader",  P_STRING|P_VI_DEF|P_GETTEXT,
 #ifdef FEAT_PRINTER
 			    (char_u *)&p_header, PV_NONE,
 			    {(char_u *)N_("%<%f%h%m%=Page %N"), (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
    {"printmbcharset", "pmbcs",  P_STRING|P_VI_DEF,
 #if defined(FEAT_POSTSCRIPT) && defined(FEAT_MBYTE)
 			    (char_u *)&p_pmcs, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"printmbfont", "pmbfn",  P_STRING|P_VI_DEF,
 #if defined(FEAT_POSTSCRIPT) && defined(FEAT_MBYTE)
 			    (char_u *)&p_pmfn, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"printoptions", "popt", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_PRINTER
 			    (char_u *)&p_popt, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"prompt",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_prompt, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"pumheight",   "ph",   P_NUM|P_VI_DEF,
 #ifdef FEAT_INS_EXPAND
 			    (char_u *)&p_ph, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"quoteescape", "qe",   P_STRING|P_ALLOCED|P_VI_DEF,
 #ifdef FEAT_TEXTOBJ
 			    (char_u *)&p_qe, PV_QE,
 			    {(char_u *)"\\", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"readonly",    "ro",   P_BOOL|P_VI_DEF|P_RSTAT|P_NOGLOB,
 			    (char_u *)&p_ro, PV_RO,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"redraw",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"redrawtime",  "rdt",  P_NUM|P_VI_DEF,
 #ifdef FEAT_RELTIME
 			    (char_u *)&p_rdt, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)2000L, (char_u *)0L}},
+			    {(char_u *)2000L, (char_u *)0L} SCRIPTID_INIT},
     {"remap",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_remap, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"report",	    NULL,   P_NUM|P_VI_DEF,
 			    (char_u *)&p_report, PV_NONE,
-			    {(char_u *)2L, (char_u *)0L}},
+			    {(char_u *)2L, (char_u *)0L} SCRIPTID_INIT},
     {"restorescreen", "rs", P_BOOL|P_VI_DEF,
 #ifdef WIN3264
 			    (char_u *)&p_rs, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"revins",	    "ri",   P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_RIGHTLEFT
 			    (char_u *)&p_ri, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"rightleft",   "rl",   P_BOOL|P_VI_DEF|P_RWIN,
 #ifdef FEAT_RIGHTLEFT
 			    (char_u *)VAR_WIN, PV_RL,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"rightleftcmd", "rlc", P_STRING|P_ALLOCED|P_VI_DEF|P_RWIN,
 #ifdef FEAT_RIGHTLEFT
 			    (char_u *)VAR_WIN, PV_RLC,
 			    {(char_u *)"search", (char_u *)NULL}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"ruler",	    "ru",   P_BOOL|P_VI_DEF|P_VIM|P_RSTAT,
 #ifdef FEAT_CMDL_INFO
 			    (char_u *)&p_ru, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"rulerformat", "ruf",  P_STRING|P_VI_DEF|P_ALLOCED|P_RSTAT,
 #ifdef FEAT_STL_OPT
 			    (char_u *)&p_ruf, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"runtimepath", "rtp",  P_STRING|P_VI_DEF|P_EXPAND|P_COMMA|P_NODUP|P_SECURE,
 			    (char_u *)&p_rtp, PV_NONE,
-			    {(char_u *)DFLT_RUNTIMEPATH, (char_u *)0L}},
+			    {(char_u *)DFLT_RUNTIMEPATH, (char_u *)0L}
+			    SCRIPTID_INIT},
     {"scroll",	    "scr",  P_NUM|P_NO_MKRC|P_VI_DEF,
 			    (char_u *)VAR_WIN, PV_SCROLL,
-			    {(char_u *)12L, (char_u *)0L}},
+			    {(char_u *)12L, (char_u *)0L} SCRIPTID_INIT},
     {"scrollbind",  "scb",  P_BOOL|P_VI_DEF,
 #ifdef FEAT_SCROLLBIND
 			    (char_u *)VAR_WIN, PV_SCBIND,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"scrolljump",  "sj",   P_NUM|P_VI_DEF|P_VIM,
 			    (char_u *)&p_sj, PV_NONE,
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"scrolloff",   "so",   P_NUM|P_VI_DEF|P_VIM|P_RALL,
 			    (char_u *)&p_so, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"scrollopt",   "sbo",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_SCROLLBIND
 			    (char_u *)&p_sbo, PV_NONE,
 			    {(char_u *)"ver,jump", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"sections",    "sect", P_STRING|P_VI_DEF,
 			    (char_u *)&p_sections, PV_NONE,
-			    {(char_u *)"SHNHH HUnhsh", (char_u *)0L}},
+			    {(char_u *)"SHNHH HUnhsh", (char_u *)0L}
+			    SCRIPTID_INIT},
     {"secure",	    NULL,   P_BOOL|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_secure, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"selection",   "sel",  P_STRING|P_VI_DEF,
 #ifdef FEAT_VISUAL
 			    (char_u *)&p_sel, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"inclusive", (char_u *)0L}},
+			    {(char_u *)"inclusive", (char_u *)0L}
+			    SCRIPTID_INIT},
     {"selectmode",  "slm",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_VISUAL
 			    (char_u *)&p_slm, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"sessionoptions", "ssop", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_SESSION
 			    (char_u *)&p_ssop, PV_NONE,
 	 {(char_u *)"blank,buffers,curdir,folds,help,options,tabpages,winsize",
 							       (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"shell",	    "sh",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_sh, PV_NONE,
 			    {
 #ifdef VMS
 			    (char_u *)"-",
@@ -2134,11 +2152,11 @@ static struct vimoption
 #    endif
 #   endif
 #  endif
 # endif
 #endif /* VMS */
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"shellcmdflag","shcf", P_STRING|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_shcf, PV_NONE,
 			    {
 #if defined(MSDOS) || defined(MSWIN)
 			    (char_u *)"/c",
@@ -2147,11 +2165,11 @@ static struct vimoption
 			    (char_u *)"/c",
 # else
 			    (char_u *)"-c",
 # endif
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"shellpipe",   "sp",   P_STRING|P_VI_DEF|P_SECURE,
 #ifdef FEAT_QUICKFIX
 			    (char_u *)&p_sp, PV_NONE,
 			    {
 #if defined(UNIX) || defined(OS2)
@@ -2166,66 +2184,67 @@ static struct vimoption
 				(char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-    },
+			    SCRIPTID_INIT},
     {"shellquote",  "shq",  P_STRING|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_shq, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"shellredir",  "srr",  P_STRING|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_srr, PV_NONE,
-			    {(char_u *)">", (char_u *)0L}},
+			    {(char_u *)">", (char_u *)0L} SCRIPTID_INIT},
     {"shellslash",  "ssl",   P_BOOL|P_VI_DEF,
 #ifdef BACKSLASH_IN_FILENAME
 			    (char_u *)&p_ssl, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"shelltemp",   "stmp", P_BOOL,
 			    (char_u *)&p_stmp, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
+			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
     {"shelltype",   "st",   P_NUM|P_VI_DEF,
 #ifdef AMIGA
 			    (char_u *)&p_st, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"shellxquote", "sxq",  P_STRING|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_sxq, PV_NONE,
 			    {
 #if defined(UNIX) && defined(USE_SYSTEM) && !defined(__EMX__)
 			    (char_u *)"\"",
 #else
 			    (char_u *)"",
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"shiftround",  "sr",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_sr, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"shiftwidth",  "sw",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_sw, PV_SW,
-			    {(char_u *)8L, (char_u *)0L}},
+			    {(char_u *)8L, (char_u *)0L} SCRIPTID_INIT},
     {"shortmess",   "shm",  P_STRING|P_VIM|P_FLAGLIST,
 			    (char_u *)&p_shm, PV_NONE,
-			    {(char_u *)"", (char_u *)"filnxtToO"}},
+			    {(char_u *)"", (char_u *)"filnxtToO"}
+			    SCRIPTID_INIT},
     {"shortname",   "sn",   P_BOOL|P_VI_DEF,
 #ifdef SHORT_FNAME
 			    (char_u *)NULL, PV_NONE,
 #else
 			    (char_u *)&p_sn, PV_SN,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"showbreak",   "sbr",  P_STRING|P_VI_DEF|P_RALL,
 #ifdef FEAT_LINEBREAK
 			    (char_u *)&p_sbr, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"showcmd",	    "sc",   P_BOOL|P_VIM,
 #ifdef FEAT_CMDL_INFO
 			    (char_u *)&p_sc, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
@@ -2234,529 +2253,532 @@ static struct vimoption
 #ifdef UNIX
 				(char_u *)FALSE
 #else
 				(char_u *)TRUE
 #endif
-				}},
+				} SCRIPTID_INIT},
     {"showfulltag", "sft",  P_BOOL|P_VI_DEF,
 			    (char_u *)&p_sft, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"showmatch",   "sm",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_sm, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"showmode",    "smd",  P_BOOL|P_VIM,
 			    (char_u *)&p_smd, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
+			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
     {"showtabline", "stal", P_NUM|P_VI_DEF|P_RALL,
 #ifdef FEAT_WINDOWS
 			    (char_u *)&p_stal, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"sidescroll",  "ss",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_ss, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"sidescrolloff", "siso", P_NUM|P_VI_DEF|P_VIM|P_RBUF,
 			    (char_u *)&p_siso, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"slowopen",    "slow", P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"smartcase",   "scs",  P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_scs, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"smartindent", "si",   P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_SMARTINDENT
 			    (char_u *)&p_si, PV_SI,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"smarttab",    "sta",  P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_sta, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"softtabstop", "sts",  P_NUM|P_VI_DEF|P_VIM,
 			    (char_u *)&p_sts, PV_STS,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"sourceany",   NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"spell",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN,
 #ifdef FEAT_SPELL
 			    (char_u *)VAR_WIN, PV_SPELL,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"spellcapcheck", "spc", P_STRING|P_ALLOCED|P_VI_DEF|P_RBUF,
 #ifdef FEAT_SPELL
 			    (char_u *)&p_spc, PV_SPC,
 			    {(char_u *)"[.?!]\\_[\\])'\"	 ]\\+", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"spellfile",   "spf",  P_STRING|P_EXPAND|P_ALLOCED|P_VI_DEF|P_SECURE|P_COMMA,
 #ifdef FEAT_SPELL
 			    (char_u *)&p_spf, PV_SPF,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"spelllang",   "spl",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_RBUF|P_EXPAND,
 #ifdef FEAT_SPELL
 			    (char_u *)&p_spl, PV_SPL,
 			    {(char_u *)"en", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"spellsuggest", "sps", P_STRING|P_VI_DEF|P_EXPAND|P_SECURE|P_COMMA,
 #ifdef FEAT_SPELL
 			    (char_u *)&p_sps, PV_NONE,
 			    {(char_u *)"best", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-    },
+			    SCRIPTID_INIT},
     {"splitbelow",  "sb",   P_BOOL|P_VI_DEF,
 #ifdef FEAT_WINDOWS
 			    (char_u *)&p_sb, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"splitright",  "spr",  P_BOOL|P_VI_DEF,
 #ifdef FEAT_VERTSPLIT
 			    (char_u *)&p_spr, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"startofline", "sol",  P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_sol, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"statusline"  ,"stl",  P_STRING|P_VI_DEF|P_ALLOCED|P_RSTAT,
 #ifdef FEAT_STL_OPT
 			    (char_u *)&p_stl, PV_STL,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"suffixes",    "su",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_su, PV_NONE,
 			    {(char_u *)".bak,~,.o,.h,.info,.swp,.obj",
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"suffixesadd", "sua",  P_STRING|P_VI_DEF|P_ALLOCED|P_COMMA|P_NODUP,
 #ifdef FEAT_SEARCHPATH
 			    (char_u *)&p_sua, PV_SUA,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"swapfile",    "swf",  P_BOOL|P_VI_DEF|P_RSTAT,
 			    (char_u *)&p_swf, PV_SWF,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"swapsync",    "sws",  P_STRING|P_VI_DEF,
 			    (char_u *)&p_sws, PV_NONE,
-			    {(char_u *)"fsync", (char_u *)0L}},
+			    {(char_u *)"fsync", (char_u *)0L} SCRIPTID_INIT},
     {"switchbuf",   "swb",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_swb, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"synmaxcol",   "smc",  P_NUM|P_VI_DEF|P_RBUF,
 #ifdef FEAT_SYN_HL
 			    (char_u *)&p_smc, PV_SMC,
 			    {(char_u *)3000L, (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"syntax",	    "syn",  P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB|P_NFNAME,
 #ifdef FEAT_SYN_HL
 			    (char_u *)&p_syn, PV_SYN,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"tabline",	    "tal",  P_STRING|P_VI_DEF|P_RALL,
 #ifdef FEAT_STL_OPT
 			    (char_u *)&p_tal, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"tabpagemax",  "tpm",  P_NUM|P_VI_DEF,
 #ifdef FEAT_WINDOWS
 			    (char_u *)&p_tpm, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)10L, (char_u *)0L}},
+			    {(char_u *)10L, (char_u *)0L} SCRIPTID_INIT},
     {"tabstop",	    "ts",   P_NUM|P_VI_DEF|P_RBUF,
 			    (char_u *)&p_ts, PV_TS,
-			    {(char_u *)8L, (char_u *)0L}},
+			    {(char_u *)8L, (char_u *)0L} SCRIPTID_INIT},
     {"tagbsearch",  "tbs",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_tbs, PV_NONE,
 #ifdef VMS	/* binary searching doesn't appear to work on VMS */
 			    {(char_u *)0L, (char_u *)0L}
 #else
 			    {(char_u *)TRUE, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"taglength",   "tl",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_tl, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"tagrelative", "tr",   P_BOOL|P_VIM,
 			    (char_u *)&p_tr, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
+			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
     {"tags",	    "tag",  P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_tags, PV_TAGS,
 			    {
 #if defined(FEAT_EMACS_TAGS) && !defined(CASE_INSENSITIVE_FILENAME)
 			    (char_u *)"./tags,./TAGS,tags,TAGS",
 #else
 			    (char_u *)"./tags,tags",
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"tagstack",    "tgst", P_BOOL|P_VI_DEF,
 			    (char_u *)&p_tgst, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"term",	    NULL,   P_STRING|P_EXPAND|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RALL,
 			    (char_u *)&T_NAME, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"termbidi", "tbidi",   P_BOOL|P_VI_DEF,
 #ifdef FEAT_ARABIC
 			    (char_u *)&p_tbidi, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"termencoding", "tenc", P_STRING|P_VI_DEF|P_RCLR,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_tenc, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"terse",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_terse, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"textauto",    "ta",   P_BOOL|P_VIM,
 			    (char_u *)&p_ta, PV_NONE,
-			    {(char_u *)DFLT_TEXTAUTO, (char_u *)TRUE}},
+			    {(char_u *)DFLT_TEXTAUTO, (char_u *)TRUE}
+			    SCRIPTID_INIT},
     {"textmode",    "tx",   P_BOOL|P_VI_DEF|P_NO_MKRC,
 			    (char_u *)&p_tx, PV_TX,
 			    {
 #ifdef USE_CRNL
 			    (char_u *)TRUE,
 #else
 			    (char_u *)FALSE,
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"textwidth",   "tw",   P_NUM|P_VI_DEF|P_VIM,
 			    (char_u *)&p_tw, PV_TW,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"thesaurus",   "tsr",  P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_INS_EXPAND
 			    (char_u *)&p_tsr, PV_TSR,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"tildeop",	    "top",  P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_to, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"timeout",	    "to",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_timeout, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"timeoutlen",  "tm",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_tm, PV_NONE,
-			    {(char_u *)1000L, (char_u *)0L}},
+			    {(char_u *)1000L, (char_u *)0L} SCRIPTID_INIT},
     {"title",	    NULL,   P_BOOL|P_VI_DEF,
 #ifdef FEAT_TITLE
 			    (char_u *)&p_title, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"titlelen",    NULL,   P_NUM|P_VI_DEF,
 #ifdef FEAT_TITLE
 			    (char_u *)&p_titlelen, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)85L, (char_u *)0L}},
+			    {(char_u *)85L, (char_u *)0L} SCRIPTID_INIT},
     {"titleold",    NULL,   P_STRING|P_VI_DEF|P_GETTEXT|P_SECURE|P_NO_MKRC,
 #ifdef FEAT_TITLE
 			    (char_u *)&p_titleold, PV_NONE,
 			    {(char_u *)N_("Thanks for flying Vim"),
 							       (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"titlestring", NULL,   P_STRING|P_VI_DEF,
 #ifdef FEAT_TITLE
 			    (char_u *)&p_titlestring, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
 #if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_W32)
     {"toolbar",     "tb",   P_STRING|P_COMMA|P_VI_DEF|P_NODUP,
 			    (char_u *)&p_toolbar, PV_NONE,
-			    {(char_u *)"icons,tooltips", (char_u *)0L}},
+			    {(char_u *)"icons,tooltips", (char_u *)0L}
+			    SCRIPTID_INIT},
 #endif
 #if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_GTK) && defined(HAVE_GTK2)
     {"toolbariconsize",	"tbis", P_STRING|P_VI_DEF,
 			    (char_u *)&p_tbis, PV_NONE,
-			    {(char_u *)"small", (char_u *)0L}},
+			    {(char_u *)"small", (char_u *)0L} SCRIPTID_INIT},
 #endif
     {"ttimeout",    NULL,   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_ttimeout, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"ttimeoutlen", "ttm",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_ttm, PV_NONE,
-			    {(char_u *)-1L, (char_u *)0L}},
+			    {(char_u *)-1L, (char_u *)0L} SCRIPTID_INIT},
     {"ttybuiltin",  "tbi",  P_BOOL|P_VI_DEF,
 			    (char_u *)&p_tbi, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"ttyfast",	    "tf",   P_BOOL|P_NO_MKRC|P_VI_DEF,
 			    (char_u *)&p_tf, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"ttymouse",    "ttym", P_STRING|P_NODEFAULT|P_NO_MKRC|P_VI_DEF,
 #if defined(FEAT_MOUSE) && (defined(UNIX) || defined(VMS))
 			    (char_u *)&p_ttym, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"ttyscroll",   "tsl",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_ttyscroll, PV_NONE,
-			    {(char_u *)999L, (char_u *)0L}},
+			    {(char_u *)999L, (char_u *)0L} SCRIPTID_INIT},
     {"ttytype",	    "tty",  P_STRING|P_EXPAND|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RALL,
 			    (char_u *)&T_NAME, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"undolevels",  "ul",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_ul, PV_NONE,
 			    {
 #if defined(UNIX) || defined(WIN3264) || defined(OS2) || defined(VMS)
 			    (char_u *)1000L,
 #else
 			    (char_u *)100L,
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"updatecount", "uc",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_uc, PV_NONE,
-			    {(char_u *)200L, (char_u *)0L}},
+			    {(char_u *)200L, (char_u *)0L} SCRIPTID_INIT},
     {"updatetime",  "ut",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_ut, PV_NONE,
-			    {(char_u *)4000L, (char_u *)0L}},
+			    {(char_u *)4000L, (char_u *)0L} SCRIPTID_INIT},
     {"verbose",	    "vbs",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_verbose, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"verbosefile", "vfile", P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_vfile, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"viewdir",     "vdir", P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 #ifdef FEAT_SESSION
 			    (char_u *)&p_vdir, PV_NONE,
 			    {(char_u *)DFLT_VDIR, (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"viewoptions", "vop",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_SESSION
 			    (char_u *)&p_vop, PV_NONE,
 			    {(char_u *)"folds,options,cursor", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"viminfo",	    "vi",   P_STRING|P_COMMA|P_NODUP|P_SECURE,
 #ifdef FEAT_VIMINFO
 			    (char_u *)&p_viminfo, PV_NONE,
 #if defined(MSDOS) || defined(MSWIN) || defined(OS2)
-			    {(char_u *)"", (char_u *)"'20,<50,s10,h,rA:,rB:"}
+			    {(char_u *)"", (char_u *)"'100,<50,s10,h,rA:,rB:"}
 #else
 # ifdef AMIGA
 			    {(char_u *)"",
-				 (char_u *)"'20,<50,s10,h,rdf0:,rdf1:,rdf2:"}
+				 (char_u *)"'100,<50,s10,h,rdf0:,rdf1:,rdf2:"}
 # else
-			    {(char_u *)"", (char_u *)"'20,<50,s10,h"}
+			    {(char_u *)"", (char_u *)"'100,<50,s10,h"}
 # endif
 #endif
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"virtualedit", "ve",   P_STRING|P_COMMA|P_NODUP|P_VI_DEF|P_VIM,
 #ifdef FEAT_VIRTUALEDIT
 			    (char_u *)&p_ve, PV_NONE,
 			    {(char_u *)"", (char_u *)""}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"visualbell",  "vb",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_vb, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"w300",	    NULL,   P_NUM|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"w1200",	    NULL,   P_NUM|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"w9600",	    NULL,   P_NUM|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"warn",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_warn, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"weirdinvert", "wiv",  P_BOOL|P_VI_DEF|P_RCLR,
 			    (char_u *)&p_wiv, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"whichwrap",   "ww",   P_STRING|P_VIM|P_COMMA|P_FLAGLIST,
 			    (char_u *)&p_ww, PV_NONE,
-			    {(char_u *)"", (char_u *)"b,s"}},
+			    {(char_u *)"", (char_u *)"b,s"} SCRIPTID_INIT},
     {"wildchar",    "wc",   P_NUM|P_VIM,
 			    (char_u *)&p_wc, PV_NONE,
-			    {(char_u *)(long)Ctrl_E, (char_u *)(long)TAB}},
+			    {(char_u *)(long)Ctrl_E, (char_u *)(long)TAB}
+			    SCRIPTID_INIT},
     {"wildcharm",   "wcm",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_wcm, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"wildignore",  "wig",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_WILDIGN
 			    (char_u *)&p_wig, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"wildmenu",    "wmnu", P_BOOL|P_VI_DEF,
 #ifdef FEAT_WILDMENU
 			    (char_u *)&p_wmnu, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"wildmode",    "wim",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_wim, PV_NONE,
-			    {(char_u *)"full", (char_u *)0L}},
+			    {(char_u *)"full", (char_u *)0L} SCRIPTID_INIT},
     {"wildoptions", "wop",  P_STRING|P_VI_DEF,
 #ifdef FEAT_CMDL_COMPL
 			    (char_u *)&p_wop, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"winaltkeys",  "wak",  P_STRING|P_VI_DEF,
 #ifdef FEAT_WAK
 			    (char_u *)&p_wak, PV_NONE,
 			    {(char_u *)"menu", (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"window",	    "wi",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_window, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"winheight",   "wh",   P_NUM|P_VI_DEF,
 #ifdef FEAT_WINDOWS
 			    (char_u *)&p_wh, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"winfixheight", "wfh", P_BOOL|P_VI_DEF|P_RSTAT,
 #ifdef FEAT_WINDOWS
 			    (char_u *)VAR_WIN, PV_WFH,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"winfixwidth", "wfw", P_BOOL|P_VI_DEF|P_RSTAT,
 #ifdef FEAT_VERTSPLIT
 			    (char_u *)VAR_WIN, PV_WFW,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"winminheight", "wmh", P_NUM|P_VI_DEF,
 #ifdef FEAT_WINDOWS
 			    (char_u *)&p_wmh, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"winminwidth", "wmw", P_NUM|P_VI_DEF,
 #ifdef FEAT_VERTSPLIT
 			    (char_u *)&p_wmw, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"winwidth",   "wiw",   P_NUM|P_VI_DEF,
 #ifdef FEAT_VERTSPLIT
 			    (char_u *)&p_wiw, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)20L, (char_u *)0L}},
+			    {(char_u *)20L, (char_u *)0L} SCRIPTID_INIT},
     {"wrap",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_WRAP,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"wrapmargin",  "wm",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_wm, PV_WM,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"wrapscan",    "ws",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_ws, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"write",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_write, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"writeany",    "wa",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_wa, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"writebackup", "wb",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_wb, PV_NONE,
 			    {
 #ifdef FEAT_WRITEBACKUP
 			    (char_u *)TRUE,
 #else
 			    (char_u *)FALSE,
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"writedelay",  "wd",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_wd, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
 
 /* terminal output codes */
 #define p_term(sss, vvv)   {sss, NULL, P_STRING|P_VI_DEF|P_RALL|P_SECURE, \
 			    (char_u *)&vvv, PV_NONE, \
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
 
     p_term("t_AB", T_CAB)
     p_term("t_AF", T_CAF)
     p_term("t_AL", T_CAL)
     p_term("t_al", T_AL)
@@ -2813,11 +2835,12 @@ static struct vimoption
     p_term("t_ZH", T_CZH)
     p_term("t_ZR", T_CZR)
 
 /* terminal key codes are not in here */
 
-    {NULL, NULL, 0, NULL, PV_NONE, {NULL, NULL}}	/* end marker */
+    /* end marker */
+    {NULL, NULL, 0, NULL, PV_NONE, {NULL, NULL} SCRIPTID_INIT}
 };
 
 #define PARAM_COUNT (sizeof(options) / sizeof(struct vimoption))
 
 #ifdef FEAT_MBYTE
@@ -3982,11 +4005,11 @@ do_set(arg, opt_flags)
 	    arg += 7;
 	}
 	else
 	{
 	    prefix = 1;
-	    if (STRNCMP(arg, "no", 2) == 0)
+	    if (STRNCMP(arg, "no", 2) == 0 && STRNCMP(arg, "novice", 6) != 0)
 	    {
 		prefix = 0;
 		arg += 2;
 	    }
 	    else if (STRNCMP(arg, "inv", 3) == 0)
@@ -4117,15 +4140,27 @@ do_set(arg, opt_flags)
 	    /* Skip all options that are window-local (used for :vimgrep). */
 	    if ((opt_flags & OPT_NOWIN) && opt_idx >= 0
 					   && options[opt_idx].var == VAR_WIN)
 		goto skip;
 
-	    /* Disallow changing some options from modelines */
-	    if ((opt_flags & OPT_MODELINE) && (flags & P_SECURE))
+	    /* Disallow changing some options from modelines. */
+	    if (opt_flags & OPT_MODELINE)
 	    {
-		errmsg = (char_u *)_("E520: Not allowed in a modeline");
-		goto skip;
+		if (flags & P_SECURE)
+		{
+		    errmsg = (char_u *)_("E520: Not allowed in a modeline");
+		    goto skip;
+		}
+#ifdef FEAT_DIFF
+		/* In diff mode some options are overruled.  This avoids that
+		 * 'foldmethod' becomes "marker" instead of "diff" and that
+		 * "wrap" gets set. */
+		if (curwin->w_p_diff
+			&& (options[opt_idx].indir == PV_FDM
+			    || options[opt_idx].indir == PV_WRAP))
+		    goto skip;
+#endif
 	    }
 
 #ifdef HAVE_SANDBOX
 	    /* Disallow changing some options in the sandbox */
 	    if (sandbox != 0 && (flags & P_SECURE))
@@ -5266,25 +5301,39 @@ insecure_flag(opt_idx, opt_flags)
     /* Nothing special, return global flags field. */
     return &options[opt_idx].flags;
 }
 #endif
 
+#ifdef FEAT_TITLE
+static void redraw_titles __ARGS((void));
+
+/*
+ * Redraw the window title and/or tab page text later.
+ */
+static void redraw_titles()
+{
+    need_maketitle = TRUE;
+# ifdef FEAT_WINDOWS
+    redraw_tabline = TRUE;
+# endif
+}
+#endif
+
 /*
  * Set a string option to a new value (without checking the effect).
  * The string is copied into allocated memory.
  * if ("opt_idx" == -1) "name" is used, otherwise "opt_idx" is used.
  * When "set_sid" is zero set the scriptID to current_SID.  When "set_sid" is
  * SID_NONE don't set the scriptID.  Otherwise set the scriptID to "set_sid".
  */
-/*ARGSUSED*/
     void
 set_string_option_direct(name, opt_idx, val, opt_flags, set_sid)
     char_u	*name;
     int		opt_idx;
     char_u	*val;
     int		opt_flags;	/* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */
-    int		set_sid;
+    int		set_sid UNUSED;
 {
     char_u	*s;
     char_u	**varp;
     int		both = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;
     int		idx = opt_idx;
@@ -5405,10 +5454,14 @@ did_set_string_option(opt_idx, varp, new
     char_u	*errmsg = NULL;
     char_u	*s, *p;
     int		did_chartab = FALSE;
     char_u	**gvarp;
     long_u	free_oldval = (options[opt_idx].flags & P_ALLOCED);
+#ifdef FEAT_GUI
+    /* set when changing an option that only requires a redraw in the GUI */
+    int		redraw_gui_only = FALSE;
+#endif
 
     /* Get the global option to compare with, otherwise we would have to check
      * two values for all local options. */
     gvarp = (char_u **)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL);
 
@@ -5666,11 +5719,11 @@ did_set_string_option(opt_idx, varp, new
 		errmsg = e_invarg;
 	    else
 	    {
 # ifdef FEAT_TITLE
 		/* May show a "+" in the title now. */
-		need_maketitle = TRUE;
+		redraw_titles();
 # endif
 		/* Add 'fileencoding' to the swap file. */
 		ml_setflags(curbuf);
 	    }
 	}
@@ -5685,11 +5738,11 @@ did_set_string_option(opt_idx, varp, new
 	    }
 	    if (varp == &p_enc)
 	    {
 		errmsg = mb_init();
 # ifdef FEAT_TITLE
-		need_maketitle = TRUE;
+		redraw_titles();
 # endif
 	    }
 	}
 
 # if defined(FEAT_GUI_GTK) && defined(HAVE_GTK2)
@@ -5764,18 +5817,32 @@ did_set_string_option(opt_idx, varp, new
     else if (varp == &curbuf->b_p_keymap)
     {
 	/* load or unload key mapping tables */
 	errmsg = keymap_init();
 
-	/* When successfully installed a new keymap switch on using it. */
-	if (*curbuf->b_p_keymap != NUL && errmsg == NULL)
+	if (errmsg == NULL)
 	{
-	    curbuf->b_p_iminsert = B_IMODE_LMAP;
-	    if (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)
-		curbuf->b_p_imsearch = B_IMODE_LMAP;
-	    set_iminsert_global();
-	    set_imsearch_global();
+	    if (*curbuf->b_p_keymap != NUL)
+	    {
+		/* Installed a new keymap, switch on using it. */
+		curbuf->b_p_iminsert = B_IMODE_LMAP;
+		if (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)
+		    curbuf->b_p_imsearch = B_IMODE_LMAP;
+	    }
+	    else
+	    {
+		/* Cleared the keymap, may reset 'iminsert' and 'imsearch'. */
+		if (curbuf->b_p_iminsert == B_IMODE_LMAP)
+		    curbuf->b_p_iminsert = B_IMODE_NONE;
+		if (curbuf->b_p_imsearch == B_IMODE_LMAP)
+		    curbuf->b_p_imsearch = B_IMODE_USE_INSERT;
+	    }
+	    if ((opt_flags & OPT_LOCAL) == 0)
+	    {
+		set_iminsert_global();
+		set_imsearch_global();
+	    }
 # ifdef FEAT_WINDOWS
 	    status_redraw_curbuf();
 # endif
 	}
     }
@@ -5794,14 +5861,18 @@ did_set_string_option(opt_idx, varp, new
 	    if (get_fileformat(curbuf) == EOL_DOS)
 		curbuf->b_p_tx = TRUE;
 	    else
 		curbuf->b_p_tx = FALSE;
 #ifdef FEAT_TITLE
-	    need_maketitle = TRUE;
+	    redraw_titles();
 #endif
 	    /* update flag in swap file */
 	    ml_setflags(curbuf);
+	    /* Redraw needed when switching to/from "mac": a CR in the text
+	     * will be displayed differently. */
+	    if (get_fileformat(curbuf) == EOL_MAC || *oldval == 'm')
+		redraw_curbuf_later(NOT_VALID);
 	}
     }
 
     /* 'fileformats' */
     else if (varp == &p_ffs)
@@ -5975,19 +6046,27 @@ did_set_string_option(opt_idx, varp, new
     else if (istermoption(&options[opt_idx]) && full_screen)
     {
 	/* ":set t_Co=0" and ":set t_Co=1" do ":set t_Co=" */
 	if (varp == &T_CCO)
 	{
-	    t_colors = atoi((char *)T_CCO);
-	    if (t_colors <= 1)
+	    int colors = atoi((char *)T_CCO);
+
+	    /* Only reinitialize colors if t_Co value has really changed to
+	     * avoid expensive reload of colorscheme if t_Co is set to the
+	     * same value multiple times. */
+	    if (colors != t_colors)
 	    {
-		if (new_value_alloced)
-		    vim_free(T_CCO);
-		T_CCO = empty_option;
+		t_colors = colors;
+		if (t_colors <= 1)
+		{
+		    if (new_value_alloced)
+			vim_free(T_CCO);
+		    T_CCO = empty_option;
+		}
+		/* We now have a different color setup, initialize it again. */
+		init_highlight(TRUE, FALSE);
 	    }
-	    /* We now have a different color setup, initialize it again. */
-	    init_highlight(TRUE, FALSE);
 	}
 	ttest(FALSE);
 	if (varp == &T_ME)
 	{
 	    out_str(T_ME);
@@ -6053,27 +6132,30 @@ did_set_string_option(opt_idx, varp, new
 		else
 # endif
 		    errmsg = (char_u *)N_("E596: Invalid font(s)");
 	    }
 	}
+	redraw_gui_only = TRUE;
     }
 # ifdef FEAT_XFONTSET
     else if (varp == &p_guifontset)
     {
 	if (STRCMP(p_guifontset, "*") == 0)
 	    errmsg = (char_u *)N_("E597: can't select fontset");
 	else if (gui.in_use && gui_init_font(p_guifontset, TRUE) != OK)
 	    errmsg = (char_u *)N_("E598: Invalid fontset");
+	redraw_gui_only = TRUE;
     }
 # endif
 # ifdef FEAT_MBYTE
     else if (varp == &p_guifontwide)
     {
 	if (STRCMP(p_guifontwide, "*") == 0)
 	    errmsg = (char_u *)N_("E533: can't select wide font");
 	else if (gui_get_wide_font() == FAIL)
 	    errmsg = (char_u *)N_("E534: Invalid wide font");
+	redraw_gui_only = TRUE;
     }
 # endif
 #endif
 
 #ifdef CURSOR_SHAPE
@@ -6131,17 +6213,28 @@ did_set_string_option(opt_idx, varp, new
 #endif
 
 #ifdef FEAT_GUI
     /* 'guioptions' */
     else if (varp == &p_go)
+    {
 	gui_init_which_components(oldval);
+	redraw_gui_only = TRUE;
+    }
 #endif
 
 #if defined(FEAT_GUI_TABLINE)
     /* 'guitablabel' */
     else if (varp == &p_gtl)
+    {
 	redraw_tabline = TRUE;
+	redraw_gui_only = TRUE;
+    }
+    /* 'guitabtooltip' */
+    else if (varp == &p_gtt)
+    {
+	redraw_gui_only = TRUE;
+    }
 #endif
 
 #if defined(FEAT_MOUSE_TTY) && (defined(UNIX) || defined(VMS))
     /* 'ttymouse' */
     else if (varp == &p_ttym)
@@ -6319,10 +6412,13 @@ did_set_string_option(opt_idx, varp, new
 		curwin->w_redr_status = TRUE;
 		redraw_later(VALID);
 	    }
 # endif
 	    curbuf->b_help = (curbuf->b_p_bt[0] == 'h');
+# ifdef FEAT_TITLE
+	    redraw_titles();
+# endif
 	}
     }
 #endif
 
 #ifdef FEAT_STL_OPT
@@ -6488,11 +6584,15 @@ did_set_string_option(opt_idx, varp, new
     {
 	if (check_opt_strings(*varp, p_fdm_values, FALSE) != OK
 		|| *curwin->w_p_fdm == NUL)
 	    errmsg = e_invarg;
 	else
+	{
 	    foldUpdateAll(curwin);
+	    if (foldmethodIsDiff(curwin))
+		newFoldLevel();
+	}
     }
 # ifdef FEAT_EVAL
     /* 'foldexpr' */
     else if (varp == &curwin->w_p_fde)
     {
@@ -6715,11 +6815,15 @@ did_set_string_option(opt_idx, varp, new
     }
 #endif
 
     if (curwin->w_curswant != MAXCOL)
 	curwin->w_set_curswant = TRUE;  /* in case 'showbreak' changed */
-    check_redraw(options[opt_idx].flags);
+#ifdef FEAT_GUI
+    /* check redraw when it's not a GUI option or the GUI is active. */
+    if (!redraw_gui_only || gui.in_use)
+#endif
+	check_redraw(options[opt_idx].flags);
 
     return errmsg;
 }
 
 /*
@@ -6930,10 +7034,11 @@ check_stl_option(s)
 check_clipboard_option()
 {
     int		new_unnamed = FALSE;
     int		new_autoselect = FALSE;
     int		new_autoselectml = FALSE;
+    int		new_html = FALSE;
     regprog_T	*new_exclude_prog = NULL;
     char_u	*errmsg = NULL;
     char_u	*p;
 
     for (p = p_cb; *p != NUL; )
@@ -6953,10 +7058,15 @@ check_clipboard_option()
 					&& (p[12] == ',' || p[12] == NUL))
 	{
 	    new_autoselectml = TRUE;
 	    p += 12;
 	}
+	else if (STRNCMP(p, "html", 4) == 0 && (p[4] == ',' || p[4] == NUL))
+	{
+	    new_html = TRUE;
+	    p += 4;
+	}
 	else if (STRNCMP(p, "exclude:", 8) == 0 && new_exclude_prog == NULL)
 	{
 	    p += 8;
 	    new_exclude_prog = vim_regcomp(p, RE_MAGIC);
 	    if (new_exclude_prog == NULL)
@@ -6974,10 +7084,11 @@ check_clipboard_option()
     if (errmsg == NULL)
     {
 	clip_unnamed = new_unnamed;
 	clip_autoselect = new_autoselect;
 	clip_autoselectml = new_autoselectml;
+	clip_html = new_html;
 	vim_free(clip_exclude_prog);
 	clip_exclude_prog = new_exclude_prog;
     }
     else
 	vim_free(new_exclude_prog);
@@ -7092,10 +7203,18 @@ set_bool_option(opt_idx, varp, value, op
     if ((int *)varp == &p_cp)
     {
 	compatible_set();
     }
 
+    /* 'list', 'number' */
+    else if ((int *)varp == &curwin->w_p_list
+	  || (int *)varp == &curwin->w_p_nu)
+    {
+	if (curwin->w_curswant != MAXCOL)
+	    curwin->w_set_curswant = TRUE;
+    }
+
     else if ((int *)varp == &curbuf->b_p_ro)
     {
 	/* when 'readonly' is reset globally, also reset readonlymode */
 	if (!curbuf->b_p_ro && (opt_flags & OPT_LOCAL) == 0)
 	    readonlymode = FALSE;
@@ -7103,34 +7222,40 @@ set_bool_option(opt_idx, varp, value, op
 	/* when 'readonly' is set may give W10 again */
 	if (curbuf->b_p_ro)
 	    curbuf->b_did_warn = FALSE;
 
 #ifdef FEAT_TITLE
-	need_maketitle = TRUE;
+	redraw_titles();
 #endif
     }
 
 #ifdef FEAT_TITLE
     /* when 'modifiable' is changed, redraw the window title */
     else if ((int *)varp == &curbuf->b_p_ma)
-	need_maketitle = TRUE;
+    {
+	redraw_titles();
+    }
     /* when 'endofline' is changed, redraw the window title */
     else if ((int *)varp == &curbuf->b_p_eol)
-	need_maketitle = TRUE;
-#ifdef FEAT_MBYTE
-    /* when 'bomb' is changed, redraw the window title */
+    {
+	redraw_titles();
+    }
+# ifdef FEAT_MBYTE
+    /* when 'bomb' is changed, redraw the window title and tab page text */
     else if ((int *)varp == &curbuf->b_p_bomb)
-	need_maketitle = TRUE;
-#endif
+    {
+	redraw_titles();
+    }
+# endif
 #endif
 
     /* when 'bin' is set also set some other options */
     else if ((int *)varp == &curbuf->b_p_bin)
     {
 	set_options_bin(old_value, curbuf->b_p_bin, opt_flags);
 #ifdef FEAT_TITLE
-	need_maketitle = TRUE;
+	redraw_titles();
 #endif
     }
 
 #ifdef FEAT_AUTOCMD
     /* when 'buflisted' changes, trigger autocommands */
@@ -7277,11 +7402,11 @@ set_bool_option(opt_idx, varp, value, op
     else if ((int *)varp == &curbuf->b_changed)
     {
 	if (!value)
 	    save_file_ff(curbuf);	/* Buffer is unchanged */
 #ifdef FEAT_TITLE
-	need_maketitle = TRUE;
+	redraw_titles();
 #endif
 #ifdef FEAT_AUTOCMD
 	modified_was_set = value;
 #endif
     }
@@ -7314,10 +7439,12 @@ set_bool_option(opt_idx, varp, value, op
     /* If 'wrap' is set, set w_leftcol to zero. */
     else if ((int *)varp == &curwin->w_p_wrap)
     {
 	if (curwin->w_p_wrap)
 	    curwin->w_leftcol = 0;
+	if (curwin->w_curswant != MAXCOL)
+	    curwin->w_set_curswant = TRUE;
     }
 
 #ifdef FEAT_WINDOWS
     else if ((int *)varp == &p_ea)
     {
@@ -7484,13 +7611,17 @@ set_bool_option(opt_idx, varp, value, op
 
 	    /* Arabic requires a utf-8 encoding, inform the user if its not
 	     * set. */
 	    if (STRCMP(p_enc, "utf-8") != 0)
 	    {
+		static char *w_arabic = N_("W17: Arabic requires UTF-8, do ':set encoding=utf-8'");
+
 		msg_source(hl_attr(HLF_W));
-		MSG_ATTR(_("W17: Arabic requires UTF-8, do ':set encoding=utf-8'"),
-			hl_attr(HLF_W));
+		MSG_ATTR(_(w_arabic), hl_attr(HLF_W));
+#ifdef FEAT_EVAL
+		set_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_arabic), -1);
+#endif
 	    }
 
 # ifdef FEAT_MBYTE
 	    /* set 'delcombine' */
 	    p_deco = TRUE;
@@ -7533,22 +7664,45 @@ set_bool_option(opt_idx, varp, value, op
 	    /* Revert to the default keymap */
 	    curbuf->b_p_iminsert = B_IMODE_NONE;
 	    curbuf->b_p_imsearch = B_IMODE_USE_INSERT;
 # endif
 	}
+	if (curwin->w_curswant != MAXCOL)
+	    curwin->w_set_curswant = TRUE;
+    }
+
+    else if ((int *)varp == &p_arshape)
+    {
+	if (curwin->w_curswant != MAXCOL)
+	    curwin->w_set_curswant = TRUE;
+    }
+#endif
+
+#ifdef FEAT_LINEBREAK
+    if ((int *)varp == &curwin->w_p_lbr)
+    {
+	if (curwin->w_curswant != MAXCOL)
+	    curwin->w_set_curswant = TRUE;
+    }
+#endif
+
+#ifdef FEAT_RIGHTLEFT
+    if ((int *)varp == &curwin->w_p_rl)
+    {
+	if (curwin->w_curswant != MAXCOL)
+	    curwin->w_set_curswant = TRUE;
     }
 #endif
 
     /*
      * End of handling side effects for bool options.
      */
 
     options[opt_idx].flags |= P_WAS_SET;
 
     comp_col();			    /* in case 'ruler' or 'showcmd' changed */
-    if (curwin->w_curswant != MAXCOL)
-	curwin->w_set_curswant = TRUE;  /* in case 'list' changed */
+
     check_redraw(options[opt_idx].flags);
 
     return NULL;
 }
 
@@ -7712,11 +7866,11 @@ set_num_option(opt_idx, varp, value, err
 	if (curwin->w_p_fdl < 0)
 	    curwin->w_p_fdl = 0;
 	newFoldLevel();
     }
 
-    /* 'foldminlevel' */
+    /* 'foldminlines' */
     else if (pp == &curwin->w_p_fml)
     {
 	foldUpdateAll(curwin);
     }
 
@@ -7972,10 +8126,15 @@ set_num_option(opt_idx, varp, value, err
 	else if (curwin->w_p_scr <= 0)
 	    curwin->w_p_scr = 1;
 	else /* curwin->w_p_scr > curwin->w_height */
 	    curwin->w_p_scr = curwin->w_height;
     }
+    if (p_hi < 0)
+    {
+	errmsg = e_positive;
+	p_hi = 0;
+    }
     if (p_report < 0)
     {
 	errmsg = e_positive;
 	p_report = 1;
     }
@@ -8225,17 +8384,17 @@ set_option_value(name, number, string, o
 	    varp = get_varp_scope(&(options[opt_idx]), opt_flags);
 	    if (varp != NULL)	/* hidden option is not changed */
 	    {
 		if (number == 0 && string != NULL)
 		{
-		    int index;
+		    int idx;
 
 		    /* Either we are given a string or we are setting option
 		     * to zero. */
-		    for (index = 0; string[index] == '0'; ++index)
+		    for (idx = 0; string[idx] == '0'; ++idx)
 			;
-		    if (string[index] != NUL || index == 0)
+		    if (string[idx] != NUL || idx == 0)
 		    {
 			/* There's another character after zeros or the string
 			 * is empty.  In both cases, we are trying to set a
 			 * num option using a string. */
 			EMSG3(_("E521: Number required: &%s = '%s'"),
@@ -8321,11 +8480,11 @@ find_key_option(arg)
 	key = TERMCAP2KEY(arg[2], arg[3]);
     else
     {
 	--arg;			    /* put arg at the '<' */
 	modifiers = 0;
-	key = find_special_key(&arg, &modifiers, TRUE);
+	key = find_special_key(&arg, &modifiers, TRUE, TRUE);
 	if (modifiers)		    /* can't handle modifiers here */
 	    key = 0;
     }
     return key;
 }
@@ -8811,10 +8970,32 @@ free_termoptions()
 	}
     clear_termcodes();
 }
 
 /*
+ * Free the string for one term option, if it was allocated.
+ * Set the string to empty_option and clear allocated flag.
+ * "var" points to the option value.
+ */
+    void
+free_one_termoption(var)
+    char_u *var;
+{
+    struct vimoption   *p;
+
+    for (p = &options[0]; p->fullname != NULL; p++)
+	if (p->var == var)
+	{
+	    if (p->flags & P_ALLOCED)
+		free_string_option(*(char_u **)(p->var));
+	    *(char_u **)(p->var) = empty_option;
+	    p->flags &= ~P_ALLOCED;
+	    break;
+	}
+}
+
+/*
  * Set the terminal option defaults to the current value.
  * Used after setting the terminal name.
  */
     void
 set_term_defaults()
@@ -9269,14 +9450,13 @@ check_win_options(win)
 }
 
 /*
  * Check for NULL pointers in a winopt_T and replace them with empty_option.
  */
-/*ARGSUSED*/
     void
 check_winopt(wop)
-    winopt_T	*wop;
+    winopt_T	*wop UNUSED;
 {
 #ifdef FEAT_FOLDING
     check_string_option(&wop->wo_fdi);
     check_string_option(&wop->wo_fdm);
 # ifdef FEAT_EVAL
@@ -9294,14 +9474,13 @@ check_winopt(wop)
 }
 
 /*
  * Free the allocated memory inside a winopt_T.
  */
-/*ARGSUSED*/
     void
 clear_winopt(wop)
-    winopt_T	*wop;
+    winopt_T	*wop UNUSED;
 {
 #ifdef FEAT_FOLDING
     clear_string_option(&wop->wo_fdi);
     clear_string_option(&wop->wo_fdm);
 # ifdef FEAT_EVAL
@@ -9643,11 +9822,11 @@ set_context_in_set_cmd(xp, arg, opt_flag
 	    ++p;
 	    break;
 	}
 	--p;
     }
-    if (STRNCMP(p, "no", 2) == 0)
+    if (STRNCMP(p, "no", 2) == 0 && STRNCMP(p, "novice", 6) != 0)
     {
 	xp->xp_context = EXPAND_BOOL_SETTINGS;
 	p += 2;
     }
     if (STRNCMP(p, "inv", 3) == 0)
@@ -9832,11 +10011,12 @@ ExpandSettings(xp, regmatch, num_file, f
     for (loop = 0; loop <= 1; ++loop)
     {
 	regmatch->rm_ic = ic;
 	if (xp->xp_context != EXPAND_BOOL_SETTINGS)
 	{
-	    for (match = 0; match < sizeof(names) / sizeof(char *); ++match)
+	    for (match = 0; match < (int)(sizeof(names) / sizeof(char *));
+								      ++match)
 		if (vim_regexec(regmatch, (char_u *)names[match], (colnr_T)0))
 		{
 		    if (loop == 0)
 			num_normal++;
 		    else
@@ -10091,29 +10271,114 @@ wc_use_keyname(varp, wcp)
     return FALSE;
 }
 
 #ifdef FEAT_LANGMAP
 /*
- * Any character has an equivalent character.  This is used for keyboards that
- * have a special language mode that sends characters above 128 (although
- * other characters can be translated too).
+ * Any character has an equivalent 'langmap' character.  This is used for
+ * keyboards that have a special language mode that sends characters above
+ * 128 (although other characters can be translated too).  The "to" field is a
+ * Vim command character.  This avoids having to switch the keyboard back to
+ * ASCII mode when leaving Insert mode.
+ *
+ * langmap_mapchar[] maps any of 256 chars to an ASCII char used for Vim
+ * commands.
+ * When FEAT_MBYTE is defined langmap_mapga.ga_data is a sorted table of
+ * langmap_entry_T.  This does the same as langmap_mapchar[] for characters >=
+ * 256.
  */
+# ifdef FEAT_MBYTE
+/*
+ * With multi-byte support use growarray for 'langmap' chars >= 256
+ */
+typedef struct
+{
+    int	    from;
+    int     to;
+} langmap_entry_T;
+
+static garray_T langmap_mapga;
+static void langmap_set_entry __ARGS((int from, int to));
+
+/*
+ * Search for an entry in "langmap_mapga" for "from".  If found set the "to"
+ * field.  If not found insert a new entry at the appropriate location.
+ */
+    static void
+langmap_set_entry(from, to)
+    int    from;
+    int    to;
+{
+    langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);
+    int             a = 0;
+    int             b = langmap_mapga.ga_len;
+
+    /* Do a binary search for an existing entry. */
+    while (a != b)
+    {
+	int i = (a + b) / 2;
+	int d = entries[i].from - from;
+
+	if (d == 0)
+	{
+	    entries[i].to = to;
+	    return;
+	}
+	if (d < 0)
+	    a = i + 1;
+	else
+	    b = i;
+    }
+
+    if (ga_grow(&langmap_mapga, 1) != OK)
+	return;  /* out of memory */
+
+    /* insert new entry at position "a" */
+    entries = (langmap_entry_T *)(langmap_mapga.ga_data) + a;
+    mch_memmove(entries + 1, entries,
+			(langmap_mapga.ga_len - a) * sizeof(langmap_entry_T));
+    ++langmap_mapga.ga_len;
+    entries[0].from = from;
+    entries[0].to = to;
+}
 
 /*
- * char_u langmap_mapchar[256];
- * Normally maps each of the 128 upper chars to an <128 ascii char; used to
- * "translate" native lang chars in normal mode or some cases of
- * insert mode without having to tediously switch lang mode back&forth.
+ * Apply 'langmap' to multi-byte character "c" and return the result.
  */
+    int
+langmap_adjust_mb(c)
+    int c;
+{
+    langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);
+    int a = 0;
+    int b = langmap_mapga.ga_len;
+
+    while (a != b)
+    {
+	int i = (a + b) / 2;
+	int d = entries[i].from - c;
+
+	if (d == 0)
+	    return entries[i].to;  /* found matching entry */
+	if (d < 0)
+	    a = i + 1;
+	else
+	    b = i;
+    }
+    return c;  /* no entry found, return "c" unmodified */
+}
+# endif
 
     static void
 langmap_init()
 {
     int i;
 
-    for (i = 0; i < 256; i++)		/* we init with a-one-to one map */
-	langmap_mapchar[i] = i;
+    for (i = 0; i < 256; i++)
+	langmap_mapchar[i] = i;	 /* we init with a one-to-one map */
+# ifdef FEAT_MBYTE
+    ga_init2(&langmap_mapga, sizeof(langmap_entry_T), 8);
+# endif
 }
 
 /*
  * Called when langmap option is set; the language map can be
  * changed at any time!
@@ -10123,11 +10388,14 @@ langmap_set()
 {
     char_u  *p;
     char_u  *p2;
     int	    from, to;
 
-    langmap_init();			    /* back to one-to-one map first */
+#ifdef FEAT_MBYTE
+    ga_clear(&langmap_mapga);		    /* clear the previous map first */
+#endif
+    langmap_init();			    /* back to one-to-one map */
 
     for (p = p_langmap; p[0] != NUL; )
     {
 	for (p2 = p; p2[0] != NUL && p2[0] != ',' && p2[0] != ';';
 							       mb_ptr_adv(p2))
@@ -10173,11 +10441,17 @@ langmap_set()
 	    {
 		EMSG2(_("E357: 'langmap': Matching character missing for %s"),
 							     transchar(from));
 		return;
 	    }
-	    langmap_mapchar[from & 255] = to;
+
+#ifdef FEAT_MBYTE
+	    if (from >= 256)
+		langmap_set_entry(from, to);
+	    else
+#endif
+		langmap_mapchar[from & 255] = to;
 
 	    /* Advance to next pair */
 	    mb_ptr_adv(p);
 	    if (p2 == NULL)
 	    {
--- vim72.orig/runtime/doc/cmdline.txt
+++ vim72/runtime/doc/cmdline.txt
@@ -1,6 +1,6 @@
-*cmdline.txt*   For Vim version 7.2.  Last change: 2008 Jul 29
+*cmdline.txt*   For Vim version 7.2.  Last change: 2008 Sep 18
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
 
 
@@ -155,10 +155,15 @@ CTRL-R {0-9a-z"%#:-=.}					*c_CTRL-R* *c
 			'='	the expression register: you are prompted to
 				enter an expression (see |expression|)
 				(doesn't work at the expression prompt; some
 				things such as changing the buffer or current
 				window are not allowed to avoid side effects)
+				When the result is a |List| the items are used
+				as lines.  They can have line breaks inside
+				too.
+				When the result is a Float it's automatically
+				converted to a String.
 		See |registers| about registers.  {not in Vi}
 		Implementation detail: When using the |expression| register
 		and invoking setcmdpos(), this sets the position before
 		inserting the resulting string.  Use CTRL-R CTRL-R to set the
 		position afterwards.
@@ -434,17 +439,24 @@ matching files with the next.
 For file name completion you can use the 'suffixes' option to set a priority
 between files with almost the same name.  If there are multiple matches,
 those files with an extension that is in the 'suffixes' option are ignored.
 The default is ".bak,~,.o,.h,.info,.swp,.obj", which means that files ending
 in ".bak", "~", ".o", ".h", ".info", ".swp" and ".obj" are sometimes ignored.
-It is impossible to ignore suffixes with two dots.  Examples:
+
+An empty entry, two consecutive commas, match a file name that does not
+contain a ".", thus has no suffix.  This is useful to ignore "prog" and prefer
+"prog.c".
+
+Examples:
 
   pattern:	files:				match:	~
    test*	test.c test.h test.o		test.c
    test*	test.h test.o			test.h and test.o
    test*	test.i test.h test.c		test.i and test.c
 
+It is impossible to ignore suffixes with two dots.
+
 If there is more than one matching file (after ignoring the ones matching
 the 'suffixes' option) the first file name is inserted.  You can see that
 there is only one match when you type 'wildchar' twice and the completed
 match stays the same.  You can get to the other matches by entering
 'wildchar', CTRL-N or CTRL-P.  All files are included, also the ones with
@@ -728,23 +740,33 @@ to use |fnameescape()|.
 
 
 In Ex commands, at places where a file name can be used, the following
 characters have a special meaning.  These can also be used in the expression
 function expand() |expand()|.
-	%	is replaced with the current file name			*:_%*
-	#	is replaced with the alternate file name		*:_#*
+	%	Is replaced with the current file name.		  *:_%* *c_%*
+	#	Is replaced with the alternate file name.	  *:_#* *c_#*
 	#n	(where n is a number) is replaced with the file name of
-		buffer n.  "#0" is the same as "#"
-	##	is replaced with all names in the argument list		*:_##*
+		buffer n.  "#0" is the same as "#".
+	##	Is replaced with all names in the argument list	  *:_##* *c_##*
 		concatenated, separated by spaces.  Each space in a name
 		is preceded with a backslash.
-Note that these give the file name as it was typed.  If an absolute path is
-needed (when using the file name from a different directory), you need to add
-":p".  See |filename-modifiers|.
+	#<n	(where n is a number > 0) is replaced with old	  *:_#<* *c_#<*
+		file name n.  See |:oldfiles| or |v:oldfiles| to get the
+		number.							*E809*
+		{only when compiled with the +eval and +viminfo features}
+
+Note that these, except "#<n", give the file name as it was typed.  If an
+absolute path is needed (when using the file name from a different directory),
+you need to add ":p".  See |filename-modifiers|.
+
+The "#<n" item returns an absolute path, but it will start with "~/" for files
+below your home directory.
+
 Note that backslashes are inserted before spaces, so that the command will
 correctly interpret the file name.  But this doesn't happen for shell
-commands.  For those you probably have to use quotes: >
+commands.  For those you probably have to use quotes (this fails for files
+that contain a quote and wildcards): >
 	:!ls "%"
 	:r !spell "%"
 
 To avoid the special meaning of '%' and '#' insert a backslash before it.
 Detail: The special meaning is always escaped when there is a backslash before
--- vim72.orig/runtime/doc/eval.txt
+++ vim72/runtime/doc/eval.txt
@@ -1,6 +1,6 @@
-*eval.txt*	For Vim version 7.2.  Last change: 2008 Aug 09
+*eval.txt*	For Vim version 7.2.  Last change: 2008 Nov 27
 
 
 		  VIM REFERENCE MANUAL	  by Bram Moolenaar
 
 
@@ -1482,10 +1482,21 @@ v:mouse_lnum	Line number for a mouse cli
 					*v:mouse_col* *mouse_col-variable*
 v:mouse_col	Column number for a mouse click obtained with |getchar()|.
 		This is the screen column number, like with |virtcol()|.  The
 		value is zero when there was no mouse button click.
 
+					*v:oldfiles* *oldfiles-variable*
+v:oldfiles	List of file names that is loaded from the |viminfo| file on
+		startup.  These are the files that Vim remembers marks for.
+		The length of the List is limited by the ' argument of the
+		'viminfo' option (default is 100).
+		Also see |:oldfiles| and |c_#<|.
+		The List can be modified, but this has no effect on what is
+		stored in the |viminfo| file later.  If you use values other
+		than String this will cause trouble.
+		{only when compiled with the +viminfo feature}
+
 					*v:operator* *operator-variable*
 v:operator	The last operator given in Normal mode.  This is a single
 		character except for commands starting with <g> or <z>,
 		in which case it is two characters.  Best used alongside
 		|v:prevcount| and |v:register|.  Useful if you want to cancel
@@ -1693,11 +1704,11 @@ eval( {string})			any	evaluate {string}
 eventhandler( )			Number	TRUE if inside an event handler
 executable( {expr})		Number	1 if executable {expr} exists
 exists( {expr})			Number	TRUE if {expr} exists
 extend({expr1}, {expr2} [, {expr3}])
 				List/Dict insert items of {expr2} into {expr1}
-expand( {expr})			String	expand special keywords in {expr}
+expand( {expr} [, {flag}])	String	expand special keywords in {expr}
 feedkeys( {string} [, {mode}])	Number	add key sequence to typeahead buffer
 filereadable( {file})		Number	TRUE if {file} is a readable file
 filewritable( {file})		Number	TRUE if {file} is a writable file
 filter( {expr}, {string})	List/Dict  remove items from {expr} where
 					{string} is 0
@@ -1745,12 +1756,13 @@ getregtype( [{regname}])	String	type of
 gettabwinvar( {tabnr}, {winnr}, {name})
 				any	{name} in {winnr} in tab page {tabnr}
 getwinposx()			Number	X coord in pixels of GUI Vim window
 getwinposy()			Number	Y coord in pixels of GUI Vim window
 getwinvar( {nr}, {varname})	any	variable {varname} in window {nr}
-glob( {expr})			String	expand file wildcards in {expr}
-globpath( {path}, {expr})	String	do glob({expr}) for all dirs in {path}
+glob( {expr} [, {flag}])	String	expand file wildcards in {expr}
+globpath( {path}, {expr} [, {flag}])
+				String	do glob({expr}) for all dirs in {path}
 has( {feature})			Number	TRUE if feature {feature} supported
 has_key( {dict}, {key})		Number	TRUE if {dict} has entry {key}
 haslocaldir()			Number	TRUE if current window executed |:lcd|
 hasmapto( {what} [, {mode} [, {abbr}]])
 				Number	TRUE if mapping to {what} exists
@@ -1801,15 +1813,16 @@ matchend( {expr}, {pat}[, {start}[, {cou
 				Number	position where {pat} ends in {expr}
 matchlist( {expr}, {pat}[, {start}[, {count}]])
 				List	match and submatches of {pat} in {expr}
 matchstr( {expr}, {pat}[, {start}[, {count}]])
 				String	{count}'th match of {pat} in {expr}
-max({list})			Number	maximum value of items in {list}
-min({list})			Number	minimum value of items in {list}
-mkdir({name} [, {path} [, {prot}]])
+max( {list})			Number	maximum value of items in {list}
+min( {list})			Number	minimum value of items in {list}
+mkdir( {name} [, {path} [, {prot}]])
 				Number	create directory {name}
 mode( [expr])			String	current editing mode
+mzeval( {expr})			any	evaluate |MzScheme| expression
 nextnonblank( {lnum})		Number	line nr of non-blank line >= {lnum}
 nr2char( {expr})		String	single char with ASCII value {expr}
 pathshorten( {expr})		String	shorten directory names in a path
 pow( {x}, {y})			Float	{x} to the power of {y}
 prevnonblank( {lnum})		Number	line nr of non-blank line <= {lnum}
@@ -2400,10 +2413,11 @@ cursor({list})
 		line.
 		If {col} is zero, the cursor will stay in the current column.
 		When 'virtualedit' is used {off} specifies the offset in
 		screen columns from the start of the character.  E.g., a
 		position within a <Tab> or after the last character.
+		Returns 0 when the position could be set, -1 otherwise.
 
 
 deepcopy({expr}[, {noref}])				*deepcopy()* *E698*
 		Make a copy of {expr}.	For Numbers and Strings this isn't
 		different from using {expr} directly.
@@ -3273,18 +3287,20 @@ getwinvar({winnr}, {varname})				*getwin
 		Like |gettabwinvar()| for the current tabpage.
 		Examples: >
 			:let list_is_on = getwinvar(2, '&list')
 			:echo "myvar = " . getwinvar(1, 'myvar')
 <
-							*glob()*
-glob({expr})	Expand the file wildcards in {expr}.  See |wildcards| for the
+glob({expr} [, {flag}])					*glob()*
+		Expand the file wildcards in {expr}.  See |wildcards| for the
 		use of special characters.
 		The result is a String.
 		When there are several matches, they are separated by <NL>
 		characters.
-		The 'wildignore' option applies: Names matching one of the
-		patterns in 'wildignore' will be skipped.
+		Unless the optional {flag} argument is given and is non-zero,
+		the 'suffixes' and 'wildignore' options apply: Names matching
+		one of the patterns in 'wildignore' will be skipped and
+		'suffixes' affect the ordering of matches.
 		If the expansion fails, the result is an empty string.
 		A name for a non-existing file is not included.
 
 		For most systems backticks can be used to get files names from
 		any external command.  Example: >
@@ -3294,24 +3310,26 @@ glob({expr})	Expand the file wildcards i
 		item per line.	Spaces inside an item are allowed.
 
 		See |expand()| for expanding special Vim variables.  See
 		|system()| for getting the raw output of an external command.
 
-globpath({path}, {expr})				*globpath()*
+globpath({path}, {expr} [, {flag}])			*globpath()*
 		Perform glob() on all directories in {path} and concatenate
 		the results.  Example: >
 			:echo globpath(&rtp, "syntax/c.vim")
 <		{path} is a comma-separated list of directory names.  Each
 		directory name is prepended to {expr} and expanded like with
-		glob().  A path separator is inserted when needed.
+		|glob()|.  A path separator is inserted when needed.
 		To add a comma inside a directory name escape it with a
 		backslash.  Note that on MS-Windows a directory may have a
 		trailing backslash, remove it if you put a comma after it.
 		If the expansion fails for one of the directories, there is no
 		error message.
-		The 'wildignore' option applies: Names matching one of the
-		patterns in 'wildignore' will be skipped.
+		Unless the optional {flag} argument is given and is non-zero,
+		the 'suffixes' and 'wildignore' options apply: Names matching
+		one of the patterns in 'wildignore' will be skipped and
+		'suffixes' affect the ordering of matches.
 
 		The "**" item can be used to search in a directory tree.
 		For example, to find all "README.txt" files in the directories
 		in 'runtimepath' and below: >
 			:echo globpath(&rtp, "**/README.txt")
@@ -3783,11 +3801,12 @@ log10({expr})						*log10()*
 map({expr}, {string})					*map()*
 		{expr} must be a |List| or a |Dictionary|.
 		Replace each item in {expr} with the result of evaluating
 		{string}.
 		Inside {string} |v:val| has the value of the current item.
-		For a |Dictionary| |v:key| has the key of the current item.
+		For a |Dictionary| |v:key| has the key of the current item
+		and for a |List| |v:key| has the index of the current item.
 		Example: >
 			:call map(mylist, '"> " . v:val . " <"')
 <		This puts "> " before and " <" after each item in "mylist".
 
 		Note that {string} is the result of an expression and is then
@@ -4070,10 +4089,27 @@ mode([expr])	Return a string that indica
 		This is useful in the 'statusline' option or when used
 		with |remote_expr()| In most other places it always returns
 		"c" or "n".
 		Also see |visualmode()|.
 
+mzeval({expr})							*mzeval()*
+		Evaluate MzScheme expression {expr} and return its result
+		convert to Vim data structures.
+		Numbers and strings are returned as they are.
+		Pairs (including lists and improper lists) and vectors are
+		returned as Vim |Lists|.
+		Hash tables are represented as Vim |Dictionary| type with keys
+		converted to strings.
+		All other types are converted to string with display function.
+		Examples: >
+		    :mz (define l (list 1 2 3))
+		    :mz (define h (make-hash)) (hash-set! h "list" l)
+		    :echo mzeval("l")
+		    :echo mzeval("h")
+<
+		{only available when compiled with the |+mzscheme| feature}
+
 nextnonblank({lnum})					*nextnonblank()*
 		Return the line number of the first line at or below {lnum}
 		that is not blank.  Example: >
 			if getline(nextnonblank(1)) =~ "Java"
 <		When {lnum} is invalid or there is no non-blank line at or
@@ -4498,10 +4534,11 @@ remove({dict}, {key})
 rename({from}, {to})					*rename()*
 		Rename the file by the name {from} to the name {to}.  This
 		should also work to move files across file systems.  The
 		result is a Number, which is 0 if the file was renamed
 		successfully, and non-zero when the renaming failed.
+		NOTE: If {to} exists it is overwritten without warning.
 		This function is not available in the |sandbox|.
 
 repeat({expr}, {count})					*repeat()*
 		Repeat {expr} {count} times and return the concatenated
 		result.  Example: >
@@ -5330,18 +5367,23 @@ synIDattr({synID}, {what} [, {mode}])
 		{what}		result
 		"name"		the name of the syntax item
 		"fg"		foreground color (GUI: color name used to set
 				the color, cterm: color number as a string,
 				term: empty string)
-		"bg"		background color (like "fg")
+		"bg"		background color (as with "fg")
+		"font"		font name (only available in the GUI)
+				|highlight-font|
+		"sp"		special color (as with "fg") |highlight-guisp|
 		"fg#"		like "fg", but for the GUI and the GUI is
 				running the name in "#RRGGBB" form
 		"bg#"		like "fg#" for "bg"
+		"sp#"		like "fg#" for "sp"
 		"bold"		"1" if bold
 		"italic"	"1" if italic
 		"reverse"	"1" if reverse
 		"inverse"	"1" if inverse (= reverse)
+		"standout"	"1" if standout
 		"underline"	"1" if underlined
 		"undercurl"	"1" if undercurled
 
 		Example (echoes the color of the syntax item under the
 		cursor): >
@@ -5821,11 +5863,12 @@ mouse_dec		Compiled with support for Dec
 mouse_gpm		Compiled with support for gpm (Linux console mouse)
 mouse_netterm		Compiled with support for netterm mouse.
 mouse_pterm		Compiled with support for qnx pterm mouse.
 mouse_sysmouse		Compiled with support for sysmouse (*BSD console mouse)
 mouse_xterm		Compiled with support for xterm mouse.
-multi_byte		Compiled with support for editing Korean et al.
+multi_byte		Compiled with support for 'encoding'
+multi_byte_encoding	'encoding' is set to a multi-byte encoding.
 multi_byte_ime		Compiled with support for IME input method.
 multi_lang		Compiled with support for multiple languages.
 mzscheme		Compiled with MzScheme interface |mzscheme|.
 netbeans_intg		Compiled with support for |netbeans|.
 netbeans_enabled	Compiled with support for |netbeans| and it's used.
@@ -5846,10 +5889,11 @@ ruby			Compiled with Ruby interface |rub
 scrollbind		Compiled with 'scrollbind' support.
 showcmd			Compiled with 'showcmd' support.
 signs			Compiled with |:sign| support.
 smartindent		Compiled with 'smartindent' support.
 sniff			Compiled with SNiFF interface support.
+startuptime		Compiled with |--startuptime| support.
 statusline		Compiled with support for 'statusline', 'rulerformat'
 			and special formats of 'titlestring' and 'iconstring'.
 sun_workshop		Compiled with support for Sun |workshop|.
 spell			Compiled with spell checking support |spell|.
 syntax			Compiled with syntax highlighting support |syntax|.
--- vim72.orig/runtime/doc/starting.txt
+++ vim72/runtime/doc/starting.txt
@@ -1,6 +1,6 @@
-*starting.txt*  For Vim version 7.2.  Last change: 2008 Jun 21
+*starting.txt*  For Vim version 7.2.  Last change: 2008 Nov 09
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
 
 
@@ -142,10 +142,18 @@ a slash.  Thus "-R" means recovery and "
 			(nothing)		yes		    yes
 			-u NONE			no		    no
 			-u NORC			no		    yes
 			--noplugin		yes		    no
 
+--startuptime {fname}					*--startuptime*
+		During startup write timing messages to the file {fname}.
+		This can be used to find out where time is spent while loading
+		your .vimrc, plugins and opening the first file.
+		When {fname} already exists new messages are appended.
+		(Only available when compiled with the |+startuptime|
+		feature).
+
 							*--literal*
 --literal	Take file names literally, don't expand wildcards.  Not needed
 		for Unix, because Vim always takes file names literally (the
 		shell expands wildcards).
 		Applies to all the names, also the ones that come before this
@@ -469,10 +477,11 @@ a slash.  Thus "-R" means recovery and "
 							*-X*
 -X		Do not try connecting to the X server to get the current
 		window title and copy/paste using the X clipboard.  This
 		avoids a long startup time when running Vim in a terminal
 		emulator and the connection to the X server is slow.
+		See |--startuptime| to find out if affects you.
 		Only makes a difference on Unix or VMS, when compiled with the
 		|+X11| feature.  Otherwise it's ignored.
 		To disable the connection only for specific terminals, see the
 		'clipboard' option.
 		When the X11 Session Management Protocol (XSMP) handler has
@@ -1335,12 +1344,13 @@ working on.  Viminfo and Session files t
 enter Vim and directly start working in your desired setup. |session-file|
 
 							*viminfo-read*
 When Vim is started and the 'viminfo' option is non-empty, the contents of
 the viminfo file are read and the info can be used in the appropriate places.
-The marks are not read in at startup (but file marks are).  See
-|initialization| for how to set the 'viminfo' option upon startup.
+The |v:oldfiles| variable is filled.  The marks are not read in at startup
+(but file marks are).  See |initialization| for how to set the 'viminfo'
+option upon startup.
 
 							*viminfo-write*
 When Vim exits and 'viminfo' is non-empty, the info is stored in the viminfo
 file (it's actually merged with the existing one, if one exists).  The
 'viminfo' option is a string containing information about what info should be
@@ -1370,10 +1380,12 @@ about to abandon with ":bdel", use ":wv"
 stored, but the '"' mark is.  The '"' mark is very useful for jumping to the
 cursor position when the file was last exited.  No marks are saved for files
 that start with any string given with the "r" flag in 'viminfo'.  This can be
 used to avoid saving marks for files on removable media (for MS-DOS you would
 use "ra:,rb:", for Amiga "rdf0:,rdf1:,rdf2:").
+The |v:oldfiles| variable is filled with the file names that the viminfo file
+has marks for.
 
 							*viminfo-file-marks*
 Uppercase marks ('A to 'Z) are stored when writing the viminfo file.  The
 numbered marks ('0 to '9) are a bit special.  When the viminfo file is written
 (when exiting or with the ":wviminfo" command), '0 is set to the current cursor
@@ -1461,12 +1473,12 @@ either have to fix the error, or delete
 most of the information will be restored).
 
 						   *:rv* *:rviminfo* *E195*
 :rv[iminfo][!] [file]	Read from viminfo file [file] (default: see above).
 			If [!] is given, then any information that is
-			already set (registers, marks, etc.) will be
-			overwritten.  {not in Vi}
+			already set (registers, marks, |v:oldfiles|, etc.)
+			will be overwritten   {not in Vi}
 
 					*:wv* *:wviminfo* *E137* *E138* *E574*
 :wv[iminfo][!] [file]	Write to viminfo file [file] (default: see above).
 			The information in the file is first read in to make
 			a merge between old and new info.  When [!] is used,
@@ -1477,6 +1489,22 @@ most of the information will be restored
 			check that no old temp files were left behind (e.g.
 			~/.viminf*) and that you can write in the directory of
 			the .viminfo file.
 			{not in Vi}
 
+						*:ol* *:oldfiles*
+:ol[dfiles]		List the files that have marks stored in the viminfo
+			file.  This list is read on startup and only changes
+			afterwards with ":rviminfo!".  Also see |v:oldfiles|.
+			The number can be used with |c_#<|.
+			{not in Vi, only when compiled with the +eval feature}
+
+:bro[wse] ol[dfiles][!]
+			List file names as with |:oldfiles|, and then prompt
+			for a number.  When the number is valid that file from
+			the list is edited.
+			If you get the |press-enter| prompt you can press "q"
+			and still get the prompt to enter a file number.
+			Use ! to abondon a modified buffer. |abandon|
+			{not when compiled with tiny or small features}
+
  vim:tw=78:ts=8:ft=help:norl:
--- vim72.orig/runtime/doc/usr_21.txt
+++ vim72/runtime/doc/usr_21.txt
@@ -1,6 +1,6 @@
-*usr_21.txt*	For Vim version 7.2.  Last change: 2007 May 01
+*usr_21.txt*	For Vim version 7.2.  Last change: 2008 Nov 09
 
 		     VIM USER MANUAL - by Bram Moolenaar
 
 			   Go away and come back
 
@@ -151,11 +151,11 @@ See the 'viminfo' option and |viminfo-fi
 When you run Vim multiple times, the last one exiting will store its
 information.  This may cause information that previously exiting Vims stored
 to be lost.  Each item can be remembered only once.
 
 
-GETTING BACK TO WHERE YOU WERE
+GETTING BACK TO WHERE YOU STOPPED VIM
 
 You are halfway editing a file and it's time to leave for holidays.  You exit
 Vim and go enjoy yourselves, forgetting all about your work.  After a couple
 of weeks you start Vim, and type:
 >
@@ -166,10 +166,52 @@ And you are right back where you left Vi
 position that '0 pointed to is made '1.  And '1 is made to '2, and so forth.
 Mark '9 is lost.
    The |:marks| command is useful to find out where '0 to '9 will take you.
 
 
+GETTING BACK TO SOME FILE
+
+If you want to go back to a file that you edited recently, but not when
+exiting Vim, there is a slightly more complicated way.  You can see a list of
+files by typing the command: >
+
+	:oldfiles
+<	1: ~/.viminfo ~
+	2: ~/text/resume.txt ~
+	3: /tmp/draft ~
+
+Now you would like to edit the second file, which is in the list preceded by
+"2:".  You type: >
+
+	:e #<2
+
+Instead of ":e" you can use any command that has a file name argument, the
+"#<2" item works in the same place as "%" (current file name) and "#"
+(alternate file name).  So you can also split the window to edit the third
+file: >
+
+	:split #<3
+
+That #<123 thing is a bit complicated when you just want to edit a file.
+Fortunately there is a simpler way: >
+
+	:browse oldfiles
+<	1: ~/.viminfo ~
+	2: ~/text/resume.txt ~
+	3: /tmp/draft ~
+	-- More --
+
+You get the same list of files as with |:oldfiles|.  If you want to edit
+"resume.txt" first press "q" to stop the listing.  You will get a prompt:
+
+	Type number and <Enter> (empty cancels): ~
+
+Type "2" and press <Enter> to edit the second file.
+
+More info at |:oldfiles|, |v:oldfiles| and |c_#<|.
+
+
 MOVE INFO FROM ONE VIM TO ANOTHER
 
 You can use the ":wviminfo" and ":rviminfo" commands to save and restore the
 information while still running Vim.  This is useful for exchanging register
 contents between two instances of Vim, for example.  In the first Vim do: >
--- vim72.orig/src/feature.h
+++ vim72/src/feature.h
@@ -765,13 +765,17 @@
 # define FEAT_GUI_TABLINE
 #endif
 
 /*
  * +browse		":browse" command.
+ *			or just the ":browse" command modifier
  */
-#if defined(FEAT_NORMAL) && (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC))
-# define FEAT_BROWSE
+#if defined(FEAT_NORMAL)
+# define FEAT_BROWSE_CMD
+# if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC)
+#  define FEAT_BROWSE
+# endif
 #endif
 
 /*
  * +dialog_gui		Use GUI dialog.
  * +dialog_con		May use Console dialog.
@@ -838,14 +842,18 @@
  * DEBUG		Output a lot of debugging garbage.
  */
 /* #define DEBUG */
 
 /*
- * STARTUPTIME		Time the startup process.  Writes a "vimstartup" file
- *			with timestamps.
+ * STARTUPTIME		Time the startup process.  Writes a file with
+ *			timestamps.
  */
-/* #define STARTUPTIME "vimstartup" */
+#if defined(FEAT_NORMAL) \
+	&& ((defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)) \
+		|| defined(WIN3264))
+# define STARTUPTIME 1
+#endif
 
 /*
  * MEM_PROFILE		Debugging of memory allocation and freeing.
  */
 /* #define MEM_PROFILE */
--- vim72.orig/src/mark.c
+++ vim72/src/mark.c
@@ -882,14 +882,13 @@ ex_delmarks(eap)
 
 #if defined(FEAT_JUMPLIST) || defined(PROTO)
 /*
  * print the jumplist
  */
-/*ARGSUSED*/
     void
 ex_jumps(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     int		i;
     char_u	*name;
 
     cleanup_jumplist();
@@ -931,14 +930,13 @@ ex_jumps(eap)
 }
 
 /*
  * print the changelist
  */
-/*ARGSUSED*/
     void
 ex_changes(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     int		i;
     char_u	*name;
 
     /* Highlight title */
@@ -1021,10 +1019,13 @@ mark_adjust(line1, line2, amount, amount
 {
     int		i;
     int		fnum = curbuf->b_fnum;
     linenr_T	*lp;
     win_T	*win;
+#ifdef FEAT_WINDOWS
+    tabpage_T	*tab;
+#endif
 
     if (line2 < line1 && amount_after == 0L)	    /* nothing to do */
 	return;
 
     if (!cmdmod.lockmarks)
@@ -1062,11 +1063,11 @@ mark_adjust(line1, line2, amount, amount
 
 #ifdef FEAT_QUICKFIX
 	/* quickfix marks */
 	qf_mark_adjust(NULL, line1, line2, amount, amount_after);
 	/* location lists */
-	FOR_ALL_WINDOWS(win)
+	FOR_ALL_TAB_WINDOWS(tab, win)
 	    qf_mark_adjust(win, line1, line2, amount, amount_after);
 #endif
 
 #ifdef FEAT_SIGNS
 	sign_mark_adjust(line1, line2, amount, amount_after);
@@ -1084,11 +1085,11 @@ mark_adjust(line1, line2, amount, amount
 	one_adjust_nodel(&(saved_cursor.lnum));
 
     /*
      * Adjust items in all windows related to the current buffer.
      */
-    FOR_ALL_WINDOWS(win)
+    FOR_ALL_TAB_WINDOWS(tab, win)
     {
 #ifdef FEAT_JUMPLIST
 	if (!cmdmod.lockmarks)
 	    /* Marks in the jumplist.  When deleting lines, this may create
 	     * duplicate marks in the jumplist, they will be removed later. */
@@ -1625,19 +1626,21 @@ write_one_mark(fp_out, c, pos)
 	fprintf(fp_out, "\t%c\t%ld\t%d\n", c, (long)pos->lnum, (int)pos->col);
 }
 
 /*
  * Handle marks in the viminfo file:
- * fp_out == NULL   read marks for current buffer only
- * fp_out != NULL   copy marks for buffers not in buffer list
+ * fp_out != NULL: copy marks for buffers not in buffer list
+ * fp_out == NULL && (flags & VIF_WANT_MARKS): read marks for curbuf only
+ * fp_out == NULL && (flags & VIF_GET_OLDFILES | VIF_FORCEIT): fill v:oldfiles
  */
     void
-copy_viminfo_marks(virp, fp_out, count, eof)
+copy_viminfo_marks(virp, fp_out, count, eof, flags)
     vir_T	*virp;
     FILE	*fp_out;
     int		count;
     int		eof;
+    int		flags;
 {
     char_u	*line = virp->vir_line;
     buf_T	*buf;
     int		num_marked_files;
     int		load_marks;
@@ -1645,14 +1648,27 @@ copy_viminfo_marks(virp, fp_out, count,
     char_u	*str;
     int		i;
     char_u	*p;
     char_u	*name_buf;
     pos_T	pos;
+#ifdef FEAT_EVAL
+    list_T	*list = NULL;
+#endif
 
     if ((name_buf = alloc(LSIZE)) == NULL)
 	return;
     *name_buf = NUL;
+
+#ifdef FEAT_EVAL
+    if (fp_out == NULL && (flags & (VIF_GET_OLDFILES | VIF_FORCEIT)))
+    {
+	list = list_alloc();
+	if (list != NULL)
+	    set_vim_var_list(VV_OLDFILES, list);
+    }
+#endif
+
     num_marked_files = get_viminfo_parameter('\'');
     while (!eof && (count < num_marked_files || fp_out == NULL))
     {
 	if (line[0] != '>')
 	{
@@ -1679,18 +1695,23 @@ copy_viminfo_marks(virp, fp_out, count,
 	    p--;
 	if (*p)
 	    p++;
 	*p = NUL;
 
+#ifdef FEAT_EVAL
+	if (list != NULL)
+	    list_append_string(list, str, -1);
+#endif
+
 	/*
 	 * If fp_out == NULL, load marks for current buffer.
 	 * If fp_out != NULL, copy marks for buffers not in buflist.
 	 */
 	load_marks = copy_marks_out = FALSE;
 	if (fp_out == NULL)
 	{
-	    if (curbuf->b_ffname != NULL)
+	    if ((flags & VIF_WANT_MARKS) && curbuf->b_ffname != NULL)
 	    {
 		if (*name_buf == NUL)	    /* only need to do this once */
 		    home_replace(NULL, curbuf->b_ffname, name_buf, LSIZE, TRUE);
 		if (fnamecmp(str, name_buf) == 0)
 		    load_marks = TRUE;
--- vim72.orig/src/misc1.c
+++ vim72/src/misc1.c
@@ -1024,16 +1024,18 @@ open_line(dir, flags, old_indent)
 		if (lead_repl != NULL)
 		{
 		    int		c = 0;
 		    int		off = 0;
 
-		    for (p = lead_flags; *p && *p != ':'; ++p)
+		    for (p = lead_flags; *p != NUL && *p != ':'; )
 		    {
 			if (*p == COM_RIGHT || *p == COM_LEFT)
-			    c = *p;
+			    c = *p++;
 			else if (VIM_ISDIGIT(*p) || *p == '-')
 			    off = getdigits(&p);
+			else
+			    ++p;
 		    }
 		    if (c == COM_RIGHT)    /* right adjusted leader */
 		    {
 			/* find last non-white in the leader to line up with */
 			for (p = leader + lead_len - 1; p > leader
@@ -1117,11 +1119,11 @@ open_line(dir, flags, old_indent)
 				    break;
 			    }
 			    if (i != lead_repl_len)
 			    {
 				mch_memmove(p + lead_repl_len, p + i,
-				       (size_t)(lead_len - i - (leader - p)));
+				       (size_t)(lead_len - i - (p - leader)));
 				lead_len += lead_repl_len - i;
 			    }
 			}
 #endif
 			mch_memmove(p, lead_repl, (size_t)lead_repl_len);
@@ -2186,16 +2188,15 @@ del_chars(count, fixpos)
  * If "fixpos" is TRUE, don't leave the cursor on the NUL after the line.
  * Caller must have prepared for undo.
  *
  * return FAIL for failure, OK otherwise
  */
-/*ARGSUSED*/
     int
 del_bytes(count, fixpos_arg, use_delcombine)
     long	count;
     int		fixpos_arg;
-    int		use_delcombine;	    /* 'delcombine' option applies */
+    int		use_delcombine UNUSED;	    /* 'delcombine' option applies */
 {
     char_u	*oldp, *newp;
     colnr_T	oldlen;
     linenr_T	lnum = curwin->w_cursor.lnum;
     colnr_T	col = curwin->w_cursor.col;
@@ -2344,35 +2345,39 @@ truncate_line(fixpos)
 del_lines(nlines, undo)
     long	nlines;		/* number of lines to delete */
     int		undo;		/* if TRUE, prepare for undo */
 {
     long	n;
+    linenr_T	first = curwin->w_cursor.lnum;
 
     if (nlines <= 0)
 	return;
 
     /* save the deleted lines for undo */
-    if (undo && u_savedel(curwin->w_cursor.lnum, nlines) == FAIL)
+    if (undo && u_savedel(first, nlines) == FAIL)
 	return;
 
     for (n = 0; n < nlines; )
     {
 	if (curbuf->b_ml.ml_flags & ML_EMPTY)	    /* nothing to delete */
 	    break;
 
-	ml_delete(curwin->w_cursor.lnum, TRUE);
+	ml_delete(first, TRUE);
 	++n;
 
 	/* If we delete the last line in the file, stop */
-	if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)
+	if (first > curbuf->b_ml.ml_line_count)
 	    break;
     }
-    /* adjust marks, mark the buffer as changed and prepare for displaying */
-    deleted_lines_mark(curwin->w_cursor.lnum, n);
 
+    /* Correct the cursor position before calling deleted_lines_mark(), it may
+     * trigger a callback to display the cursor. */
     curwin->w_cursor.col = 0;
     check_cursor_lnum();
+
+    /* adjust marks, mark the buffer as changed and prepare for displaying */
+    deleted_lines_mark(first, n);
 }
 
     int
 gchar_pos(pos)
     pos_T *pos;
@@ -2620,10 +2625,12 @@ deleted_lines(lnum, count)
     changed_lines(lnum, 0, lnum + count, -count);
 }
 
 /*
  * Like deleted_lines(), but adjust marks first.
+ * Make sure the cursor is on a valid line before calling, a GUI callback may
+ * be triggered to display the cursor.
  */
     void
 deleted_lines_mark(lnum, count)
     linenr_T	lnum;
     long	count;
@@ -2715,10 +2722,13 @@ changed_common(lnum, col, lnume, xtra)
     colnr_T	col;
     linenr_T	lnume;
     long	xtra;
 {
     win_T	*wp;
+#ifdef FEAT_WINDOWS
+    tabpage_T	*tp;
+#endif
     int		i;
 #ifdef FEAT_JUMPLIST
     int		cols;
     pos_T	*p;
     int		add;
@@ -2767,19 +2777,19 @@ changed_common(lnum, col, lnume, xtra)
 		{
 		    /* changelist is full: remove oldest entry */
 		    curbuf->b_changelistlen = JUMPLISTSIZE - 1;
 		    mch_memmove(curbuf->b_changelist, curbuf->b_changelist + 1,
 					  sizeof(pos_T) * (JUMPLISTSIZE - 1));
-		    FOR_ALL_WINDOWS(wp)
+		    FOR_ALL_TAB_WINDOWS(tp, wp)
 		    {
 			/* Correct position in changelist for other windows on
 			 * this buffer. */
 			if (wp->w_buffer == curbuf && wp->w_changelistidx > 0)
 			    --wp->w_changelistidx;
 		    }
 		}
-		FOR_ALL_WINDOWS(wp)
+		FOR_ALL_TAB_WINDOWS(tp, wp)
 		{
 		    /* For other windows, if the position in the changelist is
 		     * at the end it stays at the end. */
 		    if (wp->w_buffer == curbuf
 			    && wp->w_changelistidx == curbuf->b_changelistlen)
@@ -2794,11 +2804,11 @@ changed_common(lnum, col, lnume, xtra)
 	 * takes you back to it. */
 	curwin->w_changelistidx = curbuf->b_changelistlen;
 #endif
     }
 
-    FOR_ALL_WINDOWS(wp)
+    FOR_ALL_TAB_WINDOWS(tp, wp)
     {
 	if (wp->w_buffer == curbuf)
 	{
 	    /* Mark this window to be redrawn later. */
 	    if (wp->w_redr_type < VALID)
@@ -2876,10 +2886,17 @@ changed_common(lnum, col, lnume, xtra)
 			 * may need to be redrawn */
 			wp->w_lines[i].wl_valid = FALSE;
 		    }
 #endif
 		}
+
+#ifdef FEAT_FOLDING
+	    /* Take care of side effects for setting w_topline when folds have
+	     * changed.  Esp. when the buffer was changed in another window. */
+	    if (hasAnyFolding(wp))
+		set_topline(wp, wp->w_topline);
+#endif
 	}
     }
 
     /* Call update_screen() later, which checks out what needs to be redrawn,
      * since it notices b_mod_set and then uses b_mod_*. */
@@ -2953,10 +2970,12 @@ check_status(buf)
     void
 change_warning(col)
     int	    col;		/* column for message; non-zero when in insert
 				   mode and 'showmode' is on */
 {
+    static char *w_readonly = N_("W10: Warning: Changing a readonly file");
+
     if (curbuf->b_did_warn == FALSE
 	    && curbufIsChanged() == 0
 #ifdef FEAT_AUTOCMD
 	    && !autocmd_busy
 #endif
@@ -2975,12 +2994,14 @@ change_warning(col)
 	 */
 	msg_start();
 	if (msg_row == Rows - 1)
 	    msg_col = col;
 	msg_source(hl_attr(HLF_W));
-	MSG_PUTS_ATTR(_("W10: Warning: Changing a readonly file"),
-						   hl_attr(HLF_W) | MSG_HIST);
+	MSG_PUTS_ATTR(_(w_readonly), hl_attr(HLF_W) | MSG_HIST);
+#ifdef FEAT_EVAL
+	set_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_readonly), -1);
+#endif
 	msg_clr_eos();
 	(void)msg_end();
 	if (msg_silent == 0 && !silent_mode)
 	{
 	    out_flush();
@@ -3243,13 +3264,13 @@ prompt_for_number(mouse_used)
     int		save_cmdline_row;
     int		save_State;
 
     /* When using ":silent" assume that <CR> was entered. */
     if (mouse_used != NULL)
-	MSG_PUTS(_("Type number or click with mouse (<Enter> cancels): "));
+	MSG_PUTS(_("Type number and <Enter> or click with mouse (empty cancels): "));
     else
-	MSG_PUTS(_("Choice number (<Enter> cancels): "));
+	MSG_PUTS(_("Type number and <Enter> (empty cancels): "));
 
     /* Set the state such that text can be selected/copied/pasted and we still
      * get mouse events. */
     save_cmdline_row = cmdline_row;
     cmdline_row = 0;
@@ -3262,10 +3283,11 @@ prompt_for_number(mouse_used)
 	/* don't call wait_return() now */
 	/* msg_putchar('\n'); */
 	cmdline_row = msg_row - 1;
 	need_wait_return = FALSE;
 	msg_didany = FALSE;
+	msg_didout = FALSE;
     }
     else
 	cmdline_row = save_cmdline_row;
     State = save_State;
 
@@ -3446,11 +3468,13 @@ init_homedir()
     {
 	char_u *homedrive, *homepath;
 
 	homedrive = mch_getenv((char_u *)"HOMEDRIVE");
 	homepath = mch_getenv((char_u *)"HOMEPATH");
-	if (homedrive != NULL && homepath != NULL
+	if (homepath == NULL || *homepath == NUL)
+	    homepath = "\\";
+	if (homedrive != NULL
 			   && STRLEN(homedrive) + STRLEN(homepath) < MAXPATHL)
 	{
 	    sprintf((char *)NameBuff, "%s%s", homedrive, homepath);
 	    if (NameBuff[0] != NUL)
 	    {
@@ -4139,14 +4163,13 @@ vim_setenv(name, val)
 
 #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
 /*
  * Function given to ExpandGeneric() to obtain an environment variable name.
  */
-/*ARGSUSED*/
     char_u *
 get_env_name(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
 # if defined(AMIGA) || defined(__MRC__) || defined(__SC__)
     /*
      * No environ[] on the Amiga and on the Mac (using MPW).
@@ -4643,11 +4666,10 @@ concat_fnames(fname1, fname2, sep)
 	STRCAT(dest, fname2);
     }
     return dest;
 }
 
-#if defined(FEAT_EVAL) || defined(FEAT_GETTEXT) || defined(PROTO)
 /*
  * Concatenate two strings and return the result in allocated memory.
  * Returns NULL when out of memory.
  */
     char_u  *
@@ -4664,11 +4686,10 @@ concat_str(str1, str2)
 	STRCPY(dest, str1);
 	STRCPY(dest + l, str2);
     }
     return dest;
 }
-#endif
 
 /*
  * Add a path separator to a file name, unless it already ends in a path
  * separator.
  */
@@ -4734,13 +4755,13 @@ find_start_comment(ind_maxcomment)	    /
 	/*
 	 * Check if the comment start we found is inside a string.
 	 * If it is then restrict the search to below this line and try again.
 	 */
 	line = ml_get(pos->lnum);
-	for (p = line; *p && (unsigned)(p - line) < pos->col; ++p)
+	for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)
 	    p = skip_string(p);
-	if ((unsigned)(p - line) <= pos->col)
+	if ((colnr_T)(p - line) <= pos->col)
 	    break;
 	cur_maxcomment = curwin->w_cursor.lnum - pos->lnum - 1;
 	if (cur_maxcomment <= 0)
 	{
 	    pos = NULL;
@@ -6267,11 +6288,11 @@ get_c_indent()
      * inserting new stuff.
      * For unknown reasons the cursor might be past the end of the line, thus
      * check for that.
      */
     if ((State & INSERT)
-	    && curwin->w_cursor.col < STRLEN(linecopy)
+	    && curwin->w_cursor.col < (colnr_T)STRLEN(linecopy)
 	    && linecopy[curwin->w_cursor.col] == ')')
 	linecopy[curwin->w_cursor.col] = NUL;
 
     theline = skipwhite(linecopy);
 
@@ -7704,15 +7725,18 @@ term_again:
 	}
 
 	/*
 	 * If the NEXT line is a function declaration, the current
 	 * line needs to be indented as a function type spec.
-	 * Don't do this if the current line looks like a comment
-	 * or if the current line is terminated, ie. ends in ';'.
+	 * Don't do this if the current line looks like a comment or if the
+	 * current line is terminated, ie. ends in ';', or if the current line
+	 * contains { or }: "void f() {\n if (1)"
 	 */
 	else if (cur_curpos.lnum < curbuf->b_ml.ml_line_count
 		&& !cin_nocode(theline)
+		&& vim_strchr(theline, '{') == NULL
+		&& vim_strchr(theline, '}') == NULL
 		&& !cin_ends_in(theline, (char_u *)":", NULL)
 		&& !cin_ends_in(theline, (char_u *)",", NULL)
 		&& cin_isfuncdecl(NULL, cur_curpos.lnum + 1)
 		&& !cin_isterminated(theline, FALSE, TRUE))
 	{
@@ -8424,10 +8448,50 @@ fast_breakcheck()
 	ui_breakcheck();
     }
 }
 
 /*
+ * Invoke expand_wildcards() for one pattern.
+ * Expand items like "%:h" before the expansion.
+ * Returns OK or FAIL.
+ */
+    int
+expand_wildcards_eval(pat, num_file, file, flags)
+    char_u	 **pat;		/* pointer to input pattern */
+    int		  *num_file;	/* resulting number of files */
+    char_u	***file;	/* array of resulting files */
+    int		   flags;	/* EW_DIR, etc. */
+{
+    int		ret = FAIL;
+    char_u	*eval_pat = NULL;
+    char_u	*exp_pat = *pat;
+    char_u      *ignored_msg;
+    int		usedlen;
+
+    if (*exp_pat == '%' || *exp_pat == '#' || *exp_pat == '<')
+    {
+	++emsg_off;
+	eval_pat = eval_vars(exp_pat, exp_pat, &usedlen,
+						    NULL, &ignored_msg, NULL);
+	--emsg_off;
+	if (eval_pat != NULL)
+	    exp_pat = concat_str(eval_pat, exp_pat + usedlen);
+    }
+
+    if (exp_pat != NULL)
+	ret = expand_wildcards(1, &exp_pat, num_file, file, flags);
+
+    if (eval_pat != NULL)
+    {
+	vim_free(exp_pat);
+	vim_free(eval_pat);
+    }
+
+    return ret;
+}
+
+/*
  * Expand wildcards.  Calls gen_expand_wildcards() and removes files matching
  * 'wildignore'.
  * Returns OK or FAIL.
  */
     int
@@ -8520,15 +8584,29 @@ match_suffix(fname)
     fnamelen = (int)STRLEN(fname);
     setsuflen = 0;
     for (setsuf = p_su; *setsuf; )
     {
 	setsuflen = copy_option_part(&setsuf, suf_buf, MAXSUFLEN, ".,");
-	if (fnamelen >= setsuflen
-		&& fnamencmp(suf_buf, fname + fnamelen - setsuflen,
-					      (size_t)setsuflen) == 0)
-	    break;
-	setsuflen = 0;
+	if (setsuflen == 0)
+	{
+	    char_u *tail = gettail(fname);
+
+	    /* empty entry: match name without a '.' */
+	    if (vim_strchr(tail, '.') == NULL)
+	    {
+		setsuflen = 1;
+		break;
+	    }
+	}
+	else
+	{
+	    if (fnamelen >= setsuflen
+		    && fnamencmp(suf_buf, fname + fnamelen - setsuflen,
+						  (size_t)setsuflen) == 0)
+		break;
+	    setsuflen = 0;
+	}
     }
     return (setsuflen != 0);
 }
 
 #if !defined(NO_EXPANDPATH) || defined(PROTO)
@@ -8726,11 +8804,11 @@ dos_expandpath(
     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
     {
 	/* The active codepage differs from 'encoding'.  Attempt using the
 	 * wide function.  If it fails because it is not implemented fall back
 	 * to the non-wide version (for Windows 98) */
-	wn = enc_to_ucs2(buf, NULL);
+	wn = enc_to_utf16(buf, NULL);
 	if (wn != NULL)
 	{
 	    hFind = FindFirstFileW(wn, &wfb);
 	    if (hFind == INVALID_HANDLE_VALUE
 			      && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
@@ -8754,11 +8832,11 @@ dos_expandpath(
     while (ok)
     {
 #ifdef WIN3264
 # ifdef FEAT_MBYTE
 	if (wn != NULL)
-	    p = ucs2_to_enc(wfb.cFileName, NULL);   /* p is allocated here */
+	    p = utf16_to_enc(wfb.cFileName, NULL);   /* p is allocated here */
 	else
 # endif
 	    p = (char_u *)fb.cFileName;
 #else
 	p = (char_u *)fb.ff_name;
@@ -8828,11 +8906,11 @@ dos_expandpath(
 	    FindClose(hFind);
 # ifdef FEAT_MBYTE
 	    if (wn != NULL)
 	    {
 		vim_free(wn);
-		wn = enc_to_ucs2(buf, NULL);
+		wn = enc_to_utf16(buf, NULL);
 		if (wn != NULL)
 		    hFind = FindFirstFileW(wn, &wfb);
 	    }
 	    if (wn == NULL)
 # endif
@@ -9186,11 +9264,11 @@ gen_expand_wildcards(num_pat, pat, num_f
 		 * found file names and start all over again.
 		 */
 		else if (vim_strpbrk(p, (char_u *)"$~") != NULL)
 		{
 		    vim_free(p);
-		    ga_clear(&ga);
+		    ga_clear_strings(&ga);
 		    i = mch_expand_wildcards(num_pat, pat, num_file, file,
 								       flags);
 		    recursive = FALSE;
 		    return i;
 		}
--- vim72.orig/src/proto/eval.pro
+++ vim72/src/proto/eval.pro
@@ -15,11 +15,11 @@ int eval_printexpr __ARGS((char_u *fname
 void eval_diff __ARGS((char_u *origfile, char_u *newfile, char_u *outfile));
 void eval_patch __ARGS((char_u *origfile, char_u *difffile, char_u *outfile));
 int eval_to_bool __ARGS((char_u *arg, int *error, char_u **nextcmd, int skip));
 char_u *eval_to_string_skip __ARGS((char_u *arg, char_u **nextcmd, int skip));
 int skip_expr __ARGS((char_u **pp));
-char_u *eval_to_string __ARGS((char_u *arg, char_u **nextcmd, int dolist));
+char_u *eval_to_string __ARGS((char_u *arg, char_u **nextcmd, int convert));
 char_u *eval_to_string_safe __ARGS((char_u *arg, char_u **nextcmd, int use_sandbox));
 int eval_to_number __ARGS((char_u *expr));
 list_T *eval_spell_expr __ARGS((char_u *badword, char_u *expr));
 int get_spellword __ARGS((list_T *list, char_u **pp));
 typval_T *eval_expr __ARGS((char_u *arg, char_u **nextcmd));
@@ -44,24 +44,33 @@ void del_menutrans_vars __ARGS((void));
 char_u *get_user_var_name __ARGS((expand_T *xp, int idx));
 list_T *list_alloc __ARGS((void));
 void list_unref __ARGS((list_T *l));
 void list_free __ARGS((list_T *l, int recurse));
 dictitem_T *dict_lookup __ARGS((hashitem_T *hi));
+char_u *list_find_str __ARGS((list_T *l, long idx));
+int list_append_tv __ARGS((list_T *l, typval_T *tv));
 int list_append_dict __ARGS((list_T *list, dict_T *dict));
+int list_append_string __ARGS((list_T *l, char_u *str, int len));
 int garbage_collect __ARGS((void));
 dict_T *dict_alloc __ARGS((void));
+dictitem_T *dictitem_alloc __ARGS((char_u *key));
+void dictitem_free __ARGS((dictitem_T *item));
+int dict_add __ARGS((dict_T *d, dictitem_T *item));
 int dict_add_nr_str __ARGS((dict_T *d, char *key, long nr, char_u *str));
 char_u *get_dict_string __ARGS((dict_T *d, char_u *key, int save));
 long get_dict_number __ARGS((dict_T *d, char_u *key));
 char_u *get_function_name __ARGS((expand_T *xp, int idx));
 char_u *get_expr_name __ARGS((expand_T *xp, int idx));
 long do_searchpair __ARGS((char_u *spat, char_u *mpat, char_u *epat, int dir, char_u *skip, int flags, pos_T *match_pos, linenr_T lnum_stop, long time_limit));
 void set_vim_var_nr __ARGS((int idx, long val));
 long get_vim_var_nr __ARGS((int idx));
 char_u *get_vim_var_str __ARGS((int idx));
-void set_vcount __ARGS((long count, long count1));
+list_T *get_vim_var_list __ARGS((int idx));
+void set_vim_var_char __ARGS((int c));
+void set_vcount __ARGS((long count, long count1, int set_prevcount));
 void set_vim_var_string __ARGS((int idx, char_u *val, int len));
+void set_vim_var_list __ARGS((int idx, list_T *val));
 void set_reg_var __ARGS((int c));
 char_u *v_exception __ARGS((char_u *oldval));
 char_u *v_throwpoint __ARGS((char_u *oldval));
 char_u *set_cmdarg __ARGS((exarg_T *eap, char_u *oldarg));
 void free_tv __ARGS((typval_T *varp));
@@ -70,10 +79,11 @@ long get_tv_number_chk __ARGS((typval_T
 char_u *get_tv_string_chk __ARGS((typval_T *varp));
 char_u *get_var_value __ARGS((char_u *name));
 void new_script_vars __ARGS((scid_T id));
 void init_var_dict __ARGS((dict_T *dict, dictitem_T *dict_var));
 void vars_clear __ARGS((hashtab_T *ht));
+void copy_tv __ARGS((typval_T *from, typval_T *to));
 void ex_echo __ARGS((exarg_T *eap));
 void ex_echohl __ARGS((exarg_T *eap));
 void ex_execute __ARGS((exarg_T *eap));
 void ex_function __ARGS((exarg_T *eap));
 void free_all_functions __ARGS((void));
@@ -92,8 +102,9 @@ int func_has_ended __ARGS((void *cookie)
 int func_has_abort __ARGS((void *cookie));
 int read_viminfo_varlist __ARGS((vir_T *virp, int writing));
 void write_viminfo_varlist __ARGS((FILE *fp));
 int store_session_globals __ARGS((FILE *fd));
 void last_set_msg __ARGS((scid_T scriptID));
+void ex_oldfiles __ARGS((exarg_T *eap));
 int modify_fname __ARGS((char_u *src, int *usedlen, char_u **fnamep, char_u **bufp, int *fnamelen));
 char_u *do_string_sub __ARGS((char_u *str, char_u *pat, char_u *sub, char_u *flags));
 /* vim: set ft=c : */
--- vim72.orig/src/proto/ex_cmds.pro
+++ vim72/src/proto/ex_cmds.pro
@@ -7,13 +7,13 @@ int do_move __ARGS((linenr_T line1, line
 void ex_copy __ARGS((linenr_T line1, linenr_T line2, linenr_T n));
 void free_prev_shellcmd __ARGS((void));
 void do_bang __ARGS((int addr_count, exarg_T *eap, int forceit, int do_in, int do_out));
 void do_shell __ARGS((char_u *cmd, int flags));
 char_u *make_filter_cmd __ARGS((char_u *cmd, char_u *itmp, char_u *otmp));
-void append_redir __ARGS((char_u *buf, char_u *opt, char_u *fname));
+void append_redir __ARGS((char_u *buf, int buflen, char_u *opt, char_u *fname));
 int viminfo_error __ARGS((char *errnum, char *message, char_u *line));
-int read_viminfo __ARGS((char_u *file, int want_info, int want_marks, int forceit));
+int read_viminfo __ARGS((char_u *file, int flags));
 void write_viminfo __ARGS((char_u *file, int forceit));
 int viminfo_readline __ARGS((vir_T *virp));
 char_u *viminfo_readstring __ARGS((vir_T *virp, int off, int convert));
 void viminfo_writestring __ARGS((FILE *fd, char_u *p));
 void do_fixdel __ARGS((exarg_T *eap));
@@ -25,11 +25,11 @@ void ex_write __ARGS((exarg_T *eap));
 int do_write __ARGS((exarg_T *eap));
 void ex_wnext __ARGS((exarg_T *eap));
 void do_wqall __ARGS((exarg_T *eap));
 int not_writing __ARGS((void));
 int getfile __ARGS((int fnum, char_u *ffname, char_u *sfname, int setpm, linenr_T lnum, int forceit));
-int do_ecmd __ARGS((int fnum, char_u *ffname, char_u *sfname, exarg_T *eap, linenr_T newlnum, int flags));
+int do_ecmd __ARGS((int fnum, char_u *ffname, char_u *sfname, exarg_T *eap, linenr_T newlnum, int flags, win_T *oldwin));
 void ex_append __ARGS((exarg_T *eap));
 void ex_change __ARGS((exarg_T *eap));
 void ex_z __ARGS((exarg_T *eap));
 int check_restricted __ARGS((void));
 int check_secure __ARGS((void));
@@ -53,7 +53,10 @@ void ex_sign __ARGS((exarg_T *eap));
 void sign_gui_started __ARGS((void));
 int sign_get_attr __ARGS((int typenr, int line));
 char_u *sign_get_text __ARGS((int typenr));
 void *sign_get_image __ARGS((int typenr));
 char_u *sign_typenr2name __ARGS((int typenr));
+void free_signs __ARGS((void));
+char_u *get_sign_name __ARGS((expand_T *xp, int idx));
+void set_context_in_sign_cmd __ARGS((expand_T *xp, char_u *arg));
 void ex_drop __ARGS((exarg_T *eap));
 /* vim: set ft=c : */
--- vim72.orig/src/proto/mark.pro
+++ vim72/src/proto/mark.pro
@@ -24,7 +24,7 @@ void set_last_cursor __ARGS((win_T *win)
 void free_all_marks __ARGS((void));
 int read_viminfo_filemark __ARGS((vir_T *virp, int force));
 void write_viminfo_filemarks __ARGS((FILE *fp));
 int removable __ARGS((char_u *name));
 int write_viminfo_marks __ARGS((FILE *fp_out));
-void copy_viminfo_marks __ARGS((vir_T *virp, FILE *fp_out, int count, int eof));
+void copy_viminfo_marks __ARGS((vir_T *virp, FILE *fp_out, int count, int eof, int flags));
 /* vim: set ft=c : */
--- vim72.orig/src/structs.h
+++ vim72/src/structs.h
@@ -14,11 +14,11 @@
  * There is something wrong in the SAS compiler that makes typedefs not
  * valid in include files.  Has been fixed in version 6.58.
  */
 #if defined(SASC) && SASC < 658
 typedef long		linenr_T;
-typedef unsigned	colnr_T;
+typedef int		colnr_T;
 typedef unsigned short	short_u;
 #endif
 
 /*
  * position in file or buffer
@@ -31,13 +31,13 @@ typedef struct
     colnr_T	coladd;
 #endif
 } pos_T;
 
 #ifdef FEAT_VIRTUALEDIT
-# define INIT_POS_T {0, 0, 0}
+# define INIT_POS_T(l, c, ca) {l, c, ca}
 #else
-# define INIT_POS_T {0, 0}
+# define INIT_POS_T(l, c, ca) {l, c}
 #endif
 
 /*
  * Same, but without coladd.
  */
@@ -430,10 +430,11 @@ struct buffheader
  */
 typedef struct expand
 {
     int		xp_context;		/* type of expansion */
     char_u	*xp_pattern;		/* start of item to expand */
+    int		xp_pattern_len;		/* bytes in xp_pattern before cursor */
 #if defined(FEAT_USR_CMDS) && defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
     char_u	*xp_arg;		/* completion function */
     int		xp_scriptID;		/* SID for completion function */
 #endif
     int		xp_backslash;		/* one of the XP_BS_ values */
@@ -457,11 +458,11 @@ typedef struct expand
  * easy manipulation.
  */
 typedef struct
 {
     int		hide;			/* TRUE when ":hide" was used */
-# ifdef FEAT_BROWSE
+# ifdef FEAT_BROWSE_CMD
     int		browse;			/* TRUE to invoke file dialog */
 # endif
 # ifdef FEAT_WINDOWS
     int		split;			/* flags for win_split() */
     int		tab;			/* > 0 when ":tab" was used */
@@ -880,10 +881,12 @@ typedef struct
 /* Struct to hold the saved typeahead for save_typeahead(). */
 typedef struct
 {
     typebuf_T		save_typebuf;
     int			typebuf_valid;	    /* TRUE when save_typebuf valid */
+    int			old_char;
+    int			old_mod_mask;
     struct buffheader	save_stuffbuff;
 #ifdef USE_INPUT_BUF
     char_u		*save_inputbuf;
 #endif
 } tasave_T;
@@ -1164,11 +1167,12 @@ struct file_buffer
     char_u	*b_ffname;	/* full path file name */
     char_u	*b_sfname;	/* short file name */
     char_u	*b_fname;	/* current file name */
 
 #ifdef UNIX
-    int		b_dev;		/* device number (-1 if not set) */
+    int		b_dev_valid;	/* TRUE when b_dev has a valid number */
+    dev_t	b_dev;		/* device number */
     ino_t	b_ino;		/* inode number */
 #endif
 #ifdef FEAT_CW_EDITOR
     FSSpec	b_FSSpec;	/* MacOS File Identification */
 #endif
@@ -1618,10 +1622,18 @@ struct diffblock_S
     linenr_T	df_lnum[DB_COUNT];	/* line number in buffer */
     linenr_T	df_count[DB_COUNT];	/* nr of inserted/changed lines */
 };
 #endif
 
+#define SNAP_HELP_IDX	0
+#ifdef FEAT_AUTOCMD
+# define SNAP_AUCMD_IDX 1
+# define SNAP_COUNT	2
+#else
+# define SNAP_COUNT	1
+#endif
+
 /*
  * Tab pages point to the top frame of each tab page.
  * Note: Most values are NOT valid for the current tab page!  Use "curwin",
  * "firstwin", etc. for that.  "tp_topframe" is always valid and can be
  * compared against "topframe" to find the current tab page.
@@ -1646,11 +1658,11 @@ struct tabpage_S
 #ifdef FEAT_DIFF
     diff_T	    *tp_first_diff;
     buf_T	    *(tp_diffbuf[DB_COUNT]);
     int		    tp_diff_invalid;	/* list of diffs is outdated */
 #endif
-    frame_T	    *tp_snapshot;    /* window layout snapshot */
+    frame_T	    *(tp_snapshot[SNAP_COUNT]);  /* window layout snapshots */
 #ifdef FEAT_EVAL
     dictitem_T	    tp_winvar;	    /* variable for "t:" Dictionary */
     dict_T	    tp_vars;	    /* internal variables, local to tab page */
 #endif
 };
@@ -1782,14 +1794,19 @@ struct window_S
     colnr_T	w_old_visual_col;   /* last known start of visual part */
     colnr_T	w_old_curswant;	    /* last known value of Curswant */
 #endif
 
     /*
-     * The next three specify the offsets for displaying the buffer:
+     * "w_topline", "w_leftcol" and "w_skipcol" specify the offsets for
+     * displaying the buffer.
      */
     linenr_T	w_topline;	    /* buffer line number of the line at the
 				       top of the window */
+#ifdef FEAT_AUTOCMD
+    char	w_topline_was_set;  /* flag set to TRUE when topline is set,
+				       e.g. by winrestview() */
+#endif
 #ifdef FEAT_DIFF
     int		w_topfill;	    /* number of filler lines above w_topline */
     int		w_old_topfill;	    /* w_topfill at last redraw */
     int		w_botfill;	    /* TRUE when filler lines are actually
 				       below w_topline (at end of file) */
@@ -2268,20 +2285,17 @@ typedef int vimmenu_T;
  * Struct to save values in before executing autocommands for a buffer that is
  * not the current buffer.  Without FEAT_AUTOCMD only "curbuf" is remembered.
  */
 typedef struct
 {
-    buf_T	*save_buf;	/* saved curbuf */
+    buf_T	*save_curbuf;	/* saved curbuf */
 #ifdef FEAT_AUTOCMD
-    buf_T	*new_curbuf;	/* buffer to be used */
-    win_T	*save_curwin;	/* saved curwin, NULL if it didn't change */
-    win_T	*new_curwin;	/* new curwin if save_curwin != NULL */
-    pos_T	save_cursor;	/* saved cursor pos of save_curwin */
-    linenr_T	save_topline;	/* saved topline of save_curwin */
-# ifdef FEAT_DIFF
-    int		save_topfill;	/* saved topfill of save_curwin */
-# endif
+    int		use_aucmd_win;	/* using aucmd_win */
+    win_T	*save_curwin;	/* saved curwin */
+    win_T	*new_curwin;	/* new curwin */
+    buf_T	*new_curbuf;	/* new curbuf */
+    char_u	*globaldir;	/* saved value of globaldir */
 #endif
 } aco_save_T;
 
 /*
  * Generic option table item, only used for printer at the moment.
--- vim72.orig/src/vim.h
+++ vim72/src/vim.h
@@ -50,11 +50,13 @@
 # endif
 #endif
 
 /* user ID of root is usually zero, but not for everybody */
 #ifdef __TANDEM
-# define _TANDEM_SOURCE
+# ifndef _TANDEM_SOURCE
+#  define _TANDEM_SOURCE
+# endif
 # include <floss.h>
 # define ROOT_UID 65535
 #else
 # define ROOT_UID 0
 #endif
@@ -260,10 +262,18 @@
 /* __ARGS and __PARMS are the same thing. */
 #ifndef __PARMS
 # define __PARMS(x) __ARGS(x)
 #endif
 
+/* Mark unused function arguments with UNUSED, so that gcc -Wunused-parameter
+ * can be used to check for mistakes. */
+#ifdef HAVE_ATTRIBUTE_UNUSED
+# define UNUSED __attribute__((unused))
+#else
+# define UNUSED
+#endif
+
 /* if we're compiling in C++ (currently only KVim), the system
  * headers must have the correct prototypes or nothing will build.
  * conversely, our prototypes might clash due to throw() specifiers and
  * cause compilation failures even though the headers are correct.  For
  * a concrete example, gcc-3.2 enforces exception specifications, and
@@ -339,12 +349,18 @@
 # endif
 #endif
 #ifdef BACKSLASH_IN_FILENAME
 # define PATH_ESC_CHARS ((char_u *)" \t\n*?[{`%#'\"|!<")
 #else
-# define PATH_ESC_CHARS ((char_u *)" \t\n*?[{`$\\%#'\"|!<")
-# define SHELL_ESC_CHARS ((char_u *)" \t\n*?[{`$\\%#'\"|!<>();&")
+# ifdef VMS
+    /* VMS allows a lot of characters in the file name */
+#  define PATH_ESC_CHARS ((char_u *)" \t\n*?{`\\%#'\"|!")
+#  define SHELL_ESC_CHARS ((char_u *)" \t\n*?{`\\%#'|!()&")
+# else
+#  define PATH_ESC_CHARS ((char_u *)" \t\n*?[{`$\\%#'\"|!<")
+#  define SHELL_ESC_CHARS ((char_u *)" \t\n*?[{`$\\%#'\"|!<>();&")
+# endif
 #endif
 
 #define NUMBUFLEN 30	    /* length of a buffer to store a number in ASCII */
 
 /*
@@ -368,11 +384,11 @@ typedef		 __int64        long_i;
    * that change size between 32-bit and 64-bit platforms.  For any such type,
    * __w64 should appear only on the 32-bit definition of the typedef.
    * Define __w64 as an empty token for everything but MSVC 7.x or later.
    */
 # if !defined(_MSC_VER)	|| (_MSC_VER < 1300)
-#  define __w64 
+#  define __w64
 # endif
 typedef unsigned long __w64	long_u;
 typedef		 long __w64     long_i;
 # define SCANF_HEX_LONG_U       "%lx"
 # define SCANF_DECIMAL_LONG_U   "%lu"
@@ -459,10 +475,27 @@ typedef unsigned long u8char_T;	    /* l
 #endif
 #ifdef HAVE_STDARG_H
 # include <stdarg.h>
 #endif
 
+# if defined(HAVE_SYS_SELECT_H) && \
+	(!defined(HAVE_SYS_TIME_H) || defined(SYS_SELECT_WITH_SYS_TIME))
+#  include <sys/select.h>
+# endif
+
+# ifndef HAVE_SELECT
+#  ifdef HAVE_SYS_POLL_H
+#   include <sys/poll.h>
+#   define HAVE_POLL
+#  else
+#   ifdef HAVE_POLL_H
+#    include <poll.h>
+#    define HAVE_POLL
+#   endif
+#  endif
+# endif
+
 /* ================ end of the header file puzzle =============== */
 
 /*
  * For dynamically loaded imm library. Currently, only for Win32.
  */
@@ -577,11 +610,11 @@ extern char *(*dyn_libintl_textdomain)(c
 #define VALID_BOTLINE_AP 0x40	/* w_botine is approximated */
 #define VALID_TOPLINE	0x80	/* w_topline is valid (for cursor position) */
 
 /*
  * Terminal highlighting attribute bits.
- * Attibutes above HL_ALL are used for syntax highlighting.
+ * Attributes above HL_ALL are used for syntax highlighting.
  */
 #define HL_NORMAL		0x00
 #define HL_INVERSE		0x01
 #define HL_BOLD			0x02
 #define HL_ITALIC		0x04
@@ -700,10 +733,14 @@ extern char *(*dyn_libintl_textdomain)(c
 #define EXPAND_COLORS		28
 #define EXPAND_COMPILER		29
 #define EXPAND_USER_DEFINED	30
 #define EXPAND_USER_LIST	31
 #define EXPAND_SHELLCMD		32
+#define EXPAND_CSCOPE		33
+#define EXPAND_SIGN		34
+#define EXPAND_PROFILE		35
+#define EXPAND_BEHAVE		36
 
 /* Values for exmode_active (0 is no exmode) */
 #define EXMODE_NORMAL		1
 #define EXMODE_VIM		2
 
@@ -1049,10 +1086,11 @@ extern char *(*dyn_libintl_textdomain)(c
 #define WSP_TOP		4	/* window at top-left of shell */
 #define WSP_BOT		8	/* window at bottom-right of shell */
 #define WSP_HELP	16	/* creating the help window */
 #define WSP_BELOW	32	/* put new window below/right */
 #define WSP_ABOVE	64	/* put new window above/left */
+#define WSP_NEWLOC	128	/* don't copy location list */
 
 /*
  * arguments for gui_set_shellsize()
  */
 #define RESIZE_VERT	1	/* resize vertically */
@@ -1240,11 +1278,11 @@ typedef enum
     , HLF_CUL	    /* 'cursurline' */
     , HLF_COUNT	    /* MUST be the last one */
 } hlf_T;
 
 /* The HL_FLAGS must be in the same order as the HLF_ enums!
- * When chainging this also adjust the default for 'highlight'. */
+ * When changing this also adjust the default for 'highlight'. */
 #define HL_FLAGS {'8', '@', 'd', 'e', 'h', 'i', 'l', 'm', 'M', \
 		  'n', 'r', 's', 'S', 'c', 't', 'v', 'V', 'w', 'W', \
 		  'f', 'F', 'A', 'C', 'D', 'T', '>', \
 		  'B', 'P', 'R', 'L', \
 		  '+', '=', 'x', 'X', '*', '#', '_', '!', '.'}
@@ -1326,15 +1364,15 @@ typedef enum
 #else
 # define MSG_BUF_LEN 80		/* length of buffer for small messages */
 # define MSG_BUF_CLEN  MSG_BUF_LEN	    /* cell length */
 #endif
 
-#if defined(AMIGA) || defined(__linux__) || defined(__QNX__) || defined(__CYGWIN32__) || defined(_AIX)
-# define TBUFSZ 2048		/* buffer size for termcap entry */
-#else
-# define TBUFSZ 1024		/* buffer size for termcap entry */
-#endif
+/* Size of the buffer used for tgetent().  Unfortunately this is largely
+ * undocumented, some systems use 1024.  Using a buffer that is too small
+ * causes a buffer overrun and a crash.  Use the maximum known value to stay
+ * on the safe side. */
+#define TBUFSZ 2048		/* buffer size for termcap entry */
 
 /*
  * Maximum length of key sequence to be mapped.
  * Must be able to hold an Amiga resize report.
  */
@@ -1408,11 +1446,11 @@ typedef enum
 #endif
 
 #ifdef FEAT_MBYTE
 /* We need to call mb_stricmp() even when we aren't dealing with a multi-byte
  * encoding because mb_stricmp() takes care of all ascii and non-ascii
- * encodings, including characters with umluats in latin1, etc., while
+ * encodings, including characters with umlauts in latin1, etc., while
  * STRICMP() only handles the system locale version, which often does not
  * handle non-ascii properly. */
 
 # define MB_STRICMP(d, s)	mb_strnicmp((char_u *)(d), (char_u *)(s), (int)MAXCOL)
 # define MB_STRNICMP(d, s, n)	mb_strnicmp((char_u *)(d), (char_u *)(s), (int)(n))
@@ -1449,12 +1487,12 @@ typedef enum
 # define PERROR(msg)		    (void)emsg3((char_u *)"%s: %s", (char_u *)msg, (char_u *)strerror(errno))
 #else
 # define PERROR(msg)		    perror(msg)
 #endif
 
-typedef long	    linenr_T;		/* line number type */
-typedef unsigned    colnr_T;		/* column number type */
+typedef long	linenr_T;		/* line number type */
+typedef int	colnr_T;		/* column number type */
 typedef unsigned short disptick_T;	/* display tick type */
 
 #define MAXLNUM (0x7fffffffL)		/* maximum (invalid) line number */
 
 /*
@@ -1726,11 +1764,12 @@ typedef int proftime_T;	    /* dummy for
 #define VV_MOUSE_WIN	49
 #define VV_MOUSE_LNUM   50
 #define VV_MOUSE_COL	51
 #define VV_OP		52
 #define VV_SEARCHFORWARD 53
-#define VV_LEN		54	/* number of v: vars */
+#define VV_OLDFILES	54
+#define VV_LEN		55	/* number of v: vars */
 
 #ifdef FEAT_CLIPBOARD
 
 /* VIM_ATOM_NAME is the older Vim-specific selection type for X11.  Still
  * supported for when a mix of Vim versions is used. VIMENC_ATOM_NAME includes
@@ -1977,10 +2016,13 @@ typedef int VimClipboard;	/* This is req
 # else
 #  define X_DISPLAY	xterm_dpy
 # endif
 #endif
 
+#ifndef FEAT_NETBEANS_INTG
+# undef NBDEBUG
+#endif
 #ifdef NBDEBUG /* Netbeans debugging. */
 # include "nbdebug.h"
 #else
 # define nbdebug(a)
 #endif
@@ -2052,6 +2094,12 @@ typedef int VimClipboard;	/* This is req
 /* last argument for do_source() */
 #define DOSO_NONE	0
 #define DOSO_VIMRC	1	/* loading vimrc file */
 #define DOSO_GVIMRC	2	/* loading gvimrc file */
 
+/* flags for read_viminfo() and children */
+#define VIF_WANT_INFO		1	/* load non-mark info */
+#define VIF_WANT_MARKS		2	/* load file marks */
+#define VIF_FORCEIT		4	/* overwrite info already read */
+#define VIF_GET_OLDFILES	8	/* load v:oldfiles */
+
 #endif /* VIM__H */
--- vim72.orig/src/gui_x11.c
+++ vim72/src/gui_x11.c
@@ -568,26 +568,24 @@ static char **gui_argv = NULL;
 
 /*
  * Call-back routines.
  */
 
-/* ARGSUSED */
     static void
 gui_x11_timer_cb(timed_out, interval_id)
     XtPointer	    timed_out;
-    XtIntervalId    *interval_id;
+    XtIntervalId    *interval_id UNUSED;
 {
     *((int *)timed_out) = TRUE;
 }
 
-/* ARGSUSED */
     static void
 gui_x11_visibility_cb(w, dud, event, dum)
-    Widget	w;
-    XtPointer	dud;
+    Widget	w UNUSED;
+    XtPointer	dud UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     if (event->type != VisibilityNotify)
 	return;
 
     gui.visibility = event->xvisibility.state;
@@ -601,17 +599,16 @@ gui_x11_visibility_cb(w, dud, event, dum
 
     /* This is needed for when redrawing is slow. */
     gui_mch_update();
 }
 
-/* ARGSUSED */
     static void
 gui_x11_expose_cb(w, dud, event, dum)
-    Widget	w;
-    XtPointer	dud;
+    Widget	w UNUSED;
+    XtPointer	dud UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     XExposeEvent	*gevent;
     int			new_x;
 
     if (event->type != Expose)
@@ -678,17 +675,16 @@ shellRectangle(Widget shell, XRectangle
     r->y = absy;
     XtVaGetValues(shell, XmNheight, &r->height, XmNwidth, &r->width, NULL);
 }
 #endif
 
-/* ARGSUSED */
     static void
 gui_x11_resize_window_cb(w, dud, event, dum)
-    Widget	w;
-    XtPointer	dud;
+    Widget	w UNUSED;
+    XtPointer	dud UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     static int lastWidth, lastHeight;
 
     if (event->type != ConfigureNotify)
 	return;
@@ -725,56 +721,52 @@ gui_x11_resize_window_cb(w, dud, event,
 #ifdef FEAT_XIM
     xim_set_preedit();
 #endif
 }
 
-/* ARGSUSED */
     static void
 gui_x11_focus_change_cb(w, data, event, dum)
-    Widget	w;
-    XtPointer	data;
+    Widget	w UNUSED;
+    XtPointer	data UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     gui_focus_change(event->type == FocusIn);
 }
 
-/* ARGSUSED */
     static void
 gui_x11_enter_cb(w, data, event, dum)
-    Widget	w;
-    XtPointer	data;
-    XEvent	*event;
-    Boolean	*dum;
+    Widget	w UNUSED;
+    XtPointer	data UNUSED;
+    XEvent	*event UNUSED;
+    Boolean	*dum UNUSED;
 {
     gui_focus_change(TRUE);
 }
 
-/* ARGSUSED */
     static void
 gui_x11_leave_cb(w, data, event, dum)
-    Widget	w;
-    XtPointer	data;
-    XEvent	*event;
-    Boolean	*dum;
+    Widget	w UNUSED;
+    XtPointer	data UNUSED;
+    XEvent	*event UNUSED;
+    Boolean	*dum UNUSED;
 {
     gui_focus_change(FALSE);
 }
 
 #if defined(X_HAVE_UTF8_STRING) && defined(FEAT_MBYTE)
 # if X_HAVE_UTF8_STRING
 #  define USE_UTF8LOOKUP
 # endif
 #endif
 
-/* ARGSUSED */
     void
 gui_x11_key_hit_cb(w, dud, event, dum)
-    Widget	w;
-    XtPointer	dud;
+    Widget	w UNUSED;
+    XtPointer	dud UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     XKeyPressedEvent	*ev_press;
 #ifdef FEAT_XIM
     char_u		string2[256];
     char_u		string_shortbuf[256];
@@ -1076,17 +1068,16 @@ theend:
     if (string_alloced)
 	XtFree((char *)string);
 #endif
 }
 
-/* ARGSUSED */
     static void
 gui_x11_mouse_cb(w, dud, event, dum)
-    Widget	w;
-    XtPointer	dud;
+    Widget	w UNUSED;
+    XtPointer	dud UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     static XtIntervalId timer = (XtIntervalId)0;
     static int	timed_out = TRUE;
 
     int		button;
@@ -1208,15 +1199,15 @@ gui_mch_prepare(argc, argv)
     gui_argv[gui_argc++] = argv[0];
     arg = 1;
     while (arg < *argc)
     {
 	/* Look for argv[arg] in cmdline_options[] table */
-	for (i = 0; i < XtNumber(cmdline_options); i++)
+	for (i = 0; i < (int)XtNumber(cmdline_options); i++)
 	    if (strcmp(argv[arg], cmdline_options[i].option) == 0)
 		break;
 
-	if (i < XtNumber(cmdline_options))
+	if (i < (int)XtNumber(cmdline_options))
 	{
 	    /* Remember finding "-rv" or "-reverse" */
 	    if (strcmp("-rv", argv[arg]) == 0
 		    || strcmp("-reverse", argv[arg]) == 0)
 		found_reverse_arg = TRUE;
@@ -1317,16 +1308,15 @@ gui_mch_init_check()
  */
 static XtInputId _xsmp_xtinputid;
 
 static void local_xsmp_handle_requests __ARGS((XtPointer c, int *s, XtInputId *i));
 
-/*ARGSUSED*/
     static void
 local_xsmp_handle_requests(c, s, i)
-    XtPointer	c;
-    int		*s;
-    XtInputId	*i;
+    XtPointer	c UNUSED;
+    int		*s UNUSED;
+    XtInputId	*i UNUSED;
 {
     if (xsmp_handle_requests() == FAIL)
 	XtRemoveInput(_xsmp_xtinputid);
 }
 #endif
@@ -1436,11 +1426,11 @@ gui_mch_init()
 	mask = XParseGeometry((char *)gui.geom, &x, &y, &w, &h);
 	if (mask & WidthValue)
 	    Columns = w;
 	if (mask & HeightValue)
 	{
-	    if (p_window > h - 1 || !option_was_set((char_u *)"window"))
+	    if (p_window > (long)h - 1 || !option_was_set((char_u *)"window"))
 		p_window = h - 1;
 	    Rows = h;
 	}
 	/*
 	 * Set the (x,y) position of the main window only if specified in the
@@ -1585,10 +1575,12 @@ gui_mch_uninit()
 {
     gui_x11_destroy_widgets();
     XtCloseDisplay(gui.dpy);
     gui.dpy = NULL;
     vimShell = (Widget)0;
+    vim_free(gui_argv);
+    gui_argv = NULL;
 }
 
 /*
  * Called when the foreground or background color has been changed.
  */
@@ -1749,20 +1741,21 @@ gui_init_menu_font()
     }
 #endif
 }
 #endif
 
-/*ARGSUSED*/
     void
 gui_mch_exit(rc)
-    int		rc;
+    int		rc UNUSED;
 {
 #if 0
     /* Lesstif gives an error message here, and so does Solaris.  The man page
      * says that this isn't needed when exiting, so just skip it. */
     XtCloseDisplay(gui.dpy);
 #endif
+    vim_free(gui_argv);
+    gui_argv = NULL;
 }
 
 /*
  * Get the position of the top left corner of the window.
  */
@@ -1793,21 +1786,20 @@ gui_mch_set_winpos(x, y)
 	XtNx,	x,
 	XtNy,	y,
 	NULL);
 }
 
-/*ARGSUSED*/
     void
 gui_mch_set_shellsize(width, height, min_width, min_height,
 		    base_width, base_height, direction)
     int		width;
     int		height;
     int		min_width;
     int		min_height;
     int		base_width;
     int		base_height;
-    int		direction;
+    int		direction UNUSED;
 {
 #ifdef FEAT_XIM
     height += xim_get_status_area_height(),
 #endif
     XtVaSetValues(vimShell,
@@ -1841,15 +1833,14 @@ gui_mch_get_screen_dimensions(screen_w,
  * Initialise vim to use the font "font_name".  If it's NULL, pick a default
  * font.
  * If "fontset" is TRUE, load the "font_name" as a fontset.
  * Return FAIL if the font could not be loaded, OK otherwise.
  */
-/*ARGSUSED*/
     int
 gui_mch_init_font(font_name, do_fontset)
     char_u	*font_name;
-    int		do_fontset;
+    int		do_fontset UNUSED;
 {
     XFontStruct	*font = NULL;
 
 #ifdef FEAT_XFONTSET
     XFontSet	fontset = NULL;
@@ -2023,14 +2014,13 @@ gui_mch_get_font(name, giveErrorIfMissin
 #if defined(FEAT_EVAL) || defined(PROTO)
 /*
  * Return the name of font "font" in allocated memory.
  * Don't know how to get the actual name, thus use the provided name.
  */
-/*ARGSUSED*/
     char_u *
 gui_mch_get_fontname(font, name)
-    GuiFont font;
+    GuiFont font UNUSED;
     char_u  *name;
 {
     if (name == NULL)
 	return NULL;
     return vim_strsave(name);
@@ -2448,11 +2438,11 @@ find_closest_color(colormap, colorPtr)
     {
 	gui.color_approx = TRUE;
 	*colorPtr = colortable[closest];
     }
 
-    free(colortable);
+    vim_free(colortable);
     return OK;
 }
 
 /*
  * Set the current text foreground color.
@@ -2515,11 +2505,11 @@ draw_curl(row, col, cells)
     int col;
     int cells;
 {
     int			i;
     int			offset;
-    const static int	val[8] = {1, 0, 0, 0, 1, 2, 2, 2 };
+    static const int	val[8] = {1, 0, 0, 0, 1, 2, 2, 2 };
 
     XSetForeground(gui.dpy, gui.text_gc, prev_sp_color);
     for (i = FILL_X(col); i < FILL_X(col + cells); ++i)
     {
 	offset = val[i % 8];
@@ -2563,12 +2553,14 @@ gui_mch_draw_string(row, col, s, len, fl
 	{
 	    c = utf_ptr2char(p);
 # ifdef FEAT_XFONTSET
 	    if (current_fontset != NULL)
 	    {
-		if (c >= 0x10000 && sizeof(wchar_t) <= 2)
+#  ifdef SMALL_WCHAR_T
+		if (c >= 0x10000)
 		    c = 0xbf;		/* show chars > 0xffff as ? */
+#  endif
 		((wchar_t *)buf)[wlen] = c;
 	    }
 	    else
 # endif
 	    {
@@ -3130,15 +3122,15 @@ gui_mch_menu_hidden(menu, hidden)
 gui_mch_draw_menubar()
 {
     /* Nothing to do in X */
 }
 
-/* ARGSUSED */
     void
 gui_x11_menu_cb(w, client_data, call_data)
-    Widget	w;
-    XtPointer	client_data, call_data;
+    Widget	w UNUSED;
+    XtPointer	client_data;
+    XtPointer	call_data UNUSED;
 {
     gui_menu_cb((vimmenu_T *)client_data);
 }
 
 #endif /* FEAT_MENU */
@@ -3147,17 +3139,16 @@ gui_x11_menu_cb(w, client_data, call_dat
 
 /*
  * Function called when window closed.	Works like ":qa".
  * Should put up a requester!
  */
-/*ARGSUSED*/
     static void
 gui_x11_wm_protocol_handler(w, client_data, event, dum)
-    Widget	w;
-    XtPointer	client_data;
+    Widget	w UNUSED;
+    XtPointer	client_data UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     /*
      * Only deal with Client messages.
      */
     if (event->type != ClientMessage)
@@ -3166,11 +3157,11 @@ gui_x11_wm_protocol_handler(w, client_da
     /*
      * The WM_SAVE_YOURSELF event arrives when the window manager wants to
      * exit.  That can be cancelled though, thus Vim shouldn't exit here.
      * Just sync our swap files.
      */
-    if (((XClientMessageEvent *)event)->data.l[0] ==
+    if ((Atom)((XClientMessageEvent *)event)->data.l[0] ==
 						  wm_atoms[SAVE_YOURSELF_IDX])
     {
 	out_flush();
 	ml_sync_all(FALSE, FALSE);	/* preserve all swap files */
 
@@ -3179,28 +3170,27 @@ gui_x11_wm_protocol_handler(w, client_da
 	 * thus set argv to NULL. */
 	XSetCommand(gui.dpy, XtWindow(vimShell), NULL, 0);
 	return;
     }
 
-    if (((XClientMessageEvent *)event)->data.l[0] !=
+    if ((Atom)((XClientMessageEvent *)event)->data.l[0] !=
 						  wm_atoms[DELETE_WINDOW_IDX])
 	return;
 
     gui_shell_closed();
 }
 
 #ifdef FEAT_CLIENTSERVER
 /*
  * Function called when property changed. Check for incoming commands
  */
-/*ARGSUSED*/
     static void
 gui_x11_send_event_handler(w, client_data, event, dum)
-    Widget	w;
-    XtPointer	client_data;
+    Widget	w UNUSED;
+    XtPointer	client_data UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     XPropertyEvent *e = (XPropertyEvent *) event;
 
     if (e->type == PropertyNotify && e->window == commWindow
 	    && e->atom == commProperty &&  e->state == PropertyNewValue)
@@ -3271,15 +3261,14 @@ gui_mch_start_blink()
 	blink_state = BLINK_ON;
 	gui_update_cursor(TRUE, FALSE);
     }
 }
 
-/* ARGSUSED */
     static void
 gui_x11_blink_cb(timed_out, interval_id)
-    XtPointer	    timed_out;
-    XtIntervalId    *interval_id;
+    XtPointer	    timed_out UNUSED;
+    XtIntervalId    *interval_id UNUSED;
 {
     if (blink_state == BLINK_ON)
     {
 	gui_undraw_cursor();
 	blink_state = BLINK_OFF;
@@ -3437,62 +3426,51 @@ gui_mch_drawsign(row, col, typenr)
     void *
 gui_mch_register_sign(signfile)
     char_u	    *signfile;
 {
     XpmAttributes   attrs;
-    XImage	    *sign;
+    XImage	    *sign = NULL;
     int		    status;
 
     /*
      * Setup the color substitution table.
      */
-    sign = NULL;
     if (signfile[0] != NUL && signfile[0] != '-')
     {
-	sign = (XImage *)alloc(sizeof(XImage));
-	if (sign != NULL)
+	XpmColorSymbol color[5] =
 	{
-	    XpmColorSymbol color[5] =
-	    {
-		{"none", NULL, 0},
-		{"iconColor1", NULL, 0},
-		{"bottomShadowColor", NULL, 0},
-		{"topShadowColor", NULL, 0},
-		{"selectColor", NULL, 0}
-	    };
-	    attrs.valuemask = XpmColorSymbols;
-	    attrs.numsymbols = 2;
-	    attrs.colorsymbols = color;
-	    attrs.colorsymbols[0].pixel = gui.back_pixel;
-	    attrs.colorsymbols[1].pixel = gui.norm_pixel;
-	    status = XpmReadFileToImage(gui.dpy, (char *)signfile,
+	    {"none", NULL, 0},
+	    {"iconColor1", NULL, 0},
+	    {"bottomShadowColor", NULL, 0},
+	    {"topShadowColor", NULL, 0},
+	    {"selectColor", NULL, 0}
+	};
+	attrs.valuemask = XpmColorSymbols;
+	attrs.numsymbols = 2;
+	attrs.colorsymbols = color;
+	attrs.colorsymbols[0].pixel = gui.back_pixel;
+	attrs.colorsymbols[1].pixel = gui.norm_pixel;
+	status = XpmReadFileToImage(gui.dpy, (char *)signfile,
 							 &sign, NULL, &attrs);
-
-	    if (status == 0)
-	    {
-		/* Sign width is fixed at two columns now.
-		if (sign->width > gui.sign_width)
-		    gui.sign_width = sign->width + 8; */
-	    }
-	    else
-	    {
-		vim_free(sign);
-		sign = NULL;
-		EMSG(_(e_signdata));
-	    }
+	if (status == 0)
+	{
+	    /* Sign width is fixed at two columns now.
+	    if (sign->width > gui.sign_width)
+	        gui.sign_width = sign->width + 8; */
 	}
+	else
+	    EMSG(_(e_signdata));
     }
 
     return (void *)sign;
 }
 
     void
 gui_mch_destroy_sign(sign)
     void *sign;
 {
-    XFree(((XImage *)sign)->data);
-    vim_free(sign);
+    XDestroyImage((XImage*)sign);
 }
 #endif
 
 
 #ifdef FEAT_MOUSESHAPE
--- vim72.orig/src/os_unix.c
+++ vim72/src/os_unix.c
@@ -179,11 +179,12 @@ static RETSIGTYPE catch_sigpwr __ARGS(SI
 #endif
 #if defined(SIGALRM) && defined(FEAT_X11) \
 	&& defined(FEAT_TITLE) && !defined(FEAT_GUI_GTK)
 # define SET_SIG_ALARM
 static RETSIGTYPE sig_alarm __ARGS(SIGPROTOARG);
-static int sig_alarm_called;
+/* volatile because it is used in signal handler sig_alarm(). */
+static volatile int sig_alarm_called;
 #endif
 static RETSIGTYPE deathtrap __ARGS(SIGPROTOARG);
 
 static void catch_int_signal __ARGS((void));
 static void set_signals __ARGS((void));
@@ -199,17 +200,20 @@ static int save_patterns __ARGS((int num
 
 #ifndef SIG_ERR
 # define SIG_ERR	((RETSIGTYPE (*)())-1)
 #endif
 
-static int	do_resize = FALSE;
+/* volatile because it is used in signal handler sig_winch(). */
+static volatile int do_resize = FALSE;
 #ifndef __EMX__
 static char_u	*extra_shell_arg = NULL;
 static int	show_shell_mess = TRUE;
 #endif
-static int	deadly_signal = 0;	    /* The signal we caught */
-static int	in_mch_delay = FALSE;	    /* sleeping in mch_delay() */
+/* volatile because it is used in signal handler deathtrap(). */
+static volatile int deadly_signal = 0;	    /* The signal we caught */
+/* volatile because it is used in signal handler deathtrap(). */
+static volatile int in_mch_delay = FALSE;    /* sleeping in mch_delay() */
 
 static int curr_tmode = TMODE_COOK;	/* contains current terminal mode */
 
 #ifdef USE_XSMP
 typedef struct
@@ -313,16 +317,36 @@ static struct signalinfo
     {SIGPIPE,	    "PIPE",	FALSE},
 #endif
     {-1,	    "Unknown!", FALSE}
 };
 
+    int
+mch_chdir(path)
+    char *path;
+{
+    if (p_verbose >= 5)
+    {
+	verbose_enter();
+	smsg((char_u *)"chdir(%s)", path);
+	verbose_leave();
+    }
+# ifdef VMS
+    return chdir(vms_fixfilename(path));
+# else
+    return chdir(path);
+# endif
+}
+
+/*
+ * Write s[len] to the screen.
+ */
     void
 mch_write(s, len)
     char_u	*s;
     int		len;
 {
-    write(1, (char *)s, len);
+    ignored = (int)write(1, (char *)s, len);
     if (p_wd)		/* Unix is too fast, slow down a bit more */
 	RealWaitForChar(read_cmd_fd, p_wd, NULL);
 }
 
 /*
@@ -445,14 +469,13 @@ mch_char_avail()
 
 /*
  * Return total amount of memory available in Kbyte.
  * Doesn't change when memory has been allocated.
  */
-/* ARGSUSED */
     long_u
 mch_total_mem(special)
-    int special;
+    int special UNUSED;
 {
 # ifdef __EMX__
     return ulimit(3, 0L) >> 10;   /* always 32MB? */
 # else
     long_u	mem = 0;
@@ -797,16 +820,15 @@ init_signal_stack()
     }
 }
 #endif
 
 /*
- * We need correct potatotypes for a signal function, otherwise mean compilers
+ * We need correct prototypes for a signal function, otherwise mean compilers
  * will barf when the second argument to signal() is ``wrong''.
  * Let me try it with a few tricky defines from my own osdef.h	(jw).
  */
 #if defined(SIGWINCH)
-/* ARGSUSED */
     static RETSIGTYPE
 sig_winch SIGDEFARG(sigarg)
 {
     /* this is not required on all systems, but it doesn't hurt anybody */
     signal(SIGWINCH, (RETSIGTYPE (*)())sig_winch);
@@ -814,11 +836,10 @@ sig_winch SIGDEFARG(sigarg)
     SIGRETURN;
 }
 #endif
 
 #if defined(SIGINT)
-/* ARGSUSED */
     static RETSIGTYPE
 catch_sigint SIGDEFARG(sigarg)
 {
     /* this is not required on all systems, but it doesn't hurt anybody */
     signal(SIGINT, (RETSIGTYPE (*)())catch_sigint);
@@ -826,11 +847,10 @@ catch_sigint SIGDEFARG(sigarg)
     SIGRETURN;
 }
 #endif
 
 #if defined(SIGPWR)
-/* ARGSUSED */
     static RETSIGTYPE
 catch_sigpwr SIGDEFARG(sigarg)
 {
     /* this is not required on all systems, but it doesn't hurt anybody */
     signal(SIGPWR, (RETSIGTYPE (*)())catch_sigpwr);
@@ -846,11 +866,10 @@ catch_sigpwr SIGDEFARG(sigarg)
 
 #ifdef SET_SIG_ALARM
 /*
  * signal function for alarm().
  */
-/* ARGSUSED */
     static RETSIGTYPE
 sig_alarm SIGDEFARG(sigarg)
 {
     /* doesn't do anything, just to break a system call */
     sig_alarm_called = TRUE;
@@ -1063,23 +1082,27 @@ deathtrap SIGDEFARG(sigarg)
 #endif
 
     SIGRETURN;
 }
 
-#ifdef _REENTRANT
+#if defined(_REENTRANT) && defined(SIGCONT)
 /*
  * On Solaris with multi-threading, suspending might not work immediately.
  * Catch the SIGCONT signal, which will be used as an indication whether the
  * suspending has been done or not.
+ *
+ * On Linux, signal is not always handled immediately either.
+ * See https://bugs.launchpad.net/bugs/291373
+ *
+ * volatile because it is used in in signal handler sigcont_handler().
  */
-static int sigcont_received;
+static volatile int sigcont_received;
 static RETSIGTYPE sigcont_handler __ARGS(SIGPROTOARG);
 
 /*
  * signal handler for SIGCONT
  */
-/* ARGSUSED */
     static RETSIGTYPE
 sigcont_handler SIGDEFARG(sigarg)
 {
     sigcont_received = TRUE;
     SIGRETURN;
@@ -1113,19 +1136,32 @@ mch_suspend()
 	if (x11_display != NULL)
 	    XFlush(x11_display);
     }
 # endif
 
-# ifdef _REENTRANT
+# if defined(_REENTRANT) && defined(SIGCONT)
     sigcont_received = FALSE;
 # endif
     kill(0, SIGTSTP);	    /* send ourselves a STOP signal */
-# ifdef _REENTRANT
-    /* When we didn't suspend immediately in the kill(), do it now.  Happens
-     * on multi-threaded Solaris. */
-    if (!sigcont_received)
-	pause();
+# if defined(_REENTRANT) && defined(SIGCONT)
+    /*
+     * Wait for the SIGCONT signal to be handled. It generally happens
+     * immediately, but somehow not all the time. Do not call pause()
+     * because there would be race condition which would hang Vim if
+     * signal happened in between the test of sigcont_received and the
+     * call to pause(). If signal is not yet received, call sleep(0)
+     * to just yield CPU. Signal should then be received. If somehow
+     * it's still not received, sleep 1, 2, 3 ms. Don't bother waiting
+     * further if signal is not received after 1+2+3+4 ms (not expected
+     * to happen).
+     */
+    {
+	long wait_time;
+	for (wait_time = 0; !sigcont_received && wait_time <= 3L; wait_time++)
+	    /* Loop is not entered most of the time */
+	    mch_delay(wait_time, FALSE);
+    }
 # endif
 
 # ifdef FEAT_TITLE
     /*
      * Set oldtitle to NULL, so the current title is obtained again.
@@ -1170,11 +1206,11 @@ set_signals()
      * For "rvim" the STOP signal is ignored.
      */
 #ifdef SIGTSTP
     signal(SIGTSTP, restricted ? SIG_IGN : SIG_DFL);
 #endif
-#ifdef _REENTRANT
+#if defined(_REENTRANT) && defined(SIGCONT)
     signal(SIGCONT, sigcont_handler);
 #endif
 
     /*
      * We want to ignore breaking of PIPEs.
@@ -1229,11 +1265,11 @@ catch_int_signal()
 
     void
 reset_signals()
 {
     catch_signals(SIG_DFL, SIG_DFL);
-#ifdef _REENTRANT
+#if defined(_REENTRANT) && defined(SIGCONT)
     /* SIGCONT isn't in the list, because its default action is ignore */
     signal(SIGCONT, SIG_DFL);
 #endif
 }
 
@@ -1324,15 +1360,14 @@ vim_handle_signal(sig)
 }
 
 /*
  * Check_win checks whether we have an interactive stdout.
  */
-/* ARGSUSED */
     int
 mch_check_win(argc, argv)
-    int	    argc;
-    char    **argv;
+    int	    argc UNUSED;
+    char    **argv UNUSED;
 {
 #ifdef OS2
     /*
      * Store argv[0], may be used for $VIM.  Only use it if it is an absolute
      * name, mostly it's just "vim" and found in the path, which is unusable.
@@ -1412,15 +1447,14 @@ x_error_handler(dpy, error_event)
 }
 
 /*
  * Another X Error handler, just used to check for errors.
  */
-/* ARGSUSED */
     static int
 x_error_check(dpy, error_event)
-    Display *dpy;
-    XErrorEvent	*error_event;
+    Display *dpy UNUSED;
+    XErrorEvent	*error_event UNUSED;
 {
     got_x_error = TRUE;
     return 0;
 }
 
@@ -1429,41 +1463,41 @@ x_error_check(dpy, error_event)
 /*
  * An X IO Error handler, used to catch error while opening the display.
  */
 static int x_IOerror_check __ARGS((Display *dpy));
 
-/* ARGSUSED */
     static int
 x_IOerror_check(dpy)
-    Display *dpy;
+    Display *dpy UNUSED;
 {
     /* This function should not return, it causes exit().  Longjump instead. */
     LONGJMP(lc_jump_env, 1);
-    /*NOTREACHED*/
-    return 0;
+#  ifdef VMS
+    return 0;  /* avoid the compiler complains about missing return value */
+#  endif
 }
 # endif
 
 /*
  * An X IO Error handler, used to catch terminal errors.
  */
 static int x_IOerror_handler __ARGS((Display *dpy));
 
-/* ARGSUSED */
     static int
 x_IOerror_handler(dpy)
-    Display *dpy;
+    Display *dpy UNUSED;
 {
     xterm_dpy = NULL;
     x11_window = 0;
     x11_display = NULL;
     xterm_Shell = (Widget)0;
 
     /* This function should not return, it causes exit().  Longjump instead. */
     LONGJMP(x_jump_env, 1);
-    /*NOTREACHED*/
-    return 0;
+# ifdef VMS
+    return 0;  /* avoid the compiler complains about missing return value */
+# endif
 }
 #endif
 
 /*
  * Return TRUE when connection to the X server is desired.
@@ -1704,13 +1738,13 @@ get_x11_icon(test_only)
 
     /* could not get old icon, use terminal name */
     if (oldicon == NULL && !test_only)
     {
 	if (STRNCMP(T_NAME, "builtin_", 8) == 0)
-	    oldicon = T_NAME + 8;
+	    oldicon = vim_strsave(T_NAME + 8);
 	else
-	    oldicon = T_NAME;
+	    oldicon = vim_strsave(T_NAME);
     }
 
     return retval;
 }
 
@@ -1895,14 +1929,13 @@ set_x11_icon(icon)
     XFlush(x11_display);
 }
 
 #else  /* FEAT_X11 */
 
-/*ARGSUSED*/
     static int
 get_x11_title(test_only)
-    int	    test_only;
+    int	    test_only UNUSED;
 {
     return FALSE;
 }
 
     static int
@@ -1910,13 +1943,13 @@ get_x11_icon(test_only)
     int	    test_only;
 {
     if (!test_only)
     {
 	if (STRNCMP(T_NAME, "builtin_", 8) == 0)
-	    oldicon = T_NAME + 8;
+	    oldicon = vim_strsave(T_NAME + 8);
 	else
-	    oldicon = T_NAME;
+	    oldicon = vim_strsave(T_NAME);
     }
     return FALSE;
 }
 
 #endif /* FEAT_X11 */
@@ -2412,10 +2445,16 @@ mch_FullName(fname, buf, len, force)
 	if (p != NULL)
 	{
 #ifdef HAVE_FCHDIR
 	    if (fd >= 0)
 	    {
+		if (p_verbose >= 5)
+		{
+		    verbose_enter();
+		    MSG("fchdir() to previous dir");
+		    verbose_leave();
+		}
 		l = fchdir(fd);
 		close(fd);
 	    }
 	    else
 #endif
@@ -2436,11 +2475,11 @@ mch_FullName(fname, buf, len, force)
 	}
 #endif
     }
 
     /* Catch file names which are too long. */
-    if (retval == FAIL || STRLEN(buf) + STRLEN(fname) >= len)
+    if (retval == FAIL || (int)(STRLEN(buf) + STRLEN(fname)) >= len)
 	return FAIL;
 
     /* Do not append ".", "/dir/." is equal to "/dir". */
     if (STRCMP(fname, ".") != 0)
 	STRCAT(buf, fname);
@@ -2473,15 +2512,14 @@ mch_isFullName(fname)
 /*
  * Set the case of the file name, if it already exists.  This will cause the
  * file name to remain exactly the same.
  * Only required for file systems where case is ignored and preserved.
  */
-/*ARGSUSED*/
     void
 fname_case(name, len)
     char_u	*name;
-    int		len;	    /* buffer size, only used when name gets longer */
+    int		len UNUSED;  /* buffer size, only used when name gets longer */
 {
     struct stat st;
     char_u	*slash, *tail;
     DIR		*dirp;
     struct dirent *dp;
@@ -2655,11 +2693,11 @@ mch_copy_sec(from_file, to_file)
  * Return a pointer to the ACL of file "fname" in allocated memory.
  * Return NULL if the ACL is not available for whatever reason.
  */
     vim_acl_T
 mch_get_acl(fname)
-    char_u	*fname;
+    char_u	*fname UNUSED;
 {
     vim_acl_T	ret = NULL;
 #ifdef HAVE_POSIX_ACL
     ret = (vim_acl_T)acl_get_file((char *)fname, ACL_TYPE_ACCESS);
 #else
@@ -2715,11 +2753,11 @@ mch_get_acl(fname)
 /*
  * Set the ACL of file "fname" to "acl" (unless it's NULL).
  */
     void
 mch_set_acl(fname, aclent)
-    char_u	*fname;
+    char_u	*fname UNUSED;
     vim_acl_T	aclent;
 {
     if (aclent == NULL)
 	return;
 #ifdef HAVE_POSIX_ACL
@@ -2758,14 +2796,13 @@ mch_free_acl(aclent)
 #endif
 
 /*
  * Set hidden flag for "name".
  */
-/* ARGSUSED */
     void
 mch_hide(name)
-    char_u	*name;
+    char_u	*name UNUSED;
 {
     /* can't hide a file */
 }
 
 /*
@@ -2903,11 +2940,11 @@ mch_early_init()
      * running out of stack space.
      * Use of sigaltstack() is preferred, it's more portable.
      * Ignore any errors.
      */
 #if defined(HAVE_SIGALTSTACK) || defined(HAVE_SIGSTACK)
-    signal_stack = malloc(SIGSTKSZ);
+    signal_stack = (char *)alloc(SIGSTKSZ);
     init_signal_stack();
 #endif
 }
 
 #if defined(EXITFREE) || defined(PROTO)
@@ -2934,11 +2971,12 @@ mch_free_mem()
 	x11_display = NULL; /* freed by XtDestroyApplicationContext() */
 #   endif
     }
 #  endif
 # endif
-# ifdef FEAT_X11
+    /* Don't close the display for GTK 1, it is done in exit(). */
+# if defined(FEAT_X11) && (!defined(FEAT_GUI_GTK) || defined(HAVE_GTK2))
     if (x11_display != NULL
 #  ifdef FEAT_XCLIPBOARD
 	    && x11_display != xterm_dpy
 #  endif
 	    )
@@ -3449,14 +3487,13 @@ check_mouse_termcode()
 #endif
 
 /*
  * set screen mode, always fails.
  */
-/* ARGSUSED */
     int
 mch_screenmode(arg)
-    char_u   *arg;
+    char_u   *arg UNUSED;
 {
     EMSG(_(e_screenmode));
     return FAIL;
 }
 
@@ -3924,13 +3961,13 @@ mch_call_shell(cmd, options)
 		 * or dup() failed we'd just do the same thing ourselves
 		 * anyway -- webb
 		 */
 		if (fd >= 0)
 		{
-		    dup(fd); /* To replace stdin  (file descriptor 0) */
-		    dup(fd); /* To replace stdout (file descriptor 1) */
-		    dup(fd); /* To replace stderr (file descriptor 2) */
+		    ignored = dup(fd); /* To replace stdin  (fd 0) */
+		    ignored = dup(fd); /* To replace stdout (fd 1) */
+		    ignored = dup(fd); /* To replace stderr (fd 2) */
 
 		    /* Don't need this now that we've duplicated it */
 		    close(fd);
 		}
 	    }
@@ -3944,11 +3981,21 @@ mch_call_shell(cmd, options)
 # ifdef HAVE_SETSID
 		/* Create our own process group, so that the child and all its
 		 * children can be kill()ed.  Don't do this when using pipes,
 		 * because stdin is not a tty, we would lose /dev/tty. */
 		if (p_stmp)
+		{
 		    (void)setsid();
+#  if defined(SIGHUP)
+		    /* When doing "!xterm&" and 'shell' is bash: the shell
+		     * will exit and send SIGHUP to all processes in its
+		     * group, killing the just started process.  Ignore SIGHUP
+		     * to avoid that. (suggested by Simon Schubert)
+		     */
+		    signal(SIGHUP, SIG_IGN);
+#  endif
+		}
 # endif
 # ifdef FEAT_GUI
 		if (pty_slave_fd >= 0)
 		{
 		    /* push stream discipline modules */
@@ -3994,42 +4041,42 @@ mch_call_shell(cmd, options)
 		{
 		    close(pty_master_fd);   /* close master side of pty */
 
 		    /* set up stdin/stdout/stderr for the child */
 		    close(0);
-		    dup(pty_slave_fd);
+		    ignored = dup(pty_slave_fd);
 		    close(1);
-		    dup(pty_slave_fd);
+		    ignored = dup(pty_slave_fd);
 		    if (gui.in_use)
 		    {
 			close(2);
-			dup(pty_slave_fd);
+			ignored = dup(pty_slave_fd);
 		    }
 
 		    close(pty_slave_fd);    /* has been dupped, close it now */
 		}
 		else
 # endif
 		{
 		    /* set up stdin for the child */
 		    close(fd_toshell[1]);
 		    close(0);
-		    dup(fd_toshell[0]);
+		    ignored = dup(fd_toshell[0]);
 		    close(fd_toshell[0]);
 
 		    /* set up stdout for the child */
 		    close(fd_fromshell[0]);
 		    close(1);
-		    dup(fd_fromshell[1]);
+		    ignored = dup(fd_fromshell[1]);
 		    close(fd_fromshell[1]);
 
 # ifdef FEAT_GUI
 		    if (gui.in_use)
 		    {
 			/* set up stderr for the child */
 			close(2);
-			dup(1);
+			ignored = dup(1);
 		    }
 # endif
 		}
 	    }
 
@@ -4076,10 +4123,13 @@ mch_call_shell(cmd, options)
 		int	    c;
 		int	    toshell_fd;
 		int	    fromshell_fd;
 		garray_T    ga;
 		int	    noread_cnt;
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+		struct timeval  start_tv;
+# endif
 
 # ifdef FEAT_GUI
 		if (pty_master_fd >= 0)
 		{
 		    close(pty_slave_fd);	/* close slave side of pty */
@@ -4144,23 +4194,25 @@ mch_call_shell(cmd, options)
 				len = write(toshell_fd, "", (size_t)1);
 			    else
 			    {
 				s = vim_strchr(lp + written, NL);
 				len = write(toshell_fd, (char *)lp + written,
-					   s == NULL ? l : s - (lp + written));
+					   s == NULL ? l
+					      : (size_t)(s - (lp + written)));
 			    }
-			    if (len == l)
+			    if (len == (int)l)
 			    {
 				/* Finished a line, add a NL, unless this line
 				 * should not have one. */
 				if (lnum != curbuf->b_op_end.lnum
 					|| !curbuf->b_p_bin
 					|| (lnum != write_no_eol_lnum
 					    && (lnum !=
 						    curbuf->b_ml.ml_line_count
 						    || curbuf->b_p_eol)))
-				    write(toshell_fd, "\n", (size_t)1);
+				    ignored = write(toshell_fd, "\n",
+								   (size_t)1);
 				++lnum;
 				if (lnum > curbuf->b_op_end.lnum)
 				{
 				    /* finished all the lines, close pipe */
 				    close(toshell_fd);
@@ -4184,11 +4236,13 @@ mch_call_shell(cmd, options)
 
 		if (options & SHELL_READ)
 		    ga_init2(&ga, 1, BUFLEN);
 
 		noread_cnt = 0;
-
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+		gettimeofday(&start_tv, NULL);
+# endif
 		for (;;)
 		{
 		    /*
 		     * Check if keys have been typed, write them to the child
 		     * if there are any.
@@ -4197,29 +4251,38 @@ mch_call_shell(cmd, options)
 		     * Don't do this when filtering and terminal is in cooked
 		     * mode, the shell command will handle the I/O.  Avoids
 		     * that a typed password is echoed for ssh or gpg command.
 		     * Don't get characters when the child has already
 		     * finished (wait_pid == 0).
-		     * Don't get extra characters when we already have one.
 		     * Don't read characters unless we didn't get output for a
-		     * while, avoids that ":r !ls" eats typeahead.
+		     * while (noread_cnt > 4), avoids that ":r !ls" eats
+		     * typeahead.
 		     */
 		    len = 0;
 		    if (!(options & SHELL_EXPAND)
 			    && ((options &
 					 (SHELL_READ|SHELL_WRITE|SHELL_COOKED))
 				      != (SHELL_READ|SHELL_WRITE|SHELL_COOKED)
-#ifdef FEAT_GUI
+# ifdef FEAT_GUI
 						    || gui.in_use
-#endif
+# endif
 						    )
 			    && wait_pid == 0
-			    && (ta_len > 0
-				|| (noread_cnt > 4
-				    && (len = ui_inchar(ta_buf,
-						       BUFLEN, 10L, 0)) > 0)))
+			    && (ta_len > 0 || noread_cnt > 4))
 		    {
+		      if (ta_len == 0)
+		      {
+			  /* Get extra characters when we don't have any.
+			   * Reset the counter and timer. */
+			  noread_cnt = 0;
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+			  gettimeofday(&start_tv, NULL);
+# endif
+			  len = ui_inchar(ta_buf, BUFLEN, 10L, 0);
+		      }
+		      if (ta_len > 0 || len > 0)
+		      {
 			/*
 			 * For pipes:
 			 * Check for CTRL-C: send interrupt signal to child.
 			 * Check for CTRL-D: EOF, close pipe to child.
 			 */
@@ -4269,11 +4332,12 @@ mch_call_shell(cmd, options)
 			    }
 			    else if (ta_buf[i] == '\r')
 				ta_buf[i] = '\n';
 # ifdef FEAT_MBYTE
 			    if (has_mbyte)
-				i += (*mb_ptr2len)(ta_buf + i) - 1;
+				i += (*mb_ptr2len_len)(ta_buf + i,
+							ta_len + len - i) - 1;
 # endif
 			}
 
 			/*
 			 * For pipes: echo the typed characters.
@@ -4317,13 +4381,13 @@ mch_call_shell(cmd, options)
 			    len = write(toshell_fd, (char *)ta_buf, (size_t)1);
 			    if (len > 0)
 			    {
 				ta_len -= len;
 				mch_memmove(ta_buf, ta_buf + len, ta_len);
-				noread_cnt = 0;
 			    }
 			}
+		      }
 		    }
 
 		    if (got_int)
 		    {
 			/* CTRL-C sends a signal to the child, we ignore it
@@ -4427,10 +4491,29 @@ mch_call_shell(cmd, options)
 			windgoto(msg_row, msg_col);
 			cursor_on();
 			out_flush();
 			if (got_int)
 			    break;
+
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+			{
+			    struct timeval  now_tv;
+			    long	    msec;
+
+			    /* Avoid that we keep looping here without
+			     * checking for a CTRL-C for a long time.  Don't
+			     * break out too often to avoid losing typeahead. */
+			    gettimeofday(&now_tv, NULL);
+			    msec = (now_tv.tv_sec - start_tv.tv_sec) * 1000L
+				+ (now_tv.tv_usec - start_tv.tv_usec) / 1000L;
+			    if (msec > 2000)
+			    {
+				noread_cnt = 5;
+				break;
+			    }
+			}
+# endif
 		    }
 
 		    /* If we already detected the child has finished break the
 		     * loop now. */
 		    if (wait_pid == pid)
@@ -4670,20 +4753,19 @@ WaitForChar(msec)
  * Time == -1 will block forever.
  * When a GUI is being used, this will not be used for input -- webb
  * Returns also, when a request from Sniff is waiting -- toni.
  * Or when a Linux GPM mouse event is waiting.
  */
-/* ARGSUSED */
 #if defined(__BEOS__)
     int
 #else
     static  int
 #endif
 RealWaitForChar(fd, msec, check_for_gpm)
     int		fd;
     long	msec;
-    int		*check_for_gpm;
+    int		*check_for_gpm UNUSED;
 {
     int		ret;
 #if defined(FEAT_XCLIPBOARD) || defined(USE_XSMP) || defined(FEAT_MZSCHEME)
     static int	busy = FALSE;
 
@@ -5074,11 +5156,10 @@ mch_expandpath(gap, path, flags)
 # define SEEK_END 2
 #endif
 
 #define SHELL_SPECIAL (char_u *)"\t \"&'$;<>()\\|"
 
-/* ARGSUSED */
     int
 mch_expand_wildcards(num_pat, pat, num_file, file, flags)
     int		   num_pat;
     char_u	 **pat;
     int		  *num_file;
@@ -5496,11 +5577,11 @@ mch_expand_wildcards(num_pat, pat, num_f
 	return FAIL;
     }
     i = fread((char *)buffer, 1, len, fd);
     fclose(fd);
     mch_remove(tempname);
-    if (i != len)
+    if (i != (int)len)
     {
 	/* unexpected read error */
 	EMSG2(_(e_notread), tempname);
 	vim_free(tempname);
 	vim_free(buffer);
@@ -5557,11 +5638,11 @@ mch_expand_wildcards(num_pat, pat, num_f
 	 */
 	check_spaces = FALSE;
 	if (shell_style == STYLE_PRINT && !did_find_nul)
 	{
 	    /* If there is a NUL, set did_find_nul, else set check_spaces */
-	    if (len && (int)STRLEN(buffer) < len - 1)
+	    if (len && (int)STRLEN(buffer) < (int)len - 1)
 		did_find_nul = TRUE;
 	    else
 		check_spaces = TRUE;
 	}
 
@@ -5849,11 +5930,13 @@ gpm_open()
 	    /* gpm library tries to handling TSTP causes
 	     * problems. Anyways, we close connection to Gpm whenever
 	     * we are going to suspend or starting an external process
 	     * so we shouldn't  have problem with this
 	     */
+# ifdef SIGTSTP
 	    signal(SIGTSTP, restricted ? SIG_IGN : SIG_DFL);
+# endif
 	    return 1; /* succeed */
 	}
 	if (gpm_fd == -2)
 	    Gpm_Close(); /* We don't want to talk to xterm via gpm */
 	return 0;
@@ -5999,11 +6082,10 @@ sysmouse_close()
 }
 
 /*
  * Gets info from sysmouse and adds special keys to input buf.
  */
-/* ARGSUSED */
     static RETSIGTYPE
 sig_sysmouse SIGDEFARG(sigarg)
 {
     struct mouse_info	mouse;
     struct video_info	video;
@@ -6563,15 +6645,14 @@ static void xsmp_handle_interaction __AR
 
 /*
  * This is our chance to ask the user if they want to save,
  * or abort the logout
  */
-/*ARGSUSED*/
     static void
 xsmp_handle_interaction(smc_conn, client_data)
     SmcConn	smc_conn;
-    SmPointer	client_data;
+    SmPointer	client_data UNUSED;
 {
     cmdmod_T	save_cmdmod;
     int		cancel_shutdown = False;
 
     save_cmdmod = cmdmod;
@@ -6600,20 +6681,19 @@ xsmp_handle_interaction(smc_conn, client
 # endif
 
 /*
  * Callback that starts save-yourself.
  */
-/*ARGSUSED*/
     static void
 xsmp_handle_save_yourself(smc_conn, client_data, save_type,
 					       shutdown, interact_style, fast)
     SmcConn	smc_conn;
-    SmPointer	client_data;
-    int		save_type;
+    SmPointer	client_data UNUSED;
+    int		save_type UNUSED;
     Bool	shutdown;
-    int		interact_style;
-    Bool	fast;
+    int		interact_style UNUSED;
+    Bool	fast UNUSED;
 {
     /* Handle already being in saveyourself */
     if (xsmp.save_yourself)
 	SmcSaveYourselfDone(smc_conn, True);
     xsmp.save_yourself = True;
@@ -6643,15 +6723,14 @@ xsmp_handle_save_yourself(smc_conn, clie
 
 
 /*
  * Callback to warn us of imminent death.
  */
-/*ARGSUSED*/
     static void
 xsmp_die(smc_conn, client_data)
-    SmcConn	smc_conn;
-    SmPointer	client_data;
+    SmcConn	smc_conn UNUSED;
+    SmPointer	client_data UNUSED;
 {
     xsmp_close();
 
     /* quit quickly leaving swapfiles for modified buffers behind */
     getout_preserve_modified(0);
@@ -6659,29 +6738,27 @@ xsmp_die(smc_conn, client_data)
 
 
 /*
  * Callback to tell us that save-yourself has completed.
  */
-/*ARGSUSED*/
     static void
 xsmp_save_complete(smc_conn, client_data)
-    SmcConn	smc_conn;
-    SmPointer	client_data;
+    SmcConn	smc_conn UNUSED;
+    SmPointer	client_data UNUSED;
 {
     xsmp.save_yourself = False;
 }
 
 
 /*
  * Callback to tell us that an instigated shutdown was cancelled
  * (maybe even by us)
  */
-/*ARGSUSED*/
     static void
 xsmp_shutdown_cancelled(smc_conn, client_data)
     SmcConn	smc_conn;
-    SmPointer	client_data;
+    SmPointer	client_data UNUSED;
 {
     if (xsmp.save_yourself)
 	SmcSaveYourselfDone(smc_conn, True);
     xsmp.save_yourself = False;
     xsmp.shutdown = False;
@@ -6689,17 +6766,16 @@ xsmp_shutdown_cancelled(smc_conn, client
 
 
 /*
  * Callback to tell us that a new ICE connection has been established.
  */
-/*ARGSUSED*/
     static void
 xsmp_ice_connection(iceConn, clientData, opening, watchData)
     IceConn	iceConn;
-    IcePointer	clientData;
+    IcePointer	clientData UNUSED;
     Bool	opening;
-    IcePointer	*watchData;
+    IcePointer	*watchData UNUSED;
 {
     /* Intercept creation of ICE connection fd */
     if (opening)
     {
 	xsmp_icefd = IceConnectionNumber(iceConn);
@@ -6812,11 +6888,12 @@ xsmp_init(void)
 xsmp_close()
 {
     if (xsmp_icefd != -1)
     {
 	SmcCloseConnection(xsmp.smcconn, 0, NULL);
-	vim_free(xsmp.clientid);
+	if (xsmp.clientid != NULL)
+	    free(xsmp.clientid);
 	xsmp.clientid = NULL;
 	xsmp_icefd = -1;
     }
 }
 #endif /* USE_XSMP */
--- vim72.orig/src/gui_riscos.c
+++ vim72/src/gui_riscos.c
@@ -693,11 +693,11 @@ gui_mch_set_winpos(int x, int y)
 
     void
 gui_mch_set_shellsize(width, height, min_width, min_height, base_width, base_height, direction)
     int width;		/* In OS units */
     int height;
-    int min_width;	/* Smallest permissable window size (ignored) */
+    int min_width;	/* Smallest permissible window size (ignored) */
     int min_height;
     int base_width;	/* Space for scroll bars, etc */
     int base_height;
     int direction;
 {
@@ -861,11 +861,11 @@ zap_load_file(name, style)
 	return NULL;	/* Unable to load file */
 
     if (strncmp(file, "ZapFont\015", 8) == 0)
 	return file;	/* Loaded OK! */
 
-    free(file);
+    vim_free(file);
     return NULL;	/* Not a valid font file */
 }
 
 /* Load and convert the named font.
  * If name is NULL or a null string then convert the system font.
--- vim72.orig/src/gui_w48.c
+++ vim72/src/gui_w48.c
@@ -151,10 +151,13 @@ static int		s_busy_processing = FALSE;
 static int		destroying = FALSE;	/* call DestroyWindow() ourselves */
 
 #ifdef MSWIN_FIND_REPLACE
 static UINT		s_findrep_msg = 0;	/* set in gui_w[16/32].c */
 static FINDREPLACE	s_findrep_struct;
+# if defined(FEAT_MBYTE) && defined(WIN3264)
+static FINDREPLACEW	s_findrep_struct_w;
+# endif
 static HWND		s_findrep_hwnd = NULL;
 static int		s_findrep_is_find;	/* TRUE for find dialog, FALSE
 						   for find/replace dialog */
 #endif
 
@@ -545,11 +548,11 @@ char_to_string(int ch, char_u *string, i
 	    }
 	}
 	else
 	{
 	    len = 1;
-	    ws = ucs2_to_enc(wstring, &len);
+	    ws = utf16_to_enc(wstring, &len);
 	    if (ws == NULL)
 		len = 0;
 	    else
 	    {
 		if (len > slen)	/* just in case */
@@ -882,19 +885,68 @@ _OnMenu(
 	gui_menu_cb(pMenu);
 }
 #endif
 
 #ifdef MSWIN_FIND_REPLACE
+# if defined(FEAT_MBYTE) && defined(WIN3264)
+/*
+ * copy useful data from structure LPFINDREPLACE to structure LPFINDREPLACEW
+ */
+    static void
+findrep_atow(LPFINDREPLACEW lpfrw, LPFINDREPLACE lpfr)
+{
+    WCHAR *wp;
+
+    lpfrw->hwndOwner = lpfr->hwndOwner;
+    lpfrw->Flags = lpfr->Flags;
+
+    wp = enc_to_utf16(lpfr->lpstrFindWhat, NULL);
+    wcsncpy(lpfrw->lpstrFindWhat, wp, lpfrw->wFindWhatLen - 1);
+    vim_free(wp);
+
+    /* the field "lpstrReplaceWith" doesn't need to be copied */
+}
+
+/*
+ * copy useful data from structure LPFINDREPLACEW to structure LPFINDREPLACE
+ */
+    static void
+findrep_wtoa(LPFINDREPLACE lpfr, LPFINDREPLACEW lpfrw)
+{
+    char_u *p;
+
+    lpfr->Flags = lpfrw->Flags;
+
+    p = utf16_to_enc(lpfrw->lpstrFindWhat, NULL);
+    vim_strncpy(lpfr->lpstrFindWhat, p, lpfr->wFindWhatLen - 1);
+    vim_free(p);
+
+    p = utf16_to_enc(lpfrw->lpstrReplaceWith, NULL);
+    vim_strncpy(lpfr->lpstrReplaceWith, p, lpfr->wReplaceWithLen - 1);
+    vim_free(p);
+}
+# endif
+
 /*
  * Handle a Find/Replace window message.
  */
     static void
 _OnFindRepl(void)
 {
     int	    flags = 0;
     int	    down;
 
+# if defined(FEAT_MBYTE) && defined(WIN3264)
+    /* If the OS is Windows NT, and 'encoding' differs from active codepage:
+     * convert text from wide string. */
+    if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
+			&& enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+    {
+        findrep_wtoa(&s_findrep_struct, &s_findrep_struct_w);
+    }
+# endif
+
     if (s_findrep_struct.Flags & FR_DIALOGTERM)
 	/* Give main window the focus back. */
 	(void)SetFocus(s_hwnd);
 
     if (s_findrep_struct.Flags & FR_FINDNEXT)
@@ -1030,13 +1082,12 @@ _TextAreaWndProc(
 
 #ifdef FEAT_BEVAL
 	case WM_NOTIFY: Handle_WM_Notify(hwnd, (LPNMHDR)lParam);
 	    return TRUE;
 #endif
-
-    default:
-	return MyWindowProc(hwnd, uMsg, wParam, lParam);
+	default:
+	    return MyWindowProc(hwnd, uMsg, wParam, lParam);
     }
 }
 
 #if (defined(WIN3264) && defined(FEAT_MBYTE)) \
 	|| defined(GLOBAL_IME) \
@@ -1661,12 +1712,21 @@ process_message(void)
 #ifdef FEAT_OLE
     /* Look after OLE Automation commands */
     if (msg.message == WM_OLE)
     {
 	char_u *str = (char_u *)msg.lParam;
-	add_to_input_buf(str, (int)STRLEN(str));
-	vim_free(str);
+	if (str == NULL || *str == NUL)
+	{
+	    /* Message can't be ours, forward it.  Fixes problem with Ultramon
+	     * 3.0.4 */
+	    DispatchMessage(&msg);
+	}
+	else
+	{
+	    add_to_input_buf(str, (int)STRLEN(str));
+	    vim_free(str);  /* was allocated in CVim::SendKeys() */
+	}
 	return;
     }
 #endif
 
 #ifdef FEAT_NETBEANS_INTG
@@ -1935,10 +1995,15 @@ gui_mch_wait_for_chars(int wtime)
 	    (void)SetActiveWindow(s_hwnd);
 #endif
 	    s_need_activate = FALSE;
 	}
 
+#ifdef FEAT_NETBEANS_INTG
+	/* Process the queued netbeans messages. */
+	netbeans_parse_messages();
+#endif
+
 	/*
 	 * Don't use gui_mch_update() because then we will spin-lock until a
 	 * char arrives, instead we use GetMessage() to hang until an
 	 * event arrives.  No need to check for input_buf_full because we are
 	 * returning as soon as it contains a single char -- webb
@@ -2126,11 +2191,11 @@ GetTextWidthEnc(HDC hdc, char_u *str, in
 
     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
     {
 	/* 'encoding' differs from active codepage: convert text and use wide
 	 * function */
-	wstr = enc_to_ucs2(str, &wlen);
+	wstr = enc_to_utf16(str, &wlen);
 	if (wstr != NULL)
 	{
 	    n = GetTextExtentPointW(hdc, wstr, wlen, &size);
 	    vim_free(wstr);
 	    if (n)
@@ -2250,11 +2315,11 @@ add_tabline_popup_menu_entry(HMENU pmenu
 
     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
     {
 	/* 'encoding' differs from active codepage: convert menu name
 	 * and use wide function */
-	wn = enc_to_ucs2(item_text, NULL);
+	wn = enc_to_utf16(item_text, NULL);
 	if (wn != NULL)
 	{
 	    MENUITEMINFOW	infow;
 
 	    infow.cbSize = sizeof(infow);
@@ -2420,11 +2485,11 @@ gui_mch_update_tabline(void)
 #ifdef FEAT_MBYTE
 	wstr = NULL;
 	if (use_unicode)
 	{
 	    /* Need to go through Unicode. */
-	    wstr = enc_to_ucs2(NameBuff, NULL);
+	    wstr = enc_to_utf16(NameBuff, NULL);
 	    if (wstr != NULL)
 	    {
 		TCITEMW		tiw;
 
 		tiw.mask = TCIF_TEXT;
@@ -2519,12 +2584,12 @@ set_window_title(HWND hwnd, char *title)
     if (title != NULL && enc_codepage >= 0 && enc_codepage != (int)GetACP())
     {
 	WCHAR	*wbuf;
 	int	n;
 
-	/* Convert the title from 'encoding' to ucs2. */
-	wbuf = (WCHAR *)enc_to_ucs2((char_u *)title, NULL);
+	/* Convert the title from 'encoding' to UTF-16. */
+	wbuf = (WCHAR *)enc_to_utf16((char_u *)title, NULL);
 	if (wbuf != NULL)
 	{
 	    n = SetWindowTextW(hwnd, wbuf);
 	    vim_free(wbuf);
 	    if (n != 0 || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
@@ -2546,11 +2611,23 @@ gui_mch_find_dialog(exarg_T *eap)
 	    DestroyWindow(s_findrep_hwnd);
 
 	if (!IsWindow(s_findrep_hwnd))
 	{
 	    initialise_findrep(eap->arg);
-	    s_findrep_hwnd = FindText((LPFINDREPLACE) &s_findrep_struct);
+# if defined(FEAT_MBYTE) && defined(WIN3264)
+	    /* If the OS is Windows NT, and 'encoding' differs from active
+	     * codepage: convert text and use wide function. */
+	    if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
+		    && enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+	    {
+	        findrep_atow(&s_findrep_struct_w, &s_findrep_struct);
+		s_findrep_hwnd = FindTextW(
+					(LPFINDREPLACEW) &s_findrep_struct_w);
+	    }
+	    else
+# endif
+		s_findrep_hwnd = FindText((LPFINDREPLACE) &s_findrep_struct);
 	}
 
 	set_window_title(s_findrep_hwnd,
 			       _("Find string (use '\\\\' to find  a '\\')"));
 	(void)SetFocus(s_findrep_hwnd);
@@ -2571,11 +2648,22 @@ gui_mch_replace_dialog(exarg_T *eap)
 	    DestroyWindow(s_findrep_hwnd);
 
 	if (!IsWindow(s_findrep_hwnd))
 	{
 	    initialise_findrep(eap->arg);
-	    s_findrep_hwnd = ReplaceText((LPFINDREPLACE) &s_findrep_struct);
+# if defined(FEAT_MBYTE) && defined(WIN3264)
+	    if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
+		    && enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+	    {
+		findrep_atow(&s_findrep_struct_w, &s_findrep_struct);
+		s_findrep_hwnd = ReplaceTextW(
+					(LPFINDREPLACEW) &s_findrep_struct_w);
+	    }
+	    else
+# endif
+		s_findrep_hwnd = ReplaceText(
+					   (LPFINDREPLACE) &s_findrep_struct);
 	}
 
 	set_window_title(s_findrep_hwnd,
 			    _("Find & Replace (use '\\\\' to find  a '\\')"));
 	(void)SetFocus(s_findrep_hwnd);
@@ -3220,11 +3308,11 @@ gui_mch_browseW(
 	char_u *dflt,
 	char_u *ext,
 	char_u *initdir,
 	char_u *filter)
 {
-    /* We always use the wide function.  This means enc_to_ucs2() must work,
+    /* We always use the wide function.  This means enc_to_utf16() must work,
      * otherwise it fails miserably! */
     OPENFILENAMEW	fileStruct;
     WCHAR		fileBuf[MAXPATHL];
     WCHAR		*wp;
     int			i;
@@ -3236,11 +3324,11 @@ gui_mch_browseW(
 
     if (dflt == NULL)
 	fileBuf[0] = NUL;
     else
     {
-	wp = enc_to_ucs2(dflt, NULL);
+	wp = enc_to_utf16(dflt, NULL);
 	if (wp == NULL)
 	    fileBuf[0] = NUL;
 	else
 	{
 	    for (i = 0; wp[i] != NUL && i < MAXPATHL - 1; ++i)
@@ -3255,32 +3343,32 @@ gui_mch_browseW(
 
     memset(&fileStruct, 0, sizeof(OPENFILENAMEW));
 #ifdef OPENFILENAME_SIZE_VERSION_400
     /* be compatible with Windows NT 4.0 */
     /* TODO: what to use for OPENFILENAMEW??? */
-    fileStruct.lStructSize = sizeof(OPENFILENAME_SIZE_VERSION_400);
+    fileStruct.lStructSize = OPENFILENAME_SIZE_VERSION_400;
 #else
     fileStruct.lStructSize = sizeof(fileStruct);
 #endif
 
     if (title != NULL)
-	titlep = enc_to_ucs2(title, NULL);
+	titlep = enc_to_utf16(title, NULL);
     fileStruct.lpstrTitle = titlep;
 
     if (ext != NULL)
-	extp = enc_to_ucs2(ext, NULL);
+	extp = enc_to_utf16(ext, NULL);
     fileStruct.lpstrDefExt = extp;
 
     fileStruct.lpstrFile = fileBuf;
     fileStruct.nMaxFile = MAXPATHL;
     fileStruct.lpstrFilter = filterp;
     fileStruct.hwndOwner = s_hwnd;		/* main Vim window is owner*/
     /* has an initial dir been specified? */
     if (initdir != NULL && *initdir != NUL)
     {
 	/* Must have backslashes here, no matter what 'shellslash' says */
-	initdirp = enc_to_ucs2(initdir, NULL);
+	initdirp = enc_to_utf16(initdir, NULL);
 	if (initdirp != NULL)
 	{
 	    for (wp = initdirp; *wp != NUL; ++wp)
 		if (*wp == '/')
 		    *wp = '\\';
@@ -3316,11 +3404,11 @@ gui_mch_browseW(
     vim_free(initdirp);
     vim_free(titlep);
     vim_free(extp);
 
     /* Convert from UCS2 to 'encoding'. */
-    p = ucs2_to_enc(fileBuf, NULL);
+    p = utf16_to_enc(fileBuf, NULL);
     if (p != NULL)
 	/* when out of memory we get garbage for non-ASCII chars */
 	STRCPY(fileBuf, p);
     vim_free(p);
 
@@ -3333,11 +3421,11 @@ gui_mch_browseW(
 # endif /* FEAT_MBYTE */
 
 
 /*
  * Convert the string s to the proper format for a filter string by replacing
- * the \t and \n delimeters with \0.
+ * the \t and \n delimiters with \0.
  * Returns the converted string in allocated memory.
  *
  * Keep in sync with convert_filterW() above!
  */
     static char_u *
@@ -3416,11 +3504,11 @@ gui_mch_browse(
     filterp = convert_filter(filter);
 
     memset(&fileStruct, 0, sizeof(OPENFILENAME));
 #ifdef OPENFILENAME_SIZE_VERSION_400
     /* be compatible with Windows NT 4.0 */
-    fileStruct.lStructSize = sizeof(OPENFILENAME_SIZE_VERSION_400);
+    fileStruct.lStructSize = OPENFILENAME_SIZE_VERSION_400;
 #else
     fileStruct.lStructSize = sizeof(fileStruct);
 #endif
 
     fileStruct.lpstrTitle = title;
@@ -3516,11 +3604,11 @@ _OnDropFiles(
     if (fnames != NULL)
 	for (i = 0; i < cFiles; ++i)
 	{
 #ifdef FEAT_MBYTE
 	    if (DragQueryFileW(hDrop, i, wszFile, BUFPATHLEN) > 0)
-		fnames[i] = ucs2_to_enc(wszFile, NULL);
+		fnames[i] = utf16_to_enc(wszFile, NULL);
 	    else
 #endif
 	    {
 		DragQueryFile(hDrop, i, szFile, BUFPATHLEN);
 		fnames[i] = vim_strsave(szFile);
@@ -3672,11 +3760,12 @@ _OnScroll(
 /*
  * Get command line arguments.
  * Use "prog" as the name of the program and "cmdline" as the arguments.
  * Copy the arguments to allocated memory.
  * Return the number of arguments (including program name).
- * Return pointers to the arguments in "argvp".
+ * Return pointers to the arguments in "argvp".  Memory is allocated with
+ * malloc(), use free() instead of vim_free().
  * Return pointer to buffer in "tofree".
  * Returns zero when out of memory.
  */
 /*ARGSUSED*/
     int
@@ -3690,10 +3779,12 @@ get_cmd_args(char *prog, char *cmdline,
     int		inquote;
     int		argc;
     char	**argv = NULL;
     int		round;
 
+    *tofree = NULL;
+
 #ifdef FEAT_MBYTE
     /* Try using the Unicode version first, it takes care of conversion when
      * 'encoding' is changed. */
     argc = get_cmd_argsW(&argv);
     if (argc != 0)
@@ -3800,18 +3891,18 @@ get_cmd_args(char *prog, char *cmdline,
 	if (round == 1)
 	{
 	    argv = (char **)malloc((argc + 1) * sizeof(char *));
 	    if (argv == NULL )
 	    {
-		vim_free(newcmdline);
+		free(newcmdline);
 		return 0;		   /* malloc error */
 	    }
 	    pnew = newcmdline;
+	    *tofree = newcmdline;
 	}
     }
 
 done:
-
     argv[argc] = NULL;		/* NULL-terminated list */
     *argvp = argv;
     return argc;
 }
--- vim72.orig/src/os_vms.c
+++ vim72/src/os_vms.c
@@ -226,11 +226,11 @@ mch_getenv(char_u *lognam)
 	return(cp);
     }
     else if ((sbuf = getenv((char *)lognam)))
     {
 	lengte = strlen(sbuf) + 1;
-	cp = (char_u *)malloc((size_t)lengte);
+	cp = (char_u *)alloc((size_t)lengte);
 	if (cp)
 	    strcpy((char *)cp, sbuf);
 	return cp;
     }
     else
@@ -379,11 +379,11 @@ vms_wproc(char *name, int val)
 	    return 1;
     }
     if (--vms_match_free == 0) {
 	/* add more space to store matches */
 	vms_match_alloced += EXPL_ALLOC_INC;
-	vms_fmatch = (char_u **)realloc(vms_fmatch,
+	vms_fmatch = (char_u **)vim_realloc(vms_fmatch,
 		sizeof(char **) * vms_match_alloced);
 	if (!vms_fmatch)
 	    return 0;
 	vms_match_free = EXPL_ALLOC_INC;
     }
@@ -458,11 +458,11 @@ mch_expand_wildcards(int num_pat, char_u
 
 	    /* allocate memory for pointers */
 	    if (--files_free < 1)
 	    {
 		files_alloced += EXPL_ALLOC_INC;
-		*file = (char_u **)realloc(*file,
+		*file = (char_u **)vim_realloc(*file,
 		    sizeof(char_u **) * files_alloced);
 		if (*file == NULL)
 		{
 		    *file = (char_u **)"";
 		    *num_file = 0;
@@ -612,18 +612,18 @@ vms_fixfilename(void *instring)
     len = strlen(instring) + 1;
     if (len > buflen)
     {
 	buflen = len + 128;
 	if (buf)
-	    buf = (char *)realloc(buf, buflen);
+	    buf = (char *)vim_realloc(buf, buflen);
 	else
-	    buf = (char *)calloc(buflen, sizeof(char));
+	    buf = (char *)alloc(buflen * sizeof(char));
     }
 
 #ifdef DEBUG
      char		 *tmpbuf = NULL;
-     tmpbuf = (char *)calloc(buflen, sizeof(char));
+     tmpbuf = (char *)alloc(buflen * sizeof(char));
      strcpy(tmpbuf, instring);
 #endif
 
     Fspec_Rms = buf;				/* for decc$to_vms */
 
--- vim72.orig/src/os_w32exe.c
+++ vim72/src/os_w32exe.c
@@ -127,11 +127,12 @@ WinMain(
 #ifdef VIMDLL
     FreeLibrary(hLib);
 errout:
 #endif
     free(argv);
-    free(tofree);
+    if (tofree != NULL)
+	free(tofree);
 #ifdef FEAT_MBYTE
     free_cmd_argsW();
 #endif
 
     return 0;
--- vim72.orig/src/os_win16.c
+++ vim72/src/os_win16.c
@@ -119,11 +119,12 @@ WinMain(
     pmain = VimMain;
     pSaveInst(hInstance);
     pmain(argc, argv);
 
     free(argv);
-    free(tofree);
+    if (tofree != NULL)
+	free(tofree);
 
     return 0;
 }
 #endif
 
--- vim72.orig/src/if_xcmdsrv.c
+++ vim72/src/if_xcmdsrv.c
@@ -19,25 +19,10 @@
 # ifdef FEAT_X11
 #  include <X11/Intrinsic.h>
 #  include <X11/Xatom.h>
 # endif
 
-# if defined(HAVE_SYS_SELECT_H) && \
-	(!defined(HAVE_SYS_TIME_H) || defined(SYS_SELECT_WITH_SYS_TIME))
-#  include <sys/select.h>
-# endif
-
-# ifndef HAVE_SELECT
-#  ifdef HAVE_SYS_POLL_H
-#   include <sys/poll.h>
-#  else
-#   ifdef HAVE_POLL_H
-#    include <poll.h>
-#   endif
-#  endif
-# endif
-
 /*
  * This file provides procedures that implement the command server
  * functionality of Vim when in contact with an X11 server.
  *
  * Adapted from TCL/TK's send command  in tkSend.c of the tk 3.6 distribution.
@@ -680,11 +665,11 @@ serverGetVimNames(dpy)
 
     /*
      * Scan all of the names out of the property.
      */
     ga_init2(&ga, 1, 100);
-    for (p = regProp; (p - regProp) < numItems; p++)
+    for (p = regProp; (long_u)(p - regProp) < numItems; p++)
     {
 	entry = p;
 	while (*p != 0 && !isspace(*p))
 	    p++;
 	if (*p != 0)
@@ -734,11 +719,11 @@ ServerReplyFind(w, op)
 	{
 	    p = ((struct ServerReply *) serverReply.ga_data)
 		+ serverReply.ga_len;
 	    e.id = w;
 	    ga_init2(&e.strings, 1, 100);
-	    memcpy(p, &e, sizeof(e));
+	    mch_memmove(p, &e, sizeof(e));
 	    serverReply.ga_len++;
 	}
     }
     else if (p != NULL && op == SROP_Delete)
     {
@@ -967,11 +952,11 @@ LookupName(dpy, name, delete, loose)
     /*
      * Scan the property for the desired name.
      */
     returnValue = (int_u)None;
     entry = NULL;	/* Not needed, but eliminates compiler warning. */
-    for (p = regProp; (p - regProp) < numItems; )
+    for (p = regProp; (long_u)(p - regProp) < numItems; )
     {
 	entry = p;
 	while (*p != 0 && !isspace(*p))
 	    p++;
 	if (*p != 0 && STRICMP(name, p + 1) == 0)
@@ -984,11 +969,11 @@ LookupName(dpy, name, delete, loose)
 	p++;
     }
 
     if (loose != NULL && returnValue == (int_u)None && !IsSerialName(name))
     {
-	for (p = regProp; (p - regProp) < numItems; )
+	for (p = regProp; (long_u)(p - regProp) < numItems; )
 	{
 	    entry = p;
 	    while (*p != 0 && !isspace(*p))
 		p++;
 	    if (*p != 0 && IsSerialName(p + 1)
@@ -1016,11 +1001,11 @@ LookupName(dpy, name, delete, loose)
 	while (*p != 0)
 	    p++;
 	p++;
 	count = numItems - (p - regProp);
 	if (count > 0)
-	    memcpy(entry, p, count);
+	    mch_memmove(entry, p, count);
 	XChangeProperty(dpy, RootWindow(dpy, 0), registryProperty, XA_STRING,
 			8, PropModeReplace, regProp,
 			(int)(numItems - (p - entry)));
 	XSync(dpy, False);
     }
@@ -1054,11 +1039,11 @@ DeleteAnyLingerer(dpy, win)
      */
     if (GetRegProp(dpy, &regProp, &numItems, FALSE) == FAIL)
 	return;
 
     /* Scan the property for the window id.  */
-    for (p = regProp; (p - regProp) < numItems; )
+    for (p = regProp; (long_u)(p - regProp) < numItems; )
     {
 	if (*p != 0)
 	{
 	    sscanf((char *)p, "%x", &wwin);
 	    if ((Window)wwin == win)
@@ -1070,11 +1055,11 @@ DeleteAnyLingerer(dpy, win)
 		while (*p != 0)
 		    p++;
 		p++;
 		lastHalf = numItems - (p - regProp);
 		if (lastHalf > 0)
-		    memcpy(entry, p, lastHalf);
+		    mch_memmove(entry, p, lastHalf);
 		numItems = (entry - regProp) + lastHalf;
 		p = entry;
 		continue;
 	    }
 	}
@@ -1194,11 +1179,11 @@ serverEventProc(dpy, eventPtr)
     /*
      * Several commands and results could arrive in the property at
      * one time;  each iteration through the outer loop handles a
      * single command or result.
      */
-    for (p = propInfo; (p - propInfo) < numItems; )
+    for (p = propInfo; (long_u)(p - propInfo) < numItems; )
     {
 	/*
 	 * Ignore leading NULs; each command or result starts with a
 	 * NUL so that no matter how badly formed a preceding command
 	 * is, we'll be able to tell that a new command/result is
@@ -1228,11 +1213,11 @@ serverEventProc(dpy, eventPtr)
 	    name = NULL;
 	    resWindow = None;
 	    serial = (char_u *)"";
 	    script = NULL;
 	    enc = NULL;
-	    while (p - propInfo < numItems && *p == '-')
+	    while ((long_u)(p - propInfo) < numItems && *p == '-')
 	    {
 		switch (p[1])
 		{
 		    case 'r':
 			end = skipwhite(p + 2);
@@ -1331,11 +1316,11 @@ serverEventProc(dpy, eventPtr)
 	    p += 2;
 	    gotSerial = 0;
 	    res = (char_u *)"";
 	    code = 0;
 	    enc = NULL;
-	    while ((p-propInfo) < numItems && *p == '-')
+	    while ((long_u)(p - propInfo) < numItems && *p == '-')
 	    {
 		switch (p[1])
 		{
 		    case 'r':
 			if (p[2] == ' ')
@@ -1399,11 +1384,11 @@ serverEventProc(dpy, eventPtr)
 	     */
 	    p += 2;
 	    gotWindow = 0;
 	    str = (char_u *)"";
 	    enc = NULL;
-	    while ((p-propInfo) < numItems && *p == '-')
+	    while ((long_u)(p - propInfo) < numItems && *p == '-')
 	    {
 		switch (p[1])
 		{
 		    case 'n':
 			if (p[2] == ' ')
@@ -1487,15 +1472,14 @@ AppendPropCarefully(dpy, window, propert
 
 
 /*
  * Another X Error handler, just used to check for errors.
  */
-/* ARGSUSED */
     static int
 x_error_check(dpy, error_event)
-    Display	*dpy;
-    XErrorEvent	*error_event;
+    Display	*dpy UNUSED;
+    XErrorEvent	*error_event UNUSED;
 {
     got_x_error = TRUE;
     return 0;
 }
 
--- vim72.orig/src/if_sniff.c
+++ vim72/src/if_sniff.c
@@ -714,12 +714,14 @@ ConnectToSniffEmacs()
     }
 
 #else		/* UNIX Version of the Code */
     int ToSniffEmacs[2], FromSniffEmacs[2];
 
-    pipe(ToSniffEmacs);
-    pipe(FromSniffEmacs);
+    if (pipe(ToSniffEmacs) != 0)
+	return 1;
+    if (pipe(FromSniffEmacs) != 0)
+	return 1;
 
     /* fork */
     if ((sniffemacs_pid=fork()) == 0)
     {
 	/* child */
@@ -1112,11 +1114,12 @@ vi_error_msg(str)
     static void
 vi_open_file(fname)
     char *fname;
 {
     ++no_wait_return;
-    do_ecmd(0, (char_u *)fname, NULL, NULL, ECMD_ONE, ECMD_HIDE+ECMD_OLDBUF);
+    do_ecmd(0, (char_u *)fname, NULL, NULL, ECMD_ONE, ECMD_HIDE+ECMD_OLDBUF,
+	    curwin);
     curbuf->b_sniff = TRUE;
     --no_wait_return;					/* [ex_docmd.c] */
 }
 
     static buf_T *
--- vim72.orig/src/netbeans.c
+++ vim72/src/netbeans.c
@@ -30,10 +30,11 @@
 #  include <tchar.h>	/* for _T definition for TRACEn macros */
 # endif
 /* WinSock API is separated from C API, thus we can't use read(), write(),
  * errno... */
 # define sock_errno WSAGetLastError()
+# undef ECONNREFUSED
 # define ECONNREFUSED WSAECONNREFUSED
 # ifdef EINTR
 #  undef EINTR
 # endif
 # define EINTR WSAEINTR
@@ -67,11 +68,12 @@ static char *ExtEdProtocolVersion = "2.4
 
 static long pos2off __ARGS((buf_T *, pos_T *));
 static pos_T *off2pos __ARGS((buf_T *, long));
 static pos_T *get_off_or_lnum __ARGS((buf_T *buf, char_u **argp));
 static long get_buf_size __ARGS((buf_T *));
-static void netbeans_keystring __ARGS((int key, char *keystr));
+static int netbeans_keystring __ARGS((char_u *keystr));
+static void postpone_keycommand __ARGS((char_u *keystr));
 static void special_keys __ARGS((char_u *args));
 
 static void netbeans_connect __ARGS((void));
 static int getConnInfo __ARGS((char *file, char **host, char **port, char **password));
 
@@ -499,11 +501,11 @@ getConnInfo(char *file, char **host, cha
 }
 
 
 struct keyqueue
 {
-    int		     key;
+    char_u	    *keystr;
     struct keyqueue *next;
     struct keyqueue *prev;
 };
 
 typedef struct keyqueue keyQ_T;
@@ -511,17 +513,21 @@ typedef struct keyqueue keyQ_T;
 static keyQ_T keyHead; /* dummy node, header for circular queue */
 
 
 /*
  * Queue up key commands sent from netbeans.
+ * We store the string, because it may depend on the global mod_mask and
+ * :nbkey doesn't have a key number.
  */
     static void
-postpone_keycommand(int key)
+postpone_keycommand(char_u *keystr)
 {
     keyQ_T *node;
 
     node = (keyQ_T *)alloc(sizeof(keyQ_T));
+    if (node == NULL)
+	return;  /* out of memory, drop the key */
 
     if (keyHead.next == NULL) /* initialize circular queue */
     {
 	keyHead.next = &keyHead;
 	keyHead.prev = &keyHead;
@@ -531,28 +537,33 @@ postpone_keycommand(int key)
     node->next = &keyHead;
     node->prev = keyHead.prev;
     keyHead.prev->next = node;
     keyHead.prev = node;
 
-    node->key = key;
+    node->keystr = vim_strsave(keystr);
 }
 
 /*
  * Handle any queued-up NetBeans keycommands to be send.
  */
     static void
 handle_key_queue(void)
 {
-    while (keyHead.next && keyHead.next != &keyHead)
+    int postponed = FALSE;
+
+    while (!postponed && keyHead.next && keyHead.next != &keyHead)
     {
 	/* first, unlink the node */
 	keyQ_T *node = keyHead.next;
 	keyHead.next = node->next;
 	node->next->prev = node->prev;
 
-	/* now, send the keycommand */
-	netbeans_keycommand(node->key);
+	/* Now, send the keycommand.  This may cause it to be postponed again
+	 * and change keyHead. */
+	if (node->keystr != NULL)
+	    postponed = !netbeans_keystring(node->keystr);
+	vim_free(node->keystr);
 
 	/* Finally, dispose of the node */
 	vim_free(node);
     }
 }
@@ -698,33 +709,43 @@ netbeans_parse_messages(void)
 #define MAXMSGSIZE 4096
 
 /*
  * Read and process a command from netbeans.
  */
-/*ARGSUSED*/
 #if defined(FEAT_GUI_W32) || defined(PROTO)
 /* Use this one when generating prototypes, the others are static. */
     void
 messageFromNetbeansW32()
 #else
 # ifdef FEAT_GUI_MOTIF
     static void
-messageFromNetbeans(XtPointer clientData, int *unused1, XtInputId *unused2)
+messageFromNetbeans(XtPointer clientData UNUSED,
+		    int *unused1 UNUSED,
+		    XtInputId *unused2 UNUSED)
 # endif
 # ifdef FEAT_GUI_GTK
     static void
-messageFromNetbeans(gpointer clientData, gint unused1,
-						    GdkInputCondition unused2)
+messageFromNetbeans(gpointer clientData UNUSED,
+		    gint unused1 UNUSED,
+		    GdkInputCondition unused2 UNUSED)
 # endif
 #endif
 {
     static char_u	*buf = NULL;
     int			len;
     int			readlen = 0;
 #ifndef FEAT_GUI_GTK
     static int		level = 0;
 #endif
+#ifdef HAVE_SELECT
+    struct timeval	tval;
+    fd_set		rfds;
+#else
+# ifdef HAVE_POLL
+    struct pollfd	fds;
+# endif
+#endif
 
     if (sd < 0)
     {
 	nbdebug(("messageFromNetbeans() called without a socket\n"));
 	return;
@@ -740,13 +761,30 @@ messageFromNetbeans(gpointer clientData,
 	buf = alloc(MAXMSGSIZE);
 	if (buf == NULL)
 	    return;	/* out of memory! */
     }
 
-    /* Keep on reading for as long as there is something to read. */
+    /* Keep on reading for as long as there is something to read.
+     * Use select() or poll() to avoid blocking on a message that is exactly
+     * MAXMSGSIZE long. */
     for (;;)
     {
+#ifdef HAVE_SELECT
+	FD_ZERO(&rfds);
+        FD_SET(sd, &rfds);
+        tval.tv_sec = 0;
+        tval.tv_usec = 0;
+        if (select(sd + 1, &rfds, NULL, NULL, &tval) <= 0)
+            break;
+#else
+# ifdef HAVE_POLL
+	fds.fd = sd;
+	fds.events = POLLIN;
+        if (poll(&fds, 1, 0) <= 0)
+            break;
+# endif
+#endif
 	len = sock_read(sd, buf, MAXMSGSIZE);
 	if (len <= 0)
 	    break;	/* error or nothing more to read */
 
 	/* Store the read message in the queue. */
@@ -767,15 +805,18 @@ messageFromNetbeans(gpointer clientData,
 	    PERROR(_("read from Netbeans socket"));
 	}
 	return; /* don't try to parse it */
     }
 
-#ifdef FEAT_GUI_GTK
+#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_W32)
+    /* Let the main loop handle messages. */
+# ifdef FEAT_GUI_GTK
     if (gtk_main_level() > 0)
 	gtk_main_quit();
+# endif
 #else
-    /* Parse the messages, but avoid recursion. */
+    /* Parse the messages now, but avoid recursion. */
     if (level == 1)
 	netbeans_parse_messages();
 
     --level;
 #endif
@@ -865,11 +906,11 @@ nb_parse_cmd(char_u *cmd)
 
     if (nb_do_cmd(bufno, (char_u *)verb, isfunc, r_cmdno, (char_u *)q) == FAIL)
     {
 #ifdef NBDEBUG
 	/*
-	 * This happens because the ExtEd can send a cammand or 2 after
+	 * This happens because the ExtEd can send a command or 2 after
 	 * doing a stopDocumentListen command. It doesn't harm anything
 	 * so I'm disabling it except for debugging.
 	 */
 	nbdebug(("nb_parse_cmd: Command error for \"%s\"\n", cmd));
 	EMSG("E629: bad return from nb_do_cmd");
@@ -1041,11 +1082,11 @@ netbeans_end(void)
 	}
 	sprintf(buf, "%d:killed=%d\n", i, r_cmdno);
 	nbdebug(("EVT: %s", buf));
 /*	nb_send(buf, "netbeans_end");    avoid "write failed" messages */
 	if (sd >= 0)
-	    sock_write(sd, buf, (int)STRLEN(buf));  /* ignore errors */
+	    ignored = sock_write(sd, buf, (int)STRLEN(buf));
     }
 }
 
 /*
  * Send a message to netbeans.
@@ -1166,11 +1207,11 @@ nb_quote(char_u *txt)
 	    default:
 		*q++ = *p;
 		break;
 	}
     }
-    *q++ = '\0';
+    *q = '\0';
 
     return buf;
 }
 
 
@@ -1491,33 +1532,36 @@ nb_do_cmd(
 		    netbeansFireChanges = oldFire;
 		    netbeansSuppressNoLines = oldSuppress;
 		    return FAIL;
 		}
 		first = *pos;
-		nbdebug(("    FIRST POS: line %d, col %d\n", first.lnum, first.col));
+		nbdebug(("    FIRST POS: line %d, col %d\n",
+						      first.lnum, first.col));
 		pos = off2pos(buf->bufp, off+count-1);
 		if (!pos)
 		{
 		    nbdebug(("    !bad count\n"));
 		    nb_reply_text(cmdno, (char_u *)"!bad count");
 		    netbeansFireChanges = oldFire;
 		    netbeansSuppressNoLines = oldSuppress;
 		    return FAIL;
 		}
 		last = *pos;
-		nbdebug(("    LAST POS: line %d, col %d\n", last.lnum, last.col));
+		nbdebug(("    LAST POS: line %d, col %d\n",
+							last.lnum, last.col));
 		del_from_lnum = first.lnum;
 		del_to_lnum = last.lnum;
 		doupdate = 1;
 
 		/* Get the position of the first byte after the deleted
 		 * section.  "next" is NULL when deleting to the end of the
 		 * file. */
 		next = off2pos(buf->bufp, off + count);
 
 		/* Remove part of the first line. */
-		if (first.col != 0 || (next != NULL && first.lnum == next->lnum))
+		if (first.col != 0
+				|| (next != NULL && first.lnum == next->lnum))
 		{
 		    if (first.lnum != last.lnum
 			    || (next != NULL && first.lnum != next->lnum))
 		    {
 			/* remove to the end of the first line */
@@ -1576,18 +1620,22 @@ nb_do_cmd(
 		    for (i = del_from_lnum; i <= del_to_lnum; i++)
 		    {
 			int id = buf_findsign_id(buf->bufp, (linenr_T)i);
 			if (id > 0)
 			{
-			    nbdebug(("    Deleting sign %d on line %d\n", id, i));
+			    nbdebug(("    Deleting sign %d on line %d\n",
+								      id, i));
 			    buf_delsign(buf->bufp, id);
 			}
 			else
+			{
 			    nbdebug(("    No sign on line %d\n", i));
+			}
 		    }
 
-		    nbdebug(("    Deleting lines %d through %d\n", del_from_lnum, del_to_lnum));
+		    nbdebug(("    Deleting lines %d through %d\n",
+						 del_from_lnum, del_to_lnum));
 		    curwin->w_cursor.lnum = del_from_lnum;
 		    curwin->w_cursor.col = 0;
 		    del_lines(del_to_lnum - del_from_lnum + 1, FALSE);
 		}
 
@@ -1793,11 +1841,11 @@ nb_do_cmd(
 	    }
 	    vim_free(buf->displayname);
 	    buf->displayname = NULL;
 
 	    netbeansReadFile = 0; /* don't try to open disk file */
-	    do_ecmd(0, NULL, 0, 0, ECMD_ONE, ECMD_HIDE + ECMD_OLDBUF);
+	    do_ecmd(0, NULL, 0, 0, ECMD_ONE, ECMD_HIDE + ECMD_OLDBUF, curwin);
 	    netbeansReadFile = 1;
 	    buf->bufp = curbuf;
 	    maketitle();
 	    buf->insertDone = FALSE;
 	    gui_update_menus(0);
@@ -1919,11 +1967,11 @@ nb_do_cmd(
 		return FAIL;
 	    bufp = buflist_findname(path);
 	    vim_free(path);
 	    if (bufp == NULL)
 	    {
-	    	nbdebug(("    File %s not found in setBufferNumber\n", args));
+		nbdebug(("    File %s not found in setBufferNumber\n", args));
 		EMSG2("E642: File %s not found in setBufferNumber", args);
 		return FAIL;
 	    }
 	    buf->bufp = bufp;
 	    buf->nbbuf_number = bufp->b_fnum;
@@ -1958,11 +2006,11 @@ nb_do_cmd(
 	    vim_free(buf->displayname);
 	    buf->displayname = nb_unquote(args, NULL);
 
 	    netbeansReadFile = 0; /* don't try to open disk file */
 	    do_ecmd(0, (char_u *)buf->displayname, 0, 0, ECMD_ONE,
-						     ECMD_HIDE + ECMD_OLDBUF);
+					     ECMD_HIDE + ECMD_OLDBUF, curwin);
 	    netbeansReadFile = 1;
 	    buf->bufp = curbuf;
 	    maketitle();
 	    gui_update_menus(0);
 /* =====================================================================*/
@@ -1977,11 +2025,11 @@ nb_do_cmd(
 	    }
 	    /* Edit a file: like create + setFullName + read the file. */
 	    vim_free(buf->displayname);
 	    buf->displayname = nb_unquote(args, NULL);
 	    do_ecmd(0, (char_u *)buf->displayname, NULL, NULL, ECMD_ONE,
-						     ECMD_HIDE + ECMD_OLDBUF);
+					     ECMD_HIDE + ECMD_OLDBUF, curwin);
 	    buf->bufp = curbuf;
 	    buf->initDone = TRUE;
 	    doupdate = 1;
 #if defined(FEAT_TITLE)
 	    maketitle();
@@ -2139,11 +2187,13 @@ nb_do_cmd(
 #ifdef FEAT_FOLDING
 		foldOpenCursor();
 #endif
 	    }
 	    else
+	    {
 		nbdebug(("    BAD POSITION in setDot: %s\n", s));
+	    }
 
 	    /* gui_update_cursor(TRUE, FALSE); */
 	    /* update_curbuf(NOT_VALID); */
 	    update_topline();		/* scroll to show the line */
 	    update_screen(VALID);
@@ -2275,13 +2325,10 @@ nb_do_cmd(
 	{
 #ifdef FEAT_SIGNS
 	    int serNum;
 	    int localTypeNum;
 	    int typeNum;
-# ifdef NBDEBUG
-	    int len;
-# endif
 	    pos_T *pos;
 
 	    if (buf == NULL || buf->bufp == NULL)
 	    {
 		nbdebug(("    invalid buffer identifier in addAnno\n"));
@@ -2301,17 +2348,14 @@ nb_do_cmd(
 	    typeNum = mapsigntype(buf, localTypeNum);
 
 	    pos = get_off_or_lnum(buf->bufp, &args);
 
 	    cp = (char *)args;
-# ifdef NBDEBUG
-	    len =
-# endif
-		strtol(cp, &cp, 10);
+	    ignored = (int)strtol(cp, &cp, 10);
 	    args = (char_u *)cp;
 # ifdef NBDEBUG
-	    if (len != -1)
+	    if (ignored != -1)
 	    {
 		nbdebug(("    partial line annotation -- Not Yet Implemented!\n"));
 	    }
 # endif
 	    if (serNum >= GUARDEDOFFSET)
@@ -2319,11 +2363,11 @@ nb_do_cmd(
 		nbdebug(("    too many annotations! ignoring...\n"));
 		return FAIL;
 	    }
 	    if (pos)
 	    {
-		coloncmd(":sign place %d line=%d name=%d buffer=%d",
+		coloncmd(":sign place %d line=%ld name=%d buffer=%d",
 			   serNum, pos->lnum, typeNum, buf->bufp->b_fnum);
 		if (typeNum == curPCtype)
 		    coloncmd(":sign jump %d buffer=%d", serNum,
 						       buf->bufp->b_fnum);
 	    }
@@ -2423,11 +2467,11 @@ nb_do_cmd(
 			{
 			    if (buf_findsigntype_id(buf->bufp, lnum,
 				GUARDED) == 0)
 			    {
 				coloncmd(
-				    ":sign place %d line=%d name=%d buffer=%d",
+				    ":sign place %d line=%ld name=%d buffer=%d",
 				     guardId++, lnum, GUARDED,
 				     buf->bufp->b_fnum);
 			    }
 			}
 		    }
@@ -2484,11 +2528,11 @@ nb_do_cmd(
 #endif
 		}
 	    }
 	    else
 	    {
-	        nbdebug(("    Buffer has no changes!\n"));
+		nbdebug(("    Buffer has no changes!\n"));
 	    }
 /* =====================================================================*/
 	}
 	else if (streq((char *)cmd, "netbeansBuffer"))
 	{
@@ -2580,11 +2624,11 @@ coloncmd(char *cmd, ...)
 {
     char buf[1024];
     va_list ap;
 
     va_start(ap, cmd);
-    vsprintf(buf, cmd, ap);
+    vim_vsnprintf(buf, sizeof(buf), cmd, ap, NULL);
     va_end(ap);
 
     nbdebug(("    COLONCMD %s\n", buf));
 
 /*     ALT_INPUT_LOCK_ON; */
@@ -2647,11 +2691,11 @@ special_keys(char_u *args)
 
     void
 ex_nbkey(eap)
     exarg_T	*eap;
 {
-    netbeans_keystring(0, (char *)eap->arg);
+    (void)netbeans_keystring(eap->arg);
 }
 
 
 /*
  * Initialize highlights and signs for use by netbeans  (mostly obsolete)
@@ -2669,11 +2713,11 @@ nb_init_graphics(void)
 	did_init = TRUE;
     }
 }
 
 /*
- * Convert key to netbeans name.
+ * Convert key to netbeans name.  This uses the global "mod_mask".
  */
     static void
 netbeans_keyname(int key, char *buf)
 {
     char *name = 0;
@@ -2745,15 +2789,14 @@ netbeans_keyname(int key, char *buf)
 /*
  * Function to be called for balloon evaluation.  Grabs the text under the
  * cursor and sends it to the debugger for evaluation.  The debugger should
  * respond with a showBalloon command when there is a useful result.
  */
-/*ARGSUSED*/
     void
 netbeans_beval_cb(
 	BalloonEval	*beval,
-	int		 state)
+	int		 state UNUSED)
 {
     win_T	*wp;
     char_u	*text;
     linenr_T	lnum;
     int		col;
@@ -2922,48 +2965,30 @@ netbeans_file_opened(buf_T *bufp)
     if (p_acd && vim_chdirfile(bufp->b_ffname) == OK)
 	shorten_fnames(TRUE);
 }
 
 /*
- * Tell netbeans a file was closed.
+ * Tell netbeans that a file was deleted or wiped out.
  */
     void
-netbeans_file_closed(buf_T *bufp)
+netbeans_file_killed(buf_T *bufp)
 {
     int		bufno = nb_getbufno(bufp);
     nbbuf_T	*nbbuf = nb_get_buf(bufno);
     char	buffer[2*MAXPATHL];
 
-    if (!haveConnection || bufno < 0)
+    if (!haveConnection || bufno == -1)
 	return;
 
-    if (!netbeansCloseFile)
-    {
-	nbdebug(("Ignoring file_closed for %s. File was closed from IDE\n",
-		    bufp->b_ffname));
-	return;
-    }
-
-    nbdebug(("netbeans_file_closed:\n"));
-    nbdebug(("    Closing bufno: %d", bufno));
-    if (curbuf != NULL && curbuf != bufp)
-    {
-	nbdebug(("    Curbuf bufno:  %d\n", nb_getbufno(curbuf)));
-    }
-    else if (curbuf == bufp)
-    {
-	nbdebug(("    curbuf == bufp\n"));
-    }
-
-    if (bufno <= 0)
-	return;
+    nbdebug(("netbeans_file_killed:\n"));
+    nbdebug(("    Killing bufno: %d", bufno));
 
     sprintf(buffer, "%d:killed=%d\n", bufno, r_cmdno);
 
     nbdebug(("EVT: %s", buffer));
 
-    nb_send(buffer, "netbeans_file_closed");
+    nb_send(buffer, "netbeans_file_killed");
 
     if (nbbuf != NULL)
 	nbbuf->bufp = NULL;
 }
 
@@ -3078,15 +3103,14 @@ netbeans_removed(
     nbdebug(("EVT: %s", buf));
     nb_send((char *)buf, "netbeans_removed");
 }
 
 /*
- * Send netbeans an unmodufied command.
+ * Send netbeans an unmodified command.
  */
-/*ARGSUSED*/
     void
-netbeans_unmodified(buf_T *bufp)
+netbeans_unmodified(buf_T *bufp UNUSED)
 {
 #if 0
     char_u	buf[128];
     int		bufno;
     nbbuf_T	*nbbuf;
@@ -3136,56 +3160,59 @@ netbeans_button_release(int button)
 
 
 /*
  * Send a keypress event back to netbeans. This usually simulates some
  * kind of function key press. This function operates on a key code.
+ * Return TRUE when the key was sent, FALSE when the command has been
+ * postponed.
  */
-    void
+    int
 netbeans_keycommand(int key)
 {
     char	keyName[60];
 
     netbeans_keyname(key, keyName);
-    netbeans_keystring(key, keyName);
+    return netbeans_keystring((char_u *)keyName);
 }
 
 
 /*
  * Send a keypress event back to netbeans. This usually simulates some
  * kind of function key press. This function operates on a key string.
+ * Return TRUE when the key was sent, FALSE when the command has been
+ * postponed.
  */
-    static void
-netbeans_keystring(int key, char *keyName)
+    static int
+netbeans_keystring(char_u *keyName)
 {
     char	buf[2*MAXPATHL];
     int		bufno = nb_getbufno(curbuf);
     long	off;
     char_u	*q;
 
     if (!haveConnection)
-	return;
+	return TRUE;
 
 
     if (bufno == -1)
     {
 	nbdebug(("got keycommand for non-NetBeans buffer, opening...\n"));
 	q = curbuf->b_ffname == NULL ? (char_u *)""
 						 : nb_quote(curbuf->b_ffname);
 	if (q == NULL)
-	    return;
+	    return TRUE;
 	vim_snprintf(buf, sizeof(buf), "0:fileOpened=%d \"%s\" %s %s\n", 0,
 		q,
 		"T",  /* open in NetBeans */
 		"F"); /* modified */
 	if (curbuf->b_ffname != NULL)
 	    vim_free(q);
 	nbdebug(("EVT: %s", buf));
 	nb_send(buf, "netbeans_keycommand");
 
-	if (key > 0)
-	    postpone_keycommand(key);
-	return;
+	postpone_keycommand(keyName);
+	return FALSE;
     }
 
     /* sync the cursor position */
     off = pos2off(curbuf, &curwin->w_cursor);
     sprintf(buf, "%d:newDotAndMark=%d %ld %ld\n", bufno, r_cmdno, off, off);
@@ -3207,10 +3234,11 @@ netbeans_keystring(int key, char *keyNam
     vim_snprintf(buf, sizeof(buf), "%d:keyAtPos=%d \"%s\" %ld %ld/%ld\n",
 	    bufno, r_cmdno, keyName,
 		off, (long)curwin->w_cursor.lnum, (long)curwin->w_cursor.col);
     nbdebug(("EVT: %s", buf));
     nb_send(buf, "netbeans_keycommand");
+    return TRUE;
 }
 
 
 /*
  * Send a save event to netbeans.
@@ -3375,11 +3403,11 @@ netbeans_gutter_click(linenr_T lnum)
     }
 }
 
 
 /*
- * Add a sign of the reqested type at the requested location.
+ * Add a sign of the requested type at the requested location.
  *
  * Reverse engineering:
  * Apparently an annotation is defined the first time it is used in a buffer.
  * When the same annotation is used in two buffers, the second time we do not
  * need to define a new sign name but reuse the existing one.  But since the
@@ -3389,17 +3417,16 @@ netbeans_gutter_click(linenr_T lnum)
  *
  * globalsignmap[]	stores the signs that have been defined globally.
  * buf->signmapused[]	maps buffer-local annotation IDs to an index in
  *			globalsignmap[].
  */
-/*ARGSUSED*/
     static void
 addsigntype(
     nbbuf_T	*buf,
     int		typeNum,
     char_u	*typeName,
-    char_u	*tooltip,
+    char_u	*tooltip UNUSED,
     char_u	*glyphFile,
     int		use_fg,
     int		fg,
     int		use_bg,
     int		bg)
@@ -3529,11 +3556,12 @@ get_buf_size(buf_T *bufp)
 	    eol_size = 2;
 	else
 	    eol_size = 1;
 	for (lnum = 1; lnum <= bufp->b_ml.ml_line_count; ++lnum)
 	{
-	    char_count += (long)STRLEN(ml_get(lnum)) + eol_size;
+	    char_count += (long)STRLEN(ml_get_buf(bufp, lnum, FALSE))
+								   + eol_size;
 	    /* Check for a CTRL-C every 100000 characters */
 	    if (char_count > last_check)
 	    {
 		ui_breakcheck();
 		if (got_int)
--- vim72.orig/src/popupmnu.c
+++ vim72/src/popupmnu.c
@@ -343,25 +343,40 @@ pum_redraw()
 			if (curwin->w_p_rl)
 			{
 			    if (st != NULL)
 			    {
 				char_u	*rt = reverse_text(st);
-				char_u	*rt_saved = rt;
-				int	len, j;
 
 				if (rt != NULL)
 				{
-				    len = (int)STRLEN(rt);
-				    if (len > pum_width)
+				    char_u	*rt_start = rt;
+				    int		size;
+
+				    size = vim_strsize(rt);
+				    if (size > pum_width)
 				    {
-					for (j = pum_width; j < len; ++j)
+					do
+					{
+					    size -= has_mbyte
+						    ? (*mb_ptr2cells)(rt) : 1;
 					    mb_ptr_adv(rt);
-					len = pum_width;
+					} while (size > pum_width);
+
+					if (size < pum_width)
+					{
+					    /* Most left character requires
+					     * 2-cells but only 1 cell is
+					     * available on screen.  Put a
+					     * '<' on the left of the pum
+					     * item */
+					    *(--rt) = '<';
+					    size++;
+					}
 				    }
-				    screen_puts_len(rt, len, row,
-							col - len + 1, attr);
-				    vim_free(rt_saved);
+				    screen_puts_len(rt, (int)STRLEN(rt),
+						   row, col - size + 1, attr);
+				    vim_free(rt_start);
 				}
 				vim_free(st);
 			    }
 			    col -= width;
 			}
@@ -571,11 +586,11 @@ pum_set_selected(n, repeat)
 		}
 		else
 		{
 		    /* Don't want to sync undo in the current buffer. */
 		    ++no_u_sync;
-		    res = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, 0);
+		    res = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, 0, NULL);
 		    --no_u_sync;
 		    if (res == OK)
 		    {
 			/* Edit a new, empty buffer. Set options for a "wipeout"
 			 * buffer. */
--- vim72.orig/src/proto/buffer.pro
+++ vim72/src/proto/buffer.pro
@@ -31,33 +31,32 @@ void buf_set_name __ARGS((int fnum, char
 void buf_name_changed __ARGS((buf_T *buf));
 buf_T *setaltfname __ARGS((char_u *ffname, char_u *sfname, linenr_T lnum));
 char_u *getaltfname __ARGS((int errmsg));
 int buflist_add __ARGS((char_u *fname, int flags));
 void buflist_slash_adjust __ARGS((void));
-void buflist_altfpos __ARGS((void));
+void buflist_altfpos __ARGS((win_T *win));
 int otherfile __ARGS((char_u *ffname));
 void buf_setino __ARGS((buf_T *buf));
 void fileinfo __ARGS((int fullname, int shorthelp, int dont_truncate));
-void col_print __ARGS((char_u *buf, int col, int vcol));
+void col_print __ARGS((char_u *buf, size_t buflen, int col, int vcol));
 void maketitle __ARGS((void));
 void resettitle __ARGS((void));
 void free_titles __ARGS((void));
 int build_stl_str_hl __ARGS((win_T *wp, char_u *out, size_t outlen, char_u *fmt, int use_sandbox, int fillchar, int maxwidth, struct stl_hlrec *hltab, struct stl_hlrec *tabtab));
-void get_rel_pos __ARGS((win_T *wp, char_u *str));
-int append_arg_number __ARGS((win_T *wp, char_u *buf, int add_file, int maxlen));
+void get_rel_pos __ARGS((win_T *wp, char_u *buf, int buflen));
 char_u *fix_fname __ARGS((char_u *fname));
 void fname_expand __ARGS((buf_T *buf, char_u **ffname, char_u **sfname));
 char_u *alist_name __ARGS((aentry_T *aep));
 void do_arg_all __ARGS((int count, int forceit, int keep_tabs));
 void ex_buffer_all __ARGS((exarg_T *eap));
 void do_modelines __ARGS((int flags));
 int read_viminfo_bufferlist __ARGS((vir_T *virp, int writing));
 void write_viminfo_bufferlist __ARGS((FILE *fp));
 char *buf_spname __ARGS((buf_T *buf));
 void buf_addsign __ARGS((buf_T *buf, int id, linenr_T lnum, int typenr));
-int buf_change_sign_type __ARGS((buf_T *buf, int markId, int typenr));
-int_u buf_getsigntype __ARGS((buf_T *buf, linenr_T lnum, int type));
+linenr_T buf_change_sign_type __ARGS((buf_T *buf, int markId, int typenr));
+int buf_getsigntype __ARGS((buf_T *buf, linenr_T lnum, int type));
 linenr_T buf_delsign __ARGS((buf_T *buf, int id));
 int buf_findsign __ARGS((buf_T *buf, int id));
 int buf_findsign_id __ARGS((buf_T *buf, linenr_T lnum));
 int buf_findsigntype_id __ARGS((buf_T *buf, linenr_T lnum, int typenr));
 int buf_signcount __ARGS((buf_T *buf, linenr_T lnum));
--- vim72.orig/src/quickfix.c
+++ vim72/src/quickfix.c
@@ -1417,11 +1417,13 @@ qf_jump(qi, dir, errornr, forceit)
     char_u		*old_swb = p_swb;
     unsigned		old_swb_flags = swb_flags;
     int			opened_window = FALSE;
     win_T		*win;
     win_T		*altwin;
+    int			flags;
 #endif
+    win_T		*oldwin = curwin;
     int			print_message = TRUE;
     int			len;
 #ifdef FEAT_FOLDING
     int			old_KeyTyped = KeyTyped; /* getting file may reset it */
 #endif
@@ -1528,11 +1530,10 @@ qf_jump(qi, dir, errornr, forceit)
      * For ":helpgrep" find a help window or open one.
      */
     if (qf_ptr->qf_type == 1 && (!curwin->w_buffer->b_help || cmdmod.tab != 0))
     {
 	win_T	*wp;
-	int	n;
 
 	if (cmdmod.tab != 0)
 	    wp = NULL;
 	else
 	    for (wp = firstwin; wp != NULL; wp = wp->w_next)
@@ -1544,27 +1545,29 @@ qf_jump(qi, dir, errornr, forceit)
 	{
 	    /*
 	     * Split off help window; put it at far top if no position
 	     * specified, the current window is vertically split and narrow.
 	     */
-	    n = WSP_HELP;
+	    flags = WSP_HELP;
 # ifdef FEAT_VERTSPLIT
 	    if (cmdmod.split == 0 && curwin->w_width != Columns
 						      && curwin->w_width < 80)
-		n |= WSP_TOP;
+		flags |= WSP_TOP;
 # endif
-	    if (win_split(0, n) == FAIL)
+	    if (qi != &ql_info)
+		flags |= WSP_NEWLOC;  /* don't copy the location list */
+
+	    if (win_split(0, flags) == FAIL)
 		goto theend;
 	    opened_window = TRUE;	/* close it when fail */
 
 	    if (curwin->w_height < p_hh)
 		win_setheight((int)p_hh);
 
 	    if (qi != &ql_info)	    /* not a quickfix list */
 	    {
 		/* The new window should use the supplied location list */
-		qf_free_all(curwin);
 		curwin->w_llist = qi;
 		qi->qf_refcount++;
 	    }
 	}
 
@@ -1607,24 +1610,28 @@ qf_jump(qi, dir, errornr, forceit)
 	    {
 		if (wp->w_buffer->b_fnum == qf_ptr->qf_fnum)
 		{
 		    goto_tabpage_win(tp, wp);
 		    usable_win = 1;
-		    break;
+		    goto win_found;
 		}
 	    }
 	}
+win_found:
 
 	/*
 	 * If there is only one window and it is the quickfix window, create a
 	 * new one above the quickfix window.
 	 */
 	if (((firstwin == lastwin) && bt_quickfix(curbuf)) || !usable_win)
 	{
 	    ll_ref = curwin->w_llist_ref;
 
-	    if (win_split(0, WSP_ABOVE) == FAIL)
+	    flags = WSP_ABOVE;
+	    if (ll_ref != NULL)
+		flags |= WSP_NEWLOC;
+	    if (win_split(0, flags) == FAIL)
 		goto failed;		/* not enough room for window */
 	    opened_window = TRUE;	/* close it when fail */
 	    p_swb = empty_option;	/* don't split again */
 	    swb_flags = 0;
 # ifdef FEAT_SCROLLBIND
@@ -1632,11 +1639,10 @@ qf_jump(qi, dir, errornr, forceit)
 # endif
 	    if (ll_ref != NULL)
 	    {
 		/* The new window should use the location list from the
 		 * location list window */
-		qf_free_all(curwin);
 		curwin->w_llist = ll_ref;
 		ll_ref->qf_refcount++;
 	    }
 	}
 	else
@@ -1742,11 +1748,12 @@ qf_jump(qi, dir, errornr, forceit)
 		EMSG(_(e_nowrtmsg));
 		ok = FALSE;
 	    }
 	    else
 		ok = do_ecmd(qf_ptr->qf_fnum, NULL, NULL, NULL, (linenr_T)1,
-						   ECMD_HIDE + ECMD_SET_HELP);
+					   ECMD_HIDE + ECMD_SET_HELP,
+					   oldwin == curwin ? curwin : NULL);
 	}
 	else
 	    ok = buflist_getfile(qf_ptr->qf_fnum,
 			    (linenr_T)1, GETF_SETMARK | GETF_SWITCH, forceit);
     }
@@ -1890,11 +1897,10 @@ qf_list(eap)
     char_u	*fname;
     qfline_T	*qfp;
     int		i;
     int		idx1 = 1;
     int		idx2 = -1;
-    int		need_return = TRUE;
     char_u	*arg = eap->arg;
     int		all = eap->forceit;	/* if not :cl!, only show
 						   recognised errors */
     qf_info_T	*qi = &ql_info;
 
@@ -1930,17 +1936,13 @@ qf_list(eap)
     qfp = qi->qf_lists[qi->qf_curlist].qf_start;
     for (i = 1; !got_int && i <= qi->qf_lists[qi->qf_curlist].qf_count; )
     {
 	if ((qfp->qf_valid || all) && idx1 <= i && i <= idx2)
 	{
-	    if (need_return)
-	    {
-		msg_putchar('\n');
-		if (got_int)
-		    break;
-		need_return = FALSE;
-	    }
+	    msg_putchar('\n');
+	    if (got_int)
+		break;
 
 	    fname = NULL;
 	    if (qfp->qf_fnum != 0
 			      && (buf = buflist_findnr(qfp->qf_fnum)) != NULL)
 	    {
@@ -1979,11 +1981,10 @@ qf_list(eap)
 	    qf_fmt_text((fname != NULL || qfp->qf_lnum != 0)
 				     ? skipwhite(qfp->qf_text) : qfp->qf_text,
 							      IObuff, IOSIZE);
 	    msg_prt_line(IObuff, FALSE);
 	    out_flush();		/* show one line at a time */
-	    need_return = TRUE;
 	}
 
 	qfp = qfp->qf_next;
 	++i;
 	ui_breakcheck();
@@ -2231,11 +2232,10 @@ ex_cwindow(eap)
 
 /*
  * ":cclose": close the window showing the list of errors.
  * ":lclose": close the window showing the location list
  */
-/*ARGSUSED*/
     void
 ex_cclose(eap)
     exarg_T	*eap;
 {
     win_T	*win = NULL;
@@ -2265,10 +2265,11 @@ ex_copen(eap)
     qf_info_T	*qi = &ql_info;
     int		height;
     win_T	*win;
     tabpage_T	*prevtab = curtab;
     buf_T	*qf_buf;
+    win_T	*oldwin = curwin;
 
     if (eap->cmdidx == CMD_lopen || eap->cmdidx == CMD_lwindow)
     {
 	qi = GET_LOC_LIST(curwin);
 	if (qi == NULL)
@@ -2305,43 +2306,48 @@ ex_copen(eap)
 	win = curwin;
 
 	if (eap->cmdidx == CMD_copen || eap->cmdidx == CMD_cwindow)
 	    /* Create the new window at the very bottom. */
 	    win_goto(lastwin);
-	if (win_split(height, WSP_BELOW) == FAIL)
+	if (win_split(height, WSP_BELOW | WSP_NEWLOC) == FAIL)
 	    return;		/* not enough room for window */
 #ifdef FEAT_SCROLLBIND
 	curwin->w_p_scb = FALSE;
 #endif
 
-	/* Remove the location list for the quickfix window */
-	qf_free_all(curwin);
-
 	if (eap->cmdidx == CMD_lopen || eap->cmdidx == CMD_lwindow)
 	{
 	    /*
 	     * For the location list window, create a reference to the
 	     * location list from the window 'win'.
 	     */
 	    curwin->w_llist_ref = win->w_llist;
 	    win->w_llist->qf_refcount++;
 	}
 
+	if (oldwin != curwin)
+	    oldwin = NULL;  /* don't store info when in another window */
 	if (qf_buf != NULL)
 	    /* Use the existing quickfix buffer */
 	    (void)do_ecmd(qf_buf->b_fnum, NULL, NULL, NULL, ECMD_ONE,
-						     ECMD_HIDE + ECMD_OLDBUF);
+					     ECMD_HIDE + ECMD_OLDBUF, oldwin);
 	else
 	{
 	    /* Create a new quickfix buffer */
-	    (void)do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE);
+	    (void)do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, oldwin);
 	    /* switch off 'swapfile' */
 	    set_option_value((char_u *)"swf", 0L, NULL, OPT_LOCAL);
 	    set_option_value((char_u *)"bt", 0L, (char_u *)"quickfix",
 								   OPT_LOCAL);
 	    set_option_value((char_u *)"bh", 0L, (char_u *)"wipe", OPT_LOCAL);
-	    set_option_value((char_u *)"diff", 0L, NULL, OPT_LOCAL);
+#ifdef FEAT_DIFF
+	    curwin->w_p_diff = FALSE;
+#endif
+#ifdef FEAT_FOLDING
+	    set_option_value((char_u *)"fdm", 0L, (char_u *)"manual",
+								   OPT_LOCAL);
+#endif
 	}
 
 	/* Only set the height when still in the same tab page and there is no
 	 * window to the side. */
 	if (curtab == prevtab
@@ -2598,14 +2604,16 @@ qf_fill_buffer(qi)
      * autocommands. */
     set_option_value((char_u *)"ft", 0L, (char_u *)"qf", OPT_LOCAL);
     curbuf->b_p_ma = FALSE;
 
 #ifdef FEAT_AUTOCMD
+    keep_filetype = TRUE;		/* don't detect 'filetype' */
     apply_autocmds(EVENT_BUFREADPOST, (char_u *)"quickfix", NULL,
 							       FALSE, curbuf);
     apply_autocmds(EVENT_BUFWINENTER, (char_u *)"quickfix", NULL,
 							       FALSE, curbuf);
+    keep_filetype = FALSE;
 #endif
 
     /* make sure it will be redrawn */
     redraw_curbuf_later(NOT_VALID);
 
@@ -2757,11 +2765,11 @@ ex_make(eap)
     if (cmd == NULL)
 	return;
     sprintf((char *)cmd, "%s%s%s", (char *)p_shq, (char *)eap->arg,
 							       (char *)p_shq);
     if (*p_sp != NUL)
-	append_redir(cmd, p_sp, fname);
+	append_redir(cmd, len, p_sp, fname);
     /*
      * Output a newline if there's something else than the :make command that
      * was typed (in which case the cursor is in column 0).
      */
     if (msg_col == 0)
@@ -3194,11 +3202,11 @@ ex_vimgrep(eap)
 		    if ((flags & VGR_GLOBAL) == 0
 					       || regmatch.endpos[0].lnum > 0)
 			break;
 		    col = regmatch.endpos[0].col
 					    + (col == regmatch.endpos[0].col);
-		    if (col > STRLEN(ml_get_buf(buf, lnum, FALSE)))
+		    if (col > (colnr_T)STRLEN(ml_get_buf(buf, lnum, FALSE)))
 			break;
 		}
 		line_breakcheck();
 		if (got_int)
 		    break;
@@ -3395,18 +3403,19 @@ load_dummy_buffer(fname)
 	return NULL;
 
     /* Init the options. */
     buf_copy_options(newbuf, BCO_ENTER | BCO_NOHELP);
 
-    /* set curwin/curbuf to buf and save a few things */
-    aucmd_prepbuf(&aco, newbuf);
+    /* need to open the memfile before putting the buffer in a window */
+    if (ml_open(newbuf) == OK)
+    {
+	/* set curwin/curbuf to buf and save a few things */
+	aucmd_prepbuf(&aco, newbuf);
 
-    /* Need to set the filename for autocommands. */
-    (void)setfname(curbuf, fname, NULL, FALSE);
+	/* Need to set the filename for autocommands. */
+	(void)setfname(curbuf, fname, NULL, FALSE);
 
-    if (ml_open(curbuf) == OK)
-    {
 	/* Create swap file now to avoid the ATTENTION message. */
 	check_need_swap(TRUE);
 
 	/* Remove the "dummy" flag, otherwise autocommands may not
 	 * work. */
@@ -3425,14 +3434,14 @@ load_dummy_buffer(fname)
 		if (buf_valid(newbuf))
 		    wipe_buffer(newbuf, FALSE);
 		newbuf = curbuf;
 	    }
 	}
-    }
 
-    /* restore curwin/curbuf and a few other things */
-    aucmd_restbuf(&aco);
+	/* restore curwin/curbuf and a few other things */
+	aucmd_restbuf(&aco);
+    }
 
     if (!buf_valid(newbuf))
 	return NULL;
     if (failed)
     {
--- vim72.orig/src/window.c
+++ vim72/src/window.c
@@ -9,24 +9,24 @@
 
 #include "vim.h"
 
 static int path_is_url __ARGS((char_u *p));
 #if defined(FEAT_WINDOWS) || defined(PROTO)
-static int win_split_ins __ARGS((int size, int flags, win_T *newwin, int dir));
-static void win_init __ARGS((win_T *newp, win_T *oldp));
+static void win_init __ARGS((win_T *newp, win_T *oldp, int flags));
+static void win_init_some __ARGS((win_T *newp, win_T *oldp));
 static void frame_comp_pos __ARGS((frame_T *topfrp, int *row, int *col));
 static void frame_setheight __ARGS((frame_T *curfrp, int height));
 #ifdef FEAT_VERTSPLIT
 static void frame_setwidth __ARGS((frame_T *curfrp, int width));
 #endif
 static void win_exchange __ARGS((long));
 static void win_rotate __ARGS((int, int));
 static void win_totop __ARGS((int size, int flags));
 static void win_equal_rec __ARGS((win_T *next_curwin, int current, frame_T *topfr, int dir, int col, int row, int width, int height));
 static int last_window __ARGS((void));
+static int one_window __ARGS((void));
 static win_T *win_free_mem __ARGS((win_T *win, int *dirp, tabpage_T *tp));
-static win_T *winframe_remove __ARGS((win_T *win, int *dirp, tabpage_T *tp));
 static frame_T *win_altframe __ARGS((win_T *win, tabpage_T *tp));
 static tabpage_T *alt_tabpage __ARGS((void));
 static win_T *frame2win __ARGS((frame_T *frp));
 static int frame_has_win __ARGS((frame_T *frp, win_T *wp));
 static void frame_new_height __ARGS((frame_T *topfrp, int height, int topfirst, int wfh));
@@ -39,20 +39,19 @@ static void frame_add_vsep __ARGS((frame
 static int frame_minwidth __ARGS((frame_T *topfrp, win_T *next_curwin));
 static void frame_fix_width __ARGS((win_T *wp));
 #endif
 #endif
 static int win_alloc_firstwin __ARGS((win_T *oldwin));
+static void new_frame __ARGS((win_T *wp));
 #if defined(FEAT_WINDOWS) || defined(PROTO)
 static tabpage_T *alloc_tabpage __ARGS((void));
 static int leave_tabpage __ARGS((buf_T *new_curbuf));
 static void enter_tabpage __ARGS((tabpage_T *tp, buf_T *old_curbuf));
 static void frame_fix_height __ARGS((win_T *wp));
 static int frame_minheight __ARGS((frame_T *topfrp, win_T *next_curwin));
 static void win_enter_ext __ARGS((win_T *wp, int undo_sync, int no_curwin));
 static void win_free __ARGS((win_T *wp, tabpage_T *tp));
-static void win_append __ARGS((win_T *, win_T *));
-static void win_remove __ARGS((win_T *, tabpage_T *tp));
 static void frame_append __ARGS((frame_T *after, frame_T *frp));
 static void frame_insert __ARGS((frame_T *before, frame_T *frp));
 static void frame_remove __ARGS((frame_T *frp));
 #ifdef FEAT_VERTSPLIT
 static void win_new_width __ARGS((win_T *wp, int width));
@@ -60,21 +59,19 @@ static void win_goto_ver __ARGS((int up,
 static void win_goto_hor __ARGS((int left, long count));
 #endif
 static void frame_add_height __ARGS((frame_T *frp, int n));
 static void last_status_rec __ARGS((frame_T *fr, int statusline));
 
-static void make_snapshot __ARGS((void));
 static void make_snapshot_rec __ARGS((frame_T *fr, frame_T **frp));
-static void clear_snapshot __ARGS((tabpage_T *tp));
+static void clear_snapshot __ARGS((tabpage_T *tp, int idx));
 static void clear_snapshot_rec __ARGS((frame_T *fr));
-static void restore_snapshot __ARGS((int close_curwin));
 static int check_snapshot_rec __ARGS((frame_T *sn, frame_T *fr));
 static win_T *restore_snapshot_rec __ARGS((frame_T *sn, frame_T *fr));
 
 #endif /* FEAT_WINDOWS */
 
-static win_T *win_alloc __ARGS((win_T *after));
+static win_T *win_alloc __ARGS((win_T *after, int hidden));
 static void win_new_height __ARGS((win_T *, int));
 
 #define URL_SLASH	1		/* path_is_url() has found "://" */
 #define URL_BACKSLASH	2		/* path_is_url() has found ":\\" */
 
@@ -257,11 +254,11 @@ newwindow:
     case Ctrl_W:
     case 'w':
 /* cursor to previous window with wrap around */
     case 'W':
 		CHECK_CMDWIN
-		if (lastwin == firstwin && Prenum != 1)	/* just one window */
+		if (firstwin == lastwin && Prenum != 1)	/* just one window */
 		    beep_flush();
 		else
 		{
 		    if (Prenum)			/* go to specified window */
 		    {
@@ -341,11 +338,11 @@ newwindow:
 		break;
 #endif
 
 /* move window to new tab page */
     case 'T':
-		if (firstwin == lastwin)
+		if (one_window())
 		    MSG(_(m_onlyone));
 		else
 		{
 		    tabpage_T	*oldtab = curtab;
 		    tabpage_T	*newtab;
@@ -529,11 +526,12 @@ wingotofile:
 		    if (win_split(0, 0) == OK)
 		    {
 # ifdef FEAT_SCROLLBIND
 			curwin->w_p_scb = FALSE;
 # endif
-			(void)do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL, ECMD_HIDE);
+			(void)do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,
+							   ECMD_HIDE, NULL);
 			if (nchar == 'F' && lnum >= 0)
 			{
 			    curwin->w_cursor.lnum = lnum;
 			    check_cursor_lnum();
 			    beginline(BL_SOL | BL_FIX);
@@ -591,13 +589,11 @@ wingotofile:
 #endif
 		++no_mapping;
 		++allow_keys;   /* no mapping for xchar, but allow key codes */
 		if (xchar == NUL)
 		    xchar = plain_vgetc();
-#ifdef FEAT_LANGMAP
 		LANGMAP_ADJUST(xchar, TRUE);
-#endif
 		--no_mapping;
 		--allow_keys;
 #ifdef FEAT_CMDL_INFO
 		(void)add_to_showcmd(xchar);
 #endif
@@ -628,11 +624,11 @@ wingotofile:
 			break;
 
 #ifdef FEAT_SEARCHPATH
 		    case 'f':	    /* CTRL-W gf: "gf" in a new tab page */
 		    case 'F':	    /* CTRL-W gF: "gF" in a new tab page */
-			cmdmod.tab = TRUE;
+			cmdmod.tab = tabpage_index(curtab) + 1;
 			nchar = xchar;
 			goto wingotofile;
 #endif
 		    default:
 			beep_flush();
@@ -678,24 +674,24 @@ win_split(size, flags)
     }
 
     /* When creating the help window make a snapshot of the window layout.
      * Otherwise clear the snapshot, it's now invalid. */
     if (flags & WSP_HELP)
-	make_snapshot();
+	make_snapshot(SNAP_HELP_IDX);
     else
-	clear_snapshot(curtab);
+	clear_snapshot(curtab, SNAP_HELP_IDX);
 
     return win_split_ins(size, flags, NULL, 0);
 }
 
 /*
  * When "newwin" is NULL: split the current window in two.
  * When "newwin" is not NULL: insert this window at the far
  * top/left/right/bottom.
  * return FAIL for failure, OK otherwise
  */
-    static int
+    int
 win_split_ins(size, flags, newwin, dir)
     int		size;
     int		flags;
     win_T	*newwin;
     int		dir;
@@ -892,29 +888,36 @@ win_split_ins(size, flags, newwin, dir)
 #endif
 			p_sb))))
     {
 	/* new window below/right of current one */
 	if (newwin == NULL)
-	    wp = win_alloc(oldwin);
+	    wp = win_alloc(oldwin, FALSE);
 	else
 	    win_append(oldwin, wp);
     }
     else
     {
 	if (newwin == NULL)
-	    wp = win_alloc(oldwin->w_prev);
+	    wp = win_alloc(oldwin->w_prev, FALSE);
 	else
 	    win_append(oldwin->w_prev, wp);
     }
 
     if (newwin == NULL)
     {
 	if (wp == NULL)
 	    return FAIL;
 
+	new_frame(wp);
+	if (wp->w_frame == NULL)
+	{
+	    win_free(wp, NULL);
+	    return FAIL;
+	}
+
 	/* make the contents of the new window the same as the current one */
-	win_init(wp, curwin);
+	win_init(wp, curwin, flags);
     }
 
     /*
      * Reorganise the tree of frames to insert the new window.
      */
@@ -969,17 +972,11 @@ win_split_ins(size, flags, newwin, dir)
 	    for (frp = frp->fr_child; frp != NULL; frp = frp->fr_next)
 		frp->fr_parent = curfrp;
     }
 
     if (newwin == NULL)
-    {
-	/* Create a frame for the new window. */
-	frp = (frame_T *)alloc_clear((unsigned)sizeof(frame_T));
-	frp->fr_layout = FR_LEAF;
-	frp->fr_win = wp;
-	wp->w_frame = frp;
-    }
+	frp = wp->w_frame;
     else
 	frp = newwin->w_frame;
     frp->fr_parent = curfrp->fr_parent;
 
     /* Insert the new frame at the right place in the frame list. */
@@ -1155,19 +1152,23 @@ win_split_ins(size, flags, newwin, dir)
 	p_wh = i;
 
     return OK;
 }
 
+
 /*
  * Initialize window "newp" from window "oldp".
  * Used when splitting a window and when creating a new tab page.
  * The windows will both edit the same buffer.
+ * WSP_NEWLOC may be specified in flags to prevent the location list from
+ * being copied.
  */
     static void
-win_init(newp, oldp)
+win_init(newp, oldp, flags)
     win_T	*newp;
     win_T	*oldp;
+    int		 flags UNUSED;
 {
     int		i;
 
     newp->w_buffer = oldp->w_buffer;
     oldp->w_buffer->b_nwindows++;
@@ -1188,36 +1189,55 @@ win_init(newp, oldp)
     newp->w_prev_fraction_row = oldp->w_prev_fraction_row;
 #ifdef FEAT_JUMPLIST
     copy_jumplist(oldp, newp);
 #endif
 #ifdef FEAT_QUICKFIX
-    copy_loclist(oldp, newp);
+    if (flags & WSP_NEWLOC)
+    {
+	/* Don't copy the location list.  */
+	newp->w_llist = NULL;
+	newp->w_llist_ref = NULL;
+    }
+    else
+	copy_loclist(oldp, newp);
 #endif
     if (oldp->w_localdir != NULL)
 	newp->w_localdir = vim_strsave(oldp->w_localdir);
 
-    /* Use the same argument list. */
-    newp->w_alist = oldp->w_alist;
-    ++newp->w_alist->al_refcount;
-    newp->w_arg_idx = oldp->w_arg_idx;
-
-    /*
-     * copy tagstack and options from existing window
-     */
+    /* copy tagstack and folds */
     for (i = 0; i < oldp->w_tagstacklen; i++)
     {
 	newp->w_tagstack[i] = oldp->w_tagstack[i];
 	if (newp->w_tagstack[i].tagname != NULL)
 	    newp->w_tagstack[i].tagname =
 				   vim_strsave(newp->w_tagstack[i].tagname);
     }
     newp->w_tagstackidx = oldp->w_tagstackidx;
     newp->w_tagstacklen = oldp->w_tagstacklen;
-    win_copy_options(oldp, newp);
 # ifdef FEAT_FOLDING
     copyFoldingState(oldp, newp);
 # endif
+
+    win_init_some(newp, oldp);
+}
+
+/*
+ * Initialize window "newp" from window"old".
+ * Only the essential things are copied.
+ */
+    static void
+win_init_some(newp, oldp)
+    win_T	*newp;
+    win_T	*oldp;
+{
+    /* Use the same argument list. */
+    newp->w_alist = oldp->w_alist;
+    ++newp->w_alist->al_refcount;
+    newp->w_arg_idx = oldp->w_arg_idx;
+
+    /* copy options from existing window */
+    win_copy_options(oldp, newp);
 }
 
 #endif /* FEAT_WINDOWS */
 
 #if defined(FEAT_WINDOWS) || defined(PROTO)
@@ -1256,15 +1276,14 @@ win_count()
  * Make "count" windows on the screen.
  * Return actual number of windows on the screen.
  * Must be called when there is just one window, filling the whole screen
  * (excluding the command line).
  */
-/*ARGSUSED*/
     int
 make_windows(count, vertical)
     int		count;
-    int		vertical;	/* split windows vertically if TRUE */
+    int		vertical UNUSED;  /* split windows vertically if TRUE */
 {
     int		maxcount;
     int		todo;
 
 #ifdef FEAT_VERTSPLIT
@@ -1555,19 +1574,12 @@ win_totop(size, flags)
     }
 
 #if defined(FEAT_GUI) && defined(FEAT_VERTSPLIT)
     /* When 'guioptions' includes 'L' or 'R' may have to remove or add
      * scrollbars.  Have to update them anyway. */
-    if (gui.in_use)
-    {
-	out_flush();
-	gui_init_which_components(NULL);
-	gui_update_scrollbars(TRUE);
-    }
-    need_mouse_correct = TRUE;
+    gui_may_update_scrollbars();
 #endif
-
 }
 
 /*
  * Move window "win1" to below/right of "win2" and make "win1" the current
  * window.  Only works within the same frame!
@@ -2038,17 +2050,44 @@ close_windows(buf, keep_curwin)
     if (h != tabline_height())
 	shell_new_rows();
 }
 
 /*
- * Return TRUE if the current window is the only window that exists.
+ * Return TRUE if the current window is the only window that exists (ignoring
+ * "aucmd_win").
  * Returns FALSE if there is a window, possibly in another tab page.
  */
     static int
 last_window()
 {
-    return (lastwin == firstwin && first_tabpage->tp_next == NULL);
+    return (one_window() && first_tabpage->tp_next == NULL);
+}
+
+/*
+ * Return TRUE if there is only one window other than "aucmd_win" in the
+ * current tab page.
+ */
+    static int
+one_window()
+{
+#ifdef FEAT_AUTOCMD
+    win_T	*wp;
+    int		seen_one = FALSE;
+
+    FOR_ALL_WINDOWS(wp)
+    {
+	if (wp != aucmd_win)
+	{
+	    if (seen_one)
+		return FALSE;
+	    seen_one = TRUE;
+	}
+    }
+    return TRUE;
+#else
+    return firstwin == lastwin;
+#endif
 }
 
 /*
  * Close window "win".  Only works for the current tab page.
  * If "free_buf" is TRUE related buffer may be unloaded.
@@ -2073,10 +2112,23 @@ win_close(win, free_buf)
     {
 	EMSG(_("E444: Cannot close last window"));
 	return;
     }
 
+#ifdef FEAT_AUTOCMD
+    if (win == aucmd_win)
+    {
+	EMSG(_("E813: Cannot close autocmd window"));
+	return;
+    }
+    if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())
+    {
+	EMSG(_("E814: Cannot close window, only autocmd window would remain"));
+	return;
+    }
+#endif
+
     /*
      * When closing the last window in a tab page first go to another tab
      * page and then close the window and the tab page.  This avoids that
      * curwin and curtab are not invalid while we are freeing memory, they may
      * be used in GUI events.
@@ -2102,11 +2154,11 @@ win_close(win, free_buf)
     /* When closing the help window, try restoring a snapshot after closing
      * the window.  Otherwise clear the snapshot, it's now invalid. */
     if (win->w_buffer->b_help)
 	help_window = TRUE;
     else
-	clear_snapshot(curtab);
+	clear_snapshot(curtab, SNAP_HELP_IDX);
 
 #ifdef FEAT_AUTOCMD
     if (win == curwin)
     {
 	/*
@@ -2219,11 +2271,11 @@ win_close(win, free_buf)
     last_status(FALSE);
 
     /* After closing the help window, try restoring the window layout from
      * before it was opened. */
     if (help_window)
-	restore_snapshot(close_curwin);
+	restore_snapshot(SNAP_HELP_IDX, close_curwin);
 
 #if defined(FEAT_GUI) && defined(FEAT_VERTSPLIT)
     /* When 'guioptions' includes 'L' or 'R' may have to remove scrollbars. */
     if (gui.in_use && !win_hasvertsplit())
 	gui_init_which_components(NULL);
@@ -2300,17 +2352,10 @@ win_free_mem(win, dirp, tp)
     tabpage_T	*tp;		/* tab page "win" is in, NULL for current */
 {
     frame_T	*frp;
     win_T	*wp;
 
-#ifdef FEAT_FOLDING
-    clearFolding(win);
-#endif
-
-    /* reduce the reference count to the argument list. */
-    alist_unlink(win->w_alist);
-
     /* Remove the window and its frame from the tree of frames. */
     frp = win->w_frame;
     wp = winframe_remove(win, dirp, tp);
     vim_free(frp);
     win_free(win, tp);
@@ -2332,24 +2377,31 @@ win_free_all()
 # ifdef FEAT_WINDOWS
     while (first_tabpage->tp_next != NULL)
 	tabpage_close(TRUE);
 # endif
 
+# ifdef FEAT_AUTOCMD
+    if (aucmd_win != NULL)
+    {
+	(void)win_free_mem(aucmd_win, &dummy, NULL);
+	aucmd_win = NULL;
+    }
+# endif
+
     while (firstwin != NULL)
 	(void)win_free_mem(firstwin, &dummy, NULL);
 }
 #endif
 
 /*
  * Remove a window and its frame from the tree of frames.
  * Returns a pointer to the window that got the freed up space.
  */
-/*ARGSUSED*/
-    static win_T *
+    win_T *
 winframe_remove(win, dirp, tp)
     win_T	*win;
-    int		*dirp;		/* set to 'v' or 'h' for direction if 'ea' */
+    int		*dirp UNUSED;	/* set to 'v' or 'h' for direction if 'ea' */
     tabpage_T	*tp;		/* tab page "win" is in, NULL for current */
 {
     frame_T	*frp, *frp2, *frp3;
     frame_T	*frp_close = win->w_frame;
     win_T	*wp;
@@ -3081,11 +3133,11 @@ close_others(message, forceit)
 {
     win_T	*wp;
     win_T	*nextwp;
     int		r;
 
-    if (lastwin == firstwin)
+    if (one_window())
     {
 	if (message
 #ifdef FEAT_AUTOCMD
 		    && !autocmd_busy
 #endif
@@ -3143,31 +3195,38 @@ close_others(message, forceit)
  * Called when a new file is being edited.
  */
     void
 curwin_init()
 {
-    redraw_win_later(curwin, NOT_VALID);
-    curwin->w_lines_valid = 0;
-    curwin->w_cursor.lnum = 1;
-    curwin->w_curswant = curwin->w_cursor.col = 0;
+    win_init_empty(curwin);
+}
+
+    void
+win_init_empty(wp)
+    win_T *wp;
+{
+    redraw_win_later(wp, NOT_VALID);
+    wp->w_lines_valid = 0;
+    wp->w_cursor.lnum = 1;
+    wp->w_curswant = wp->w_cursor.col = 0;
 #ifdef FEAT_VIRTUALEDIT
-    curwin->w_cursor.coladd = 0;
+    wp->w_cursor.coladd = 0;
 #endif
-    curwin->w_pcmark.lnum = 1;	/* pcmark not cleared but set to line 1 */
-    curwin->w_pcmark.col = 0;
-    curwin->w_prev_pcmark.lnum = 0;
-    curwin->w_prev_pcmark.col = 0;
-    curwin->w_topline = 1;
+    wp->w_pcmark.lnum = 1;	/* pcmark not cleared but set to line 1 */
+    wp->w_pcmark.col = 0;
+    wp->w_prev_pcmark.lnum = 0;
+    wp->w_prev_pcmark.col = 0;
+    wp->w_topline = 1;
 #ifdef FEAT_DIFF
-    curwin->w_topfill = 0;
+    wp->w_topfill = 0;
 #endif
-    curwin->w_botline = 2;
+    wp->w_botline = 2;
 #ifdef FEAT_FKMAP
-    if (curwin->w_p_rl)
-	curwin->w_farsi = W_CONV + W_R_L;
+    if (wp->w_p_rl)
+	wp->w_farsi = W_CONV + W_R_L;
     else
-	curwin->w_farsi = W_CONV;
+	wp->w_farsi = W_CONV;
 #endif
 }
 
 /*
  * Allocate the first window and put an empty buffer in it.
@@ -3185,13 +3244,34 @@ win_alloc_first()
     if (first_tabpage == NULL)
 	return FAIL;
     first_tabpage->tp_topframe = topframe;
     curtab = first_tabpage;
 #endif
+
     return OK;
 }
 
+#if defined(FEAT_AUTOCMD) || defined(PROTO)
+/*
+ * Init "aucmd_win".  This can only be done after the first
+ * window is fully initialized, thus it can't be in win_alloc_first().
+ */
+    void
+win_alloc_aucmd_win()
+{
+    aucmd_win = win_alloc(NULL, TRUE);
+    if (aucmd_win != NULL)
+    {
+	win_init_some(aucmd_win, curwin);
+# ifdef FEAT_SCROLLBIND
+	aucmd_win->w_p_scb = FALSE;
+# endif
+	new_frame(aucmd_win);
+    }
+}
+#endif
+
 /*
  * Allocate the first window or the first window in a new tab page.
  * When "oldwin" is NULL create an empty buffer for it.
  * When "oldwin" is not NULL copy info from it to the new window (only with
  * FEAT_WINDOWS).
@@ -3199,11 +3279,11 @@ win_alloc_first()
  */
     static int
 win_alloc_firstwin(oldwin)
     win_T	*oldwin;
 {
-    curwin = win_alloc(NULL);
+    curwin = win_alloc(NULL, FALSE);
     if (oldwin == NULL)
     {
 	/* Very first window, need to create an empty buffer for it and
 	 * initialize from scratch. */
 	curbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);
@@ -3218,34 +3298,49 @@ win_alloc_firstwin(oldwin)
     }
 #ifdef FEAT_WINDOWS
     else
     {
 	/* First window in new tab page, initialize it from "oldwin". */
-	win_init(curwin, oldwin);
+	win_init(curwin, oldwin, 0);
 
 # ifdef FEAT_SCROLLBIND
 	/* We don't want scroll-binding in the first window. */
 	curwin->w_p_scb = FALSE;
 # endif
     }
 #endif
 
-    topframe = (frame_T *)alloc_clear((unsigned)sizeof(frame_T));
-    if (topframe == NULL)
+    new_frame(curwin);
+    if (curwin->w_frame == NULL)
 	return FAIL;
-    topframe->fr_layout = FR_LEAF;
+    topframe = curwin->w_frame;
 #ifdef FEAT_VERTSPLIT
     topframe->fr_width = Columns;
 #endif
     topframe->fr_height = Rows - p_ch;
     topframe->fr_win = curwin;
-    curwin->w_frame = topframe;
 
     return OK;
 }
 
 /*
+ * Create a frame for window "wp".
+ */
+    static void
+new_frame(win_T *wp)
+{
+    frame_T *frp = (frame_T *)alloc_clear((unsigned)sizeof(frame_T));
+
+    wp->w_frame = frp;
+    if (frp != NULL)
+    {
+	frp->fr_layout = FR_LEAF;
+	frp->fr_win = wp;
+    }
+}
+
+/*
  * Initialize the window and frame size to the maximum.
  */
     void
 win_init_size()
 {
@@ -3291,14 +3386,17 @@ alloc_tabpage()
 
     void
 free_tabpage(tp)
     tabpage_T	*tp;
 {
+    int idx;
+
 # ifdef FEAT_DIFF
     diff_clear(tp);
 # endif
-    clear_snapshot(tp);
+    for (idx = 0; idx < SNAP_COUNT; ++idx)
+	clear_snapshot(tp, idx);
 #ifdef FEAT_EVAL
     vars_clear(&tp->tp_vars.dv_hashtab);	/* free all t: variables */
 #endif
     vim_free(tp);
 }
@@ -3361,16 +3459,11 @@ win_new_tabpage(after)
 	last_status(FALSE);
 
 #if defined(FEAT_GUI)
 	/* When 'guioptions' includes 'L' or 'R' may have to remove or add
 	 * scrollbars.  Have to update them anyway. */
-	if (gui.in_use && starting == 0)
-	{
-	    gui_init_which_components(NULL);
-	    gui_update_scrollbars(TRUE);
-	}
-	need_mouse_correct = TRUE;
+	gui_may_update_scrollbars();
 #endif
 
 	redraw_all_later(CLEAR);
 #ifdef FEAT_AUTOCMD
 	apply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);
@@ -3488,14 +3581,13 @@ tabpage_index(ftp)
  * Prepare for leaving the current tab page.
  * When autocomands change "curtab" we don't leave the tab page and return
  * FAIL.
  * Careful: When OK is returned need to get a new tab page very very soon!
  */
-/*ARGSUSED*/
     static int
 leave_tabpage(new_curbuf)
-    buf_T	*new_curbuf;	    /* what is going to be the new curbuf,
+    buf_T	*new_curbuf UNUSED;    /* what is going to be the new curbuf,
 				       NULL if unknown */
 {
     tabpage_T	*tp = curtab;
 
 #ifdef FEAT_VISUAL
@@ -3533,15 +3625,14 @@ leave_tabpage(new_curbuf)
 
 /*
  * Start using tab page "tp".
  * Only to be used after leave_tabpage() or freeing the current tab page.
  */
-/*ARGSUSED*/
     static void
 enter_tabpage(tp, old_curbuf)
     tabpage_T	*tp;
-    buf_T	*old_curbuf;
+    buf_T	*old_curbuf UNUSED;
 {
     int		old_off = tp->tp_firstwin->w_winrow;
     win_T	*next_prevwin = tp->tp_prevwin;
 
     curtab = tp;
@@ -3586,16 +3677,11 @@ enter_tabpage(tp, old_curbuf)
 #endif
 
 #if defined(FEAT_GUI)
     /* When 'guioptions' includes 'L' or 'R' may have to remove or add
      * scrollbars.  Have to update them anyway. */
-    if (gui.in_use && starting == 0)
-    {
-	gui_init_which_components(NULL);
-	gui_update_scrollbars(TRUE);
-    }
-    need_mouse_correct = TRUE;
+    gui_may_update_scrollbars();
 #endif
 
     redraw_all_later(CLEAR);
 }
 
@@ -4026,18 +4112,18 @@ win_enter_ext(wp, undo_sync, curwin_inva
 	    char_u	cwd[MAXPATHL];
 
 	    if (mch_dirname(cwd, MAXPATHL) == OK)
 		globaldir = vim_strsave(cwd);
 	}
-	mch_chdir((char *)curwin->w_localdir);
-	shorten_fnames(TRUE);
+	if (mch_chdir((char *)curwin->w_localdir) == 0)
+	    shorten_fnames(TRUE);
     }
     else if (globaldir != NULL)
     {
 	/* Window doesn't have a local directory and we are not in the global
 	 * directory: Change to the global directory. */
-	mch_chdir((char *)globaldir);
+	ignored = mch_chdir((char *)globaldir);
 	vim_free(globaldir);
 	globaldir = NULL;
 	shorten_fnames(TRUE);
     }
 
@@ -4143,16 +4229,17 @@ buf_jump_open_tab(buf)
 # endif
 }
 #endif
 
 /*
- * allocate a window structure and link it in the window list
+ * Allocate a window structure and link it in the window list when "hidden" is
+ * FALSE.
  */
-/*ARGSUSED*/
     static win_T *
-win_alloc(after)
-    win_T	*after;
+win_alloc(after, hidden)
+    win_T	*after UNUSED;
+    int		hidden UNUSED;
 {
     win_T	*newwin;
 
     /*
      * allocate window structure and linesizes arrays
@@ -4174,11 +4261,12 @@ win_alloc(after)
 #endif
 	/*
 	 * link the window in the window list
 	 */
 #ifdef FEAT_WINDOWS
-	win_append(after, newwin);
+	if (!hidden)
+	    win_append(after, newwin);
 #endif
 #ifdef FEAT_VERTSPLIT
 	newwin->w_wincol = 0;
 	newwin->w_width = Columns;
 #endif
@@ -4235,10 +4323,17 @@ win_free(wp, tp)
     win_T	*wp;
     tabpage_T	*tp;		/* tab page "win" is in, NULL for current */
 {
     int		i;
 
+#ifdef FEAT_FOLDING
+    clearFolding(wp);
+#endif
+
+    /* reduce the reference count to the argument list. */
+    alist_unlink(wp->w_alist);
+
 #ifdef FEAT_AUTOCMD
     /* Don't execute autocommands while the window is halfway being deleted.
      * gui_mch_destroy_scrollbar() may trigger a FocusGained event. */
     block_autocmds();
 #endif
@@ -4297,22 +4392,25 @@ win_free(wp, tp)
 	gui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_LEFT]);
 	gui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_RIGHT]);
     }
 #endif /* FEAT_GUI */
 
-    win_remove(wp, tp);
+#ifdef FEAT_AUTOCMD
+    if (wp != aucmd_win)
+#endif
+	win_remove(wp, tp);
     vim_free(wp);
 
 #ifdef FEAT_AUTOCMD
     unblock_autocmds();
 #endif
 }
 
 /*
  * Append window "wp" in the window list after window "after".
  */
-    static void
+    void
 win_append(after, wp)
     win_T	*after, *wp;
 {
     win_T	*before;
 
@@ -4334,11 +4432,11 @@ win_append(after, wp)
 }
 
 /*
  * Remove a window from the window list.
  */
-    static void
+    void
 win_remove(wp, tp)
     win_T	*wp;
     tabpage_T	*tp;		/* tab page "win" is in, NULL for current */
 {
     if (wp->w_prev != NULL)
@@ -6034,10 +6132,11 @@ min_rows()
 }
 
 /*
  * Return TRUE if there is only one window (in the current tab page), not
  * counting a help or preview window, unless it is the current window.
+ * Does not count "aucmd_win".
  */
     int
 only_one_window()
 {
 #ifdef FEAT_WINDOWS
@@ -6047,15 +6146,19 @@ only_one_window()
     /* If there is another tab page there always is another window. */
     if (first_tabpage->tp_next != NULL)
 	return FALSE;
 
     for (wp = firstwin; wp != NULL; wp = wp->w_next)
-	if (!((wp->w_buffer->b_help && !curbuf->b_help)
+	if ((!((wp->w_buffer->b_help && !curbuf->b_help)
 # ifdef FEAT_QUICKFIX
 		    || wp->w_p_pvw
 # endif
 	     ) || wp == curwin)
+# ifdef FEAT_AUTOCMD
+		&& wp != aucmd_win
+# endif
+	   )
 	    ++count;
     return (count <= 1);
 #else
     return TRUE;
 #endif
@@ -6106,15 +6209,16 @@ check_lnums(do_curwin)
  */
 
 /*
  * Create a snapshot of the current frame sizes.
  */
-    static void
-make_snapshot()
+    void
+make_snapshot(idx)
+    int idx;
 {
-    clear_snapshot(curtab);
-    make_snapshot_rec(topframe, &curtab->tp_snapshot);
+    clear_snapshot(curtab, idx);
+    make_snapshot_rec(topframe, &curtab->tp_snapshot[idx]);
 }
 
     static void
 make_snapshot_rec(fr, frp)
     frame_T	*fr;
@@ -6138,15 +6242,16 @@ make_snapshot_rec(fr, frp)
 
 /*
  * Remove any existing snapshot.
  */
     static void
-clear_snapshot(tp)
+clear_snapshot(tp, idx)
     tabpage_T	*tp;
+    int		idx;
 {
-    clear_snapshot_rec(tp->tp_snapshot);
-    tp->tp_snapshot = NULL;
+    clear_snapshot_rec(tp->tp_snapshot[idx]);
+    tp->tp_snapshot[idx] = NULL;
 }
 
     static void
 clear_snapshot_rec(fr)
     frame_T	*fr;
@@ -6162,30 +6267,31 @@ clear_snapshot_rec(fr)
 /*
  * Restore a previously created snapshot, if there is any.
  * This is only done if the screen size didn't change and the window layout is
  * still the same.
  */
-    static void
-restore_snapshot(close_curwin)
+    void
+restore_snapshot(idx, close_curwin)
+    int		idx;
     int		close_curwin;	    /* closing current window */
 {
     win_T	*wp;
 
-    if (curtab->tp_snapshot != NULL
+    if (curtab->tp_snapshot[idx] != NULL
 # ifdef FEAT_VERTSPLIT
-	    && curtab->tp_snapshot->fr_width == topframe->fr_width
+	    && curtab->tp_snapshot[idx]->fr_width == topframe->fr_width
 # endif
-	    && curtab->tp_snapshot->fr_height == topframe->fr_height
-	    && check_snapshot_rec(curtab->tp_snapshot, topframe) == OK)
+	    && curtab->tp_snapshot[idx]->fr_height == topframe->fr_height
+	    && check_snapshot_rec(curtab->tp_snapshot[idx], topframe) == OK)
     {
-	wp = restore_snapshot_rec(curtab->tp_snapshot, topframe);
+	wp = restore_snapshot_rec(curtab->tp_snapshot[idx], topframe);
 	win_comp_pos();
 	if (wp != NULL && close_curwin)
 	    win_goto(wp);
 	redraw_all_later(CLEAR);
     }
-    clear_snapshot(curtab);
+    clear_snapshot(curtab, idx);
 }
 
 /*
  * Check if frames "sn" and "fr" have the same layout, same following frames
  * and same children.
--- vim72.orig/src/move.c
+++ vim72/src/move.c
@@ -181,13 +181,10 @@ update_topline()
     if (bufempty())		/* special case - file is empty */
     {
 	if (curwin->w_topline != 1)
 	    redraw_later(NOT_VALID);
 	curwin->w_topline = 1;
-#ifdef FEAT_DIFF
-	curwin->w_topfill = 0;
-#endif
 	curwin->w_botline = 2;
 	curwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;
 #ifdef FEAT_SCROLLBIND
 	curwin->w_scbind_pos = 1;
 #endif
@@ -278,22 +275,24 @@ update_topline()
 	if (!(curwin->w_valid & VALID_BOTLINE_AP))
 	    validate_botline();
 
 	if (curwin->w_botline <= curbuf->b_ml.ml_line_count)
 	{
-	    if (curwin->w_cursor.lnum < curwin->w_botline
-		    && ((long)curwin->w_cursor.lnum
+	    if (curwin->w_cursor.lnum < curwin->w_botline)
+	    {
+	      if (((long)curwin->w_cursor.lnum
 					     >= (long)curwin->w_botline - p_so
 #ifdef FEAT_FOLDING
 			|| hasAnyFolding(curwin)
 #endif
 			))
-	    {
+	      {
 		lineoff_T	loff;
 
-		/* Cursor is above botline, check if there are 'scrolloff'
-		 * window lines below the cursor.  If not, need to scroll. */
+		/* Cursor is (a few lines) above botline, check if there are
+		 * 'scrolloff' window lines below the cursor.  If not, need to
+		 * scroll. */
 		n = curwin->w_empty_rows;
 		loff.lnum = curwin->w_cursor.lnum;
 #ifdef FEAT_FOLDING
 		/* In a fold go to its last line. */
 		(void)hasFolding(loff.lnum, NULL, &loff.lnum);
@@ -315,10 +314,14 @@ update_topline()
 		    botline_forw(&loff);
 		}
 		if (n >= p_so)
 		    /* sufficient context, no need to scroll */
 		    check_botline = FALSE;
+	      }
+	      else
+		  /* sufficient context, no need to scroll */
+		  check_botline = FALSE;
 	    }
 	    if (check_botline)
 	    {
 #ifdef FEAT_FOLDING
 		if (hasAnyFolding(curwin))
@@ -507,10 +510,13 @@ set_topline(wp, lnum)
     (void)hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);
 #endif
     /* Approximate the value of w_botline */
     wp->w_botline += lnum - wp->w_topline;
     wp->w_topline = lnum;
+#ifdef FEAT_AUTOCMD
+    wp->w_topline_was_set = TRUE;
+#endif
 #ifdef FEAT_DIFF
     wp->w_topfill = 0;
 #endif
     wp->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_TOPLINE);
     /* Don't set VALID_TOPLINE here, 'scrolloff' needs to be checked. */
@@ -881,26 +887,26 @@ validate_cheight()
     void
 validate_cursor_col()
 {
     colnr_T off;
     colnr_T col;
+    int     width;
 
     validate_virtcol();
     if (!(curwin->w_valid & VALID_WCOL))
     {
 	col = curwin->w_virtcol;
 	off = curwin_col_off();
 	col += off;
+	width = W_WIDTH(curwin) - off + curwin_col_off2();
 
 	/* long line wrapping, adjust curwin->w_wrow */
 	if (curwin->w_p_wrap
 		&& col >= (colnr_T)W_WIDTH(curwin)
-		&& W_WIDTH(curwin) - off + curwin_col_off2() > 0)
-	{
-	    col -= W_WIDTH(curwin);
-	    col = col % (W_WIDTH(curwin) - off + curwin_col_off2());
-	}
+		&& width > 0)
+	    /* use same formula as what is used in curs_columns() */
+	    col -= ((col - W_WIDTH(curwin)) / width + 1) * width;
 	if (col > (int)curwin->w_leftcol)
 	    col -= curwin->w_leftcol;
 	else
 	    col = 0;
 	curwin->w_wcol = col;
@@ -1033,10 +1039,11 @@ curs_columns(scroll)
 	width = textwidth + curwin_col_off2();
 
 	/* long line wrapping, adjust curwin->w_wrow */
 	if (curwin->w_wcol >= W_WIDTH(curwin))
 	{
+	    /* this same formula is used in validate_cursor_col() */
 	    n = (curwin->w_wcol - W_WIDTH(curwin)) / width + 1;
 	    curwin->w_wcol -= n * width;
 	    curwin->w_wrow += n;
 
 #ifdef FEAT_LINEBREAK
@@ -1227,15 +1234,14 @@ curs_columns(scroll)
 }
 
 /*
  * Scroll the current window down by "line_count" logical lines.  "CTRL-Y"
  */
-/*ARGSUSED*/
     void
 scrolldown(line_count, byfold)
     long	line_count;
-    int		byfold;		/* TRUE: count a closed fold as one line */
+    int		byfold UNUSED;	/* TRUE: count a closed fold as one line */
 {
     long	done = 0;	/* total # of physical lines done */
     int		wrow;
     int		moved = FALSE;
 
@@ -1247,11 +1253,12 @@ scrolldown(line_count, byfold)
 #endif
     validate_cursor();		/* w_wrow needs to be valid */
     while (line_count-- > 0)
     {
 #ifdef FEAT_DIFF
-	if (curwin->w_topfill < diff_check(curwin, curwin->w_topline))
+	if (curwin->w_topfill < diff_check(curwin, curwin->w_topline)
+		&& curwin->w_topfill < curwin->w_height - 1)
 	{
 	    ++curwin->w_topfill;
 	    ++done;
 	}
 	else
@@ -1338,15 +1345,14 @@ scrolldown(line_count, byfold)
 }
 
 /*
  * Scroll the current window up by "line_count" logical lines.  "CTRL-E"
  */
-/*ARGSUSED*/
     void
 scrollup(line_count, byfold)
     long	line_count;
-    int		byfold;		/* TRUE: count a closed fold as one line */
+    int		byfold UNUSED;	/* TRUE: count a closed fold as one line */
 {
 #if defined(FEAT_FOLDING) || defined(FEAT_DIFF)
     linenr_T	lnum;
 
     if (
@@ -1602,11 +1608,11 @@ scrollup_clamp()
 
 /*
  * Add one line above "lp->lnum".  This can be a filler line, a closed fold or
  * a (wrapped) text line.  Uses and sets "lp->fill".
  * Returns the height of the added line in "lp->height".
- * Lines above the first one are incredibly high.
+ * Lines above the first one are incredibly high: MAXCOL.
  */
     static void
 topline_back(lp)
     lineoff_T	*lp;
 {
@@ -1934,11 +1940,11 @@ scroll_cursor_bot(min_scroll, set_topbot
 		curwin->w_topline > 1;
 		curwin->w_topline = loff.lnum)
 	{
 	    loff.lnum = curwin->w_topline;
 	    topline_back(&loff);
-	    if (used + loff.height > curwin->w_height)
+	    if (loff.height == MAXCOL || used + loff.height > curwin->w_height)
 		break;
 	    used += loff.height;
 #ifdef FEAT_DIFF
 	    curwin->w_topfill = loff.fill;
 #endif
@@ -2013,11 +2019,14 @@ scroll_cursor_bot(min_scroll, set_topbot
 		)
 	    break;
 
 	/* Add one line above */
 	topline_back(&loff);
-	used += loff.height;
+	if (loff.height == MAXCOL)
+	    used = MAXCOL;
+	else
+	    used += loff.height;
 	if (used > curwin->w_height)
 	    break;
 	if (loff.lnum >= curwin->w_botline
 #ifdef FEAT_DIFF
 		&& (loff.lnum > curwin->w_botline
@@ -2167,11 +2176,14 @@ scroll_cursor_halfway(atend)
 	}
 
 	if (below > above)	    /* add a line above the cursor */
 	{
 	    topline_back(&loff);
-	    used += loff.height;
+	    if (loff.height == MAXCOL)
+		used = MAXCOL;
+	    else
+		used += loff.height;
 	    if (used > curwin->w_height)
 		break;
 	    above += loff.height;
 	    topline = loff.lnum;
 #ifdef FEAT_DIFF
@@ -2464,13 +2476,16 @@ onepage(dir, count)
 	     * at the bottom of the window. */
 	    n = 0;
 	    while (n <= curwin->w_height && loff.lnum >= 1)
 	    {
 		topline_back(&loff);
-		n += loff.height;
+		if (loff.height == MAXCOL)
+		    n = MAXCOL;
+		else
+		    n += loff.height;
 	    }
-	    if (n <= curwin->w_height)		    /* at begin of file */
+	    if (loff.lnum < 1)			/* at begin of file */
 	    {
 		curwin->w_topline = 1;
 #ifdef FEAT_DIFF
 		max_topfill();
 #endif
--- vim72.orig/src/auto/configure
+++ vim72/src/auto/configure
@@ -1,8 +1,8 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.62.
+# Generated by GNU Autoconf 2.63.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
@@ -633,147 +633,151 @@ ac_includes_default="\
 #endif
 #ifdef HAVE_UNISTD_H
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL
-PATH_SEPARATOR
-PACKAGE_NAME
-PACKAGE_TARNAME
-PACKAGE_VERSION
-PACKAGE_STRING
-PACKAGE_BUGREPORT
-exec_prefix
-prefix
-program_transform_name
-bindir
-sbindir
-libexecdir
-datarootdir
-datadir
-sysconfdir
-sharedstatedir
-localstatedir
-includedir
-oldincludedir
-docdir
-infodir
-htmldir
-dvidir
-pdfdir
-psdir
-libdir
-localedir
-mandir
-DEFS
-ECHO_C
-ECHO_N
-ECHO_T
-LIBS
-build_alias
-host_alias
-target_alias
-SET_MAKE
-CC
-CFLAGS
-LDFLAGS
-CPPFLAGS
-ac_ct_CC
-EXEEXT
-OBJEXT
-CPP
-GREP
-EGREP
-AWK
-STRIP
-CPP_MM
-OS_EXTRA_SRC
-OS_EXTRA_OBJ
-VIMNAME
-EXNAME
-VIEWNAME
-line_break
-dovimdiff
-dogvimdiff
-compiledby
-vi_cv_path_mzscheme
-MZSCHEME_SRC
-MZSCHEME_OBJ
-MZSCHEME_PRO
-MZSCHEME_LIBS
-MZSCHEME_CFLAGS
-vi_cv_path_perl
-vi_cv_perllib
-shrpenv
-PERL_SRC
-PERL_OBJ
-PERL_PRO
-PERL_CFLAGS
-PERL_LIBS
-vi_cv_path_python
-PYTHON_CONFDIR
-PYTHON_LIBS
-PYTHON_GETPATH_CFLAGS
-PYTHON_CFLAGS
-PYTHON_SRC
-PYTHON_OBJ
-vi_cv_path_tcl
-TCL_SRC
-TCL_OBJ
-TCL_PRO
-TCL_CFLAGS
-TCL_LIBS
-vi_cv_path_ruby
-RUBY_SRC
-RUBY_OBJ
-RUBY_PRO
-RUBY_CFLAGS
-RUBY_LIBS
-WORKSHOP_SRC
-WORKSHOP_OBJ
-NETBEANS_SRC
-NETBEANS_OBJ
-SNIFF_SRC
-SNIFF_OBJ
-xmkmfpath
-XMKMF
-X_CFLAGS
-X_PRE_LIBS
-X_LIBS
-X_EXTRA_LIBS
-X_LIB
-GTK_CONFIG
-GTK12_CONFIG
-PKG_CONFIG
-GTK_CFLAGS
-GTK_LIBS
-GTK_LIBNAME
-GNOME_LIBS
-GNOME_LIBDIR
-GNOME_INCLUDEDIR
-GNOME_CONFIG
-MOTIF_LIBNAME
-NARROW_PROTO
-GUI_INC_LOC
-GUI_LIB_LOC
-GUITYPE
-GUI_X_LIBS
-HANGULIN_SRC
-HANGULIN_OBJ
-TAGPRG
-INSTALL_LANGS
-INSTALL_TOOL_LANGS
-MSGFMT
-MAKEMO
-DEPEND_CFLAGS_FILTER
+ac_subst_vars='LTLIBOBJS
 LIBOBJS
-LTLIBOBJS'
+DEPEND_CFLAGS_FILTER
+MAKEMO
+MSGFMT
+INSTALL_TOOL_LANGS
+INSTALL_LANGS
+TAGPRG
+HANGULIN_OBJ
+HANGULIN_SRC
+GUI_X_LIBS
+GUITYPE
+GUI_LIB_LOC
+GUI_INC_LOC
+NARROW_PROTO
+MOTIF_LIBNAME
+GNOME_CONFIG
+GNOME_INCLUDEDIR
+GNOME_LIBDIR
+GNOME_LIBS
+GTK_LIBNAME
+GTK_LIBS
+GTK_CFLAGS
+PKG_CONFIG
+GTK12_CONFIG
+GTK_CONFIG
+X_LIB
+X_EXTRA_LIBS
+X_LIBS
+X_PRE_LIBS
+X_CFLAGS
+XMKMF
+xmkmfpath
+SNIFF_OBJ
+SNIFF_SRC
+NETBEANS_OBJ
+NETBEANS_SRC
+WORKSHOP_OBJ
+WORKSHOP_SRC
+RUBY_LIBS
+RUBY_CFLAGS
+RUBY_PRO
+RUBY_OBJ
+RUBY_SRC
+vi_cv_path_ruby
+TCL_LIBS
+TCL_CFLAGS
+TCL_PRO
+TCL_OBJ
+TCL_SRC
+vi_cv_path_tcl
+PYTHON_OBJ
+PYTHON_SRC
+PYTHON_CFLAGS
+PYTHON_GETPATH_CFLAGS
+PYTHON_LIBS
+PYTHON_CONFDIR
+vi_cv_path_python
+PERL_LIBS
+PERL_CFLAGS
+PERL_PRO
+PERL_OBJ
+PERL_SRC
+shrpenv
+vi_cv_perllib
+vi_cv_path_perl
+MZSCHEME_MZC
+MZSCHEME_EXTRA
+MZSCHEME_CFLAGS
+MZSCHEME_LIBS
+MZSCHEME_PRO
+MZSCHEME_OBJ
+MZSCHEME_SRC
+vi_cv_path_mzscheme
+compiledby
+dogvimdiff
+dovimdiff
+line_break
+VIEWNAME
+EXNAME
+VIMNAME
+OS_EXTRA_OBJ
+OS_EXTRA_SRC
+XCODE_SELECT
+CPP_MM
+STRIP
+AWK
+EGREP
+GREP
+CPP
+OBJEXT
+EXEEXT
+ac_ct_CC
+CPPFLAGS
+LDFLAGS
+CFLAGS
+CC
+SET_MAKE
+target_alias
+host_alias
+build_alias
+LIBS
+ECHO_T
+ECHO_N
+ECHO_C
+DEFS
+mandir
+localedir
+libdir
+psdir
+pdfdir
+dvidir
+htmldir
+infodir
+docdir
+oldincludedir
+includedir
+localstatedir
+sharedstatedir
+sysconfdir
+datadir
+datarootdir
+libexecdir
+sbindir
+bindir
+program_transform_name
+prefix
+exec_prefix
+PACKAGE_BUGREPORT
+PACKAGE_STRING
+PACKAGE_VERSION
+PACKAGE_TARNAME
+PACKAGE_NAME
+PATH_SEPARATOR
+SHELL'
 ac_subst_files=''
 ac_user_opts='
 enable_option_checking
 enable_darwin
 with_mac_arch
+with_developer_dir
 with_local_dir
 with_vim_name
 with_ex_name
 with_view_name
 with_global_runtime
@@ -789,10 +793,11 @@ enable_perlinterp
 enable_pythoninterp
 with_python_config_dir
 enable_tclinterp
 with_tclsh
 enable_rubyinterp
+with_ruby_command
 enable_cscope
 enable_workshop
 enable_netbeans
 enable_sniff
 enable_multibyte
@@ -1251,13 +1256,13 @@ if test -n "$ac_prev"; then
 fi
 
 if test -n "$ac_unrecognized_opts"; then
   case $enable_option_checking in
     no) ;;
-    fatal) { $as_echo "$as_me: error: Unrecognized options: $ac_unrecognized_opts" >&2
+    fatal) { $as_echo "$as_me: error: unrecognized options: $ac_unrecognized_opts" >&2
    { (exit 1); exit 1; }; } ;;
-    *)     $as_echo "$as_me: WARNING: Unrecognized options: $ac_unrecognized_opts" >&2 ;;
+    *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
   esac
 fi
 
 # Check all directory arguments for consistency.
 for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
@@ -1306,11 +1311,11 @@ test "$silent" = yes && exec 6>/dev/null
 
 
 ac_pwd=`pwd` && test -n "$ac_pwd" &&
 ac_ls_di=`ls -di .` &&
 ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
-  { $as_echo "$as_me: error: Working directory cannot be determined" >&2
+  { $as_echo "$as_me: error: working directory cannot be determined" >&2
    { (exit 1); exit 1; }; }
 test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
   { $as_echo "$as_me: error: pwd does not report name of working directory" >&2
    { (exit 1); exit 1; }; }
 
@@ -1487,10 +1492,11 @@ Optional Features:
 
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
   --with-mac-arch=ARCH    current, intel, ppc or both
+  --with-developer-dir=PATH    use PATH as location for Xcode developer tools
   --with-local-dir=PATH   search PATH instead of /usr/local for local libraries.
   --without-local-dir     do not search /usr/local for local libraries.
   --with-vim-name=NAME    what to call the Vim executable
   --with-ex-name=NAME     what to call the Ex executable
   --with-view-name=NAME   what to call the View executable
@@ -1499,10 +1505,11 @@ Optional Packages:
   --with-features=TYPE    tiny, small, normal, big or huge (default: normal)
   --with-compiledby=NAME  name to show in :version message
   --with-plthome=PLTHOME   Use PLTHOME.
   --with-python-config-dir=PATH  Python's config directory
   --with-tclsh=PATH       which tclsh to use (default: tclsh8.0)
+  --with-ruby-command=RUBY  name of the Ruby command (default: ruby)
   --with-x                use the X Window System
   --with-gtk-prefix=PFX   Prefix where GTK is installed (optional)
   --with-gtk-exec-prefix=PFX Exec prefix where GTK is installed (optional)
   --with-gnome-includes=DIR Specify location of GNOME headers
   --with-gnome-libs=DIR   Specify location of GNOME libs
@@ -1585,11 +1592,11 @@ fi
 
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
 configure
-generated by GNU Autoconf 2.62
+generated by GNU Autoconf 2.63
 
 Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
@@ -1599,11 +1606,11 @@ fi
 cat >auto/config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
 It was created by $as_me, which was
-generated by GNU Autoconf 2.62.  Invocation command line was
+generated by GNU Autoconf 2.63.  Invocation command line was
 
   $ $0 $@
 
 _ACEOF
 exec 5>>auto/config.log
@@ -1722,12 +1729,12 @@ _ASBOX
   for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
     eval ac_val=\$$ac_var
     case $ac_val in #(
     *${as_nl}*)
       case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: Cache variable $ac_var contains a newline." >&5
-$as_echo "$as_me: WARNING: Cache variable $ac_var contains a newline." >&2;} ;;
+      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
       esac
       case $ac_var in #(
       _ | IFS | as_nl) ;; #(
       BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
       *) $as_unset $ac_var ;;
@@ -1926,10 +1933,12 @@ $as_echo "$as_me:   current value: \`$ac
       *) ac_configure_args="$ac_configure_args '$ac_arg'" ;;
     esac
   fi
 done
 if $ac_cache_corrupted; then
+  { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
   { $as_echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
 $as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
   { { $as_echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
 $as_echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
    { (exit 1); exit 1; }; }
@@ -2082,16 +2091,12 @@ fi
   if test "x$ac_ct_CC" = x; then
     CC=""
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&5
-$as_echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&2;}
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     CC=$ac_ct_CC
   fi
 else
@@ -2286,30 +2291,28 @@ done
   if test "x$ac_ct_CC" = x; then
     CC=""
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&5
-$as_echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&2;}
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     CC=$ac_ct_CC
   fi
 fi
 
 fi
 
 
-test -z "$CC" && { { $as_echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
+test -z "$CC" && { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
 See \`config.log' for more details." >&5
 $as_echo "$as_me: error: no acceptable C compiler found in \$PATH
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 
 # Provide some information about the compiler.
 $as_echo "$as_me:$LINENO: checking for C compiler version" >&5
 set X $ac_compile
 ac_compiler=$2
@@ -2435,15 +2438,17 @@ fi
 $as_echo "$ac_file" >&6; }
 if test -z "$ac_file"; then
   $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
+{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { $as_echo "$as_me:$LINENO: error: C compiler cannot create executables
 See \`config.log' for more details." >&5
 $as_echo "$as_me: error: C compiler cannot create executables
 See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
+   { (exit 77); exit 77; }; }; }
 fi
 
 ac_exeext=$ac_cv_exeext
 
 # Check that the compiler produces executables we can run.  If not, either
@@ -2467,17 +2472,19 @@ $as_echo "$ac_try_echo") >&5
     cross_compiling=no
   else
     if test "$cross_compiling" = maybe; then
 	cross_compiling=yes
     else
-	{ { $as_echo "$as_me:$LINENO: error: cannot run C compiled programs.
+	{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: cannot run C compiled programs.
 If you meant to cross compile, use \`--host'.
 See \`config.log' for more details." >&5
 $as_echo "$as_me: error: cannot run C compiled programs.
 If you meant to cross compile, use \`--host'.
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
     fi
   fi
 fi
 { $as_echo "$as_me:$LINENO: result: yes" >&5
 $as_echo "yes" >&6; }
@@ -2516,15 +2523,17 @@ for ac_file in conftest.exe conftest con
 	  break;;
     * ) break;;
   esac
 done
 else
-  { { $as_echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
+  { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
 See \`config.log' for more details." >&5
 $as_echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 
 rm -f conftest$ac_cv_exeext
 { $as_echo "$as_me:$LINENO: result: $ac_cv_exeext" >&5
 $as_echo "$ac_cv_exeext" >&6; }
@@ -2574,15 +2583,17 @@ $as_echo "$ac_try_echo") >&5
 done
 else
   $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
+{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { $as_echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
 See \`config.log' for more details." >&5
 $as_echo "$as_me: error: cannot compute suffix of object files: cannot compile
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 
 rm -f conftest.$ac_cv_objext conftest.$ac_ext
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_objext" >&5
@@ -3146,15 +3157,17 @@ done
 # Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
 rm -f conftest.err conftest.$ac_ext
 if $ac_preproc_ok; then
   :
 else
-  { { $as_echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
+  { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
 See \`config.log' for more details." >&5
 $as_echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -3821,17 +3834,82 @@ else
   MACARCH="current"; { $as_echo "$as_me:$LINENO: result: defaulting to $MACARCH" >&5
 $as_echo "defaulting to $MACARCH" >&6; }
 fi
 
 
+  { $as_echo "$as_me:$LINENO: checking --with-developer-dir argument" >&5
+$as_echo_n "checking --with-developer-dir argument... " >&6; }
+
+# Check whether --with-developer-dir was given.
+if test "${with_developer_dir+set}" = set; then
+  withval=$with_developer_dir; DEVELOPER_DIR="$withval"; { $as_echo "$as_me:$LINENO: result: $DEVELOPER_DIR" >&5
+$as_echo "$DEVELOPER_DIR" >&6; }
+else
+  DEVELOPER_DIR=""; { $as_echo "$as_me:$LINENO: result: not present" >&5
+$as_echo "not present" >&6; }
+fi
+
+
+  if test "x$DEVELOPER_DIR" = "x"; then
+    # Extract the first word of "xcode-select", so it can be a program name with args.
+set dummy xcode-select; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_path_XCODE_SELECT+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  case $XCODE_SELECT in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_XCODE_SELECT="$XCODE_SELECT" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_XCODE_SELECT="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+XCODE_SELECT=$ac_cv_path_XCODE_SELECT
+if test -n "$XCODE_SELECT"; then
+  { $as_echo "$as_me:$LINENO: result: $XCODE_SELECT" >&5
+$as_echo "$XCODE_SELECT" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    if test "x$XCODE_SELECT" != "x"; then
+      { $as_echo "$as_me:$LINENO: checking for developer dir using xcode-select" >&5
+$as_echo_n "checking for developer dir using xcode-select... " >&6; }
+      DEVELOPER_DIR=`$XCODE_SELECT -print-path`
+      { $as_echo "$as_me:$LINENO: result: $DEVELOPER_DIR" >&5
+$as_echo "$DEVELOPER_DIR" >&6; }
+    else
+      DEVELOPER_DIR=/Developer
+    fi
+  fi
+
   if test "x$MACARCH" = "xboth"; then
     { $as_echo "$as_me:$LINENO: checking for 10.4 universal SDK" >&5
 $as_echo_n "checking for 10.4 universal SDK... " >&6; }
                             save_cppflags="$CPPFLAGS"
     save_cflags="$CFLAGS"
     save_ldflags="$LDFLAGS"
-    CFLAGS="$CFLAGS -isysroot /Developer/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
+    CFLAGS="$CFLAGS -isysroot $DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
     cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
@@ -3948,13 +4026,13 @@ rm -f core conftest.err conftest.$ac_obj
     MACOSX=yes
     OS_EXTRA_SRC="os_macosx.c os_mac_conv.c";
     OS_EXTRA_OBJ="objects/os_macosx.o objects/os_mac_conv.o"
         CPPFLAGS="$CPPFLAGS -DMACOS_X_UNIX -no-cpp-precomp"
     if test "x$MACARCH" = "xboth"; then
-      CPPFLAGS="$CPPFLAGS -I/Developer/SDKs/MacOSX10.4u.sdk/Developer/Headers/FlatCarbon"
+      CPPFLAGS="$CPPFLAGS -I$DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk/Developer/Headers/FlatCarbon"
     else
-      CPPFLAGS="$CPPFLAGS -I/Developer/Headers/FlatCarbon"
+      CPPFLAGS="$CPPFLAGS -I$DEVELOPER_DIR/Headers/FlatCarbon"
     fi
 
                 # On IRIX 5.3, sys/types and inttypes.h are conflicting.
 
 
@@ -4014,12 +4092,13 @@ rm -f core conftest.err conftest.$ac_obj
 fi
 ac_res=`eval 'as_val=${'$as_ac_Header'}
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
 
 fi
@@ -4152,11 +4231,11 @@ else
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_header_Carbon_Carbon_h" >&5
 $as_echo "$ac_cv_header_Carbon_Carbon_h" >&6; }
 
 fi
-if test $ac_cv_header_Carbon_Carbon_h = yes; then
+if test "x$ac_cv_header_Carbon_Carbon_h" = x""yes; then
   CARBON=yes
 fi
 
 
     if test "x$CARBON" = "xyes"; then
@@ -4482,11 +4561,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_selinux_is_selinux_enabled" >&5
 $as_echo "$ac_cv_lib_selinux_is_selinux_enabled" >&6; }
-if test $ac_cv_lib_selinux_is_selinux_enabled = yes; then
+if test "x$ac_cv_lib_selinux_is_selinux_enabled" = x""yes; then
   LIBS="$LIBS -lselinux"
 	   cat >>confdefs.h <<\_ACEOF
 #define HAVE_SELINUX 1
 _ACEOF
 
@@ -4632,12 +4711,12 @@ $as_echo_n "checking PLTHOME environment
     if test "X$PLTHOME" != "X"; then
 	{ $as_echo "$as_me:$LINENO: result: \"$PLTHOME\"" >&5
 $as_echo "\"$PLTHOME\"" >&6; }
 	vi_cv_path_mzscheme_pfx="$PLTHOME"
     else
-	{ $as_echo "$as_me:$LINENO: result: \"not set\"" >&5
-$as_echo "\"not set\"" >&6; }
+	{ $as_echo "$as_me:$LINENO: result: not set" >&5
+$as_echo "not set" >&6; }
 		# Extract the first word of "mzscheme", so it can be a program name with args.
 set dummy mzscheme; ac_word=$2
 { $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
 if test "${ac_cv_path_vi_cv_path_mzscheme+set}" = set; then
@@ -4688,66 +4767,90 @@ fi
 	    	    { $as_echo "$as_me:$LINENO: checking MzScheme install prefix" >&5
 $as_echo_n "checking MzScheme install prefix... " >&6; }
 if test "${vi_cv_path_mzscheme_pfx+set}" = set; then
   $as_echo_n "(cached) " >&6
 else
-   vi_cv_path_mzscheme_pfx=`
-	    ${vi_cv_path_mzscheme} -evm \
-	    "(display (simplify-path		\
+  	    	    echo "(display (simplify-path		\
 	       (build-path (call-with-values	\
 		(lambda () (split-path (find-system-path (quote exec-file)))) \
-		(lambda (base name must-be-dir?) base)) (quote up))))"`
+		(lambda (base name must-be-dir?) base)) (quote up))))" > mzdirs.scm
+	    	     vi_cv_path_mzscheme_pfx=`${vi_cv_path_mzscheme} -r mzdirs.scm | \
+		sed -e 's+/$++'`
 fi
 { $as_echo "$as_me:$LINENO: result: $vi_cv_path_mzscheme_pfx" >&5
 $as_echo "$vi_cv_path_mzscheme_pfx" >&6; }
-	    	    vi_cv_path_mzscheme_pfx=`echo "$vi_cv_path_mzscheme_pfx" | sed 's+/$++'`
+	    rm -f mzdirs.scm
 	fi
     fi
   fi
 
   SCHEME_INC=
   if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
     { $as_echo "$as_me:$LINENO: checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include" >&5
 $as_echo_n "checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include... " >&6; }
     if test -f $vi_cv_path_mzscheme_pfx/include/scheme.h; then
-      { $as_echo "$as_me:$LINENO: result: \"yes\"" >&5
-$as_echo "\"yes\"" >&6; }
+      SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include
+      { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
     else
-      { $as_echo "$as_me:$LINENO: result: \"no\"" >&5
-$as_echo "\"no\"" >&6; }
-      { $as_echo "$as_me:$LINENO: checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/plt/include" >&5
-$as_echo_n "checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/plt/include... " >&6; }
+      { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+      { $as_echo "$as_me:$LINENO: checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/plt" >&5
+$as_echo_n "checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/plt... " >&6; }
       if test -f $vi_cv_path_mzscheme_pfx/include/plt/scheme.h; then
-	{ $as_echo "$as_me:$LINENO: result: \"yes\"" >&5
-$as_echo "\"yes\"" >&6; }
-	SCHEME_INC=/plt
+	{ $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+	SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/plt
       else
-	{ $as_echo "$as_me:$LINENO: result: \"no\"" >&5
-$as_echo "\"no\"" >&6; }
-	vi_cv_path_mzscheme_pfx=
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	{ $as_echo "$as_me:$LINENO: checking if scheme.h can be found in /usr/include/plt/" >&5
+$as_echo_n "checking if scheme.h can be found in /usr/include/plt/... " >&6; }
+	if test -f /usr/include/plt/scheme.h; then
+	  { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+	  SCHEME_INC=/usr/include/plt
+	else
+	  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	  vi_cv_path_mzscheme_pfx=
+	fi
       fi
     fi
   fi
 
   if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
     if test "x$MACOSX" = "xyes"; then
       MZSCHEME_LIBS="-framework PLT_MzScheme"
+    elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"; then
+      MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"
+      MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
     elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"; then
       MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
     else
-      MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
+            if test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.so"; then
+        MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme3m"
+	MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+      else
+        MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
+      fi
       if test "$GCC" = yes; then
-			MZSCHEME_LIBS="$MZSCHEME_LIBS -Wl,-rpath -Wl,${vi_cv_path_mzscheme_pfx}/lib"
+			MZSCHEME_LIBS="${MZSCHEME_LIBS} -Wl,-rpath -Wl,${vi_cv_path_mzscheme_pfx}/lib"
       elif test "`(uname) 2>/dev/null`" = SunOS &&
 			       uname -r | grep '^5' >/dev/null; then
-	MZSCHEME_LIBS="$MZSCHEME_LIBS -R ${vi_cv_path_mzscheme_pfx}/lib"
+	MZSCHEME_LIBS="${MZSCHEME_LIBS} -R ${vi_cv_path_mzscheme_pfx}/lib"
       fi
     fi
     if test -d $vi_cv_path_mzscheme_pfx/lib/plt/collects; then
       SCHEME_COLLECTS=lib/plt/
     fi
-    MZSCHEME_CFLAGS="-I${vi_cv_path_mzscheme_pfx}/include${SCHEME_INC}   \
+    if test -f "${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects/scheme/base.ss" ; then
+            MZSCHEME_EXTRA="mzscheme_base.c"
+      MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DINCLUDE_MZSCHEME_BASE"
+      MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
+    fi
+    MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -I${SCHEME_INC} \
       -DMZSCHEME_COLLECTS='\"${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects\"'"
     MZSCHEME_SRC="if_mzsch.c"
     MZSCHEME_OBJ="objects/if_mzsch.o"
     MZSCHEME_PRO="if_mzsch.pro"
     cat >>confdefs.h <<\_ACEOF
@@ -4758,10 +4861,12 @@ _ACEOF
 
 
 
 
 
+
+
 fi
 
 
 { $as_echo "$as_me:$LINENO: checking --enable-perlinterp argument" >&5
 $as_echo_n "checking --enable-perlinterp argument... " >&6; }
@@ -5089,11 +5194,11 @@ if test "${vi_cv_path_python_conf+set}"
   $as_echo_n "(cached) " >&6
 else
 
 	vi_cv_path_python_conf=
 	for path in "${vi_cv_path_python_pfx}" "${vi_cv_path_python_epfx}"; do
-	  for subdir in lib share; do
+	  for subdir in lib64 lib share; do
 	    d="${path}/${subdir}/python${vi_cv_var_python_version}/config"
 	    if test -d "$d" && test -f "$d/config.c"; then
 	      vi_cv_path_python_conf="$d"
 	    fi
 	  done
@@ -5666,13 +5771,25 @@ else
 fi
 
 { $as_echo "$as_me:$LINENO: result: $enable_rubyinterp" >&5
 $as_echo "$enable_rubyinterp" >&6; }
 if test "$enable_rubyinterp" = "yes"; then
+  { $as_echo "$as_me:$LINENO: checking --with-ruby-command argument" >&5
+$as_echo_n "checking --with-ruby-command argument... " >&6; }
+
+# Check whether --with-ruby-command was given.
+if test "${with_ruby_command+set}" = set; then
+  withval=$with_ruby_command; RUBY_CMD="$withval"; { $as_echo "$as_me:$LINENO: result: $RUBY_CMD" >&5
+$as_echo "$RUBY_CMD" >&6; }
+else
+  RUBY_CMD="ruby"; { $as_echo "$as_me:$LINENO: result: defaulting to $RUBY_CMD" >&5
+$as_echo "defaulting to $RUBY_CMD" >&6; }
+fi
 
-  # Extract the first word of "ruby", so it can be a program name with args.
-set dummy ruby; ac_word=$2
+
+  # Extract the first word of "$RUBY_CMD", so it can be a program name with args.
+set dummy $RUBY_CMD; ac_word=$2
 { $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
 if test "${ac_cv_path_vi_cv_path_ruby+set}" = set; then
   $as_echo_n "(cached) " >&6
 else
@@ -5715,15 +5832,21 @@ $as_echo_n "checking Ruby version... " >
     if $vi_cv_path_ruby -e '(VERSION rescue RUBY_VERSION) >= "1.6.0" or exit 1' >/dev/null 2>/dev/null; then
       { $as_echo "$as_me:$LINENO: result: OK" >&5
 $as_echo "OK" >&6; }
       { $as_echo "$as_me:$LINENO: checking Ruby header files" >&5
 $as_echo_n "checking Ruby header files... " >&6; }
-      rubyhdrdir=`$vi_cv_path_ruby -r mkmf -e 'print Config::CONFIG["archdir"] || $hdrdir' 2>/dev/null`
+      rubyhdrdir=`$vi_cv_path_ruby -r mkmf -e 'print Config::CONFIG["rubyhdrdir"] || Config::CONFIG["archdir"] || $hdrdir' 2>/dev/null`
       if test "X$rubyhdrdir" != "X"; then
 	{ $as_echo "$as_me:$LINENO: result: $rubyhdrdir" >&5
 $as_echo "$rubyhdrdir" >&6; }
 	RUBY_CFLAGS="-I$rubyhdrdir"
+        rubyarch=`$vi_cv_path_ruby -r rbconfig -e 'print Config::CONFIG["arch"]'`
+        if test -d "$rubyhdrdir/$rubyarch"; then
+          RUBY_CFLAGS="$RUBY_CFLAGS -I$rubyhdrdir/$rubyarch"
+        fi
+        rubyversion=`$vi_cv_path_ruby -r rbconfig -e 'print Config::CONFIG["ruby_version"].gsub(/\./, "")[0,2]'`
+        RUBY_CFLAGS="$RUBY_CFLAGS -DRUBY_VERSION=$rubyversion"
 	rubylibs=`$vi_cv_path_ruby -r rbconfig -e 'print Config::CONFIG["LIBS"]'`
 	if test "X$rubylibs" != "X"; then
 	  RUBY_LIBS="$rubylibs"
 	fi
 	librubyarg=`$vi_cv_path_ruby -r rbconfig -e 'print Config.expand(Config::CONFIG["LIBRUBYARG"])'`
@@ -5743,22 +5866,25 @@ $as_echo "$rubyhdrdir" >&6; }
 	if test "X$librubyarg" != "X"; then
 	  RUBY_LIBS="$librubyarg $RUBY_LIBS"
 	fi
 	rubyldflags=`$vi_cv_path_ruby -r rbconfig -e 'print Config::CONFIG["LDFLAGS"]'`
 	if test "X$rubyldflags" != "X"; then
-	  LDFLAGS="$rubyldflags $LDFLAGS"
+	  	  	  	  rubyldflags=`echo "$rubyldflags" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//'`
+	  if test "X$rubyldflags" != "X"; then
+	    LDFLAGS="$rubyldflags $LDFLAGS"
+	  fi
 	fi
 	RUBY_SRC="if_ruby.c"
 	RUBY_OBJ="objects/if_ruby.o"
 	RUBY_PRO="if_ruby.pro"
 	cat >>confdefs.h <<\_ACEOF
 #define FEAT_RUBY 1
 _ACEOF
 
       else
-	{ $as_echo "$as_me:$LINENO: result: not found" >&5
-$as_echo "not found" >&6; }
+	{ $as_echo "$as_me:$LINENO: result: not found; disabling Ruby" >&5
+$as_echo "not found; disabling Ruby" >&6; }
       fi
     else
       { $as_echo "$as_me:$LINENO: result: too old; need Ruby version 1.6.0 or later" >&5
 $as_echo "too old; need Ruby version 1.6.0 or later" >&6; }
     fi
@@ -5889,11 +6015,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_socket_socket" >&5
 $as_echo "$ac_cv_lib_socket_socket" >&6; }
-if test $ac_cv_lib_socket_socket = yes; then
+if test "x$ac_cv_lib_socket_socket" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBSOCKET 1
 _ACEOF
 
   LIBS="-lsocket $LIBS"
@@ -5964,11 +6090,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname" >&5
 $as_echo "$ac_cv_lib_nsl_gethostbyname" >&6; }
-if test $ac_cv_lib_nsl_gethostbyname = yes; then
+if test "x$ac_cv_lib_nsl_gethostbyname" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBNSL 1
 _ACEOF
 
   LIBS="-lnsl $LIBS"
@@ -6201,12 +6327,12 @@ fi
 if test "x$with_x" = xno; then
   # The user explicitly disabled X.
   have_x=disabled
 else
   case $x_includes,$x_libraries in #(
-    *\'*) { { $as_echo "$as_me:$LINENO: error: Cannot use X directory names containing '" >&5
-$as_echo "$as_me: error: Cannot use X directory names containing '" >&2;}
+    *\'*) { { $as_echo "$as_me:$LINENO: error: cannot use X directory names containing '" >&5
+$as_echo "$as_me: error: cannot use X directory names containing '" >&2;}
    { (exit 1); exit 1; }; };; #(
     *,NONE | NONE,*) if test "${ac_cv_have_x+set}" = set; then
   $as_echo_n "(cached) " >&6
 else
   # One or both of the vars are not set, and there is no cached value.
@@ -6240,11 +6366,11 @@ _ACEOF
     case $ac_im_incroot in
 	/usr/include) ac_x_includes= ;;
 	*) test -f "$ac_im_incroot/X11/Xos.h" && ac_x_includes=$ac_im_incroot;;
     esac
     case $ac_im_usrlibdir in
-	/usr/lib | /lib) ;;
+	/usr/lib | /usr/lib64 | /lib | /lib64) ;;
 	*) test -d "$ac_im_usrlibdir" && ac_x_libraries=$ac_im_usrlibdir ;;
     esac
   fi
   cd ..
   rm -f -r conftest.dir
@@ -6680,11 +6806,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dnet_dnet_ntoa" >&5
 $as_echo "$ac_cv_lib_dnet_dnet_ntoa" >&6; }
-if test $ac_cv_lib_dnet_dnet_ntoa = yes; then
+if test "x$ac_cv_lib_dnet_dnet_ntoa" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -ldnet"
 fi
 
     if test $ac_cv_lib_dnet_dnet_ntoa = no; then
       { $as_echo "$as_me:$LINENO: checking for dnet_ntoa in -ldnet_stub" >&5
@@ -6750,11 +6876,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dnet_stub_dnet_ntoa" >&5
 $as_echo "$ac_cv_lib_dnet_stub_dnet_ntoa" >&6; }
-if test $ac_cv_lib_dnet_stub_dnet_ntoa = yes; then
+if test "x$ac_cv_lib_dnet_stub_dnet_ntoa" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -ldnet_stub"
 fi
 
     fi
 fi
@@ -6922,11 +7048,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname" >&5
 $as_echo "$ac_cv_lib_nsl_gethostbyname" >&6; }
-if test $ac_cv_lib_nsl_gethostbyname = yes; then
+if test "x$ac_cv_lib_nsl_gethostbyname" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lnsl"
 fi
 
       if test $ac_cv_lib_nsl_gethostbyname = no; then
 	{ $as_echo "$as_me:$LINENO: checking for gethostbyname in -lbsd" >&5
@@ -6992,11 +7118,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_bsd_gethostbyname" >&5
 $as_echo "$ac_cv_lib_bsd_gethostbyname" >&6; }
-if test $ac_cv_lib_bsd_gethostbyname = yes; then
+if test "x$ac_cv_lib_bsd_gethostbyname" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lbsd"
 fi
 
       fi
     fi
@@ -7158,11 +7284,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_socket_connect" >&5
 $as_echo "$ac_cv_lib_socket_connect" >&6; }
-if test $ac_cv_lib_socket_connect = yes; then
+if test "x$ac_cv_lib_socket_connect" = x""yes; then
   X_EXTRA_LIBS="-lsocket $X_EXTRA_LIBS"
 fi
 
     fi
 
@@ -7317,11 +7443,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_posix_remove" >&5
 $as_echo "$ac_cv_lib_posix_remove" >&6; }
-if test $ac_cv_lib_posix_remove = yes; then
+if test "x$ac_cv_lib_posix_remove" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lposix"
 fi
 
     fi
 
@@ -7476,11 +7602,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_ipc_shmat" >&5
 $as_echo "$ac_cv_lib_ipc_shmat" >&6; }
-if test $ac_cv_lib_ipc_shmat = yes; then
+if test "x$ac_cv_lib_ipc_shmat" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lipc"
 fi
 
     fi
   fi
@@ -7557,11 +7683,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_ICE_IceConnectionNumber" >&5
 $as_echo "$ac_cv_lib_ICE_IceConnectionNumber" >&6; }
-if test $ac_cv_lib_ICE_IceConnectionNumber = yes; then
+if test "x$ac_cv_lib_ICE_IceConnectionNumber" = x""yes; then
   X_PRE_LIBS="$X_PRE_LIBS -lSM -lICE"
 fi
 
   LDFLAGS=$ac_save_LDFLAGS
 
@@ -7725,11 +7851,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xdmcp__XdmcpAuthDoIt" >&5
 $as_echo "$ac_cv_lib_Xdmcp__XdmcpAuthDoIt" >&6; }
-if test $ac_cv_lib_Xdmcp__XdmcpAuthDoIt = yes; then
+if test "x$ac_cv_lib_Xdmcp__XdmcpAuthDoIt" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lXdmcp"
 fi
 
 
                     { $as_echo "$as_me:$LINENO: checking for IceOpenConnection in -lICE" >&5
@@ -7795,11 +7921,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_ICE_IceOpenConnection" >&5
 $as_echo "$ac_cv_lib_ICE_IceOpenConnection" >&6; }
-if test $ac_cv_lib_ICE_IceOpenConnection = yes; then
+if test "x$ac_cv_lib_ICE_IceOpenConnection" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lSM -lICE"
 fi
 
 
         LDFLAGS="$X_LIBS $ac_save_LDFLAGS"
@@ -7866,11 +7992,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xpm_XpmCreatePixmapFromData" >&5
 $as_echo "$ac_cv_lib_Xpm_XpmCreatePixmapFromData" >&6; }
-if test $ac_cv_lib_Xpm_XpmCreatePixmapFromData = yes; then
+if test "x$ac_cv_lib_Xpm_XpmCreatePixmapFromData" = x""yes; then
   X_PRE_LIBS="$X_PRE_LIBS -lXpm"
 fi
 
 
         { $as_echo "$as_me:$LINENO: checking if X11 header files implicitly declare return values" >&5
@@ -7968,10 +8094,86 @@ fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
     CFLAGS=$cflags_save
 
     LDFLAGS="$ac_save_LDFLAGS"
 
+    { $as_echo "$as_me:$LINENO: checking size of wchar_t is 2 bytes" >&5
+$as_echo_n "checking size of wchar_t is 2 bytes... " >&6; }
+    if test "${ac_cv_small_wchar_t+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test "$cross_compiling" = yes; then
+  { { $as_echo "$as_me:$LINENO: error: failed to compile test program" >&5
+$as_echo "$as_me: error: failed to compile test program" >&2;}
+   { (exit 1); exit 1; }; }
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <X11/Xlib.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+		main()
+		{
+		  if (sizeof(wchar_t) <= 2)
+		    exit(1);
+		  exit(0);
+		}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_small_wchar_t="no"
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+$as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_small_wchar_t="yes"
+fi
+rm -rf conftest.dSYM
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+fi
+
+    { $as_echo "$as_me:$LINENO: result: $ac_cv_small_wchar_t" >&5
+$as_echo "$ac_cv_small_wchar_t" >&6; }
+    if test "x$ac_cv_small_wchar_t" = "xyes" ; then
+      cat >>confdefs.h <<\_ACEOF
+#define SMALL_WCHAR_T 1
+_ACEOF
+
+    fi
+
   fi
 fi
 
 test "x$with_x" = xno -a "x$MACOSX" != "xyes" -a "x$QNX" != "xyes" && enable_gui=no
 
@@ -9249,11 +9451,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xext_XShapeQueryExtension" >&5
 $as_echo "$ac_cv_lib_Xext_XShapeQueryExtension" >&6; }
-if test $ac_cv_lib_Xext_XShapeQueryExtension = yes; then
+if test "x$ac_cv_lib_Xext_XShapeQueryExtension" = x""yes; then
   GUI_X_LIBS="-lXext"
 fi
 
     { $as_echo "$as_me:$LINENO: checking for wslen in -lw" >&5
 $as_echo_n "checking for wslen in -lw... " >&6; }
@@ -9318,11 +9520,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_w_wslen" >&5
 $as_echo "$ac_cv_lib_w_wslen" >&6; }
-if test $ac_cv_lib_w_wslen = yes; then
+if test "x$ac_cv_lib_w_wslen" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lw"
 fi
 
   { $as_echo "$as_me:$LINENO: checking for dlsym in -ldl" >&5
 $as_echo_n "checking for dlsym in -ldl... " >&6; }
@@ -9387,11 +9589,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dl_dlsym" >&5
 $as_echo "$ac_cv_lib_dl_dlsym" >&6; }
-if test $ac_cv_lib_dl_dlsym = yes; then
+if test "x$ac_cv_lib_dl_dlsym" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -ldl"
 fi
 
   { $as_echo "$as_me:$LINENO: checking for XmuCreateStippledPixmap in -lXmu" >&5
 $as_echo_n "checking for XmuCreateStippledPixmap in -lXmu... " >&6; }
@@ -9456,11 +9658,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xmu_XmuCreateStippledPixmap" >&5
 $as_echo "$ac_cv_lib_Xmu_XmuCreateStippledPixmap" >&6; }
-if test $ac_cv_lib_Xmu_XmuCreateStippledPixmap = yes; then
+if test "x$ac_cv_lib_Xmu_XmuCreateStippledPixmap" = x""yes; then
   GUI_X_LIBS="-lXmu $GUI_X_LIBS"
 fi
 
   if test -z "$SKIP_MOTIF"; then
     { $as_echo "$as_me:$LINENO: checking for XpEndJob in -lXp" >&5
@@ -9526,11 +9728,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xp_XpEndJob" >&5
 $as_echo "$ac_cv_lib_Xp_XpEndJob" >&6; }
-if test $ac_cv_lib_Xp_XpEndJob = yes; then
+if test "x$ac_cv_lib_Xp_XpEndJob" = x""yes; then
   GUI_X_LIBS="-lXp $GUI_X_LIBS"
 fi
 
   fi
   LDFLAGS=$ldflags_save
@@ -9697,12 +9899,13 @@ ac_res=`eval 'as_val=${'$as_ac_Header'}
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
 
 fi
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
 
 fi
@@ -9850,12 +10053,13 @@ ac_res=`eval 'as_val=${'$as_ac_Header'}
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
 
 fi
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
 
 fi
@@ -10096,12 +10300,13 @@ ac_res=`eval 'as_val=${'$as_ac_Header'}
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
 
 fi
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
 
 fi
@@ -10360,10 +10565,60 @@ sed 's/^/| /' conftest.$ac_ext >&5
 $as_echo "no" >&6; }
 fi
 
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
+{ $as_echo "$as_me:$LINENO: checking whether __attribute__((unused)) is allowed" >&5
+$as_echo_n "checking whether __attribute__((unused)) is allowed... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdio.h>
+int
+main ()
+{
+int x __attribute__((unused));
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }; cat >>confdefs.h <<\_ACEOF
+#define HAVE_ATTRIBUTE_UNUSED 1
+_ACEOF
+
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
 if test "${ac_cv_header_elf_h+set}" = set; then
   { $as_echo "$as_me:$LINENO: checking for elf.h" >&5
 $as_echo_n "checking for elf.h... " >&6; }
 if test "${ac_cv_header_elf_h+set}" = set; then
   $as_echo_n "(cached) " >&6
@@ -10487,11 +10742,11 @@ else
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_header_elf_h" >&5
 $as_echo "$ac_cv_header_elf_h" >&6; }
 
 fi
-if test $ac_cv_header_elf_h = yes; then
+if test "x$ac_cv_header_elf_h" = x""yes; then
   HAS_ELF=1
 fi
 
 
 if test "$HAS_ELF" = 1; then
@@ -10553,11 +10808,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_elf_main" >&5
 $as_echo "$ac_cv_lib_elf_main" >&6; }
-if test $ac_cv_lib_elf_main = yes; then
+if test "x$ac_cv_lib_elf_main" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBELF 1
 _ACEOF
 
   LIBS="-lelf $LIBS"
@@ -10627,12 +10882,13 @@ rm -f core conftest.err conftest.$ac_obj
 fi
 ac_res=`eval 'as_val=${'$as_ac_Header'}
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_hdr" | $as_tr_cpp` 1
 _ACEOF
 
 ac_header_dirent=$ac_hdr; break
@@ -10914,19 +11170,18 @@ fi
 
 
 
 
 
-
 for ac_header in stdarg.h stdlib.h string.h sys/select.h sys/utsname.h \
 	termcap.h fcntl.h sgtty.h sys/ioctl.h sys/time.h sys/types.h termio.h \
 	iconv.h langinfo.h math.h unistd.h stropts.h errno.h \
 	sys/resource.h sys/systeminfo.h locale.h \
 	sys/stream.h termios.h libc.h sys/statfs.h \
 	poll.h sys/poll.h pwd.h utime.h sys/param.h libintl.h \
 	libgen.h util/debug.h util/msg18n.h frame.h \
-	sys/acl.h sys/access.h sys/sysctl.h sys/sysinfo.h wchar.h wctype.h
+	sys/acl.h sys/access.h sys/sysinfo.h wchar.h wctype.h
 do
 as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
   { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
 $as_echo_n "checking for $ac_header... " >&6; }
@@ -11048,31 +11303,97 @@ esac
 { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
 $as_echo_n "checking for $ac_header... " >&6; }
 if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
   $as_echo_n "(cached) " >&6
 else
-  eval "$as_ac_Header=\$ac_header_preproc"
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+ac_res=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+
+fi
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+for ac_header in sys/ptem.h
+do
+as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
+$as_echo_n "checking for $ac_header... " >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#if defined HAVE_SYS_STREAM_H
+#  include <sys/stream.h>
+#endif
+
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  eval "$as_ac_Header=yes"
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval "$as_ac_Header=no"
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 ac_res=`eval 'as_val=${'$as_ac_Header'}
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-
-fi
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
 
 fi
 
 done
 
 
 
-for ac_header in sys/ptem.h
+for ac_header in sys/sysctl.h
 do
 as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
 $as_echo_n "checking for $ac_header... " >&6; }
 if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
@@ -11082,12 +11403,12 @@ else
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#if defined HAVE_SYS_STREAM_H
-#  include <sys/stream.h>
+#if defined HAVE_SYS_PARAM_H
+#  include <sys/param.h>
 #endif
 
 #include <$ac_header>
 _ACEOF
 rm -f conftest.$ac_objext
@@ -11120,12 +11441,13 @@ rm -f core conftest.err conftest.$ac_obj
 fi
 ac_res=`eval 'as_val=${'$as_ac_Header'}
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
 
 fi
@@ -11320,12 +11642,13 @@ ac_res=`eval 'as_val=${'$as_ac_Header'}
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
 
 fi
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
 
 fi
@@ -11563,10 +11886,71 @@ cat >>confdefs.h <<\_ACEOF
 #define const /**/
 _ACEOF
 
 fi
 
+{ $as_echo "$as_me:$LINENO: checking for working volatile" >&5
+$as_echo_n "checking for working volatile... " >&6; }
+if test "${ac_cv_c_volatile+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+volatile int x;
+int * volatile y = (int *) 0;
+return !x && !y;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_c_volatile=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_c_volatile=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_c_volatile" >&5
+$as_echo "$ac_cv_c_volatile" >&6; }
+if test $ac_cv_c_volatile = no; then
+
+cat >>confdefs.h <<\_ACEOF
+#define volatile /**/
+_ACEOF
+
+fi
+
 { $as_echo "$as_me:$LINENO: checking for mode_t" >&5
 $as_echo_n "checking for mode_t... " >&6; }
 if test "${ac_cv_type_mode_t+set}" = set; then
   $as_echo_n "(cached) " >&6
 else
@@ -11657,11 +12041,11 @@ fi
 
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_type_mode_t" >&5
 $as_echo "$ac_cv_type_mode_t" >&6; }
-if test $ac_cv_type_mode_t = yes; then
+if test "x$ac_cv_type_mode_t" = x""yes; then
   :
 else
 
 cat >>confdefs.h <<_ACEOF
 #define mode_t int
@@ -11761,11 +12145,11 @@ fi
 
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_type_off_t" >&5
 $as_echo "$ac_cv_type_off_t" >&6; }
-if test $ac_cv_type_off_t = yes; then
+if test "x$ac_cv_type_off_t" = x""yes; then
   :
 else
 
 cat >>confdefs.h <<_ACEOF
 #define off_t long int
@@ -11865,11 +12249,11 @@ fi
 
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_type_pid_t" >&5
 $as_echo "$ac_cv_type_pid_t" >&6; }
-if test $ac_cv_type_pid_t = yes; then
+if test "x$ac_cv_type_pid_t" = x""yes; then
   :
 else
 
 cat >>confdefs.h <<_ACEOF
 #define pid_t int
@@ -11969,11 +12353,11 @@ fi
 
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_type_size_t" >&5
 $as_echo "$ac_cv_type_size_t" >&6; }
-if test $ac_cv_type_size_t = yes; then
+if test "x$ac_cv_type_size_t" = x""yes; then
   :
 else
 
 cat >>confdefs.h <<_ACEOF
 #define size_t unsigned int
@@ -12173,11 +12557,11 @@ fi
 
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_type_ino_t" >&5
 $as_echo "$ac_cv_type_ino_t" >&6; }
-if test $ac_cv_type_ino_t = yes; then
+if test "x$ac_cv_type_ino_t" = x""yes; then
   :
 else
 
 cat >>confdefs.h <<_ACEOF
 #define ino_t long
@@ -12277,11 +12661,11 @@ fi
 
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_type_dev_t" >&5
 $as_echo "$ac_cv_type_dev_t" >&6; }
-if test $ac_cv_type_dev_t = yes; then
+if test "x$ac_cv_type_dev_t" = x""yes; then
   :
 else
 
 cat >>confdefs.h <<_ACEOF
 #define dev_t unsigned
@@ -12567,12 +12951,13 @@ LIBS=$ac_check_lib_save_LIBS
 fi
 ac_res=`eval 'as_val=${'$as_ac_Lib'}
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-if test `eval 'as_val=${'$as_ac_Lib'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Lib'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_LIB${libname}" | $as_tr_cpp` 1
 _ACEOF
 
   LIBS="-l${libname} $LIBS"
@@ -13419,24 +13804,24 @@ $as_echo "$ac_try_echo") >&5
 	fi
 	{ $as_echo "$as_me:$LINENO: result: pty mode: $vim_cv_tty_mode, group: $vim_cv_tty_group" >&5
 $as_echo "pty mode: $vim_cv_tty_mode, group: $vim_cv_tty_group" >&6; }
       else
 	vim_cv_tty_group=world
-	{ $as_echo "$as_me:$LINENO: result: ptys are world accessable" >&5
-$as_echo "ptys are world accessable" >&6; }
+	{ $as_echo "$as_me:$LINENO: result: ptys are world accessible" >&5
+$as_echo "ptys are world accessible" >&6; }
       fi
 
 else
   $as_echo "$as_me: program exited with status $ac_status" >&5
 $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
 
       vim_cv_tty_group=world
-      { $as_echo "$as_me:$LINENO: result: can't determine - assume ptys are world accessable" >&5
-$as_echo "can't determine - assume ptys are world accessable" >&6; }
+      { $as_echo "$as_me:$LINENO: result: can't determine - assume ptys are world accessible" >&5
+$as_echo "can't determine - assume ptys are world accessible" >&6; }
 
 fi
 rm -rf conftest.dSYM
 rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
@@ -13719,14 +14104,13 @@ fi
 
 
 
 
 
-
-for ac_func in bcmp fchdir fchown fseeko fsync ftello getcwd getpseudotty \
+for ac_func in bcmp fchdir fchown fsync getcwd getpseudotty \
 	getpwnam getpwuid getrlimit gettimeofday getwd lstat memcmp \
-	memset nanosleep opendir putenv qsort readlink select setenv \
+	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
 	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
 	sigvec strcasecmp strerror strftime stricmp strncasecmp \
 	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
 	usleep utime utimes
 do
@@ -13816,19 +14200,152 @@ rm -f core conftest.err conftest.$ac_obj
 fi
 ac_res=`eval 'as_val=${'$as_ac_var'}
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-if test `eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_var'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
 
 fi
 done
 
+{ $as_echo "$as_me:$LINENO: checking for _LARGEFILE_SOURCE value needed for large files" >&5
+$as_echo_n "checking for _LARGEFILE_SOURCE value needed for large files... " >&6; }
+if test "${ac_cv_sys_largefile_source+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  while :; do
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h> /* for off_t */
+     #include <stdio.h>
+int
+main ()
+{
+int (*fp) (FILE *, off_t, int) = fseeko;
+     return fseeko (stdin, 0, 0) && fp (stdin, 0, 0);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_sys_largefile_source=no; break
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#define _LARGEFILE_SOURCE 1
+#include <sys/types.h> /* for off_t */
+     #include <stdio.h>
+int
+main ()
+{
+int (*fp) (FILE *, off_t, int) = fseeko;
+     return fseeko (stdin, 0, 0) && fp (stdin, 0, 0);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_sys_largefile_source=1; break
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+  ac_cv_sys_largefile_source=unknown
+  break
+done
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_sys_largefile_source" >&5
+$as_echo "$ac_cv_sys_largefile_source" >&6; }
+case $ac_cv_sys_largefile_source in #(
+  no | unknown) ;;
+  *)
+cat >>confdefs.h <<_ACEOF
+#define _LARGEFILE_SOURCE $ac_cv_sys_largefile_source
+_ACEOF
+;;
+esac
+rm -rf conftest*
+
+# We used to try defining _XOPEN_SOURCE=500 too, to work around a bug
+# in glibc 2.1.3, but that breaks too many other things.
+# If you want fseeko and ftello with glibc, upgrade to a fixed glibc.
+if test $ac_cv_sys_largefile_source != unknown; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_FSEEKO 1
+_ACEOF
+
+fi
+
 
 { $as_echo "$as_me:$LINENO: checking for st_blksize" >&5
 $as_echo_n "checking for st_blksize... " >&6; }
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -14200,11 +14717,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_m_strtod" >&5
 $as_echo "$ac_cv_lib_m_strtod" >&6; }
-if test $ac_cv_lib_m_strtod = yes; then
+if test "x$ac_cv_lib_m_strtod" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBM 1
 _ACEOF
 
   LIBS="-lm $LIBS"
@@ -14360,11 +14877,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_posix1e_acl_get_file" >&5
 $as_echo "$ac_cv_lib_posix1e_acl_get_file" >&6; }
-if test $ac_cv_lib_posix1e_acl_get_file = yes; then
+if test "x$ac_cv_lib_posix1e_acl_get_file" = x""yes; then
   LIBS="$LIBS -lposix1e"
 else
   { $as_echo "$as_me:$LINENO: checking for acl_get_file in -lacl" >&5
 $as_echo_n "checking for acl_get_file in -lacl... " >&6; }
 if test "${ac_cv_lib_acl_acl_get_file+set}" = set; then
@@ -14428,11 +14945,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_acl_acl_get_file" >&5
 $as_echo "$ac_cv_lib_acl_acl_get_file" >&6; }
-if test $ac_cv_lib_acl_acl_get_file = yes; then
+if test "x$ac_cv_lib_acl_acl_get_file" = x""yes; then
   LIBS="$LIBS -lacl"
 		  { $as_echo "$as_me:$LINENO: checking for fgetxattr in -lattr" >&5
 $as_echo_n "checking for fgetxattr in -lattr... " >&6; }
 if test "${ac_cv_lib_attr_fgetxattr+set}" = set; then
   $as_echo_n "(cached) " >&6
@@ -14495,11 +15012,11 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_attr_fgetxattr" >&5
 $as_echo "$ac_cv_lib_attr_fgetxattr" >&6; }
-if test $ac_cv_lib_attr_fgetxattr = yes; then
+if test "x$ac_cv_lib_attr_fgetxattr" = x""yes; then
   LIBS="$LIBS -lattr"
 fi
 
 fi
 
@@ -14873,10 +15390,62 @@ _ACEOF
 else
   { $as_echo "$as_me:$LINENO: result: yes" >&5
 $as_echo "yes" >&6; }
 fi
 
+{ $as_echo "$as_me:$LINENO: checking for FD_CLOEXEC" >&5
+$as_echo_n "checking for FD_CLOEXEC... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#if HAVE_FCNTL_H
+# include <fcntl.h>
+#endif
+int
+main ()
+{
+	int flag = FD_CLOEXEC;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }; cat >>confdefs.h <<\_ACEOF
+#define HAVE_FD_CLOEXEC 1
+_ACEOF
+
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	{ $as_echo "$as_me:$LINENO: result: not usable" >&5
+$as_echo "not usable" >&6; }
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
 { $as_echo "$as_me:$LINENO: checking for rename" >&5
 $as_echo_n "checking for rename... " >&6; }
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -15224,11 +15793,10 @@ cat >>confdefs.h <<_ACEOF
 #define SIZEOF_INT $ac_cv_sizeof_int
 _ACEOF
 
 
 
-
 bcopy_test_prog='
 #include "confdefs.h"
 #ifdef HAVE_STRING_H
 # include <string.h>
 #endif
@@ -15456,11 +16024,11 @@ fi
 
 
 if test "$enable_multibyte" = "yes"; then
   cflags_save=$CFLAGS
   ldflags_save=$LDFLAGS
-  if test -n "$x_includes" ; then
+  if test "x$x_includes" != "xNONE" ; then
     CFLAGS="$CFLAGS -I$x_includes"
     LDFLAGS="$X_LIBS $LDFLAGS -lX11"
     { $as_echo "$as_me:$LINENO: checking whether X_LOCALE needed" >&5
 $as_echo_n "checking whether X_LOCALE needed... " >&6; }
     cat >conftest.$ac_ext <<_ACEOF
@@ -15633,21 +16201,22 @@ rm -f core conftest.err conftest.$ac_obj
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_xpg4__xpg4_setrunelocale" >&5
 $as_echo "$ac_cv_lib_xpg4__xpg4_setrunelocale" >&6; }
-if test $ac_cv_lib_xpg4__xpg4_setrunelocale = yes; then
+if test "x$ac_cv_lib_xpg4__xpg4_setrunelocale" = x""yes; then
   LIBS="$LIBS -lxpg4"
 fi
 
 
 { $as_echo "$as_me:$LINENO: checking how to create tags" >&5
 $as_echo_n "checking how to create tags... " >&6; }
 test -f tags && mv tags tags.save
 if (eval ctags --version /dev/null | grep Exuberant) < /dev/null 1>&5 2>&1; then
   TAGPRG="ctags -I INIT+ --fields=+S"
 else
+  TAGPRG="ctags"
   (eval etags	   /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="etags"
   (eval etags -c   /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="etags -c"
   (eval ctags	   /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="ctags"
   (eval ctags -t   /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="ctags -t"
   (eval ctags -ts  /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="ctags -ts"
@@ -15931,12 +16500,13 @@ rm -f core conftest.err conftest.$ac_obj
 fi
 ac_res=`eval 'as_val=${'$as_ac_var'}
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-if test `eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_var'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
 
 fi
@@ -16132,11 +16702,11 @@ else
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_header_dlfcn_h" >&5
 $as_echo "$ac_cv_header_dlfcn_h" >&6; }
 
 fi
-if test $ac_cv_header_dlfcn_h = yes; then
+if test "x$ac_cv_header_dlfcn_h" = x""yes; then
   DLL=dlfcn.h
 else
   if test "${ac_cv_header_dl_h+set}" = set; then
   { $as_echo "$as_me:$LINENO: checking for dl.h" >&5
 $as_echo_n "checking for dl.h... " >&6; }
@@ -16262,11 +16832,11 @@ else
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_header_dl_h" >&5
 $as_echo "$ac_cv_header_dl_h" >&6; }
 
 fi
-if test $ac_cv_header_dl_h = yes; then
+if test "x$ac_cv_header_dl_h" = x""yes; then
   DLL=dl.h
 fi
 
 
 fi
@@ -16781,12 +17351,13 @@ ac_res=`eval 'as_val=${'$as_ac_Header'}
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
 
 fi
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
 
 fi
@@ -16814,28 +17385,36 @@ $as_echo "yes" >&6; }
     { $as_echo "$as_me:$LINENO: result: no" >&5
 $as_echo "no" >&6; }
   fi
 fi
 if test "x$MACARCH" = "xboth"; then
-  LDFLAGS="$LDFLAGS -isysroot /Developer/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
+  LDFLAGS="$LDFLAGS -isysroot $DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
 fi
 
-{ $as_echo "$as_me:$LINENO: checking for GCC 3 or later" >&5
-$as_echo_n "checking for GCC 3 or later... " >&6; }
 DEPEND_CFLAGS_FILTER=
 if test "$GCC" = yes; then
+  { $as_echo "$as_me:$LINENO: checking for GCC 3 or later" >&5
+$as_echo_n "checking for GCC 3 or later... " >&6; }
   gccmajor=`echo "$gccversion" | sed -e 's/^\([1-9]\)\..*$/\1/g'`
   if test "$gccmajor" -gt "2"; then
     DEPEND_CFLAGS_FILTER="| sed 's+-I */+-isystem /+g'"
-  fi
-fi
-if test "$DEPEND_CFLAGS_FILTER" = ""; then
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+    { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+  else
+    { $as_echo "$as_me:$LINENO: result: no" >&5
 $as_echo "no" >&6; }
-else
-  { $as_echo "$as_me:$LINENO: result: yes" >&5
+  fi
+        { $as_echo "$as_me:$LINENO: checking whether we need -D_FORTIFY_SOURCE=1" >&5
+$as_echo_n "checking whether we need -D_FORTIFY_SOURCE=1... " >&6; }
+  if test "$gccmajor" -gt "3"; then
+    CFLAGS=`echo "$CFLAGS" | sed -e 's/-Wp,-D_FORTIFY_SOURCE=.//g' -e 's/-D_FORTIFY_SOURCE=.//g' -e 's/$/ -D_FORTIFY_SOURCE=1/'`
+    { $as_echo "$as_me:$LINENO: result: yes" >&5
 $as_echo "yes" >&6; }
+  else
+    { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+  fi
 fi
 
 
 ac_config_files="$ac_config_files auto/config.mk:config.mk.in"
 
@@ -16864,12 +17443,12 @@ _ACEOF
   for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
     eval ac_val=\$$ac_var
     case $ac_val in #(
     *${as_nl}*)
       case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: Cache variable $ac_var contains a newline." >&5
-$as_echo "$as_me: WARNING: Cache variable $ac_var contains a newline." >&2;} ;;
+      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
       esac
       case $ac_var in #(
       _ | IFS | as_nl) ;; #(
       BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
       *) $as_unset $ac_var ;;
@@ -17257,11 +17836,11 @@ exec 6>&1
 # Save the log message, to keep $[0] and so on meaningful, and to
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
 This file was extended by $as_me, which was
-generated by GNU Autoconf 2.62.  Invocation command line was
+generated by GNU Autoconf 2.63.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
   CONFIG_LINKS    = $CONFIG_LINKS
   CONFIG_COMMANDS = $CONFIG_COMMANDS
@@ -17270,10 +17849,19 @@ generated by GNU Autoconf 2.62.  Invocat
 on `(hostname || uname -n) 2>/dev/null | sed 1q`
 "
 
 _ACEOF
 
+case $ac_config_files in *"
+"*) set x $ac_config_files; shift; ac_config_files=$*;;
+esac
+
+case $ac_config_headers in *"
+"*) set x $ac_config_headers; shift; ac_config_headers=$*;;
+esac
+
+
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 # Files that config.status was made for.
 config_files="$ac_config_files"
 config_headers="$ac_config_headers"
 
@@ -17282,20 +17870,21 @@ _ACEOF
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 ac_cs_usage="\
 \`$as_me' instantiates files from templates according to the
 current configuration.
 
-Usage: $0 [OPTIONS] [FILE]...
+Usage: $0 [OPTION]... [FILE]...
 
   -h, --help       print this help, then exit
   -V, --version    print version number and configuration settings, then exit
-  -q, --quiet      do not print progress messages
+  -q, --quiet, --silent
+                   do not print progress messages
   -d, --debug      don't remove temporary files
       --recheck    update $as_me by reconfiguring in the same conditions
-  --file=FILE[:TEMPLATE]
+      --file=FILE[:TEMPLATE]
                    instantiate the configuration file FILE
-  --header=FILE[:TEMPLATE]
+      --header=FILE[:TEMPLATE]
                    instantiate the configuration header FILE
 
 Configuration files:
 $config_files
 
@@ -17306,11 +17895,11 @@ Report bugs to <bug-autoconf@gnu.org>."
 
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
 config.status
-configured by $0, generated by GNU Autoconf 2.62,
+configured by $0, generated by GNU Autoconf 2.63,
   with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
 Copyright (C) 2008 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
@@ -17503,11 +18092,12 @@ for ac_last_try in false false false fal
   . ./conf$$subs.sh ||
     { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
 $as_echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
    { (exit 1); exit 1; }; }
 
-  if test `sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X` = $ac_delim_num; then
+  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
+  if test $ac_delim_n = $ac_delim_num; then
     break
   elif $ac_last_try; then
     { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
 $as_echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
    { (exit 1); exit 1; }; }
@@ -17708,21 +18298,21 @@ cat >>$CONFIG_STATUS <<_ACEOF || ac_writ
     defundef = substr(arg[1], 2)
     mac1 = arg[2]
   }
   split(mac1, mac2, "(") #)
   macro = mac2[1]
+  prefix = substr(line, 1, index(line, defundef) - 1)
   if (D_is_set[macro]) {
     # Preserve the white space surrounding the "#".
-    prefix = substr(line, 1, index(line, defundef) - 1)
     print prefix "define", macro P[macro] D[macro]
     next
   } else {
     # Replace #undef with comments.  This is necessary, for example,
     # in the case of _POSIX_SOURCE, which is predefined and required
     # on some systems where configure will not decide to define it.
     if (defundef == "undef") {
-      print "/*", line, "*/"
+      print "/*", prefix defundef, macro, "*/"
       next
     }
   }
 }
 { print }
@@ -17742,12 +18332,12 @@ do
   case $ac_tag in
   :[FHLC]) ac_mode=$ac_tag; continue;;
   esac
   case $ac_mode$ac_tag in
   :[FHL]*:*);;
-  :L* | :C*:*) { { $as_echo "$as_me:$LINENO: error: Invalid tag $ac_tag." >&5
-$as_echo "$as_me: error: Invalid tag $ac_tag." >&2;}
+  :L* | :C*:*) { { $as_echo "$as_me:$LINENO: error: invalid tag $ac_tag" >&5
+$as_echo "$as_me: error: invalid tag $ac_tag" >&2;}
    { (exit 1); exit 1; }; };;
   :[FH]-) ac_tag=-:-;;
   :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
   esac
   ac_save_IFS=$IFS
@@ -18061,10 +18651,10 @@ if test "$no_create" != yes; then
   # Use ||, not &&, to avoid exiting from the if with $? = 1, which
   # would make configure fail if this is the last instruction.
   $ac_cs_success || { (exit 1); exit 1; }
 fi
 if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
-  { $as_echo "$as_me:$LINENO: WARNING: Unrecognized options: $ac_unrecognized_opts" >&5
-$as_echo "$as_me: WARNING: Unrecognized options: $ac_unrecognized_opts" >&2;}
+  { $as_echo "$as_me:$LINENO: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
+$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
 fi
 
 
--- vim72.orig/src/configure.in
+++ vim72/src/configure.in
@@ -114,10 +114,26 @@ if test "`(uname) 2>/dev/null`" = Darwin
   AC_MSG_CHECKING(--with-mac-arch argument)
   AC_ARG_WITH(mac-arch, [  --with-mac-arch=ARCH    current, intel, ppc or both],
 	MACARCH="$withval"; AC_MSG_RESULT($MACARCH),
 	MACARCH="current"; AC_MSG_RESULT(defaulting to $MACARCH))
 
+  AC_MSG_CHECKING(--with-developer-dir argument)
+  AC_ARG_WITH(developer-dir, [  --with-developer-dir=PATH    use PATH as location for Xcode developer tools],
+	DEVELOPER_DIR="$withval"; AC_MSG_RESULT($DEVELOPER_DIR),
+        DEVELOPER_DIR=""; AC_MSG_RESULT(not present))
+
+  if test "x$DEVELOPER_DIR" = "x"; then
+    AC_PATH_PROG(XCODE_SELECT, xcode-select)
+    if test "x$XCODE_SELECT" != "x"; then
+      AC_MSG_CHECKING(for developer dir using xcode-select)
+      DEVELOPER_DIR=`$XCODE_SELECT -print-path`
+      AC_MSG_RESULT([$DEVELOPER_DIR])
+    else
+      DEVELOPER_DIR=/Developer
+    fi
+  fi
+
   if test "x$MACARCH" = "xboth"; then
     AC_MSG_CHECKING(for 10.4 universal SDK)
     dnl There is a terrible inconsistency (but we appear to get away with it):
     dnl $CFLAGS uses the 10.4u SDK library for the headers, while $CPPFLAGS
     dnl doesn't, because "gcc -E" doesn't grok it.  That means the configure
@@ -125,11 +141,11 @@ if test "`(uname) 2>/dev/null`" = Darwin
     dnl files. $LDFLAGS is set at the end, because configure uses it together
     dnl with $CFLAGS and we can only have one -sysroot argument.
     save_cppflags="$CPPFLAGS"
     save_cflags="$CFLAGS"
     save_ldflags="$LDFLAGS"
-    CFLAGS="$CFLAGS -isysroot /Developer/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
+    CFLAGS="$CFLAGS -isysroot $DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
     AC_TRY_LINK([ ], [ ],
 	AC_MSG_RESULT(found, will make universal binary),
 
 	AC_MSG_RESULT(not found)
 	CFLAGS="$save_cflags"
@@ -155,13 +171,13 @@ if test "`(uname) 2>/dev/null`" = Darwin
     OS_EXTRA_SRC="os_macosx.c os_mac_conv.c";
     OS_EXTRA_OBJ="objects/os_macosx.o objects/os_mac_conv.o"
     dnl TODO: use -arch i386 on Intel machines
     CPPFLAGS="$CPPFLAGS -DMACOS_X_UNIX -no-cpp-precomp"
     if test "x$MACARCH" = "xboth"; then
-      CPPFLAGS="$CPPFLAGS -I/Developer/SDKs/MacOSX10.4u.sdk/Developer/Headers/FlatCarbon"
+      CPPFLAGS="$CPPFLAGS -I$DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk/Developer/Headers/FlatCarbon"
     else
-      CPPFLAGS="$CPPFLAGS -I/Developer/Headers/FlatCarbon"
+      CPPFLAGS="$CPPFLAGS -I$DEVELOPER_DIR/Headers/FlatCarbon"
     fi
 
     dnl If Carbon is found, assume we don't want X11
     dnl unless it was specifically asked for (--with-x)
     dnl or Motif, Athena or GTK GUI is used.
@@ -412,11 +428,11 @@ if test "$enable_mzschemeinterp" = "yes"
     AC_MSG_CHECKING(PLTHOME environment var)
     if test "X$PLTHOME" != "X"; then
 	AC_MSG_RESULT("$PLTHOME")
 	vi_cv_path_mzscheme_pfx="$PLTHOME"
     else
-	AC_MSG_RESULT("not set")
+	AC_MSG_RESULT(not set)
 	dnl -- try to find MzScheme executable
 	AC_PATH_PROG(vi_cv_path_mzscheme, mzscheme)
 
 	dnl resolve symbolic link, the executable is often elsewhere and there
 	dnl are no links for the include files.
@@ -428,60 +444,85 @@ if test "$enable_mzschemeinterp" = "yes"
 	fi
 
 	if test "X$vi_cv_path_mzscheme" != "X"; then
 	    dnl -- find where MzScheme thinks it was installed
 	    AC_CACHE_CHECK(MzScheme install prefix,vi_cv_path_mzscheme_pfx,
-	    [ vi_cv_path_mzscheme_pfx=`
-	    ${vi_cv_path_mzscheme} -evm \
-	    "(display (simplify-path		\
+	    dnl different versions of MzScheme differ in command line processing
+	    dnl use universal approach
+	    echo "(display (simplify-path		\
 	       (build-path (call-with-values	\
 		(lambda () (split-path (find-system-path (quote exec-file)))) \
-		(lambda (base name must-be-dir?) base)) (quote up))))"` ])
-	    dnl Remove a trailing slash.
-	    vi_cv_path_mzscheme_pfx=`echo "$vi_cv_path_mzscheme_pfx" | sed 's+/$++'`
+		(lambda (base name must-be-dir?) base)) (quote up))))" > mzdirs.scm
+	    dnl Remove a trailing slash
+	    [ vi_cv_path_mzscheme_pfx=`${vi_cv_path_mzscheme} -r mzdirs.scm | \
+		sed -e 's+/$++'` ])
+	    rm -f mzdirs.scm
 	fi
     fi
   fi
 
   SCHEME_INC=
   if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
     AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include)
     if test -f $vi_cv_path_mzscheme_pfx/include/scheme.h; then
-      AC_MSG_RESULT("yes")
+      SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include
+      AC_MSG_RESULT(yes)
     else
-      AC_MSG_RESULT("no")
-      AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/plt/include)
+      AC_MSG_RESULT(no)
+      AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/plt)
       if test -f $vi_cv_path_mzscheme_pfx/include/plt/scheme.h; then
-	AC_MSG_RESULT("yes")
-	SCHEME_INC=/plt
+	AC_MSG_RESULT(yes)
+	SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/plt
       else
-	AC_MSG_RESULT("no")
-	vi_cv_path_mzscheme_pfx=
+	AC_MSG_RESULT(no)
+	AC_MSG_CHECKING(if scheme.h can be found in /usr/include/plt/)
+	if test -f /usr/include/plt/scheme.h; then
+	  AC_MSG_RESULT(yes)
+	  SCHEME_INC=/usr/include/plt
+	else
+	  AC_MSG_RESULT(no)
+	  vi_cv_path_mzscheme_pfx=
+	fi
       fi
     fi
   fi
 
   if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
     if test "x$MACOSX" = "xyes"; then
       MZSCHEME_LIBS="-framework PLT_MzScheme"
+    elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"; then
+      MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"
+      MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
     elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"; then
       MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
     else
-      MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
+      dnl Using shared objects
+      if test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.so"; then
+        MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme3m"
+	MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+      else
+        MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
+      fi
       if test "$GCC" = yes; then
 	dnl Make Vim remember the path to the library.  For when it's not in
 	dnl $LD_LIBRARY_PATH.
-	MZSCHEME_LIBS="$MZSCHEME_LIBS -Wl,-rpath -Wl,${vi_cv_path_mzscheme_pfx}/lib"
+	MZSCHEME_LIBS="${MZSCHEME_LIBS} -Wl,-rpath -Wl,${vi_cv_path_mzscheme_pfx}/lib"
       elif test "`(uname) 2>/dev/null`" = SunOS &&
 			       uname -r | grep '^5' >/dev/null; then
-	MZSCHEME_LIBS="$MZSCHEME_LIBS -R ${vi_cv_path_mzscheme_pfx}/lib"
+	MZSCHEME_LIBS="${MZSCHEME_LIBS} -R ${vi_cv_path_mzscheme_pfx}/lib"
       fi
     fi
     if test -d $vi_cv_path_mzscheme_pfx/lib/plt/collects; then
       SCHEME_COLLECTS=lib/plt/
     fi
-    MZSCHEME_CFLAGS="-I${vi_cv_path_mzscheme_pfx}/include${SCHEME_INC}   \
+    if test -f "${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects/scheme/base.ss" ; then
+      dnl need to generate bytecode for MzScheme base
+      MZSCHEME_EXTRA="mzscheme_base.c"
+      MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DINCLUDE_MZSCHEME_BASE"
+      MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
+    fi
+    MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -I${SCHEME_INC} \
       -DMZSCHEME_COLLECTS='\"${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects\"'"
     MZSCHEME_SRC="if_mzsch.c"
     MZSCHEME_OBJ="objects/if_mzsch.o"
     MZSCHEME_PRO="if_mzsch.pro"
     AC_DEFINE(FEAT_MZSCHEME)
@@ -489,10 +530,12 @@ if test "$enable_mzschemeinterp" = "yes"
   AC_SUBST(MZSCHEME_SRC)
   AC_SUBST(MZSCHEME_OBJ)
   AC_SUBST(MZSCHEME_PRO)
   AC_SUBST(MZSCHEME_LIBS)
   AC_SUBST(MZSCHEME_CFLAGS)
+  AC_SUBST(MZSCHEME_EXTRA)
+  AC_SUBST(MZSCHEME_MZC)
 fi
 
 
 AC_MSG_CHECKING(--enable-perlinterp argument)
 AC_ARG_ENABLE(perlinterp,
@@ -657,11 +700,11 @@ if test "$enable_pythoninterp" = "yes";
 
       AC_CACHE_CHECK(Python's configuration directory,vi_cv_path_python_conf,
       [
 	vi_cv_path_python_conf=
 	for path in "${vi_cv_path_python_pfx}" "${vi_cv_path_python_epfx}"; do
-	  for subdir in lib share; do
+	  for subdir in lib64 lib share; do
 	    d="${path}/${subdir}/python${vi_cv_var_python_version}/config"
 	    if test -d "$d" && test -f "$d/config.c"; then
 	      vi_cv_path_python_conf="$d"
 	    fi
 	  done
@@ -920,21 +963,31 @@ AC_MSG_CHECKING(--enable-rubyinterp argu
 AC_ARG_ENABLE(rubyinterp,
 	[  --enable-rubyinterp     Include Ruby interpreter.], ,
 	[enable_rubyinterp="no"])
 AC_MSG_RESULT($enable_rubyinterp)
 if test "$enable_rubyinterp" = "yes"; then
+  AC_MSG_CHECKING(--with-ruby-command argument)
+  AC_ARG_WITH(ruby-command, [  --with-ruby-command=RUBY  name of the Ruby command (default: ruby)],
+	RUBY_CMD="$withval"; AC_MSG_RESULT($RUBY_CMD),
+	RUBY_CMD="ruby"; AC_MSG_RESULT(defaulting to $RUBY_CMD))
   AC_SUBST(vi_cv_path_ruby)
-  AC_PATH_PROG(vi_cv_path_ruby, ruby)
+  AC_PATH_PROG(vi_cv_path_ruby, $RUBY_CMD)
   if test "X$vi_cv_path_ruby" != "X"; then
     AC_MSG_CHECKING(Ruby version)
     if $vi_cv_path_ruby -e '(VERSION rescue RUBY_VERSION) >= "1.6.0" or exit 1' >/dev/null 2>/dev/null; then
       AC_MSG_RESULT(OK)
       AC_MSG_CHECKING(Ruby header files)
-      rubyhdrdir=`$vi_cv_path_ruby -r mkmf -e 'print Config::CONFIG[["archdir"]] || $hdrdir' 2>/dev/null`
+      rubyhdrdir=`$vi_cv_path_ruby -r mkmf -e 'print Config::CONFIG[["rubyhdrdir"]] || Config::CONFIG[["archdir"]] || $hdrdir' 2>/dev/null`
       if test "X$rubyhdrdir" != "X"; then
 	AC_MSG_RESULT($rubyhdrdir)
 	RUBY_CFLAGS="-I$rubyhdrdir"
+        rubyarch=`$vi_cv_path_ruby -r rbconfig -e 'print Config::CONFIG[["arch"]]'`
+        if test -d "$rubyhdrdir/$rubyarch"; then
+          RUBY_CFLAGS="$RUBY_CFLAGS -I$rubyhdrdir/$rubyarch"
+        fi
+        rubyversion=`$vi_cv_path_ruby -r rbconfig -e 'print Config::CONFIG[["ruby_version"]].gsub(/\./, "")[[0,2]]'`
+        RUBY_CFLAGS="$RUBY_CFLAGS -DRUBY_VERSION=$rubyversion"
 	rubylibs=`$vi_cv_path_ruby -r rbconfig -e 'print Config::CONFIG[["LIBS"]]'`
 	if test "X$rubylibs" != "X"; then
 	  RUBY_LIBS="$rubylibs"
 	fi
 	librubyarg=`$vi_cv_path_ruby -r rbconfig -e 'print Config.expand(Config::CONFIG[["LIBRUBYARG"]])'`
@@ -955,18 +1008,24 @@ if test "$enable_rubyinterp" = "yes"; th
 	if test "X$librubyarg" != "X"; then
 	  RUBY_LIBS="$librubyarg $RUBY_LIBS"
 	fi
 	rubyldflags=`$vi_cv_path_ruby -r rbconfig -e 'print Config::CONFIG[["LDFLAGS"]]'`
 	if test "X$rubyldflags" != "X"; then
-	  LDFLAGS="$rubyldflags $LDFLAGS"
+	  dnl Ruby on Mac OS X 10.5 adds "-arch" flags but these should only
+	  dnl be included if requested by passing --with-mac-arch to
+	  dnl configure, so strip these flags first (if present)
+	  rubyldflags=`echo "$rubyldflags" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//'`
+	  if test "X$rubyldflags" != "X"; then
+	    LDFLAGS="$rubyldflags $LDFLAGS"
+	  fi
 	fi
 	RUBY_SRC="if_ruby.c"
 	RUBY_OBJ="objects/if_ruby.o"
 	RUBY_PRO="if_ruby.pro"
 	AC_DEFINE(FEAT_RUBY)
       else
-	AC_MSG_RESULT(not found, disabling Ruby)
+	AC_MSG_RESULT(not found; disabling Ruby)
       fi
     else
       AC_MSG_RESULT(too old; need Ruby version 1.6.0 or later)
     fi
   fi
@@ -1191,10 +1250,32 @@ else
     )
     CFLAGS=$cflags_save
 
     LDFLAGS="$ac_save_LDFLAGS"
 
+    AC_MSG_CHECKING(size of wchar_t is 2 bytes)
+    AC_CACHE_VAL(ac_cv_small_wchar_t,
+	[AC_TRY_RUN([
+#include <X11/Xlib.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+		main()
+		{
+		  if (sizeof(wchar_t) <= 2)
+		    exit(1);
+		  exit(0);
+		}],
+		ac_cv_small_wchar_t="no",
+		ac_cv_small_wchar_t="yes",
+		AC_MSG_ERROR(failed to compile test program))])
+    AC_MSG_RESULT($ac_cv_small_wchar_t)
+    if test "x$ac_cv_small_wchar_t" = "xyes" ; then
+      AC_DEFINE(SMALL_WCHAR_T)
+    fi
+
   fi
 fi
 
 test "x$with_x" = xno -a "x$MACOSX" != "xyes" -a "x$QNX" != "xyes" && enable_gui=no
 
@@ -2065,10 +2146,15 @@ fi
 AC_MSG_CHECKING(whether __DATE__ and __TIME__ work)
 AC_TRY_COMPILE([#include <stdio.h>], [printf("(" __DATE__ " " __TIME__ ")");],
 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_DATE_TIME),
 	AC_MSG_RESULT(no))
 
+AC_MSG_CHECKING(whether __attribute__((unused)) is allowed)
+AC_TRY_COMPILE([#include <stdio.h>], [int x __attribute__((unused));],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ATTRIBUTE_UNUSED),
+	AC_MSG_RESULT(no))
+
 dnl Checks for header files.
 AC_CHECK_HEADER(elf.h, HAS_ELF=1)
 dnl AC_CHECK_HEADER(dwarf.h, SVR4=1)
 if test "$HAS_ELF" = 1; then
   AC_CHECK_LIB(elf, main)
@@ -2093,18 +2179,24 @@ AC_CHECK_HEADERS(stdarg.h stdlib.h strin
 	iconv.h langinfo.h math.h unistd.h stropts.h errno.h \
 	sys/resource.h sys/systeminfo.h locale.h \
 	sys/stream.h termios.h libc.h sys/statfs.h \
 	poll.h sys/poll.h pwd.h utime.h sys/param.h libintl.h \
 	libgen.h util/debug.h util/msg18n.h frame.h \
-	sys/acl.h sys/access.h sys/sysctl.h sys/sysinfo.h wchar.h wctype.h)
+	sys/acl.h sys/access.h sys/sysinfo.h wchar.h wctype.h)
 
 dnl sys/ptem.h depends on sys/stream.h on Solaris
 AC_CHECK_HEADERS(sys/ptem.h, [], [],
 [#if defined HAVE_SYS_STREAM_H
 #  include <sys/stream.h>
 #endif])
 
+dnl sys/sysctl.h depends on sys/param.h on OpenBSD
+AC_CHECK_HEADERS(sys/sysctl.h, [], [],
+[#if defined HAVE_SYS_PARAM_H
+#  include <sys/param.h>
+#endif])
+
 
 dnl pthread_np.h may exist but can only be used after including pthread.h
 AC_MSG_CHECKING([for pthread_np.h])
 AC_TRY_COMPILE([
 #include <pthread.h>
@@ -2146,10 +2238,11 @@ CPPFLAGS=$cppflags_save
 fi
 
 dnl Checks for typedefs, structures, and compiler characteristics.
 AC_PROG_GCC_TRADITIONAL
 AC_C_CONST
+AC_C_VOLATILE
 AC_TYPE_MODE_T
 AC_TYPE_OFF_T
 AC_TYPE_PID_T
 AC_TYPE_SIZE_T
 AC_TYPE_UID_T
@@ -2488,15 +2581,15 @@ main()
 	  vim_cv_tty_mode=0620
 	fi
 	AC_MSG_RESULT([pty mode: $vim_cv_tty_mode, group: $vim_cv_tty_group])
       else
 	vim_cv_tty_group=world
-	AC_MSG_RESULT([ptys are world accessable])
+	AC_MSG_RESULT([ptys are world accessible])
       fi
     ],[
       vim_cv_tty_group=world
-      AC_MSG_RESULT([can't determine - assume ptys are world accessable])
+      AC_MSG_RESULT([can't determine - assume ptys are world accessible])
     ],[
       AC_MSG_ERROR(cross-compiling: please set 'vim_cv_tty_group' and 'vim_cv_tty_mode')
     ])
   ])
 rm -f conftest_grp
@@ -2563,18 +2656,20 @@ main()
 
 if test "x$vim_cv_getcwd_broken" = "xyes" ; then
   AC_DEFINE(BAD_GETCWD)
 fi
 
-dnl Check for functions in one big call, to reduce the size of configure
-AC_CHECK_FUNCS(bcmp fchdir fchown fseeko fsync ftello getcwd getpseudotty \
+dnl Check for functions in one big call, to reduce the size of configure.
+dnl Can only be used for functions that do not require any include.
+AC_CHECK_FUNCS(bcmp fchdir fchown fsync getcwd getpseudotty \
 	getpwnam getpwuid getrlimit gettimeofday getwd lstat memcmp \
-	memset nanosleep opendir putenv qsort readlink select setenv \
+	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
 	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
 	sigvec strcasecmp strerror strftime stricmp strncasecmp \
 	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
 	usleep utime utimes)
+AC_FUNC_FSEEKO
 
 dnl fstatfs() can take 2 to 4 arguments, try to use st_blksize if possible
 AC_MSG_CHECKING(for st_blksize)
 AC_TRY_COMPILE(
 [#include <sys/types.h>
@@ -2786,10 +2881,20 @@ if test "$enable_sysmouse" = "yes"; then
   fi
 else
   AC_MSG_RESULT(yes)
 fi
 
+dnl make sure the FD_CLOEXEC flag for fcntl()'s F_SETFD command is known
+AC_MSG_CHECKING(for FD_CLOEXEC)
+AC_TRY_COMPILE(
+[#if HAVE_FCNTL_H
+# include <fcntl.h>
+#endif],
+[	int flag = FD_CLOEXEC;],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_FD_CLOEXEC),
+	AC_MSG_RESULT(not usable))
+
 dnl rename needs to be checked separately to work on Nextstep with cc
 AC_MSG_CHECKING(for rename)
 AC_TRY_LINK([#include <stdio.h>], [rename("this", "that")],
 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_RENAME),
 	AC_MSG_RESULT(no))
@@ -2867,11 +2972,10 @@ main()
 	    ac_cv_sizeof_int=0,
 	    AC_MSG_ERROR(failed to compile test program))])
 AC_MSG_RESULT($ac_cv_sizeof_int)
 AC_DEFINE_UNQUOTED(SIZEOF_INT, $ac_cv_sizeof_int)
 
-
 dnl Check for memmove() before bcopy(), makes memmove() be used when both are
 dnl present, fixes problem with incompatibility between Solaris 2.4 and 2.5.
 
 [bcopy_test_prog='
 #include "confdefs.h"
@@ -2949,11 +3053,11 @@ dnl Find out if _Xsetlocale() is support
 dnl Check if X_LOCALE should be defined.
 
 if test "$enable_multibyte" = "yes"; then
   cflags_save=$CFLAGS
   ldflags_save=$LDFLAGS
-  if test -n "$x_includes" ; then
+  if test "x$x_includes" != "xNONE" ; then
     CFLAGS="$CFLAGS -I$x_includes"
     LDFLAGS="$X_LIBS $LDFLAGS -lX11"
     AC_MSG_CHECKING(whether X_LOCALE needed)
     AC_TRY_COMPILE([#include <X11/Xlocale.h>],,
 	AC_TRY_LINK_FUNC([_Xsetlocale], [AC_MSG_RESULT(yes)
@@ -2965,11 +3069,11 @@ if test "$enable_multibyte" = "yes"; the
 fi
 
 dnl Link with xpg4, it is said to make Korean locale working
 AC_CHECK_LIB(xpg4, _xpg4_setrunelocale, [LIBS="$LIBS -lxpg4"],,)
 
-dnl Check how we can run ctags
+dnl Check how we can run ctags.  Default to "ctags" when nothing works.
 dnl --version for Exuberant ctags (preferred)
 dnl       Add --fields=+S to get function signatures for omni completion.
 dnl -t for typedefs (many ctags have this)
 dnl -s for static functions (Elvis ctags only?)
 dnl -v for variables. Dangerous, most ctags take this for 'vgrind style'.
@@ -2977,10 +3081,11 @@ dnl -i+m to test for older Exuberant cta
 AC_MSG_CHECKING(how to create tags)
 test -f tags && mv tags tags.save
 if (eval ctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
   TAGPRG="ctags -I INIT+ --fields=+S"
 else
+  TAGPRG="ctags"
   (eval etags	   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="etags"
   (eval etags -c   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="etags -c"
   (eval ctags	   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags"
   (eval ctags -t   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -t"
   (eval ctags -ts  /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -ts"
@@ -3142,30 +3247,38 @@ if test "x$MACOSX" = "xyes" && test "x$C
   else
     AC_MSG_RESULT(no)
   fi
 fi
 if test "x$MACARCH" = "xboth"; then
-  LDFLAGS="$LDFLAGS -isysroot /Developer/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
+  LDFLAGS="$LDFLAGS -isysroot $DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
 fi
 
 dnl gcc 3.1 changed the meaning of -MM.  The only solution appears to be to
 dnl use "-isystem" instead of "-I" for all non-Vim include dirs.
 dnl But only when making dependencies, cproto and lint don't take "-isystem".
 dnl Mac gcc returns "powerpc-apple-darwin8-gcc-4.0.1 (GCC)...", need to allow
 dnl the number before the version number.
-AC_MSG_CHECKING(for GCC 3 or later)
 DEPEND_CFLAGS_FILTER=
 if test "$GCC" = yes; then
+  AC_MSG_CHECKING(for GCC 3 or later)
   gccmajor=`echo "$gccversion" | sed -e 's/^\([[1-9]]\)\..*$/\1/g'`
   if test "$gccmajor" -gt "2"; then
     DEPEND_CFLAGS_FILTER="| sed 's+-I */+-isystem /+g'"
+    AC_MSG_RESULT(yes)
+  else
+    AC_MSG_RESULT(no)
+  fi
+  dnl -D_FORTIFY_SOURCE=2 crashes Vim on strcpy(buf, "000") when buf is
+  dnl declared as char x[1] but actually longer.  Introduced in gcc 4.0.
+  dnl Also remove duplicate _FORTIFY_SOURCE arguments.
+  AC_MSG_CHECKING(whether we need -D_FORTIFY_SOURCE=1)
+  if test "$gccmajor" -gt "3"; then
+    CFLAGS=`echo "$CFLAGS" | sed -e 's/-Wp,-D_FORTIFY_SOURCE=.//g' -e 's/-D_FORTIFY_SOURCE=.//g' -e 's/$/ -D_FORTIFY_SOURCE=1/'`
+    AC_MSG_RESULT(yes)
+  else
+    AC_MSG_RESULT(no)
   fi
-fi
-if test "$DEPEND_CFLAGS_FILTER" = ""; then
-  AC_MSG_RESULT(no)
-else
-  AC_MSG_RESULT(yes)
 fi
 AC_SUBST(DEPEND_CFLAGS_FILTER)
 
 dnl write output files
 AC_OUTPUT(auto/config.mk:config.mk.in)
--- vim72.orig/src/if_python.c
+++ vim72/src/if_python.c
@@ -35,10 +35,16 @@
 #endif
 
 #ifdef HAVE_STDARG_H
 # undef HAVE_STDARG_H	/* Python's config.h defines it as well. */
 #endif
+#ifdef _POSIX_C_SOURCE
+# undef _POSIX_C_SOURCE	/* pyconfig.h defines it as well. */
+#endif
+#ifdef _XOPEN_SOURCE
+# undef _XOPEN_SOURCE	/* pyconfig.h defines it as well. */
+#endif
 
 #define PY_SSIZE_T_CLEAN
 
 #include <Python.h>
 #if defined(MACOS) && !defined(MACOS_X_UNIX)
@@ -529,10 +535,16 @@ Python_Init(void)
 	    goto fail;
 
 	if (PythonMod_Init())
 	    goto fail;
 
+	/* Remove the element from sys.path that was added because of our
+	 * argv[0] value in PythonMod_Init().  Previously we used an empty
+	 * string, but dependinding on the OS we then get an empty entry or
+	 * the current directory in sys.path. */
+	PyRun_SimpleString("import sys; sys.path = filter(lambda x: x != '/must>not&exist', sys.path)");
+
 	/* the first python thread is vim's, release the lock */
 	Python_SaveThread();
 
 	initialised = 1;
     }
@@ -1088,13 +1100,12 @@ static struct PyMethodDef VimMethods[] =
     { NULL,	     NULL,		0,	    NULL }
 };
 
 /* Vim module - Implementation
  */
-/*ARGSUSED*/
     static PyObject *
-VimCommand(PyObject *self, PyObject *args)
+VimCommand(PyObject *self UNUSED, PyObject *args)
 {
     char *cmd;
     PyObject *result;
 
     if (!PyArg_ParseTuple(args, "s", &cmd))
@@ -1143,48 +1154,56 @@ VimToPython(typval_T *our_tv, int depth,
 	return result;
     }
 
     /* Check if we run into a recursive loop.  The item must be in lookupDict
      * then and we can use it again. */
-    sprintf(ptrBuf, PRINTF_DECIMAL_LONG_U, (long_u)our_tv);
-    result = PyDict_GetItemString(lookupDict, ptrBuf);
-    if (result != NULL)
-	Py_INCREF(result);
-    else if (our_tv->v_type == VAR_STRING)
+    if ((our_tv->v_type == VAR_LIST && our_tv->vval.v_list != NULL)
+	    || (our_tv->v_type == VAR_DICT && our_tv->vval.v_dict != NULL))
+    {
+	sprintf(ptrBuf, PRINTF_DECIMAL_LONG_U,
+	        our_tv->v_type == VAR_LIST ? (long_u)our_tv->vval.v_list
+		                           : (long_u)our_tv->vval.v_dict);
+	result = PyDict_GetItemString(lookupDict, ptrBuf);
+	if (result != NULL)
+	{
+	    Py_INCREF(result);
+	    return result;
+	}
+    }
+
+    if (our_tv->v_type == VAR_STRING)
     {
 	result = Py_BuildValue("s", our_tv->vval.v_string);
-	PyDict_SetItemString(lookupDict, ptrBuf, result);
     }
     else if (our_tv->v_type == VAR_NUMBER)
     {
 	char buf[NUMBUFLEN];
 
 	/* For backwards compatibility numbers are stored as strings. */
 	sprintf(buf, "%ld", (long)our_tv->vval.v_number);
 	result = Py_BuildValue("s", buf);
-	PyDict_SetItemString(lookupDict, ptrBuf, result);
     }
 # ifdef FEAT_FLOAT
     else if (our_tv->v_type == VAR_FLOAT)
     {
 	char buf[NUMBUFLEN];
 
 	sprintf(buf, "%f", our_tv->vval.v_float);
 	result = Py_BuildValue("s", buf);
-	PyDict_SetItemString(lookupDict, ptrBuf, result);
     }
 # endif
     else if (our_tv->v_type == VAR_LIST)
     {
 	list_T		*list = our_tv->vval.v_list;
 	listitem_T	*curr;
 
 	result = PyList_New(0);
-	PyDict_SetItemString(lookupDict, ptrBuf, result);
 
 	if (list != NULL)
 	{
+	    PyDict_SetItemString(lookupDict, ptrBuf, result);
+
 	    for (curr = list->lv_first; curr != NULL; curr = curr->li_next)
 	    {
 		newObj = VimToPython(&curr->li_tv, depth + 1, lookupDict);
 		PyList_Append(result, newObj);
 		Py_DECREF(newObj);
@@ -1192,19 +1211,20 @@ VimToPython(typval_T *our_tv, int depth,
 	}
     }
     else if (our_tv->v_type == VAR_DICT)
     {
 	result = PyDict_New();
-	PyDict_SetItemString(lookupDict, ptrBuf, result);
 
 	if (our_tv->vval.v_dict != NULL)
 	{
 	    hashtab_T	*ht = &our_tv->vval.v_dict->dv_hashtab;
 	    long_u	todo = ht->ht_used;
 	    hashitem_T	*hi;
 	    dictitem_T	*di;
 
+	    PyDict_SetItemString(lookupDict, ptrBuf, result);
+
 	    for (hi = ht->ht_array; todo > 0; ++hi)
 	    {
 		if (!HASHITEM_EMPTY(hi))
 		{
 		    --todo;
@@ -1225,13 +1245,12 @@ VimToPython(typval_T *our_tv, int depth,
 
     return result;
 }
 #endif
 
-/*ARGSUSED*/
     static PyObject *
-VimEval(PyObject *self, PyObject *args)
+VimEval(PyObject *self UNUSED, PyObject *args)
 {
 #ifdef FEAT_EVAL
     char	*expr;
     typval_T	*our_tv;
     PyObject	*result;
@@ -1877,13 +1896,12 @@ static PyTypeObject BufListType = {
 };
 
 /* Buffer list object - Implementation
  */
 
-/*ARGSUSED*/
     static PyInt
-BufListLength(PyObject *self)
+BufListLength(PyObject *self UNUSED)
 {
     buf_T	*b = firstbuf;
     PyInt	n = 0;
 
     while (b)
@@ -1893,13 +1911,12 @@ BufListLength(PyObject *self)
     }
 
     return n;
 }
 
-/*ARGSUSED*/
     static PyObject *
-BufListItem(PyObject *self, PyInt n)
+BufListItem(PyObject *self UNUSED, PyInt n)
 {
     buf_T *b;
 
     for (b = firstbuf; b; b = b->b_next, --n)
     {
@@ -2045,10 +2062,11 @@ WindowSetattr(PyObject *self, char *name
     }
     else if (strcmp(name, "cursor") == 0)
     {
 	long lnum;
 	long col;
+	long len;
 
 	if (!PyArg_Parse(val, "(ll)", &lnum, &col))
 	    return -1;
 
 	if (lnum <= 0 || lnum > this->win->w_buffer->b_ml.ml_line_count)
@@ -2059,14 +2077,20 @@ WindowSetattr(PyObject *self, char *name
 
 	/* Check for keyboard interrupts */
 	if (VimErrorCheck())
 	    return -1;
 
-	/* NO CHECK ON COLUMN - SEEMS NOT TO MATTER */
+	/* When column is out of range silently correct it. */
+	len = (long)STRLEN(ml_get_buf(this->win->w_buffer, lnum, FALSE));
+	if (col > len)
+	    col = len;
 
 	this->win->w_cursor.lnum = lnum;
 	this->win->w_cursor.col = col;
+#ifdef FEAT_VIRTUALEDIT
+	this->win->w_cursor.coladd = 0;
+#endif
 	update_screen(VALID);
 
 	return 0;
     }
     else if (strcmp(name, "height") == 0)
@@ -2193,13 +2217,12 @@ static PyTypeObject WinListType = {
     (reprfunc) 0,			/* tp_str,  str(x)  */
 };
 
 /* Window list object - Implementation
  */
-/*ARGSUSED*/
     static PyInt
-WinListLength(PyObject *self)
+WinListLength(PyObject *self UNUSED)
 {
     win_T	*w = firstwin;
     PyInt	n = 0;
 
     while (w != NULL)
@@ -2209,13 +2232,12 @@ WinListLength(PyObject *self)
     }
 
     return n;
 }
 
-/*ARGSUSED*/
     static PyObject *
-WinListItem(PyObject *self, PyInt n)
+WinListItem(PyObject *self UNUSED, PyInt n)
 {
     win_T *w;
 
     for (w = firstwin; w != NULL; w = W_NEXT(w), --n)
 	if (n == 0)
@@ -2257,13 +2279,12 @@ static PyTypeObject CurrentType = {
     (reprfunc) 0,			/* tp_str,  str(x)  */
 };
 
 /* Current items object - Implementation
  */
-/*ARGSUSED*/
     static PyObject *
-CurrentGetattr(PyObject *self, char *name)
+CurrentGetattr(PyObject *self UNUSED, char *name)
 {
     if (strcmp(name, "buffer") == 0)
 	return (PyObject *)BufferNew(curbuf);
     else if (strcmp(name, "window") == 0)
 	return (PyObject *)WindowNew(curwin);
@@ -2278,13 +2299,12 @@ CurrentGetattr(PyObject *self, char *nam
 	PyErr_SetString(PyExc_AttributeError, name);
 	return NULL;
     }
 }
 
-/*ARGSUSED*/
     static int
-CurrentSetattr(PyObject *self, char *name, PyObject *value)
+CurrentSetattr(PyObject *self UNUSED, char *name, PyObject *value)
 {
     if (strcmp(name, "line") == 0)
     {
 	if (SetBufferLine(curbuf, (PyInt)curwin->w_cursor.lnum, value, NULL) == FAIL)
 	    return -1;
@@ -2343,11 +2363,12 @@ static CurrentObject TheCurrent =
     static int
 PythonMod_Init(void)
 {
     PyObject *mod;
     PyObject *dict;
-    static char *(argv[2]) = {"", NULL};
+    /* The special value is removed from sys.path in Python_Init(). */
+    static char *(argv[2]) = {"/must>not&exist/foo", NULL};
 
     /* Fixups... */
     BufferType.ob_type = &PyType_Type;
     RangeType.ob_type = &PyType_Type;
     WindowType.ob_type = &PyType_Type;
@@ -2487,13 +2508,13 @@ SetBufferLine(buf_T *buf, PyInt n, PyObj
 	    PyErr_SetVim(_("cannot save undo information"));
 	else if (ml_delete((linenr_T)n, FALSE) == FAIL)
 	    PyErr_SetVim(_("cannot delete line"));
 	else
 	{
-	    deleted_lines_mark((linenr_T)n, 1L);
 	    if (buf == curwin->w_buffer)
 		py_fix_cursor((linenr_T)n, (linenr_T)n + 1, (linenr_T)-1);
+	    deleted_lines_mark((linenr_T)n, 1L);
 	}
 
 	curbuf = savebuf;
 
 	if (PyErr_Occurred() || VimErrorCheck())
@@ -2586,14 +2607,13 @@ SetBufferLineList(buf_T *buf, PyInt lo,
 		{
 		    PyErr_SetVim(_("cannot delete line"));
 		    break;
 		}
 	    }
-	    deleted_lines_mark((linenr_T)lo, (long)i);
-
 	    if (buf == curwin->w_buffer)
 		py_fix_cursor((linenr_T)lo, (linenr_T)hi, (linenr_T)-n);
+	    deleted_lines_mark((linenr_T)lo, (long)i);
 	}
 
 	curbuf = savebuf;
 
 	if (PyErr_Occurred() || VimErrorCheck())
--- vim72.orig/src/gui_w32.c
+++ vim72/src/gui_w32.c
@@ -210,34 +210,34 @@ typedef struct _DllVersionInfo
     DWORD dwMinorVersion;
     DWORD dwBuildNumber;
     DWORD dwPlatformID;
 } DLLVERSIONINFO;
 
+#include <poppack.h>
+
 typedef struct tagTOOLINFOA_NEW
 {
 	UINT cbSize;
 	UINT uFlags;
 	HWND hwnd;
-	UINT uId;
+	UINT_PTR uId;
 	RECT rect;
 	HINSTANCE hinst;
 	LPSTR lpszText;
 	LPARAM lParam;
 } TOOLINFO_NEW;
 
 typedef struct tagNMTTDISPINFO_NEW
 {
     NMHDR      hdr;
-    LPTSTR     lpszText;
+    LPSTR      lpszText;
     char       szText[80];
     HINSTANCE  hinst;
     UINT       uFlags;
     LPARAM     lParam;
 } NMTTDISPINFO_NEW;
 
-#include <poppack.h>
-
 typedef HRESULT (WINAPI* DLLGETVERSIONPROC)(DLLVERSIONINFO *);
 #ifndef TTM_SETMAXTIPWIDTH
 # define TTM_SETMAXTIPWIDTH	(WM_USER+24)
 #endif
 
@@ -990,11 +990,11 @@ _WndProc(
 			    /* Set the maximum width, this also enables using
 			     * \n for line break. */
 			    SendMessage(lpdi->hdr.hwndFrom, TTM_SETMAXTIPWIDTH,
 								      0, 500);
 
-			    tt_text = enc_to_ucs2(str, NULL);
+			    tt_text = enc_to_utf16(str, NULL);
 			    lpdi->lpszText = tt_text;
 			    /* can't show tooltip if failed */
 			}
 			else
 # endif
@@ -1327,10 +1327,11 @@ gui_mch_init(void)
     const char szVimWndClass[] = VIM_CLASS;
     const char szTextAreaClass[] = "VimTextArea";
     WNDCLASS wndclass;
 #ifdef FEAT_MBYTE
     const WCHAR szVimWndClassW[] = VIM_CLASSW;
+    const WCHAR szTextAreaClassW[] = L"VimTextArea";
     WNDCLASSW wndclassw;
 #endif
 #ifdef GLOBAL_IME
     ATOM	atom;
 #endif
@@ -1477,10 +1478,32 @@ gui_mch_init(void)
 #if defined(FEAT_MBYTE_IME) && defined(DYNAMIC_IME)
     dyn_imm_load();
 #endif
 
     /* Create the text area window */
+#ifdef FEAT_MBYTE
+    if (wide_WindowProc)
+    {
+	if (GetClassInfoW(s_hinst, szTextAreaClassW, &wndclassw) == 0)
+	{
+	    wndclassw.style = CS_OWNDC;
+	    wndclassw.lpfnWndProc = _TextAreaWndProc;
+	    wndclassw.cbClsExtra = 0;
+	    wndclassw.cbWndExtra = 0;
+	    wndclassw.hInstance = s_hinst;
+	    wndclassw.hIcon = NULL;
+	    wndclassw.hCursor = LoadCursor(NULL, IDC_ARROW);
+	    wndclassw.hbrBackground = NULL;
+	    wndclassw.lpszMenuName = NULL;
+	    wndclassw.lpszClassName = szTextAreaClassW;
+
+	    if (RegisterClassW(&wndclassw) == 0)
+		return FAIL;
+	}
+    }
+    else
+#endif
     if (GetClassInfo(s_hinst, szTextAreaClass, &wndclass) == 0)
     {
 	wndclass.style = CS_OWNDC;
 	wndclass.lpfnWndProc = _TextAreaWndProc;
 	wndclass.cbClsExtra = 0;
@@ -1580,10 +1603,21 @@ gui_mch_init(void)
     s_findrep_struct.lpstrFindWhat[0] = NUL;
     s_findrep_struct.lpstrReplaceWith = alloc(MSWIN_FR_BUFSIZE);
     s_findrep_struct.lpstrReplaceWith[0] = NUL;
     s_findrep_struct.wFindWhatLen = MSWIN_FR_BUFSIZE;
     s_findrep_struct.wReplaceWithLen = MSWIN_FR_BUFSIZE;
+# if defined(FEAT_MBYTE) && defined(WIN3264)
+    s_findrep_struct_w.lStructSize = sizeof(s_findrep_struct_w);
+    s_findrep_struct_w.lpstrFindWhat =
+			      (LPWSTR)alloc(MSWIN_FR_BUFSIZE * sizeof(WCHAR));
+    s_findrep_struct_w.lpstrFindWhat[0] = NUL;
+    s_findrep_struct_w.lpstrReplaceWith =
+			      (LPWSTR)alloc(MSWIN_FR_BUFSIZE * sizeof(WCHAR));
+    s_findrep_struct_w.lpstrReplaceWith[0] = NUL;
+    s_findrep_struct_w.wFindWhatLen = MSWIN_FR_BUFSIZE;
+    s_findrep_struct_w.wReplaceWithLen = MSWIN_FR_BUFSIZE;
+# endif
 #endif
 
 theend:
     /* Display any pending error messages */
     display_errors();
@@ -1933,11 +1967,11 @@ GetResultStr(HWND hwnd, int GCS, int *le
     /* Reads in the composition string. */
     buf = GetCompositionString_inUCS2(hIMC, GCS, lenp);
     if (buf == NULL)
 	return NULL;
 
-    convbuf = ucs2_to_enc(buf, lenp);
+    convbuf = utf16_to_enc(buf, lenp);
     pImmReleaseContext(hwnd, hIMC);
     vim_free(buf);
     return convbuf;
 }
 #endif
@@ -2564,11 +2598,11 @@ gui_mch_add_menu(
 
 	    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
 	    {
 		/* 'encoding' differs from active codepage: convert menu name
 		 * and use wide function */
-		wn = enc_to_ucs2(menu->name, NULL);
+		wn = enc_to_utf16(menu->name, NULL);
 		if (wn != NULL)
 		{
 		    MENUITEMINFOW	infow;
 
 		    infow.cbSize = sizeof(infow);
@@ -2726,11 +2760,11 @@ gui_mch_add_menu_item(
 
 	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
 	{
 	    /* 'encoding' differs from active codepage: convert menu item name
 	     * and use wide function */
-	    wn = enc_to_ucs2(menu->name, NULL);
+	    wn = enc_to_utf16(menu->name, NULL);
 	    if (wn != NULL)
 	    {
 		n = InsertMenuW(parent->submenu_id, (UINT)idx,
 			(menu_is_separator(menu->name)
 				 ? MF_SEPARATOR : MF_STRING) | MF_BYPOSITION,
@@ -2936,12 +2970,31 @@ dialog_callback(
 	if (button >= DLG_NONBUTTON_CONTROL)
 	    return TRUE;
 
 	/* If the edit box exists, copy the string. */
 	if (s_textfield != NULL)
-	    GetDlgItemText(hwnd, DLG_NONBUTTON_CONTROL + 2,
+	{
+# if defined(FEAT_MBYTE) && defined(WIN3264)
+	    /* If the OS is Windows NT, and 'encoding' differs from active
+	     * codepage: use wide function and convert text. */
+	    if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
+		    && enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+            {
+	       WCHAR  *wp = (WCHAR *)alloc(IOSIZE * sizeof(WCHAR));
+	       char_u *p;
+
+	       GetDlgItemTextW(hwnd, DLG_NONBUTTON_CONTROL + 2, wp, IOSIZE);
+	       p = utf16_to_enc(wp, NULL);
+	       vim_strncpy(s_textfield, p, IOSIZE);
+	       vim_free(p);
+	       vim_free(wp);
+	    }
+	    else
+# endif
+		GetDlgItemText(hwnd, DLG_NONBUTTON_CONTROL + 2,
 							 s_textfield, IOSIZE);
+	}
 
 	/*
 	 * Need to check for IDOK because if the user just hits Return to
 	 * accept the default value, some reason this is what we get.
 	 */
@@ -3568,11 +3621,11 @@ nCopyAnsiToWideChar(
     WCHAR	*wn;
 
     if (enc_codepage == 0 && (int)GetACP() != enc_codepage)
     {
 	/* Not a codepage, use our own conversion function. */
-	wn = enc_to_ucs2(lpAnsiIn, NULL);
+	wn = enc_to_utf16(lpAnsiIn, NULL);
 	if (wn != NULL)
 	{
 	    wcscpy(lpWCStr, wn);
 	    nChar = (int)wcslen(wn) + 1;
 	    vim_free(wn);
--- vim72.orig/src/os_mswin.c
+++ vim72/src/os_mswin.c
@@ -307,11 +307,11 @@ mch_settitle(
     {
 #  ifdef FEAT_MBYTE
 	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
 	{
 	    /* Convert the title from 'encoding' to the active codepage. */
-	    WCHAR	*wp = enc_to_ucs2(title, NULL);
+	    WCHAR	*wp = enc_to_utf16(title, NULL);
 	    int	n;
 
 	    if (wp != NULL)
 	    {
 		n = SetConsoleTitleW(wp);
@@ -404,14 +404,14 @@ mch_FullName(
 	    /* Use the wide function:
 	     * - convert the fname from 'encoding' to UCS2.
 	     * - invoke _wfullpath()
 	     * - convert the result from UCS2 to 'encoding'.
 	     */
-	    wname = enc_to_ucs2(fname, NULL);
+	    wname = enc_to_utf16(fname, NULL);
 	    if (wname != NULL && _wfullpath(wbuf, wname, MAX_PATH - 1) != NULL)
 	    {
-		cname = ucs2_to_enc((short_u *)wbuf, NULL);
+		cname = utf16_to_enc((short_u *)wbuf, NULL);
 		if (cname != NULL)
 		{
 		    vim_strncpy(buf, cname, len - 1);
 		    nResult = OK;
 		}
@@ -505,11 +505,11 @@ vim_stat(const char *name, struct stat *
 	    /* Wide functions of Borland C 5.5 do not work on Windows 98. */
 	    && g_PlatformId == VER_PLATFORM_WIN32_NT
 # endif
        )
     {
-	WCHAR	*wp = enc_to_ucs2(buf, NULL);
+	WCHAR	*wp = enc_to_utf16(buf, NULL);
 	int	n;
 
 	if (wp != NULL)
 	{
 	    n = _wstat(wp, (struct _stat *)stp);
@@ -651,10 +651,16 @@ mch_has_wildcard(char_u *p)
 mch_chdir(char *path)
 {
     if (path[0] == NUL)		/* just checking... */
 	return -1;
 
+    if (p_verbose >= 5)
+    {
+	verbose_enter();
+	smsg((char_u *)"chdir(%s)", path);
+	verbose_leave();
+    }
     if (isalpha(path[0]) && path[1] == ':')	/* has a drive name */
     {
 	/* If we can change to the drive, skip that part of the path.  If we
 	 * can't then the current directory may be invalid, try using chdir()
 	 * with the whole path. */
@@ -666,11 +672,11 @@ mch_chdir(char *path)
 	return 0;
 
 #ifdef FEAT_MBYTE
     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
     {
-	WCHAR	*p = enc_to_ucs2(path, NULL);
+	WCHAR	*p = enc_to_utf16(path, NULL);
 	int	n;
 
 	if (p != NULL)
 	{
 	    n = _wchdir(p);
@@ -889,23 +895,24 @@ mch_libcall(
 }
 #endif
 
 #if defined(FEAT_MBYTE) || defined(PROTO)
 /*
- * Convert an UTF-8 string to UCS-2.
+ * Convert an UTF-8 string to UTF-16.
  * "instr[inlen]" is the input.  "inlen" is in bytes.
- * When "outstr" is NULL only return the number of UCS-2 words produced.
+ * When "outstr" is NULL only return the number of UTF-16 words produced.
  * Otherwise "outstr" must be a buffer of sufficient size.
- * Returns the number of UCS-2 words produced.
+ * Returns the number of UTF-16 words produced.
  */
     int
-utf8_to_ucs2(char_u *instr, int inlen, short_u *outstr, int *unconvlenp)
+utf8_to_utf16(char_u *instr, int inlen, short_u *outstr, int *unconvlenp)
 {
     int		outlen = 0;
     char_u	*p = instr;
     int		todo = inlen;
     int		l;
+    int		ch;
 
     while (todo > 0)
     {
 	/* Only convert if we have a complete sequence. */
 	l = utf_ptr2len_len(p, todo);
@@ -915,44 +922,68 @@ utf8_to_ucs2(char_u *instr, int inlen, s
 	    if (unconvlenp != NULL)
 		*unconvlenp = todo;
 	    break;
 	}
 
-	if (outstr != NULL)
-	    *outstr++ = utf_ptr2char(p);
+	ch = utf_ptr2char(p);
+	if (ch >= 0x10000)
+	{
+	    /* non-BMP character, encoding with surrogate pairs */
+	    ++outlen;
+	    if (outstr != NULL)
+	    {
+		*outstr++ = (0xD800 - (0x10000 >> 10)) + (ch >> 10);
+		*outstr++ = 0xDC00 | (ch & 0x3FF);
+	    }
+	}
+	else if (outstr != NULL)
+	    *outstr++ = ch;
 	++outlen;
 	p += l;
 	todo -= l;
     }
 
     return outlen;
 }
 
 /*
- * Convert an UCS-2 string to UTF-8.
- * The input is "instr[inlen]" with "inlen" in number of ucs-2 words.
+ * Convert an UTF-16 string to UTF-8.
+ * The input is "instr[inlen]" with "inlen" in number of UTF-16 words.
  * When "outstr" is NULL only return the required number of bytes.
  * Otherwise "outstr" must be a buffer of sufficient size.
  * Return the number of bytes produced.
  */
     int
-ucs2_to_utf8(short_u *instr, int inlen, char_u *outstr)
+utf16_to_utf8(short_u *instr, int inlen, char_u *outstr)
 {
     int		outlen = 0;
     int		todo = inlen;
     short_u	*p = instr;
     int		l;
+    int		ch, ch2;
 
     while (todo > 0)
     {
+	ch = *p;
+	if (ch >= 0xD800 && ch <= 0xDBFF && todo > 1)
+	{
+	    /* surrogate pairs handling */
+	    ch2 = p[1];
+	    if (ch2 >= 0xDC00 && ch2 <= 0xDFFF)
+	    {
+		ch = ((ch - 0xD800) << 10) + (ch2 & 0x3FF) + 0x10000;
+		++p;
+		--todo;
+	    }
+	}
 	if (outstr != NULL)
 	{
-	    l = utf_char2bytes(*p, outstr);
+	    l = utf_char2bytes(ch, outstr);
 	    outstr += l;
 	}
 	else
-	    l = utf_char2len(*p);
+	    l = utf_char2len(ch);
 	++p;
 	outlen += l;
 	--todo;
     }
 
@@ -1077,18 +1108,18 @@ crnl_to_nl(const char_u *str, int *size)
  * Note: the following two functions are only guaranteed to work when using
  * valid MS-Windows codepages or when iconv() is available.
  */
 
 /*
- * Convert "str" from 'encoding' to UCS-2.
+ * Convert "str" from 'encoding' to UTF-16.
  * Input in "str" with length "*lenp".  When "lenp" is NULL, use strlen().
  * Output is returned as an allocated string.  "*lenp" is set to the length of
  * the result.  A trailing NUL is always added.
  * Returns NULL when out of memory.
  */
     short_u *
-enc_to_ucs2(char_u *str, int *lenp)
+enc_to_utf16(char_u *str, int *lenp)
 {
     vimconv_T	conv;
     WCHAR	*ret;
     char_u	*allocbuf = NULL;
     int		len_loc;
@@ -1100,11 +1131,11 @@ enc_to_ucs2(char_u *str, int *lenp)
 	lenp = &len_loc;
     }
 
     if (enc_codepage > 0)
     {
-	/* We can do any CP### -> UCS-2 in one pass, and we can do it
+	/* We can do any CP### -> UTF-16 in one pass, and we can do it
 	 * without iconv() (convert_* may need iconv). */
 	MultiByteToWideChar_alloc(enc_codepage, 0, str, *lenp, &ret, &length);
     }
     else
     {
@@ -1121,15 +1152,15 @@ enc_to_ucs2(char_u *str, int *lenp)
 	    if (str == NULL)
 		return NULL;
 	}
 	convert_setup(&conv, NULL, NULL);
 
-	length = utf8_to_ucs2(str, *lenp, NULL, NULL);
+	length = utf8_to_utf16(str, *lenp, NULL, NULL);
 	ret = (WCHAR *)alloc((unsigned)((length + 1) * sizeof(WCHAR)));
 	if (ret != NULL)
 	{
-	    utf8_to_ucs2(str, *lenp, (short_u *)ret, NULL);
+	    utf8_to_utf16(str, *lenp, (short_u *)ret, NULL);
 	    ret[length] = 0;
 	}
 
 	vim_free(allocbuf);
     }
@@ -1137,19 +1168,19 @@ enc_to_ucs2(char_u *str, int *lenp)
     *lenp = length;
     return (short_u *)ret;
 }
 
 /*
- * Convert an UCS-2 string to 'encoding'.
+ * Convert an UTF-16 string to 'encoding'.
  * Input in "str" with length (counted in wide characters) "*lenp".  When
  * "lenp" is NULL, use wcslen().
  * Output is returned as an allocated string.  If "*lenp" is not NULL it is
  * set to the length of the result.
  * Returns NULL when out of memory.
  */
     char_u *
-ucs2_to_enc(short_u *str, int *lenp)
+utf16_to_enc(short_u *str, int *lenp)
 {
     vimconv_T	conv;
     char_u	*utf8_str = NULL, *enc_str = NULL;
     int		len_loc;
 
@@ -1159,24 +1190,24 @@ ucs2_to_enc(short_u *str, int *lenp)
 	lenp = &len_loc;
     }
 
     if (enc_codepage > 0)
     {
-	/* We can do any UCS-2 -> CP### in one pass. */
+	/* We can do any UTF-16 -> CP### in one pass. */
 	int length;
 
 	WideCharToMultiByte_alloc(enc_codepage, 0, str, *lenp,
 					    (LPSTR *)&enc_str, &length, 0, 0);
 	*lenp = length;
 	return enc_str;
     }
 
     /* Avoid allocating zero bytes, it generates an error message. */
-    utf8_str = alloc(ucs2_to_utf8(str, *lenp == 0 ? 1 : *lenp, NULL));
+    utf8_str = alloc(utf16_to_utf8(str, *lenp == 0 ? 1 : *lenp, NULL));
     if (utf8_str != NULL)
     {
-	*lenp = ucs2_to_utf8(str, *lenp, utf8_str);
+	*lenp = utf16_to_utf8(str, *lenp, utf8_str);
 
 	/* We might be called before we have p_enc set up. */
 	conv.vc_type = CONV_NONE;
 	convert_setup(&conv, (char_u *)"utf-8",
 					    p_enc? p_enc: (char_u *)"latin1");
@@ -1197,10 +1228,29 @@ ucs2_to_enc(short_u *str, int *lenp)
     return enc_str;
 }
 #endif /* FEAT_MBYTE */
 
 /*
+ * Wait for another process to Close the Clipboard.
+ * Returns TRUE for success.
+ */
+    static int
+vim_open_clipboard(void)
+{
+    int delay = 10;
+
+    while (!OpenClipboard(NULL))
+    {
+        if (delay > 500)
+            return FALSE;  /* waited too long, give up */
+        Sleep(delay);
+        delay *= 2;	/* wait for 10, 20, 40, 80, etc. msec */
+    }
+    return TRUE;
+}
+
+/*
  * Get the current selection and put it in the clipboard register.
  *
  * NOTE: Must use GlobalLock/Unlock here to ensure Win32s compatibility.
  * On NT/W95 the clipboard data is a fixed global memory object and
  * so its handle = its pointer.
@@ -1227,11 +1277,11 @@ clip_mch_request_selection(VimClipboard
 
     /*
      * Don't pass GetActiveWindow() as an argument to OpenClipboard() because
      * then we can't paste back into the same window for some reason - webb.
      */
-    if (!OpenClipboard(NULL))
+    if (!vim_open_clipboard())
 	return;
 
     /* Check for vim's own clipboard format first.  This only gets the type of
      * the data, still need to use CF_UNICODETEXT or CF_TEXT for the text. */
     if (IsClipboardFormatAvailable(cbd->format))
@@ -1306,11 +1356,11 @@ clip_mch_request_selection(VimClipboard
 	    {
 		for (str_size = 0; str_size < maxlen; ++str_size)
 		    if (hMemWstr[str_size] == NUL)
 			break;
 	    }
-	    to_free = str = ucs2_to_enc((short_u *)hMemWstr, &str_size);
+	    to_free = str = utf16_to_enc((short_u *)hMemWstr, &str_size);
 	    GlobalUnlock(hMemW);
 	}
     }
     else
 #endif
@@ -1338,11 +1388,11 @@ clip_mch_request_selection(VimClipboard
 			break;
 	    }
 
 # if defined(FEAT_MBYTE) && defined(WIN3264)
 	    /* The text is in the active codepage.  Convert to 'encoding',
-	     * going through UCS-2. */
+	     * going through UTF-16. */
 	    acp_to_enc(str, str_size, &to_free, &maxlen);
 	    if (to_free != NULL)
 	    {
 		str_size = maxlen;
 		str = to_free;
@@ -1402,11 +1452,11 @@ acp_to_enc(str, str_size, out, outlen)
 
     MultiByteToWideChar_alloc(GetACP(), 0, str, str_size, &widestr, outlen);
     if (widestr != NULL)
     {
 	++*outlen;	/* Include the 0 after the string */
-	*out = ucs2_to_enc((short_u *)widestr, outlen);
+	*out = utf16_to_enc((short_u *)widestr, outlen);
 	vim_free(widestr);
     }
 }
 #endif
 
@@ -1464,13 +1514,13 @@ clip_mch_set_selection(VimClipboard *cbd
 # if defined(FEAT_MBYTE) && defined(WIN3264)
     {
 	WCHAR		*out;
 	int		len = metadata.txtlen;
 
-	/* Convert the text to UCS-2. This is put on the clipboard as
+	/* Convert the text to UTF-16. This is put on the clipboard as
 	 * CF_UNICODETEXT. */
-	out = (WCHAR *)enc_to_ucs2(str, &len);
+	out = (WCHAR *)enc_to_utf16(str, &len);
 	if (out != NULL)
 	{
 	    WCHAR *lpszMemW;
 
 	    /* Convert the text for CF_TEXT to Active codepage. Otherwise it's
@@ -1486,11 +1536,11 @@ clip_mch_set_selection(VimClipboard *cbd
 		return;		/* out of memory */
 	    }
 	    WideCharToMultiByte(GetACP(), 0, out, len,
 						  str, metadata.txtlen, 0, 0);
 
-	    /* Allocate memory for the UCS-2 text, add one NUL word to
+	    /* Allocate memory for the UTF-16 text, add one NUL word to
 	     * terminate the string. */
 	    hMemW = (LPSTR)GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
 						   (len + 1) * sizeof(WCHAR));
 	    lpszMemW = (WCHAR *)GlobalLock(hMemW);
 	    if (lpszMemW != NULL)
@@ -1535,11 +1585,11 @@ clip_mch_set_selection(VimClipboard *cbd
      *
      * Don't pass GetActiveWindow() as an argument to OpenClipboard()
      * because then we can't paste back into the same window for some
      * reason - webb.
      */
-    if (OpenClipboard(NULL))
+    if (vim_open_clipboard())
     {
 	if (EmptyClipboard())
 	{
 	    SetClipboardData(cbd->format, hMemVim);
 	    hMemVim = 0;
--- vim72.orig/src/os_win32.c
+++ vim72/src/os_win32.c
@@ -1585,11 +1585,11 @@ executable_exists(char *name)
     char	fname[_MAX_PATH];
 
 #ifdef FEAT_MBYTE
     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
     {
-	WCHAR	*p = enc_to_ucs2(name, NULL);
+	WCHAR	*p = enc_to_utf16(name, NULL);
 	WCHAR	fnamew[_MAX_PATH];
 	WCHAR	*dumw;
 	long	n;
 
 	if (p != NULL)
@@ -2438,11 +2438,11 @@ mch_dirname(
     {
 	WCHAR	wbuf[_MAX_PATH + 1];
 
 	if (GetCurrentDirectoryW(_MAX_PATH, wbuf) != 0)
 	{
-	    char_u  *p = ucs2_to_enc(wbuf, NULL);
+	    char_u  *p = utf16_to_enc(wbuf, NULL);
 
 	    if (p != NULL)
 	    {
 		vim_strncpy(buf, p, len - 1);
 		vim_free(p);
@@ -2464,11 +2464,11 @@ mch_dirname(
 mch_getperm(char_u *name)
 {
 #ifdef FEAT_MBYTE
     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
     {
-	WCHAR	*p = enc_to_ucs2(name, NULL);
+	WCHAR	*p = enc_to_utf16(name, NULL);
 	long	n;
 
 	if (p != NULL)
 	{
 	    n = (long)GetFileAttributesW(p);
@@ -2493,11 +2493,11 @@ mch_setperm(
 {
     perm |= FILE_ATTRIBUTE_ARCHIVE;	/* file has changed, set archive bit */
 #ifdef FEAT_MBYTE
     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
     {
-	WCHAR	*p = enc_to_ucs2(name, NULL);
+	WCHAR	*p = enc_to_utf16(name, NULL);
 	long	n;
 
 	if (p != NULL)
 	{
 	    n = (long)SetFileAttributesW(p, perm);
@@ -2520,11 +2520,11 @@ mch_hide(char_u *name)
     int		perm;
 #ifdef FEAT_MBYTE
     WCHAR	*p = NULL;
 
     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
-	p = enc_to_ucs2(name, NULL);
+	p = enc_to_utf16(name, NULL);
 #endif
 
 #ifdef FEAT_MBYTE
     if (p != NULL)
     {
@@ -2588,11 +2588,11 @@ mch_is_linked(char_u *fname)
     BY_HANDLE_FILE_INFORMATION inf;
 #ifdef FEAT_MBYTE
     WCHAR	*wn = NULL;
 
     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
-	wn = enc_to_ucs2(fname, NULL);
+	wn = enc_to_utf16(fname, NULL);
     if (wn != NULL)
     {
 	hFile = CreateFileW(wn,		/* file name */
 		    GENERIC_READ,	/* access mode */
 		    0,			/* share mode */
@@ -4237,11 +4237,11 @@ mch_remove(char_u *name)
     WCHAR	*wn = NULL;
     int		n;
 
     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
     {
-	wn = enc_to_ucs2(name, NULL);
+	wn = enc_to_utf16(name, NULL);
 	if (wn != NULL)
 	{
 	    SetFileAttributesW(wn, FILE_ATTRIBUTE_NORMAL);
 	    n = DeleteFileW(wn) ? 0 : -1;
 	    vim_free(wn);
@@ -4380,12 +4380,12 @@ mch_rename(
     WCHAR	*wnew = NULL;
     int		retval = -1;
 
     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
     {
-	wold = enc_to_ucs2((char_u *)pszOldFile, NULL);
-	wnew = enc_to_ucs2((char_u *)pszNewFile, NULL);
+	wold = enc_to_utf16((char_u *)pszOldFile, NULL);
+	wnew = enc_to_utf16((char_u *)pszNewFile, NULL);
 	if (wold != NULL && wnew != NULL)
 	    retval = mch_wrename(wold, wnew);
 	vim_free(wold);
 	vim_free(wnew);
 	if (retval == 0 || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
@@ -4490,11 +4490,11 @@ mch_access(char *n, int p)
     int		retval = -1;	    /* default: fail */
 #ifdef FEAT_MBYTE
     WCHAR	*wn = NULL;
 
     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
-	wn = enc_to_ucs2(n, NULL);
+	wn = enc_to_utf16(n, NULL);
 #endif
 
     if (mch_isdir(n))
     {
 	char TempName[_MAX_PATH + 16] = "";
@@ -4616,11 +4616,11 @@ getout:
     return retval;
 }
 
 #if defined(FEAT_MBYTE) || defined(PROTO)
 /*
- * Version of open() that may use ucs2 file name.
+ * Version of open() that may use UTF-16 file name.
  */
     int
 mch_open(char *name, int flags, int mode)
 {
     /* _wopen() does not work with Borland C 5.5: creates a read-only file. */
@@ -4628,11 +4628,11 @@ mch_open(char *name, int flags, int mode
     WCHAR	*wn;
     int		f;
 
     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
     {
-	wn = enc_to_ucs2(name, NULL);
+	wn = enc_to_utf16(name, NULL);
 	if (wn != NULL)
 	{
 	    f = _wopen(wn, flags, mode);
 	    vim_free(wn);
 	    if (f >= 0)
@@ -4646,11 +4646,11 @@ mch_open(char *name, int flags, int mode
 
     return open(name, flags, mode);
 }
 
 /*
- * Version of fopen() that may use ucs2 file name.
+ * Version of fopen() that may use UTF-16 file name.
  */
     FILE *
 mch_fopen(char *name, char *mode)
 {
     WCHAR	*wn, *wm;
@@ -4673,12 +4673,12 @@ mch_fopen(char *name, char *mode)
 	if (newMode == 't')
 	    _set_fmode(_O_TEXT);
 	else if (newMode == 'b')
 	    _set_fmode(_O_BINARY);
 # endif
-	wn = enc_to_ucs2(name, NULL);
-	wm = enc_to_ucs2(mode, NULL);
+	wn = enc_to_utf16(name, NULL);
+	wm = enc_to_utf16(mode, NULL);
 	if (wn != NULL && wm != NULL)
 	    f = _wfopen(wn, wm);
 	vim_free(wn);
 	vim_free(wm);
 
@@ -4774,12 +4774,12 @@ copy_infostreams(char_u *from, char_u *t
     void		*context = NULL;
     DWORD		lo, hi;
     int			len;
 
     /* Convert the file names to wide characters. */
-    fromw = enc_to_ucs2(from, NULL);
-    tow = enc_to_ucs2(to, NULL);
+    fromw = enc_to_utf16(from, NULL);
+    tow = enc_to_utf16(to, NULL);
     if (fromw != NULL && tow != NULL)
     {
 	/* Open the file for reading. */
 	sh = CreateFileW(fromw, GENERIC_READ, FILE_SHARE_READ, NULL,
 			     OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
@@ -5120,11 +5120,11 @@ fix_arg_enc(void)
 	return;		/* out of memory */
 
     for (i = 0; i < used_file_count; ++i)
     {
 	idx = used_file_indexes[i];
-	str = ucs2_to_enc(ArglistW[idx], NULL);
+	str = utf16_to_enc(ArglistW[idx], NULL);
 	if (str != NULL)
 	{
 #ifdef FEAT_DIFF
 	    /* When using diff mode may need to concatenate file name to
 	     * directory name.  Just like it's done in main(). */
--- vim72.orig/src/proto/os_mswin.pro
+++ vim72/src/proto/os_mswin.pro
@@ -20,18 +20,18 @@ int mch_has_exp_wildcard __ARGS((char_u
 int mch_has_wildcard __ARGS((char_u *p));
 int mch_chdir __ARGS((char *path));
 int can_end_termcap_mode __ARGS((int give_msg));
 int mch_screenmode __ARGS((char_u *arg));
 int mch_libcall __ARGS((char_u *libname, char_u *funcname, char_u *argstring, int argint, char_u **string_result, int *number_result));
-int utf8_to_ucs2 __ARGS((char_u *instr, int inlen, short_u *outstr, int *unconvlenp));
-int ucs2_to_utf8 __ARGS((short_u *instr, int inlen, char_u *outstr));
+int utf8_to_utf16 __ARGS((char_u *instr, int inlen, short_u *outstr, int *unconvlenp));
+int utf16_to_utf8 __ARGS((short_u *instr, int inlen, char_u *outstr));
 void MultiByteToWideChar_alloc __ARGS((UINT cp, DWORD flags, LPCSTR in, int inlen, LPWSTR *out, int *outlen));
 void WideCharToMultiByte_alloc __ARGS((UINT cp, DWORD flags, LPCWSTR in, int inlen, LPSTR *out, int *outlen, LPCSTR def, LPBOOL useddef));
 int clip_mch_own_selection __ARGS((VimClipboard *cbd));
 void clip_mch_lose_selection __ARGS((VimClipboard *cbd));
-short_u *enc_to_ucs2 __ARGS((char_u *str, int *lenp));
-char_u *ucs2_to_enc __ARGS((short_u *str, int *lenp));
+short_u *enc_to_utf16 __ARGS((char_u *str, int *lenp));
+char_u *utf16_to_enc __ARGS((short_u *str, int *lenp));
 void clip_mch_request_selection __ARGS((VimClipboard *cbd));
 void acp_to_enc __ARGS((char_u *str, int str_size, char_u **out, int *outlen));
 void clip_mch_set_selection __ARGS((VimClipboard *cbd));
 void DumpPutS __ARGS((const char *psz));
 int mch_get_winpos __ARGS((int *x, int *y));
--- vim72.orig/runtime/doc/options.txt
+++ vim72/runtime/doc/options.txt
@@ -1,6 +1,6 @@
-*options.txt*	For Vim version 7.2.  Last change: 2008 Aug 06
+*options.txt*	For Vim version 7.2.  Last change: 2008 Nov 25
 
 
 		  VIM REFERENCE MANUAL	  by Bram Moolenaar
 
 
@@ -1441,10 +1441,18 @@ A jump table for the options with a shor
 			Also applies to the modeless selection.
 
 	autoselectml	Like "autoselect", but for the modeless selection
 			only.  Compare to the 'A' flag in 'guioptions'.
 
+	html		When the clipboard contains HTML, use this when
+			pasting.  When putting text on the clipboard, mark it
+			as HTML.  This works to copy rendered HTML from
+			Firefox, paste it as raw HTML in Vim, select the HTML
+			in Vim and paste it in a rich edit box in Firefox.
+			Only supported for GTK version 2 and later.
+			Only available with the |+multi_byte| feature.
+
 	exclude:{pattern}
 			Defines a pattern that is matched against the name of
 			the terminal 'term'.  If there is a match, no
 			connection will be made to the X server.  This is
 			useful in this situation:
@@ -4173,13 +4181,10 @@ A jump table for the options with a shor
 	care of translating these special characters to the original meaning
 	of the key.  This means you don't have to change the keyboard mode to
 	be able to execute Normal mode commands.
 	This is the opposite of the 'keymap' option, where characters are
 	mapped in Insert mode.
-	This only works for 8-bit characters.  The value of 'langmap' may be
-	specified with multi-byte characters (e.g., UTF-8), but only the lower
-	8 bits of each character will be used.
 
 	Example (for Greek, in UTF-8):				*greek*  >
 	    :set langmap=A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,QQ,R,S,T,U,V,WW,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,qq,r,s,t,u,v,w,x,y,z
 <	Example (exchanges meaning of z and y for commands): >
 	    :set langmap=zy,yz,ZY,YZ
@@ -7470,11 +7475,13 @@ A jump table for the options with a shor
 			global
 			{not in Vi}
 			{not available when compiled without the |+wildignore|
 			feature}
 	A list of file patterns.  A file that matches with one of these
-	patterns is ignored when completing file or directory names.
+	patterns is ignored when completing file or directory names, and
+	influences the result of |expand()|, |glob()| and |globpath()| unless
+	a flag is passed to disable this.
 	The pattern is used like with |:autocmd|, see |autocmd-patterns|.
 	Also see 'suffixes'.
 	Example: >
 		:set wildignore=*.o,*.obj
 <	The use of |:set+=| and |:set-=| is preferred when adding or removing
--- vim72.orig/src/proto/ex_getln.pro
+++ vim72/src/proto/ex_getln.pro
@@ -2,10 +2,11 @@
 char_u *getcmdline __ARGS((int firstc, long count, int indent));
 char_u *getcmdline_prompt __ARGS((int firstc, char_u *prompt, int attr, int xp_context, char_u *xp_arg));
 int text_locked __ARGS((void));
 void text_locked_msg __ARGS((void));
 int curbuf_locked __ARGS((void));
+int allbuf_locked __ARGS((void));
 char_u *getexline __ARGS((int c, void *dummy, int indent));
 char_u *getexmodeline __ARGS((int promptc, void *dummy, int indent));
 int cmdline_overstrike __ARGS((void));
 int cmdline_at_end __ARGS((void));
 colnr_T cmdline_getvcol_cursor __ARGS((void));
@@ -29,11 +30,11 @@ void tilde_replace __ARGS((char_u *orig_
 char_u *sm_gettail __ARGS((char_u *s));
 char_u *addstar __ARGS((char_u *fname, int len, int context));
 void set_cmd_context __ARGS((expand_T *xp, char_u *str, int len, int col));
 int expand_cmdline __ARGS((expand_T *xp, char_u *str, int col, int *matchcount, char_u ***matches));
 int ExpandGeneric __ARGS((expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file, char_u *((*func)(expand_T *, int))));
-char_u *globpath __ARGS((char_u *path, char_u *file));
+char_u *globpath __ARGS((char_u *path, char_u *file, int expand_options));
 void init_history __ARGS((void));
 int get_histtype __ARGS((char_u *name));
 void add_to_history __ARGS((int histype, char_u *new_entry, int in_map, int sep));
 int get_history_idx __ARGS((int histype));
 char_u *get_cmdline_str __ARGS((void));
--- vim72.orig/src/workshop.c
+++ vim72/src/workshop.c
@@ -54,16 +54,16 @@ static void	 load_buffer_by_name(char *,
 static void	 load_buffer_by_number(int, int);
 #endif
 static void	 load_window(char *, int lnum);
 static void	 warp_to_pc(int);
 #ifdef FEAT_BEVAL
-void		workshop_beval_cb(BalloonEval *, int);
+void		 workshop_beval_cb(BalloonEval *, int);
+static int	 computeIndex(int, char_u *, int);
 #endif
 static char	*fixAccelText(char *);
 static void	 addMenu(char *, char *, char *);
 static char	*lookupVerb(char *, int);
-static int	 computeIndex(int, char_u *, int);
 static void	 coloncmd(char *, Boolean);
 
 extern Widget	 vimShell;
 extern Widget	 textArea;
 extern XtAppContext app_context;
@@ -202,16 +202,15 @@ workshop_get_editor_version()
  *	workshop_load_file
  *
  * Function:
  *	Load a given file into the WorkShop buffer.
  */
-/*ARGSUSED*/
     void
 workshop_load_file(
 	char	*filename,		/* the file to load */
 	int	 line,			/* an optional line number (or 0) */
-	char	*frameid)		/* used for multi-frame support */
+	char	*frameid UNUSED)	/* used for multi-frame support */
 {
 #ifdef WSDEBUG_TRACE
     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
 	wstrace("workshop_load_file(%s, %d)\n", filename, line);
 #endif
@@ -261,14 +260,13 @@ workshop_goto_line(
 #endif
 
     load_window(filename, lineno);
 }
 
-/*ARGSUSED*/
     void
 workshop_front_file(
-	char	*filename)
+	char	*filename UNUSED)
 {
 #ifdef WSDEBUG_TRACE
     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
 	wstrace("workshop_front_file()\n");
 #endif
@@ -536,13 +534,12 @@ workshop_adjust_marks(Widget *window, in
  * Are there any moved marks? If so, call workshop_move_mark on
  * each of them now. This is how eserve can find out if for example
  * breakpoints have moved when a program has been recompiled and
  * reloaded into dbx.
  */
-/*ARGSUSED*/
     void
-workshop_moved_marks(char *filename)
+workshop_moved_marks(char *filename UNUSED)
 {
 #ifdef WSDEBUG_TRACE
     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
 	wstrace("XXXworkshop_moved_marks(%s)\n", filename);
 #endif
@@ -573,15 +570,14 @@ workshop_get_font_height()
     }
 
     return (int)h;
 }
 
-/*ARGSUSED*/
     void
 workshop_footer_message(
-	char		*message,
-	int		 severity)	/* severity is currently unused */
+	char	*message,
+	int	severity UNUSED)	/* severity is currently unused */
 {
 #ifdef WSDEBUG_TRACE
     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
 	wstrace("workshop_footer_message(%s, %d)\n", message, severity);
 #endif
@@ -685,19 +681,18 @@ workshop_submenu_end()
 /*
  * This is where menus are really made. Each item will generate an amenu vim
  * command. The globals curMenuName and curMenuPriority contain the name and
  * priority of the parent menu tree.
  */
-/*ARGSUSED*/
     void
 workshop_menu_item(
 	char		*label,
 	char		*verb,
-	char		*accelerator,
+	char		*accelerator UNUSED,
 	char		*acceleratorText,
-	char		*name,
-	char		*filepos,
+	char		*name UNUSED,
+	char		*filepos UNUSED,
 	char		*sensitive)
 {
     char		 cbuf[BUFSIZ];
     char		 namebuf[BUFSIZ];
     char		 accText[BUFSIZ];
@@ -808,17 +803,16 @@ workshop_toolbar_end()
 	set_option_value((char_u *)"go", 0L, buf, 0);
     }
     workshopInitDone = True;
 }
 
-/*ARGSUSED*/
     void
 workshop_toolbar_button(
 	char	*label,
 	char	*verb,
-	char	*senseVerb,
-	char	*filepos,
+	char	*senseVerb UNUSED,
+	char	*filepos UNUSED,
 	char	*help,
 	char	*sense,
 	char	*file,
 	char	*left)
 {
@@ -966,11 +960,13 @@ workshop_set_option(
     {
 	case 's':
 	    if (strcmp(option, "syntax") == 0)
 		vim_snprintf(cbuf, sizeof(cbuf), "syntax %s", value);
 	    else if (strcmp(option, "savefiles") == 0)
-		; /* XXX - Not yet implemented */
+	    {
+		/* XXX - Not yet implemented */
+	    }
 	    break;
 
 	case 'l':
 	    if (strcmp(option, "lineno") == 0)
 		sprintf(cbuf, "set %snu",
@@ -1096,14 +1092,13 @@ workshop_hotkeys(
 }
 
 /*
  * A button in the toolbar has been pushed.
  */
-/*ARGSUSED*/
     int
 workshop_get_positions(
-	void		*clientData,	/* unused */
+	void		*clientData UNUSED,
 	char	       **filename,	/* output data */
 	int		*curLine,	/* output data */
 	int		*curCol,	/* output data */
 	int		*selStartLine,	/* output data */
 	int		*selStartCol,	/* output data */
@@ -1119,12 +1114,16 @@ workshop_get_positions(
 	wstrace("workshop_get_positions(%#x, \"%s\", ...)\n",
 		clientData, (curbuf && curbuf->b_sfname != NULL)
 				      ? (char *)curbuf->b_sfname : "<None>");
 #endif
 
-    strcpy(ffname, (char *) curbuf->b_ffname);
-    *filename = ffname;		/* copy so nobody can change b_ffname */
+    if (curbuf->b_ffname == NULL)
+	ffname[0] = NUL;
+    else
+	/* copy so nobody can change b_ffname */
+	strcpy(ffname, (char *) curbuf->b_ffname);
+    *filename = ffname;
     *curLine = curwin->w_cursor.lnum;
     *curCol = curwin->w_cursor.col;
 
     if (curbuf->b_visual.vi_mode == 'v' &&
 	    equalpos(curwin->w_cursor, curbuf->b_visual.vi_end))
@@ -1520,13 +1519,12 @@ workshop_test_getselectedtext()
 	return selection;
     else
 	return NULL;
 }
 
-/*ARGSUSED*/
     void
-workshop_save_sensitivity(char *filename)
+workshop_save_sensitivity(char *filename UNUSED)
 {
 }
 
 #endif
 
@@ -1624,12 +1622,10 @@ workshop_beval_cb(
 		workshop_send_message(buf);
 	    }
 	}
     }
 }
-#endif
-
 
     static int
 computeIndex(
 	int		 wantedCol,
 	char_u		*line,
@@ -1649,10 +1645,11 @@ computeIndex(
 	    return idx;
     }
 
     return -1;
 }
+#endif
 
     static void
 addMenu(
 	char		*menu,		/* menu name */
 	char		*accel,		/* accelerator text (optional) */
--- vim72.orig/src/getchar.c
+++ vim72/src/getchar.c
@@ -20,11 +20,11 @@
 
 /*
  * These buffers are used for storing:
  * - stuffed characters: A command that is translated into another command.
  * - redo characters: will redo the last change.
- * - recorded chracters: for the "q" command.
+ * - recorded characters: for the "q" command.
  *
  * The bytes are stored like in the typeahead buffer:
  * - K_SPECIAL introduces a special key (two more bytes follow).  A literal
  *   K_SPECIAL is stored as K_SPECIAL KS_SPECIAL KE_FILLER.
  * - CSI introduces a GUI termcap code (also when gui.in_use is FALSE,
@@ -127,11 +127,11 @@ static void	closescript __ARGS((void));
 static int	vgetorpeek __ARGS((int));
 static void	map_free __ARGS((mapblock_T **));
 static void	validate_maphash __ARGS((void));
 static void	showmap __ARGS((mapblock_T *mp, int local));
 #ifdef FEAT_EVAL
-static char_u	*eval_map_expr __ARGS((char_u *str));
+static char_u	*eval_map_expr __ARGS((char_u *str, int c));
 #endif
 
 /*
  * Free and clear a buffer.
  */
@@ -1281,11 +1281,11 @@ free_typebuf()
 {
     if (typebuf.tb_buf == typebuf_init)
 	EMSG2(_(e_intern2), "Free typebuf 1");
     else
 	vim_free(typebuf.tb_buf);
-    if (typebuf.tb_buf == noremapbuf_init)
+    if (typebuf.tb_noremap == noremapbuf_init)
 	EMSG2(_(e_intern2), "Free typebuf 2");
     else
 	vim_free(typebuf.tb_noremap);
 }
 
@@ -1307,10 +1307,13 @@ save_typebuf()
 	return FAIL;
     }
     return OK;
 }
 
+static int old_char = -1;	/* character put back by vungetc() */
+static int old_mod_mask;	/* mod_mask for ungotten character */
+
 #if defined(FEAT_EVAL) || defined(FEAT_EX_EXTRA) || defined(PROTO)
 
 /*
  * Save all three kinds of typeahead, so that the user must type at a prompt.
  */
@@ -1321,10 +1324,14 @@ save_typeahead(tp)
     tp->save_typebuf = typebuf;
     tp->typebuf_valid = (alloc_typebuf() == OK);
     if (!tp->typebuf_valid)
 	typebuf = tp->save_typebuf;
 
+    tp->old_char = old_char;
+    tp->old_mod_mask = old_mod_mask;
+    old_char = -1;
+
     tp->save_stuffbuff = stuffbuff;
     stuffbuff.bh_first.b_next = NULL;
 # ifdef USE_INPUT_BUF
     tp->save_inputbuf = get_input_buf();
 # endif
@@ -1342,10 +1349,13 @@ restore_typeahead(tp)
     {
 	free_typebuf();
 	typebuf = tp->save_typebuf;
     }
 
+    old_char = tp->old_char;
+    old_mod_mask = tp->old_mod_mask;
+
     free_buff(&stuffbuff);
     stuffbuff = tp->save_stuffbuff;
 # ifdef USE_INPUT_BUF
     set_input_buf(tp->save_inputbuf);
 # endif
@@ -1497,21 +1507,18 @@ updatescript(c)
 }
 
 #define KL_PART_KEY -1		/* keylen value for incomplete key-code */
 #define KL_PART_MAP -2		/* keylen value for incomplete mapping */
 
-static int old_char = -1;	/* character put back by vungetc() */
-static int old_mod_mask;	/* mod_mask for ungotten character */
-
 /*
  * Get the next input character.
  * Can return a special key or a multi-byte character.
  * Can return NUL when called recursively, use safe_vgetc() if that's not
  * wanted.
  * This translates escaped K_SPECIAL and CSI bytes to a K_SPECIAL or CSI byte.
  * Collects the bytes of a multibyte character into the whole character.
- * Returns the modifers in the global "mod_mask".
+ * Returns the modifiers in the global "mod_mask".
  */
     int
 vgetc()
 {
     int		c, c2;
@@ -2380,10 +2387,21 @@ vgetorpeek(advance)
 		    }
 
 		    /* complete match */
 		    if (keylen >= 0 && keylen <= typebuf.tb_len)
 		    {
+#ifdef FEAT_EVAL
+			int save_m_expr;
+			int save_m_noremap;
+			int save_m_silent;
+			char_u *save_m_keys;
+			char_u *save_m_str;
+#else
+# define save_m_noremap mp->m_noremap
+# define save_m_silent mp->m_silent
+#endif
+
 			/* write chars to script file(s) */
 			if (keylen > typebuf.tb_maplen)
 			    gotchars(typebuf.tb_buf + typebuf.tb_off
 							  + typebuf.tb_maplen,
 						  keylen - typebuf.tb_maplen);
@@ -2422,10 +2440,20 @@ vgetorpeek(advance)
 							      0, TRUE, FALSE);
 			}
 #endif
 
 #ifdef FEAT_EVAL
+			/* Copy the values from *mp that are used, because
+			 * evaluating the expression may invoke a function
+			 * that redefines the mapping, thereby making *mp
+			 * invalid. */
+			save_m_expr = mp->m_expr;
+			save_m_noremap = mp->m_noremap;
+			save_m_silent = mp->m_silent;
+			save_m_keys = NULL;  /* only saved when needed */
+			save_m_str = NULL;  /* only saved when needed */
+
 			/*
 			 * Handle ":map <expr>": evaluate the {rhs} as an
 			 * expression.  Save and restore the typeahead so that
 			 * getchar() can be used.  Also save and restore the
 			 * command line for "normal :".
@@ -2437,11 +2465,13 @@ vgetorpeek(advance)
 
 			    save_typeahead(&tabuf);
 			    if (tabuf.typebuf_valid)
 			    {
 				vgetc_busy = 0;
-				s = eval_map_expr(mp->m_str);
+				save_m_keys = vim_strsave(mp->m_keys);
+				save_m_str = vim_strsave(mp->m_str);
+				s = eval_map_expr(save_m_str, NUL);
 				vgetc_busy = save_vgetc_busy;
 			    }
 			    else
 				s = NULL;
 			    restore_typeahead(&tabuf);
@@ -2460,22 +2490,37 @@ vgetorpeek(advance)
 			 */
 			if (s == NULL)
 			    i = FAIL;
 			else
 			{
-			    i = ins_typebuf(s,
-				    mp->m_noremap != REMAP_YES
-					    ? mp->m_noremap
-					    : STRNCMP(s, mp->m_keys,
-							  (size_t)keylen) != 0
-						     ? REMAP_YES : REMAP_SKIP,
-				0, TRUE, cmd_silent || mp->m_silent);
+			    int noremap;
+
+			    if (save_m_noremap != REMAP_YES)
+				noremap = save_m_noremap;
+			    else if (
+#ifdef FEAT_EVAL
+				STRNCMP(s, save_m_keys != NULL
+						   ? save_m_keys : mp->m_keys,
+							 (size_t)keylen)
+#else
+				STRNCMP(s, mp->m_keys, (size_t)keylen)
+#endif
+				   != 0)
+				noremap = REMAP_YES;
+			    else
+				noremap = REMAP_SKIP;
+			    i = ins_typebuf(s, noremap,
+					0, TRUE, cmd_silent || save_m_silent);
 #ifdef FEAT_EVAL
-			    if (mp->m_expr)
+			    if (save_m_expr)
 				vim_free(s);
 #endif
 			}
+#ifdef FEAT_EVAL
+			vim_free(save_m_keys);
+			vim_free(save_m_str);
+#endif
 			if (i == FAIL)
 			{
 			    c = -1;
 			    break;
 			}
@@ -3311,11 +3356,11 @@ do_map(maptype, arg, mode, abbrev)
 			if (vim_iswordc(keys[n]) != vim_iswordc(keys[len - 2]))
 			{
 			    retval = 1;
 			    goto theend;
 			}
-	    /* An abbrevation cannot contain white space. */
+	    /* An abbreviation cannot contain white space. */
 	    for (n = 0; n < len; ++n)
 		if (vim_iswhite(keys[n]))
 		{
 		    retval = 1;
 		    goto theend;
@@ -3699,15 +3744,14 @@ get_map_mode(cmdp, forceit)
 
 /*
  * Clear all mappings or abbreviations.
  * 'abbr' should be FALSE for mappings, TRUE for abbreviations.
  */
-/*ARGSUSED*/
     void
 map_clear(cmdp, arg, forceit, abbr)
     char_u	*cmdp;
-    char_u	*arg;
+    char_u	*arg UNUSED;
     int		forceit;
     int		abbr;
 {
     int		mode;
 #ifdef FEAT_LOCALMAP
@@ -3732,17 +3776,16 @@ map_clear(cmdp, arg, forceit, abbr)
 }
 
 /*
  * Clear all mappings in "mode".
  */
-/*ARGSUSED*/
     void
 map_clear_int(buf, mode, local, abbr)
-    buf_T	*buf;	    /* buffer for local mappings */
-    int		mode;	    /* mode in which to delete */
-    int		local;	    /* TRUE for buffer-local mappings */
-    int		abbr;	    /* TRUE for abbreviations */
+    buf_T	*buf UNUSED;	/* buffer for local mappings */
+    int		mode;		/* mode in which to delete */
+    int		local UNUSED;	/* TRUE for buffer-local mappings */
+    int		abbr;		/* TRUE for abbreviations */
 {
     mapblock_T	*mp, **mpp;
     int		hash;
     int		new_hash;
 
@@ -3814,11 +3857,15 @@ showmap(mp, local)
     int		local;	    /* TRUE for buffer-local map */
 {
     int len = 1;
 
     if (msg_didout || msg_silent != 0)
+    {
 	msg_putchar('\n');
+	if (got_int)	    /* 'q' typed at MORE prompt */
+	    return;
+    }
     if ((mp->m_mode & (INSERT + CMDLINE)) == INSERT + CMDLINE)
 	msg_putchar('!');			/* :map! */
     else if (mp->m_mode & INSERT)
 	msg_putchar('i');			/* :imap */
     else if (mp->m_mode & LANGMAP)
@@ -4261,11 +4308,11 @@ check_abbr(c, ptr, col, mincol)
 	/* no remapping implies no abbreviation */
 	return FALSE;
 
     /*
      * Check for word before the cursor: If it ends in a keyword char all
-     * chars before it must be al keyword chars or non-keyword chars, but not
+     * chars before it must be keyword chars or non-keyword chars, but not
      * white space. If it ends in a non-keyword char we accept any characters
      * before it except white space.
      */
     if (col == 0)				/* cannot be an abbr. */
 	return FALSE;
@@ -4356,13 +4403,13 @@ check_abbr(c, ptr, col, mincol)
 	     *
 	     * Character CTRL-] is treated specially - it completes the
 	     * abbreviation, but is not inserted into the input stream.
 	     */
 	    j = 0;
-					/* special key code, split up */
 	    if (c != Ctrl_RSB)
 	    {
+					/* special key code, split up */
 		if (IS_SPECIAL(c) || c == K_SPECIAL)
 		{
 		    tb[j++] = K_SPECIAL;
 		    tb[j++] = K_SECOND(c);
 		    tb[j++] = K_THIRD(c);
@@ -4387,11 +4434,11 @@ check_abbr(c, ptr, col, mincol)
 					/* insert the last typed char */
 		(void)ins_typebuf(tb, 1, 0, TRUE, mp->m_silent);
 	    }
 #ifdef FEAT_EVAL
 	    if (mp->m_expr)
-		s = eval_map_expr(mp->m_str);
+		s = eval_map_expr(mp->m_str, c);
 	    else
 #endif
 		s = mp->m_str;
 	    if (s != NULL)
 	    {
@@ -4423,12 +4470,13 @@ check_abbr(c, ptr, col, mincol)
 /*
  * Evaluate the RHS of a mapping or abbreviations and take care of escaping
  * special characters.
  */
     static char_u *
-eval_map_expr(str)
+eval_map_expr(str, c)
     char_u	*str;
+    int		c;	    /* NUL or typed character for abbreviation */
 {
     char_u	*res;
     char_u	*p;
     char_u	*save_cmd;
     pos_T	save_cursor;
@@ -4441,10 +4489,11 @@ eval_map_expr(str)
      * effects.  Also restore the cursor position. */
     ++textlock;
 #ifdef FEAT_EX_EXTRA
     ++ex_normal_lock;
 #endif
+    set_vim_var_char(c);  /* set v:char to the typed character */
     save_cursor = curwin->w_cursor;
     p = eval_to_string(str, NULL, FALSE);
     --textlock;
 #ifdef FEAT_EX_EXTRA
     --ex_normal_lock;
@@ -4700,11 +4749,11 @@ makemap(fd, buf)
 		    }
 		    if (c1 && putc(c1, fd) < 0)
 			return FAIL;
 		    if (mp->m_noremap != REMAP_YES && fprintf(fd, "nore") < 0)
 			return FAIL;
-		    if (fprintf(fd, cmd) < 0)
+		    if (fputs(cmd, fd) < 0)
 			return FAIL;
 		    if (buf != NULL && fputs(" <buffer>", fd) < 0)
 			return FAIL;
 		    if (mp->m_silent && fputs(" <silent>", fd) < 0)
 			return FAIL;
@@ -4799,11 +4848,11 @@ put_escstr(fd, strstart, what)
 		c = TO_SPECIAL(str[1], str[2]);
 		str += 2;
 	    }
 	    if (IS_SPECIAL(c) || modifiers)	/* special key */
 	    {
-		if (fprintf(fd, (char *)get_special_key_name(c, modifiers)) < 0)
+		if (fputs((char *)get_special_key_name(c, modifiers), fd) < 0)
 		    return FAIL;
 		continue;
 	    }
 	}
 
--- vim72.orig/src/diff.c
+++ vim72/src/diff.c
@@ -6,11 +6,11 @@
  * Do ":help credits" in Vim to see a list of people who contributed.
  * See README.txt for an overview of the Vim source code.
  */
 
 /*
- * diff.c: code for diff'ing two or three buffers.
+ * diff.c: code for diff'ing two, three or four buffers.
  */
 
 #include "vim.h"
 
 #if defined(FEAT_DIFF) || defined(PROTO)
@@ -71,10 +71,12 @@ diff_buf_delete(buf)
 	i = diff_buf_idx_tp(buf, tp);
 	if (i != DB_COUNT)
 	{
 	    tp->tp_diffbuf[i] = NULL;
 	    tp->tp_diff_invalid = TRUE;
+	    if (tp == curtab)
+		diff_redraw(TRUE);
 	}
     }
 }
 
 /*
@@ -100,10 +102,11 @@ diff_buf_adjust(win)
 	    i = diff_buf_idx(win->w_buffer);
 	    if (i != DB_COUNT)
 	    {
 		curtab->tp_diffbuf[i] = NULL;
 		curtab->tp_diff_invalid = TRUE;
+		diff_redraw(TRUE);
 	    }
 	}
     }
     else
 	diff_buf_add(win->w_buffer);
@@ -111,11 +114,11 @@ diff_buf_adjust(win)
 
 /*
  * Add a buffer to make diffs for.
  * Call this when a new buffer is being edited in the current window where
  * 'diff' is set.
- * Marks the current buffer as being part of the diff and requireing updating.
+ * Marks the current buffer as being part of the diff and requiring updating.
  * This must be done before any autocmd, because a command may use info
  * about the screen contents.
  */
     void
 diff_buf_add(buf)
@@ -129,10 +132,11 @@ diff_buf_add(buf)
     for (i = 0; i < DB_COUNT; ++i)
 	if (curtab->tp_diffbuf[i] == NULL)
 	{
 	    curtab->tp_diffbuf[i] = buf;
 	    curtab->tp_diff_invalid = TRUE;
+	    diff_redraw(TRUE);
 	    return;
 	}
 
     EMSGN(_("E96: Can not diff more than %ld buffers"), DB_COUNT);
 }
@@ -646,23 +650,23 @@ diff_write(buf, fname)
  * Completely update the diffs for the buffers involved.
  * This uses the ordinary "diff" command.
  * The buffers are written to a file, also for unmodified buffers (the file
  * could have been produced by autocommands, e.g. the netrw plugin).
  */
-/*ARGSUSED*/
     void
 ex_diffupdate(eap)
-    exarg_T	*eap;	    /* can be NULL, it's not used */
+    exarg_T	*eap UNUSED;	    /* can be NULL */
 {
     buf_T	*buf;
     int		idx_orig;
     int		idx_new;
     char_u	*tmp_orig;
     char_u	*tmp_new;
     char_u	*tmp_diff;
     FILE	*fd;
     int		ok;
+    int		io_error = FALSE;
 
     /* Delete all diffblocks. */
     diff_clear(curtab);
     curtab->tp_diff_invalid = FALSE;
 
@@ -695,22 +699,30 @@ ex_diffupdate(eap)
      */
     for (;;)
     {
 	ok = FALSE;
 	fd = mch_fopen((char *)tmp_orig, "w");
-	if (fd != NULL)
+	if (fd == NULL)
+	    io_error = TRUE;
+	else
 	{
-	    fwrite("line1\n", (size_t)6, (size_t)1, fd);
+	    if (fwrite("line1\n", (size_t)6, (size_t)1, fd) != 1)
+		io_error = TRUE;
 	    fclose(fd);
 	    fd = mch_fopen((char *)tmp_new, "w");
-	    if (fd != NULL)
+	    if (fd == NULL)
+		io_error = TRUE;
+	    else
 	    {
-		fwrite("line2\n", (size_t)6, (size_t)1, fd);
+		if (fwrite("line2\n", (size_t)6, (size_t)1, fd) != 1)
+		    io_error = TRUE;
 		fclose(fd);
 		diff_file(tmp_orig, tmp_new, tmp_diff);
 		fd = mch_fopen((char *)tmp_diff, "r");
-		if (fd != NULL)
+		if (fd == NULL)
+		    io_error = TRUE;
+		else
 		{
 		    char_u	linebuf[LBUFLEN];
 
 		    for (;;)
 		    {
@@ -759,10 +771,12 @@ ex_diffupdate(eap)
 	if (ok)
 	    break;
     }
     if (!ok)
     {
+	if (io_error)
+	    EMSG(_("E810: Cannot read or write temp files"));
 	EMSG(_("E97: Cannot create diffs"));
 	diff_a_works = MAYBE;
 #if defined(MSWIN) || defined(MSDOS)
 	diff_bin_works = MAYBE;
 #endif
@@ -810,40 +824,42 @@ diff_file(tmp_orig, tmp_new, tmp_diff)
     char_u	*tmp_orig;
     char_u	*tmp_new;
     char_u	*tmp_diff;
 {
     char_u	*cmd;
+    size_t	len;
 
 #ifdef FEAT_EVAL
     if (*p_dex != NUL)
 	/* Use 'diffexpr' to generate the diff file. */
 	eval_diff(tmp_orig, tmp_new, tmp_diff);
     else
 #endif
     {
-	cmd = alloc((unsigned)(STRLEN(tmp_orig) + STRLEN(tmp_new)
-				+ STRLEN(tmp_diff) + STRLEN(p_srr) + 27));
+	len = STRLEN(tmp_orig) + STRLEN(tmp_new)
+				      + STRLEN(tmp_diff) + STRLEN(p_srr) + 27;
+	cmd = alloc((unsigned)len);
 	if (cmd != NULL)
 	{
 	    /* We don't want $DIFF_OPTIONS to get in the way. */
 	    if (getenv("DIFF_OPTIONS"))
 		vim_setenv((char_u *)"DIFF_OPTIONS", (char_u *)"");
 
 	    /* Build the diff command and execute it.  Always use -a, binary
 	     * differences are of no use.  Ignore errors, diff returns
 	     * non-zero when differences have been found. */
-	    sprintf((char *)cmd, "diff %s%s%s%s%s %s",
+	    vim_snprintf((char *)cmd, len, "diff %s%s%s%s%s %s",
 		    diff_a_works == FALSE ? "" : "-a ",
 #if defined(MSWIN) || defined(MSDOS)
 		    diff_bin_works == TRUE ? "--binary " : "",
 #else
 		    "",
 #endif
 		    (diff_flags & DIFF_IWHITE) ? "-b " : "",
 		    (diff_flags & DIFF_ICASE) ? "-i " : "",
 		    tmp_orig, tmp_new);
-	    append_redir(cmd, p_srr, tmp_diff);
+	    append_redir(cmd, (int)len, p_srr, tmp_diff);
 #ifdef FEAT_AUTOCMD
 	    block_autocmds();	/* Avoid ShellCmdPost stuff */
 #endif
 	    (void)call_shell(cmd, SHELL_FILTER|SHELL_SILENT|SHELL_DOOUT);
 #ifdef FEAT_AUTOCMD
@@ -864,20 +880,22 @@ ex_diffpatch(eap)
     exarg_T	*eap;
 {
     char_u	*tmp_orig;	/* name of original temp file */
     char_u	*tmp_new;	/* name of patched temp file */
     char_u	*buf = NULL;
+    size_t	buflen;
     win_T	*old_curwin = curwin;
     char_u	*newname = NULL;	/* name of patched file buffer */
 #ifdef UNIX
     char_u	dirbuf[MAXPATHL];
     char_u	*fullname = NULL;
 #endif
 #ifdef FEAT_BROWSE
     char_u	*browseFile = NULL;
     int		browse_flag = cmdmod.browse;
 #endif
+    struct stat st;
 
 #ifdef FEAT_BROWSE
     if (cmdmod.browse)
     {
 	browseFile = do_browse(0, (char_u *)_("Patch file"),
@@ -903,34 +921,35 @@ ex_diffpatch(eap)
 
 #ifdef UNIX
     /* Get the absolute path of the patchfile, changing directory below. */
     fullname = FullName_save(eap->arg, FALSE);
 #endif
-    buf = alloc((unsigned)(STRLEN(tmp_orig) + (
+    buflen = STRLEN(tmp_orig) + (
 # ifdef UNIX
 		    fullname != NULL ? STRLEN(fullname) :
 # endif
-		    STRLEN(eap->arg)) + STRLEN(tmp_new) + 16));
+		    STRLEN(eap->arg)) + STRLEN(tmp_new) + 16;
+    buf = alloc((unsigned)buflen);
     if (buf == NULL)
 	goto theend;
 
 #ifdef UNIX
-    /* Temporaraly chdir to /tmp, to avoid patching files in the current
+    /* Temporarily chdir to /tmp, to avoid patching files in the current
      * directory when the patch file contains more than one patch.  When we
      * have our own temp dir use that instead, it will be cleaned up when we
      * exit (any .rej files created).  Don't change directory if we can't
      * return to the current. */
     if (mch_dirname(dirbuf, MAXPATHL) != OK || mch_chdir((char *)dirbuf) != 0)
 	dirbuf[0] = NUL;
     else
     {
 # ifdef TEMPDIRNAMES
 	if (vim_tempdir != NULL)
-	    mch_chdir((char *)vim_tempdir);
+	    ignored = mch_chdir((char *)vim_tempdir);
 	else
 # endif
-	    mch_chdir("/tmp");
+	    ignored = mch_chdir("/tmp");
 	shorten_fnames(TRUE);
     }
 #endif
 
 #ifdef FEAT_EVAL
@@ -944,11 +963,12 @@ ex_diffpatch(eap)
     else
 #endif
     {
 	/* Build the patch command and execute it.  Ignore errors.  Switch to
 	 * cooked mode to allow the user to respond to prompts. */
-	sprintf((char *)buf, "patch -o %s %s < \"%s\"", tmp_new, tmp_orig,
+	vim_snprintf((char *)buf, buflen, "patch -o %s %s < \"%s\"",
+		tmp_new, tmp_orig,
 # ifdef UNIX
 		fullname != NULL ? fullname :
 # endif
 		eap->arg);
 #ifdef FEAT_AUTOCMD
@@ -978,48 +998,55 @@ ex_diffpatch(eap)
     mch_remove(buf);
     STRCPY(buf, tmp_new);
     STRCAT(buf, ".rej");
     mch_remove(buf);
 
-    if (curbuf->b_fname != NULL)
+    /* Only continue if the output file was created. */
+    if (mch_stat((char *)tmp_new, &st) < 0 || st.st_size == 0)
+	EMSG(_("E816: Cannot read patch output"));
+    else
     {
-	newname = vim_strnsave(curbuf->b_fname,
+	if (curbuf->b_fname != NULL)
+	{
+	    newname = vim_strnsave(curbuf->b_fname,
 					  (int)(STRLEN(curbuf->b_fname) + 4));
-	if (newname != NULL)
-	    STRCAT(newname, ".new");
-    }
+	    if (newname != NULL)
+		STRCAT(newname, ".new");
+	}
 
 #ifdef FEAT_GUI
-    need_mouse_correct = TRUE;
+	need_mouse_correct = TRUE;
 #endif
-    /* don't use a new tab page, each tab page has its own diffs */
-    cmdmod.tab = 0;
-
-    if (win_split(0, (diff_flags & DIFF_VERTICAL) ? WSP_VERT : 0) != FAIL)
-    {
-	/* Pretend it was a ":split fname" command */
-	eap->cmdidx = CMD_split;
-	eap->arg = tmp_new;
-	do_exedit(eap, old_curwin);
+	/* don't use a new tab page, each tab page has its own diffs */
+	cmdmod.tab = 0;
 
-	if (curwin != old_curwin)		/* split must have worked */
+	if (win_split(0, (diff_flags & DIFF_VERTICAL) ? WSP_VERT : 0) != FAIL)
 	{
-	    /* Set 'diff', 'scrollbind' on and 'wrap' off. */
-	    diff_win_options(curwin, TRUE);
-	    diff_win_options(old_curwin, TRUE);
+	    /* Pretend it was a ":split fname" command */
+	    eap->cmdidx = CMD_split;
+	    eap->arg = tmp_new;
+	    do_exedit(eap, old_curwin);
 
-	    if (newname != NULL)
+	    /* check that split worked and editing tmp_new */
+	    if (curwin != old_curwin && win_valid(old_curwin))
 	    {
-		/* do a ":file filename.new" on the patched buffer */
-		eap->arg = newname;
-		ex_file(eap);
+		/* Set 'diff', 'scrollbind' on and 'wrap' off. */
+		diff_win_options(curwin, TRUE);
+		diff_win_options(old_curwin, TRUE);
+
+		if (newname != NULL)
+		{
+		    /* do a ":file filename.new" on the patched buffer */
+		    eap->arg = newname;
+		    ex_file(eap);
 
 #ifdef FEAT_AUTOCMD
-		/* Do filetype detection with the new name. */
-		if (au_has_group((char_u *)"filetypedetect"))
-		    do_cmdline_cmd((char_u *)":doau filetypedetect BufRead");
+		    /* Do filetype detection with the new name. */
+		    if (au_has_group((char_u *)"filetypedetect"))
+			do_cmdline_cmd((char_u *)":doau filetypedetect BufRead");
 #endif
+		}
 	    }
 	}
     }
 
 theend:
@@ -1072,14 +1099,13 @@ ex_diffsplit(eap)
 }
 
 /*
  * Set options to show difs for the current window.
  */
-/*ARGSUSED*/
     void
 ex_diffthis(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     /* Set 'diff', 'scrollbind' on and 'wrap' off. */
     diff_win_options(curwin, TRUE);
 }
 
@@ -1089,30 +1115,35 @@ ex_diffthis(eap)
     void
 diff_win_options(wp, addbuf)
     win_T	*wp;
     int		addbuf;		/* Add buffer to diff. */
 {
+# ifdef FEAT_FOLDING
+    win_T *old_curwin = curwin;
+
+    /* close the manually opened folds */
+    curwin = wp;
+    newFoldLevel();
+    curwin = old_curwin;
+# endif
+
     wp->w_p_diff = TRUE;
     wp->w_p_scb = TRUE;
     wp->w_p_wrap = FALSE;
 # ifdef FEAT_FOLDING
-    {
-	win_T	    *old_curwin = curwin;
-
-	curwin = wp;
-	curbuf = curwin->w_buffer;
-	set_string_option_direct((char_u *)"fdm", -1, (char_u *)"diff",
+    curwin = wp;
+    curbuf = curwin->w_buffer;
+    set_string_option_direct((char_u *)"fdm", -1, (char_u *)"diff",
 						       OPT_LOCAL|OPT_FREE, 0);
-	curwin = old_curwin;
-	curbuf = curwin->w_buffer;
-	wp->w_p_fdc = diff_foldcolumn;
-	wp->w_p_fen = TRUE;
-	wp->w_p_fdl = 0;
-	foldUpdateAll(wp);
-	/* make sure topline is not halfway a fold */
-	changed_window_setting_win(wp);
-    }
+    curwin = old_curwin;
+    curbuf = curwin->w_buffer;
+    wp->w_p_fdc = diff_foldcolumn;
+    wp->w_p_fen = TRUE;
+    wp->w_p_fdl = 0;
+    foldUpdateAll(wp);
+    /* make sure topline is not halfway a fold */
+    changed_window_setting_win(wp);
 # endif
 #ifdef FEAT_SCROLLBIND
     if (vim_strchr(p_sbo, 'h') == NULL)
 	do_cmdline_cmd((char_u *)"set sbo+=hor");
 #endif
@@ -1136,11 +1167,11 @@ ex_diffoff(eap)
     int		diffwin = FALSE;
 #endif
 
     for (wp = firstwin; wp != NULL; wp = wp->w_next)
     {
-	if (wp == curwin || eap->forceit)
+	if (wp == curwin || (eap->forceit && wp->w_p_diff))
 	{
 	    /* Set 'diff', 'scrollbind' off and 'wrap' on. */
 	    wp->w_p_diff = FALSE;
 	    wp->w_p_scb = FALSE;
 	    wp->w_p_wrap = TRUE;
@@ -2112,10 +2143,12 @@ ex_diffgetput(eap)
 	if (buf == NULL)
 	{
 	    EMSG2(_("E102: Can't find buffer \"%s\""), eap->arg);
 	    return;
 	}
+	if (buf == curbuf)
+	    return;		/* nothing to do */
 	idx_other = diff_buf_idx(buf);
 	if (idx_other == DB_COUNT)
 	{
 	    EMSG2(_("E103: Buffer \"%s\" is not in diff mode"), eap->arg);
 	    return;
--- vim72.orig/src/fold.c
+++ vim72/src/fold.c
@@ -46,11 +46,11 @@ typedef struct
 static void newFoldLevelWin __ARGS((win_T *wp));
 static int checkCloseRec __ARGS((garray_T *gap, linenr_T lnum, int level));
 static int foldFind __ARGS((garray_T *gap, linenr_T lnum, fold_T **fpp));
 static int foldLevelWin __ARGS((win_T *wp, linenr_T lnum));
 static void checkupdate __ARGS((win_T *wp));
-static void setFoldRepeat __ARGS((linenr_T lnum, long count, int open));
+static void setFoldRepeat __ARGS((linenr_T lnum, long count, int do_open));
 static linenr_T setManualFold __ARGS((linenr_T lnum, int opening, int recurse, int *donep));
 static linenr_T setManualFoldWin __ARGS((win_T *wp, linenr_T lnum, int opening, int recurse, int *donep));
 static void foldOpenNested __ARGS((fold_T *fpr));
 static void deleteFoldEntry __ARGS((garray_T *gap, int idx, int recursive));
 static void foldMarkAdjustRecurse __ARGS((garray_T *gap, linenr_T line1, linenr_T line2, long amount, long amount_after));
@@ -738,11 +738,11 @@ deleteFold(start, end, recursive, had_vi
     garray_T	*gap;
     fold_T	*fp;
     garray_T	*found_ga;
     fold_T	*found_fp = NULL;
     linenr_T	found_off = 0;
-    int		use_level = FALSE;
+    int		use_level;
     int		maybe_small = FALSE;
     int		level = 0;
     linenr_T	lnum = start;
     linenr_T	lnum_off;
     int		did_one = FALSE;
@@ -755,10 +755,11 @@ deleteFold(start, end, recursive, had_vi
     {
 	/* Find the deepest fold for "start". */
 	gap = &curwin->w_folds;
 	found_ga = NULL;
 	lnum_off = 0;
+	use_level = FALSE;
 	for (;;)
 	{
 	    if (!foldFind(gap, lnum - lnum_off, &fp))
 		break;
 	    /* lnum is inside this fold, remember info */
@@ -781,24 +782,25 @@ deleteFold(start, end, recursive, had_vi
 	    ++lnum;
 	}
 	else
 	{
 	    lnum = found_fp->fd_top + found_fp->fd_len + found_off;
-	    did_one = TRUE;
 
 	    if (foldmethodIsManual(curwin))
 		deleteFoldEntry(found_ga,
 		    (int)(found_fp - (fold_T *)found_ga->ga_data), recursive);
 	    else
 	    {
-		if (found_fp->fd_top + found_off < first_lnum)
-		    first_lnum = found_fp->fd_top;
-		if (lnum > last_lnum)
+		if (first_lnum > found_fp->fd_top + found_off)
+		    first_lnum = found_fp->fd_top + found_off;
+		if (last_lnum < lnum)
 		    last_lnum = lnum;
-		parseMarker(curwin);
+		if (!did_one)
+		    parseMarker(curwin);
 		deleteFoldMarkers(found_fp, recursive, found_off);
 	    }
+	    did_one = TRUE;
 
 	    /* redraw window */
 	    changed_window_setting();
 	}
     }
@@ -809,10 +811,14 @@ deleteFold(start, end, recursive, had_vi
 	/* Force a redraw to remove the Visual highlighting. */
 	if (had_visual)
 	    redraw_curbuf_later(INVERTED);
 #endif
     }
+    else
+	/* Deleting markers may make cursor column invalid. */
+	check_cursor_col();
+
     if (last_lnum > 0)
 	changed_lines(first_lnum, (colnr_T)0, last_lnum, 0L);
 }
 
 /* clearFolding() {{{2 */
@@ -841,11 +847,11 @@ foldUpdate(wp, top, bot)
     linenr_T	bot;
 {
     fold_T	*fp;
 
     /* Mark all folds from top to bot as maybe-small. */
-    (void)foldFind(&curwin->w_folds, curwin->w_cursor.lnum, &fp);
+    (void)foldFind(&curwin->w_folds, top, &fp);
     while (fp < (fold_T *)curwin->w_folds.ga_data + curwin->w_folds.ga_len
 	    && fp->fd_top < bot)
     {
 	fp->fd_small = MAYBE;
 	++fp;
@@ -1239,22 +1245,22 @@ checkupdate(wp)
 /*
  * Open or close fold for current window at line "lnum".
  * Repeat "count" times.
  */
     static void
-setFoldRepeat(lnum, count, open)
+setFoldRepeat(lnum, count, do_open)
     linenr_T	lnum;
     long	count;
-    int		open;
+    int		do_open;
 {
     int		done;
     long	n;
 
     for (n = 0; n < count; ++n)
     {
 	done = DONE_NOTHING;
-	(void)setManualFold(lnum, open, FALSE, &done);
+	(void)setManualFold(lnum, do_open, FALSE, &done);
 	if (!(done & DONE_ACTION))
 	{
 	    /* Only give an error message when no fold could be opened. */
 	    if (n == 0 && !(done & DONE_FOLD))
 		EMSG(_(e_nofold));
@@ -1599,15 +1605,15 @@ foldMarkAdjustRecurse(gap, line1, line2,
 		else
 		    fp->fd_top += amount;
 	    }
 	    else
 	    {
-		/* 2, 3, or 5: need to correct nested folds too */
-		foldMarkAdjustRecurse(&fp->fd_nested, line1 - fp->fd_top,
-				  line2 - fp->fd_top, amount, amount_after);
 		if (fp->fd_top < top)
 		{
+		    /* 2 or 3: need to correct nested folds too */
+		    foldMarkAdjustRecurse(&fp->fd_nested, line1 - fp->fd_top,
+				  line2 - fp->fd_top, amount, amount_after);
 		    if (last <= line2)
 		    {
 			/* 2. fold contains line1, line2 is below fold */
 			if (amount == MAXLNUM)
 			    fp->fd_len = line1 - fp->fd_top;
@@ -1620,11 +1626,15 @@ foldMarkAdjustRecurse(gap, line1, line2,
 			fp->fd_len += amount_after;
 		    }
 		}
 		else
 		{
-		    /* 5. fold is below line1 and contains line2 */
+		    /* 5. fold is below line1 and contains line2; need to
+		     * correct nested folds too */
+		    foldMarkAdjustRecurse(&fp->fd_nested, line1 - fp->fd_top,
+				  line2 - fp->fd_top, amount,
+				  amount_after + (fp->fd_top - top));
 		    if (amount == MAXLNUM)
 		    {
 			fp->fd_len -= line2 - fp->fd_top + 1;
 			fp->fd_top = line1;
 		    }
@@ -1920,11 +1930,11 @@ get_foldtext(wp, lnum, lnume, foldinfo,
     char_u	*text = NULL;
 
 #ifdef FEAT_EVAL
     if (*wp->w_p_fdt != NUL)
     {
-	char_u	dashes[51];
+	char_u	dashes[MAX_LEVEL + 2];
 	win_T	*save_curwin;
 	int	level;
 	char_u	*p;
 
 	/* Set "v:foldstart" and "v:foldend". */
@@ -1932,12 +1942,12 @@ get_foldtext(wp, lnum, lnume, foldinfo,
 	set_vim_var_nr(VV_FOLDEND, lnume);
 
 	/* Set "v:folddashes" to a string of "level" dashes. */
 	/* Set "v:foldlevel" to "level". */
 	level = foldinfo->fi_level;
-	if (level > 50)
-	    level = 50;
+	if (level > (int)sizeof(dashes) - 1)
+	    level = (int)sizeof(dashes) - 1;
 	vim_memset(dashes, '-', (size_t)level);
 	dashes[level] = NUL;
 	set_vim_var_string(VV_FOLDDASHES, dashes, -1);
 	set_vim_var_nr(VV_FOLDLEVEL, (long)level);
 	save_curwin = curwin;
@@ -2244,10 +2254,44 @@ foldUpdateIEMS(wp, top, bot)
 	    if (fline.lvl >= 0)
 		break;
 	}
     }
 
+    /*
+     * If folding is defined by the syntax, it is possible that a change in
+     * one line will cause all sub-folds of the current fold to change (e.g.,
+     * closing a C-style comment can cause folds in the subsequent lines to
+     * appear). To take that into account we should adjust the value of "bot"
+     * to point to the end of the current fold:
+     */
+    if (foldlevelSyntax == getlevel)
+    {
+	garray_T *gap = &wp->w_folds;
+	fold_T	 *fp = NULL;
+	int	  current_fdl = 0;
+	linenr_T  fold_start_lnum = 0;
+	linenr_T  lnum_rel = fline.lnum;
+
+	while (current_fdl < fline.lvl)
+	{
+	    if (!foldFind(gap, lnum_rel, &fp))
+		break;
+	    ++current_fdl;
+
+	    fold_start_lnum += fp->fd_top;
+	    gap = &fp->fd_nested;
+	    lnum_rel -= fp->fd_top;
+	}
+	if (fp != NULL && current_fdl == fline.lvl)
+	{
+	    linenr_T fold_end_lnum = fold_start_lnum + fp->fd_len;
+
+	    if (fold_end_lnum > bot)
+		bot = fold_end_lnum;
+	}
+    }
+
     start = fline.lnum;
     end = bot;
     /* Do at least one line. */
     if (start > end && end < wp->w_buffer->b_ml.ml_line_count)
 	end = start;
@@ -2805,10 +2849,12 @@ foldSplit(gap, i, top, bot)
 	return;
     fp = (fold_T *)gap->ga_data + i;
     fp[1].fd_top = bot + 1;
     fp[1].fd_len = fp->fd_len - (fp[1].fd_top - fp->fd_top);
     fp[1].fd_flags = fp->fd_flags;
+    fp[1].fd_small = MAYBE;
+    fp->fd_small = MAYBE;
 
     /* Move nested folds below bot to new fold.  There can't be
      * any between top and bot, they have been removed by the caller. */
     gap1 = &fp->fd_nested;
     gap2 = &fp[1].fd_nested;
@@ -3191,12 +3237,12 @@ foldlevelMarker(flp)
 		if (n > 0)
 		{
 		    flp->lvl = n;
 		    flp->lvl_next = n - 1;
 		    /* never start a fold with an end marker */
-		    if (flp->lvl_next > flp->lvl)
-			flp->lvl_next = flp->lvl;
+		    if (flp->lvl_next > start_lvl)
+			flp->lvl_next = start_lvl;
 		}
 	    }
 	    else
 		--flp->lvl_next;
 	}
--- vim72.orig/src/gui.c
+++ vim72/src/gui.c
@@ -137,11 +137,11 @@ gui_start()
 	    else
 	    {
 		/* The read returns when the child closes the pipe (or when
 		 * the child dies for some reason). */
 		close(pipefd[1]);
-		(void)read(pipefd[0], &dummy, (size_t)1);
+		ignored = (int)read(pipefd[0], &dummy, (size_t)1);
 		close(pipefd[0]);
 	    }
 
 	    /* When swapping screens we may need to go to the next line, e.g.,
 	     * after a hit-enter prompt and using ":gui". */
@@ -676,15 +676,14 @@ gui_shell_closed()
  * font.
  * If "fontset" is TRUE, the "font_list" is used as one name for the fontset.
  * Return OK when able to set the font.  When it failed FAIL is returned and
  * the fonts are unchanged.
  */
-/*ARGSUSED*/
     int
 gui_init_font(font_list, fontset)
     char_u	*font_list;
-    int		fontset;
+    int		fontset UNUSED;
 {
 #define FONTLEN 320
     char_u	font_name[FONTLEN];
     int		font_list_empty = FALSE;
     int		ret = FAIL;
@@ -958,11 +957,11 @@ gui_update_cursor(force, clear_selection
 	    {
 		static int iid;
 		guicolor_T fg, bg;
 
 		if (
-# ifdef HAVE_GTK2
+# if defined(HAVE_GTK2) && !defined(FEAT_HANGULIN)
 			preedit_get_status()
 # else
 			im_get_status()
 # endif
 			)
@@ -1136,14 +1135,13 @@ gui_position_menu()
 
 /*
  * Position the various GUI components (text area, menu).  The vertical
  * scrollbars are NOT handled here.  See gui_update_scrollbars().
  */
-/*ARGSUSED*/
     static void
 gui_position_components(total_width)
-    int	    total_width;
+    int	    total_width UNUSED;
 {
     int	    text_area_x;
     int	    text_area_y;
     int	    text_area_width;
     int	    text_area_height;
@@ -1372,14 +1370,13 @@ gui_get_shellsize()
 /*
  * Set the size of the Vim shell according to Rows and Columns.
  * If "fit_to_display" is TRUE then the size may be reduced to fit the window
  * on the screen.
  */
-/*ARGSUSED*/
     void
 gui_set_shellsize(mustset, fit_to_display, direction)
-    int		mustset;		/* set by the user */
+    int		mustset UNUSED;		/* set by the user */
     int		fit_to_display;
     int		direction;		/* RESIZE_HOR, RESIZE_VER */
 {
     int		base_width;
     int		base_height;
@@ -1387,10 +1384,15 @@ gui_set_shellsize(mustset, fit_to_displa
     int		height;
     int		min_width;
     int		min_height;
     int		screen_w;
     int		screen_h;
+#ifdef HAVE_GTK2
+    int		un_maximize = mustset;
+    int         did_adjust = 0;
+#endif
+    int		x = -1, y = -1;
 
     if (!gui.shell_created)
 	return;
 
 #ifdef MSWIN
@@ -1403,10 +1405,14 @@ gui_set_shellsize(mustset, fit_to_displa
     }
 #endif
 
     base_width = gui_get_base_width();
     base_height = gui_get_base_height();
+    if (fit_to_display)
+	/* Remember the original window position. */
+	gui_mch_get_winpos(&x, &y);
+
 #ifdef USE_SUN_WORKSHOP
     if (!mustset && usingSunWorkShop
 				&& workshop_get_width_height(&width, &height))
     {
 	Columns = (width - base_width + gui.char_width - 1) / gui.char_width;
@@ -1426,34 +1432,60 @@ gui_set_shellsize(mustset, fit_to_displa
 	{
 	    Columns = (screen_w - base_width) / gui.char_width;
 	    if (Columns < MIN_COLUMNS)
 		Columns = MIN_COLUMNS;
 	    width = Columns * gui.char_width + base_width;
+#ifdef HAVE_GTK2
+	    ++did_adjust;
+#endif
 	}
 	if ((direction & RESIZE_VERT) && height > screen_h)
 	{
 	    Rows = (screen_h - base_height) / gui.char_height;
 	    check_shellsize();
 	    height = Rows * gui.char_height + base_height;
+#ifdef HAVE_GTK2
+	    ++did_adjust;
+#endif
 	}
+#ifdef HAVE_GTK2
+	if (did_adjust == 2 || (width + gui.char_width >= screen_w
+				     && height + gui.char_height >= screen_h))
+	    /* don't unmaximize if at maximum size */
+	    un_maximize = FALSE;
+#endif
     }
     gui.num_cols = Columns;
     gui.num_rows = Rows;
 
     min_width = base_width + MIN_COLUMNS * gui.char_width;
     min_height = base_height + MIN_LINES * gui.char_height;
-# ifdef FEAT_WINDOWS
+#ifdef FEAT_WINDOWS
     min_height += tabline_height() * gui.char_height;
-# endif
+#endif
+
+#ifdef HAVE_GTK2
+    if (un_maximize)
+    {
+	/* If the window size is smaller than the screen unmaximize the
+	 * window, otherwise resizing won't work. */
+	gui_mch_get_screen_dimensions(&screen_w, &screen_h);
+	if ((width + gui.char_width < screen_w
+				   || height + gui.char_height * 2 < screen_h)
+		&& gui_mch_maximized())
+	    gui_mch_unmaximize();
+    }
+#endif
 
     gui_mch_set_shellsize(width, height, min_width, min_height,
 					  base_width, base_height, direction);
-    if (fit_to_display)
-    {
-	int	    x, y;
 
-	/* Some window managers put the Vim window left of/above the screen. */
+    if (fit_to_display && x >= 0 && y >= 0)
+    {
+	/* Some window managers put the Vim window left of/above the screen.
+	 * Only change the position if it wasn't already negative before
+	 * (happens on MS-Windows with a secondary monitor). */
 	gui_mch_update();
 	if (gui_mch_get_winpos(&x, &y) == OK && (x < 0 || y < 0))
 	    gui_mch_set_winpos(x < 0 ? 0 : x, y < 0 ? 0 : y);
     }
 
@@ -3118,14 +3150,13 @@ static int	prev_which_scrollbars[3];
 /*
  * Set which components are present.
  * If "oldval" is not NULL, "oldval" is the previous value, the new value is
  * in p_go.
  */
-/*ARGSUSED*/
     void
 gui_init_which_components(oldval)
-    char_u	*oldval;
+    char_u	*oldval UNUSED;
 {
 #ifdef FEAT_MENU
     static int	prev_menu_is_active = -1;
 #endif
 #ifdef FEAT_TOOLBAR
@@ -3239,11 +3270,11 @@ gui_init_which_components(oldval)
 	    /* We don't want a resize event change "Rows" here, save and
 	     * restore it.  Resizing is handled below. */
 	    i = Rows;
 	    gui_update_tabline();
 	    Rows = i;
-	    need_set_size = RESIZE_VERT;
+	    need_set_size |= RESIZE_VERT;
 	    if (using_tabline)
 		fix_size = TRUE;
 	    if (!gui_use_tabline())
 		redraw_tabline = TRUE;    /* may draw non-GUI tab line */
 	}
@@ -3273,13 +3304,13 @@ gui_init_which_components(oldval)
 		    }
 		}
 		if (gui.which_scrollbars[i] != prev_which_scrollbars[i])
 		{
 		    if (i == SBAR_BOTTOM)
-			need_set_size = RESIZE_VERT;
+			need_set_size |= RESIZE_VERT;
 		    else
-			need_set_size = RESIZE_HOR;
+			need_set_size |= RESIZE_HOR;
 		    if (gui.which_scrollbars[i])
 			fix_size = TRUE;
 		}
 	    }
 #ifdef FEAT_WINDOWS
@@ -3295,32 +3326,32 @@ gui_init_which_components(oldval)
 	     * restore it.  Resizing is handled below. */
 	    i = Rows;
 	    gui_mch_enable_menu(gui.menu_is_active);
 	    Rows = i;
 	    prev_menu_is_active = gui.menu_is_active;
-	    need_set_size = RESIZE_VERT;
+	    need_set_size |= RESIZE_VERT;
 	    if (gui.menu_is_active)
 		fix_size = TRUE;
 	}
 #endif
 
 #ifdef FEAT_TOOLBAR
 	if (using_toolbar != prev_toolbar)
 	{
 	    gui_mch_show_toolbar(using_toolbar);
 	    prev_toolbar = using_toolbar;
-	    need_set_size = RESIZE_VERT;
+	    need_set_size |= RESIZE_VERT;
 	    if (using_toolbar)
 		fix_size = TRUE;
 	}
 #endif
 #ifdef FEAT_FOOTER
 	if (using_footer != prev_footer)
 	{
 	    gui_mch_enable_footer(using_footer);
 	    prev_footer = using_footer;
-	    need_set_size = RESIZE_VERT;
+	    need_set_size |= RESIZE_VERT;
 	    if (using_footer)
 		fix_size = TRUE;
 	}
 #endif
 #if defined(FEAT_MENU) && !defined(WIN16) && !(defined(WIN3264) && !defined(FEAT_TEAROFF))
@@ -3328,14 +3359,15 @@ gui_init_which_components(oldval)
 	{
 	    gui_mch_toggle_tearoffs(using_tearoff);
 	    prev_tearoff = using_tearoff;
 	}
 #endif
-	if (need_set_size)
+	if (need_set_size != 0)
 	{
 #ifdef FEAT_GUI_GTK
-	    long    c = Columns;
+	    long    prev_Columns = Columns;
+	    long    prev_Rows = Rows;
 #endif
 	    /* Adjust the size of the window to make the text area keep the
 	     * same size and to avoid that part of our window is off-screen
 	     * and a scrollbar can't be used, for example. */
 	    gui_set_shellsize(FALSE, fix_size, need_set_size);
@@ -3347,15 +3379,18 @@ gui_init_which_components(oldval)
 	     * change Columns and Rows when we don't want it.  Wait for a
 	     * character here to avoid this effect.
 	     * If you remove this, please test this command for resizing
 	     * effects (with optional left scrollbar): ":vsp|q|vsp|q|vsp|q".
 	     * Don't do this while starting up though.
-	     * And don't change Rows, it may have be reduced intentionally
-	     * when adding menu/toolbar/tabline. */
-	    if (!gui.starting)
+	     * Don't change Rows when adding menu/toolbar/tabline.
+	     * Don't change Columns when adding vertical toolbar. */
+	    if (!gui.starting && need_set_size != (RESIZE_VERT | RESIZE_HOR))
 		(void)char_avail();
-	    Columns = c;
+	    if ((need_set_size & RESIZE_VERT) == 0)
+		Rows = prev_Rows;
+	    if ((need_set_size & RESIZE_HOR) == 0)
+		Columns = prev_Columns;
 #endif
 	}
 #ifdef FEAT_WINDOWS
 	/* When the console tabline appears or disappears the window positions
 	 * change. */
@@ -3877,10 +3912,25 @@ gui_drag_scrollbar(sb, value, still_drag
 
 /*
  * Scrollbar stuff:
  */
 
+/*
+ * Called when something in the window layout has changed.
+ */
+    void
+gui_may_update_scrollbars()
+{
+    if (gui.in_use && starting == 0)
+    {
+	out_flush();
+	gui_init_which_components(NULL);
+	gui_update_scrollbars(TRUE);
+    }
+    need_mouse_correct = TRUE;
+}
+
     void
 gui_update_scrollbars(force)
     int		force;	    /* Force all scrollbars to get updated */
 {
     win_T	*wp;
@@ -4405,11 +4455,11 @@ gui_do_horiz_scroll()
 {
     /* no wrapping, no scrolling */
     if (curwin->w_p_wrap)
 	return FALSE;
 
-    if (curwin->w_leftcol == scrollbar_value)
+    if ((long_u)curwin->w_leftcol == scrollbar_value)
 	return FALSE;
 
     curwin->w_leftcol = (colnr_T)scrollbar_value;
 
     /* When the line of the cursor is too short, move the cursor to the
@@ -4418,11 +4468,11 @@ gui_do_horiz_scroll()
     if (vim_strchr(p_go, GO_HORSCROLL) == NULL
 	    && longest_lnum >= curwin->w_topline
 	    && longest_lnum < curwin->w_botline
 	    && !virtual_active())
     {
-	if (scrollbar_value > scroll_line_len(curwin->w_cursor.lnum))
+	if (scrollbar_value > (long_u)scroll_line_len(curwin->w_cursor.lnum))
 	{
 	    curwin->w_cursor.lnum = longest_lnum;
 	    curwin->w_cursor.col = 0;
 	}
     }
@@ -4664,15 +4714,14 @@ gui_mouse_correct()
 }
 
 /*
  * Find window where the mouse pointer "y" coordinate is in.
  */
-/*ARGSUSED*/
     static win_T *
 xy2win(x, y)
-    int		x;
-    int		y;
+    int		x UNUSED;
+    int		y UNUSED;
 {
 #ifdef FEAT_WINDOWS
     int		row;
     int		col;
     win_T	*wp;
@@ -4988,10 +5037,23 @@ gui_do_findrepl(flags, find_text, repl_t
     int		i;
     int		type = (flags & FRD_TYPE_MASK);
     char_u	*p;
     regmatch_T	regmatch;
     int		save_did_emsg = did_emsg;
+    static int  busy = FALSE;
+
+    /* When the screen is being updated we should not change buffers and
+     * windows structures, it may cause freed memory to be used.  Also don't
+     * do this recursively (pressing "Find" quickly several times. */
+    if (updating_screen || busy)
+	return FALSE;
+
+    /* refuse replace when text cannot be changed */
+    if ((type == FRD_REPLACE || type == FRD_REPLACEALL) && text_locked())
+	return FALSE;
+
+    busy = TRUE;
 
     ga_init2(&ga, 1, 100);
     if (type == FRD_REPLACEALL)
 	ga_concat(&ga, (char_u *)"%s/");
 
@@ -5078,10 +5140,11 @@ gui_do_findrepl(flags, find_text, repl_t
 	msg_didout = 0;			/* overwrite any message */
 	need_wait_return = FALSE;	/* don't wait for return */
     }
 
     vim_free(ga.ga_data);
+    busy = FALSE;
     return (ga.ga_len > 0);
 }
 
 #endif
 
@@ -5118,15 +5181,14 @@ gui_wingoto_xy(x, y)
  * Process file drop.  Mouse cursor position, key modifiers, name of files
  * and count of files are given.  Argument "fnames[count]" has full pathnames
  * of dropped files, they will be freed in this function, and caller can't use
  * fnames after call this function.
  */
-/*ARGSUSED*/
     void
 gui_handle_drop(x, y, modifiers, fnames, count)
-    int		x;
-    int		y;
+    int		x UNUSED;
+    int		y UNUSED;
     int_u	modifiers;
     char_u	**fnames;
     int		count;
 {
     int		i;
--- vim72.orig/src/gui_at_sb.c
+++ vim72/src/gui_at_sb.c
@@ -196,14 +196,17 @@ ScrollbarClassRec vim_scrollbarClassRec
     /* query_geometry	*/  XtInheritQueryGeometry,
     /* display_accelerator*/	XtInheritDisplayAccelerator,
     /* extension	*/  NULL
   },
   { /* simple fields */
-    /* change_sensitive	*/  XtInheritChangeSensitive
+    /* change_sensitive	*/  XtInheritChangeSensitive,
+#ifndef OLDXAW
+    /* extension */	    NULL
+#endif
   },
   { /* scrollbar fields */
-    /* ignore	    */	0
+    /* empty	    */	    0
   }
 };
 
 WidgetClass vim_scrollbarWidgetClass = (WidgetClass)&vim_scrollbarClassRec;
 
@@ -239,11 +242,12 @@ FillArea(sbw, top, bottom, fill, draw_sh
     int sw, margin, floor;
     int lx, ly, lw, lh;
 
     if (bottom <= 0 || bottom <= top)
 	return;
-    if ((sw = sbw->scrollbar.shadow_width) < 0)
+    sw = sbw->scrollbar.shadow_width;
+    if (sw < 0)
 	sw = 0;
     margin = MARGIN (sbw);
     floor = sbw->scrollbar.length - margin + 2;
 
     if (sbw->scrollbar.orientation == XtorientHorizontal)
@@ -514,17 +518,16 @@ SetDimensions(sbw)
 	sbw->scrollbar.length = sbw->core.width;
 	sbw->scrollbar.thickness = sbw->core.height;
     }
 }
 
-/* ARGSUSED */
     static void
 Initialize(request, new, args, num_args)
-    Widget	request;	/* what the client asked for */
+    Widget	request UNUSED;	/* what the client asked for */
     Widget	new;		/* what we're going to give him */
-    ArgList	args;
-    Cardinal	*num_args;
+    ArgList	args UNUSED;
+    Cardinal	*num_args UNUSED;
 {
     ScrollbarWidget sbw = (ScrollbarWidget) new;
 
     CreateGC(new);
     AllocTopShadowGC(new);
@@ -554,18 +557,17 @@ Realize(w, valueMask, attributes)
     /* The Simple widget actually stuffs the value in the valuemask. */
     (*vim_scrollbarWidgetClass->core_class.superclass->core_class.realize)
 	(w, valueMask, attributes);
 }
 
-/* ARGSUSED */
     static Boolean
 SetValues(current, request, desired, args, num_args)
-    Widget  current,	    /* what I am */
-	    request,	    /* what he wants me to be */
-	    desired;	    /* what I will become */
-    ArgList args;
-    Cardinal *num_args;
+    Widget  current;	    /* what I am */
+    Widget  request UNUSED; /* what he wants me to be */
+    Widget  desired;	    /* what I will become */
+    ArgList args UNUSED;
+    Cardinal *num_args UNUSED;
 {
     ScrollbarWidget	sbw = (ScrollbarWidget) current;
     ScrollbarWidget	dsbw = (ScrollbarWidget) desired;
     Boolean		redraw = FALSE;
 
@@ -607,11 +609,10 @@ Resize(w)
     SetDimensions ((ScrollbarWidget) w);
     Redisplay(w, (XEvent*) NULL, (Region)NULL);
 }
 
 
-/* ARGSUSED */
     static void
 Redisplay(w, event, region)
     Widget w;
     XEvent *event;
     Region region;
@@ -787,15 +788,14 @@ HandleThumb(w, event, params, num_params
 	XtCallActionProc(w, "MoveThumb", event, params, *num_params);
 	XtCallActionProc(w, "NotifyThumb", event, params, *num_params);
     }
 }
 
-/* ARGSUSED */
     static void
 RepeatNotify(client_data, idp)
     XtPointer client_data;
-    XtIntervalId *idp;
+    XtIntervalId *idp UNUSED;
 {
     ScrollbarWidget sbw = (ScrollbarWidget) client_data;
     int		    call_data;
     char	    mode = sbw->scrollbar.scroll_mode;
     unsigned long   rep;
@@ -837,50 +837,46 @@ FloatInRange(num, small, big)
     float num, small, big;
 {
     return (num < small) ? small : ((num > big) ? big : num);
 }
 
-/* ARGSUSED */
     static void
 ScrollOneLineUp(w, event, params, num_params)
     Widget	w;
     XEvent	*event;
-    String	*params;
-    Cardinal	*num_params;
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
     ScrollSome(w, event, -ONE_LINE_DATA);
 }
 
-/* ARGSUSED */
     static void
 ScrollOneLineDown(w, event, params, num_params)
     Widget	w;
     XEvent	*event;
-    String	*params;
-    Cardinal	*num_params;
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
     ScrollSome(w, event, ONE_LINE_DATA);
 }
 
-/* ARGSUSED */
     static void
 ScrollPageDown(w, event, params, num_params)
     Widget	w;
     XEvent	*event;
-    String	*params;
-    Cardinal	*num_params;
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
     ScrollSome(w, event, ONE_PAGE_DATA);
 }
 
-/* ARGSUSED */
     static void
 ScrollPageUp(w, event, params, num_params)
     Widget	w;
     XEvent	*event;
-    String	*params;
-    Cardinal	*num_params;
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
     ScrollSome(w, event, -ONE_PAGE_DATA);
 }
 
     static void
@@ -899,17 +895,16 @@ ScrollSome(w, event, call_data)
 
     sbw->scrollbar.scroll_mode = SMODE_LINE_UP;
     XtCallCallbacks(w, XtNscrollProc, (XtPointer)call_data);
 }
 
-/* ARGSUSED */
     static void
 NotifyScroll(w, event, params, num_params)
     Widget	w;
     XEvent	*event;
-    String	*params;
-    Cardinal	*num_params;
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
     ScrollbarWidget sbw = (ScrollbarWidget) w;
     Position	    x, y, loc;
     Dimension	    arrow_size;
     unsigned long   delay = 0;
@@ -989,17 +984,16 @@ NotifyScroll(w, event, params, num_param
 	sbw->scrollbar.timer_id =
 	    XtAppAddTimeOut(XtWidgetToApplicationContext(w),
 					   delay, RepeatNotify, (XtPointer)w);
 }
 
-/* ARGSUSED */
     static void
 EndScroll(w, event, params, num_params)
     Widget w;
-    XEvent *event;	/* unused */
-    String *params;	/* unused */
-    Cardinal *num_params;   /* unused */
+    XEvent *event UNUSED;
+    String *params UNUSED;
+    Cardinal *num_params UNUSED;
 {
     ScrollbarWidget sbw = (ScrollbarWidget) w;
 
     sbw->scrollbar.scroll_mode = SMODE_NONE;
     /* no need to remove any autoscroll timeout; it will no-op */
@@ -1021,17 +1015,16 @@ FractionLoc(sbw, x, y)
     height = (float)sbw->core.height - 2 * margin;
     width = (float)sbw->core.width - 2 * margin;
     return PICKLENGTH(sbw, x / width, y / height);
 }
 
-/* ARGSUSED */
     static void
 MoveThumb(w, event, params, num_params)
     Widget	w;
     XEvent	*event;
-    String	*params;	/* unused */
-    Cardinal	*num_params;	/* unused */
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
     ScrollbarWidget	sbw = (ScrollbarWidget)w;
     Position		x, y;
     float		top;
     char		old_mode = sbw->scrollbar.scroll_mode;
@@ -1067,31 +1060,36 @@ MoveThumb(w, event, params, num_params)
     PaintThumb(sbw);
     XFlush(XtDisplay(w));   /* re-draw it before Notifying */
 }
 
 
-/* ARGSUSED */
     static void
 NotifyThumb(w, event, params, num_params)
     Widget	w;
     XEvent	*event;
-    String	*params;	/* unused */
-    Cardinal	*num_params;	/* unused */
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
     ScrollbarWidget sbw = (ScrollbarWidget)w;
+    /* Use a union to avoid a warning for the weird conversion from float to
+     * XtPointer.  Comes from Xaw/Scrollbar.c. */
+    union {
+	XtPointer xtp;
+	float xtf;
+    } xtpf;
 
     if (LookAhead(w, event))
 	return;
 
     /* thumbProc is not pretty, but is necessary for backwards
        compatibility on those architectures for which it work{s,ed};
        the intent is to pass a (truncated) float by value. */
-    XtCallCallbacks(w, XtNthumbProc, *(XtPointer*)&sbw->scrollbar.top);
+    xtpf.xtf = sbw->scrollbar.top;
+    XtCallCallbacks(w, XtNthumbProc, xtpf.xtp);
     XtCallCallbacks(w, XtNjumpProc, (XtPointer)&sbw->scrollbar.top);
 }
 
-/* ARGSUSED */
     static void
 AllocTopShadowGC(w)
     Widget w;
 {
     ScrollbarWidget sbw = (ScrollbarWidget) w;
@@ -1101,11 +1099,10 @@ AllocTopShadowGC(w)
     valuemask = GCForeground;
     myXGCV.foreground = sbw->scrollbar.top_shadow_pixel;
     sbw->scrollbar.top_shadow_GC = XtGetGC(w, valuemask, &myXGCV);
 }
 
-/* ARGSUSED */
     static void
 AllocBotShadowGC(w)
     Widget w;
 {
     ScrollbarWidget sbw = (ScrollbarWidget) w;
@@ -1115,15 +1112,14 @@ AllocBotShadowGC(w)
     valuemask = GCForeground;
     myXGCV.foreground = sbw->scrollbar.bot_shadow_pixel;
     sbw->scrollbar.bot_shadow_GC = XtGetGC(w, valuemask, &myXGCV);
 }
 
-/* ARGSUSED */
     static void
 _Xaw3dDrawShadows(gw, event, region, out)
     Widget  gw;
-    XEvent  *event;
+    XEvent  *event UNUSED;
     Region  region;
     int	    out;
 {
     XPoint  pt[6];
     ScrollbarWidget sbw = (ScrollbarWidget) gw;
--- vim72.orig/src/gui_gtk_x11.c
+++ vim72/src/gui_gtk_x11.c
@@ -105,10 +105,11 @@ enum
 {
     TARGET_TYPE_NONE,
     TARGET_UTF8_STRING,
     TARGET_STRING,
     TARGET_COMPOUND_TEXT,
+    TARGET_HTML,
     TARGET_TEXT,
     TARGET_TEXT_URI_LIST,
     TARGET_TEXT_PLAIN,
     TARGET_VIM,
     TARGET_VIMENC
@@ -121,10 +122,11 @@ enum
 static const GtkTargetEntry selection_targets[] =
 {
     {VIMENC_ATOM_NAME,	0, TARGET_VIMENC},
     {VIM_ATOM_NAME,	0, TARGET_VIM},
 #ifdef FEAT_MBYTE
+    {"text/html",	0, TARGET_HTML},
     {"UTF8_STRING",	0, TARGET_UTF8_STRING},
 #endif
     {"COMPOUND_TEXT",	0, TARGET_COMPOUND_TEXT},
     {"TEXT",		0, TARGET_TEXT},
     {"STRING",		0, TARGET_STRING}
@@ -138,10 +140,11 @@ static const GtkTargetEntry selection_ta
  */
 static const GtkTargetEntry dnd_targets[] =
 {
     {"text/uri-list",	0, TARGET_TEXT_URI_LIST},
 # ifdef FEAT_MBYTE
+    {"text/html",	0, TARGET_HTML},
     {"UTF8_STRING",	0, TARGET_UTF8_STRING},
 # endif
     {"STRING",		0, TARGET_STRING},
     {"text/plain",	0, TARGET_TEXT_PLAIN}
 };
@@ -176,10 +179,11 @@ static GdkAtom save_yourself_atom = GDK_
 
 /*
  * Atoms used to control/reference X11 selections.
  */
 #ifdef FEAT_MBYTE
+static GdkAtom html_atom = GDK_NONE;
 static GdkAtom utf8_string_atom = GDK_NONE;
 #endif
 #ifndef HAVE_GTK2
 static GdkAtom compound_text_atom = GDK_NONE;
 static GdkAtom text_atom = GDK_NONE;
@@ -410,10 +414,11 @@ static char **gui_argv = NULL;
 #ifdef HAVE_GTK2
 static const char *role_argument = NULL;
 #endif
 #if defined(FEAT_GUI_GNOME) && defined(FEAT_SESSION)
 static const char *restart_command = NULL;
+static       char *abs_restart_command = NULL;
 #endif
 static int found_iconic_arg = FALSE;
 
 #ifdef FEAT_GUI_GNOME
 /*
@@ -447,12 +452,14 @@ gui_mch_prepare(int *argc, char **argv)
     if (strchr(argv[0], G_DIR_SEPARATOR) != NULL)
     {
 	char_u buf[MAXPATHL];
 
 	if (mch_FullName((char_u *)argv[0], buf, (int)sizeof(buf), TRUE) == OK)
-	    /* Tiny leak; doesn't matter, and usually we don't even get here */
-	    restart_command = (char *)vim_strsave(buf);
+	{
+	    abs_restart_command = (char *)vim_strsave(buf);
+	    restart_command = abs_restart_command;
+	}
     }
 #endif
 
     /*
      * Move all the entries in argv which are relevant to GTK+ and GNOME
@@ -609,21 +616,25 @@ gui_mch_prepare(int *argc, char **argv)
 #if defined(EXITFREE) || defined(PROTO)
     void
 gui_mch_free_all()
 {
     vim_free(gui_argv);
+#if defined(FEAT_GUI_GNOME) && defined(FEAT_SESSION)
+    vim_free(abs_restart_command);
+#endif
 }
 #endif
 
 /*
  * This should be maybe completely removed.
  * Doesn't seem possible, since check_copy_area() relies on
  * this information.  --danielk
  */
-/*ARGSUSED*/
     static gint
-visibility_event(GtkWidget *widget, GdkEventVisibility *event, gpointer data)
+visibility_event(GtkWidget *widget UNUSED,
+		 GdkEventVisibility *event,
+		 gpointer data UNUSED)
 {
     gui.visibility = event->state;
     /*
      * When we do an gdk_window_copy_area(), and the window is partially
      * obscured, we want to receive an event to tell us whether it worked
@@ -636,13 +647,14 @@ visibility_event(GtkWidget *widget, GdkE
 }
 
 /*
  * Redraw the corresponding portions of the screen.
  */
-/*ARGSUSED*/
     static gint
-expose_event(GtkWidget *widget, GdkEventExpose *event, gpointer data)
+expose_event(GtkWidget *widget UNUSED,
+	     GdkEventExpose *event,
+	     gpointer data UNUSED)
 {
     /* Skip this when the GUI isn't set up yet, will redraw later. */
     if (gui.starting)
 	return FALSE;
 
@@ -666,13 +678,14 @@ expose_event(GtkWidget *widget, GdkEvent
 
 #ifdef FEAT_CLIENTSERVER
 /*
  * Handle changes to the "Comm" property
  */
-/*ARGSUSED2*/
     static gint
-property_event(GtkWidget *widget, GdkEventProperty *event, gpointer data)
+property_event(GtkWidget *widget,
+	       GdkEventProperty *event,
+	       gpointer data UNUSED)
 {
     if (event->type == GDK_PROPERTY_NOTIFY
 	    && event->state == (int)GDK_PROPERTY_NEW_VALUE
 	    && GDK_WINDOW_XWINDOW(event->window) == commWindow
 	    && GET_X_ATOM(event->atom) == commProperty)
@@ -738,13 +751,12 @@ gui_mch_stop_blink(void)
     if (blink_state == BLINK_OFF)
 	gui_update_cursor(TRUE, FALSE);
     blink_state = BLINK_NONE;
 }
 
-/*ARGSUSED*/
     static gint
-blink_cb(gpointer data)
+blink_cb(gpointer data UNUSED)
 {
     if (blink_state == BLINK_ON)
     {
 	gui_undraw_cursor();
 	blink_state = BLINK_OFF;
@@ -779,13 +791,14 @@ gui_mch_start_blink(void)
 	blink_state = BLINK_ON;
 	gui_update_cursor(TRUE, FALSE);
     }
 }
 
-/*ARGSUSED*/
     static gint
-enter_notify_event(GtkWidget *widget, GdkEventCrossing *event, gpointer data)
+enter_notify_event(GtkWidget *widget UNUSED,
+		   GdkEventCrossing *event UNUSED,
+		   gpointer data UNUSED)
 {
     if (blink_state == BLINK_NONE)
 	gui_mch_start_blink();
 
     /* make sure keyboard input goes there */
@@ -793,23 +806,25 @@ enter_notify_event(GtkWidget *widget, Gd
 	gtk_widget_grab_focus(gui.drawarea);
 
     return FALSE;
 }
 
-/*ARGSUSED*/
     static gint
-leave_notify_event(GtkWidget *widget, GdkEventCrossing *event, gpointer data)
+leave_notify_event(GtkWidget *widget UNUSED,
+		   GdkEventCrossing *event UNUSED,
+		   gpointer data UNUSED)
 {
     if (blink_state != BLINK_NONE)
 	gui_mch_stop_blink();
 
     return FALSE;
 }
 
-/*ARGSUSED*/
     static gint
-focus_in_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)
+focus_in_event(GtkWidget *widget,
+	       GdkEventFocus *event UNUSED,
+	       gpointer data UNUSED)
 {
     gui_focus_change(TRUE);
 
     if (blink_state == BLINK_NONE)
 	gui_mch_start_blink();
@@ -824,13 +839,14 @@ focus_in_event(GtkWidget *widget, GdkEve
 	gtk_main_quit();
 
     return TRUE;
 }
 
-/*ARGSUSED*/
     static gint
-focus_out_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)
+focus_out_event(GtkWidget *widget UNUSED,
+	        GdkEventFocus *event UNUSED,
+		gpointer data UNUSED)
 {
     gui_focus_change(FALSE);
 
     if (blink_state != BLINK_NONE)
 	gui_mch_stop_blink();
@@ -954,13 +970,14 @@ modifiers_gdk2mouse(guint state)
 }
 
 /*
  * Main keyboard handler:
  */
-/*ARGSUSED*/
     static gint
-key_press_event(GtkWidget *widget, GdkEventKey *event, gpointer data)
+key_press_event(GtkWidget *widget UNUSED,
+		GdkEventKey *event,
+		gpointer data UNUSED)
 {
 #ifdef HAVE_GTK2
     /* 256 bytes is way over the top, but for safety let's reduce it only
      * for GTK+ 2 where we know for sure how large the string might get.
      * (That is, up to 6 bytes + NUL + CSI escapes + safety measure.) */
@@ -1223,13 +1240,14 @@ key_press_event(GtkWidget *widget, GdkEv
 
     return TRUE;
 }
 
 #if defined(FEAT_XIM) && defined(HAVE_GTK2)
-/*ARGSUSED0*/
     static gboolean
-key_release_event(GtkWidget *widget, GdkEventKey *event, gpointer data)
+key_release_event(GtkWidget *widget UNUSED,
+		  GdkEventKey *event,
+		  gpointer data UNUSED)
 {
     /*
      * GTK+ 2 input methods may do fancy stuff on key release events too.
      * With the default IM for instance, you can enter any UCS code point
      * by holding down CTRL-SHIFT and typing hexadecimal digits.
@@ -1241,15 +1259,14 @@ key_release_event(GtkWidget *widget, Gdk
 
 /****************************************************************************
  * Selection handlers:
  */
 
-/*ARGSUSED*/
     static gint
-selection_clear_event(GtkWidget		*widget,
+selection_clear_event(GtkWidget		*widget UNUSED,
 		      GdkEventSelection	*event,
-		      gpointer		user_data)
+		      gpointer		user_data UNUSED)
 {
     if (event->selection == clip_plus.gtk_sel_atom)
 	clip_lose_selection(&clip_plus);
     else
 	clip_lose_selection(&clip_star);
@@ -1263,16 +1280,15 @@ selection_clear_event(GtkWidget		*widget
 #define RS_NONE	0	/* selection_received_cb() not called yet */
 #define RS_OK	1	/* selection_received_cb() called and OK */
 #define RS_FAIL	2	/* selection_received_cb() called and failed */
 static int received_selection = RS_NONE;
 
-/*ARGSUSED*/
     static void
-selection_received_cb(GtkWidget		*widget,
+selection_received_cb(GtkWidget		*widget UNUSED,
 		      GtkSelectionData	*data,
-		      guint		time_,
-		      gpointer		user_data)
+		      guint		time_ UNUSED,
+		      gpointer		user_data UNUSED)
 {
     VimClipboard    *cbd;
     char_u	    *text;
     char_u	    *tmpbuf = NULL;
 #ifdef HAVE_GTK2
@@ -1350,10 +1366,28 @@ selection_received_cb(GtkWidget		*widget
 		    text = tmpbuf;
 	    }
 	    else
 		text = tmpbuf_utf8;
 	}
+	else if (len >= 2 && text[0] == 0xff && text[1] == 0xfe)
+	{
+	    vimconv_T conv;
+
+	    /* UTF-16, we get this for HTML */
+	    conv.vc_type = CONV_NONE;
+	    convert_setup_ext(&conv, (char_u *)"utf-16le", FALSE, p_enc, TRUE);
+
+	    if (conv.vc_type != CONV_NONE)
+	    {
+		text += 2;
+		len -= 2;
+		tmpbuf = string_convert(&conv, text, &len);
+		convert_setup(&conv, NULL, NULL);
+	    }
+	    if (tmpbuf != NULL)
+		text = tmpbuf;
+	}
     }
 #else /* !HAVE_GTK2 */
 # ifdef FEAT_MBYTE
     else if (data->type == utf8_string_atom)
     {
@@ -1412,17 +1446,16 @@ selection_received_cb(GtkWidget		*widget
 
 /*
  * Prepare our selection data for passing it to the external selection
  * client.
  */
-/*ARGSUSED*/
     static void
-selection_get_cb(GtkWidget	    *widget,
+selection_get_cb(GtkWidget	    *widget UNUSED,
 		 GtkSelectionData   *selection_data,
 		 guint		    info,
-		 guint		    time_,
-		 gpointer	    user_data)
+		 guint		    time_ UNUSED,
+		 gpointer	    user_data UNUSED)
 {
     char_u	    *string;
     char_u	    *tmpbuf;
     long_u	    tmplen;
     int		    length;
@@ -1438,10 +1471,11 @@ selection_get_cb(GtkWidget	    *widget,
     if (!cbd->owned)
 	return;			/* Shouldn't ever happen */
 
     if (info != (guint)TARGET_STRING
 #ifdef FEAT_MBYTE
+	    && (!clip_html || info != (guint)TARGET_HTML)
 	    && info != (guint)TARGET_UTF8_STRING
 	    && info != (guint)TARGET_VIMENC
 #endif
 	    && info != (guint)TARGET_VIM
 	    && info != (guint)TARGET_COMPOUND_TEXT
@@ -1473,10 +1507,44 @@ selection_get_cb(GtkWidget	    *widget,
 	string = tmpbuf;
 	type = vim_atom;
     }
 
 #ifdef FEAT_MBYTE
+    else if (info == (guint)TARGET_HTML)
+    {
+	vimconv_T conv;
+
+	/* Since we get utf-16, we probably should set it as well. */
+	conv.vc_type = CONV_NONE;
+	convert_setup_ext(&conv, p_enc, TRUE, (char_u *)"utf-16le", FALSE);
+	if (conv.vc_type != CONV_NONE)
+	{
+	    tmpbuf = string_convert(&conv, string, &length);
+	    convert_setup(&conv, NULL, NULL);
+	    vim_free(string);
+	    string = tmpbuf;
+	}
+
+	/* Prepend the BOM: "fffe" */
+	if (string != NULL)
+	{
+	    tmpbuf = alloc(length + 2);
+	    tmpbuf[0] = 0xff;
+	    tmpbuf[1] = 0xfe;
+	    mch_memmove(tmpbuf + 2, string, (size_t)length);
+	    vim_free(string);
+	    string = tmpbuf;
+	    length += 2;
+
+	    selection_data->type = selection_data->target;
+	    selection_data->format = 16;	/* 16 bits per char */
+	    gtk_selection_data_set(selection_data, html_atom, 16,
+							      string, length);
+	    vim_free(string);
+	}
+	return;
+    }
     else if (info == (guint)TARGET_VIMENC)
     {
 	int l = STRLEN(p_enc);
 
 	/* contents: motion_type 'encoding' NUL text */
@@ -1676,11 +1744,11 @@ process_motion_notify(int x, int y, GdkM
 	dx = x < 0 ? -x : x - gui.drawarea->allocation.width;
 	dy = y < 0 ? -y : y - gui.drawarea->allocation.height;
 
 	offshoot = dx > dy ? dx : dy;
 
-	/* Make a linearly declaying timer delay with a threshold of 5 at a
+	/* Make a linearly decaying timer delay with a threshold of 5 at a
 	 * distance of 127 pixels from the main window.
 	 *
 	 * One could think endlessly about the most ergonomic variant here.
 	 * For example it could make sense to calculate the distance from the
 	 * drags start instead...
@@ -1705,13 +1773,12 @@ process_motion_notify(int x, int y, GdkM
 }
 
 /*
  * Timer used to recognize multiple clicks of the mouse button.
  */
-/*ARGSUSED0*/
     static gint
-motion_repeat_timer_cb(gpointer data)
+motion_repeat_timer_cb(gpointer data UNUSED)
 {
     int		    x;
     int		    y;
     GdkModifierType state;
 
@@ -1747,13 +1814,14 @@ motion_repeat_timer_cb(gpointer data)
     /* Don't happen again.  We will get reinstalled in the synthetic event
      * if needed -- thus repeating should still work. */
     return FALSE;
 }
 
-/*ARGSUSED2*/
     static gint
-motion_notify_event(GtkWidget *widget, GdkEventMotion *event, gpointer data)
+motion_notify_event(GtkWidget *widget,
+		    GdkEventMotion *event,
+		    gpointer data UNUSED)
 {
     if (event->is_hint)
     {
 	int		x;
 	int		y;
@@ -1775,13 +1843,14 @@ motion_notify_event(GtkWidget *widget, G
 /*
  * Mouse button handling.  Note please that we are capturing multiple click's
  * by our own timeout mechanism instead of the one provided by GTK+ itself.
  * This is due to the way the generic VIM code is recognizing multiple clicks.
  */
-/*ARGSUSED2*/
     static gint
-button_press_event(GtkWidget *widget, GdkEventButton *event, gpointer data)
+button_press_event(GtkWidget *widget,
+		   GdkEventButton *event,
+		   gpointer data UNUSED)
 {
     int button;
     int repeated_click = FALSE;
     int x, y;
     int_u vim_modifiers;
@@ -1853,13 +1922,14 @@ button_press_event(GtkWidget *widget, Gd
 #ifdef HAVE_GTK2
 /*
  * GTK+ 2 doesn't handle mouse buttons 4, 5, 6 and 7 the same way as GTK+ 1.
  * Instead, it abstracts scrolling via the new GdkEventScroll.
  */
-/*ARGSUSED2*/
     static gboolean
-scroll_event(GtkWidget *widget, GdkEventScroll *event, gpointer data)
+scroll_event(GtkWidget *widget,
+	     GdkEventScroll *event,
+	     gpointer data UNUSED)
 {
     int	    button;
     int_u   vim_modifiers;
 
     if (gtk_socket_id != 0 && !GTK_WIDGET_HAS_FOCUS(widget))
@@ -1894,13 +1964,14 @@ scroll_event(GtkWidget *widget, GdkEvent
     return TRUE;
 }
 #endif /* HAVE_GTK2 */
 
 
-/*ARGSUSED*/
     static gint
-button_release_event(GtkWidget *widget, GdkEventButton *event, gpointer data)
+button_release_event(GtkWidget *widget UNUSED,
+		     GdkEventButton *event,
+		     gpointer data UNUSED)
 {
     int x, y;
     int_u vim_modifiers;
 
     /* Remove any motion "machine gun" timers used for automatic further
@@ -2098,20 +2169,19 @@ drag_handle_text(GdkDragContext	    *con
 }
 
 /*
  * DND receiver.
  */
-/*ARGSUSED2*/
     static void
 drag_data_received_cb(GtkWidget		*widget,
 		      GdkDragContext	*context,
 		      gint		x,
 		      gint		y,
 		      GtkSelectionData	*data,
 		      guint		info,
 		      guint		time_,
-		      gpointer		user_data)
+		      gpointer		user_data UNUSED)
 {
     GdkModifierType state;
 
     /* Guard against trash */
     if (data->data == NULL
@@ -2141,11 +2211,10 @@ drag_data_received_cb(GtkWidget		*widget
 /*
  * GnomeClient interact callback.  Check for unsaved buffers that cannot
  * be abandoned and pop up a dialog asking the user for confirmation if
  * necessary.
  */
-/*ARGSUSED0*/
     static void
 sm_client_check_changed_any(GnomeClient	    *client,
 			    gint	    key,
 			    GnomeDialogType type,
 			    gpointer	    data)
@@ -2249,11 +2318,10 @@ write_session_file(char_u *filename)
 /*
  * "save_yourself" signal handler.  Initiate an interaction to ask the user
  * for confirmation if necessary.  Save the current editing session and tell
  * the session manager how to restart Vim.
  */
-/*ARGSUSED1*/
     static gboolean
 sm_client_save_yourself(GnomeClient	    *client,
 			gint		    phase,
 			GnomeSaveStyle	    save_style,
 			gboolean	    shutdown,
@@ -2337,11 +2405,10 @@ sm_client_save_yourself(GnomeClient
 /*
  * Called when the session manager wants us to die.  There isn't much to save
  * here since "save_yourself" has been emitted before (unless serious trouble
  * is happening).
  */
-/*ARGSUSED0*/
     static void
 sm_client_die(GnomeClient *client, gpointer data)
 {
     /* Don't write messages to the GUI anymore */
     full_screen = FALSE;
@@ -2377,14 +2444,13 @@ setup_save_yourself(void)
 
 # ifdef USE_XSMP
 /*
  * GTK tells us that XSMP needs attention
  */
-/*ARGSUSED*/
     static gboolean
 local_xsmp_handle_requests(source, condition, data)
-    GIOChannel		*source;
+    GIOChannel		*source UNUSED;
     GIOCondition	condition;
     gpointer		data;
 {
     if (condition == G_IO_IN)
     {
@@ -2478,20 +2544,22 @@ setup_save_yourself(void)
  *
  * The GNOME session support is much cooler anyway.  Unlike this ugly
  * WM_SAVE_YOURSELF hack it actually stores the session...  And yes,
  * it should work with KDE as well.
  */
-/*ARGSUSED1*/
     static GdkFilterReturn
-global_event_filter(GdkXEvent *xev, GdkEvent *event, gpointer data)
+global_event_filter(GdkXEvent *xev,
+		    GdkEvent *event UNUSED,
+		    gpointer data UNUSED)
 {
     XEvent *xevent = (XEvent *)xev;
 
     if (xevent != NULL
 	    && xevent->type == ClientMessage
 	    && xevent->xclient.message_type == GET_X_ATOM(wm_protocols_atom)
-	    && xevent->xclient.data.l[0] == GET_X_ATOM(save_yourself_atom))
+	    && (long_u)xevent->xclient.data.l[0]
+					    == GET_X_ATOM(save_yourself_atom))
     {
 	out_flush();
 	ml_sync_all(FALSE, FALSE); /* preserve all swap files */
 	/*
 	 * Set the window's WM_COMMAND property, to let the window manager
@@ -2510,11 +2578,10 @@ global_event_filter(GdkXEvent *xev, GdkE
 # else /* !HAVE_GTK2 */
 
 /*
  * GDK handler for X ClientMessage events.
  */
-/*ARGSUSED2*/
     static GdkFilterReturn
 gdk_wm_protocols_filter(GdkXEvent *xev, GdkEvent *event, gpointer data)
 {
     /* From example in gdkevents.c/gdk_wm_protocols_filter */
     XEvent *xevent = (XEvent *)xev;
@@ -2556,13 +2623,12 @@ gdk_wm_protocols_filter(GdkXEvent *xev,
 
 
 /*
  * Setup the window icon & xcmdsrv comm after the main window has been realized.
  */
-/*ARGSUSED*/
     static void
-mainwin_realize(GtkWidget *widget, gpointer data)
+mainwin_realize(GtkWidget *widget UNUSED, gpointer data UNUSED)
 {
 /* If you get an error message here, you still need to unpack the runtime
  * archive! */
 #ifdef magick
 # undef magick
@@ -2710,15 +2776,14 @@ create_blank_pointer(void)
 
     return cursor;
 }
 
 #ifdef HAVE_GTK_MULTIHEAD
-/*ARGSUSED1*/
     static void
 mainwin_screen_changed_cb(GtkWidget  *widget,
-			  GdkScreen  *previous_screen,
-			  gpointer   data)
+			  GdkScreen  *previous_screen UNUSED,
+			  gpointer   data UNUSED)
 {
     if (!gtk_widget_has_screen(widget))
 	return;
 
     /*
@@ -2755,13 +2820,12 @@ mainwin_screen_changed_cb(GtkWidget  *wi
  * dummy blank cursor.
  *
  * Don't try to set any VIM scrollbar sizes anywhere here. I'm relying on the
  * fact that the main VIM engine doesn't take them into account anywhere.
  */
-/*ARGSUSED1*/
     static void
-drawarea_realize_cb(GtkWidget *widget, gpointer data)
+drawarea_realize_cb(GtkWidget *widget, gpointer data UNUSED)
 {
     GtkWidget *sbar;
 
 #ifdef FEAT_XIM
     xim_init();
@@ -2787,13 +2851,12 @@ drawarea_realize_cb(GtkWidget *widget, g
 }
 
 /*
  * Properly clean up on shutdown.
  */
-/*ARGSUSED0*/
     static void
-drawarea_unrealize_cb(GtkWidget *widget, gpointer data)
+drawarea_unrealize_cb(GtkWidget *widget UNUSED, gpointer data UNUSED)
 {
     /* Don't write messages to the GUI anymore */
     full_screen = FALSE;
 
 #ifdef FEAT_XIM
@@ -2825,26 +2888,26 @@ drawarea_unrealize_cb(GtkWidget *widget,
     gdk_cursor_destroy(gui.blank_pointer);
     gui.blank_pointer = NULL;
 #endif
 }
 
-/*ARGSUSED0*/
     static void
-drawarea_style_set_cb(GtkWidget	*widget,
-		      GtkStyle	*previous_style,
-		      gpointer	data)
+drawarea_style_set_cb(GtkWidget	*widget UNUSED,
+		      GtkStyle	*previous_style UNUSED,
+		      gpointer	data UNUSED)
 {
     gui_mch_new_colors();
 }
 
 /*
  * Callback routine for the "delete_event" signal on the toplevel window.
  * Tries to vim gracefully, or refuses to exit with changed buffers.
  */
-/*ARGSUSED*/
     static gint
-delete_event_cb(GtkWidget *widget, GdkEventAny *event, gpointer data)
+delete_event_cb(GtkWidget *widget UNUSED,
+		GdkEventAny *event UNUSED,
+		gpointer data UNUSED)
 {
     gui_shell_closed();
     return TRUE;
 }
 
@@ -2962,11 +3025,11 @@ update_window_manager_hints(int force_wi
     int min_width;
     int min_height;
 
     /* At start-up, don't try to set the hints until the initial
      * values have been used (those that dictate our initial size)
-     * Let forced (i.e., correct) values thruogh always.
+     * Let forced (i.e., correct) values through always.
      */
     if (!(force_width && force_height)  &&  init_window_hints_state > 0)
     {
 	/* Don't do it! */
 	init_window_hints_state = 2;
@@ -3140,13 +3203,12 @@ static GtkTooltips *tabline_tooltip;
 static int clicked_page;	    /* page clicked in tab line */
 
 /*
  * Handle selecting an item in the tab line popup menu.
  */
-/*ARGSUSED*/
     static void
-tabline_menu_handler(GtkMenuItem *item, gpointer user_data)
+tabline_menu_handler(GtkMenuItem *item UNUSED, gpointer user_data)
 {
     /* Add the string cmd into input buffer */
     send_tabline_menu_event(clicked_page, (int)(long)user_data);
 
     if (gtk_main_level() > 0)
@@ -3242,17 +3304,16 @@ on_tabline_menu(GtkWidget *widget, GdkEv
 }
 
 /*
  * Handle selecting one of the tabs.
  */
-/*ARGSUSED*/
     static void
 on_select_tab(
-	GtkNotebook	*notebook,
-	GtkNotebookPage *page,
+	GtkNotebook	*notebook UNUSED,
+	GtkNotebookPage *page UNUSED,
 	gint		idx,
-	gpointer	data)
+	gpointer	data UNUSED)
 {
     if (!ignore_tabline_evt)
     {
 	if (send_tabline_event(idx + 1) && gtk_main_level() > 0)
 	    gtk_main_quit();
@@ -3458,10 +3519,11 @@ gui_mch_init(void)
     /* LINTED: avoid warning: conversion to 'unsigned long' */
     gui.spcolor = g_new0(GdkColor, 1);
 
     /* Initialise atoms */
 #ifdef FEAT_MBYTE
+    html_atom = gdk_atom_intern("text/html", FALSE);
     utf8_string_atom = gdk_atom_intern("UTF8_STRING", FALSE);
 #endif
 #ifndef HAVE_GTK2
     compound_text_atom = gdk_atom_intern("COMPOUND_TEXT", FALSE);
     text_atom = gdk_atom_intern("TEXT", FALSE);
@@ -3782,11 +3844,11 @@ gui_mch_init(void)
     wm_protocols_atom = gdk_atom_intern("WM_PROTOCOLS", FALSE);
     save_yourself_atom = gdk_atom_intern("WM_SAVE_YOURSELF", FALSE);
 #endif
 
     if (gtk_socket_id != 0)
-	/* make sure keybord input can go to the drawarea */
+	/* make sure keyboard input can go to the drawarea */
 	GTK_WIDGET_SET_FLAGS(gui.drawarea, GTK_CAN_FOCUS);
 
     /*
      * Set clipboard specific atoms
      */
@@ -3920,14 +3982,14 @@ gui_mch_new_colors(void)
 }
 
 /*
  * This signal informs us about the need to rearrange our sub-widgets.
  */
-/*ARGSUSED*/
     static gint
-form_configure_event(GtkWidget *widget, GdkEventConfigure *event,
-		     gpointer data)
+form_configure_event(GtkWidget *widget UNUSED,
+		     GdkEventConfigure *event,
+		     gpointer data UNUSED)
 {
     int usable_height = event->height;
 
     /* When in a GtkPlug, we can't guarantee valid heights (as a round
      * no. of char-heights), so we have to manually sanitise them.
@@ -3946,13 +4008,12 @@ form_configure_event(GtkWidget *widget,
 /*
  * Function called when window already closed.
  * We can't do much more here than to trying to preserve what had been done,
  * since the window is already inevitably going away.
  */
-/*ARGSUSED0*/
     static void
-mainwin_destroy_cb(GtkObject *object, gpointer data)
+mainwin_destroy_cb(GtkObject *object UNUSED, gpointer data UNUSED)
 {
     /* Don't write messages to the GUI anymore */
     full_screen = FALSE;
 
     gui.mainwin  = NULL;
@@ -3978,13 +4039,12 @@ mainwin_destroy_cb(GtkObject *object, gp
  * Thus set hints at start-up to ensure correct init. size, then a
  * second after the final attempt to reset the real minimum hinst (done by
  * scrollbar init.), actually do the standard hinst and stop the timer.
  * We'll not let the default hints be set while this timer's active.
  */
-/*ARGSUSED*/
     static gboolean
-check_startup_plug_hints(gpointer data)
+check_startup_plug_hints(gpointer data UNUSED)
 {
     if (init_window_hints_state == 1)
     {
 	/* Safe to use normal hints now */
 	init_window_hints_state = 0;
@@ -4004,10 +4064,12 @@ check_startup_plug_hints(gpointer data)
     int
 gui_mch_open(void)
 {
     guicolor_T fg_pixel = INVALCOLOR;
     guicolor_T bg_pixel = INVALCOLOR;
+    guint		pixel_width;
+    guint		pixel_height;
 
 #ifdef HAVE_GTK2
     /*
      * Allow setting a window role on the command line, or invent one
      * if none was specified.  This is mainly useful for GNOME session
@@ -4044,20 +4106,18 @@ gui_mch_open(void)
     {
 	int		mask;
 	unsigned int	w, h;
 	int		x = 0;
 	int		y = 0;
-	guint		pixel_width;
-	guint		pixel_height;
 
 	mask = XParseGeometry((char *)gui.geom, &x, &y, &w, &h);
 
 	if (mask & WidthValue)
 	    Columns = w;
 	if (mask & HeightValue)
 	{
-	    if (p_window > h - 1 || !option_was_set((char_u *)"window"))
+	    if (p_window > (long)h - 1 || !option_was_set((char_u *)"window"))
 		p_window = h - 1;
 	    Rows = h;
 	}
 
 	pixel_width = (guint)(gui_get_base_width() + Columns * gui.char_width);
@@ -4068,18 +4128,18 @@ gui_mch_open(void)
 	pixel_height += get_menu_tool_height();
 #endif
 
 	if (mask & (XValue | YValue))
 	{
-	    int w, h;
-	    gui_mch_get_screen_dimensions(&w, &h);
-	    h += p_ghr + get_menu_tool_height();
-	    w += get_menu_tool_width();
+	    int ww, hh;
+	    gui_mch_get_screen_dimensions(&ww, &hh);
+	    hh += p_ghr + get_menu_tool_height();
+	    ww += get_menu_tool_width();
 	    if (mask & XNegative)
-		x += w - pixel_width;
+		x += ww - pixel_width;
 	    if (mask & YNegative)
-		y += h - pixel_height;
+		y += hh - pixel_height;
 #ifdef HAVE_GTK2
 	    gtk_window_move(GTK_WINDOW(gui.mainwin), x, y);
 #else
 	    gtk_widget_set_uposition(gui.mainwin, x, y);
 #endif
@@ -4098,13 +4158,20 @@ gui_mch_open(void)
 	    init_window_hints_state = 1;
 	    g_timeout_add(1000, check_startup_plug_hints, NULL);
 	}
     }
 
-    gtk_form_set_size(GTK_FORM(gui.formwin),
-	    (guint)(gui_get_base_width() + Columns * gui.char_width),
-	    (guint)(gui_get_base_height() + Rows * gui.char_height));
+    pixel_width = (guint)(gui_get_base_width() + Columns * gui.char_width);
+    pixel_height = (guint)(gui_get_base_height() + Rows * gui.char_height);
+#ifdef HAVE_GTK2
+    /* For GTK2 changing the size of the form widget doesn't cause window
+     * resizing. */
+    if (gtk_socket_id == 0)
+	gtk_window_resize(GTK_WINDOW(gui.mainwin), pixel_width, pixel_height);
+#else
+    gtk_form_set_size(GTK_FORM(gui.formwin), pixel_width, pixel_height);
+#endif
     update_window_manager_hints(0, 0);
 
     if (foreground_argument != NULL)
 	fg_pixel = gui_get_color((char_u *)foreground_argument);
     if (fg_pixel == INVALCOLOR)
@@ -4227,13 +4294,12 @@ gui_mch_open(void)
 
     return OK;
 }
 
 
-/*ARGSUSED0*/
     void
-gui_mch_exit(int rc)
+gui_mch_exit(int rc UNUSED)
 {
     if (gui.mainwin != NULL)
 	gtk_widget_destroy(gui.mainwin);
 
     if (gtk_main_level() > 0)
@@ -4284,11 +4350,10 @@ static int resize_idle_installed = FALSE
  * DISABLED: When doing ":set lines+=1" this function would first invoke
  * gui_resize_shell() with the old size, then the normal callback would
  * report the new size through form_configure_event().  That caused the window
  * layout to be messed up.
  */
-/*ARGSUSED0*/
     static gboolean
 force_shell_resize_idle(gpointer data)
 {
     if (gui.mainwin != NULL
 	    && GTK_WIDGET_REALIZED(gui.mainwin)
@@ -4309,19 +4374,41 @@ force_shell_resize_idle(gpointer data)
     return FALSE; /* don't call me again */
 }
 #endif
 #endif /* HAVE_GTK2 */
 
+#if defined(HAVE_GTK2) || defined(PROTO)
+/*
+ * Return TRUE if the main window is maximized.
+ */
+    int
+gui_mch_maximized()
+{
+    return (gui.mainwin != NULL && gui.mainwin->window != NULL
+	    && (gdk_window_get_state(gui.mainwin->window)
+					       & GDK_WINDOW_STATE_MAXIMIZED));
+}
+
+/*
+ * Unmaximize the main window
+ */
+    void
+gui_mch_unmaximize()
+{
+    if (gui.mainwin != NULL)
+	gtk_window_unmaximize(GTK_WINDOW(gui.mainwin));
+}
+#endif
+
 /*
  * Set the windows size.
  */
-/*ARGSUSED2*/
     void
 gui_mch_set_shellsize(int width, int height,
-		      int min_width,  int min_height,
-		      int base_width, int base_height,
-		      int direction)
+		      int min_width UNUSED,  int min_height UNUSED,
+		      int base_width UNUSED, int base_height UNUSED,
+		      int direction UNUSED)
 {
 #ifndef HAVE_GTK2
     /* Hack: When the form already is at the desired size, the window might
      * have been resized with the mouse.  Force a resize by setting a
      * different size first. */
@@ -4411,13 +4498,12 @@ gui_mch_get_screen_dimensions(int *scree
     *screen_w -= get_menu_tool_width();
     *screen_h -= get_menu_tool_height();
 }
 
 #if defined(FEAT_TITLE) || defined(PROTO)
-/*ARGSUSED*/
     void
-gui_mch_settitle(char_u *title, char_u *icon)
+gui_mch_settitle(char_u *title, char_u *icon UNUSED)
 {
 # ifdef HAVE_GTK2
     if (title != NULL && output_conv.vc_type != CONV_NONE)
 	title = string_convert(&output_conv, title, NULL);
 # endif
@@ -4491,11 +4577,10 @@ gui_mch_show_toolbar(int showit)
 #ifndef HAVE_GTK2
 /*
  * Get a font structure for highlighting.
  * "cbdata" is a pointer to the global gui structure.
  */
-/*ARGSUSED*/
     static void
 font_sel_ok(GtkWidget *wgt, gpointer cbdata)
 {
     gui_T *vw = (gui_T *)cbdata;
     GtkFontSelectionDialog *fs = (GtkFontSelectionDialog *)vw->fontdlg;
@@ -4507,22 +4592,20 @@ font_sel_ok(GtkWidget *wgt, gpointer cbd
     gtk_widget_hide(vw->fontdlg);
     if (gtk_main_level() > 0)
 	gtk_main_quit();
 }
 
-/*ARGSUSED*/
     static void
 font_sel_cancel(GtkWidget *wgt, gpointer cbdata)
 {
     gui_T *vw = (gui_T *)cbdata;
 
     gtk_widget_hide(vw->fontdlg);
     if (gtk_main_level() > 0)
 	gtk_main_quit();
 }
 
-/*ARGSUSED*/
     static void
 font_sel_destroy(GtkWidget *wgt, gpointer cbdata)
 {
     gui_T *vw = (gui_T *)cbdata;
 
@@ -4618,11 +4701,10 @@ gui_mch_adjust_charheight(void)
 
 #if defined(FEAT_XFONTSET) || defined(PROTO)
 /*
  * Try to load the requested fontset.
  */
-/*ARGSUSED2*/
     GuiFontset
 gui_mch_get_fontset(char_u *name, int report_error, int fixed_width)
 {
     GdkFont *font;
 
@@ -4675,10 +4757,13 @@ gui_mch_font_dialog(char_u *oldval)
     }
 
     if (oldval != NULL && *oldval != NUL)
 	gtk_font_selection_dialog_set_font_name(
 		GTK_FONT_SELECTION_DIALOG(gui.fontdlg), (char *)oldval);
+    else
+	gtk_font_selection_dialog_set_font_name(
+		GTK_FONT_SELECTION_DIALOG(gui.fontdlg), DEFAULT_FONT);
 
     if (gui.fontname)
     {
 	g_free(gui.fontname);
 	gui.fontname = NULL;
@@ -4762,10 +4847,13 @@ gui_mch_font_dialog(char_u *oldval)
 		GTK_FONT_SELECTION_DIALOG(dialog), (const char *)oldname);
 
 	if (oldname != oldval)
 	    vim_free(oldname);
     }
+    else
+	gtk_font_selection_dialog_set_font_name(
+		GTK_FONT_SELECTION_DIALOG(dialog), DEFAULT_FONT);
 
     response = gtk_dialog_run(GTK_DIALOG(dialog));
 
     if (response == GTK_RESPONSE_OK)
     {
@@ -4861,11 +4949,11 @@ get_styled_font_variants(char_u * font_n
 
     styled_font[0] = &gui.bold_font;
     styled_font[1] = &gui.ital_font;
     styled_font[2] = &gui.boldital_font;
 
-    /* First free whatever was freviously there. */
+    /* First free whatever was previously there. */
     for (i = 0; i < 3; ++i)
 	if (*styled_font[i])
 	{
 	    gdk_font_unref(*styled_font[i]);
 	    *styled_font[i] = NULL;
@@ -5010,13 +5098,12 @@ ascii_glyph_table_init(void)
 
 /*
  * Initialize Vim to use the font or fontset with the given name.
  * Return FAIL if the font could not be loaded, OK otherwise.
  */
-/*ARGSUSED1*/
     int
-gui_mch_init_font(char_u *font_name, int fontset)
+gui_mch_init_font(char_u *font_name, int fontset UNUSED)
 {
 #ifdef HAVE_GTK2
     PangoFontDescription    *font_desc;
     PangoLayout		    *layout;
     int			    width;
@@ -5178,12 +5265,28 @@ gui_mch_init_font(char_u *font_name, int
 	gtk_widget_show(alignment);
     }
 # endif
 #endif /* !HAVE_GTK2 */
 
-    /* Preserve the logical dimensions of the screen. */
-    update_window_manager_hints(0, 0);
+#ifdef HAVE_GTK2
+    if (gui_mch_maximized())
+    {
+	int w, h;
+
+	/* Update lines and columns in accordance with the new font, keep the
+	 * window maximized. */
+	gtk_window_get_size(GTK_WINDOW(gui.mainwin), &w, &h);
+	w -= get_menu_tool_width();
+	h -= get_menu_tool_height();
+	gui_resize_shell(w, h);
+    }
+    else
+#endif
+    {
+	/* Preserve the logical dimensions of the screen. */
+	update_window_manager_hints(0, 0);
+    }
 
     return OK;
 }
 
 /*
@@ -5324,13 +5427,12 @@ gui_mch_get_font(char_u *name, int repor
 
 #if defined(FEAT_EVAL) || defined(PROTO)
 /*
  * Return the name of font "font" in allocated memory.
  */
-/*ARGSUSED*/
     char_u *
-gui_mch_get_fontname(GuiFont font, char_u *name)
+gui_mch_get_fontname(GuiFont font, char_u *name UNUSED)
 {
 # ifdef HAVE_GTK2
     if (font != NOFONT)
     {
 	char	*pangoname = pango_font_description_to_string(font);
@@ -5730,11 +5832,11 @@ draw_glyph_string(int row, int col, int
     static void
 draw_under(int flags, int row, int col, int cells)
 {
     int			i;
     int			offset;
-    const static int	val[8] = {1, 0, 0, 0, 1, 2, 2, 2 };
+    static const int	val[8] = {1, 0, 0, 0, 1, 2, 2, 2 };
     int			y = FILL_Y(row + 1) - 1;
 
     /* Undercurl: draw curl at the bottom of the character cell. */
     if (flags & DRAW_UNDERC)
     {
@@ -6083,16 +6185,19 @@ gui_mch_draw_string(int row, int col, ch
 	while (p < s + len)
 	{
 # ifdef FEAT_MBYTE
 	    if (enc_utf8)
 	    {
-		c = utf_ptr2char(p);
+		int pcc[MAX_MCO];
+
+		/* TODO: use the composing characters */
+		c = utfc_ptr2char_len(p, pcc, len - (p - s));
 		if (c >= 0x10000)	/* show chars > 0xffff as ? */
 		    c = 0xbf;
 		buf[textlen].byte1 = c >> 8;
 		buf[textlen].byte2 = c;
-		p += utf_ptr2len(p);
+		p += utfc_ptr2len_len(p, len - (p - s));
 		width += utf_char2cells(c);
 	    }
 	    else
 # endif
 	    {
@@ -6112,12 +6217,12 @@ gui_mch_draw_string(int row, int col, ch
 	textlen = len;
 # ifdef FEAT_MBYTE
 	if (has_mbyte)
 	{
 	    width = 0;
-	    for (p = s; p < s + len; p += (*mb_ptr2len)(p))
-		width += (*mb_ptr2cells)(p);
+	    for (p = s; p < s + len; p += (*mb_ptr2len_len)(p, len - (p - s)))
+		width += (*mb_ptr2cells_len)(p, len - (p - s));
 	}
 	else
 # endif
 	    width = len;
     }
@@ -6400,11 +6505,10 @@ input_timer_cb(gpointer data)
 
 #ifdef FEAT_SNIFF
 /*
  * Callback function, used when data is available on the SNiFF connection.
  */
-/* ARGSUSED */
     static void
 sniff_request_cb(
     gpointer	data,
     gint	source_fd,
     GdkInputCondition condition)
@@ -6663,16 +6767,18 @@ gui_mch_insert_lines(int row, int num_li
     void
 clip_mch_request_selection(VimClipboard *cbd)
 {
     GdkAtom	target;
     unsigned	i;
-    int		nbytes;
-    char_u	*buffer;
     time_t	start;
 
     for (i = 0; i < N_SELECTION_TARGETS; ++i)
     {
+#ifdef FEAT_MBYTE
+	if (!clip_html && selection_targets[i].info == TARGET_HTML)
+	    continue;
+#endif
 	received_selection = RS_NONE;
 	target = gdk_atom_intern(selection_targets[i].target, FALSE);
 
 	gtk_selection_convert(gui.drawarea,
 			      cbd->gtk_sel_atom, target,
@@ -6688,34 +6794,18 @@ clip_mch_request_selection(VimClipboard
 	if (received_selection != RS_FAIL)
 	    return;
     }
 
     /* Final fallback position - use the X CUT_BUFFER0 store */
-    nbytes = 0;
-    buffer = (char_u *)XFetchBuffer(GDK_WINDOW_XDISPLAY(gui.mainwin->window),
-				    &nbytes, 0);
-    if (nbytes > 0)
-    {
-	/* Got something */
-	clip_yank_selection(MCHAR, buffer, (long)nbytes, cbd);
-	if (p_verbose > 0)
-	{
-	    verbose_enter();
-	    smsg((char_u *)_("Used CUT_BUFFER0 instead of empty selection"));
-	    verbose_leave();
-	}
-    }
-    if (buffer != NULL)
-	XFree(buffer);
+    yank_cut_buffer0(GDK_WINDOW_XDISPLAY(gui.mainwin->window), cbd);
 }
 
 /*
  * Disown the selection.
  */
-/*ARGSUSED*/
     void
-clip_mch_lose_selection(VimClipboard *cbd)
+clip_mch_lose_selection(VimClipboard *cbd UNUSED)
 {
     /* WEIRD: when using NULL to actually disown the selection, we lose the
      * selection the first time we own it. */
     /*
     gtk_selection_owner_set(NULL, cbd->gtk_sel_atom, (guint32)GDK_CURRENT_TIME);
@@ -6739,13 +6829,12 @@ clip_mch_own_selection(VimClipboard *cbd
 
 /*
  * Send the current selection to the clipboard.  Do nothing for X because we
  * will fill in the selection only when requested by another app.
  */
-/*ARGSUSED*/
     void
-clip_mch_set_selection(VimClipboard *cbd)
+clip_mch_set_selection(VimClipboard *cbd UNUSED)
 {
 }
 
 
 #if defined(FEAT_MENU) || defined(PROTO)
@@ -6948,11 +7037,11 @@ mch_set_mouse_shape(int shape)
 	    if (id >= GDK_LAST_CURSOR)
 		id = GDK_LEFT_PTR;
 	    else
 		id &= ~1;	/* they are always even (why?) */
 	}
-	else if (shape < sizeof(mshape_ids) / sizeof(int))
+	else if (shape < (int)(sizeof(mshape_ids) / sizeof(int)))
 	    id = mshape_ids[shape];
 	else
 	    return;
 # ifdef HAVE_GTK_MULTIHEAD
 	c = gdk_cursor_new_for_display(
--- vim72.orig/src/gui_xmdlg.c
+++ vim72/src/gui_xmdlg.c
@@ -8,11 +8,11 @@
  */
 
 /*
  * (C) 2001,2005 by Marcin Dalecki <martin@dalecki.de>
  *
- * Implementation of dialogue functions for the Motif GUI variant.
+ * Implementation of dialog functions for the Motif GUI variant.
  *
  * Note about Lesstif: Apparently lesstif doesn't get the widget layout right,
  * when using a dynamic scrollbar policy.
  */
 
@@ -367,14 +367,14 @@ fill_lists(enum ListSpecifier fix, Share
     char	*list[NONE][MAX_ENTRIES_IN_LIST];
     int		count[NONE];
     char	buf[TEMP_BUF_SIZE];
     XmString	items[MAX_ENTRIES_IN_LIST];
     int		i;
-    int		index;
+    int		idx;
 
-    for (index = (int)ENCODING; index < (int)NONE; ++index)
-	count[index] = 0;
+    for (idx = (int)ENCODING; idx < (int)NONE; ++idx)
+	count[idx] = 0;
 
     /* First we insert the wild char into every single list. */
     if (fix != ENCODING)
 	add_to_list(list[ENCODING], wild, &count[ENCODING]);
     if (fix != NAME)
@@ -446,11 +446,11 @@ fill_lists(enum ListSpecifier fix, Share
 	{
 	    Widget button;
 
 	    items[i] = XmStringCreateLocalized(list[ENCODING][i]);
 
-	    if (i < n_items)
+	    if (i < (int)n_items)
 	    {
 		/* recycle old button */
 		XtVaSetValues(children[i],
 			XmNlabelString, items[i],
 			XmNuserData, i,
@@ -479,11 +479,11 @@ fill_lists(enum ListSpecifier fix, Share
 	    XtFree(list[ENCODING][i]);
 	}
 
 	/* Destroy all the outstanding menu items.
 	 */
-	for (i = count[ENCODING]; i < n_items; ++i)
+	for (i = count[ENCODING]; i < (int)n_items; ++i)
 	{
 	    XtUnmanageChild(children[i]);
 	    XtDestroyWidget(children[i]);
 	}
 
@@ -501,18 +501,18 @@ fill_lists(enum ListSpecifier fix, Share
     }
 
     /*
      * Now loop trough the remaining lists and set them up.
      */
-    for (index = (int)NAME; index < (int)NONE; ++index)
+    for (idx = (int)NAME; idx < (int)NONE; ++idx)
     {
 	Widget w;
 
-	if (fix == (enum ListSpecifier)index)
+	if (fix == (enum ListSpecifier)idx)
 	    continue;
 
-	switch ((enum ListSpecifier)index)
+	switch ((enum ListSpecifier)idx)
 	{
 	    case NAME:
 		w = data->list[NAME];
 		break;
 	    case STYLE:
@@ -523,32 +523,31 @@ fill_lists(enum ListSpecifier fix, Share
 		break;
 	    default:
 		w = (Widget)0;	/* for lint */
 	}
 
-	for (i = 0; i < count[index]; ++i)
+	for (i = 0; i < count[idx]; ++i)
 	{
-	    items[i] = XmStringCreateLocalized(list[index][i]);
-	    XtFree(list[index][i]);
+	    items[i] = XmStringCreateLocalized(list[idx][i]);
+	    XtFree(list[idx][i]);
 	}
 	XmListDeleteAllItems(w);
-	XmListAddItems(w, items, count[index], 1);
-	if (data->sel[index])
+	XmListAddItems(w, items, count[idx], 1);
+	if (data->sel[idx])
 	{
 	    XmStringFree(items[0]);
-	    items[0] = XmStringCreateLocalized(data->sel[index]);
+	    items[0] = XmStringCreateLocalized(data->sel[idx]);
 	    XmListSelectItem(w, items[0], False);
 	    XmListSetBottomItem(w, items[0]);
 	}
-	for (i = 0; i < count[index]; ++i)
+	for (i = 0; i < count[idx]; ++i)
 	    XmStringFree(items[i]);
     }
 }
 
-/*ARGSUSED*/
     static void
-stoggle_callback(Widget w,
+stoggle_callback(Widget w UNUSED,
 	SharedFontSelData *data,
 	XmToggleButtonCallbackStruct *call_data)
 {
     int		i, do_sel;
     char	newSize[TEMP_BUF_SIZE];
@@ -632,20 +631,23 @@ do_choice(Widget w,
 
     if (!data->sel[which])
 	data->sel[which] = XtNewString(sel);
     else
     {
-	XtFree(data->sel[which]);
 	if (!strcmp(data->sel[which], sel))
 	{
 	    /* unselecting current selection */
+	    XtFree(data->sel[which]);
 	    data->sel[which] = NULL;
 	    if (w)
 		XmListDeselectItem(w, call_data->item);
 	}
 	else
+	{
+	    XtFree(data->sel[which]);
 	    data->sel[which] = XtNewString(sel);
+	}
     }
     XtFree(sel);
 
     fill_lists(which, data);
 
@@ -693,29 +695,28 @@ do_choice(Widget w,
     else
     {
 	int	    n;
 	XmString    str;
 	Arg	    args[4];
-	char	    *msg = _("no specific match");
+	char	    *nomatch_msg = _("no specific match");
 
 	n = 0;
-	str = XmStringCreateLocalized(msg);
+	str = XmStringCreateLocalized(nomatch_msg);
 	XtSetArg(args[n], XmNlabelString, str); ++n;
 	XtSetValues(data->sample, args, n);
 	apply_fontlist(data->sample);
-	XmTextSetString(data->name, msg);
+	XmTextSetString(data->name, nomatch_msg);
 	XmStringFree(str);
 
 	return False;
     }
 }
 
-/*ARGSUSED*/
     static void
 encoding_callback(Widget w,
 	SharedFontSelData *data,
-	XtPointer dummy)
+	XtPointer dummy UNUSED)
 {
     XmString str;
     XmListCallbackStruct fake_data;
 
     XtVaGetValues(w, XmNlabelString, &str, NULL);
@@ -750,15 +751,14 @@ size_callback(Widget w,
 	XmListCallbackStruct *call_data)
 {
     do_choice(w, data, call_data, SIZE);
 }
 
-/*ARGSUSED*/
     static void
-cancel_callback(Widget w,
+cancel_callback(Widget w UNUSED,
 	SharedFontSelData *data,
-	XmListCallbackStruct *call_data)
+	XmListCallbackStruct *call_data UNUSED)
 {
     if (data->sel[ENCODING])
     {
 	XtFree(data->sel[ENCODING]);
 	data->sel[ENCODING] = NULL;
@@ -787,15 +787,14 @@ cancel_callback(Widget w,
     XFreeFontNames(data->names);
     data->names = NULL;
     data->exit = True;
 }
 
-/*ARGSUSED*/
     static void
-ok_callback(Widget w,
+ok_callback(Widget w UNUSED,
 	SharedFontSelData *data,
-	XmPushButtonCallbackStruct *call_data)
+	XmPushButtonCallbackStruct *call_data UNUSED)
 {
     char    *pattern;
     char    **name;
     int	    i;
 
@@ -884,25 +883,25 @@ gui_xm_select_font(char_u *current)
      */
 
     {
 	int	i;
 	int	max;
-	int	index = 0;
+	int	idx = 0;
 	int	size;
-	char	str[128];
+	char	buf[128];
 
 	for (i = 0, max = 0; i < data->num; i++)
 	{
-	    get_part(fn(data, i), 7, str);
-	    size = atoi(str);
+	    get_part(fn(data, i), 7, buf);
+	    size = atoi(buf);
 	    if ((size > max) && (size < MAX_DISPLAY_SIZE))
 	    {
-		index = i;
+		idx = i;
 		max = size;
 	    }
 	}
-	strcpy(big_font, fn(data, index));
+	strcpy(big_font, fn(data, idx));
     }
     data->old = XLoadQueryFont(XtDisplay(parent), big_font);
     data->old_list = gui_motif_create_fontlist(data->old);
 
     /* Set the title of the Dialog window. */
@@ -1215,32 +1214,32 @@ gui_xm_select_font(char_u *current)
 
 	names = XListFonts(XtDisplay(form), (char *) current, 1, &i);
 
 	if (i != 0)
 	{
-	    char name[TEMP_BUF_SIZE];
-	    char style[TEMP_BUF_SIZE];
-	    char size[TEMP_BUF_SIZE];
-	    char encoding[TEMP_BUF_SIZE];
+	    char namebuf[TEMP_BUF_SIZE];
+	    char stylebuf[TEMP_BUF_SIZE];
+	    char sizebuf[TEMP_BUF_SIZE];
+	    char encodingbuf[TEMP_BUF_SIZE];
 	    char *found;
 
 	    found = names[0];
 
-	    name_part(found, name);
-	    style_part(found, style);
-	    size_part(found, size, data->in_pixels);
-	    encoding_part(found, encoding);
-
-	    if (strlen(name) > 0
-		    && strlen(style) > 0
-		    && strlen(size) > 0
-		    && strlen(encoding) > 0)
+	    name_part(found, namebuf);
+	    style_part(found, stylebuf);
+	    size_part(found, sizebuf, data->in_pixels);
+	    encoding_part(found, encodingbuf);
+
+	    if (strlen(namebuf) > 0
+		    && strlen(stylebuf) > 0
+		    && strlen(sizebuf) > 0
+		    && strlen(encodingbuf) > 0)
 	    {
-		data->sel[NAME] = XtNewString(name);
-		data->sel[STYLE] = XtNewString(style);
-		data->sel[SIZE] = XtNewString(size);
-		data->sel[ENCODING] = XtNewString(encoding);
+		data->sel[NAME] = XtNewString(namebuf);
+		data->sel[STYLE] = XtNewString(stylebuf);
+		data->sel[SIZE] = XtNewString(sizebuf);
+		data->sel[ENCODING] = XtNewString(encodingbuf);
 		data->font_name = XtNewString(names[0]);
 		display_sample(data);
 		XmTextSetString(data->name, data->font_name);
 	    }
 	    else
@@ -1273,17 +1272,16 @@ gui_xm_select_font(char_u *current)
     /* modal event loop */
     while (!data->exit)
 	XtAppProcessEvent(XtWidgetToApplicationContext(data->dialog),
 							(XtInputMask)XtIMAll);
 
-    XtDestroyWidget(data->dialog);
-
     if (data->old)
     {
 	XFreeFont(XtDisplay(data->dialog),  data->old);
 	XmFontListFree(data->old_list);
     }
+    XtDestroyWidget(data->dialog);
 
     gui_motif_synch_fonts();
 
     return (char_u *) data->font_name;
 }
--- vim72.orig/src/gui_xmebw.c
+++ vim72/src/gui_xmebw.c
@@ -233,17 +233,16 @@ bump_color(unsigned short value)
     int tmp = 2 * (((int) value - 65535) / 3) + 65535;
 
     return tmp;
 }
 
-/*ARGSUSED*/
     static int
 alloc_color(Display	*display,
 	Colormap	colormap,
 	char		*colorname,
 	XColor		*xcolor,
-	void		*closure)
+	void		*closure UNUSED)
 {
     int status;
 
     if (colorname)
 	if (!XParseColor(display, colormap, colorname, xcolor))
@@ -593,13 +592,14 @@ draw_unhighlight(XmEnhancedButtonWidget
     else
 	XmeClearBorder(XtDisplay(eb), XtWindow(eb), 0, 0, XtWidth(eb),
 		       XtHeight(eb), eb->primitive.highlight_thickness);
 }
 
-/*ARGSUSED*/
     static void
-draw_pixmap(XmEnhancedButtonWidget eb, XEvent *event, Region region)
+draw_pixmap(XmEnhancedButtonWidget eb,
+	    XEvent *event UNUSED,
+	    Region region UNUSED)
 {
     Pixmap	pix;
     GC		gc = eb->label.normal_GC;
     int		depth;
     Cardinal	width;
@@ -639,11 +639,11 @@ draw_pixmap(XmEnhancedButtonWidget eb, X
     if (w < width)
 	width = w;
     height = eb->core.height - 2 * y;
     if (h < height)
 	height = h;
-    if (depth == eb->core.depth)
+    if (depth == (int)eb->core.depth)
 	XCopyArea(XtDisplay(eb), pix, XtWindow(eb), gc, 0, 0,
 		width, height, x, y);
     else if (depth == 1)
 	XCopyPlane(XtDisplay(eb), pix, XtWindow(eb), gc, 0, 0,
 		width, height, x, y, (unsigned long)1);
@@ -729,13 +729,15 @@ draw_label(XmEnhancedButtonWidget eb, XE
 
     if (replaceGC)
 	eb->label.normal_GC = tmp_gc;
 }
 
-/*ARGSUSED*/
     static void
-Enter(Widget wid, XEvent *event, String *params, Cardinal *num_params)
+Enter(Widget wid,
+      XEvent *event,
+      String *params UNUSED,
+      Cardinal *num_params UNUSED)
 {
     XmEnhancedButtonWidget eb = (XmEnhancedButtonWidget) wid;
     XmPushButtonCallbackStruct call_value;
 
     if (Lab_IsMenupane(eb))
@@ -816,13 +818,15 @@ Enter(Widget wid, XEvent *event, String
 	draw_shadows(eb);
 	draw_pixmap(eb, event, NULL);
     }
 }
 
-/*ARGSUSED*/
     static void
-Leave(Widget wid, XEvent *event, String *params, Cardinal *num_params)
+Leave(Widget wid,
+      XEvent *event,
+      String *params UNUSED,
+      Cardinal *num_params UNUSED)
 {
     XmEnhancedButtonWidget eb = (XmEnhancedButtonWidget)wid;
     XmPushButtonCallbackStruct call_value;
 
     if (Lab_IsMenupane(eb))
@@ -974,13 +978,12 @@ set_size(XmEnhancedButtonWidget newtb)
 
 	(* resize) ((Widget) newtb);
     }
 }
 
-/*ARGSUSED*/
     static void
-Initialize(Widget rq, Widget ebw, ArgList args, Cardinal *n)
+Initialize(Widget rq, Widget ebw, ArgList args UNUSED, Cardinal *n UNUSED)
 {
     XmEnhancedButtonWidget  request = (XmEnhancedButtonWidget)rq;
     XmEnhancedButtonWidget  eb = (XmEnhancedButtonWidget)ebw;
     XtWidgetProc	    resize;
 
@@ -1054,13 +1057,16 @@ Destroy(Widget w)
 	return;
 
     free_pixmaps((XmEnhancedButtonWidget)w);
 }
 
-/*ARGSUSED*/
     static Boolean
-SetValues(Widget current, Widget request, Widget new, ArgList args, Cardinal *n)
+SetValues(Widget current,
+	  Widget request UNUSED,
+	  Widget new,
+	  ArgList args UNUSED,
+	  Cardinal *n UNUSED)
 {
     XmEnhancedButtonWidget  cur = (XmEnhancedButtonWidget) current;
     XmEnhancedButtonWidget  eb = (XmEnhancedButtonWidget) new;
     Boolean		    redraw = False;
     Boolean		    change = True;
@@ -1106,11 +1112,11 @@ SetValues(Widget current, Widget request
 	    if (root == root_q)
 	    {
 		if ((win_x < 0) || (win_y < 0))
 		    return False;
 
-		if ((win_x > r_width) || (win_y > r_height))
+		if ((win_x > (int)r_width) || (win_y > (int)r_height))
 		    return False;
 		draw_highlight(eb);
 		draw_shadows(eb);
 	    }
 	}
@@ -1254,11 +1260,11 @@ Redisplay(Widget w, XEvent *event, Regio
 	       ->primitive_class.border_highlight))(w);
 	draw_pixmap(eb, event, region);
     }
     else
     {
-	int adjust = 0;
+	adjust = 0;
 
 #if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
 	/*
 	 *  NOTE: PushButton has two types of shadows: primitive-shadow and
 	 *  default-button-shadow.  If pushbutton is in a menu only primitive
@@ -1266,16 +1272,15 @@ Redisplay(Widget w, XEvent *event, Regio
 	 */
 	switch (default_button_emphasis)
 	{
 	    case XmEXTERNAL_HIGHLIGHT:
 		adjust = (eb->primitive.highlight_thickness -
-			(eb->pushbutton.default_button_shadow_thickness ?
-			 Xm3D_ENHANCE_PIXEL : 0));
+			 (eb->pushbutton.default_button_shadow_thickness
+			  ?  Xm3D_ENHANCE_PIXEL : 0));
 		break;
 
 	    case XmINTERNAL_HIGHLIGHT:
-		adjust = 0;
 		break;
 
 	    default:
 		assert(FALSE);
 		return;
--- vim72.orig/src/message.c
+++ vim72/src/message.c
@@ -105,11 +105,11 @@ msg(s)
 {
     return msg_attr_keep(s, 0, FALSE);
 }
 
 #if defined(FEAT_EVAL) || defined(FEAT_X11) || defined(USE_XSMP) \
-    || defined(PROTO)
+    || defined(FEAT_GUI_GTK) || defined(PROTO)
 /*
  * Like msg() but keep it silent when 'verbosefile' is set.
  */
     int
 verb_msg(s)
@@ -816,14 +816,13 @@ delete_first_msg()
 }
 
 /*
  * ":messages" command.
  */
-/*ARGSUSED*/
     void
 ex_messages(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     struct msg_hist *p;
     char_u	    *s;
 
     msg_hist_off = TRUE;
@@ -974,11 +973,11 @@ wait_return(redraw)
 			c = K_IGNORE;
 			hit_return_msg();
 		    }
 		}
 		else if (msg_scrolled > Rows - 2
-				     && (c == 'j' || c == K_DOWN || c == 'd'))
+			 && (c == 'j' || c == K_DOWN || c == 'd' || c == 'f'))
 		    c = K_IGNORE;
 	    }
 	} while ((had_got_int && c == Ctrl_C)
 				|| c == K_IGNORE
 #ifdef FEAT_GUI
@@ -2502,23 +2501,24 @@ do_more_prompt(typed_char)
 	case K_DOWN:
 	    scroll = 1;
 	    break;
 
 	case 'u':		/* Up half a page */
-	case K_PAGEUP:
 	    scroll = -(Rows / 2);
 	    break;
 
 	case 'd':		/* Down half a page */
 	    scroll = Rows / 2;
 	    break;
 
 	case 'b':		/* one page back */
+	case K_PAGEUP:
 	    scroll = -(Rows - 1);
 	    break;
 
 	case ' ':		/* one extra page */
+	case 'f':
 	case K_PAGEDOWN:
 	case K_LEFTMOUSE:
 	    scroll = Rows - 1;
 	    break;
 
@@ -2550,18 +2550,20 @@ do_more_prompt(typed_char)
 #ifdef FEAT_CON_DIALOG
 	    if (confirm_msg_used)
 	    {
 		/* Jump to the choices of the dialog. */
 		retval = TRUE;
-		lines_left = Rows - 1;
 	    }
 	    else
 #endif
 	    {
 		got_int = TRUE;
 		quit_more = TRUE;
 	    }
+	    /* When there is some more output (wrapping line) display that
+	     * without another prompt. */
+	    lines_left = Rows - 1;
 	    break;
 
 #ifdef FEAT_CLIPBOARD
 	case Ctrl_Y:
 	    /* Strange way to allow copying (yanking) a modeless
@@ -3018,15 +3020,11 @@ redir_write(str, maxlen)
      * Must come before the rest because of updating "msg_col".
      */
     if (*p_vfile != NUL)
 	verbose_write(s, maxlen);
 
-    if (redir_fd != NULL
-#ifdef FEAT_EVAL
-			  || redir_reg || redir_vname
-#endif
-				       )
+    if (redirecting())
     {
 	/* If the string doesn't start with CR or NL, go to msg_col */
 	if (*s != '\n' && *s != '\r')
 	{
 	    while (cur_col < msg_col)
@@ -3069,10 +3067,20 @@ redir_write(str, maxlen)
 	if (msg_silent != 0)	/* should update msg_col */
 	    msg_col = cur_col;
     }
 }
 
+    int
+redirecting()
+{
+    return redir_fd != NULL
+#ifdef FEAT_EVAL
+			  || redir_reg || redir_vname
+#endif
+				       ;
+}
+
 /*
  * Before giving verbose message.
  * Must always be called paired with verbose_leave()!
  */
     void
@@ -3279,19 +3287,19 @@ msg_advance(col)
  * The second button should be the 'Cancel' button
  * Other buttons- use your imagination!
  * A '&' in a button name becomes a shortcut, so each '&' should be before a
  * different letter.
  */
-/* ARGSUSED */
     int
 do_dialog(type, title, message, buttons, dfltbutton, textfield)
-    int		type;
-    char_u	*title;
+    int		type UNUSED;
+    char_u	*title UNUSED;
     char_u	*message;
     char_u	*buttons;
     int		dfltbutton;
-    char_u	*textfield;	/* IObuff for inputdialog(), NULL otherwise */
+    char_u	*textfield UNUSED;	/* IObuff for inputdialog(), NULL
+					   otherwise */
 {
     int		oldState;
     int		retval = 0;
     char_u	*hotkeys;
     int		c;
@@ -3307,11 +3315,14 @@ do_dialog(type, title, message, buttons,
     /* When GUI is running and 'c' not in 'guioptions', use the GUI dialog */
     if (gui.in_use && vim_strchr(p_go, GO_CONDIALOG) == NULL)
     {
 	c = gui_mch_dialog(type, title, message, buttons, dfltbutton,
 								   textfield);
-	msg_end_prompt();
+	/* avoid a hit-enter prompt without clearing the cmdline */
+	need_wait_return = FALSE;
+	emsg_on_display = FALSE;
+	cmdline_row = msg_row;
 
 	/* Flush output to avoid that further messages and redrawing is done
 	 * in the wrong order. */
 	out_flush();
 	gui_mch_update();
@@ -4007,11 +4018,11 @@ vim_snprintf(str, str_m, fmt, a1, a2, a3
     while (*p != NUL)
     {
 	if (*p != '%')
 	{
 	    char    *q = strchr(p + 1, '%');
-	    size_t  n = (q == NULL) ? STRLEN(p) : (q - p);
+	    size_t  n = (q == NULL) ? STRLEN(p) : (size_t)(q - p);
 
 	    /* Copy up to the next '%' or NUL without any changes. */
 	    if (str_l < str_m)
 	    {
 		size_t avail = str_m - str_l;
@@ -4254,11 +4265,12 @@ vim_snprintf(str, str_m, fmt, a1, a2, a3
 			/* memchr on HP does not like n > 2^31  !!! */
 			char *q = memchr(str_arg, '\0',
 				  precision <= (size_t)0x7fffffffL ? precision
 						       : (size_t)0x7fffffffL);
 #endif
-			str_arg_l = (q == NULL) ? precision : q - str_arg;
+			str_arg_l = (q == NULL) ? precision
+						      : (size_t)(q - str_arg);
 		    }
 		    break;
 
 		default:
 		    break;
@@ -4354,11 +4366,12 @@ vim_snprintf(str, str_m, fmt, a1, a2, a3
 				uint_arg =
 #ifndef HAVE_STDARG_H
 					    get_a_arg(arg_idx);
 #else
 # if defined(FEAT_EVAL)
-					    tvs != NULL ? tv_nr(tvs, &arg_idx) :
+					    tvs != NULL ? (unsigned)
+							tv_nr(tvs, &arg_idx) :
 # endif
 						va_arg(ap, unsigned int);
 #endif
 				if (uint_arg != 0)
 				    arg_sign = 1;
@@ -4367,11 +4380,12 @@ vim_snprintf(str, str_m, fmt, a1, a2, a3
 				ulong_arg =
 #ifndef HAVE_STDARG_H
 					    get_a_arg(arg_idx);
 #else
 # if defined(FEAT_EVAL)
-					    tvs != NULL ? tv_nr(tvs, &arg_idx) :
+					    tvs != NULL ? (unsigned long)
+							tv_nr(tvs, &arg_idx) :
 # endif
 						va_arg(ap, unsigned long int);
 #endif
 				if (ulong_arg != 0)
 				    arg_sign = 1;
@@ -4554,11 +4568,17 @@ vim_snprintf(str, str_m, fmt, a1, a2, a3
 			else
 			    fmt_spec = fmt_spec == 'g' ? 'e' : 'E';
 			remove_trailing_zeroes = TRUE;
 		    }
 
-		    if (fmt_spec == 'f' && abs_f > 1.0e307)
+		    if (fmt_spec == 'f' &&
+#ifdef VAX
+			    abs_f > 1.0e38
+#else
+			    abs_f > 1.0e307
+#endif
+			    )
 		    {
 			/* Avoid a buffer overflow */
 			strcpy(tmp, "inf");
 			str_arg_l = 3;
 		    }
@@ -4583,65 +4603,66 @@ vim_snprintf(str, str_m, fmt, a1, a2, a3
 			str_arg_l = sprintf(tmp, format, f);
 
 			if (remove_trailing_zeroes)
 			{
 			    int i;
-			    char *p;
+			    char *tp;
 
 			    /* Using %g or %G: remove superfluous zeroes. */
 			    if (fmt_spec == 'f')
-				p = tmp + str_arg_l - 1;
+				tp = tmp + str_arg_l - 1;
 			    else
 			    {
-				p = (char *)vim_strchr((char_u *)tmp,
+				tp = (char *)vim_strchr((char_u *)tmp,
 						 fmt_spec == 'e' ? 'e' : 'E');
-				if (p != NULL)
+				if (tp != NULL)
 				{
 				    /* Remove superfluous '+' and leading
 				     * zeroes from the exponent. */
-				    if (p[1] == '+')
+				    if (tp[1] == '+')
 				    {
 					/* Change "1.0e+07" to "1.0e07" */
-					STRMOVE(p + 1, p + 2);
+					STRMOVE(tp + 1, tp + 2);
 					--str_arg_l;
 				    }
-				    i = (p[1] == '-') ? 2 : 1;
-				    while (p[i] == '0')
+				    i = (tp[1] == '-') ? 2 : 1;
+				    while (tp[i] == '0')
 				    {
 					/* Change "1.0e07" to "1.0e7" */
-					STRMOVE(p + i, p + i + 1);
+					STRMOVE(tp + i, tp + i + 1);
 					--str_arg_l;
 				    }
-				    --p;
+				    --tp;
 				}
 			    }
 
-			    if (p != NULL && !precision_specified)
+			    if (tp != NULL && !precision_specified)
 				/* Remove trailing zeroes, but keep the one
 				 * just after a dot. */
-				while (p > tmp + 2 && *p == '0' && p[-1] != '.')
+				while (tp > tmp + 2 && *tp == '0'
+							     && tp[-1] != '.')
 				{
-				    STRMOVE(p, p + 1);
-				    --p;
+				    STRMOVE(tp, tp + 1);
+				    --tp;
 				    --str_arg_l;
 				}
 			}
 			else
 			{
-			    char *p;
+			    char *tp;
 
 			    /* Be consistent: some printf("%e") use 1.0e+12
 			     * and some 1.0e+012.  Remove one zero in the last
 			     * case. */
-			    p = (char *)vim_strchr((char_u *)tmp,
+			    tp = (char *)vim_strchr((char_u *)tmp,
 						 fmt_spec == 'e' ? 'e' : 'E');
-			    if (p != NULL && (p[1] == '+' || p[1] == '-')
-					  && p[2] == '0'
-					  && vim_isdigit(p[3])
-					  && vim_isdigit(p[4]))
+			    if (tp != NULL && (tp[1] == '+' || tp[1] == '-')
+					  && tp[2] == '0'
+					  && vim_isdigit(tp[3])
+					  && vim_isdigit(tp[4]))
 			    {
-				STRMOVE(p + 2, p + 3);
+				STRMOVE(tp + 2, tp + 3);
 				--str_arg_l;
 			    }
 			}
 		    }
 		    str_arg = tmp;
@@ -4683,11 +4704,12 @@ vim_snprintf(str, str_m, fmt, a1, a2, a3
 		    if (str_l < str_m)
 		    {
 			size_t avail = str_m - str_l;
 
 			vim_memset(str + str_l, zero_padding ? '0' : ' ',
-					     (size_t)pn > avail ? avail : pn);
+					     (size_t)pn > avail ? avail
+								: (size_t)pn);
 		    }
 		    str_l += pn;
 		}
 	    }
 
@@ -4710,11 +4732,12 @@ vim_snprintf(str, str_m, fmt, a1, a2, a3
 		    if (str_l < str_m)
 		    {
 			size_t avail = str_m - str_l;
 
 			mch_memmove(str + str_l, str_arg,
-					     (size_t)zn > avail ? avail : zn);
+					     (size_t)zn > avail ? avail
+								: (size_t)zn);
 		    }
 		    str_l += zn;
 		}
 
 		/* insert zero padding as requested by the precision or min
@@ -4725,11 +4748,12 @@ vim_snprintf(str, str_m, fmt, a1, a2, a3
 		    if (str_l < str_m)
 		    {
 			size_t avail = str_m-str_l;
 
 			vim_memset(str + str_l, '0',
-					     (size_t)zn > avail ? avail : zn);
+					     (size_t)zn > avail ? avail
+								: (size_t)zn);
 		    }
 		    str_l += zn;
 		}
 	    }
 
@@ -4744,11 +4768,11 @@ vim_snprintf(str, str_m, fmt, a1, a2, a3
 		    {
 			size_t avail = str_m - str_l;
 
 			mch_memmove(str + str_l,
 				str_arg + zero_padding_insertion_ind,
-				(size_t)sn > avail ? avail : sn);
+				(size_t)sn > avail ? avail : (size_t)sn);
 		    }
 		    str_l += sn;
 		}
 	    }
 
@@ -4764,11 +4788,12 @@ vim_snprintf(str, str_m, fmt, a1, a2, a3
 		    if (str_l < str_m)
 		    {
 			size_t avail = str_m - str_l;
 
 			vim_memset(str + str_l, ' ',
-					     (size_t)pn > avail ? avail : pn);
+					     (size_t)pn > avail ? avail
+								: (size_t)pn);
 		    }
 		    str_l += pn;
 		}
 	    }
 	}
--- vim72.orig/runtime/doc/spell.txt
+++ vim72/runtime/doc/spell.txt
@@ -1,6 +1,6 @@
-*spell.txt*	For Vim version 7.2.  Last change: 2008 Jun 21
+*spell.txt*	For Vim version 7.2.  Last change: 2008 Nov 30
 
 
 		  VIM REFERENCE MANUAL	  by Bram Moolenaar
 
 
@@ -829,12 +829,15 @@ AFFIX FILE FORMAT			*spell-aff-format* *
 							*spell-affix-comment*
 Comment lines in the .aff file start with a '#':
 
 	# comment line ~
 
-With some items it's also possible to put a comment after it, but this isn't
-supported in general.
+Items with a fixed number of arguments can be followed by a comment.  But only
+if none of the arguments can contain white space.  The comment must start with
+a "#" character.  Example:
+
+	KEEPCASE =  # fix case for words with this flag ~
 
 
 ENCODING							*spell-SET*
 
 The affix file can be in any encoding that is supported by "iconv".  However,
@@ -963,10 +966,13 @@ When using "caplong" the two-character f
 "B1", "BB", etc.  This is useful to use one-character flags for the most
 common items and two-character flags for uncommon items.
 
 Note: When using utf-8 only characters up to 65000 may be used for flags.
 
+Note: even when using "num" or "long" the number of flags available to
+compounding and prefixes is limited to about 250.
+
 
 AFFIXES
 					    *spell-PFX* *spell-SFX*
 The usual PFX (prefix) and SFX (suffix) lines are supported (see the Myspell
 documentation or the Aspell manual:
@@ -1176,10 +1182,13 @@ Once a word has been marked as bad it wo
 word as good.
 
 The flag also applies to the word with affixes, thus this can be used to mark
 a whole bunch of related words as bad.
 
+							*spell-FORBIDDENWORD*
+FORBIDDENWORD can be used just like BAD.  For compatibility with Hunspell.
+
 							*spell-NEEDAFFIX*
 The NEEDAFFIX flag is used to require that a word is used with an affix.  The
 word itself is not a good word (unless there is an empty affix).  Example:
 
 	NEEDAFFIX + ~
@@ -1266,10 +1275,14 @@ on the inside of a compound word.  This
 The NEEDCOMPOUND flag is used to require that a word is used as part of a
 compound word.  The word itself is not a good word.  Example:
 
 	NEEDCOMPOUND & ~
 
+							*spell-ONLYINCOMPOUND*
+The ONLYINCOMPOUND does exactly the same as NEEDCOMPOUND.  Supported for
+compatiblity with Hunspell.
+
 							*spell-COMPOUNDMIN*
 The minimal character length of a word used for compounding is specified with
 COMPOUNDMIN.  Example:
 	COMPOUNDMIN 5 ~
 
@@ -1326,10 +1339,24 @@ Note: this doesn't work for postponed pr
 The COMPOUNDROOT flag is used for words in the dictionary that are already a
 compound.  This means it counts for two words when checking the compounding
 rules.  Can also be used for an affix to count the affix as a compounding
 word.
 
+						*spell-CHECKCOMPOUNDPATTERN*
+CHECKCOMPOUNDPATTERN is used to define patterns that, when matching at the
+position where two words are compounded together forbids the compound.
+For example:
+	CHECKCOMPOUNDPATTERN o e ~
+
+This forbids compounding if the first word ends in "o" and the second word
+starts with "e".
+
+The arguments must be plain text, no patterns are actually supported, despite
+the item name.  Case is always ignored.
+
+The Hunspell feature to use three arguments and flags is not supported.
+
 							*spell-SYLLABLE*
 The SYLLABLE item defines characters or character sequences that are used to
 count the number of syllables in a word.  Example:
 	SYLLABLE aeiouy/aa/au/ea/ee/ei/ie/oa/oe/oo/ou/uu/ui ~
 
@@ -1494,10 +1521,14 @@ These items appear in the affix file of
 ignored, not supported or defined in another way.
 
 ACCENT		(Hunspell)				*spell-ACCENT*
 		Use MAP instead. |spell-MAP|
 
+BREAK		(Hunspell)				*spell-BREAK*
+		Define break points.  Unclear how it works exactly.
+		Not supported.
+
 CHECKCOMPOUNDCASE  (Hunspell)			*spell-CHECKCOMPOUNDCASE*
 		Disallow uppercase letters at compound word boundaries.
 		Not supported.
 
 CHECKCOMPOUNDDUP  (Hunspell)			*spell-CHECKCOMPOUNDDUP*
@@ -1510,13 +1541,10 @@ CHECKCOMPOUNDREP  (Hunspell)			*spell-CH
 
 CHECKCOMPOUNDTRIPLE  (Hunspell)			*spell-CHECKCOMPOUNDTRIPLE*
 		Forbid three identical characters when compounding.  Not
 		supported.
 
-CHECKCOMPOUNDPATTERN  (Hunspell)		*spell-CHECKCOMPOUNDPATTERN*
-		Forbid compounding when patterns match.  Not supported.
-
 COMPLEXPREFIXES  (Hunspell)				*spell-COMPLEXPREFIXES*
 		Enables using two prefixes.  Not supported.
 
 COMPOUND	(Hunspell)				*spell-COMPOUND*
 		This is one line with the count of COMPOUND items, followed by
@@ -1534,16 +1562,21 @@ COMPOUNDEND	(Hunspell)				*spell-COMPOUN
 		Use COMPOUNDRULE instead. |spell-COMPOUNDRULE|
 
 COMPOUNDMIDDLE	(Hunspell)				*spell-COMPOUNDMIDDLE*
 		Use COMPOUNDRULE instead. |spell-COMPOUNDRULE|
 
+COMPOUNDRULES	(Hunspell)				*spell-COMPOUNDRULES*
+		Number of COMPOUNDRULE lines following.  Ignored, but the
+		argument must be a number.
+
 COMPOUNDSYLLABLE  (Hunspell)			*spell-COMPOUNDSYLLABLE*
 		Use SYLLABLE and COMPOUNDSYLMAX instead. |spell-SYLLABLE|
 		|spell-COMPOUNDSYLMAX|
 
-FORBIDDENWORD	(Hunspell)				*spell-FORBIDDENWORD*
-		Use BAD instead. |spell-BAD|
+KEY		(Hunspell)				*spell-KEY*
+		Define characters that are close together on the keyboard.
+		Used to give better suggestions.  Not supported.
 
 LANG		(Hunspell)				*spell-LANG*
 		This specifies language-specific behavior.  This actually
 		moves part of the language knowledge into the program,
 		therefore Vim does not support it.  Each language property
@@ -1551,14 +1584,11 @@ LANG		(Hunspell)				*spell-LANG*
 
 LEMMA_PRESENT	(Hunspell)				*spell-LEMMA_PRESENT*
 		Only needed for morphological analysis.
 
 MAXNGRAMSUGS	(Hunspell)				*spell-MAXNGRAMSUGS*
-		Not supported.
-
-ONLYINCOMPOUND	(Hunspell)				*spell-ONLYINCOMPOUND*
-		Use NEEDCOMPOUND instead. |spell-NEEDCOMPOUND|
+		Set number of n-gram suggestions.  Not supported.
 
 PSEUDOROOT	(Hunspell)				*spell-PSEUDOROOT*
 		Use NEEDAFFIX instead. |spell-NEEDAFFIX|
 
 SUGSWITHDOTS	(Hunspell)				*spell-SUGSWITHDOTS*
--- vim72.orig/src/ops.c
+++ vim72/src/ops.c
@@ -70,15 +70,15 @@ static struct yankreg	*y_previous = NULL
  * structure used by block_prep, op_delete and op_yank for blockwise operators
  * also op_change, op_shift, op_insert, op_replace - AKelly
  */
 struct block_def
 {
-    int		startspaces;	/* 'extra' cols of first char */
-    int		endspaces;	/* 'extra' cols of first char */
+    int		startspaces;	/* 'extra' cols before first char */
+    int		endspaces;	/* 'extra' cols after last char */
     int		textlen;	/* chars in block */
-    char_u	*textstart;	/* pointer to 1st char in block */
-    colnr_T	textcol;	/* cols of chars (at least part.) in block */
+    char_u	*textstart;	/* pointer to 1st char (partially) in block */
+    colnr_T	textcol;	/* index of chars (partially) in block */
     colnr_T	start_vcol;	/* start col of 1st char wholly inside block */
     colnr_T	end_vcol;	/* start col of 1st char wholly after block */
 #ifdef FEAT_VISUALEXTRA
     int		is_short;	/* TRUE if line is too short to fit in block */
     int		is_MAX;		/* TRUE if curswant==MAXCOL when starting */
@@ -380,22 +380,20 @@ shift_block(oap, amount)
     oparg_T	*oap;
     int		amount;
 {
     int			left = (oap->op_type == OP_LSHIFT);
     int			oldstate = State;
-    int			total, split;
-    char_u		*newp, *oldp, *midp, *ptr;
+    int			total;
+    char_u		*newp, *oldp;
     int			oldcol = curwin->w_cursor.col;
     int			p_sw = (int)curbuf->b_p_sw;
     int			p_ts = (int)curbuf->b_p_ts;
     struct block_def	bd;
-    int			internal = 0;
     int			incr;
-    colnr_T		vcol, col = 0, ws_vcol;
+    colnr_T		ws_vcol;
     int			i = 0, j = 0;
     int			len;
-
 #ifdef FEAT_RIGHTLEFT
     int			old_p_ri = p_ri;
 
     p_ri = 0;			/* don't want revins in ident */
 #endif
@@ -422,12 +420,13 @@ shift_block(oap, amount)
 	if (bd.startspaces)
 	{
 #ifdef FEAT_MBYTE
 	    if (has_mbyte)
 		bd.textstart += (*mb_ptr2len)(bd.textstart);
+	    else
 #endif
-	    ++bd.textstart;
+		++bd.textstart;
 	}
 	for ( ; vim_iswhite(*bd.textstart); )
 	{
 	    incr = lbr_chartabsize_adv(&bd.textstart, (colnr_T)(bd.start_vcol));
 	    total += incr;
@@ -454,71 +453,94 @@ shift_block(oap, amount)
 	/* the end */
 	mch_memmove(newp + bd.textcol + i + j, bd.textstart, (size_t)len);
     }
     else /* left */
     {
-	vcol = oap->start_vcol;
-	/* walk vcol past ws to be removed */
-	for (midp = oldp + bd.textcol;
-	      vcol < (oap->start_vcol + total) && vim_iswhite(*midp); )
-	{
-	    incr = lbr_chartabsize_adv(&midp, (colnr_T)vcol);
-	    vcol += incr;
-	}
-	/* internal is the block-internal ws replacing a split TAB */
-	if (vcol > (oap->start_vcol + total))
-	{
-	    /* we have to split the TAB *(midp-1) */
-	    internal = vcol - (oap->start_vcol + total);
-	}
-	/* if 'expandtab' is not set, use TABs */
+	colnr_T	    destination_col;	/* column to which text in block will
+					   be shifted */
+	char_u	    *verbatim_copy_end;	/* end of the part of the line which is
+					   copied verbatim */
+	colnr_T	    verbatim_copy_width;/* the (displayed) width of this part
+					   of line */
+	unsigned    fill;		/* nr of spaces that replace a TAB */
+	unsigned    new_line_len;	/* the length of the line after the
+					   block shift */
+	size_t	    block_space_width;
+	size_t	    shift_amount;
+	char_u	    *non_white = bd.textstart;
+	colnr_T	    non_white_col;
 
-	split = bd.startspaces + internal;
-	if (split > 0)
-	{
-	    if (!curbuf->b_p_et)
-	    {
-		for (ptr = oldp, col = 0; ptr < oldp+bd.textcol; )
-		    col += lbr_chartabsize_adv(&ptr, (colnr_T)col);
+	/*
+	 * Firstly, let's find the first non-whitespace character that is
+	 * displayed after the block's start column and the character's column
+	 * number. Also, let's calculate the width of all the whitespace
+	 * characters that are displayed in the block and precede the searched
+	 * non-whitespace character.
+	 */
 
-		/* col+1 now equals the start col of the first char of the
-		 * block (may be < oap.start_vcol if we're splitting a TAB) */
-		i = ((col % p_ts) + split) / p_ts; /* number of tabs */
-	    }
-	    if (i)
-		j = ((col % p_ts) + split) % p_ts; /* number of spp */
-	    else
-		j = split;
-	}
+	/* If "bd.startspaces" is set, "bd.textstart" points to the character,
+	 * the part of which is displayed at the block's beginning. Let's start
+	 * searching from the next character. */
+	if (bd.startspaces)
+	    mb_ptr_adv(non_white);
 
-	newp = alloc_check(bd.textcol + i + j + (unsigned)STRLEN(midp) + 1);
-	if (newp == NULL)
-	    return;
-	vim_memset(newp, NUL, (size_t)(bd.textcol + i + j + STRLEN(midp) + 1));
+	/* The character's column is in "bd.start_vcol".  */
+	non_white_col = bd.start_vcol;
 
-	/* copy first part we want to keep */
-	mch_memmove(newp, oldp, (size_t)bd.textcol);
-	/* Now copy any TABS and spp to ensure correct alignment! */
-	while (vim_iswhite(*midp))
+	while (vim_iswhite(*non_white))
 	{
-	    if (*midp == TAB)
-		i++;
-	    else /*space */
-		j++;
-	    midp++;
+	    incr = lbr_chartabsize_adv(&non_white, non_white_col);
+	    non_white_col += incr;
 	}
-	/* We might have an extra TAB worth of spp now! */
-	if (j / p_ts && !curbuf->b_p_et)
+
+	block_space_width = non_white_col - oap->start_vcol;
+	/* We will shift by "total" or "block_space_width", whichever is less.
+	 */
+	shift_amount = (block_space_width < (size_t)total
+					 ? block_space_width : (size_t)total);
+
+	/* The column to which we will shift the text.  */
+	destination_col = (colnr_T)(non_white_col - shift_amount);
+
+	/* Now let's find out how much of the beginning of the line we can
+	 * reuse without modification.  */
+	verbatim_copy_end = bd.textstart;
+	verbatim_copy_width = bd.start_vcol;
+
+	/* If "bd.startspaces" is set, "bd.textstart" points to the character
+	 * preceding the block. We have to subtract its width to obtain its
+	 * column number.  */
+	if (bd.startspaces)
+	    verbatim_copy_width -= bd.start_char_vcols;
+	while (verbatim_copy_width < destination_col)
 	{
-	    i++;
-	    j -= p_ts;
+	    incr = lbr_chartabsize(verbatim_copy_end, verbatim_copy_width);
+	    if (verbatim_copy_width + incr > destination_col)
+		break;
+	    verbatim_copy_width += incr;
+	    mb_ptr_adv(verbatim_copy_end);
 	}
-	copy_chars(newp + bd.textcol, (size_t)i, TAB);
-	copy_spaces(newp + bd.textcol + i, (size_t)j);
 
-	/* the end */
-	STRMOVE(newp + STRLEN(newp), midp);
+	/* If "destination_col" is different from the width of the initial
+	 * part of the line that will be copied, it means we encountered a tab
+	 * character, which we will have to partly replace with spaces.  */
+	fill = destination_col - verbatim_copy_width;
+
+	/* The replacement line will consist of:
+	 * - the beginning of the original line up to "verbatim_copy_end",
+	 * - "fill" number of spaces,
+	 * - the rest of the line, pointed to by non_white.  */
+	new_line_len = (unsigned)(verbatim_copy_end - oldp)
+		       + fill
+		       + (unsigned)STRLEN(non_white) + 1;
+
+	newp = alloc_check(new_line_len);
+	if (newp == NULL)
+	    return;
+	mch_memmove(newp, oldp, (size_t)(verbatim_copy_end - oldp));
+	copy_spaces(newp + (verbatim_copy_end - oldp), (size_t)fill);
+	STRMOVE(newp + (verbatim_copy_end - oldp) + fill, non_white);
     }
     /* replace the line */
     ml_replace(curwin->w_cursor.lnum, newp, FALSE);
     changed_bytes(curwin->w_cursor.lnum, (colnr_T)bd.textcol);
     State = oldstate;
@@ -1120,10 +1142,12 @@ stuff_yank(regname, p)
 	y_current->y_type = MCHAR;  /* used to be MLINE, why? */
     }
     return OK;
 }
 
+static int execreg_lastc = NUL;
+
 /*
  * execute a yank register: copy it into the stuff buffer
  *
  * return FAIL for failure, OK otherwise
  */
@@ -1132,32 +1156,31 @@ do_execreg(regname, colon, addcr, silent
     int	    regname;
     int	    colon;		/* insert ':' before each line */
     int	    addcr;		/* always add '\n' to end of line */
     int	    silent;		/* set "silent" flag in typeahead buffer */
 {
-    static int	lastc = NUL;
     long	i;
     char_u	*p;
     int		retval = OK;
     int		remap;
 
     if (regname == '@')			/* repeat previous one */
     {
-	if (lastc == NUL)
+	if (execreg_lastc == NUL)
 	{
 	    EMSG(_("E748: No previously used register"));
 	    return FAIL;
 	}
-	regname = lastc;
+	regname = execreg_lastc;
     }
 					/* check for valid regname */
     if (regname == '%' || regname == '#' || !valid_yank_reg(regname, FALSE))
     {
 	emsg_invreg(regname);
 	return FAIL;
     }
-    lastc = regname;
+    execreg_lastc = regname;
 
 #ifdef FEAT_CLIPBOARD
     regname = may_get_selection(regname);
 #endif
 
@@ -1276,22 +1299,28 @@ put_reedit_in_typebuf(silent)
 	if (ins_typebuf(buf, REMAP_NONE, 0, TRUE, silent) == OK)
 	    restart_edit = NUL;
     }
 }
 
+/*
+ * Insert register contents "s" into the typeahead buffer, so that it will be
+ * executed again.
+ * When "esc" is TRUE it is to be taken literally: Escape CSI characters and
+ * no remapping.
+ */
     static int
 put_in_typebuf(s, esc, colon, silent)
     char_u	*s;
-    int		esc;	    /* Escape CSI characters */
+    int		esc;
     int		colon;	    /* add ':' before the line */
     int		silent;
 {
     int		retval = OK;
 
     put_reedit_in_typebuf(silent);
     if (colon)
-	retval = ins_typebuf((char_u *)"\n", REMAP_YES, 0, TRUE, silent);
+	retval = ins_typebuf((char_u *)"\n", REMAP_NONE, 0, TRUE, silent);
     if (retval == OK)
     {
 	char_u	*p;
 
 	if (esc)
@@ -1299,16 +1328,17 @@ put_in_typebuf(s, esc, colon, silent)
 	else
 	    p = s;
 	if (p == NULL)
 	    retval = FAIL;
 	else
-	    retval = ins_typebuf(p, REMAP_YES, 0, TRUE, silent);
+	    retval = ins_typebuf(p, esc ? REMAP_NONE : REMAP_YES,
+							     0, TRUE, silent);
 	if (esc)
 	    vim_free(p);
     }
     if (colon && retval == OK)
-	retval = ins_typebuf((char_u *)":", REMAP_YES, 0, TRUE, silent);
+	retval = ins_typebuf((char_u *)":", REMAP_NONE, 0, TRUE, silent);
     return retval;
 }
 
 /*
  * Insert a yank register: copy it into the Read buffer.
@@ -1996,10 +2026,11 @@ op_replace(oap, c)
     if (oap->block_mode)
     {
 	bd.is_MAX = (curwin->w_curswant == MAXCOL);
 	for ( ; curwin->w_cursor.lnum <= oap->end.lnum; ++curwin->w_cursor.lnum)
 	{
+	    curwin->w_cursor.col = 0;  /* make sure cursor position is valid */
 	    block_prep(oap, &bd, curwin->w_cursor.lnum, TRUE);
 	    if (bd.textlen == 0 && (!virtual_op || bd.is_MAX))
 		continue;	    /* nothing to replace */
 
 	    /* n == number of extra chars required
@@ -2011,10 +2042,11 @@ op_replace(oap, c)
 	     * coladd offset as part of "startspaces" */
 	    if (virtual_op && bd.is_short && *bd.textstart == NUL)
 	    {
 		pos_T vpos;
 
+		vpos.lnum = curwin->w_cursor.lnum;
 		getvpos(&vpos, oap->start_vcol);
 		bd.startspaces += vpos.coladd;
 		n = bd.startspaces;
 	    }
 	    else
@@ -2207,16 +2239,19 @@ op_tilde(oap)
 #ifdef FEAT_VISUAL
     if (oap->block_mode)		    /* Visual block mode */
     {
 	for (; pos.lnum <= oap->end.lnum; ++pos.lnum)
 	{
+	    int one_change;
+
 	    block_prep(oap, &bd, pos.lnum, FALSE);
 	    pos.col = bd.textcol;
-	    did_change = swapchars(oap->op_type, &pos, bd.textlen);
+	    one_change = swapchars(oap->op_type, &pos, bd.textlen);
+	    did_change |= one_change;
 
 # ifdef FEAT_NETBEANS_INTG
-	    if (usingNetbeans && did_change)
+	    if (usingNetbeans && one_change)
 	    {
 		char_u *ptr = ml_get_buf(curbuf, pos.lnum, FALSE);
 
 		netbeans_removed(curbuf, pos.lnum, bd.textcol,
 							    (long)bd.textlen);
@@ -2666,15 +2701,12 @@ op_change(oap)
 
 			/* If the block starts in virtual space, count the
 			 * initial coladd offset as part of "startspaces" */
 			if (bd.is_short)
 			{
-			    linenr_T lnum = curwin->w_cursor.lnum;
-
-			    curwin->w_cursor.lnum = linenr;
+			    vpos.lnum = linenr;
 			    (void)getvpos(&vpos, oap->start_vcol);
-			    curwin->w_cursor.lnum = lnum;
 			}
 			else
 			    vpos.coladd = 0;
 # endif
 			oldp = ml_get(linenr);
@@ -3964,10 +3996,18 @@ ex_display(eap)
 	    else
 		yb = &(y_regs[0]);
 	}
 	else
 	    yb = &(y_regs[i]);
+
+#ifdef FEAT_EVAL
+	if (name == MB_TOLOWER(redir_reg)
+		|| (redir_reg == '"' && yb == y_previous))
+	    continue;	    /* do not list register being written to, the
+			     * pointer can be freed */
+#endif
+
 	if (yb->y_array != NULL)
 	{
 	    msg_putchar('\n');
 	    msg_putchar('"');
 	    msg_putchar(name);
@@ -4446,33 +4486,18 @@ fex_format(lnum, count, c)
     int		c;	/* character to be inserted */
 {
     int		use_sandbox = was_set_insecurely((char_u *)"formatexpr",
 								   OPT_LOCAL);
     int		r;
-#ifdef FEAT_MBYTE
-    char_u	buf[MB_MAXBYTES];
-#else
-    char_u	buf[2];
-#endif
 
     /*
      * Set v:lnum to the first line number and v:count to the number of lines.
      * Set v:char to the character to be inserted (can be NUL).
      */
     set_vim_var_nr(VV_LNUM, lnum);
     set_vim_var_nr(VV_COUNT, count);
-
-#ifdef FEAT_MBYTE
-    if (has_mbyte)
-	buf[(*mb_char2bytes)(c, buf)] = NUL;
-    else
-#endif
-    {
-	buf[0] = c;
-	buf[1] = NUL;
-    }
-    set_vim_var_string(VV_CHAR, buf, -1);
+    set_vim_var_char(c);
 
     /*
      * Evaluate the function.
      */
     if (use_sandbox)
@@ -4846,11 +4871,12 @@ paragraph_start(lnum)
  *
  * for delete:
  * - textlen includes the first/last char to be (partly) deleted
  * - start/endspaces is the number of columns that are taken by the
  *   first/last deleted char minus the number of columns that have to be
- *   deleted.  for yank and tilde:
+ *   deleted.
+ * for yank and tilde:
  * - textlen includes the first/last char to be wholly yanked
  * - start/endspaces is the number of columns of the first/last yanked char
  *   that are to be yanked.
  */
     static void
@@ -5310,34 +5336,45 @@ read_viminfo_register(virp, force)
     char_u	*str;
     char_u	**array = NULL;
 
     /* We only get here (hopefully) if line[0] == '"' */
     str = virp->vir_line + 1;
+
+    /* If the line starts with "" this is the y_previous register. */
     if (*str == '"')
     {
 	set_prev = TRUE;
 	str++;
     }
+
     if (!ASCII_ISALNUM(*str) && *str != '-')
     {
 	if (viminfo_error("E577: ", _("Illegal register name"), virp->vir_line))
 	    return TRUE;	/* too many errors, pretend end-of-file */
 	do_it = FALSE;
     }
     get_yank_register(*str++, FALSE);
     if (!force && y_current->y_array != NULL)
 	do_it = FALSE;
+
+    if (*str == '@')
+    {
+	/* "x@: register x used for @@ */
+	if (force || execreg_lastc == NUL)
+	    execreg_lastc = str[-1];
+    }
+
     size = 0;
     limit = 100;	/* Optimized for registers containing <= 100 lines */
     if (do_it)
     {
 	if (set_prev)
 	    y_previous = y_current;
 	vim_free(y_current->y_array);
 	array = y_current->y_array =
 		       (char_u **)alloc((unsigned)(limit * sizeof(char_u *)));
-	str = skipwhite(str);
+	str = skipwhite(skiptowhite(str));
 	if (STRNCMP(str, "CHAR", 4) == 0)
 	    y_current->y_type = MCHAR;
 #ifdef FEAT_VISUAL
 	else if (STRNCMP(str, "BLOCK", 5) == 0)
 	    y_current->y_type = MBLOCK;
@@ -5416,10 +5453,11 @@ write_viminfo_registers(fp)
     if (max_num_lines == 0)
 	return;
     max_kbyte = get_viminfo_parameter('s');
     if (max_kbyte == 0)
 	return;
+
     for (i = 0; i < NUM_REGISTERS; i++)
     {
 	if (y_regs[i].y_array == NULL)
 	    continue;
 #ifdef FEAT_CLIPBOARD
@@ -5470,11 +5508,14 @@ write_viminfo_registers(fp)
 		break;
 	}
 	if (y_previous == &y_regs[i])
 	    fprintf(fp, "\"");
 	c = get_register_name(i);
-	fprintf(fp, "\"%c\t%s\t%d\n", c, type,
+	fprintf(fp, "\"%c", c);
+	if (c == execreg_lastc)
+	    fprintf(fp, "@");
+	fprintf(fp, "\t%s\t%d\n", type,
 #ifdef FEAT_VISUAL
 		    (int)y_regs[i].y_width
 #else
 		    0
 #endif
@@ -5548,10 +5589,36 @@ x11_export_final_selection()
 
     /* Check it's OK */
     if (dpy != NULL && str != NULL && motion_type >= 0
 					       && len < 1024*1024 && len > 0)
     {
+#ifdef FEAT_MBYTE
+	/* The CUT_BUFFER0 is supposed to always contain latin1.  Convert from
+	 * 'enc' when it is a multi-byte encoding.  When 'enc' is an 8-bit
+	 * encoding conversion usually doesn't work, so keep the text as-is.
+	 */
+	if (has_mbyte)
+	{
+	    vimconv_T	vc;
+
+	    vc.vc_type = CONV_NONE;
+	    if (convert_setup(&vc, p_enc, (char_u *)"latin1") == OK)
+	    {
+		int	intlen = len;
+		char_u	*conv_str;
+
+		conv_str = string_convert(&vc, str, &intlen);
+		len = intlen;
+		if (conv_str != NULL)
+		{
+		    vim_free(str);
+		    str = conv_str;
+		}
+		convert_setup(&vc, NULL, NULL);
+	    }
+	}
+#endif
 	XStoreBuffer(dpy, (char *)str, (int)len, 0);
 	XFlush(dpy);
     }
 
     vim_free(str);
@@ -6039,11 +6106,11 @@ str_to_reg(y_ptr, type, str, len, blockl
     char_u	**pp;
 #ifdef FEAT_VISUAL
     long	maxlen;
 #endif
 
-    if (y_ptr->y_array == NULL)		/* NULL means emtpy register */
+    if (y_ptr->y_array == NULL)		/* NULL means empty register */
 	y_ptr->y_size = 0;
 
     /*
      * Count the number of lines within the string
      */
@@ -6256,15 +6323,24 @@ cursor_pos_info()
 	    if (*p_sel == 'e' && max_pos.col > 0)
 		--max_pos.col;
 
 	    if (VIsual_mode == Ctrl_V)
 	    {
+#ifdef FEAT_LINEBREAK
+		char_u * saved_sbr = p_sbr;
+
+		/* Make 'sbr' empty for a moment to get the correct size. */
+		p_sbr = empty_option;
+#endif
 		oparg.is_VIsual = 1;
 		oparg.block_mode = TRUE;
 		oparg.op_type = OP_NOP;
 		getvcols(curwin, &min_pos, &max_pos,
 					  &oparg.start_vcol, &oparg.end_vcol);
+#ifdef FEAT_LINEBREAK
+		p_sbr = saved_sbr;
+#endif
 		if (curwin->w_curswant == MAXCOL)
 		    oparg.end_vcol = MAXCOL;
 		/* Swap the start, end vcol if needed */
 		if (oparg.end_vcol < oparg.start_vcol)
 		{
@@ -6364,25 +6440,27 @@ cursor_pos_info()
 	{
 	    if (VIsual_mode == Ctrl_V && curwin->w_curswant < MAXCOL)
 	    {
 		getvcols(curwin, &min_pos, &max_pos, &min_pos.col,
 								&max_pos.col);
-		sprintf((char *)buf1, _("%ld Cols; "),
+		vim_snprintf((char *)buf1, sizeof(buf1), _("%ld Cols; "),
 			(long)(oparg.end_vcol - oparg.start_vcol + 1));
 	    }
 	    else
 		buf1[0] = NUL;
 
 	    if (char_count_cursor == byte_count_cursor
 						  && char_count == byte_count)
-		sprintf((char *)IObuff, _("Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Bytes"),
+		vim_snprintf((char *)IObuff, IOSIZE,
+			_("Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Bytes"),
 			buf1, line_count_selected,
 			(long)curbuf->b_ml.ml_line_count,
 			word_count_cursor, word_count,
 			byte_count_cursor, byte_count);
 	    else
-		sprintf((char *)IObuff, _("Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Chars; %ld of %ld Bytes"),
+		vim_snprintf((char *)IObuff, IOSIZE,
+			_("Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Chars; %ld of %ld Bytes"),
 			buf1, line_count_selected,
 			(long)curbuf->b_ml.ml_line_count,
 			word_count_cursor, word_count,
 			char_count_cursor, char_count,
 			byte_count_cursor, byte_count);
@@ -6390,24 +6468,26 @@ cursor_pos_info()
 	else
 #endif
 	{
 	    p = ml_get_curline();
 	    validate_virtcol();
-	    col_print(buf1, (int)curwin->w_cursor.col + 1,
+	    col_print(buf1, sizeof(buf1), (int)curwin->w_cursor.col + 1,
 		    (int)curwin->w_virtcol + 1);
-	    col_print(buf2, (int)STRLEN(p), linetabsize(p));
+	    col_print(buf2, sizeof(buf2), (int)STRLEN(p), linetabsize(p));
 
 	    if (char_count_cursor == byte_count_cursor
 		    && char_count == byte_count)
-		sprintf((char *)IObuff, _("Col %s of %s; Line %ld of %ld; Word %ld of %ld; Byte %ld of %ld"),
+		vim_snprintf((char *)IObuff, IOSIZE,
+		    _("Col %s of %s; Line %ld of %ld; Word %ld of %ld; Byte %ld of %ld"),
 		    (char *)buf1, (char *)buf2,
 		    (long)curwin->w_cursor.lnum,
 		    (long)curbuf->b_ml.ml_line_count,
 		    word_count_cursor, word_count,
 		    byte_count_cursor, byte_count);
 	    else
-		sprintf((char *)IObuff, _("Col %s of %s; Line %ld of %ld; Word %ld of %ld; Char %ld of %ld; Byte %ld of %ld"),
+		vim_snprintf((char *)IObuff, IOSIZE,
+		    _("Col %s of %s; Line %ld of %ld; Word %ld of %ld; Char %ld of %ld; Byte %ld of %ld"),
 		    (char *)buf1, (char *)buf2,
 		    (long)curwin->w_cursor.lnum,
 		    (long)curbuf->b_ml.ml_line_count,
 		    word_count_cursor, word_count,
 		    char_count_cursor, char_count,
--- vim72.orig/src/tag.c
+++ vim72/src/tag.c
@@ -88,21 +88,22 @@ static char_u *topmsg = (char_u *)N_("E5
 static char_u	*tagmatchname = NULL;	/* name of last used tag */
 
 /*
  * We use ftello() here, if available.  It returns off_t instead of long,
  * which helps if long is 32 bit and off_t is 64 bit.
+ * We assume that when fseeko() is available then ftello() is too.
  */
-#ifdef HAVE_FTELLO
+#ifdef HAVE_FSEEKO
 # define ftell ftello
 #endif
 
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
 /*
  * Tag for preview window is remembered separately, to avoid messing up the
  * normal tagstack.
  */
-static taggy_T ptag_entry = {NULL};
+static taggy_T ptag_entry = {NULL, {INIT_POS_T(0, 0, 0), 0}, 0, 0};
 #endif
 
 /*
  * Jump to tag; handling of tag commands and tag stack
  *
@@ -513,11 +514,11 @@ do_tag(tag, type, count, forceit, verbos
 
 	    /*
 	     * If a count is supplied to the ":tag <name>" command, then
 	     * jump to count'th matching tag.
 	     */
-	    if (type == DT_TAG && count > 0)
+	    if (type == DT_TAG && *tag != NUL && count > 0)
 		cur_match = count - 1;
 
 	    if (type == DT_SELECT || type == DT_JUMP
 #if defined(FEAT_QUICKFIX)
 		|| type == DT_LTAG
@@ -616,11 +617,11 @@ do_tag(tag, type, count, forceit, verbos
 		MSG_PUTS_ATTR(_("  # pri kind tag"), hl_attr(HLF_T));
 		msg_clr_eos();
 		taglen_advance(taglen);
 		MSG_PUTS_ATTR(_("file\n"), hl_attr(HLF_T));
 
-		for (i = 0; i < num_matches; ++i)
+		for (i = 0; i < num_matches && !got_int; ++i)
 		{
 		    parse_match(matches[i], &tagp);
 		    if (!new_tag && (
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
 				(g_do_tagpreview
@@ -653,10 +654,12 @@ do_tag(tag, type, count, forceit, verbos
 			msg_puts_long_attr(p, hl_attr(HLF_D));
 			vim_free(p);
 		    }
 		    if (msg_col > 0)
 			msg_putchar('\n');
+		    if (got_int)
+			break;
 		    msg_advance(15);
 
 		    /* print any extra fields */
 		    command_end = tagp.command_end;
 		    if (command_end != NULL)
@@ -687,10 +690,12 @@ do_tag(tag, type, count, forceit, verbos
 			    while (*p && *p != '\r' && *p != '\n')
 			    {
 				if (msg_col + ptr2cells(p) >= Columns)
 				{
 				    msg_putchar('\n');
+				    if (got_int)
+					break;
 				    msg_advance(15);
 				}
 				p = msg_outtrans_one(p, attr);
 				if (*p == TAB)
 				{
@@ -702,10 +707,12 @@ do_tag(tag, type, count, forceit, verbos
 			    }
 			}
 			if (msg_col > 15)
 			{
 			    msg_putchar('\n');
+			    if (got_int)
+				break;
 			    msg_advance(15);
 			}
 		    }
 		    else
 		    {
@@ -732,10 +739,12 @@ do_tag(tag, type, count, forceit, verbos
 
 		    while (p != command_end)
 		    {
 			if (msg_col + (*p == TAB ? 1 : ptr2cells(p)) > Columns)
 			    msg_putchar('\n');
+			if (got_int)
+			    break;
 			msg_advance(15);
 
 			/* skip backslash used for escaping command char */
 			if (*p == '\\' && *(p + 1) == *tagp.command)
 			    ++p;
@@ -758,16 +767,13 @@ do_tag(tag, type, count, forceit, verbos
 			    break;
 		    }
 		    if (msg_col)
 			msg_putchar('\n');
 		    ui_breakcheck();
-		    if (got_int)
-		    {
-			got_int = FALSE;	/* only stop the listing */
-			break;
-		    }
 		}
+		if (got_int)
+		    got_int = FALSE;	/* only stop the listing */
 		ask_for_selection = TRUE;
 	    }
 #if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)
 	    else if (type == DT_LTAG)
 	    {
@@ -1098,14 +1104,13 @@ taglen_advance(l)
 }
 
 /*
  * Print the tag stack
  */
-/*ARGSUSED*/
     void
 do_tags(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     int		i;
     char_u	*name;
     taggy_T	*tagstack = curwin->w_tagstack;
     int		tagstackidx = curwin->w_tagstackidx;
@@ -2523,15 +2528,14 @@ static void found_tagfile_cb __ARGS((cha
 
 /*
  * Callback function for finding all "tags" and "tags-??" files in
  * 'runtimepath' doc directories.
  */
-/*ARGSUSED*/
     static void
 found_tagfile_cb(fname, cookie)
     char_u	*fname;
-    void	*cookie;
+    void	*cookie UNUSED;
 {
     if (ga_grow(&tag_fnames, 1) == OK)
 	((char_u **)(tag_fnames.ga_data))[tag_fnames.ga_len++] =
 							   vim_strsave(fname);
 }
@@ -2540,10 +2544,19 @@ found_tagfile_cb(fname, cookie)
     void
 free_tag_stuff()
 {
     ga_clear_strings(&tag_fnames);
     do_tag(NULL, DT_FREE, 0, 0, 0);
+    tag_freematch();
+
+# if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
+    if (ptag_entry.tagname)
+    {
+        vim_free(ptag_entry.tagname);
+        ptag_entry.tagname = NULL;
+    }
+# endif
 }
 #endif
 
 /*
  * Get the next name of a tag file from the tag file list.
@@ -2723,21 +2736,38 @@ parse_tag_line(lbuf,
 	 * 1:  struct EnvBase ^?EnvBase^A139,4627
 	 * 2: #define	ARPB_WILD_WORLD ^?153,5194
 	 */
 	p_7f = vim_strchr(lbuf, 0x7f);
 	if (p_7f == NULL)
+	{
+etag_fail:
+	    if (vim_strchr(lbuf, '\n') == NULL)
+	    {
+		/* Truncated line.  Ignore it. */
+		if (p_verbose >= 5)
+		{
+		    verbose_enter();
+		    MSG(_("Ignoring long line in tags file"));
+		    verbose_leave();
+		}
+		tagp->command = lbuf;
+		tagp->tagname = lbuf;
+		tagp->tagname_end = lbuf;
+		return OK;
+	    }
 	    return FAIL;
+	}
 
 	/* Find ^A.  If not found the line number is after the 0x7f */
 	p = vim_strchr(p_7f, Ctrl_A);
 	if (p == NULL)
 	    p = p_7f + 1;
 	else
 	    ++p;
 
 	if (!VIM_ISDIGIT(*p))	    /* check for start of line number */
-	    return FAIL;
+	    goto etag_fail;
 	tagp->command = p;
 
 
 	if (p[-1] == Ctrl_A)	    /* first format: explicit tagname given */
 	{
@@ -2747,11 +2777,11 @@ parse_tag_line(lbuf,
 	else			    /* second format: isolate tagname */
 	{
 	    /* find end of tagname */
 	    for (p = p_7f - 1; !vim_iswordc(*p); --p)
 		if (p == lbuf)
-		    return FAIL;
+		    goto etag_fail;
 	    tagp->tagname_end = p + 1;
 	    while (p >= lbuf && vim_iswordc(*p))
 		--p;
 	    tagp->tagname = p + 1;
 	}
@@ -3760,11 +3790,11 @@ add_tag_field(dict, field_name, start, e
 	    end = start + STRLEN(start);
 	    while (end > start && (end[-1] == '\r' || end[-1] == '\n'))
 		--end;
 	}
 	len = (int)(end - start);
-	if (len > sizeof(buf) - 1)
+	if (len > (int)sizeof(buf) - 1)
 	    len = sizeof(buf) - 1;
 	vim_strncpy(buf, start, len);
     }
     buf[len] = NUL;
     return dict_add_nr_str(dict, field_name, 0L, buf);
--- vim72.orig/src/proto/misc2.pro
+++ vim72/src/proto/misc2.pro
@@ -57,11 +57,11 @@ void ga_append __ARGS((garray_T *gap, in
 int name_to_mod_mask __ARGS((int c));
 int simplify_key __ARGS((int key, int *modifiers));
 int handle_x_keys __ARGS((int key));
 char_u *get_special_key_name __ARGS((int c, int modifiers));
 int trans_special __ARGS((char_u **srcp, char_u *dst, int keycode));
-int find_special_key __ARGS((char_u **srcp, int *modp, int keycode));
+int find_special_key __ARGS((char_u **srcp, int *modp, int keycode, int keep_x_key));
 int extract_modifiers __ARGS((int key, int *modp));
 int find_special_key_in_table __ARGS((int c));
 int get_special_key_code __ARGS((char_u *name));
 char_u *get_key_name __ARGS((int i));
 int get_mouse_button __ARGS((int code, int *is_click, int *is_drag));
--- vim72.orig/src/gui_mac.c
+++ vim72/src/gui_mac.c
@@ -4964,11 +4964,11 @@ gui_mch_add_menu_item(vimmenu_T *menu, i
 	int	    key = 0;
 	int	    modifiers = 0;
 	char_u	    *p_actext;
 
 	p_actext = menu->actext;
-	key = find_special_key(&p_actext, &modifiers, /*keycode=*/0);
+	key = find_special_key(&p_actext, &modifiers, FALSE, FALSE);
 	if (*p_actext != 0)
 	    key = 0; /* error: trailing text */
 	/* find_special_key() returns a keycode with as many of the
 	 * specified modifiers as appropriate already applied (e.g., for
 	 * "<D-C-x>" it returns Ctrl-X as the keycode and MOD_MASK_CMD
--- vim72.orig/runtime/doc/netbeans.txt
+++ vim72/runtime/doc/netbeans.txt
@@ -1,6 +1,6 @@
-*netbeans.txt*  For Vim version 7.2.  Last change: 2008 Jun 28
+*netbeans.txt*  For Vim version 7.2.  Last change: 2009 Jan 06
 
 
 		  VIM REFERENCE MANUAL    by Gordon Prieur et al.
 
 
@@ -720,12 +720,14 @@ keyCommand keyName
 keyAtPos keyName lnum/col
 		Like "keyCommand" and also report the line number and column
 		of the cursor.
 		New in version 2.1.
 
-killed		A file was closed by the user.  Only for files that have been
-		assigned a number by the IDE.
+killed		A file was deleted or wiped out by the user and the buffer
+		annotations have been removed.  The bufID number for this
+		buffer has become invalid.  Only for files that have been
+		assigned a bufID number by the IDE.
 
 newDotAndMark off off
 		Reports the position of the cursor being at "off" bytes into
 		the buffer.  Only sent just before a "keyCommand" event.
 
--- vim72.orig/src/proto/netbeans.pro
+++ vim72/src/proto/netbeans.pro
@@ -9,16 +9,16 @@ void netbeans_beval_cb __ARGS((BalloonEv
 void netbeans_startup_done __ARGS((void));
 void netbeans_send_disconnect __ARGS((void));
 void netbeans_frame_moved __ARGS((int new_x, int new_y));
 void netbeans_file_activated __ARGS((buf_T *bufp));
 void netbeans_file_opened __ARGS((buf_T *bufp));
-void netbeans_file_closed __ARGS((buf_T *bufp));
+void netbeans_file_killed __ARGS((buf_T *bufp));
 void netbeans_inserted __ARGS((buf_T *bufp, linenr_T linenr, colnr_T col, char_u *txt, int newlen));
 void netbeans_removed __ARGS((buf_T *bufp, linenr_T linenr, colnr_T col, long len));
 void netbeans_unmodified __ARGS((buf_T *bufp));
 void netbeans_button_release __ARGS((int button));
-void netbeans_keycommand __ARGS((int key));
+int netbeans_keycommand __ARGS((int key));
 void netbeans_save_buffer __ARGS((buf_T *bufp));
 void netbeans_deleted_all_lines __ARGS((buf_T *bufp));
 int netbeans_is_guarded __ARGS((linenr_T top, linenr_T bot));
 void netbeans_draw_multisign_indicator __ARGS((int row));
 void netbeans_draw_multisign_indicator __ARGS((int row));
--- vim72.orig/src/edit.c
+++ vim72/src/edit.c
@@ -55,11 +55,11 @@ static char *ctrl_x_msgs[] =
     N_(" Omni completion (^O^N^P)"),
     N_(" Spelling suggestion (s^N^P)"),
     N_(" Keyword Local completion (^N^P)"),
 };
 
-static char_u e_hitend[] = N_("Hit end of paragraph");
+static char e_hitend[] = N_("Hit end of paragraph");
 
 /*
  * Structure used to store one match for insert completion.
  */
 typedef struct compl_S compl_T;
@@ -112,10 +112,14 @@ static int	  compl_restarting = FALSE;	/
 
 /* When the first completion is done "compl_started" is set.  When it's
  * FALSE the word to be completed must be located. */
 static int	  compl_started = FALSE;
 
+/* Set when doing something for completion that may call edit() recursively,
+ * which is not allowed. */
+static int	  compl_busy = FALSE;
+
 static int	  compl_matches = 0;
 static char_u	  *compl_pattern = NULL;
 static int	  compl_direction = FORWARD;
 static int	  compl_shows_dir = FORWARD;
 static int	  compl_pending = 0;	    /* > 1 for postponed CTRL-N */
@@ -145,10 +149,11 @@ static char_u *find_line_end __ARGS((cha
 static void ins_compl_free __ARGS((void));
 static void ins_compl_clear __ARGS((void));
 static int  ins_compl_bs __ARGS((void));
 static void ins_compl_new_leader __ARGS((void));
 static void ins_compl_addleader __ARGS((int c));
+static int ins_compl_len __ARGS((void));
 static void ins_compl_restart __ARGS((void));
 static void ins_compl_set_original_text __ARGS((char_u *str));
 static void ins_compl_addfrommatch __ARGS((void));
 static int  ins_compl_prep __ARGS((int c));
 static buf_T *ins_compl_next_buf __ARGS((buf_T *buf, int flag));
@@ -162,11 +167,11 @@ static int  ins_compl_next __ARGS((int a
 static int  ins_compl_key2dir __ARGS((int c));
 static int  ins_compl_pum_key __ARGS((int c));
 static int  ins_compl_key2count __ARGS((int c));
 static int  ins_compl_use_match __ARGS((int c));
 static int  ins_complete __ARGS((int c));
-static int  quote_meta __ARGS((char_u *dest, char_u *str, int len));
+static unsigned  quote_meta __ARGS((char_u *dest, char_u *str, int len));
 #endif /* FEAT_INS_EXPAND */
 
 #define BACKSPACE_CHAR		    1
 #define BACKSPACE_WORD		    2
 #define BACKSPACE_WORD_NOT_SPACE    3
@@ -174,11 +179,11 @@ static int  quote_meta __ARGS((char_u *d
 
 static void ins_redraw __ARGS((int ready));
 static void ins_ctrl_v __ARGS((void));
 static void undisplay_dollar __ARGS((void));
 static void insert_special __ARGS((int, int, int));
-static void internal_format __ARGS((int textwidth, int second_indent, int flags, int format_only));
+static void internal_format __ARGS((int textwidth, int second_indent, int flags, int format_only, int c));
 static void check_auto_format __ARGS((int));
 static void redo_literal __ARGS((int c));
 static void start_arrow __ARGS((pos_T *end_insert_pos));
 #ifdef FEAT_SPELL
 static void check_spell_redraw __ARGS((void));
@@ -195,11 +200,12 @@ static void replace_join __ARGS((int off
 static void replace_pop_ins __ARGS((void));
 #ifdef FEAT_MBYTE
 static void mb_replace_pop_ins __ARGS((int cc));
 #endif
 static void replace_flush __ARGS((void));
-static void replace_do_bs __ARGS((void));
+static void replace_do_bs __ARGS((int limit_col));
+static int del_char_after_col __ARGS((int limit_col));
 #ifdef FEAT_CINDENT
 static int cindent_on __ARGS((void));
 #endif
 static void ins_reg __ARGS((void));
 static void ins_ctrl_g __ARGS((void));
@@ -302,11 +308,11 @@ edit(cmdchar, startln, count)
     long	count;
 {
     int		c = 0;
     char_u	*ptr;
     int		lastc;
-    colnr_T	mincol;
+    int		mincol;
     static linenr_T o_lnum = 0;
     int		i;
     int		did_backspace = TRUE;	    /* previous char was backspace */
 #ifdef FEAT_CINDENT
     int		line_is_white = FALSE;	    /* line is empty before insert */
@@ -342,11 +348,11 @@ edit(cmdchar, startln, count)
 	return FALSE;
     }
 
 #ifdef FEAT_INS_EXPAND
     /* Don't allow recursive insert mode when busy with completion. */
-    if (compl_started || pum_visible())
+    if (compl_started || compl_busy || pum_visible())
     {
 	EMSG(_(e_secure));
 	return FALSE;
     }
     ins_compl_clear();	    /* clear stuff for CTRL-X mode */
@@ -383,11 +389,11 @@ edit(cmdchar, startln, count)
     {
 	Insstart = curwin->w_cursor;
 	if (startln)
 	    Insstart.col = 0;
     }
-    Insstart_textlen = linetabsize(ml_get_curline());
+    Insstart_textlen = (colnr_T)linetabsize(ml_get_curline());
     Insstart_blank_vcol = MAXCOL;
     if (!did_ai)
 	ai_col = 0;
 
     if (cmdchar != NUL && restart_edit == 0)
@@ -649,11 +655,11 @@ edit(cmdchar, startln, count)
 		)
 	{
 	    mincol = curwin->w_wcol;
 	    validate_cursor_col();
 
-	    if ((int)curwin->w_wcol < (int)mincol - curbuf->b_p_ts
+	    if ((int)curwin->w_wcol < mincol - curbuf->b_p_ts
 		    && curwin->w_wrow == W_WINROW(curwin)
 						 + curwin->w_height - 1 - p_so
 		    && (curwin->w_cursor.lnum != curwin->w_topline
 #ifdef FEAT_DIFF
 			|| curwin->w_topfill > 0
@@ -749,11 +755,11 @@ edit(cmdchar, startln, count)
 		/* CTRL-L: Add one character from the current match to
 		 * "compl_leader".  Except when at the original match and
 		 * there is nothing to add, CTRL-L works like CTRL-P then. */
 		if (c == Ctrl_L
 			&& (ctrl_x_mode != CTRL_X_WHOLE_LINE
-			    || STRLEN(compl_shown_match->cp_str)
+			    || (int)STRLEN(compl_shown_match->cp_str)
 					  > curwin->w_cursor.col - compl_col))
 		{
 		    ins_compl_addfrommatch();
 		    continue;
 		}
@@ -1336,12 +1342,14 @@ doESCkey:
 		    && ctrl_x_mode != 0
 		    && !(compl_cont_status & CONT_LOCAL))
 		goto normalchar;
 
 docomplete:
+	    compl_busy = TRUE;
 	    if (ins_complete(c) == FAIL)
 		compl_cont_status = 0;
+	    compl_busy = FALSE;
 	    break;
 #endif /* FEAT_INS_EXPAND */
 
 	case Ctrl_Y:	/* copy from previous line or scroll down */
 	case Ctrl_E:	/* copy from next line	   or scroll up */
@@ -1439,14 +1447,13 @@ force_cindent:
  * This is postponed until getting the next character to make '$' in the 'cpo'
  * option work correctly.
  * Only redraw when there are no characters available.  This speeds up
  * inserting sequences of characters (e.g., for CTRL-R).
  */
-/*ARGSUSED*/
     static void
 ins_redraw(ready)
-    int		ready;	    /* not busy with something */
+    int		ready UNUSED;	    /* not busy with something */
 {
     if (!char_avail())
     {
 #ifdef FEAT_AUTOCMD
 	/* Trigger CursorMoved if the cursor moved.  Not when the popup menu is
@@ -1769,11 +1776,11 @@ change_indent(type, amount, round, repla
     {
 	/*
 	 * Compute the screen column where the cursor should be.
 	 */
 	vcol = get_indent() - vcol;
-	curwin->w_virtcol = (vcol < 0) ? 0 : vcol;
+	curwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);
 
 	/*
 	 * Advance the cursor until we reach the right screen column.
 	 */
 	vcol = last_vcol = 0;
@@ -1796,13 +1803,13 @@ change_indent(type, amount, round, repla
 	 * May need to insert spaces to be able to position the cursor on
 	 * the right screen column.
 	 */
 	if (vcol != (int)curwin->w_virtcol)
 	{
-	    curwin->w_cursor.col = new_cursor_col;
+	    curwin->w_cursor.col = (colnr_T)new_cursor_col;
 	    i = (int)curwin->w_virtcol - vcol;
-	    ptr = alloc(i + 1);
+	    ptr = alloc((unsigned)(i + 1));
 	    if (ptr != NULL)
 	    {
 		new_cursor_col += i;
 		ptr[i] = NUL;
 		while (--i >= 0)
@@ -1822,11 +1829,11 @@ change_indent(type, amount, round, repla
     curwin->w_p_list = save_p_list;
 
     if (new_cursor_col <= 0)
 	curwin->w_cursor.col = 0;
     else
-	curwin->w_cursor.col = new_cursor_col;
+	curwin->w_cursor.col = (colnr_T)new_cursor_col;
     curwin->w_set_curswant = TRUE;
     changed_cline_bef_curs();
 
     /*
      * May have to adjust the start of the insert.
@@ -1931,26 +1938,64 @@ truncate_spaces(line)
 #if defined(FEAT_VREPLACE) || defined(FEAT_INS_EXPAND) \
 	|| defined(FEAT_COMMENTS) || defined(PROTO)
 /*
  * Backspace the cursor until the given column.  Handles REPLACE and VREPLACE
  * modes correctly.  May also be used when not in insert mode at all.
+ * Will attempt not to go before "col" even when there is a composing
+ * character.
  */
     void
 backspace_until_column(col)
     int	    col;
 {
     while ((int)curwin->w_cursor.col > col)
     {
 	curwin->w_cursor.col--;
 	if (State & REPLACE_FLAG)
-	    replace_do_bs();
-	else
-	    (void)del_char(FALSE);
+	    replace_do_bs(col);
+	else if (!del_char_after_col(col))
+	    break;
     }
 }
 #endif
 
+/*
+ * Like del_char(), but make sure not to go before column "limit_col".
+ * Only matters when there are composing characters.
+ * Return TRUE when something was deleted.
+ */
+   static int
+del_char_after_col(limit_col)
+    int limit_col UNUSED;
+{
+#ifdef FEAT_MBYTE
+    if (enc_utf8 && limit_col >= 0)
+    {
+	colnr_T ecol = curwin->w_cursor.col + 1;
+
+	/* Make sure the cursor is at the start of a character, but
+	 * skip forward again when going too far back because of a
+	 * composing character. */
+	mb_adjust_cursor();
+	while (curwin->w_cursor.col < (colnr_T)limit_col)
+	{
+	    int l = utf_ptr2len(ml_get_cursor());
+
+	    if (l == 0)  /* end of line */
+		break;
+	    curwin->w_cursor.col += l;
+	}
+	if (*ml_get_cursor() == NUL || curwin->w_cursor.col == ecol)
+	    return FALSE;
+	del_bytes((long)((int)ecol - curwin->w_cursor.col), FALSE, TRUE);
+    }
+    else
+#endif
+	(void)del_char(FALSE);
+    return TRUE;
+}
+
 #if defined(FEAT_INS_EXPAND) || defined(PROTO)
 /*
  * CTRL-X pressed in Insert mode.
  */
     static void
@@ -2117,11 +2162,11 @@ ins_compl_add_infercase(str, len, icase,
 {
     char_u	*p;
     int		i, c;
     int		actual_len;		/* Take multi-byte characters */
     int		actual_compl_length;	/* into account. */
-    int		*wca;		        /* Wide character array. */
+    int		*wca;			/* Wide character array. */
     int		has_lower = FALSE;
     int		was_letter = FALSE;
 
     if (p_ic && curbuf->b_p_inf && len > 0)
     {
@@ -2158,11 +2203,11 @@ ins_compl_add_infercase(str, len, icase,
 	else
 #endif
 	    actual_compl_length = compl_length;
 
 	/* Allocate wide character array for the completion and fill it. */
-	wca = (int *)alloc(actual_len * sizeof(int));
+	wca = (int *)alloc((unsigned)(actual_len * sizeof(int)));
 	if (wca != NULL)
 	{
 	    p = str;
 	    for (i = 0; i < actual_len; ++i)
 #ifdef FEAT_MBYTE
@@ -2416,11 +2461,11 @@ ins_compl_longest_match(match)
 	compl_leader = vim_strsave(match->cp_str);
 	if (compl_leader != NULL)
 	{
 	    had_match = (curwin->w_cursor.col > compl_col);
 	    ins_compl_delete();
-	    ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
+	    ins_bytes(compl_leader + ins_compl_len());
 	    ins_redraw(FALSE);
 
 	    /* When the match isn't there (to avoid matching itself) remove it
 	     * again after redrawing. */
 	    if (!had_match)
@@ -2468,11 +2513,11 @@ ins_compl_longest_match(match)
 	{
 	    /* Leader was shortened, need to change the inserted text. */
 	    *p = NUL;
 	    had_match = (curwin->w_cursor.col > compl_col);
 	    ins_compl_delete();
-	    ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
+	    ins_bytes(compl_leader + ins_compl_len());
 	    ins_redraw(FALSE);
 
 	    /* When the match isn't there (to avoid matching itself) remove it
 	     * again after redrawing. */
 	    if (!had_match)
@@ -2537,25 +2582,25 @@ ins_compl_make_cyclic()
  * "startcol" is where the matched text starts (1 is first column).
  * "list" is the list of matches.
  */
     void
 set_completion(startcol, list)
-    int	    startcol;
+    colnr_T startcol;
     list_T  *list;
 {
     /* If already doing completions stop it. */
     if (ctrl_x_mode != 0)
 	ins_compl_prep(' ');
     ins_compl_clear();
 
     if (stop_arrow() == FAIL)
 	return;
 
-    if (startcol > (int)curwin->w_cursor.col)
+    if (startcol > curwin->w_cursor.col)
 	startcol = curwin->w_cursor.col;
     compl_col = startcol;
-    compl_length = curwin->w_cursor.col - startcol;
+    compl_length = (int)curwin->w_cursor.col - (int)startcol;
     /* compl_pattern doesn't need to be set */
     compl_orig_text = vim_strnsave(ml_get_curline() + compl_col, compl_length);
     if (compl_orig_text == NULL || ins_compl_add(compl_orig_text,
 			-1, p_ic, NULL, NULL, 0, ORIGINAL_TEXT, FALSE) != OK)
 	return;
@@ -2817,11 +2862,10 @@ ins_compl_dictionaries(dict_start, pat,
     char_u	*ptr;
     char_u	*buf;
     regmatch_T	regmatch;
     char_u	**files;
     int		count;
-    int		i;
     int		save_p_scs;
     int		dir = compl_direction;
 
     if (*dict == NUL)
     {
@@ -2849,21 +2893,22 @@ ins_compl_dictionaries(dict_start, pat,
      * to only match at the start of a line.  Otherwise just match the
      * pattern. Also need to double backslashes. */
     if (ctrl_x_mode == CTRL_X_WHOLE_LINE)
     {
 	char_u *pat_esc = vim_strsave_escaped(pat, (char_u *)"\\");
+	size_t len;
 
 	if (pat_esc == NULL)
 	    goto theend;
-	i = (int)STRLEN(pat_esc) + 10;
-	ptr = alloc(i);
+	len = STRLEN(pat_esc) + 10;
+	ptr = alloc((unsigned)len);
 	if (ptr == NULL)
 	{
 	    vim_free(pat_esc);
 	    goto theend;
 	}
-	vim_snprintf((char *)ptr, i, "^\\s*\\zs\\V%s", pat_esc);
+	vim_snprintf((char *)ptr, len, "^\\s*\\zs\\V%s", pat_esc);
 	regmatch.regprog = vim_regcomp(ptr, RE_MAGIC);
 	vim_free(pat_esc);
 	vim_free(ptr);
     }
     else
@@ -2950,11 +2995,11 @@ ins_compl_files(count, files, thesaurus,
 	fp = mch_fopen((char *)files[i], "r");  /* open dictionary file */
 	if (flags != DICT_EXACT)
 	{
 	    vim_snprintf((char *)IObuff, IOSIZE,
 			      _("Scanning dictionary: %s"), (char *)files[i]);
-	    msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
+	    (void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
 	}
 
 	if (fp != NULL)
 	{
 	    /*
@@ -3131,10 +3176,11 @@ ins_compl_free()
 	for (i = 0; i < CPT_COUNT; ++i)
 	    vim_free(match->cp_text[i]);
 	vim_free(match);
     } while (compl_curr_match != NULL && compl_curr_match != compl_first_match);
     compl_first_match = compl_curr_match = NULL;
+    compl_shown_match = NULL;
 }
 
     static void
 ins_compl_clear()
 {
@@ -3207,11 +3253,11 @@ ins_compl_bs()
     static void
 ins_compl_new_leader()
 {
     ins_compl_del_pum();
     ins_compl_delete();
-    ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
+    ins_bytes(compl_leader + ins_compl_len());
     compl_used_match = FALSE;
 
     if (compl_started)
 	ins_compl_set_original_text(compl_leader);
     else
@@ -3262,10 +3308,24 @@ ins_compl_new_leader()
     if (compl_match_array == NULL)
 	compl_enter_selects = FALSE;
 }
 
 /*
+ * Return the length of the completion, from the completion start column to
+ * the cursor column.  Making sure it never goes below zero.
+ */
+    static int
+ins_compl_len()
+{
+    int off = (int)curwin->w_cursor.col - (int)compl_col;
+
+    if (off < 0)
+	return 0;
+    return off;
+}
+
+/*
  * Append one character to the match leader.  May reduce the number of
  * matches.
  */
     static void
 ins_compl_addleader(c)
@@ -3290,11 +3350,11 @@ ins_compl_addleader(c)
     if (compl_was_interrupted)
 	ins_compl_restart();
 
     vim_free(compl_leader);
     compl_leader = vim_strnsave(ml_get_curline() + compl_col,
-					    curwin->w_cursor.col - compl_col);
+				     (int)(curwin->w_cursor.col - compl_col));
     if (compl_leader != NULL)
 	ins_compl_new_leader();
 }
 
 /*
@@ -3338,11 +3398,11 @@ ins_compl_set_original_text(str)
  */
     static void
 ins_compl_addfrommatch()
 {
     char_u	*p;
-    int		len = curwin->w_cursor.col - compl_col;
+    int		len = (int)curwin->w_cursor.col - (int)compl_col;
     int		c;
     compl_T	*cp;
 
     p = compl_shown_match->cp_str;
     if ((int)STRLEN(p) <= len)   /* the match is too short */
@@ -3619,14 +3679,13 @@ ins_compl_prep(c)
 	    /* CTRL-E means completion is Ended, go back to the typed text. */
 	    if (c == Ctrl_E)
 	    {
 		ins_compl_delete();
 		if (compl_leader != NULL)
-		    ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
+		    ins_bytes(compl_leader + ins_compl_len());
 		else if (compl_first_match != NULL)
-		    ins_bytes(compl_orig_text
-					  + curwin->w_cursor.col - compl_col);
+		    ins_bytes(compl_orig_text + ins_compl_len());
 		retval = TRUE;
 	    }
 
 	    auto_format(FALSE, TRUE);
 
@@ -3905,11 +3964,11 @@ ins_compl_get_exp(ini)
 			ins_buf->b_fname == NULL
 			    ? buf_spname(ins_buf)
 			    : ins_buf->b_sfname == NULL
 				? (char *)ins_buf->b_fname
 				: (char *)ins_buf->b_sfname);
-		msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
+		(void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
 	    }
 	    else if (*e_cpt == NUL)
 		break;
 	    else
 	    {
@@ -3934,12 +3993,12 @@ ins_compl_get_exp(ini)
 		    type = CTRL_X_PATH_DEFINES;
 #endif
 		else if (*e_cpt == ']' || *e_cpt == 't')
 		{
 		    type = CTRL_X_TAGS;
-		    sprintf((char*)IObuff, _("Scanning tags."));
-		    msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
+		    vim_snprintf((char *)IObuff, IOSIZE, _("Scanning tags."));
+		    (void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
 		}
 		else
 		    type = -1;
 
 		/* in any case e_cpt is advanced to the next entry */
@@ -3987,11 +4046,11 @@ ins_compl_get_exp(ini)
 	case CTRL_X_TAGS:
 	    /* set p_ic according to p_ic, p_scs and pat for find_tags(). */
 	    save_p_ic = p_ic;
 	    p_ic = ignorecase(compl_pattern);
 
-	    /* Find up to TAG_MANY matches.  Avoids that an enourmous number
+	    /* Find up to TAG_MANY matches.  Avoids that an enormous number
 	     * of matches is found when compl_pattern is empty */
 	    if (find_tags(compl_pattern, &num_matches, &matches,
 		    TAG_REGEXP | TAG_NAMES | TAG_NOIC |
 		    TAG_INS_COMP | (ctrl_x_mode ? TAG_VERBOSE : 0),
 		    TAG_MANY, curbuf->b_ffname) == OK && num_matches > 0)
@@ -4033,11 +4092,11 @@ ins_compl_get_exp(ini)
 #endif
 
 	case CTRL_X_SPELL:
 #ifdef FEAT_SPELL
 	    num_matches = expand_spelling(first_match_pos.lnum,
-				 first_match_pos.col, compl_pattern, &matches);
+						     compl_pattern, &matches);
 	    if (num_matches > 0)
 		ins_compl_add_matches(num_matches, matches, p_ic);
 #endif
 	    break;
 
@@ -4158,11 +4217,11 @@ ins_compl_get_exp(ini)
 								       == NULL
 						&& (IObuff[len - 2] == '?'
 						 || IObuff[len - 2] == '!'))))
 					IObuff[len++] = ' ';
 				}
-				/* copy as much as posible of the new word */
+				/* copy as much as possible of the new word */
 				if (tmp_ptr - ptr >= IOSIZE - len)
 				    tmp_ptr = ptr + IOSIZE - len - 1;
 				STRNCPY(IObuff + len, ptr, tmp_ptr - ptr);
 				len += (int)(tmp_ptr - ptr);
 				flags |= CONT_S_IPOS;
@@ -4185,11 +4244,11 @@ ins_compl_get_exp(ini)
 	    p_scs = save_p_scs;
 	    p_ws = save_p_ws;
 	}
 
 	/* check if compl_curr_match has changed, (e.g. other type of
-	 * expansion added somenthing) */
+	 * expansion added something) */
 	if (type != 0 && compl_curr_match != old_match)
 	    found_new_match = OK;
 
 	/* break the loop for specialized modes (use 'complete' just for the
 	 * generic ctrl_x_mode == 0) or when we've found a new match */
@@ -4254,11 +4313,11 @@ ins_compl_delete()
 
 /* Insert the new text being completed. */
     static void
 ins_compl_insert()
 {
-    ins_bytes(compl_shown_match->cp_str + curwin->w_cursor.col - compl_col);
+    ins_bytes(compl_shown_match->cp_str + ins_compl_len());
     if (compl_shown_match->cp_flags & ORIGINAL_TEXT)
 	compl_used_match = FALSE;
     else
 	compl_used_match = TRUE;
 }
@@ -4423,11 +4482,11 @@ ins_compl_next(allow_get_expansion, coun
     if (insert_match)
     {
 	if (!compl_get_longest || compl_used_match)
 	    ins_compl_insert();
 	else
-	    ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
+	    ins_bytes(compl_leader + ins_compl_len());
     }
     else
 	compl_used_match = FALSE;
 
     if (!allow_get_expansion)
@@ -4623,10 +4682,11 @@ ins_complete(c)
 {
     char_u	*line;
     int		startcol = 0;	    /* column where searched text starts */
     colnr_T	curs_col;	    /* cursor column */
     int		n;
+    int		save_w_wrow;
 
     compl_direction = ins_compl_key2dir(c);
     if (!compl_started)
     {
 	/* First time we hit ^N or ^P (in a row, I mean) */
@@ -4686,11 +4746,11 @@ ins_complete(c)
 		    }
 		    compl_col = compl_startpos.col;
 		}
 		compl_length = curwin->w_cursor.col - (int)compl_col;
 		/* IObuff is used to add a "word from the next line" would we
-		 * have enough space?  just being paranoic */
+		 * have enough space?  just being paranoid */
 #define	MIN_SPACE 75
 		if (compl_length > (IOSIZE - MIN_SPACE))
 		{
 		    compl_cont_status &= ~CONT_SOL;
 		    compl_length = (IOSIZE - MIN_SPACE);
@@ -4743,14 +4803,13 @@ ins_complete(c)
 	    }
 	    else if (compl_cont_status & CONT_ADDING)
 	    {
 		char_u	    *prefix = (char_u *)"\\<";
 
-		/* we need 3 extra chars, 1 for the NUL and
-		 * 2 >= strlen(prefix)	-- Acevedo */
+		/* we need up to 2 extra chars for the prefix */
 		compl_pattern = alloc(quote_meta(NULL, line + compl_col,
-							   compl_length) + 3);
+							   compl_length) + 2);
 		if (compl_pattern == NULL)
 		    return FAIL;
 		if (!vim_iswordp(line + compl_col)
 			|| (compl_col > 0
 			    && (
@@ -4821,11 +4880,11 @@ ins_complete(c)
 		    STRCAT((char *)compl_pattern, "\\k");
 		}
 		else
 		{
 		    compl_pattern = alloc(quote_meta(NULL, line + compl_col,
-							   compl_length) + 3);
+							   compl_length) + 2);
 		    if (compl_pattern == NULL)
 			return FAIL;
 		    STRCPY((char *)compl_pattern, "\\<");
 		    (void)quote_meta(compl_pattern + 2, line + compl_col,
 								compl_length);
@@ -4903,11 +4962,11 @@ ins_complete(c)
 	    curwin->w_cursor = pos;	/* restore the cursor position */
 
 	    if (col < 0)
 		col = curs_col;
 	    compl_col = col;
-	    if ((colnr_T)compl_col > curs_col)
+	    if (compl_col > curs_col)
 		compl_col = curs_col;
 
 	    /* Setup variables for completion.  Need to obtain "line" again,
 	     * it may have become invalid. */
 	    line = ml_get(curwin->w_cursor.lnum);
@@ -5007,10 +5066,11 @@ ins_complete(c)
     compl_shows_dir = compl_direction;
 
     /*
      * Find next match (and following matches).
      */
+    save_w_wrow = curwin->w_wrow;
     n = ins_compl_next(TRUE, ins_compl_key2count(c), ins_compl_use_match(c));
 
     /* may undisplay the popup menu */
     ins_compl_upd_pum();
 
@@ -5160,10 +5220,16 @@ ins_complete(c)
     if (!compl_interrupted)
     {
 	/* RedrawingDisabled may be set when invoked through complete(). */
 	n = RedrawingDisabled;
 	RedrawingDisabled = 0;
+
+	/* If the cursor moved we need to remove the pum first. */
+	setcursor();
+	if (save_w_wrow != curwin->w_wrow)
+	    ins_compl_del_pum();
+
 	ins_compl_show_pum();
 	setcursor();
 	RedrawingDisabled = n;
     }
     compl_was_interrupted = compl_interrupted;
@@ -5176,19 +5242,19 @@ ins_complete(c)
  * Looks in the first "len" chars. of "src" for search-metachars.
  * If dest is not NULL the chars. are copied there quoting (with
  * a backslash) the metachars, and dest would be NUL terminated.
  * Returns the length (needed) of dest
  */
-    static int
+    static unsigned
 quote_meta(dest, src, len)
     char_u	*dest;
     char_u	*src;
     int		len;
 {
-    int	m;
+    unsigned	m = (unsigned)len + 1;  /* one extra for the NUL */
 
-    for (m = len; --len >= 0; src++)
+    for ( ; --len >= 0; src++)
     {
 	switch (*src)
 	{
 	    case '.':
 	    case '*':
@@ -5498,11 +5564,11 @@ insertchar(c, flags, second_indent)
 	     * was called. */
 	    ins_need_undo = TRUE;
 	}
 	if (do_internal)
 #endif
-	    internal_format(textwidth, second_indent, flags, c == NUL);
+	    internal_format(textwidth, second_indent, flags, c == NUL, c);
     }
 
     if (c == NUL)	    /* only formatting was wanted */
 	return;
 
@@ -5678,15 +5744,16 @@ insertchar(c, flags, second_indent)
 
 /*
  * Format text at the current insert position.
  */
     static void
-internal_format(textwidth, second_indent, flags, format_only)
+internal_format(textwidth, second_indent, flags, format_only, c)
     int		textwidth;
     int		second_indent;
     int		flags;
     int		format_only;
+    int		c; /* character to be inserted (can be NUL) */
 {
     int		cc;
     int		save_char = NUL;
     int		haveto_redraw = FALSE;
     int		fo_ins_blank = has_format_option(FO_INS_BLANK);
@@ -5703,11 +5770,15 @@ internal_format(textwidth, second_indent
 
     /*
      * When 'ai' is off we don't want a space under the cursor to be
      * deleted.  Replace it with an 'x' temporarily.
      */
-    if (!curbuf->b_p_ai)
+    if (!curbuf->b_p_ai
+#ifdef FEAT_VREPLACE
+	    && !(State & VREPLACE_FLAG)
+#endif
+	    )
     {
 	cc = gchar_cursor();
 	if (vim_iswhite(cc))
 	{
 	    save_char = cc;
@@ -5729,13 +5800,15 @@ internal_format(textwidth, second_indent
 #ifdef FEAT_VREPLACE
 	int	orig_col = 0;
 	char_u	*saved_text = NULL;
 #endif
 	colnr_T	col;
+	colnr_T	end_col;
 
-	virtcol = get_nolist_virtcol();
-	if (virtcol < (colnr_T)textwidth)
+	virtcol = get_nolist_virtcol()
+		+ char2cells(c != NUL ? c : gchar_cursor());
+	if (virtcol <= (colnr_T)textwidth)
 	    break;
 
 #ifdef FEAT_COMMENTS
 	if (no_leader)
 	    do_comments = FALSE;
@@ -5760,42 +5833,37 @@ internal_format(textwidth, second_indent
 #ifdef FEAT_COMMENTS
 		&& leader_len == 0
 #endif
 		&& !has_format_option(FO_WRAP))
 
-	{
-	    textwidth = 0;
 	    break;
-	}
 	if ((startcol = curwin->w_cursor.col) == 0)
 	    break;
 
 	/* find column of textwidth border */
 	coladvance((colnr_T)textwidth);
 	wantcol = curwin->w_cursor.col;
 
-	curwin->w_cursor.col = startcol - 1;
-#ifdef FEAT_MBYTE
-	/* Correct cursor for multi-byte character. */
-	if (has_mbyte)
-	    mb_adjust_cursor();
-#endif
+	curwin->w_cursor.col = startcol;
 	foundcol = 0;
 
 	/*
 	 * Find position to break at.
 	 * Stop at first entered white when 'formatoptions' has 'v'
 	 */
 	while ((!fo_ins_blank && !has_format_option(FO_INS_VI))
 		    || curwin->w_cursor.lnum != Insstart.lnum
 		    || curwin->w_cursor.col >= Insstart.col)
 	{
-	    cc = gchar_cursor();
+	    if (curwin->w_cursor.col == startcol && c != NUL)
+		cc = c;
+	    else
+		cc = gchar_cursor();
 	    if (WHITECHAR(cc))
 	    {
 		/* remember position of blank just before text */
-		end_foundcol = curwin->w_cursor.col;
+		end_col = curwin->w_cursor.col;
 
 		/* find start of sequence of blanks */
 		while (curwin->w_cursor.col > 0 && WHITECHAR(cc))
 		{
 		    dec_cursor();
@@ -5811,39 +5879,77 @@ internal_format(textwidth, second_indent
 		if (has_format_option(FO_ONE_LETTER))
 		{
 		    /* do not break after one-letter words */
 		    if (curwin->w_cursor.col == 0)
 			break;	/* one-letter word at begin */
-
+#ifdef FEAT_COMMENTS
+		    /* do not break "#a b" when 'tw' is 2 */
+		    if (curwin->w_cursor.col <= leader_len)
+			break;
+#endif
 		    col = curwin->w_cursor.col;
 		    dec_cursor();
 		    cc = gchar_cursor();
 
 		    if (WHITECHAR(cc))
 			continue;	/* one-letter, continue */
 		    curwin->w_cursor.col = col;
 		}
-#ifdef FEAT_MBYTE
-		if (has_mbyte)
-		    foundcol = curwin->w_cursor.col
-					 + (*mb_ptr2len)(ml_get_cursor());
-		else
-#endif
-		    foundcol = curwin->w_cursor.col + 1;
-		if (curwin->w_cursor.col < (colnr_T)wantcol)
+
+		inc_cursor();
+
+		end_foundcol = end_col + 1;
+		foundcol = curwin->w_cursor.col;
+		if (curwin->w_cursor.col <= (colnr_T)wantcol)
 		    break;
 	    }
 #ifdef FEAT_MBYTE
-	    else if (cc >= 0x100 && fo_multibyte
-			      && curwin->w_cursor.col <= (colnr_T)wantcol)
+	    else if (cc >= 0x100 && fo_multibyte)
 	    {
 		/* Break after or before a multi-byte character. */
+		if (curwin->w_cursor.col != startcol)
+		{
+#ifdef FEAT_COMMENTS
+		    /* Don't break until after the comment leader */
+		    if (curwin->w_cursor.col < leader_len)
+			break;
+#endif
+		    col = curwin->w_cursor.col;
+		    inc_cursor();
+		    /* Don't change end_foundcol if already set. */
+		    if (foundcol != curwin->w_cursor.col)
+		    {
+			foundcol = curwin->w_cursor.col;
+			end_foundcol = foundcol;
+			if (curwin->w_cursor.col <= (colnr_T)wantcol)
+			    break;
+		    }
+		    curwin->w_cursor.col = col;
+		}
+
+		if (curwin->w_cursor.col == 0)
+		    break;
+
+		col = curwin->w_cursor.col;
+
+		dec_cursor();
+		cc = gchar_cursor();
+
+		if (WHITECHAR(cc))
+		    continue;		/* break with space */
+#ifdef FEAT_COMMENTS
+		/* Don't break until after the comment leader */
+		if (curwin->w_cursor.col < leader_len)
+		    break;
+#endif
+
+		curwin->w_cursor.col = col;
+
 		foundcol = curwin->w_cursor.col;
-		if (curwin->w_cursor.col < (colnr_T)wantcol)
-		    foundcol += (*mb_char2len)(cc);
 		end_foundcol = foundcol;
-		break;
+		if (curwin->w_cursor.col <= (colnr_T)wantcol)
+		    break;
 	    }
 #endif
 	    if (curwin->w_cursor.col == 0)
 		break;
 	    dec_cursor();
@@ -5866,18 +5972,19 @@ internal_format(textwidth, second_indent
 #ifdef FEAT_VREPLACE
 	if (State & VREPLACE_FLAG)
 	    orig_col = startcol;	/* Will start backspacing from here */
 	else
 #endif
-	    replace_offset = startcol - end_foundcol - 1;
+	    replace_offset = startcol - end_foundcol;
 
 	/*
 	 * adjust startcol for spaces that will be deleted and
 	 * characters that will remain on top line
 	 */
 	curwin->w_cursor.col = foundcol;
-	while (cc = gchar_cursor(), WHITECHAR(cc))
+	while ((cc = gchar_cursor(), WHITECHAR(cc))
+		    && (!fo_white_par || curwin->w_cursor.col < startcol))
 	    inc_cursor();
 	startcol -= curwin->w_cursor.col;
 	if (startcol < 0)
 	    startcol = 0;
 
@@ -6013,11 +6120,11 @@ auto_format(trailblank, prev_line)
     /* Don't format in Insert mode when the cursor is on a trailing blank, the
      * user might insert normal text next.  Also skip formatting when "1" is
      * in 'formatoptions' and there is a single character before the cursor.
      * Otherwise the line would be broken and when typing another non-white
      * next they are not joined back together. */
-    wasatend = (pos.col == STRLEN(old));
+    wasatend = (pos.col == (colnr_T)STRLEN(old));
     if (*old != NUL && !trailblank && wasatend)
     {
 	dec_cursor();
 	cc = gchar_cursor();
 	if (!WHITECHAR(cc) && curwin->w_cursor.col > 0
@@ -6190,11 +6297,11 @@ redo_literal(c)
 
     /* Only digits need special treatment.  Translate them into a string of
      * three digits. */
     if (VIM_ISDIGIT(c))
     {
-	sprintf((char *)buf, "%03d", c);
+	vim_snprintf((char *)buf, sizeof(buf), "%03d", c);
 	AppendToRedobuff(buf);
     }
     else
 	AppendCharToRedobuff(c);
 }
@@ -6264,11 +6371,11 @@ stop_arrow()
 	{
 	    arrow_used = FALSE;
 	    ins_need_undo = FALSE;
 	}
 	Insstart = curwin->w_cursor;	/* new insertion starts here */
-	Insstart_textlen = linetabsize(ml_get_curline());
+	Insstart_textlen = (colnr_T)linetabsize(ml_get_curline());
 	ai_col = 0;
 #ifdef FEAT_VREPLACE
 	if (State & VREPLACE_FLAG)
 	{
 	    orig_line_count = curbuf->b_ml.ml_line_count;
@@ -6367,25 +6474,30 @@ stop_insert(end_insert_pos, esc)
 	/* If a space was inserted for auto-formatting, remove it now. */
 	check_auto_format(TRUE);
 
 	/* If we just did an auto-indent, remove the white space from the end
 	 * of the line, and put the cursor back.
-	 * Do this when ESC was used or moving the cursor up/down. */
+	 * Do this when ESC was used or moving the cursor up/down.
+	 * Check for the old position still being valid, just in case the text
+	 * got changed unexpectedly. */
 	if (did_ai && (esc || (vim_strchr(p_cpo, CPO_INDENT) == NULL
-			&& curwin->w_cursor.lnum != end_insert_pos->lnum)))
+			&& curwin->w_cursor.lnum != end_insert_pos->lnum))
+		&& end_insert_pos->lnum <= curbuf->b_ml.ml_line_count)
 	{
 	    pos_T	tpos = curwin->w_cursor;
 
 	    curwin->w_cursor = *end_insert_pos;
+	    check_cursor_col();  /* make sure it is not past the line */
 	    for (;;)
 	    {
 		if (gchar_cursor() == NUL && curwin->w_cursor.col > 0)
 		    --curwin->w_cursor.col;
 		cc = gchar_cursor();
 		if (!vim_iswhite(cc))
 		    break;
-		(void)del_char(TRUE);
+		if (del_char(TRUE) == FAIL)
+		    break;  /* should not happen */
 	    }
 	    if (curwin->w_cursor.lnum != tpos.lnum)
 		curwin->w_cursor = tpos;
 	    else if (cc != NUL)
 		++curwin->w_cursor.col;	/* put cursor back on the NUL */
@@ -6393,14 +6505,15 @@ stop_insert(end_insert_pos, esc)
 #ifdef FEAT_VISUAL
 	    /* <C-S-Right> may have started Visual mode, adjust the position for
 	     * deleted characters. */
 	    if (VIsual_active && VIsual.lnum == curwin->w_cursor.lnum)
 	    {
-		cc = (int)STRLEN(ml_get_curline());
-		if (VIsual.col > (colnr_T)cc)
+		int len = (int)STRLEN(ml_get_curline());
+
+		if (VIsual.col > len)
 		{
-		    VIsual.col = cc;
+		    VIsual.col = len;
 # ifdef FEAT_VIRTUALEDIT
 		    VIsual.coladd = 0;
 # endif
 		}
 	    }
@@ -7121,13 +7234,16 @@ replace_flush()
  * Handle doing a BS for one character.
  * cc < 0: replace stack empty, just move cursor
  * cc == 0: character was inserted, delete it
  * cc > 0: character was replaced, put cc (first byte of original char) back
  * and check for more characters to be put back
+ * When "limit_col" is >= 0, don't delete before this column.  Matters when
+ * using composing characters, use del_char_after_col() instead of del_char().
  */
     static void
-replace_do_bs()
+replace_do_bs(limit_col)
+    int		limit_col;
 {
     int		cc;
 #ifdef FEAT_VREPLACE
     int		orig_len = 0;
     int		ins_len;
@@ -7151,11 +7267,11 @@ replace_do_bs()
 	}
 #endif
 #ifdef FEAT_MBYTE
 	if (has_mbyte)
 	{
-	    del_char(FALSE);
+	    (void)del_char_after_col(limit_col);
 # ifdef FEAT_VREPLACE
 	    if (State & VREPLACE_FLAG)
 		orig_len = (int)STRLEN(ml_get_cursor());
 # endif
 	    replace_push(cc);
@@ -7201,11 +7317,11 @@ replace_do_bs()
 
 	/* mark the buffer as changed and prepare for displaying */
 	changed_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);
     }
     else if (cc == 0)
-	(void)del_char(FALSE);
+	(void)del_char_after_col(limit_col);
 }
 
 #ifdef FEAT_CINDENT
 /*
  * Return TRUE if C-indenting is on.
@@ -7284,10 +7400,14 @@ in_cinkeys(keytyped, when, line_is_empty
     char_u	*p;
     char_u	*line;
     int		icase;
     int		i;
 
+    if (keytyped == NUL)
+	/* Can happen with CTRL-Y and CTRL-E on a short line. */
+	return FALSE;
+
 #ifdef FEAT_EVAL
     if (*curbuf->b_p_inde != NUL)
 	look = curbuf->b_p_indk;	/* 'indentexpr' set: use 'indentkeys' */
     else
 #endif
@@ -7644,24 +7764,20 @@ ins_reg()
      * Don't map the register name. This also prevents the mode message to be
      * deleted when ESC is hit.
      */
     ++no_mapping;
     regname = plain_vgetc();
-#ifdef FEAT_LANGMAP
     LANGMAP_ADJUST(regname, TRUE);
-#endif
     if (regname == Ctrl_R || regname == Ctrl_O || regname == Ctrl_P)
     {
 	/* Get a third key for literal register insertion */
 	literally = regname;
 #ifdef FEAT_CMDL_INFO
 	add_to_showcmd_c(literally);
 #endif
 	regname = plain_vgetc();
-#ifdef FEAT_LANGMAP
 	LANGMAP_ADJUST(regname, TRUE);
-#endif
     }
     --no_mapping;
 
 #ifdef FEAT_EVAL
     /*
@@ -8148,11 +8264,11 @@ ins_ctrl_o()
 }
 
 /*
  * If the cursor is on an indent, ^T/^D insert/delete one
  * shiftwidth.	Otherwise ^T/^D behave like a "<<" or ">>".
- * Always round the indent to 'shiftwith', this is compatible
+ * Always round the indent to 'shiftwidth', this is compatible
  * with vi.  But vi only supports ^T and ^D after an
  * autoindent, we support it everywhere.
  */
     static void
 ins_shift(c, lastc)
@@ -8237,11 +8353,11 @@ ins_bs_one(vcolp)
     {
 	/* Don't delete characters before the insert point when in
 	 * Replace mode */
 	if (curwin->w_cursor.lnum != Insstart.lnum
 		|| curwin->w_cursor.col >= Insstart.col)
-	    replace_do_bs();
+	    replace_do_bs(-1);
     }
     else
 	(void)del_char(FALSE);
 }
 
@@ -8256,10 +8372,11 @@ ins_bs(c, mode, inserted_space_p)
     int		*inserted_space_p;
 {
     linenr_T	lnum;
     int		cc;
     int		temp = 0;	    /* init for GCC */
+    colnr_T	save_col;
     colnr_T	mincol;
     int		did_backspace = FALSE;
     int		in_indent;
     int		oldState;
 #ifdef FEAT_MBYTE
@@ -8413,17 +8530,17 @@ ins_bs(c, mode, inserted_space_p)
 		/*
 		 * restore characters (blanks) deleted after cursor
 		 */
 		while (cc > 0)
 		{
-		    temp = curwin->w_cursor.col;
+		    save_col = curwin->w_cursor.col;
 #ifdef FEAT_MBYTE
 		    mb_replace_pop_ins(cc);
 #else
 		    ins_char(cc);
 #endif
-		    curwin->w_cursor.col = temp;
+		    curwin->w_cursor.col = save_col;
 		    cc = replace_pop();
 		}
 		/* restore the characters that NL replaced */
 		replace_pop_ins();
 		State = oldState;
@@ -8443,23 +8560,23 @@ ins_bs(c, mode, inserted_space_p)
 	mincol = 0;
 						/* keep indent */
 	if (mode == BACKSPACE_LINE
 		&& (curbuf->b_p_ai
 #ifdef FEAT_CINDENT
-                    || cindent_on()
+		    || cindent_on()
 #endif
 		   )
 #ifdef FEAT_RIGHTLEFT
 		&& !revins_on
 #endif
 			    )
 	{
-	    temp = curwin->w_cursor.col;
+	    save_col = curwin->w_cursor.col;
 	    beginline(BL_WHITE);
-	    if (curwin->w_cursor.col < (colnr_T)temp)
+	    if (curwin->w_cursor.col < save_col)
 		mincol = curwin->w_cursor.col;
-	    curwin->w_cursor.col = temp;
+	    curwin->w_cursor.col = save_col;
 	}
 
 	/*
 	 * Handle deleting one 'shiftwidth' or 'softtabstop'.
 	 */
@@ -8554,11 +8671,11 @@ ins_bs(c, mode, inserted_space_p)
 		    dec_cursor();
 #endif
 		break;
 	    }
 	    if (State & REPLACE_FLAG)
-		replace_do_bs();
+		replace_do_bs(-1);
 	    else
 	    {
 #ifdef FEAT_MBYTE
 		if (enc_utf8 && p_deco)
 		    (void)utfc_ptr2char(ml_get_cursor(), cpc);
@@ -8929,11 +9046,14 @@ ins_right()
 #ifdef FEAT_FOLDING
     if ((fdo_flags & FDO_HOR) && KeyTyped)
 	foldOpenCursor();
 #endif
     undisplay_dollar();
-    if (gchar_cursor() != NUL || virtual_active()
+    if (gchar_cursor() != NUL
+#ifdef FEAT_VIRTUALEDIT
+	    || virtual_active()
+#endif
 	    )
     {
 	start_arrow(&curwin->w_cursor);
 	curwin->w_set_curswant = TRUE;
 #ifdef FEAT_VIRTUALEDIT
--- vim72.orig/src/term.c
+++ vim72/src/term.c
@@ -2879,11 +2879,11 @@ ttest(pairs)
 	    T_CAF = empty_option;
 	}
 
 	/* if 'Sb' and 'AB' are not defined, reset "Co" */
 	if (*T_CSB == NUL && *T_CAB == NUL)
-	    T_CCO = empty_option;
+	    free_one_termoption(T_CCO);
 
 	/* Set 'weirdinvert' according to value of 't_xs' */
 	p_wiv = (*T_XS != NUL);
     }
     need_gather = TRUE;
@@ -2904,11 +2904,11 @@ add_long_to_buf(val, dst)
     char_u  *dst;
 {
     int	    i;
     int	    shift;
 
-    for (i = 1; i <= sizeof(long_u); i++)
+    for (i = 1; i <= (int)sizeof(long_u); i++)
     {
 	shift = 8 * (sizeof(long_u) - i);
 	dst[i - 1] = (char_u) ((val >> shift) & 0xff);
     }
 }
@@ -2935,11 +2935,11 @@ get_long_from_buf(buf, val)
 
     *val = 0;
     len = get_bytes_from_buf(buf, bytes, (int)sizeof(long_u));
     if (len != -1)
     {
-	for (i = 0; i < sizeof(long_u); i++)
+	for (i = 0; i < (int)sizeof(long_u); i++)
 	{
 	    shift = 8 * (sizeof(long_u) - 1 - i);
 	    *val += (long_u)bytes[i] << shift;
 	}
     }
@@ -4918,11 +4918,19 @@ check_termcode(max_offset, buf, buflen)
 
 	/* Finally, add the special key code to our string */
 	key_name[0] = KEY2TERMCAP0(key);
 	key_name[1] = KEY2TERMCAP1(key);
 	if (key_name[0] == KS_KEY)
-	    string[new_slen++] = key_name[1];	/* from ":set <M-b>=xx" */
+	{
+	    /* from ":set <M-b>=xx" */
+#ifdef FEAT_MBYTE
+	    if (has_mbyte)
+		new_slen += (*mb_char2bytes)(key_name[1], string + new_slen);
+	    else
+#endif
+		string[new_slen++] = key_name[1];
+	}
 	else
 	{
 	    string[new_slen++] = K_SPECIAL;
 	    string[new_slen++] = key_name[0];
 	    string[new_slen++] = key_name[1];
@@ -5545,11 +5553,11 @@ check_for_codes_from_term()
  * Translate an internal mapping/abbreviation representation into the
  * corresponding external one recognized by :map/:abbrev commands;
  * respects the current B/k/< settings of 'cpoption'.
  *
  * This function is called when expanding mappings/abbreviations on the
- * command-line, and for building the "Ambiguous mapping..." error messge.
+ * command-line, and for building the "Ambiguous mapping..." error message.
  *
  * It uses a growarray to build the translation string since the
  * latter can be wider than the original description. The caller has to
  * free the string afterwards.
  *
--- vim72.orig/src/if_ole.cpp
+++ vim72/src/if_ole.cpp
@@ -351,13 +351,17 @@ CVim::SendKeys(BSTR keys)
 	vim_free(str);
 	return E_INVALIDARG;
     }
 
     /* Pass the string to the main input loop. The memory will be freed when
-     * the message is processed.
+     * the message is processed.  Except for an empty message, we don't need
+     * to post it then.
      */
-    PostMessage(NULL, WM_OLE, 0, (LPARAM)str);
+    if (*str == NUL)
+	vim_free(str);
+    else
+	PostMessage(NULL, WM_OLE, 0, (LPARAM)str);
 
     return S_OK;
 }
 
 STDMETHODIMP
--- vim72.orig/src/Make_mvc.mak
+++ vim72/src/Make_mvc.mak
@@ -1,20 +1,20 @@
 # Makefile for Vim on Win32 (Windows NT/2000/XP/2003 and Windows 95/98/Me)
 # and Win64, using the Microsoft Visual C++ compilers. Known to work with
 # VC5, VC6 (VS98), VC7.0 (VS2002), VC7.1 (VS2003), VC8 (VS2005),
-# and VC9 (VS2008).
+# VC9 (VS2008), and VC10 (VS2010).
 #
 # To build using other Windows compilers, see INSTALLpc.txt
 #
 # This makefile can build the console, GUI, OLE-enable, Perl-enabled and
-# Python-enabled versions of vim for Win32 platforms.
+# Python-enabled versions of Vim for Win32 platforms.
 #
-# The basic command line to build vim is:
+# The basic command line to build Vim is:
 #
 #	nmake -f Make_mvc.mak
 #
-# This will build the console version of vim with no additional interfaces.
+# This will build the console version of Vim with no additional interfaces.
 # To add features, define any of the following:
 #
 #	!!!!  After changing features do "nmake clean" first  !!!!
 #
 #       Feature Set: FEATURES=[TINY, SMALL, NORMAL, BIG, HUGE] (default is BIG)
@@ -32,10 +32,11 @@
 #
 #	MzScheme interface:
 #	  MZSCHEME=[Path to MzScheme directory]
 #	  DYNAMIC_MZSCHEME=yes (to load the MzScheme DLLs dynamically)
 #	  MZSCHEME_VER=[version, 205_000, ...]
+#	  MZSCHEME_DEBUG=no
 #
 #	Perl interface:
 #	  PERL=[Path to Perl directory]
 #	  DYNAMIC_PERL=yes (to load the Perl DLL dynamically)
 #	  PERL_VER=[Perl version, in the form 55 (5.005), 56 (5.6.x), etc]
@@ -352,10 +353,19 @@ MSVCVER = 8.0
 MSVCVER = 9.0
 !endif
 !if "$(_NMAKE_VER)" == "9.00.21022.08"
 MSVCVER = 9.0
 !endif
+!if "$(_NMAKE_VER)" == "9.00.30729.01"
+MSVCVER = 9.0
+!endif
+!if "$(_NMAKE_VER)" == "10.00.20506.01"
+MSVCVER = 10.0
+!endif
+!if "$(_NMAKE_VER)" == "10.00.30128.01"
+MSVCVER = 10.0
+!endif
 !endif
 
 # Abort bulding VIM if version of VC is unrecognised.
 !ifndef MSVCVER
 !message *** ERROR
@@ -366,11 +376,11 @@ MSVCVER = 9.0
 !message to handle the new value for _NMAKE_VER, "$(_NMAKE_VER)".
 !error Make aborted.
 !endif
 
 # Convert processor ID to MVC-compatible number
-!if ("$(MSVCVER)" != "8.0") && ("$(MSVCVER)" != "9.0")
+!if ("$(MSVCVER)" != "8.0") && ("$(MSVCVER)" != "9.0") && ("$(MSVCVER)" != "10.0")
 !if "$(CPUNR)" == "i386"
 CPUARG = /G3
 !elseif "$(CPUNR)" == "i486"
 CPUARG = /G4
 !elseif "$(CPUNR)" == "i586"
@@ -399,11 +409,11 @@ OPTFLAG = /O1
 !elseif "$(OPTIMIZE)" == "SPEED"
 OPTFLAG = /O2
 !else # MAXSPEED
 OPTFLAG = /Ox
 !endif
-!if ("$(MSVCVER)" == "8.0") || ("$(MSVCVER)" == "9.0")
+!if ("$(MSVCVER)" == "8.0") || ("$(MSVCVER)" == "9.0") || ("$(MSVCVER)" == "10.0")
 # Use link time code generation if not worried about size
 !if "$(OPTIMIZE)" != "SPACE"
 OPTFLAG = $(OPTFLAG) /GL
 !endif
 !endif
@@ -616,19 +626,41 @@ PYTHON_LIB = $(PYTHON)\libs\python$(PYTH
 !message MzScheme requested - root dir is "$(MZSCHEME)"
 !ifndef MZSCHEME_VER
 MZSCHEME_VER = 205_000
 !endif
 CFLAGS = $(CFLAGS) -DFEAT_MZSCHEME -I $(MZSCHEME)\include
+!if EXIST("$(MZSCHEME)\collects\scheme\base.ss")
+# for MzScheme 4.x we need to include byte code for basic Scheme stuff
+MZSCHEME_EXTRA_DEP = mzscheme_base.c
+CFLAGS = $(CFLAGS) -DINCLUDE_MZSCHEME_BASE
+!endif
+!if EXIST("$(MZSCHEME)\lib\msvc\libmzsch$(MZSCHEME_VER).lib") \
+	&& !EXIST("$(MZSCHEME)\lib\msvc\libmzgc$(MZSCHEME_VER).lib")
+!message Building with Precise GC
+MZSCHEME_PRECISE_GC = yes
+CFLAGS = $(CFLAGS) -DMZ_PRECISE_GC
+!endif
 !if "$(DYNAMIC_MZSCHEME)" == "yes"
+!if "$(MZSCHEME_PRECISE_GC)" == "yes"
+!error MzScheme with Precise GC cannot be loaded dynamically
+!endif
 !message MzScheme DLLs will be loaded dynamically
 CFLAGS = $(CFLAGS) -DDYNAMIC_MZSCHEME \
 		-DDYNAMIC_MZSCH_DLL=\"libmzsch$(MZSCHEME_VER).dll\" \
 		-DDYNAMIC_MZGC_DLL=\"libmzgc$(MZSCHEME_VER).dll\"
 !else
+!if "$(MZSCHEME_DEBUG)" == "yes"
+CFLAGS = $(CFLAGS) -DMZSCHEME_FORCE_GC
+!endif
+!if "$(MZSCHEME_PRECISE_GC)" == "yes"
+# Precise GC does not use separate dll
+MZSCHEME_LIB = $(MZSCHEME)\lib\msvc\libmzsch$(MZSCHEME_VER).lib
+!else
 MZSCHEME_LIB = $(MZSCHEME)\lib\msvc\libmzgc$(MZSCHEME_VER).lib \
 		$(MZSCHEME)\lib\msvc\libmzsch$(MZSCHEME_VER).lib
 !endif
+!endif
 MZSCHEME_OBJ = $(OUTDIR)\if_mzsch.obj
 !endif
 
 # Perl interface
 !ifdef PERL
@@ -765,11 +797,11 @@ LINKARGS2 = $(CON_LIB) $(GUI_LIB) $(LIBC
 		$(MZSCHEME_LIB) $(PERL_LIB) $(PYTHON_LIB) $(RUBY_LIB) \
 		$(TCL_LIB) $(NETBEANS_LIB) $(XPM_LIB) $(LINK_PDB)
 
 # Report link time code generation progress if used. 
 !ifdef NODEBUG
-!if ("$(MSVCVER)" == "8.0") || ("$(MSVCVER)" == "9.0")
+!if ("$(MSVCVER)" == "8.0") || ("$(MSVCVER)" == "9.0") || ("$(MSVCVER)" == "10.0")
 !if "$(OPTIMIZE)" != "SPACE"
 LINKARGS1 = $(LINKARGS1) /LTCG:STATUS
 !endif
 !endif
 !endif
@@ -834,10 +866,11 @@ clean:
 	- if exist if_perl.c del if_perl.c
 	- if exist dimm.h del dimm.h
 	- if exist dimm_i.c del dimm_i.c
 	- if exist dimm.tlb del dimm.tlb
 	- if exist dosinst.exe del dosinst.exe
+	- if exist mzscheme_base.c del mzscheme_base.c
 	cd xxd
 	$(MAKE) /NOLOGO -f Make_mvc.mak clean
 	cd ..
 	cd GvimExt
 	$(MAKE) /NOLOGO -f Makefile clean
@@ -925,13 +958,15 @@ $(OUTDIR)/if_perl.obj: $(OUTDIR) if_perl
 	$(CC) $(CFLAGS) $(PERL_INC) if_perl.c
 
 $(OUTDIR)/if_perlsfio.obj: $(OUTDIR) if_perlsfio.c  $(INCL)
 	$(CC) $(CFLAGS) $(PERL_INC) if_perlsfio.c
 
-$(OUTDIR)/if_mzsch.obj: $(OUTDIR) if_mzsch.c  $(INCL)
+$(OUTDIR)/if_mzsch.obj: $(OUTDIR) if_mzsch.c  $(INCL) $(MZSCHEME_EXTRA_DEP)
 	$(CC) $(CFLAGS) if_mzsch.c \
 		-DMZSCHEME_COLLECTS=\"$(MZSCHEME:\=\\)\\collects\"
+mzscheme_base.c:
+	$(MZSCHEME)\mzc --c-mods mzscheme_base.c ++lib scheme/base
 
 $(OUTDIR)/if_python.obj: $(OUTDIR) if_python.c  $(INCL)
 	$(CC) $(CFLAGS) $(PYTHON_INC) if_python.c
 
 $(OUTDIR)/if_ole.obj: $(OUTDIR) if_ole.cpp  $(INCL) if_ole.h
@@ -1007,11 +1042,11 @@ $(OUTDIR)/undo.obj:	$(OUTDIR) undo.c  $(
 $(OUTDIR)/window.obj:	$(OUTDIR) window.c  $(INCL)
 
 $(OUTDIR)/xpm_w32.obj: $(OUTDIR) xpm_w32.c
 	$(CC) $(CFLAGS) $(XPM_INC) xpm_w32.c
 
-$(OUTDIR)/vim.res:	$(OUTDIR) vim.rc version.h tools.bmp tearoff.bmp \
+$(OUTDIR)/vim.res:	$(OUTDIR) vim.rc gvim.exe.mnf version.h tools.bmp tearoff.bmp \
 		vim.ico vim_error.ico vim_alert.ico vim_info.ico vim_quest.ico
 	$(RC) /l 0x409 /Fo$(OUTDIR)/vim.res $(RCFLAGS) vim.rc
 
 iid_ole.c if_ole.h vim.tlb: if_ole.idl
 	midl /nologo /error none /proxy nul /iid iid_ole.c /tlb vim.tlb \
--- vim72.orig/src/macros.h
+++ vim72/src/macros.h
@@ -125,19 +125,35 @@
 #define CHARSIZE(c)	(chartab[c] & CT_CELL_MASK)
 
 #ifdef FEAT_LANGMAP
 /*
  * Adjust chars in a language according to 'langmap' option.
- * NOTE that there is NO overhead if 'langmap' is not set; but even
- * when set we only have to do 2 ifs and an array lookup.
+ * NOTE that there is no noticeable overhead if 'langmap' is not set.
+ * When set the overhead for characters < 256 is small.
  * Don't apply 'langmap' if the character comes from the Stuff buffer.
  * The do-while is just to ignore a ';' after the macro.
  */
-# define LANGMAP_ADJUST(c, condition) do { \
-	if (*p_langmap && (condition) && !KeyStuffed && (c) >= 0 && (c) < 256) \
-	    c = langmap_mapchar[c]; \
+# ifdef FEAT_MBYTE
+#  define LANGMAP_ADJUST(c, condition) \
+    do { \
+        if (*p_langmap && (condition) && !KeyStuffed && (c) >= 0) \
+	{ \
+	    if ((c) < 256) \
+		c = langmap_mapchar[c]; \
+	    else \
+		c = langmap_adjust_mb(c); \
+	} \
     } while (0)
+# else
+#  define LANGMAP_ADJUST(c, condition) \
+    do { \
+        if (*p_langmap && (condition) && !KeyStuffed && (c) >= 0 && (c) < 256) \
+            c = langmap_mapchar[c]; \
+    } while (0)
+# endif
+#else
+# define LANGMAP_ADJUST(c, condition) /* nop */
 #endif
 
 /*
  * vim_isbreak() is used very often if 'linebreak' is set, use a macro to make
  * it work fast.
@@ -225,11 +241,11 @@
 # define ZDECODE(c)   update_keys(c ^= decrypt_byte())
 
 #endif
 
 #ifdef STARTUPTIME
-# define TIME_MSG(s) time_msg(s, NULL)
+# define TIME_MSG(s) { if (time_fd != NULL) time_msg(s, NULL); }
 #else
 # define TIME_MSG(s)
 #endif
 
 #ifdef FEAT_VREPLACE
@@ -266,11 +282,11 @@
 # define mb_ptr_back(s, p)  p -= has_mbyte ? ((*mb_head_off)(s, p - 1) + 1) : 1
 /* get length of multi-byte char, not including composing chars */
 # define mb_cptr2len(p)	    (enc_utf8 ? utf_ptr2len(p) : (*mb_ptr2len)(p))
 
 # define MB_COPY_CHAR(f, t) if (has_mbyte) mb_copy_char(&f, &t); else *t++ = *f++
-# define MB_CHARLEN(p)	    (has_mbyte ? mb_charlen(p) : STRLEN(p))
+# define MB_CHARLEN(p)	    (has_mbyte ? mb_charlen(p) : (int)STRLEN(p))
 # define PTR2CHAR(p)	    (has_mbyte ? mb_ptr2char(p) : (int)*(p))
 #else
 # define mb_ptr_adv(p)		++p
 # define mb_cptr_adv(p)		++p
 # define mb_ptr_back(s, p)	--p
--- vim72.orig/src/proto/option.pro
+++ vim72/src/proto/option.pro
@@ -27,10 +27,11 @@ char_u *get_highlight_default __ARGS((vo
 char_u *get_encoding_default __ARGS((void));
 int makeset __ARGS((FILE *fd, int opt_flags, int local_only));
 int makefoldset __ARGS((FILE *fd));
 void clear_termoptions __ARGS((void));
 void free_termoptions __ARGS((void));
+void free_one_termoption __ARGS((char_u *var));
 void set_term_defaults __ARGS((void));
 void comp_col __ARGS((void));
 char_u *get_equalprg __ARGS((void));
 void win_copy_options __ARGS((win_T *wp_from, win_T *wp_to));
 void copy_winopt __ARGS((winopt_T *from, winopt_T *to));
@@ -42,10 +43,11 @@ void reset_modifiable __ARGS((void));
 void set_iminsert_global __ARGS((void));
 void set_imsearch_global __ARGS((void));
 void set_context_in_set_cmd __ARGS((expand_T *xp, char_u *arg, int opt_flags));
 int ExpandSettings __ARGS((expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file));
 int ExpandOldSetting __ARGS((int *num_file, char_u ***file));
+int langmap_adjust_mb __ARGS((int c));
 int has_format_option __ARGS((int x));
 int shortmess __ARGS((int x));
 void vimrc_found __ARGS((char_u *fname, char_u *envname));
 void change_compatible __ARGS((int on));
 int option_was_set __ARGS((char_u *name));
--- vim72.orig/src/regexp.c
+++ vim72/src/regexp.c
@@ -469,11 +469,11 @@ get_char_class(pp)
 #define CLASS_NONE 99
     int i;
 
     if ((*pp)[1] == ':')
     {
-	for (i = 0; i < sizeof(class_names) / sizeof(*class_names); ++i)
+	for (i = 0; i < (int)(sizeof(class_names) / sizeof(*class_names)); ++i)
 	    if (STRNCMP(*pp + 2, class_names[i], STRLEN(class_names[i])) == 0)
 	    {
 		*pp += STRLEN(class_names[i]) + 2;
 		return i;
 	    }
@@ -581,10 +581,11 @@ static int	regnpar;	/* () count. */
 static int	regnzpar;	/* \z() count. */
 static int	re_has_z;	/* \z item detected */
 #endif
 static char_u	*regcode;	/* Code-emit pointer, or JUST_CALC_SIZE */
 static long	regsize;	/* Code size. */
+static int	reg_toolong;	/* TRUE when offset out of range */
 static char_u	had_endbrace[NSUBEXP];	/* flags, TRUE if end of () found */
 static unsigned	regflags;	/* RF_ flags for prog */
 static long	brace_min[10];	/* Minimums for complex brace repeats */
 static long	brace_max[10];	/* Maximums for complex brace repeats */
 static int	brace_count[10]; /* Current counts for complex brace repeats */
@@ -1026,13 +1027,15 @@ vim_regcomp(expr, re_flags)
      * Second pass: emit code.
      */
     regcomp_start(expr, re_flags);
     regcode = r->program;
     regc(REGMAGIC);
-    if (reg(REG_NOPAREN, &flags) == NULL)
+    if (reg(REG_NOPAREN, &flags) == NULL || reg_toolong)
     {
 	vim_free(r);
+	if (reg_toolong)
+	    EMSG_RET_NULL(_("E339: Pattern too long"));
 	return NULL;
     }
 
     /* Dig out information for optimizations. */
     r->regstart = NUL;		/* Worst-case defaults. */
@@ -1139,10 +1142,11 @@ regcomp_start(expr, re_flags)
 #ifdef FEAT_SYN_HL
     regnzpar = 1;
     re_has_z = 0;
 #endif
     regsize = 0L;
+    reg_toolong = FALSE;
     regflags = 0;
 #if defined(FEAT_SYN_HL) || defined(PROTO)
     had_eol = FALSE;
 #endif
 }
@@ -1226,11 +1230,11 @@ reg(paren, flagp)
     *flagp |= flags & (SPSTART | HASNL | HASLOOKBH);
     while (peekchr() == Magic('|'))
     {
 	skipchr();
 	br = regbranch(&flags);
-	if (br == NULL)
+	if (br == NULL || reg_toolong)
 	    return NULL;
 	regtail(ret, br);	/* BRANCH -> BRANCH. */
 	if (!(flags & HASWIDTH))
 	    *flagp &= ~HASWIDTH;
 	*flagp |= flags & (SPSTART | HASNL | HASLOOKBH);
@@ -1311,10 +1315,12 @@ regbranch(flagp)
 	    regtail(chain, latest);
 	if (peekchr() != Magic('&'))
 	    break;
 	skipchr();
 	regtail(latest, regnode(END)); /* operand ends */
+	if (reg_toolong)
+	    break;
 	reginsert(MATCH, latest);
 	chain = latest;
     }
 
     return ret;
@@ -1380,11 +1386,11 @@ regconcat(flagp)
 			    skipchr_keepstart();
 			    curchr = -1;
 			    break;
 	    default:
 			    latest = regpiece(&flags);
-			    if (latest == NULL)
+			    if (latest == NULL || reg_toolong)
 				return NULL;
 			    *flagp |= flags & (HASWIDTH | HASNL | HASLOOKBH);
 			    if (chain == NULL)	/* First piece. */
 				*flagp |= flags & SPSTART;
 			    else
@@ -2538,12 +2544,20 @@ regtail(p, val)
 
     if (OP(scan) == BACK)
 	offset = (int)(scan - val);
     else
 	offset = (int)(val - scan);
-    *(scan + 1) = (char_u) (((unsigned)offset >> 8) & 0377);
-    *(scan + 2) = (char_u) (offset & 0377);
+    /* When the offset uses more than 16 bits it can no longer fit in the two
+     * bytes avaliable.  Use a global flag to avoid having to check return
+     * values in too many places. */
+    if (offset > 0xffff)
+	reg_toolong = TRUE;
+    else
+    {
+	*(scan + 1) = (char_u) (((unsigned)offset >> 8) & 0377);
+	*(scan + 2) = (char_u) (offset & 0377);
+    }
 }
 
 /*
  * regoptail - regtail on item after a BRANCH; nop if none
  */
@@ -3360,16 +3374,15 @@ vim_regexec_multi(rmp, win, buf, lnum, c
 
 /*
  * Match a regexp against a string ("line" points to the string) or multiple
  * lines ("line" is NULL, use reg_getline()).
  */
-/*ARGSUSED*/
     static long
 vim_regexec_both(line, col, tm)
     char_u	*line;
     colnr_T	col;		/* column to start looking for match */
-    proftime_T	*tm;		/* timeout limit or NULL */
+    proftime_T	*tm UNUSED;	/* timeout limit or NULL */
 {
     regprog_T	*prog;
     char_u	*s;
     long	retval = 0L;
 
@@ -4530,11 +4543,11 @@ regmatch(scan)
 
 		no = op - BACKREF;
 		cleanup_subexpr();
 		if (!REG_MULTI)		/* Single-line regexp */
 		{
-		    if (reg_endp[no] == NULL)
+		    if (reg_startp[no] == NULL || reg_endp[no] == NULL)
 		    {
 			/* Backref was not set: Match an empty string. */
 			len = 0;
 		    }
 		    else
@@ -4546,11 +4559,11 @@ regmatch(scan)
 			    status = RA_NOMATCH;
 		    }
 		}
 		else				/* Multi-line regexp */
 		{
-		    if (reg_endpos[no].lnum < 0)
+		    if (reg_startpos[no].lnum < 0 || reg_endpos[no].lnum < 0)
 		    {
 			/* Backref was not set: Match an empty string. */
 			len = 0;
 		    }
 		    else
@@ -5763,18 +5776,20 @@ do_class:
     return (int)count;
 }
 
 /*
  * regnext - dig the "next" pointer out of a node
+ * Returns NULL when calculating size, when there is no next item and when
+ * there is an error.
  */
     static char_u *
 regnext(p)
     char_u  *p;
 {
     int	    offset;
 
-    if (p == JUST_CALC_SIZE)
+    if (p == JUST_CALC_SIZE || reg_toolong)
 	return NULL;
 
     offset = NEXT(p);
     if (offset == 0)
 	return NULL;
@@ -6811,10 +6826,12 @@ static int can_f_submatch = FALSE;	/* TR
 /* These pointers are used instead of reg_match and reg_mmatch for
  * reg_submatch().  Needed for when the substitution string is an expression
  * that contains a call to substitute() and submatch(). */
 static regmatch_T	*submatch_match;
 static regmmatch_T	*submatch_mmatch;
+static linenr_T		submatch_firstlnum;
+static linenr_T		submatch_maxline;
 #endif
 
 #if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) || defined(PROTO)
 /*
  * vim_regsub() - perform substitutions after a vim_regexec() or
@@ -6924,11 +6941,10 @@ vim_regsub_both(source, dest, copy, magi
 		eval_result = NULL;
 	    }
 	}
 	else
 	{
-	    linenr_T	save_reg_maxline;
 	    win_T	*save_reg_win;
 	    int		save_ireg_ic;
 
 	    vim_free(eval_result);
 
@@ -6936,11 +6952,12 @@ vim_regsub_both(source, dest, copy, magi
 	     * recursively.  Make sure submatch() gets the text from the first
 	     * level.  Don't need to save "reg_buf", because
 	     * vim_regexec_multi() can't be called recursively. */
 	    submatch_match = reg_match;
 	    submatch_mmatch = reg_mmatch;
-	    save_reg_maxline = reg_maxline;
+	    submatch_firstlnum = reg_firstlnum;
+	    submatch_maxline = reg_maxline;
 	    save_reg_win = reg_win;
 	    save_ireg_ic = ireg_ic;
 	    can_f_submatch = TRUE;
 
 	    eval_result = eval_to_string(source + 2, NULL, TRUE);
@@ -6959,11 +6976,12 @@ vim_regsub_both(source, dest, copy, magi
 		dst += STRLEN(eval_result);
 	    }
 
 	    reg_match = submatch_match;
 	    reg_mmatch = submatch_mmatch;
-	    reg_maxline = save_reg_maxline;
+	    reg_firstlnum = submatch_firstlnum;
+	    reg_maxline = submatch_maxline;
 	    reg_win = save_reg_win;
 	    ireg_ic = save_ireg_ic;
 	    can_f_submatch = FALSE;
 	}
 #endif
@@ -7194,10 +7212,35 @@ vim_regsub_both(source, dest, copy, magi
 exit:
     return (int)((dst - dest) + 1);
 }
 
 #ifdef FEAT_EVAL
+static char_u *reg_getline_submatch __ARGS((linenr_T lnum));
+
+/*
+ * Call reg_getline() with the line numbers from the submatch.  If a
+ * substitute() was used the reg_maxline and other values have been
+ * overwritten.
+ */
+    static char_u *
+reg_getline_submatch(lnum)
+    linenr_T	lnum;
+{
+    char_u *s;
+    linenr_T save_first = reg_firstlnum;
+    linenr_T save_max = reg_maxline;
+
+    reg_firstlnum = submatch_firstlnum;
+    reg_maxline = submatch_maxline;
+
+    s = reg_getline(lnum);
+
+    reg_firstlnum = save_first;
+    reg_maxline = save_max;
+    return s;
+}
+
 /*
  * Used for the submatch() function: get the string from the n'th submatch in
  * allocated memory.
  * Returns NULL when not in a ":s" command and for a non-existing submatch.
  */
@@ -7224,11 +7267,11 @@ reg_submatch(no)
 	{
 	    lnum = submatch_mmatch->startpos[no].lnum;
 	    if (lnum < 0 || submatch_mmatch->endpos[no].lnum < 0)
 		return NULL;
 
-	    s = reg_getline(lnum) + submatch_mmatch->startpos[no].col;
+	    s = reg_getline_submatch(lnum) + submatch_mmatch->startpos[no].col;
 	    if (s == NULL)  /* anti-crash check, cannot happen? */
 		break;
 	    if (submatch_mmatch->endpos[no].lnum == lnum)
 	    {
 		/* Within one line: take form start to end col. */
@@ -7250,20 +7293,20 @@ reg_submatch(no)
 		}
 		++len;
 		++lnum;
 		while (lnum < submatch_mmatch->endpos[no].lnum)
 		{
-		    s = reg_getline(lnum++);
+		    s = reg_getline_submatch(lnum++);
 		    if (round == 2)
 			STRCPY(retval + len, s);
 		    len += (int)STRLEN(s);
 		    if (round == 2)
 			retval[len] = '\n';
 		    ++len;
 		}
 		if (round == 2)
-		    STRNCPY(retval + len, reg_getline(lnum),
+		    STRNCPY(retval + len, reg_getline_submatch(lnum),
 					     submatch_mmatch->endpos[no].col);
 		len += submatch_mmatch->endpos[no].col;
 		if (round == 2)
 		    retval[len] = NUL;
 		++len;
@@ -7277,17 +7320,15 @@ reg_submatch(no)
 	    }
 	}
     }
     else
     {
-	if (submatch_match->endp[no] == NULL)
+	s = submatch_match->startp[no];
+	if (s == NULL || submatch_match->endp[no] == NULL)
 	    retval = NULL;
 	else
-	{
-	    s = submatch_match->startp[no];
 	    retval = vim_strnsave(s, (int)(submatch_match->endp[no] - s));
-	}
     }
 
     return retval;
 }
 #endif
--- vim72.orig/src/nbdebug.c
+++ vim72/src/nbdebug.c
@@ -31,11 +31,10 @@
 
 FILE		*nb_debug = NULL;
 u_int		 nb_dlevel = 0;		/* nb_debug verbosity level */
 
 void		 nbdb(char *, ...);
-void		 nbtrace(char *, ...);
 
 static int	 lookup(char *);
 #ifdef USE_NB_ERRORHANDLER
 static int	 errorHandler(Display *, XErrorEvent *);
 #endif
@@ -98,29 +97,10 @@ nbdebug_log_init(
 	}
 
 }    /* end nbdebug_log_init */
 
 
-
-
-void
-nbtrace(
-	char		*fmt,
-	...)
-{
-	va_list		 ap;
-
-	if (nb_debug!= NULL && (nb_dlevel & (NB_TRACE | NB_TRACE_VERBOSE))) {
-		va_start(ap, fmt);
-		vfprintf(nb_debug, fmt, ap);
-		va_end(ap);
-		fflush(nb_debug);
-	}
-
-}    /* end nbtrace */
-
-
 void
 nbdbg(
 	char		*fmt,
 	...)
 {
@@ -134,27 +114,10 @@ nbdbg(
 	}
 
 }    /* end nbdbg */
 
 
-void
-nbprt(
-	char		*fmt,
-	...)
-{
-	va_list		 ap;
-
-	if (nb_debug != NULL && nb_dlevel & NB_PRINT) {
-		va_start(ap, fmt);
-		vfprintf(nb_debug, fmt, ap);
-		va_end(ap);
-		fflush(nb_debug);
-	}
-
-}    /* end nbprt */
-
-
 static int
 lookup(
 	char		*file)
 {
 	char		 buf[BUFSIZ];
--- vim72.orig/src/nbdebug.h
+++ vim72/src/nbdebug.h
@@ -41,12 +41,10 @@ typedef enum {
 		WT_STOP			/* look for ~/.gvimstop if set */
 } WtWait;
 
 
 void		 nbdbg(char *, ...);
-void		 nbprt(char *, ...);
-void		 nbtrace(char *, ...);
 
 void nbdebug_wait __ARGS((u_int wait_flags, char *wait_var, u_int wait_secs));
 void nbdebug_log_init __ARGS((char *log_var, char *level_var));
 
 extern FILE	*nb_debug;
@@ -68,21 +66,7 @@ nbdbg(
 	char		*fmt,
 	...)
 {
 }
 
-void
-nbprt(
-	char		*fmt,
-	...)
-{
-}
-
-void
-nbtrace(
-	char		*fmt,
-	...)
-{
-}
-
 #endif /* NBDEBUG */
 #endif /* NBDEBUG_H */
--- vim72.orig/src/config.h.in
+++ vim72/src/config.h.in
@@ -28,16 +28,22 @@
 #undef HAVE_OUTFUNTYPE
 
 /* Define when __DATE__ " " __TIME__ can be used */
 #undef HAVE_DATE_TIME
 
+/* Define when __attribute__((unused)) can be used */
+#undef HAVE_ATTRIBUTE_UNUSED
+
 /* defined always when using configure */
 #undef UNIX
 
 /* Defined to the size of an int */
 #undef SIZEOF_INT
 
+/* Define when wchar_t is only 2 bytes. */
+#undef SMALL_WCHAR_T
+
 /*
  * If we cannot trust one of the following from the libraries, we use our
  * own safe but probably slower vim_memmove().
  */
 #undef USEBCOPY
@@ -48,10 +54,13 @@
 #undef USEMAN_S
 
 /* Define to empty if the keyword does not work.  */
 #undef const
 
+/* Define to empty if the keyword does not work.  */
+#undef volatile
+
 /* Define to `int' if <sys/types.h> doesn't define.  */
 #undef mode_t
 
 /* Define to `long' if <sys/types.h> doesn't define.  */
 #undef off_t
@@ -133,11 +142,10 @@
 #undef HAVE_BCMP
 #undef HAVE_FCHDIR
 #undef HAVE_FCHOWN
 #undef HAVE_FSEEKO
 #undef HAVE_FSYNC
-#undef HAVE_FTELLO
 #undef HAVE_GETCWD
 #undef HAVE_GETPSEUDOTTY
 #undef HAVE_GETPWNAM
 #undef HAVE_GETPWUID
 #undef HAVE_GETRLIMIT
@@ -146,10 +154,11 @@
 #undef HAVE_ICONV
 #undef HAVE_NL_LANGINFO_CODESET
 #undef HAVE_LSTAT
 #undef HAVE_MEMCMP
 #undef HAVE_MEMSET
+#undef HAVE_MKDTEMP
 #undef HAVE_NANOSLEEP
 #undef HAVE_OPENDIR
 #undef HAVE_FLOAT_FUNCS
 #undef HAVE_PUTENV
 #undef HAVE_QSORT
@@ -376,5 +385,8 @@
 /* Define name of who modified a released Vim */
 #undef MODIFIED_BY
 
 /* Define if you want XSMP interaction as well as vanilla swapfile safety */
 #undef USE_XSMP_INTERACT
+
+/* Define if fcntl()'s F_SETFD command knows about FD_CLOEXEC */
+#undef HAVE_FD_CLOEXEC
--- /dev/null
+++ vim72/src/testdir/test66.in
@@ -0,0 +1,25 @@
+
+Test for visual block shift and tab characters.
+
+STARTTEST
+:so small.vim
+/^abcdefgh
+4jI    j<<11|D
+7|a		
+7|a		   
+7|a	       	4k13|4j<
+:$-4,$w! test.out
+:$-4,$s/\s\+//g
+4kI    j<<
+7|a		
+7|a					
+7|a	       		4k13|4j3<
+:$-4,$w >> test.out
+:qa!
+ENDTEST
+
+abcdefghijklmnopqrstuvwxyz
+abcdefghijklmnopqrstuvwxyz
+abcdefghijklmnopqrstuvwxyz
+abcdefghijklmnopqrstuvwxyz
+abcdefghijklmnopqrstuvwxyz
--- /dev/null
+++ vim72/src/testdir/test66.ok
@@ -0,0 +1,10 @@
+    abcdefghijklmnopqrstuvwxyz
+abcdefghij
+    abc	    defghijklmnopqrstuvwxyz
+    abc	    defghijklmnopqrstuvwxyz
+    abc	    defghijklmnopqrstuvwxyz
+    abcdefghijklmnopqrstuvwxyz
+abcdefghij
+    abc	    defghijklmnopqrstuvwxyz
+    abc		defghijklmnopqrstuvwxyz
+    abc	    defghijklmnopqrstuvwxyz
--- vim72.orig/src/testdir/Make_amiga.mak
+++ vim72/src/testdir/Make_amiga.mak
@@ -23,11 +23,12 @@ SCRIPTS = test1.out test3.out test4.out
 		test33.out test34.out test35.out test36.out test37.out \
 		test38.out test39.out test40.out test41.out test42.out \
 		test43.out test44.out test45.out test46.out test47.out \
 		test48.out test51.out test53.out test54.out test55.out \
 		test56.out test57.out test58.out test59.out test60.out \
-		test61.out test62.out test63.out test64.out test65.out
+		test61.out test62.out test63.out test64.out test65.out \
+		test66.out test67.out test68.out test69.out
 
 .SUFFIXES: .in .out
 
 nongui:	/tmp $(SCRIPTS)
 	csh -c echo ALL DONE
@@ -108,5 +109,9 @@ test60.out: test60.in
 test61.out: test61.in
 test62.out: test62.in
 test63.out: test63.in
 test64.out: test64.in
 test65.out: test65.in
+test66.out: test66.in
+test67.out: test67.in
+test68.out: test68.in
+test69.out: test69.in
--- vim72.orig/src/testdir/Make_dos.mak
+++ vim72/src/testdir/Make_dos.mak
@@ -24,13 +24,14 @@ SCRIPTS16 =	test1.out test19.out test20.
 SCRIPTS =	test3.out test4.out test5.out test6.out test7.out \
 		test8.out test9.out test11.out test13.out test14.out \
 		test15.out test17.out test18.out test21.out test26.out \
 		test30.out test31.out test32.out test33.out test34.out \
 		test37.out test38.out test39.out test40.out test41.out \
-		test42.out test52.out test65.out
+		test42.out test52.out test65.out test66.out test67.out \
+		test68.out test69.out
 
-SCRIPTS32 =	test50.out
+SCRIPTS32 =	test50.out test70.out
 
 SCRIPTS_GUI = test16.out
 
 .SUFFIXES: .in .out
 
@@ -53,10 +54,11 @@ clean:
 	-del *.out
 	-if exist test.ok del test.ok
 	-if exist small.vim del small.vim
 	-if exist tiny.vim del tiny.vim
 	-if exist mbyte.vim del mbyte.vim
+	-if exist mzscheme.vim del mzscheme.vim
 	-del X*
 	-if exist viminfo del viminfo
 
 .in.out:
 	copy $*.ok test.ok
--- vim72.orig/src/testdir/Make_os2.mak
+++ vim72/src/testdir/Make_os2.mak
@@ -23,11 +23,12 @@ SCRIPTS = test1.out test3.out test4.out
 		test33.out test34.out test35.out test36.out test37.out \
 		test38.out test39.out test40.out test41.out test42.out \
 		test43.out test44.out test45.out test46.out test47.out \
 		test48.out test51.out test53.out test54.out test55.out \
 		test56.out test57.out test58.out test59.out test60.out \
-		test61.out test62.out test63.out test64.out test65.out
+		test61.out test62.out test63.out test64.out test65.out \
+		test66.out test67.out test68.out test69.out
 
 .SUFFIXES: .in .out
 
 all:	/tmp $(SCRIPTS)
 	@echo ALL DONE
--- vim72.orig/src/gui_beval.c
+++ vim72/src/gui_beval.c
@@ -13,15 +13,14 @@
 #if defined(FEAT_BEVAL) || defined(PROTO)
 
 /*
  * Common code, invoked when the mouse is resting for a moment.
  */
-/*ARGSUSED*/
     void
 general_beval_cb(beval, state)
     BalloonEval *beval;
-    int state;
+    int		state UNUSED;
 {
     win_T	*wp;
     int		col;
     int		use_sandbox;
     linenr_T	lnum;
@@ -549,13 +548,12 @@ target_event_cb(GtkWidget *widget, GdkEv
     }
 
     return FALSE; /* continue emission */
 }
 
-/*ARGSUSED*/
     static gint
-mainwin_event_cb(GtkWidget *widget, GdkEvent *event, gpointer data)
+mainwin_event_cb(GtkWidget *widget UNUSED, GdkEvent *event, gpointer data)
 {
     BalloonEval *beval = (BalloonEval *)data;
 
     switch (event->type)
     {
@@ -661,24 +659,24 @@ timeout_cb(gpointer data)
     requestBalloon(beval);
 
     return FALSE; /* don't call me again */
 }
 
-/*ARGSUSED2*/
     static gint
-balloon_expose_event_cb(GtkWidget *widget, GdkEventExpose *event, gpointer data)
+balloon_expose_event_cb(GtkWidget *widget,
+			GdkEventExpose *event,
+			gpointer data UNUSED)
 {
     gtk_paint_flat_box(widget->style, widget->window,
 		       GTK_STATE_NORMAL, GTK_SHADOW_OUT,
 		       &event->area, widget, "tooltip",
 		       0, 0, -1, -1);
 
     return FALSE; /* continue emission */
 }
 
 # ifndef HAVE_GTK2
-/*ARGSUSED2*/
     static void
 balloon_draw_cb(GtkWidget *widget, GdkRectangle *area, gpointer data)
 {
     GtkWidget	    *child;
     GdkRectangle    child_area;
@@ -724,17 +722,16 @@ removeEventHandler(beval)
 
 
 /*
  * The X event handler. All it does is call the real event handler.
  */
-/*ARGSUSED*/
     static void
 pointerEventEH(w, client_data, event, unused)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
     XEvent	*event;
-    Boolean	*unused;
+    Boolean	*unused UNUSED;
 {
     BalloonEval *beval = (BalloonEval *)client_data;
     pointerEvent(beval, event);
 }
 
@@ -875,15 +872,14 @@ pointerEvent(beval, event)
 	default:
 	    break;
     }
 }
 
-/*ARGSUSED*/
     static void
 timerRoutine(dx, id)
     XtPointer	    dx;
-    XtIntervalId    *id;
+    XtIntervalId    *id UNUSED;
 {
     BalloonEval *beval = (BalloonEval *)dx;
 
     beval->timerID = (XtIntervalId)NULL;
 
@@ -1289,10 +1285,27 @@ drawBalloon(beval)
 	XtVaSetValues(beval->balloonShell,
 		XtNx, tx,
 		XtNy, ty,
 		NULL);
 #endif
+	/* Set tooltip colors */
+	{
+	    Arg args[2];
+
+#ifdef FEAT_GUI_MOTIF
+	    args[0].name = XmNbackground;
+	    args[0].value = gui.tooltip_bg_pixel;
+	    args[1].name = XmNforeground;
+	    args[1].value = gui.tooltip_fg_pixel;
+#else /* Athena */
+	    args[0].name = XtNbackground;
+	    args[0].value = gui.tooltip_bg_pixel;
+	    args[1].name = XtNforeground;
+	    args[1].value = gui.tooltip_fg_pixel;
+#endif
+	    XtSetValues(beval->balloonLabel, &args[0], XtNumber(args));
+	}
 
 	XtPopup(beval->balloonShell, XtGrabNone);
 
 	beval->showState = ShS_SHOWING;
 
--- vim72.orig/src/proto/if_cscope.pro
+++ vim72/src/proto/if_cscope.pro
@@ -1,6 +1,8 @@
 /* if_cscope.c */
+char_u *get_cscope_name __ARGS((expand_T *xp, int idx));
+void set_context_in_cscope_cmd __ARGS((expand_T *xp, char_u *arg, cmdidx_T cmdidx));
 void do_cscope __ARGS((exarg_T *eap));
 void do_scscope __ARGS((exarg_T *eap));
 void do_cstag __ARGS((exarg_T *eap));
 int cs_fgets __ARGS((char_u *buf, int size));
 void cs_free_tags __ARGS((void));
--- vim72.orig/runtime/doc/if_cscop.txt
+++ vim72/runtime/doc/if_cscop.txt
@@ -1,6 +1,6 @@
-*if_cscop.txt*  For Vim version 7.2.  Last change: 2005 Mar 29
+*if_cscop.txt*  For Vim version 7.2.  Last change: 2009 Mar 18
 
 
 		  VIM REFERENCE MANUAL    by Andy Kahn
 
 							*cscope* *Cscope*
@@ -129,15 +129,26 @@ The available subcommands are:
 		4 or t: Find this text string
 		6 or e: Find this egrep pattern
 		7 or f: Find this file
 		8 or i: Find files #including this file
 
+	For all types, except 4 and 6, leading white space for {name} is
+	removed.  For 4 and 6 there is exactly one space between {querytype}
+	and {name}.  Further white space is included in {name}.
+
 	EXAMPLES >
 	    :cscope find c vim_free
-	    :cscope find 3 vim_free
+	    :cscope find 3  vim_free
+<
+	    These two examples perform the same query: functions calling
+	    "vim_free". >
+
+	    :cscope find t initOnce
+	    :cscope find t  initOnce
 <
-	    These two examples perform the same query. >
+	    The first one searches for the text "initOnce", the second one for
+	    " initOnce". >
 
 	    :cscope find 0 DEFAULT_TERM
 <
 	    Executing this example on the source code for Vim 5.1 produces the
 	    following output:
@@ -342,17 +353,12 @@ cscope version for Win32 see:
 	http://iamphet.nm.ru/cscope/index.html
 
 The DJGPP-built version from http://cscope.sourceforge.net is known to not
 work with Vim.
 
-There are a couple of hard-coded limitations:
-
-    1. The maximum number of cscope connections allowed is 8.  Do you
-    really need more?
-
-    2. Doing a |:tjump| when |:cstag| searches the tag files is not
-    configurable (e.g., you can't do a tselect instead).
+Hard-coded limitation: doing a |:tjump| when |:cstag| searches the tag files
+is not configurable (e.g., you can't do a tselect instead).
 
 ==============================================================================
 6. Suggested usage					*cscope-suggestions*
 
 Put these entries in your .vimrc (adjust the pathname accordingly to your
@@ -473,11 +479,12 @@ The cscope interface/support for Vim was
 Andy Kahn <ackahn@netapp.com>.  The original structure (as well as a tiny
 bit of code) was adapted from the cscope interface in nvi.  Please report
 any problems, suggestions, patches, et al., you have for the usage of
 cscope within Vim to him.
 							*cscope-win32*
-For a cscope version for Win32 see: http://iamphet.nm.ru/cscope/index.html
+For a cscope version for Win32 see:
+	http://code.google.com/p/cscope-win32/
 
 Win32 support was added by Sergey Khorev <sergey.khorev@gmail.com>.  Contact
 him if you have Win32-specific issues.
 
  vim:tw=78:ts=8:ft=help:norl:
--- vim72.orig/src/VisVim/Commands.cpp
+++ vim72/src/VisVim/Commands.cpp
@@ -18,100 +18,103 @@ static char THIS_FILE[] = __FILE__;
 #define CD_NONE			2	// No cd
 
 
 static BOOL g_bEnableVim = TRUE;	// Vim enabled
 static BOOL g_bDevStudioEditor = FALSE;	// Open file in Dev Studio editor simultaneously
+static BOOL g_bNewTabs = FALSE;
 static int g_ChangeDir = CD_NONE;	// CD after file open?
 
-static void VimSetEnableState (BOOL bEnableState);
-static BOOL VimOpenFile (BSTR& FileName, long LineNr);
-static DISPID VimGetDispatchId (COleAutomationControl& VimOle, char* Method);
-static void VimErrDiag (COleAutomationControl& VimOle);
-static void VimChangeDir (COleAutomationControl& VimOle, DISPID DispatchId, BSTR& FileName);
-static void DebugMsg (char* Msg, char* Arg = NULL);
+static void VimSetEnableState(BOOL bEnableState);
+static BOOL VimOpenFile(BSTR& FileName, long LineNr);
+static DISPID VimGetDispatchId(COleAutomationControl& VimOle, char* Method);
+static void VimErrDiag(COleAutomationControl& VimOle);
+static void VimChangeDir(COleAutomationControl& VimOle, DISPID DispatchId, BSTR& FileName);
+static void DebugMsg(char* Msg, char* Arg = NULL);
 
 
 /////////////////////////////////////////////////////////////////////////////
 // CCommands
 
-CCommands::CCommands ()
+CCommands::CCommands()
 {
 	// m_pApplication == NULL; M$ Code generation bug!!!
 	m_pApplication = NULL;
 	m_pApplicationEventsObj = NULL;
 	m_pDebuggerEventsObj = NULL;
 }
 
-CCommands::~CCommands ()
+CCommands::~CCommands()
 {
-	ASSERT (m_pApplication != NULL);
+	ASSERT(m_pApplication != NULL);
 	if (m_pApplication)
 	{
-		m_pApplication->Release ();
+		m_pApplication->Release();
 		m_pApplication = NULL;
 	}
 }
 
-void CCommands::SetApplicationObject (IApplication * pApplication)
+void CCommands::SetApplicationObject(IApplication * pApplication)
 {
 	// This function assumes pApplication has already been AddRef'd
 	// for us, which CDSAddIn did in it's QueryInterface call
 	// just before it called us.
 	m_pApplication = pApplication;
 	if (! m_pApplication)
 		return;
 
 	// Create Application event handlers
-	XApplicationEventsObj::CreateInstance (&m_pApplicationEventsObj);
+	XApplicationEventsObj::CreateInstance(&m_pApplicationEventsObj);
 	if (! m_pApplicationEventsObj)
 	{
-		ReportInternalError ("XApplicationEventsObj::CreateInstance");
+		ReportInternalError("XApplicationEventsObj::CreateInstance");
 		return;
 	}
-	m_pApplicationEventsObj->AddRef ();
-	m_pApplicationEventsObj->Connect (m_pApplication);
+	m_pApplicationEventsObj->AddRef();
+	m_pApplicationEventsObj->Connect(m_pApplication);
 	m_pApplicationEventsObj->m_pCommands = this;
 
 #ifdef NEVER
 	// Create Debugger event handler
 	CComPtr < IDispatch > pDebugger;
-	if (SUCCEEDED (m_pApplication->get_Debugger (&pDebugger))
+	if (SUCCEEDED(m_pApplication->get_Debugger(&pDebugger))
 	    && pDebugger != NULL)
 	{
-		XDebuggerEventsObj::CreateInstance (&m_pDebuggerEventsObj);
-		m_pDebuggerEventsObj->AddRef ();
-		m_pDebuggerEventsObj->Connect (pDebugger);
+		XDebuggerEventsObj::CreateInstance(&m_pDebuggerEventsObj);
+		m_pDebuggerEventsObj->AddRef();
+		m_pDebuggerEventsObj->Connect(pDebugger);
 		m_pDebuggerEventsObj->m_pCommands = this;
 	}
 #endif
 
 	// Get settings from registry HKEY_CURRENT_USER\Software\Vim\VisVim
-	HKEY hAppKey = GetAppKey ("Vim");
+	HKEY hAppKey = GetAppKey("Vim");
 	if (hAppKey)
 	{
-		HKEY hSectionKey = GetSectionKey (hAppKey, "VisVim");
+		HKEY hSectionKey = GetSectionKey(hAppKey, "VisVim");
 		if (hSectionKey)
 		{
-			g_bEnableVim = GetRegistryInt (hSectionKey, "EnableVim",
+			g_bEnableVim = GetRegistryInt(hSectionKey, "EnableVim",
 						       g_bEnableVim);
-			g_bDevStudioEditor = GetRegistryInt(hSectionKey,"DevStudioEditor",
-							    g_bDevStudioEditor);
-			g_ChangeDir = GetRegistryInt (hSectionKey, "ChangeDir",
+			g_bDevStudioEditor = GetRegistryInt(hSectionKey,
+					"DevStudioEditor", g_bDevStudioEditor);
+			g_bNewTabs = GetRegistryInt(hSectionKey, "NewTabs",
+						    g_bNewTabs);
+			g_ChangeDir = GetRegistryInt(hSectionKey, "ChangeDir",
 						      g_ChangeDir);
-			RegCloseKey (hSectionKey);
+			RegCloseKey(hSectionKey);
 		}
-		RegCloseKey (hAppKey);
+		RegCloseKey(hAppKey);
 	}
 }
 
-void CCommands::UnadviseFromEvents ()
+void CCommands::UnadviseFromEvents()
 {
-	ASSERT (m_pApplicationEventsObj != NULL);
+	ASSERT(m_pApplicationEventsObj != NULL);
 	if (m_pApplicationEventsObj)
 	{
-		m_pApplicationEventsObj->Disconnect (m_pApplication);
-		m_pApplicationEventsObj->Release ();
+		m_pApplicationEventsObj->Disconnect(m_pApplication);
+		m_pApplicationEventsObj->Release();
 		m_pApplicationEventsObj = NULL;
 	}
 
 #ifdef NEVER
 	if (m_pDebuggerEventsObj)
@@ -119,14 +122,14 @@ void CCommands::UnadviseFromEvents ()
 		// Since we were able to connect to the Debugger events, we
 		// should be able to access the Debugger object again to
 		// unadvise from its events (thus the VERIFY_OK below--see
 		// stdafx.h).
 		CComPtr < IDispatch > pDebugger;
-		VERIFY_OK (m_pApplication->get_Debugger (&pDebugger));
-		ASSERT (pDebugger != NULL);
-		m_pDebuggerEventsObj->Disconnect (pDebugger);
-		m_pDebuggerEventsObj->Release ();
+		VERIFY_OK(m_pApplication->get_Debugger(&pDebugger));
+		ASSERT(pDebugger != NULL);
+		m_pDebuggerEventsObj->Disconnect(pDebugger);
+		m_pDebuggerEventsObj->Release();
 		m_pDebuggerEventsObj = NULL;
 	}
 #endif
 }
 
@@ -134,365 +137,372 @@ void CCommands::UnadviseFromEvents ()
 /////////////////////////////////////////////////////////////////////////////
 // Event handlers
 
 // Application events
 
-HRESULT CCommands::XApplicationEvents::BeforeBuildStart ()
+HRESULT CCommands::XApplicationEvents::BeforeBuildStart()
 {
-	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
+	AFX_MANAGE_STATE(AfxGetStaticModuleState());
 	return S_OK;
 }
 
-HRESULT CCommands::XApplicationEvents::BuildFinish (long nNumErrors, long nNumWarnings)
+HRESULT CCommands::XApplicationEvents::BuildFinish(long nNumErrors, long nNumWarnings)
 {
-	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
+	AFX_MANAGE_STATE(AfxGetStaticModuleState());
 	return S_OK;
 }
 
-HRESULT CCommands::XApplicationEvents::BeforeApplicationShutDown ()
+HRESULT CCommands::XApplicationEvents::BeforeApplicationShutDown()
 {
-	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
+	AFX_MANAGE_STATE(AfxGetStaticModuleState());
 	return S_OK;
 }
 
 // The open document event handle is the place where the real interface work
 // is done.
 // Vim gets called from here.
 //
-HRESULT CCommands::XApplicationEvents::DocumentOpen (IDispatch * theDocument)
+HRESULT CCommands::XApplicationEvents::DocumentOpen(IDispatch * theDocument)
 {
-	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
+	AFX_MANAGE_STATE(AfxGetStaticModuleState());
 
 	if (! g_bEnableVim)
 		// Vim not enabled or empty command line entered
 		return S_OK;
 
 	// First get the current file name and line number
 
 	// Get the document object
-	CComQIPtr < ITextDocument, &IID_ITextDocument > pDoc (theDocument);
+	CComQIPtr < ITextDocument, &IID_ITextDocument > pDoc(theDocument);
 	if (! pDoc)
 		return S_OK;
 
 	BSTR FileName;
 	long LineNr = -1;
 
 	// Get the document name
-	if (FAILED (pDoc->get_FullName (&FileName)))
+	if (FAILED(pDoc->get_FullName(&FileName)))
 		return S_OK;
 
 	LPDISPATCH pDispSel;
 
 	// Get a selection object dispatch pointer
-	if (SUCCEEDED (pDoc->get_Selection (&pDispSel)))
+	if (SUCCEEDED(pDoc->get_Selection(&pDispSel)))
 	{
 		// Get the selection object
-		CComQIPtr < ITextSelection, &IID_ITextSelection > pSel (pDispSel);
+		CComQIPtr < ITextSelection, &IID_ITextSelection > pSel(pDispSel);
 
 		if (pSel)
 			// Get the selection line number
-			pSel->get_CurrentLine (&LineNr);
+			pSel->get_CurrentLine(&LineNr);
 
-		pDispSel->Release ();
+		pDispSel->Release();
 	}
 
 	// Open the file in Vim and position to the current line
-	if (VimOpenFile (FileName, LineNr))
+	if (VimOpenFile(FileName, LineNr))
 	{
 		if (! g_bDevStudioEditor)
 		{
 			// Close the document in developer studio
 			CComVariant vSaveChanges = dsSaveChangesPrompt;
 			DsSaveStatus Saved;
 
-			pDoc->Close (vSaveChanges, &Saved);
+			pDoc->Close(vSaveChanges, &Saved);
 		}
 	}
 
 	// We're done here
-	SysFreeString (FileName);
+	SysFreeString(FileName);
 	return S_OK;
 }
 
-HRESULT CCommands::XApplicationEvents::BeforeDocumentClose (IDispatch * theDocument)
+HRESULT CCommands::XApplicationEvents::BeforeDocumentClose(IDispatch * theDocument)
 {
-	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
+	AFX_MANAGE_STATE(AfxGetStaticModuleState());
 	return S_OK;
 }
 
-HRESULT CCommands::XApplicationEvents::DocumentSave (IDispatch * theDocument)
+HRESULT CCommands::XApplicationEvents::DocumentSave(IDispatch * theDocument)
 {
-	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
+	AFX_MANAGE_STATE(AfxGetStaticModuleState());
 	return S_OK;
 }
 
-HRESULT CCommands::XApplicationEvents::NewDocument (IDispatch * theDocument)
+HRESULT CCommands::XApplicationEvents::NewDocument(IDispatch * theDocument)
 {
-	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
+	AFX_MANAGE_STATE(AfxGetStaticModuleState());
 
 	if (! g_bEnableVim)
 		// Vim not enabled or empty command line entered
 		return S_OK;
 
 	// First get the current file name and line number
 
-	CComQIPtr < ITextDocument, &IID_ITextDocument > pDoc (theDocument);
+	CComQIPtr < ITextDocument, &IID_ITextDocument > pDoc(theDocument);
 	if (! pDoc)
 		return S_OK;
 
 	BSTR FileName;
 	HRESULT hr;
 
-	hr = pDoc->get_FullName (&FileName);
-	if (FAILED (hr))
+	hr = pDoc->get_FullName(&FileName);
+	if (FAILED(hr))
 		return S_OK;
 
 	// Open the file in Vim and position to the current line
-	if (VimOpenFile (FileName, 0))
+	if (VimOpenFile(FileName, 0))
 	{
 		if (! g_bDevStudioEditor)
 		{
 			// Close the document in developer studio
 			CComVariant vSaveChanges = dsSaveChangesPrompt;
 			DsSaveStatus Saved;
 
-			pDoc->Close (vSaveChanges, &Saved);
+			pDoc->Close(vSaveChanges, &Saved);
 		}
 	}
 
-	SysFreeString (FileName);
+	SysFreeString(FileName);
 	return S_OK;
 }
 
-HRESULT CCommands::XApplicationEvents::WindowActivate (IDispatch * theWindow)
+HRESULT CCommands::XApplicationEvents::WindowActivate(IDispatch * theWindow)
 {
-	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
+	AFX_MANAGE_STATE(AfxGetStaticModuleState());
 	return S_OK;
 }
 
-HRESULT CCommands::XApplicationEvents::WindowDeactivate (IDispatch * theWindow)
+HRESULT CCommands::XApplicationEvents::WindowDeactivate(IDispatch * theWindow)
 {
-	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
+	AFX_MANAGE_STATE(AfxGetStaticModuleState());
 	return S_OK;
 }
 
-HRESULT CCommands::XApplicationEvents::WorkspaceOpen ()
+HRESULT CCommands::XApplicationEvents::WorkspaceOpen()
 {
-	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
+	AFX_MANAGE_STATE(AfxGetStaticModuleState());
 	return S_OK;
 }
 
-HRESULT CCommands::XApplicationEvents::WorkspaceClose ()
+HRESULT CCommands::XApplicationEvents::WorkspaceClose()
 {
-	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
+	AFX_MANAGE_STATE(AfxGetStaticModuleState());
 	return S_OK;
 }
 
-HRESULT CCommands::XApplicationEvents::NewWorkspace ()
+HRESULT CCommands::XApplicationEvents::NewWorkspace()
 {
-	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
+	AFX_MANAGE_STATE(AfxGetStaticModuleState());
 	return S_OK;
 }
 
 // Debugger event
 
-HRESULT CCommands::XDebuggerEvents::BreakpointHit (IDispatch * pBreakpoint)
+HRESULT CCommands::XDebuggerEvents::BreakpointHit(IDispatch * pBreakpoint)
 {
-	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
+	AFX_MANAGE_STATE(AfxGetStaticModuleState());
 	return S_OK;
 }
 
 
 /////////////////////////////////////////////////////////////////////////////
 // VisVim dialog
 
 class CMainDialog : public CDialog
 {
     public:
-	CMainDialog (CWnd * pParent = NULL);	// Standard constructor
+	CMainDialog(CWnd * pParent = NULL);	// Standard constructor
 
 	//{{AFX_DATA(CMainDialog)
 	enum { IDD = IDD_ADDINMAIN };
 	int	m_ChangeDir;
 	BOOL	m_bDevStudioEditor;
+	BOOL	m_bNewTabs;
 	//}}AFX_DATA
 
 	//{{AFX_VIRTUAL(CMainDialog)
     protected:
-	virtual void DoDataExchange (CDataExchange * pDX);	// DDX/DDV support
+	virtual void DoDataExchange(CDataExchange * pDX);	// DDX/DDV support
 	//}}AFX_VIRTUAL
 
     protected:
 	//{{AFX_MSG(CMainDialog)
 	afx_msg void OnEnable();
 	afx_msg void OnDisable();
 	//}}AFX_MSG
-	DECLARE_MESSAGE_MAP ()
+	DECLARE_MESSAGE_MAP()
 };
 
-CMainDialog::CMainDialog (CWnd * pParent /* =NULL */ )
-	: CDialog (CMainDialog::IDD, pParent)
+CMainDialog::CMainDialog(CWnd * pParent /* =NULL */ )
+	: CDialog(CMainDialog::IDD, pParent)
 {
 	//{{AFX_DATA_INIT(CMainDialog)
 	m_ChangeDir = -1;
 	m_bDevStudioEditor = FALSE;
+	m_bNewTabs = FALSE;
 	//}}AFX_DATA_INIT
 }
 
-void CMainDialog::DoDataExchange (CDataExchange * pDX)
+void CMainDialog::DoDataExchange(CDataExchange * pDX)
 {
-	CDialog::DoDataExchange (pDX);
+	CDialog::DoDataExchange(pDX);
 	//{{AFX_DATA_MAP(CMainDialog)
 	DDX_Radio(pDX, IDC_CD_SOURCE_PATH, m_ChangeDir);
-	DDX_Check (pDX, IDC_DEVSTUDIO_EDITOR, m_bDevStudioEditor);
+	DDX_Check(pDX, IDC_DEVSTUDIO_EDITOR, m_bDevStudioEditor);
+	DDX_Check(pDX, IDC_NEW_TABS, m_bNewTabs);
 	//}}AFX_DATA_MAP
 }
 
-BEGIN_MESSAGE_MAP (CMainDialog, CDialog)
+BEGIN_MESSAGE_MAP(CMainDialog, CDialog)
 	//{{AFX_MSG_MAP(CMainDialog)
 	//}}AFX_MSG_MAP
-END_MESSAGE_MAP ()
+END_MESSAGE_MAP()
 
 
 /////////////////////////////////////////////////////////////////////////////
 // CCommands methods
 
-STDMETHODIMP CCommands::VisVimDialog ()
+STDMETHODIMP CCommands::VisVimDialog()
 {
-	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
+	AFX_MANAGE_STATE(AfxGetStaticModuleState());
 
 	// Use m_pApplication to access the Developer Studio Application
 	// object,
 	// and VERIFY_OK to see error strings in DEBUG builds of your add-in
 	// (see stdafx.h)
 
-	VERIFY_OK (m_pApplication->EnableModeless (VARIANT_FALSE));
+	VERIFY_OK(m_pApplication->EnableModeless(VARIANT_FALSE));
 
 	CMainDialog Dlg;
 
 	Dlg.m_bDevStudioEditor = g_bDevStudioEditor;
+	Dlg.m_bNewTabs = g_bNewTabs;
 	Dlg.m_ChangeDir = g_ChangeDir;
-	if (Dlg.DoModal () == IDOK)
+	if (Dlg.DoModal() == IDOK)
 	{
 		g_bDevStudioEditor = Dlg.m_bDevStudioEditor;
+		g_bNewTabs = Dlg.m_bNewTabs;
 		g_ChangeDir = Dlg.m_ChangeDir;
 
 		// Save settings to registry HKEY_CURRENT_USER\Software\Vim\VisVim
-		HKEY hAppKey = GetAppKey ("Vim");
+		HKEY hAppKey = GetAppKey("Vim");
 		if (hAppKey)
 		{
-			HKEY hSectionKey = GetSectionKey (hAppKey, "VisVim");
+			HKEY hSectionKey = GetSectionKey(hAppKey, "VisVim");
 			if (hSectionKey)
 			{
-				WriteRegistryInt (hSectionKey, "DevStudioEditor",
+				WriteRegistryInt(hSectionKey, "DevStudioEditor",
 						  g_bDevStudioEditor);
-				WriteRegistryInt (hSectionKey, "ChangeDir", g_ChangeDir);
-				RegCloseKey (hSectionKey);
+				WriteRegistryInt(hSectionKey, "NewTabs",
+						  g_bNewTabs);
+				WriteRegistryInt(hSectionKey, "ChangeDir", g_ChangeDir);
+				RegCloseKey(hSectionKey);
 			}
-			RegCloseKey (hAppKey);
+			RegCloseKey(hAppKey);
 		}
 	}
 
-	VERIFY_OK (m_pApplication->EnableModeless (VARIANT_TRUE));
+	VERIFY_OK(m_pApplication->EnableModeless(VARIANT_TRUE));
 	return S_OK;
 }
 
-STDMETHODIMP CCommands::VisVimEnable ()
+STDMETHODIMP CCommands::VisVimEnable()
 {
-	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
-	VimSetEnableState (true);
+	AFX_MANAGE_STATE(AfxGetStaticModuleState());
+	VimSetEnableState(true);
 	return S_OK;
 }
 
-STDMETHODIMP CCommands::VisVimDisable ()
+STDMETHODIMP CCommands::VisVimDisable()
 {
-	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
-	VimSetEnableState (false);
+	AFX_MANAGE_STATE(AfxGetStaticModuleState());
+	VimSetEnableState(false);
 	return S_OK;
 }
 
-STDMETHODIMP CCommands::VisVimToggle ()
+STDMETHODIMP CCommands::VisVimToggle()
 {
-	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
-	VimSetEnableState (! g_bEnableVim);
+	AFX_MANAGE_STATE(AfxGetStaticModuleState());
+	VimSetEnableState(! g_bEnableVim);
 	return S_OK;
 }
 
-STDMETHODIMP CCommands::VisVimLoad ()
+STDMETHODIMP CCommands::VisVimLoad()
 {
-	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
+	AFX_MANAGE_STATE(AfxGetStaticModuleState());
 
 	// Use m_pApplication to access the Developer Studio Application object,
 	// and VERIFY_OK to see error strings in DEBUG builds of your add-in
 	// (see stdafx.h)
 
 	CComBSTR bStr;
 	// Define dispatch pointers for document and selection objects
 	CComPtr < IDispatch > pDispDoc, pDispSel;
 
 	// Get a document object dispatch pointer
-	VERIFY_OK (m_pApplication->get_ActiveDocument (&pDispDoc));
+	VERIFY_OK(m_pApplication->get_ActiveDocument(&pDispDoc));
 	if (! pDispDoc)
 		return S_OK;
 
 	BSTR FileName;
 	long LineNr = -1;
 
 	// Get the document object
-	CComQIPtr < ITextDocument, &IID_ITextDocument > pDoc (pDispDoc);
+	CComQIPtr < ITextDocument, &IID_ITextDocument > pDoc(pDispDoc);
 
 	if (! pDoc)
 		return S_OK;
 
 	// Get the document name
-	if (FAILED (pDoc->get_FullName (&FileName)))
+	if (FAILED(pDoc->get_FullName(&FileName)))
 		return S_OK;
 
 	// Get a selection object dispatch pointer
-	if (SUCCEEDED (pDoc->get_Selection (&pDispSel)))
+	if (SUCCEEDED(pDoc->get_Selection(&pDispSel)))
 	{
 		// Get the selection object
-		CComQIPtr < ITextSelection, &IID_ITextSelection > pSel (pDispSel);
+		CComQIPtr < ITextSelection, &IID_ITextSelection > pSel(pDispSel);
 
 		if (pSel)
 			// Get the selection line number
-			pSel->get_CurrentLine (&LineNr);
+			pSel->get_CurrentLine(&LineNr);
 	}
 
 	// Open the file in Vim
-	VimOpenFile (FileName, LineNr);
+	VimOpenFile(FileName, LineNr);
 
-	SysFreeString (FileName);
+	SysFreeString(FileName);
 	return S_OK;
 }
 
 
 //
 // Here we do the actual processing and communication with Vim
 //
 
 // Set the enable state and save to registry
 //
-static void VimSetEnableState (BOOL bEnableState)
+static void VimSetEnableState(BOOL bEnableState)
 {
 	g_bEnableVim = bEnableState;
-	HKEY hAppKey = GetAppKey ("Vim");
+	HKEY hAppKey = GetAppKey("Vim");
 	if (hAppKey)
 	{
-		HKEY hSectionKey = GetSectionKey (hAppKey, "VisVim");
+		HKEY hSectionKey = GetSectionKey(hAppKey, "VisVim");
 		if (hSectionKey)
-			WriteRegistryInt (hSectionKey, "EnableVim", g_bEnableVim);
-		RegCloseKey (hAppKey);
+			WriteRegistryInt(hSectionKey, "EnableVim", g_bEnableVim);
+		RegCloseKey(hAppKey);
 	}
 }
 
 // Open the file 'FileName' in Vim and goto line 'LineNr'
 // 'FileName' is expected to contain an absolute DOS path including the drive
 // letter.
 // 'LineNr' must contain a valid line number or 0, e. g. for a new file
 //
-static BOOL VimOpenFile (BSTR& FileName, long LineNr)
+static BOOL VimOpenFile(BSTR& FileName, long LineNr)
 {
 
 	// OLE automation object for com. with Vim
 	// When the object goes out of scope, it's destructor destroys the OLE
 	// connection;
@@ -505,11 +515,11 @@ static BOOL VimOpenFile (BSTR& FileName,
 	// :cd D:/Src2/VisVim/
 	//
 	// Get a dispatch id for the SendKeys method of Vim;
 	// enables connection to Vim if necessary
 	DISPID DispatchId;
-	DispatchId = VimGetDispatchId (VimOle, "SendKeys");
+	DispatchId = VimGetDispatchId(VimOle, "SendKeys");
 	if (! DispatchId)
 		// OLE error, can't obtain dispatch id
 		goto OleError;
 
 	OLECHAR Buf[MAX_OLE_STR];
@@ -523,24 +533,32 @@ static BOOL VimOpenFile (BSTR& FileName,
 	VimCmd[2] = 0;
 
 #ifdef SINGLE_WINDOW
 	// Update the current file in Vim if it has been modified.
 	// Disabled, because it could write the file when you don't want to.
-	sprintf (VimCmd + 2, ":up\n");
+	sprintf(VimCmd + 2, ":up\n");
 #endif
-	if (! VimOle.Method (DispatchId, "s", TO_OLE_STR_BUF (VimCmd, Buf)))
+	if (! VimOle.Method(DispatchId, "s", TO_OLE_STR_BUF(VimCmd, Buf)))
 		goto OleError;
 
 	// Change Vim working directory to where the file is if desired
 	if (g_ChangeDir != CD_NONE)
-		VimChangeDir (VimOle, DispatchId, FileName);
+		VimChangeDir(VimOle, DispatchId, FileName);
 
 	// Make Vim open the file.
 	// In the filename convert all \ to /, put a \ before a space.
-	sprintf(VimCmd, ":drop ");
+	if (g_bNewTabs)
+	{
+		sprintf(VimCmd, ":tab drop ");
+		s = VimCmd + 11;
+	}
+	else
+	{
+		sprintf(VimCmd, ":drop ");
+		s = VimCmd + 6;
+	}
 	sprintf(FileNameTmp, "%S", (char *)FileName);
-	s = VimCmd + 6;
 	for (p = FileNameTmp; *p != '\0' && s < FileNameTmp + MAX_OLE_STR - 4;
 									  ++p)
 		if (*p == '\\')
 			*s++ = '/';
 		else
@@ -550,51 +568,51 @@ static BOOL VimOpenFile (BSTR& FileName,
 			*s++ = *p;
 		}
 	*s++ = '\n';
 	*s = '\0';
 
-	if (! VimOle.Method (DispatchId, "s", TO_OLE_STR_BUF (VimCmd, Buf)))
+	if (! VimOle.Method(DispatchId, "s", TO_OLE_STR_BUF(VimCmd, Buf)))
 		goto OleError;
 
 	if (LineNr > 0)
 	{
 		// Goto line
-		sprintf (VimCmd, ":%d\n", LineNr);
-		if (! VimOle.Method (DispatchId, "s", TO_OLE_STR_BUF (VimCmd, Buf)))
+		sprintf(VimCmd, ":%d\n", LineNr);
+		if (! VimOle.Method(DispatchId, "s", TO_OLE_STR_BUF(VimCmd, Buf)))
 			goto OleError;
 	}
 
 	// Make Vim come to the foreground
-	if (! VimOle.Method ("SetForeground"))
-		VimOle.ErrDiag ();
+	if (! VimOle.Method("SetForeground"))
+		VimOle.ErrDiag();
 
 	// We're done
 	return true;
 
     OleError:
 	// There was an OLE error
 	// Check if it's the "unknown class string" error
-	VimErrDiag (VimOle);
+	VimErrDiag(VimOle);
 	return false;
 }
 
 // Return the dispatch id for the Vim method 'Method'
 // Create the Vim OLE object if necessary
 // Returns a valid dispatch id or null on error
 //
-static DISPID VimGetDispatchId (COleAutomationControl& VimOle, char* Method)
+static DISPID VimGetDispatchId(COleAutomationControl& VimOle, char* Method)
 {
 	// Initialize Vim OLE connection if not already done
-	if (! VimOle.IsCreated ())
+	if (! VimOle.IsCreated())
 	{
-		if (! VimOle.CreateObject ("Vim.Application"))
+		if (! VimOle.CreateObject("Vim.Application"))
 			return NULL;
 	}
 
 	// Get the dispatch id for the SendKeys method.
 	// By doing this, we are checking if Vim is still there...
-	DISPID DispatchId = VimOle.GetDispatchId ("SendKeys");
+	DISPID DispatchId = VimOle.GetDispatchId("SendKeys");
 	if (! DispatchId)
 	{
 		// We can't get a dispatch id.
 		// This means that probably Vim has been terminated.
 		// Don't issue an error message here, instead
@@ -602,62 +620,62 @@ static DISPID VimGetDispatchId (COleAuto
 		//
 		// In fact, this should never happen, because the OLE aut. object
 		// should not be kept long enough to allow the user to terminate Vim
 		// to avoid memory corruption (why the heck is there no system garbage
 		// collection for those damned OLE memory chunks???).
-		VimOle.DeleteObject ();
-		if (! VimOle.CreateObject ("Vim.Application"))
+		VimOle.DeleteObject();
+		if (! VimOle.CreateObject("Vim.Application"))
 			// If this create fails, it's time for an error msg
 			return NULL;
 
-		if (! (DispatchId = VimOle.GetDispatchId ("SendKeys")))
+		if (! (DispatchId = VimOle.GetDispatchId("SendKeys")))
 			// There is something wrong...
 			return NULL;
 	}
 
 	return DispatchId;
 }
 
 // Output an error message for an OLE error
 // Check on the classstring error, which probably means Vim wasn't registered.
 //
-static void VimErrDiag (COleAutomationControl& VimOle)
+static void VimErrDiag(COleAutomationControl& VimOle)
 {
-	SCODE sc = GetScode (VimOle.GetResult ());
+	SCODE sc = GetScode(VimOle.GetResult());
 	if (sc == CO_E_CLASSSTRING)
 	{
 		char Buf[256];
-		sprintf (Buf, "There is no registered OLE automation server named "
+		sprintf(Buf, "There is no registered OLE automation server named "
 			 "\"Vim.Application\".\n"
 			 "Use the OLE-enabled version of Vim with VisVim and "
 			 "make sure to register Vim by running \"vim -register\".");
-		MessageBox (NULL, Buf, "OLE Error", MB_OK);
+		MessageBox(NULL, Buf, "OLE Error", MB_OK);
 	}
 	else
-		VimOle.ErrDiag ();
+		VimOle.ErrDiag();
 }
 
 // Change directory to the directory the file 'FileName' is in or it's parent
 // directory according to the setting of the global 'g_ChangeDir':
 // 'FileName' is expected to contain an absolute DOS path including the drive
 // letter.
 //	CD_NONE
 //	CD_SOURCE_PATH
 //	CD_SOURCE_PARENT
 //
-static void VimChangeDir (COleAutomationControl& VimOle, DISPID DispatchId, BSTR& FileName)
+static void VimChangeDir(COleAutomationControl& VimOle, DISPID DispatchId, BSTR& FileName)
 {
 	// Do a :cd first
 
 	// Get the path name of the file ("dir/")
 	CString StrFileName = FileName;
 	char Drive[_MAX_DRIVE];
 	char Dir[_MAX_DIR];
 	char DirUnix[_MAX_DIR * 2];
 	char *s, *t;
 
-	_splitpath (StrFileName, Drive, Dir, NULL, NULL);
+	_splitpath(StrFileName, Drive, Dir, NULL, NULL);
 
 	// Convert to Unix path name format, escape spaces.
 	t = DirUnix;
 	for (s = Dir; *s; ++s)
 		if (*s == '\\')
@@ -674,21 +692,20 @@ static void VimChangeDir (COleAutomation
 	// Construct the cd command; append /.. if cd to parent
 	// directory and not in root directory
 	OLECHAR Buf[MAX_OLE_STR];
 	char VimCmd[MAX_OLE_STR];
 
-	sprintf (VimCmd, ":cd %s%s%s\n", Drive, DirUnix,
+	sprintf(VimCmd, ":cd %s%s%s\n", Drive, DirUnix,
 		 g_ChangeDir == CD_SOURCE_PARENT && DirUnix[1] ? ".." : "");
-	VimOle.Method (DispatchId, "s", TO_OLE_STR_BUF (VimCmd, Buf));
+	VimOle.Method(DispatchId, "s", TO_OLE_STR_BUF(VimCmd, Buf));
 }
 
 #ifdef _DEBUG
 // Print out a debug message
 //
-static void DebugMsg (char* Msg, char* Arg)
+static void DebugMsg(char* Msg, char* Arg)
 {
 	char Buf[400];
-	sprintf (Buf, Msg, Arg);
-	AfxMessageBox (Buf);
+	sprintf(Buf, Msg, Arg);
+	AfxMessageBox(Buf);
 }
 #endif
-
--- vim72.orig/src/VisVim/Resource.h
+++ vim72/src/VisVim/Resource.h
@@ -14,10 +14,11 @@
 #define IDD_ADDINMAIN			130
 #define IDC_DEVSTUDIO_EDITOR		1000
 #define IDC_CD_SOURCE_PATH		1001
 #define IDC_CD_SOURCE_PARENT		1002
 #define IDC_CD_NONE			1003
+#define IDC_NEW_TABS			1004
 
 // Next default values for new objects
 //
 #ifdef APSTUDIO_INVOKED
 #ifndef APSTUDIO_READONLY_SYMBOLS
--- vim72.orig/src/VisVim/VisVim.rc
+++ vim72/src/VisVim/VisVim.rc
@@ -120,10 +120,13 @@ CAPTION "Vim Add-In 1.4"
 FONT 8, "MS Sans Serif"
 BEGIN
     CONTROL         "&Open file in DevStudio editor simultaneously",
                     IDC_DEVSTUDIO_EDITOR,"Button",BS_AUTOCHECKBOX | WS_GROUP | 
                     WS_TABSTOP,7,7,153,10
+    CONTROL         "Open files in new tabs",
+                    IDC_NEW_TABS,"Button",BS_AUTOCHECKBOX | WS_GROUP |
+                    WS_TABSTOP,7,21,153,10
     GROUPBOX        "Current directory",IDC_STATIC,7,35,164,58,WS_GROUP
     CONTROL         "Set to &source file path",IDC_CD_SOURCE_PATH,"Button",
                     BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP,17,49,85,10
     CONTROL         "Set to &parent directory of source file path",
                     IDC_CD_SOURCE_PARENT,"Button",BS_AUTORADIOBUTTON,17,63,
--- vim72.orig/src/proto/message.pro
+++ vim72/src/proto/message.pro
@@ -52,10 +52,11 @@ void repeat_message __ARGS((void));
 void msg_clr_eos __ARGS((void));
 void msg_clr_eos_force __ARGS((void));
 void msg_clr_cmdline __ARGS((void));
 int msg_end __ARGS((void));
 void msg_check __ARGS((void));
+int redirecting __ARGS((void));
 void verbose_enter __ARGS((void));
 void verbose_leave __ARGS((void));
 void verbose_enter_scroll __ARGS((void));
 void verbose_leave_scroll __ARGS((void));
 void verbose_stop __ARGS((void));
--- vim72.orig/src/memline.c
+++ vim72/src/memline.c
@@ -380,11 +380,11 @@ ml_open(buf)
 
     dp = (DATA_BL *)(hp->bh_data);
     dp->db_index[0] = --dp->db_txt_start;	/* at end of block */
     dp->db_free -= 1 + INDEX_SIZE;
     dp->db_line_count = 1;
-    *((char_u *)dp + dp->db_txt_start) = NUL;	/* emtpy line */
+    *((char_u *)dp + dp->db_txt_start) = NUL;	/* empty line */
 
     return OK;
 
 error:
     if (mfp != NULL)
@@ -488,10 +488,17 @@ ml_setname(buf)
 	{
 	    /* could not (re)open the swap file, what can we do???? */
 	    EMSG(_("E301: Oops, lost the swap file!!!"));
 	    return;
 	}
+#ifdef HAVE_FD_CLOEXEC
+	{
+	    int fdflags = fcntl(mfp->mf_fd, F_GETFD);
+	    if (fdflags >= 0 && (fdflags & FD_CLOEXEC) == 0)
+		fcntl(mfp->mf_fd, F_SETFD, fdflags | FD_CLOEXEC);
+	}
+#endif
     }
     if (!success)
 	EMSG(_("E302: Could not rename swap file"));
 }
 
@@ -862,25 +869,28 @@ ml_recover()
     int		attr;
 
     recoverymode = TRUE;
     called_from_main = (curbuf->b_ml.ml_mfp == NULL);
     attr = hl_attr(HLF_E);
-/*
- * If the file name ends in ".sw?" we use it directly.
- * Otherwise a search is done to find the swap file(s).
- */
+
+    /*
+     * If the file name ends in ".s[uvw][a-z]" we assume this is the swap file.
+     * Otherwise a search is done to find the swap file(s).
+     */
     fname = curbuf->b_fname;
     if (fname == NULL)		    /* When there is no file name */
 	fname = (char_u *)"";
     len = (int)STRLEN(fname);
     if (len >= 4 &&
 #if defined(VMS) || defined(RISCOS)
-	    STRNICMP(fname + len - 4, "_sw" , 3)
+	    STRNICMP(fname + len - 4, "_s" , 2)
 #else
-	    STRNICMP(fname + len - 4, ".sw" , 3)
+	    STRNICMP(fname + len - 4, ".s" , 2)
 #endif
-		== 0)
+		== 0
+		&& vim_strchr((char_u *)"UVWuvw", fname[len - 2]) != NULL
+		&& ASCII_ISALPHA(fname[len - 1]))
     {
 	directly = TRUE;
 	fname = vim_strsave(fname); /* make a copy for mf_open() */
     }
     else
@@ -1280,22 +1290,23 @@ ml_recover()
 		    }
 
 		    for (i = 0; i < dp->db_line_count; ++i)
 		    {
 			txt_start = (dp->db_index[i] & DB_INDEX_MASK);
-			if (txt_start <= HEADER_SIZE
+			if (txt_start <= (int)HEADER_SIZE
 					  || txt_start >= (int)dp->db_txt_end)
 			{
 			    p = (char_u *)"???";
 			    ++error;
 			}
 			else
 			    p = (char_u *)dp + txt_start;
 			ml_append(lnum++, p, (colnr_T)0, TRUE);
 		    }
 		    if (has_error)
-			ml_append(lnum++, (char_u *)_("???END"), (colnr_T)0, TRUE);
+			ml_append(lnum++, (char_u *)_("???END"),
+							    (colnr_T)0, TRUE);
 		}
 	    }
 	}
 
 	if (buf->b_ml.ml_stack_top == 0)	/* finished */
@@ -1552,14 +1563,19 @@ recover_names(fname, list, nr)
 			       && (p = curbuf->b_ml.ml_mfp->mf_fname) != NULL)
 	{
 	    for (i = 0; i < num_files; ++i)
 		if (fullpathcmp(p, files[i], TRUE) & FPC_SAME)
 		{
+		    /* Remove the name from files[i].  Move further entries
+		     * down.  When the array becomes empty free it here, since
+		     * FreeWild() won't be called below. */
 		    vim_free(files[i]);
-		    --num_files;
-		    for ( ; i < num_files; ++i)
-			files[i] = files[i + 1];
+		    if (--num_files == 0)
+			vim_free(files);
+		    else
+			for ( ; i < num_files; ++i)
+			    files[i] = files[i + 1];
 		}
 	}
 	if (nr > 0)
 	{
 	    file_count += num_files;
@@ -2095,16 +2111,16 @@ errorret:
 	lnum = 1;
 
     if (buf->b_ml.ml_mfp == NULL)	/* there are no lines */
 	return (char_u *)"";
 
-/*
- * See if it is the same line as requested last time.
- * Otherwise may need to flush last used line.
- * Don't use the last used line when 'swapfile' is reset, need to load all
- * blocks.
- */
+    /*
+     * See if it is the same line as requested last time.
+     * Otherwise may need to flush last used line.
+     * Don't use the last used line when 'swapfile' is reset, need to load all
+     * blocks.
+     */
     if (buf->b_ml.ml_line_lnum != lnum || mf_dont_release)
     {
 	ml_flush_line(buf);
 
 	/*
@@ -3069,16 +3085,23 @@ ml_flush_line(buf)
     int		extra;
     int		idx;
     int		start;
     int		count;
     int		i;
+    static int  entered = FALSE;
 
     if (buf->b_ml.ml_line_lnum == 0 || buf->b_ml.ml_mfp == NULL)
 	return;		/* nothing to do */
 
     if (buf->b_ml.ml_flags & ML_LINE_DIRTY)
     {
+	/* This code doesn't work recursively, but Netbeans may call back here
+	 * when obtaining the cursor position. */
+	if (entered)
+	    return;
+	entered = TRUE;
+
 	lnum = buf->b_ml.ml_line_lnum;
 	new_line = buf->b_ml.ml_line_ptr;
 
 	hp = ml_find_line(buf, lnum, ML_FIND);
 	if (hp == NULL)
@@ -3142,10 +3165,12 @@ ml_flush_line(buf)
 					     (dp->db_index[idx] & DB_MARKED));
 		(void)ml_delete_int(buf, lnum, FALSE);
 	    }
 	}
 	vim_free(new_line);
+
+	entered = FALSE;
     }
 
     buf->b_ml.ml_line_lnum = 0;
 }
 
@@ -3520,11 +3545,11 @@ resolve_symlink(fname, buf)
 	if (ret <= 0)
 	{
 	    if (errno == EINVAL || errno == ENOENT)
 	    {
 		/* Found non-symlink or not existing file, stop here.
-		 * When at the first level use the unmodifed name, skip the
+		 * When at the first level use the unmodified name, skip the
 		 * call to vim_FullName(). */
 		if (depth == 1)
 		    return FAIL;
 
 		/* Use the resolved name in tmp[]. */
@@ -3566,15 +3591,14 @@ resolve_symlink(fname, buf)
 
 /*
  * Make swap file name out of the file name and a directory name.
  * Returns pointer to allocated memory or NULL.
  */
-/*ARGSUSED*/
     char_u *
 makeswapname(fname, ffname, buf, dir_name)
     char_u	*fname;
-    char_u	*ffname;
+    char_u	*ffname UNUSED;
     buf_T	*buf;
     char_u	*dir_name;
 {
     char_u	*r, *s;
 #ifdef HAVE_READLINK
@@ -3764,12 +3788,14 @@ do_swapexists(buf, fname)
 {
     set_vim_var_string(VV_SWAPNAME, fname, -1);
     set_vim_var_string(VV_SWAPCHOICE, NULL, -1);
 
     /* Trigger SwapExists autocommands with <afile> set to the file being
-     * edited. */
+     * edited.  Disallow changing directory here. */
+    ++allbuf_lock;
     apply_autocmds(EVENT_SWAPEXISTS, buf->b_fname, NULL, FALSE, NULL);
+    --allbuf_lock;
 
     set_vim_var_string(VV_SWAPNAME, NULL, -1);
 
     switch (*get_vim_var_str(VV_SWAPCHOICE))
     {
@@ -3791,10 +3817,11 @@ do_swapexists(buf, fname)
  * Several names are tried to find one that does not exist
  * Returns the name in allocated memory or NULL.
  *
  * Note: If BASENAMELEN is not correct, you will get error messages for
  *	 not being able to open the swapfile
+ * Note: May trigger SwapExists autocmd, pointers may change!
  */
     static char_u *
 findswapname(buf, dirp, old_fname)
     buf_T	*buf;
     char_u	**dirp;		/* pointer to list of directories */
@@ -4558,11 +4585,11 @@ ml_updatechunk(buf, line, len, updtype)
 
 	    mch_memmove(buf->b_ml.ml_chunksize + curix + 1,
 			buf->b_ml.ml_chunksize + curix,
 			(buf->b_ml.ml_usedchunks - curix) *
 			sizeof(chunksize_T));
-	    /* Compute length of first half of lines in the splitted chunk */
+	    /* Compute length of first half of lines in the split chunk */
 	    size = 0;
 	    linecnt = 0;
 	    while (curline < buf->b_ml.ml_line_count
 			&& linecnt < MLCS_MINL)
 	    {
--- vim72.orig/src/search.c
+++ vim72/src/search.c
@@ -343,10 +343,19 @@ restore_search_patterns()
     void
 free_search_patterns()
 {
     vim_free(spats[0].pat);
     vim_free(spats[1].pat);
+
+# ifdef FEAT_RIGHTLEFT
+    if (mr_pattern_alloced)
+    {
+        vim_free(mr_pattern);
+        mr_pattern_alloced = FALSE;
+        mr_pattern = NULL;
+    }
+# endif
 }
 #endif
 
 /*
  * Return TRUE when case should be ignored for search pattern "pat".
@@ -511,11 +520,10 @@ last_pat_prog(regmatch)
  *
  * Return FAIL (zero) for failure, non-zero for success.
  * When FEAT_EVAL is defined, returns the index of the first matching
  * subpattern plus one; one if there was none.
  */
-/*ARGSUSED*/
     int
 searchit(win, buf, pos, dir, pat, count, options, pat_use, stop_lnum, tm)
     win_T	*win;		/* window to search in; can be NULL for a
 				   buffer without a window! */
     buf_T	*buf;
@@ -524,11 +532,11 @@ searchit(win, buf, pos, dir, pat, count,
     char_u	*pat;
     long	count;
     int		options;
     int		pat_use;	/* which pattern to use when "pat" is empty */
     linenr_T	stop_lnum;	/* stop after this line number when != 0 */
-    proftime_T	*tm;		/* timeout limit or NULL */
+    proftime_T	*tm UNUSED;	/* timeout limit or NULL */
 {
     int		found;
     linenr_T	lnum;		/* no init to shut up Apollo cc */
     regmmatch_T	regmatch;
     char_u	*ptr;
@@ -543,12 +551,10 @@ searchit(win, buf, pos, dir, pat, count,
     long	nmatched;
     int		submatch = 0;
     int		save_called_emsg = called_emsg;
 #ifdef FEAT_SEARCH_EXTRA
     int		break_loop = FALSE;
-#else
-# define break_loop FALSE
 #endif
 
     if (search_regcomp(pat, RE_SEARCH, pat_use,
 		   (options & (SEARCH_HIS + SEARCH_KEEP)), &regmatch) == FAIL)
     {
@@ -929,11 +935,14 @@ searchit(win, buf, pos, dir, pat, count,
 	     * Stop the search if wrapscan isn't set, "stop_lnum" is
 	     * specified, after an interrupt, after a match and after looping
 	     * twice.
 	     */
 	    if (!p_ws || stop_lnum != 0 || got_int || called_emsg
-					       || break_loop || found || loop)
+#ifdef FEAT_SEARCH_EXTRA
+					       || break_loop
+#endif
+					       || found || loop)
 		break;
 
 	    /*
 	     * If 'wrapscan' is set we continue at the other end of the file.
 	     * If 'shortmess' does not contain 's', we give a message.
@@ -947,11 +956,15 @@ searchit(win, buf, pos, dir, pat, count,
 		lnum = 1;
 	    if (!shortmess(SHM_SEARCH) && (options & SEARCH_MSG))
 		give_warning((char_u *)_(dir == BACKWARD
 					  ? top_bot_msg : bot_top_msg), TRUE);
 	}
-	if (got_int || called_emsg || break_loop)
+	if (got_int || called_emsg
+#ifdef FEAT_SEARCH_EXTRA
+		|| break_loop
+#endif
+		)
 	    break;
     }
     while (--count > 0 && found);   /* stop after count matches or no match */
 
     vim_free(regmatch.regprog);
@@ -2325,12 +2338,12 @@ findmatchlimit(oap, initc, flags, maxtra
 		if (!cpo_bsl)
 		{
 		    for (col = pos.col; check_prevcol(linep, col, '\\', &col);)
 			bslcnt++;
 		}
-		/* Only accept a match when 'M' is in 'cpo' or when ecaping is
-		 * what we expect. */
+		/* Only accept a match when 'M' is in 'cpo' or when escaping
+		 * is what we expect. */
 		if (cpo_bsl || (bslcnt & 1) == match_escaped)
 		{
 		    if (c == initc)
 			count++;
 		    else
@@ -4512,16 +4525,15 @@ linewhite(lnum)
 #if defined(FEAT_FIND_ID) || defined(PROTO)
 /*
  * Find identifiers or defines in included files.
  * if p_ic && (compl_cont_status & CONT_SOL) then ptr must be in lowercase.
  */
-/*ARGSUSED*/
     void
 find_pattern_in_path(ptr, dir, len, whole, skip_comments,
 				    type, count, action, start_lnum, end_lnum)
     char_u	*ptr;		/* pointer to search pattern */
-    int		dir;		/* direction of expansion */
+    int		dir UNUSED;	/* direction of expansion */
     int		len;		/* length of search pattern */
     int		whole;		/* match whole words only */
     int		skip_comments;	/* don't match inside comments */
     int		type;		/* Type of search; are we looking for a type?
 				   a macro? */
@@ -4661,11 +4673,11 @@ find_pattern_in_path(ptr, dir, len, whol
 				action == ACTION_SHOW_ALL && files[i].matched)
 			{
 			    msg_putchar('\n');	    /* cursor below last one */
 			    if (!got_int)	    /* don't display if 'q'
 						       typed at "--more--"
-						       mesage */
+						       message */
 			    {
 				msg_home_replace_hl(new_fname);
 				MSG_PUTS(_(" (includes previously listed match)"));
 				prev_fname = NULL;
 			    }
@@ -4973,11 +4985,11 @@ search_line:
 				    || (vim_strchr(p_cpo, CPO_JOINSP) == NULL
 					&& (IObuff[i-2] == '?'
 					    || IObuff[i-2] == '!'))))
 				IObuff[i++] = ' ';
 			}
-			/* copy as much as posible of the new word */
+			/* copy as much as possible of the new word */
 			if (p - aux >= IOSIZE - i)
 			    p = aux + IOSIZE - i - 1;
 			STRNCPY(IObuff + i, aux, p - aux);
 			i += (int)(p - aux);
 			reuse |= CONT_S_IPOS;
@@ -5008,11 +5020,11 @@ search_line:
 		if (curr_fname != prev_fname)
 		{
 		    if (did_show)
 			msg_putchar('\n');	/* cursor below last one */
 		    if (!got_int)		/* don't display if 'q' typed
-						    at "--more--" mesage */
+						    at "--more--" message */
 			msg_home_replace_hl(curr_fname);
 		    prev_fname = curr_fname;
 		}
 		did_show = TRUE;
 		if (!got_int)
@@ -5090,11 +5102,11 @@ search_line:
 			curwin->w_cursor.lnum = files[depth].lnum;
 		    }
 		}
 		if (action != ACTION_SHOW)
 		{
-		    curwin->w_cursor.col = (colnr_T) (startp - line);
+		    curwin->w_cursor.col = (colnr_T)(startp - line);
 		    curwin->w_set_curswant = TRUE;
 		}
 
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
 		if (g_do_tagpreview != 0
@@ -5117,11 +5129,12 @@ exit_matched:
 	    if (def_regmatch.regprog == NULL
 #ifdef FEAT_INS_EXPAND
 		    && action == ACTION_EXPAND
 		    && !(compl_cont_status & CONT_SOL)
 #endif
-		    && *(p = startp + 1))
+		    && *startp != NUL
+		    && *(p = startp + 1) != NUL)
 		goto search_line;
 	}
 	line_breakcheck();
 #ifdef FEAT_INS_EXPAND
 	if (action == ACTION_EXPAND)
--- vim72.orig/src/Makefile
+++ vim72/src/Makefile
@@ -103,12 +103,12 @@
 #	  solution for a non-standard system.
 #
 # 4. "make test"  {{{1
 #	This is optional.  This will run Vim scripts on a number of test
 #	files, and compare the produced output with the expected output.
-#	If all is well, you will get the "ALL DONE" message in the end.  See
-#	below (search for "/^test").
+#	If all is well, you will get the "ALL DONE" message in the end.  If a
+#	test fails you get "TEST FAILURE".  See below (search for "/^test").
 #
 # 5. "make install"  {{{1
 #	If the new Vim seems to be working OK you can install it and the
 #	documentation in the appropriate location. The default is
 #	"/usr/local".  Change "prefix" below to change the location.
@@ -393,11 +393,13 @@ CClink = $(CC)
 #CONF_OPT_TCL = --enable-tclinterp
 #CONF_OPT_TCL = --enable-tclinterp --with-tclsh=tclsh8.4
 
 # RUBY
 # Uncomment this when you want to include the Ruby interface.
-#CONF_OPT_RUBY = --enable-rubyinterp
+# Note: you need the development package (e.g., ruby1.9.1-dev on Ubuntu).
+# CONF_OPT_RUBY = --enable-rubyinterp
+# CONF_OPT_RUBY = --enable-rubyinterp --with-ruby-command=ruby1.9.1
 
 # MZSCHEME
 # Uncomment this when you want to include the MzScheme interface.
 #CONF_OPT_MZSCHEME = --enable-mzschemeinterp
 # PLT/mrscheme/drscheme Home dir; the PLTHOME environment variable also works
@@ -531,10 +533,15 @@ CClink = $(CC)
 #CFLAGS = -g -Wall -Wmissing-prototypes
 #CFLAGS = -O6 -fno-strength-reduce -Wall -Wshadow -Wmissing-prototypes
 #CFLAGS = -g -DDEBUG -Wall -Wshadow -Wmissing-prototypes
 #CFLAGS = -g -O2 '-DSTARTUPTIME="vimstartup"' -fno-strength-reduce -Wall -Wmissing-prototypes
 
+# Use this with GCC to check for mistakes, unused arguments, etc.
+#CFLAGS = -g -Wall -Wextra -Wmissing-prototypes -Wunreachable-code
+#PYTHON_CFLAGS_EXTRA = -Wno-missing-field-initializers
+#MZSCHEME_CFLAGS_EXTRA = -Wno-unreachable-code -Wno-unused-parameter
+
 # EFENCE - Electric-Fence malloc debugging: catches memory accesses beyond
 # allocated memory (and makes every malloc()/free() very slow).
 # Electric Fence is free (search ftp sites).
 # You may want to set the EF_PROTECT_BELOW environment variable to check the
 # other side of allocated memory.
@@ -549,11 +556,17 @@ CClink = $(CC)
 #EXTRA_DEFS = -DNBDEBUG
 
 # }}}
 
 # LINT - for running lint
+#  For standard Unix lint
+LINT = lint
 LINT_OPTIONS = -beprxzF
+#  For splint
+#  It doesn't work well, crashes on include files and non-ascii characters.
+#LINT = splint
+#LINT_OPTIONS = +unixlib -weak -macrovarprefixexclude -showfunc -linelen 9999
 
 # PROFILING - Uncomment the next two lines to do profiling with gcc and gprof.
 # Might not work with GUI or Perl.
 # For unknown reasons adding "-lc" fixes a linking problem with GCC.  That's
 # probably a bug in the "-pg" implementation.
@@ -1257,20 +1270,20 @@ CPP_DEPEND = $(CC) -I$(srcdir) -M$(CPP_M
 
 # flags for cproto
 #     This is for cproto 3 patchlevel 8 or below
 #     __inline, __attribute__ and __extension__ are not recognized by cproto
 #     G_IMPLEMENT_INLINES is to avoid functions defined in glib/gutils.h.
-NO_ATTR = -D__inline= -D__inline__= -DG_IMPLEMENT_INLINES \
-	  -D"__attribute__\\(x\\)=" -D"__asm__\\(x\\)=" \
-	  -D__extension__= -D__restrict="" \
-	  -D__gnuc_va_list=char -D__builtin_va_list=char
+#NO_ATTR = -D__inline= -D__inline__= -DG_IMPLEMENT_INLINES \
+#	  -D"__attribute__\\(x\\)=" -D"__asm__\\(x\\)=" \
+#	  -D__extension__= -D__restrict="" \
+#	  -D__gnuc_va_list=char -D__builtin_va_list=char
 
 #
-#     This is for cproto 3 patchlevel 9 or above (currently 4.6)
+#     This is for cproto 3 patchlevel 9 or above (currently 4.6, 4.7g)
 #     __inline and __attribute__ are now recognized by cproto
 #     -D"foo()=" is not supported by all compilers so do not use it
-# NO_ATTR=
+NO_ATTR=
 #
 #     maybe the "/usr/bin/cc -E" has to be adjusted for some systems
 # This is for cproto 3.5 patchlevel 3:
 # PROTO_FLAGS = -f4 -m__ARGS -d -E"$(CPP)" $(NO_ATTR)
 #
@@ -1430,10 +1443,11 @@ ALL_SRC = $(BASIC_SRC) $(ALL_GUI_SRC) $(
 # The perl sources also don't work well with lint.
 LINT_SRC = $(BASIC_SRC) $(GUI_SRC) $(HANGULIN_SRC) $(PYTHON_SRC) $(TCL_SRC) \
 	$(SNIFF_SRC) $(WORKSHOP_SRC) $(WSDEBUG_SRC) $(NETBEANS_SRC)
 #LINT_SRC = $(SRC)
 #LINT_SRC = $(ALL_SRC)
+#LINT_SRC = $(BASIC_SRC)
 
 OBJ = \
 	objects/buffer.o \
 	objects/charset.o \
 	objects/diff.o \
@@ -1735,11 +1749,12 @@ types.vim: $(TAGS_SRC) $(TAGS_INCL)
 #
 # This will produce a lot of garbage on your screen, including a few error
 # messages.  Don't worry about that.
 # If there is a real error, there will be a difference between "test.out" and
 # a "test99.ok" file.
-# If everything is alright, the final message will be "ALL DONE".
+# If everything is alright, the final message will be "ALL DONE".  If not you
+# get "TEST FAILURE".
 #
 test check:
 	$(MAKE) -f Makefile $(VIMTARGET)
 	-if test -n "$(MAKEMO)" -a -f $(PODIR)/Makefile; then \
 		cd $(PODIR); $(MAKE) -f Makefile check VIM=../$(VIMTARGET); \
@@ -2185,10 +2200,11 @@ uninstall_runtime:
 clean celan: testclean
 	-rm -f *.o objects/* core $(VIMTARGET).core $(VIMTARGET) vim xxd/*.o
 	-rm -f $(TOOLS) auto/osdef.h auto/pathdef.c auto/if_perl.c
 	-rm -f conftest* *~ auto/link.sed
 	-rm -rf $(APPDIR)
+	-rm -rf mzscheme_base.c
 	if test -d $(PODIR); then \
 		cd $(PODIR); $(MAKE) prefix=$(DESTDIR)$(prefix) clean; \
 	fi
 
 # Make a shadow directory for compilation on another system or with different
@@ -2270,16 +2286,16 @@ depend:
 		sed -e 's+^\([^ ]*\.o\)+objects/\1+' >> tmp_make; done
 	mv tmp_make Makefile
 
 # Run lint.  Clean up the *.ln files that are sometimes left behind.
 lint:
-	lint $(LINT_OPTIONS) $(LINT_CFLAGS) $(LINT_EXTRA) $(LINT_SRC)
+	$(LINT) $(LINT_OPTIONS) $(LINT_CFLAGS) $(LINT_EXTRA) $(LINT_SRC)
 	-rm -f *.ln
 
 # Check dosinst.c with lint.
 lintinstall:
-	lint $(LINT_OPTIONS) -DWIN32 -DUNIX_LINT dosinst.c
+	$(LINT) $(LINT_OPTIONS) -DWIN32 -DUNIX_LINT dosinst.c
 	-rm -f dosinst.ln
 
 ###########################################################################
 
 .c.o:
@@ -2418,21 +2434,24 @@ objects/if_cscope.o: if_cscope.c
 	$(CCC) -o $@ if_cscope.c
 
 objects/if_xcmdsrv.o: if_xcmdsrv.c
 	$(CCC) -o $@ if_xcmdsrv.c
 
-objects/if_mzsch.o: if_mzsch.c
-	$(CCC) -o $@ if_mzsch.c
+objects/if_mzsch.o: if_mzsch.c $(MZSCHEME_EXTRA)
+	$(CCC) -o $@ $(MZSCHEME_CFLAGS_EXTRA) if_mzsch.c
+
+mzscheme_base.c:
+	$(MZSCHEME_MZC) --c-mods mzscheme_base.c ++lib scheme/base
 
 objects/if_perl.o: auto/if_perl.c
 	$(CCC) -o $@ auto/if_perl.c
 
 objects/if_perlsfio.o: if_perlsfio.c
 	$(CCC) -o $@ if_perlsfio.c
 
 objects/if_python.o: if_python.c
-	$(CCC) -o $@ if_python.c
+	$(CCC) -o $@ $(PYTHON_CFLAGS_EXTRA) if_python.c
 
 objects/if_ruby.o: if_ruby.c
 	$(CCC) -o $@ if_ruby.c
 
 objects/if_sniff.o: if_sniff.c
--- vim72.orig/src/charset.c
+++ vim72/src/charset.c
@@ -15,11 +15,11 @@ static int win_chartabsize __ARGS((win_T
 
 #ifdef FEAT_MBYTE
 static int win_nolbr_chartabsize __ARGS((win_T *wp, char_u *s, colnr_T col, int *headp));
 #endif
 
-static int nr2hex __ARGS((int c));
+static unsigned nr2hex __ARGS((unsigned c));
 
 static int    chartab_initialized = FALSE;
 
 /* b_chartab[] is an array of 32 bytes, each bit representing one of the
  * characters 0-255. */
@@ -172,21 +172,31 @@ buf_init_chartab(buf, global)
 		++p;
 	    }
 	    if (VIM_ISDIGIT(*p))
 		c = getdigits(&p);
 	    else
+#ifdef FEAT_MBYTE
+		 if (has_mbyte)
+		c = mb_ptr2char_adv(&p);
+	    else
+#endif
 		c = *p++;
 	    c2 = -1;
 	    if (*p == '-' && p[1] != NUL)
 	    {
 		++p;
 		if (VIM_ISDIGIT(*p))
 		    c2 = getdigits(&p);
 		else
+#ifdef FEAT_MBYTE
+		     if (has_mbyte)
+		    c2 = mb_ptr2char_adv(&p);
+		else
+#endif
 		    c2 = *p++;
 	    }
-	    if (c <= 0 || (c2 < c && c2 != -1) || c2 >= 256
+	    if (c <= 0 || c >= 256 || (c2 < c && c2 != -1) || c2 >= 256
 						 || !(*p == NUL || *p == ','))
 		return FAIL;
 
 	    if (c2 == -1)	/* not a range */
 	    {
@@ -662,23 +672,23 @@ transchar_hex(buf, c)
 	buf[++i] = nr2hex((unsigned)c >> 12);
 	buf[++i] = nr2hex((unsigned)c >> 8);
     }
 #endif
     buf[++i] = nr2hex((unsigned)c >> 4);
-    buf[++i] = nr2hex(c);
+    buf[++i] = nr2hex((unsigned)c);
     buf[++i] = '>';
     buf[++i] = NUL;
 }
 
 /*
  * Convert the lower 4 bits of byte "c" to its hex character.
  * Lower case letters are used to avoid the confusion of <F1> being 0xf1 or
  * function key 1.
  */
-    static int
+    static unsigned
 nr2hex(c)
-    int		c;
+    unsigned	c;
 {
     if ((c & 0xf) <= 9)
 	return (c & 0xf) + '0';
     return (c & 0xf) - 10 + 'a';
 }
@@ -882,11 +892,11 @@ vim_iswordc(c)
 {
 #ifdef FEAT_MBYTE
     if (c >= 0x100)
     {
 	if (enc_dbcs != 0)
-	    return dbcs_class((unsigned)c >> 8, c & 0xff) >= 2;
+	    return dbcs_class((unsigned)c >> 8, (unsigned)(c & 0xff)) >= 2;
 	if (enc_utf8)
 	    return utf_class(c) >= 2;
     }
 #endif
     return (c > 0 && c < 0x100 && GET_CHARTAB(curbuf, c) != 0);
@@ -1024,17 +1034,16 @@ lbr_chartabsize_adv(s, col)
  *
  * If "headp" not NULL, set *headp to the size of what we for 'showbreak'
  * string at start of line.  Warning: *headp is only set if it's a non-zero
  * value, init to 0 before calling.
  */
-/*ARGSUSED*/
     int
 win_lbr_chartabsize(wp, s, col, headp)
     win_T	*wp;
     char_u	*s;
     colnr_T	col;
-    int		*headp;
+    int		*headp UNUSED;
 {
 #ifdef FEAT_LINEBREAK
     int		c;
     int		size;
     colnr_T	col2;
@@ -1088,11 +1097,11 @@ win_lbr_chartabsize(wp, s, col, headp)
 	 * Count all characters from first non-blank after a blank up to next
 	 * non-blank after a blank.
 	 */
 	numberextra = win_col_off(wp);
 	col2 = col;
-	colmax = W_WIDTH(wp) - numberextra;
+	colmax = (colnr_T)(W_WIDTH(wp) - numberextra);
 	if (col >= colmax)
 	{
 	    n = colmax + win_col_off2(wp);
 	    if (n > 0)
 		colmax += (((col - colmax) / n) + 1) * n;
@@ -1199,23 +1208,25 @@ win_nolbr_chartabsize(wp, s, col, headp)
     int
 in_win_border(wp, vcol)
     win_T	*wp;
     colnr_T	vcol;
 {
-    colnr_T	width1;		/* width of first line (after line number) */
-    colnr_T	width2;		/* width of further lines */
+    int		width1;		/* width of first line (after line number) */
+    int		width2;		/* width of further lines */
 
 #ifdef FEAT_VERTSPLIT
     if (wp->w_width == 0)	/* there is no border */
 	return FALSE;
 #endif
     width1 = W_WIDTH(wp) - win_col_off(wp);
-    if (vcol < width1 - 1)
+    if ((int)vcol < width1 - 1)
 	return FALSE;
-    if (vcol == width1 - 1)
+    if ((int)vcol == width1 - 1)
 	return TRUE;
     width2 = width1 + win_col_off2(wp);
+    if (width2 <= 0)
+	return FALSE;
     return ((vcol - width1) % width2 == width2 - 1);
 }
 #endif /* FEAT_MBYTE */
 
 /*
@@ -1242,11 +1253,14 @@ getvcol(wp, pos, start, cursor, end)
     int		ts = wp->w_buffer->b_p_ts;
     int		c;
 
     vcol = 0;
     ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);
-    posptr = ptr + pos->col;
+    if (pos->col == MAXCOL)
+	posptr = NULL;  /* continue until the NUL */
+    else
+	posptr = ptr + pos->col;
 
     /*
      * This function is used very often, do some speed optimizations.
      * When 'list', 'linebreak' and 'showbreak' are not set use a simple loop.
      * Also use this when 'list' is set but tabs take their normal size.
@@ -1300,11 +1314,11 @@ getvcol(wp, pos, start, cursor, end)
 		else
 #endif
 		    incr = CHARSIZE(c);
 	    }
 
-	    if (ptr >= posptr)	/* character at pos->col */
+	    if (posptr != NULL && ptr >= posptr) /* character at pos->col */
 		break;
 
 	    vcol += incr;
 	    mb_ptr_adv(ptr);
 	}
@@ -1321,11 +1335,11 @@ getvcol(wp, pos, start, cursor, end)
 	    {
 		incr = 1;	/* NUL at end of line only takes one column */
 		break;
 	    }
 
-	    if (ptr >= posptr)	/* character at pos->col */
+	    if (posptr != NULL && ptr >= posptr) /* character at pos->col */
 		break;
 
 	    vcol += incr;
 	    mb_ptr_adv(ptr);
 	}
@@ -1394,17 +1408,17 @@ getvvcol(wp, pos, start, cursor, end)
 	coladd = pos->coladd;
 	endadd = 0;
 # ifdef FEAT_MBYTE
 	/* Cannot put the cursor on part of a wide character. */
 	ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);
-	if (pos->col < STRLEN(ptr))
+	if (pos->col < (colnr_T)STRLEN(ptr))
 	{
 	    int c = (*mb_ptr2char)(ptr + pos->col);
 
 	    if (c != TAB && vim_isprintc(c))
 	    {
-		endadd = char2cells(c) - 1;
+		endadd = (colnr_T)(char2cells(c) - 1);
 		if (coladd > endadd)	/* past end of line */
 		    endadd = 0;
 		else
 		    coladd = 0;
 	    }
--- vim72.orig/src/digraph.c
+++ vim72/src/digraph.c
@@ -30,11 +30,11 @@ typedef struct digraph
 
 static int getexactdigraph __ARGS((int, int, int));
 static void printdigraph __ARGS((digr_T *));
 
 /* digraphs added by the user */
-static garray_T	user_digraphs = {0, 0, sizeof(digr_T), 10, NULL};
+static garray_T	user_digraphs = {0, 0, (int)sizeof(digr_T), 10, NULL};
 
 /*
  * Note: Characters marked with XX are not included literally, because some
  * compilers cannot handle them (Amiga SAS/C is the most picky one).
  */
@@ -2369,14 +2369,14 @@ printdigraph(dp)
 		*p++ = ' ';
 	    p += (*mb_char2bytes)(dp->result, p);
 	}
 	else
 #endif
-	    *p++ = dp->result;
+	    *p++ = (char_u)dp->result;
 	if (char2cells(dp->result) == 1)
 	    *p++ = ' ';
-	sprintf((char *)p, " %3d", dp->result);
+	vim_snprintf((char *)p, sizeof(buf) - (p - buf), " %3d", dp->result);
 	msg_outtrans(buf);
     }
 }
 
 #endif /* FEAT_DIGRAPHS */
@@ -2393,11 +2393,14 @@ typedef struct
 #define KMAP_MAXLEN 20	    /* maximum length of "from" or "to" */
 
 static void keymap_unload __ARGS((void));
 
 /*
- * Set up key mapping tables for the 'keymap' option
+ * Set up key mapping tables for the 'keymap' option.
+ * Returns NULL if OK, an error message for failure.  This only needs to be
+ * used when setting the option, not later when the value has already been
+ * checked.
  */
     char_u *
 keymap_init()
 {
     curbuf->b_kmap_state &= ~KEYMAP_INIT;
@@ -2410,29 +2413,33 @@ keymap_init()
 	do_cmdline_cmd((char_u *)"unlet! b:keymap_name");
     }
     else
     {
 	char_u	*buf;
+	size_t  buflen;
 
 	/* Source the keymap file.  It will contain a ":loadkeymap" command
 	 * which will call ex_loadkeymap() below. */
-	buf = alloc((unsigned)(STRLEN(curbuf->b_p_keymap)
+	buflen = STRLEN(curbuf->b_p_keymap)
 # ifdef FEAT_MBYTE
-						       + STRLEN(p_enc)
+					   + STRLEN(p_enc)
 # endif
-						       + 14));
+						       + 14;
+	buf = alloc((unsigned)buflen);
 	if (buf == NULL)
 	    return e_outofmem;
 
 # ifdef FEAT_MBYTE
 	/* try finding "keymap/'keymap'_'encoding'.vim"  in 'runtimepath' */
-	sprintf((char *)buf, "keymap/%s_%s.vim", curbuf->b_p_keymap, p_enc);
+	vim_snprintf((char *)buf, buflen, "keymap/%s_%s.vim",
+						   curbuf->b_p_keymap, p_enc);
 	if (source_runtime(buf, FALSE) == FAIL)
 # endif
 	{
 	    /* try finding "keymap/'keymap'.vim" in 'runtimepath'  */
-	    sprintf((char *)buf, "keymap/%s.vim", curbuf->b_p_keymap);
+	    vim_snprintf((char *)buf, buflen, "keymap/%s.vim",
+							  curbuf->b_p_keymap);
 	    if (source_runtime(buf, FALSE) == FAIL)
 	    {
 		vim_free(buf);
 		return (char_u *)N_("E544: Keymap file not found");
 	    }
--- vim72.orig/src/os_unix.h
+++ vim72/src/os_unix.h
@@ -122,11 +122,11 @@
 #  define SIGPROTOARG	(int, int, struct sigcontext *)
 #  define SIGDEFARG(s)	(s, sig2, scont) int s, sig2; struct sigcontext *scont;
 #  define SIGDUMMYARG	0, 0, (struct sigcontext *)0
 # else
 #  define SIGPROTOARG	(int)
-#  define SIGDEFARG(s)	(s) int s;
+#  define SIGDEFARG(s)	(s) int s UNUSED;
 #  define SIGDUMMYARG	0
 # endif
 #else
 # define SIGPROTOARG   (void)
 # define SIGDEFARG(s)  ()
@@ -480,15 +480,10 @@ typedef struct dsc$descriptor   DESC;
 # ifdef HAVE_RENAME
 #  define mch_rename(src, dst) rename(src, dst)
 # else
 int mch_rename __ARGS((const char *src, const char *dest));
 # endif
-# ifdef VMS
-#  define mch_chdir(s) chdir(vms_fixfilename(s))
-# else
-#  define mch_chdir(s) chdir(s)
-# endif
 # ifndef VMS
 #  ifdef __MVS__
   /* on OS390 Unix getenv() doesn't return a pointer to persistent
    * storage -> use __getenv() */
 #   define mch_getenv(x) (char_u *)__getenv((char *)(x))
--- vim72.orig/src/proto/edit.pro
+++ vim72/src/proto/edit.pro
@@ -6,11 +6,11 @@ void display_dollar __ARGS((colnr_T col)
 void change_indent __ARGS((int type, int amount, int round, int replaced, int call_changed_bytes));
 void truncate_spaces __ARGS((char_u *line));
 void backspace_until_column __ARGS((int col));
 int vim_is_ctrl_x_key __ARGS((int c));
 int ins_compl_add_infercase __ARGS((char_u *str, int len, int icase, char_u *fname, int dir, int flags));
-void set_completion __ARGS((int startcol, list_T *list));
+void set_completion __ARGS((colnr_T startcol, list_T *list));
 void ins_compl_show_pum __ARGS((void));
 char_u *find_word_start __ARGS((char_u *ptr));
 char_u *find_word_end __ARGS((char_u *ptr));
 int ins_compl_active __ARGS((void));
 int ins_compl_add_tv __ARGS((typval_T *tv, int dir));
--- vim72.orig/src/proto/spell.pro
+++ vim72/src/proto/spell.pro
@@ -20,7 +20,7 @@ void ex_spellinfo __ARGS((exarg_T *eap))
 void ex_spelldump __ARGS((exarg_T *eap));
 void spell_dump_compl __ARGS((buf_T *buf, char_u *pat, int ic, int *dir, int dumpflags_arg));
 char_u *spell_to_word_end __ARGS((char_u *start, buf_T *buf));
 int spell_word_start __ARGS((int startcol));
 void spell_expand_check_cap __ARGS((colnr_T col));
-int expand_spelling __ARGS((linenr_T lnum, int col, char_u *pat, char_u ***matchp));
+int expand_spelling __ARGS((linenr_T lnum, char_u *pat, char_u ***matchp));
 /* vim: set ft=c : */
--- vim72.orig/src/ex_eval.c
+++ vim72/src/ex_eval.c
@@ -58,11 +58,13 @@ static char_u	*get_end_emsg __ARGS((stru
 # define THROW_ON_INTERRUPT	(!eval_to_number("$VIMNOINTTHROW"))
 # define THROW_TEST
 #else
 /* Values used for the Vim release. */
 # define THROW_ON_ERROR		TRUE
+# define THROW_ON_ERROR_TRUE
 # define THROW_ON_INTERRUPT	TRUE
+# define THROW_ON_INTERRUPT_TRUE
 #endif
 
 static void	catch_exception __ARGS((except_T *excp));
 static void	finish_exception __ARGS((except_T *excp));
 static void	discard_exception __ARGS((except_T *excp, int was_finished));
@@ -1318,20 +1320,24 @@ do_throw(cstack)
      * if a previous error or interrupt has not been converted to an exception,
      * inactivate the try conditional, too, as if the conversion had been done,
      * and reset the did_emsg or got_int flag, so this won't happen again at
      * the next surrounding try conditional.
      */
+#ifndef THROW_ON_ERROR_TRUE
     if (did_emsg && !THROW_ON_ERROR)
     {
 	inactivate_try = TRUE;
 	did_emsg = FALSE;
     }
+#endif
+#ifndef THROW_ON_INTERRUPT_TRUE
     if (got_int && !THROW_ON_INTERRUPT)
     {
 	inactivate_try = TRUE;
 	got_int = FALSE;
     }
+#endif
     idx = cleanup_conditionals(cstack, 0, inactivate_try);
     if (idx >= 0)
     {
 	/*
 	 * If this try conditional is active and we are before its first
@@ -2252,14 +2258,13 @@ rewind_conditionals(cstack, idx, cond_ty
 }
 
 /*
  * ":endfunction" when not after a ":function"
  */
-/*ARGSUSED*/
     void
 ex_endfunction(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     EMSG(_("E193: :endfunction not inside a function"));
 }
 
 /*
--- vim72.orig/src/farsi.c
+++ vim72/src/farsi.c
@@ -101,11 +101,12 @@ toF_Xor_X_(c)
 	case IE_:
 		return _IE;
 	case F_HE:
 		tempc = _HE;
 
-		if (p_ri && (curwin->w_cursor.col+1 < STRLEN(ml_get_curline())))
+		if (p_ri && (curwin->w_cursor.col + 1
+					 < (colnr_T)STRLEN(ml_get_curline())))
 		{
 		    inc_cursor();
 
 		    if (F_is_TyB_TyC_TyD(SRC_EDT, AT_CURSOR))
 			tempc = _HE_;
@@ -342,11 +343,11 @@ put_curr_and_l_to_X(c)
     int	tempc;
 
     if (curwin->w_p_rl && p_ri)
 	return;
 
-    if ( (curwin->w_cursor.col < STRLEN(ml_get_curline())))
+    if ((curwin->w_cursor.col < (colnr_T)STRLEN(ml_get_curline())))
     {
 	if ((p_ri && curwin->w_cursor.col) || !p_ri)
 	{
 	    if (p_ri)
 		dec_cursor();
@@ -563,11 +564,11 @@ chg_c_to_X_or_X ()
 {
     int	tempc;
 
     tempc = gchar_cursor();
 
-    if (curwin->w_cursor.col+1 < STRLEN(ml_get_curline()))
+    if (curwin->w_cursor.col + 1 < (colnr_T)STRLEN(ml_get_curline()))
     {
 	inc_cursor();
 
 	if ((tempc == F_HE) && (F_is_TyB_TyC_TyD(SRC_EDT, AT_CURSOR)))
 	{
@@ -592,12 +593,12 @@ chg_c_to_X_or_X ()
     static void
 chg_l_to_X_orX_ ()
 {
     int	tempc;
 
-    if (!curwin->w_cursor.col &&
-	(curwin->w_cursor.col+1 == STRLEN(ml_get_curline())))
+    if (curwin->w_cursor.col != 0 &&
+	(curwin->w_cursor.col + 1 == (colnr_T)STRLEN(ml_get_curline())))
 	return;
 
     if (!curwin->w_cursor.col && p_ri)
 	return;
 
@@ -661,12 +662,12 @@ chg_l_to_X_orX_ ()
     static void
 chg_l_toXor_X ()
 {
     int	tempc;
 
-    if (!curwin->w_cursor.col &&
-	(curwin->w_cursor.col+1 == STRLEN(ml_get_curline())))
+    if (curwin->w_cursor.col != 0 &&
+	(curwin->w_cursor.col + 1 == (colnr_T)STRLEN(ml_get_curline())))
 	return;
 
     if (!curwin->w_cursor.col && p_ri)
 	return;
 
--- vim72.orig/src/hardcopy.c
+++ vim72/src/hardcopy.c
@@ -440,16 +440,15 @@ prt_get_unit(idx)
 }
 
 /*
  * Print the page header.
  */
-/*ARGSUSED*/
     static void
 prt_header(psettings, pagenum, lnum)
     prt_settings_T  *psettings;
     int		pagenum;
-    linenr_T	lnum;
+    linenr_T	lnum UNUSED;
 {
     int		width = psettings->chars_per_line;
     int		page_line;
     char_u	*tbuf;
     char_u	*p;
@@ -1879,11 +1878,11 @@ prt_next_dsc(p_dsc_line)
     /* DSC comments always start %% */
     if (prt_resfile_strncmp(0, "%%", 2) != 0)
 	return FALSE;
 
     /* Find type of DSC comment */
-    for (comment = 0; comment < NUM_ELEMENTS(prt_dsc_table); comment++)
+    for (comment = 0; comment < (int)NUM_ELEMENTS(prt_dsc_table); comment++)
 	if (prt_resfile_strncmp(0, prt_dsc_table[comment].string,
 					    prt_dsc_table[comment].len) == 0)
 	    break;
 
     if (comment != NUM_ELEMENTS(prt_dsc_table))
@@ -2452,16 +2451,15 @@ prt_match_charset(p_charset, p_cmap, pp_
     }
     return FALSE;
 }
 #endif
 
-/*ARGSUSED*/
     int
 mch_print_init(psettings, jobname, forceit)
     prt_settings_T *psettings;
     char_u	*jobname;
-    int		forceit;
+    int		forceit UNUSED;
 {
     int		i;
     char	*paper_name;
     int		paper_strlen;
     int		fontsize;
@@ -2512,11 +2510,11 @@ mch_print_init(psettings, jobname, force
     p_mbenc = NULL;
     props = enc_canon_props(p_encoding);
     if (!(props & ENC_8BIT) && ((*p_pmcs != NUL) || !(props & ENC_UNICODE)))
     {
 	p_mbenc_first = NULL;
-	for (cmap = 0; cmap < NUM_ELEMENTS(prt_ps_mbfonts); cmap++)
+	for (cmap = 0; cmap < (int)NUM_ELEMENTS(prt_ps_mbfonts); cmap++)
 	    if (prt_match_encoding((char *)p_encoding, &prt_ps_mbfonts[cmap],
 								    &p_mbenc))
 	    {
 		if (p_mbenc_first == NULL)
 		    p_mbenc_first = p_mbenc;
@@ -2640,11 +2638,11 @@ mch_print_init(psettings, jobname, force
     else
     {
 	paper_name = "A4";
 	paper_strlen = 2;
     }
-    for (i = 0; i < PRT_MEDIASIZE_LEN; ++i)
+    for (i = 0; i < (int)PRT_MEDIASIZE_LEN; ++i)
 	if (STRLEN(prt_mediasize[i].name) == (unsigned)paper_strlen
 		&& STRNICMP(prt_mediasize[i].name, paper_name,
 							   paper_strlen) == 0)
 	    break;
     if (i == PRT_MEDIASIZE_LEN)
@@ -3306,14 +3304,13 @@ mch_print_end_page()
     prt_dsc_noarg("PageTrailer");
 
     return !prt_file_error;
 }
 
-/*ARGSUSED*/
     int
 mch_print_begin_page(str)
-    char_u	*str;
+    char_u	*str UNUSED;
 {
     int		page_num[2];
 
     prt_page_num++;
 
@@ -3377,15 +3374,14 @@ mch_print_start_line(margin, page_line)
 #ifdef FEAT_MBYTE
     prt_half_width = FALSE;
 #endif
 }
 
-/*ARGSUSED*/
     int
 mch_print_text_out(p, len)
     char_u	*p;
-    int		len;
+    int		len UNUSED;
 {
     int		need_break;
     char_u	ch;
     char_u      ch_buff[8];
     float       char_width;
--- vim72.orig/src/syntax.c
+++ vim72/src/syntax.c
@@ -204,11 +204,11 @@ typedef struct syn_pattern
  * The attributes of the syntax item that has been recognized.
  */
 static int current_attr = 0;	    /* attr of current syntax word */
 #ifdef FEAT_EVAL
 static int current_id = 0;	    /* ID of current char for syn_get_id() */
-static int current_trans_id = 0;    /* idem, transparancy removed */
+static int current_trans_id = 0;    /* idem, transparency removed */
 #endif
 
 typedef struct syn_cluster_S
 {
     char_u	    *scl_name;	    /* syntax cluster name */
@@ -280,11 +280,11 @@ static int keepend_level = -1;
 typedef struct state_item
 {
     int		si_idx;			/* index of syntax pattern or
 					   KEYWORD_IDX */
     int		si_id;			/* highlight group ID for keywords */
-    int		si_trans_id;		/* idem, transparancy removed */
+    int		si_trans_id;		/* idem, transparency removed */
     int		si_m_lnum;		/* lnum of the match */
     int		si_m_startcol;		/* starting column of the match */
     lpos_T	si_m_endpos;		/* just after end posn of the match */
     lpos_T	si_h_startpos;		/* start position of the highlighting */
     lpos_T	si_h_endpos;		/* end position of the highlighting */
@@ -1272,11 +1272,11 @@ syn_stack_cleanup()
 	dist = 999999;
     else
 	dist = syn_buf->b_ml.ml_line_count / (syn_buf->b_sst_len - Rows) + 1;
 
     /*
-     * Go throught the list to find the "tick" for the oldest entry that can
+     * Go through the list to find the "tick" for the oldest entry that can
      * be removed.  Set "above" when the "tick" for the oldest entry is above
      * "b_sst_lasttick" (the display tick wraps around).
      */
     tick = syn_buf->b_sst_lasttick;
     above = FALSE;
@@ -2317,11 +2317,11 @@ syn_current_attr(syncing, displaying, ca
 	 * ":syn spell toplevel" was used. */
 	*can_spell = syn_buf->b_syn_spell == SYNSPL_DEFAULT
 		    ? (syn_buf->b_spell_cluster_id == 0)
 		    : (syn_buf->b_syn_spell == SYNSPL_TOP);
 
-    /* nextgroup ends at end of line, unless "skipnl" or "skipemtpy" present */
+    /* nextgroup ends at end of line, unless "skipnl" or "skipempty" present */
     if (current_next_list != NULL
 	    && syn_getcurline()[current_col + 1] == NUL
 	    && !(current_next_flags & (HL_SKIPNL | HL_SKIPEMPTY)))
 	current_next_list = NULL;
 
@@ -3084,10 +3084,16 @@ syn_add_start_off(result, regmatch, spp,
     {
 	result->lnum = regmatch->startpos[0].lnum;
 	col = regmatch->startpos[0].col;
 	off = spp->sp_offsets[idx];
     }
+    if (result->lnum > syn_buf->b_ml.ml_line_count)
+    {
+	/* a "\n" at the end of the pattern may take us below the last line */
+	result->lnum = syn_buf->b_ml.ml_line_count;
+	col = (int)STRLEN(ml_get_buf(syn_buf, result->lnum, FALSE));
+    }
     if (off != 0)
     {
 	base = ml_get_buf(syn_buf, result->lnum, FALSE);
 	p = base + col;
 	if (off > 0)
@@ -3222,15 +3228,14 @@ check_keyword_id(line, startcol, endcolp
 }
 
 /*
  * Handle ":syntax case" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_case(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	    /* not used */
+    int		syncing UNUSED;
 {
     char_u	*arg = eap->arg;
     char_u	*next;
 
     eap->nextcmd = find_nextcmd(arg);
@@ -3247,15 +3252,14 @@ syn_cmd_case(eap, syncing)
 }
 
 /*
  * Handle ":syntax spell" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_spell(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	    /* not used */
+    int		syncing UNUSED;
 {
     char_u	*arg = eap->arg;
     char_u	*next;
 
     eap->nextcmd = find_nextcmd(arg);
@@ -3515,41 +3519,38 @@ syn_clear_one(id, syncing)
 }
 
 /*
  * Handle ":syntax on" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_on(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	/* not used */
+    int		syncing UNUSED;
 {
     syn_cmd_onoff(eap, "syntax");
 }
 
 /*
  * Handle ":syntax enable" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_enable(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	/* not used */
+    int		syncing UNUSED;
 {
     set_internal_string_var((char_u *)"syntax_cmd", (char_u *)"enable");
     syn_cmd_onoff(eap, "syntax");
     do_unlet((char_u *)"g:syntax_cmd", TRUE);
 }
 
 /*
  * Handle ":syntax reset" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_reset(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	/* not used */
+    int		syncing UNUSED;
 {
     eap->nextcmd = check_nextcmd(eap->arg);
     if (!eap->skip)
     {
 	set_internal_string_var((char_u *)"syntax_cmd", (char_u *)"reset");
@@ -3559,27 +3560,25 @@ syn_cmd_reset(eap, syncing)
 }
 
 /*
  * Handle ":syntax manual" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_manual(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	/* not used */
+    int		syncing UNUSED;
 {
     syn_cmd_onoff(eap, "manual");
 }
 
 /*
  * Handle ":syntax off" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_off(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	/* not used */
+    int		syncing UNUSED;
 {
     syn_cmd_onoff(eap, "nosyntax");
 }
 
     static void
@@ -4172,11 +4171,10 @@ clear_keywtab(ht)
     for (hi = ht->ht_array; todo > 0; ++hi)
     {
 	if (!HASHITEM_EMPTY(hi))
 	{
 	    --todo;
-	    kp = HI2KE(hi);
 	    for (kp = HI2KE(hi); kp != NULL; kp = kp_next)
 	    {
 		kp_next = kp->ke_next;
 		vim_free(kp->next_list);
 		vim_free(kp->k_syn.cont_in_list);
@@ -4459,15 +4457,14 @@ syn_incl_toplevel(id, flagsp)
 }
 
 /*
  * Handle ":syntax include [@{group-name}] filename" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_include(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	    /* not used */
+    int		syncing UNUSED;
 {
     char_u	*arg = eap->arg;
     int		sgl_id = 1;
     char_u	*group_name_end;
     char_u	*rest;
@@ -4530,15 +4527,14 @@ syn_cmd_include(eap, syncing)
 }
 
 /*
  * Handle ":syntax keyword {group-name} [{option}] keyword .." command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_keyword(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	    /* not used */
+    int		syncing UNUSED;
 {
     char_u	*arg = eap->arg;
     char_u	*group_name_end;
     int		syn_id;
     char_u	*rest;
@@ -5273,15 +5269,14 @@ syn_add_cluster(name)
 
 /*
  * Handle ":syntax cluster {cluster-name} [contains={groupname},..]
  *		[add={groupname},..] [remove={groupname},..]".
  */
-/* ARGSUSED */
     static void
 syn_cmd_cluster(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	    /* not used */
+    int		syncing UNUSED;
 {
     char_u	*arg = eap->arg;
     char_u	*group_name_end;
     char_u	*rest;
     int		scl_id;
@@ -5462,15 +5457,14 @@ get_syn_pattern(arg, ci)
 }
 
 /*
  * Handle ":syntax sync .." command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_sync(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	    /* not used */
+    int		syncing UNUSED;
 {
     char_u	*arg_start = eap->arg;
     char_u	*arg_end;
     char_u	*key = NULL;
     char_u	*next_arg;
@@ -6097,14 +6091,13 @@ static char *(case_args[]) = {"match", "
 
 /*
  * Function given to ExpandGeneric() to obtain the list syntax names for
  * expansion.
  */
-/*ARGSUSED*/
     char_u *
 get_syntax_name(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     if (expand_what == EXP_SUBCMD)
 	return (char_u *)subcommands[idx].name;
     return (char_u *)case_args[idx];
@@ -6118,11 +6111,11 @@ get_syntax_name(xp, idx)
     int
 syn_get_id(wp, lnum, col, trans, spellp, keep_state)
     win_T	*wp;
     long	lnum;
     colnr_T	col;
-    int		trans;	     /* remove transparancy */
+    int		trans;	     /* remove transparency */
     int		*spellp;     /* return: can do spell checking */
     int		keep_state;  /* keep state of char at "col" */
 {
     /* When the position is not after the current position and in the same
      * line of the same buffer, need to restart parsing. */
@@ -7533,11 +7526,11 @@ highlight_clear(idx)
 }
 
 #if defined(FEAT_GUI) || defined(PROTO)
 /*
  * Set the normal foreground and background colors according to the "Normal"
- * highlighighting group.  For X11 also set "Menu", "Scrollbar", and
+ * highlighting group.  For X11 also set "Menu", "Scrollbar", and
  * "Tooltip" colors.
  */
     void
 set_normal_colors()
 {
@@ -7742,18 +7735,17 @@ fontset_name2handle(name, fixed_width)
 # endif
 
 /*
  * Get the font or fontset for one highlight group.
  */
-/*ARGSUSED*/
     static void
 hl_do_font(idx, arg, do_normal, do_menu, do_tooltip)
     int		idx;
     char_u	*arg;
-    int		do_normal;	/* set normal font */
-    int		do_menu;	/* set menu font */
-    int		do_tooltip;	/* set tooltip font */
+    int		do_normal;		/* set normal font */
+    int		do_menu UNUSED;		/* set menu font */
+    int		do_tooltip UNUSED;	/* set tooltip font */
 {
 # ifdef FEAT_XFONTSET
     /* If 'guifontset' is not empty, first try using the name as a
      * fontset.  If that doesn't work, use it as a font name. */
     if (*p_guifontset != NUL
@@ -8332,32 +8324,42 @@ highlight_has_attr(id, flag, modec)
  * Return color name of highlight group "id".
  */
     char_u *
 highlight_color(id, what, modec)
     int		id;
-    char_u	*what;	/* "fg", "bg", "sp", "fg#", "bg#" or "sp#" */
+    char_u	*what;	/* "font", "fg", "bg", "sp", "fg#", "bg#" or "sp#" */
     int		modec;	/* 'g' for GUI, 'c' for cterm, 't' for term */
 {
     static char_u	name[20];
     int			n;
     int			fg = FALSE;
 # ifdef FEAT_GUI
     int			sp = FALSE;
+    int			font = FALSE;
 # endif
 
     if (id <= 0 || id > highlight_ga.ga_len)
 	return NULL;
 
-    if (TOLOWER_ASC(what[0]) == 'f')
+    if (TOLOWER_ASC(what[0]) == 'f' && TOLOWER_ASC(what[1]) == 'g')
 	fg = TRUE;
 # ifdef FEAT_GUI
-    else if (TOLOWER_ASC(what[0]) == 's')
+    else if (TOLOWER_ASC(what[0]) == 'f' && TOLOWER_ASC(what[1]) == 'o'
+             && TOLOWER_ASC(what[2]) == 'n' && TOLOWER_ASC(what[3]) == 't')
+	font = TRUE;
+    else if (TOLOWER_ASC(what[0]) == 's' && TOLOWER_ASC(what[1]) == 'p')
 	sp = TRUE;
+    else if (!(TOLOWER_ASC(what[0]) == 'b' && TOLOWER_ASC(what[1]) == 'g'))
+	return NULL;
     if (modec == 'g')
     {
+	/* return font name */
+	if (font)
+	    return HL_TABLE()[id - 1].sg_font_name;
+
 	/* return #RRGGBB form (only possible when GUI is running) */
-	if (gui.in_use && what[1] && what[2] == '#')
+	if (gui.in_use && what[2] == '#')
 	{
 	    guicolor_T		color;
 	    long_u		rgb;
 	    static char_u	buf[10];
 
@@ -8380,10 +8382,12 @@ highlight_color(id, what, modec)
 	    return (HL_TABLE()[id - 1].sg_gui_fg_name);
 	if (sp)
 	    return (HL_TABLE()[id - 1].sg_gui_sp_name);
 	return (HL_TABLE()[id - 1].sg_gui_bg_name);
     }
+    if (font || sp)
+	return NULL;
 # endif
     if (modec == 'c')
     {
 	if (fg)
 	    n = HL_TABLE()[id - 1].sg_cterm_fg - 1;
@@ -8658,10 +8662,11 @@ syn_add_group(name)
     for (p = name; *p != NUL; ++p)
     {
 	if (!vim_isprintc(*p))
 	{
 	    EMSG(_("E669: Unprintable character in group name"));
+	    vim_free(name);
 	    return 0;
 	}
 	else if (!ASCII_ISALNUM(*p) && *p != '_')
 	{
 	    /* This is an error, but since there previously was no check only
@@ -9148,14 +9153,13 @@ highlight_list_two(cnt, attr)
     || defined(FEAT_SIGNS) || defined(PROTO)
 /*
  * Function given to ExpandGeneric() to obtain the list of group names.
  * Also used for synIDattr() function.
  */
-/*ARGSUSED*/
     char_u *
 get_highlight_name(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
 #ifdef FEAT_CMDL_COMPL
     if (idx == highlight_ga.ga_len && include_none != 0)
 	return (char_u *)"none";
--- vim72.orig/src/gui_gtk.c
+++ vim72/src/gui_gtk.c
@@ -283,18 +283,18 @@ create_menu_icon(vimmenu_T *menu, GtkIco
     }
 
     return image;
 }
 
-/*ARGSUSED*/
     static gint
-toolbar_button_focus_in_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)
-{
-    /* When we're in a GtkPlug, we don't have window focus events, only widget focus.
-     * To emulate stand-alone gvim, if a button gets focus (e.g., <Tab> into GtkPlug)
-     * immediately pass it to mainwin.
-     */
+toolbar_button_focus_in_event(GtkWidget *widget UNUSED,
+			      GdkEventFocus *event UNUSED,
+			      gpointer data UNUSED)
+{
+    /* When we're in a GtkPlug, we don't have window focus events, only widget
+     * focus.  To emulate stand-alone gvim, if a button gets focus (e.g.,
+     * <Tab> into GtkPlug) immediately pass it to mainwin. */
     if (gtk_socket_id != 0)
 	gtk_widget_grab_focus(gui.drawarea);
 
     return TRUE;
 }
@@ -583,13 +583,12 @@ gui_mch_add_menu(vimmenu_T *menu, int id
     if (vim_strchr(p_go, GO_TEAROFF) != NULL)
 	gtk_widget_show(menu->tearoff_handle);
     gtk_menu_prepend(GTK_MENU(menu->submenu_id), menu->tearoff_handle);
 }
 
-/*ARGSUSED*/
     static void
-menu_item_activate(GtkWidget *widget, gpointer data)
+menu_item_activate(GtkWidget *widget UNUSED, gpointer data)
 {
     gui_menu_cb((vimmenu_T *)data);
 
 # ifndef HAVE_GTK2
     /* Work around a bug in GTK+ 1: we don't seem to get a focus-in
@@ -1200,13 +1199,12 @@ gui_mch_destroy_scrollbar(scrollbar_T *s
  * on just about any event. */
 /* # define USE_FILE_CHOOSER */
 #endif
 
 #ifndef USE_FILE_CHOOSER
-/*ARGSUSED*/
     static void
-browse_ok_cb(GtkWidget *widget, gpointer cbdata)
+browse_ok_cb(GtkWidget *widget UNUSED, gpointer cbdata)
 {
     gui_T *vw = (gui_T *)cbdata;
 
     if (vw->browse_fname != NULL)
 	g_free(vw->browse_fname);
@@ -1216,13 +1214,12 @@ browse_ok_cb(GtkWidget *widget, gpointer
     gtk_widget_hide(vw->filedlg);
     if (gtk_main_level() > 0)
 	gtk_main_quit();
 }
 
-/*ARGSUSED*/
     static void
-browse_cancel_cb(GtkWidget *widget, gpointer cbdata)
+browse_cancel_cb(GtkWidget *widget UNUSED, gpointer cbdata)
 {
     gui_T *vw = (gui_T *)cbdata;
 
     if (vw->browse_fname != NULL)
     {
@@ -1232,13 +1229,12 @@ browse_cancel_cb(GtkWidget *widget, gpoi
     gtk_widget_hide(vw->filedlg);
     if (gtk_main_level() > 0)
 	gtk_main_quit();
 }
 
-/*ARGSUSED*/
     static gboolean
-browse_destroy_cb(GtkWidget * widget)
+browse_destroy_cb(GtkWidget *widget UNUSED)
 {
     if (gui.browse_fname != NULL)
     {
 	g_free(gui.browse_fname);
 	gui.browse_fname = NULL;
@@ -1260,18 +1256,17 @@ browse_destroy_cb(GtkWidget * widget)
  * dflt				default name
  * ext				not used (extension added)
  * initdir			initial directory, NULL for current dir
  * filter			not used (file name filter)
  */
-/*ARGSUSED*/
     char_u *
-gui_mch_browse(int saving,
+gui_mch_browse(int saving UNUSED,
 	       char_u *title,
 	       char_u *dflt,
-	       char_u *ext,
+	       char_u *ext UNUSED,
 	       char_u *initdir,
-	       char_u *filter)
+	       char_u *filter UNUSED)
 {
 #ifdef USE_FILE_CHOOSER
     GtkWidget		*fc;
 #endif
     char_u		dirbuf[MAXPATHL];
@@ -1375,11 +1370,10 @@ gui_mch_browse(int saving,
  * Returns the selected name in allocated memory, or NULL for Cancel.
  * title			title for the window
  * dflt				default name
  * initdir			initial directory, NULL for current dir
  */
-/*ARGSUSED*/
     char_u *
 gui_mch_browsedir(
 	       char_u *title,
 	       char_u *initdir)
 {
@@ -1458,11 +1452,10 @@ dlg_destroy(GtkWidget *dlg)
     /* Destroy the dialog, will break the waiting loop. */
     gtk_widget_destroy(dlg);
 }
 
 # ifdef FEAT_GUI_GNOME
-/* ARGSUSED */
     static int
 gui_gnome_dialog( int	type,
 		char_u	*title,
 		char_u	*message,
 		char_u	*buttons,
@@ -1609,22 +1602,20 @@ typedef struct _CancelData
     int		*status;
     int		ignore_enter;
     GtkWidget	*dialog;
 } CancelData;
 
-/* ARGSUSED */
     static void
 dlg_button_clicked(GtkWidget * widget, ButtonData *data)
 {
     *(data->status) = data->index + 1;
     dlg_destroy(data->dialog);
 }
 
 /*
  * This makes the Escape key equivalent to the cancel button.
  */
-/*ARGSUSED*/
     static int
 dlg_key_press_event(GtkWidget *widget, GdkEventKey *event, CancelData *data)
 {
     /* Ignore hitting Enter (or Space) when there is no default button. */
     if (data->ignore_enter && (event->keyval == GDK_Return
@@ -1653,11 +1644,10 @@ dlg_destroy_cb(int *p)
     *p = TRUE;		/* set dialog_destroyed to break out of the loop */
     if (gtk_main_level() > 0)
 	gtk_main_quit();
 }
 
-/* ARGSUSED */
     int
 gui_mch_dialog(	int	type,		/* type of dialog */
 		char_u	*title,		/* title of dialog */
 		char_u	*message,	/* message text */
 		char_u	*buttons,	/* names of buttons */
@@ -2213,11 +2203,10 @@ typedef struct _DialogInfo
     int		ignore_enter;	    /* no default button, ignore "Enter" */
     int		noalt;		    /* accept accelerators without Alt */
     GtkDialog	*dialog;	    /* Widget of the dialog */
 } DialogInfo;
 
-/*ARGSUSED2*/
     static gboolean
 dialog_key_press_event_cb(GtkWidget *widget, GdkEventKey *event, gpointer data)
 {
     DialogInfo *di = (DialogInfo *)data;
 
@@ -2322,23 +2311,10 @@ gui_mch_dialog(int	type,	    /* type of
 	    CONVERT_FROM_UTF8_FREE(text);
 	}
 	gtk_widget_destroy(dialog);
     }
 
-    /* Terrible hack: When the text area still has focus when we remove the
-     * dialog, somehow gvim loses window focus.  This is with "point to type"
-     * in the KDE 3.1 window manager.  Warp the mouse pointer to outside the
-     * window and back to avoid that. */
-    if (!gui.in_focus)
-    {
-	int x, y;
-
-	gdk_window_get_pointer(gui.drawarea->window, &x, &y, NULL);
-	gui_mch_setmouse(-100, -100);
-	gui_mch_setmouse(x, y);
-    }
-
     return response > 0 ? response : 0;
 }
 
 #endif /* FEAT_GUI_DIALOG && HAVE_GTK2 */
 
@@ -2396,18 +2372,17 @@ static int popup_mouse_pos;
  * at the current text cursor position.
  *
  * Note: The push_in output argument seems to affect scrolling of huge
  * menus that don't fit on the screen.	Leave it at the default for now.
  */
-/*ARGSUSED0*/
     static void
-popup_menu_position_func(GtkMenu *menu,
+popup_menu_position_func(GtkMenu *menu UNUSED,
 			 gint *x, gint *y,
 # ifdef HAVE_GTK2
-			 gboolean *push_in,
+			 gboolean *push_in UNUSED,
 # endif
-			 gpointer user_data)
+			 gpointer user_data UNUSED)
 {
     gdk_window_get_origin(gui.drawarea->window, x, y);
 
     if (popup_mouse_pos)
     {
@@ -2462,17 +2437,16 @@ typedef struct _SharedFindReplace
     GtkWidget *find;	/* 'Find Next' action button */
     GtkWidget *replace;	/* 'Replace With' action button */
     GtkWidget *all;	/* 'Replace All' action button */
 } SharedFindReplace;
 
-static SharedFindReplace find_widgets = { NULL, };
-static SharedFindReplace repl_widgets = { NULL, };
+static SharedFindReplace find_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
+static SharedFindReplace repl_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
 
-/* ARGSUSED */
     static int
 find_key_press_event(
-		GtkWidget	*widget,
+		GtkWidget	*widget UNUSED,
 		GdkEventKey	*event,
 		SharedFindReplace *frdp)
 {
     /* If the user is holding one of the key modifiers we will just bail out,
      * thus preserving the possibility of normal focus traversal.
@@ -2960,13 +2934,12 @@ gui_gtk_synch_fonts(void)
 
 
 /*
  * Callback for actions of the find and replace dialogs
  */
-/*ARGSUSED*/
     static void
-find_replace_cb(GtkWidget *widget, gpointer data)
+find_replace_cb(GtkWidget *widget UNUSED, gpointer data)
 {
     int			flags;
     char_u		*find_text;
     char_u		*repl_text;
     gboolean		direction_down;
@@ -3008,13 +2981,12 @@ find_replace_cb(GtkWidget *widget, gpoin
     if (rc && gtk_main_level() > 0)
 	gtk_main_quit(); /* make sure cmd will be handled immediately */
 }
 
 /* our usual callback function */
-/*ARGSUSED*/
     static void
-entry_activate_cb(GtkWidget *widget, gpointer data)
+entry_activate_cb(GtkWidget *widget UNUSED, gpointer data)
 {
     gtk_widget_grab_focus(GTK_WIDGET(data));
 }
 
 /*
@@ -3053,14 +3025,13 @@ entry_changed_cb(GtkWidget * entry, GtkW
 }
 
 /*
  * ":helpfind"
  */
-/*ARGSUSED*/
     void
 ex_helpfind(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     /* This will fail when menus are not loaded.  Well, it's only for
      * backwards compatibility anyway. */
     do_cmdline_cmd((char_u *)"emenu ToolBar.FindHelp");
 }
--- vim72.orig/src/gui_gtk_f.c
+++ vim72/src/gui_gtk_f.c
@@ -225,18 +225,18 @@ gtk_form_get_type(void)
 {
     static GtkType form_type = 0;
 
     if (!form_type)
     {
-	GtkTypeInfo form_info =
-	{
-	    "GtkForm",
-	    sizeof(GtkForm),
-	    sizeof(GtkFormClass),
-	    (GtkClassInitFunc) gtk_form_class_init,
-	    (GtkObjectInitFunc) gtk_form_init
-	};
+	GtkTypeInfo form_info;
+
+	vim_memset(&form_info, 0, sizeof(form_info));
+	form_info.type_name = "GtkForm";
+	form_info.object_size = sizeof(GtkForm);
+	form_info.class_size = sizeof(GtkFormClass);
+	form_info.class_init_func = (GtkClassInitFunc)gtk_form_class_init;
+	form_info.object_init_func = (GtkObjectInitFunc)gtk_form_init;
 
 	form_type = gtk_type_unique(GTK_TYPE_CONTAINER, &form_info);
     }
     return form_type;
 }
@@ -609,14 +609,13 @@ gtk_form_remove(GtkContainer *container,
 	g_list_free_1(tmp_list);
 	g_free(child);
     }
 }
 
-/*ARGSUSED1*/
     static void
 gtk_form_forall(GtkContainer	*container,
-		gboolean	include_internals,
+		gboolean	include_internals UNUSED,
 		GtkCallback	callback,
 		gpointer	callback_data)
 {
     GtkForm *form;
     GtkFormChild *child;
@@ -784,13 +783,12 @@ gtk_form_position_children(GtkForm *form
  * This routine identifies expose events that are generated when
  * we've temporarily moved the bin_window_origin, and translates
  * them or discards them, depending on whether we are obscured
  * or not.
  */
-/*ARGSUSED1*/
     static GdkFilterReturn
-gtk_form_filter(GdkXEvent *gdk_xevent, GdkEvent *event, gpointer data)
+gtk_form_filter(GdkXEvent *gdk_xevent, GdkEvent *event UNUSED, gpointer data)
 {
     XEvent *xevent;
     GtkForm *form;
 
     xevent = (XEvent *) gdk_xevent;
@@ -819,13 +817,14 @@ gtk_form_filter(GdkXEvent *gdk_xevent, G
 
 /* Although GDK does have a GDK_VISIBILITY_NOTIFY event,
  * there is no corresponding event in GTK, so we have
  * to get the events from a filter
  */
-/*ARGSUSED1*/
     static GdkFilterReturn
-gtk_form_main_filter(GdkXEvent *gdk_xevent, GdkEvent *event, gpointer data)
+gtk_form_main_filter(GdkXEvent *gdk_xevent,
+		     GdkEvent *event UNUSED,
+		     gpointer data)
 {
     XEvent *xevent;
     GtkForm *form;
 
     xevent = (XEvent *) gdk_xevent;
@@ -859,15 +858,13 @@ gtk_form_main_filter(GdkXEvent *gdk_xeve
  */
     static void
 gtk_form_set_static_gravity(GdkWindow *window, gboolean use_static)
 {
 #ifdef HAVE_GTK2
-    gboolean static_gravity_supported;
-
-    static_gravity_supported = gdk_window_set_static_gravities(window,
-							       use_static);
-    g_return_if_fail(static_gravity_supported);
+    /* We don't check if static gravity is actually supported, because it
+     * results in an annoying assertion error message. */
+    gdk_window_set_static_gravities(window, use_static);
 #else
     XSetWindowAttributes xattributes;
 
     xattributes.win_gravity = (use_static) ? StaticGravity : NorthWestGravity;
     xattributes.bit_gravity = (use_static) ? StaticGravity : NorthWestGravity;
@@ -909,25 +906,23 @@ gtk_form_send_configure(GtkForm *form)
 #else
     gtk_widget_event(widget, (GdkEvent*)&event);
 #endif
 }
 
-/*ARGSUSED0*/
     static void
-gtk_form_child_map(GtkWidget *widget, gpointer user_data)
+gtk_form_child_map(GtkWidget *widget UNUSED, gpointer user_data)
 {
     GtkFormChild *child;
 
     child = (GtkFormChild *)user_data;
 
     child->mapped = TRUE;
     gdk_window_show(child->window);
 }
 
-/*ARGSUSED0*/
     static void
-gtk_form_child_unmap(GtkWidget *widget, gpointer user_data)
+gtk_form_child_unmap(GtkWidget *widget UNUSED, gpointer user_data)
 {
     GtkFormChild *child;
 
     child = (GtkFormChild *)user_data;
 
--- vim72.orig/src/if_mzsch.c
+++ vim72/src/if_mzsch.c
@@ -2,10 +2,12 @@
  *
  * MzScheme interface by Sergey Khorev <sergey.khorev@gmail.com>
  * Original work by Brent Fulgham <bfulgham@debian.org>
  * (Based on lots of help from Matthew Flatt)
  *
+ * TODO Convert byte-strings to char strings?
+ *
  * This consists of six parts:
  * 1. MzScheme interpreter main program
  * 2. Routines that handle the external interface between MzScheme and
  *    Vim.
  * 3. MzScheme input/output handlers: writes output via [e]msg().
@@ -16,37 +18,38 @@
  * NOTES
  * 1. Memory, allocated with scheme_malloc*, need not to be freed explicitly,
  *    garbage collector will do it self
  * 2. Requires at least NORMAL features. I can't imagine why one may want
  *    to build with SMALL or TINY features but with MzScheme interface.
- * 3. I don't use K&R-style functions. Anyway, MzScheme headers are ANSI.
+ * 3. I don't use K&R-style functions. Anyways, MzScheme headers are ANSI.
  */
 
 #include "vim.h"
 
 #include "if_mzsch.h"
 
 /* Only do the following when the feature is enabled.  Needed for "make
  * depend". */
 #if defined(FEAT_MZSCHEME) || defined(PROTO)
 
+#include <assert.h>
+
 /* Base data structures */
 #define SCHEME_VIMBUFFERP(obj)  SAME_TYPE(SCHEME_TYPE(obj), mz_buffer_type)
 #define SCHEME_VIMWINDOWP(obj)  SAME_TYPE(SCHEME_TYPE(obj), mz_window_type)
 
 typedef struct
 {
-    Scheme_Type	    tag;
-    Scheme_Env	    *env;
+    Scheme_Object   so;
     buf_T	    *buf;
 } vim_mz_buffer;
 
 #define INVALID_BUFFER_VALUE ((buf_T *)(-1))
 
 typedef struct
 {
-    Scheme_Type	    tag;
+    Scheme_Object   so;
     win_T	    *win;
 } vim_mz_window;
 
 #define INVALID_WINDOW_VALUE ((win_T *)(-1))
 
@@ -65,31 +68,10 @@ typedef struct
 {
     char	    *name;
     Scheme_Object   *port;
 } Port_Info;
 
-/* info for closed prim */
-/*
- * data have different means:
- * for do_eval it is char*
- * for do_apply is Apply_Onfo*
- * for do_load is Port_Info*
- */
-typedef struct
-{
-    void	*data;
-    Scheme_Env	*env;
-} Cmd_Info;
-
-/* info for do_apply */
-typedef struct
-{
-    Scheme_Object   *proc;
-    int		    argc;
-    Scheme_Object   **argv;
-} Apply_Info;
-
 /*
  *========================================================================
  *  Vim-Control Commands
  *========================================================================
  */
@@ -120,11 +102,10 @@ static Scheme_Object *mzscheme_open_buff
 static Scheme_Object *set_buffer_line(void *, int, Scheme_Object **);
 static Scheme_Object *set_buffer_line_list(void *, int, Scheme_Object **);
 static Scheme_Object *insert_buffer_line_list(void *, int, Scheme_Object **);
 static Scheme_Object *get_range_start(void *, int, Scheme_Object **);
 static Scheme_Object *get_range_end(void *, int, Scheme_Object **);
-static Scheme_Object *get_buffer_namespace(void *, int, Scheme_Object **);
 static vim_mz_buffer *get_vim_curr_buffer(void);
 
 /*  Window-related commands */
 static Scheme_Object *window_new(win_T *win);
 static Scheme_Object *get_curr_win(void *, int, Scheme_Object **);
@@ -161,34 +142,66 @@ static Scheme_Object *vim_window_validp(
  */
 static int vim_error_check(void);
 static int do_mzscheme_command(exarg_T *, void *, Scheme_Closed_Prim *what);
 static void startup_mzscheme(void);
 static char *string_to_line(Scheme_Object *obj);
-static int mzscheme_io_init(void);
-static void mzscheme_interface_init(vim_mz_buffer *self);
 static void do_output(char *mesg, long len);
 static void do_printf(char *format, ...);
 static void do_flush(void);
 static Scheme_Object *_apply_thunk_catch_exceptions(
 	Scheme_Object *, Scheme_Object **);
 static Scheme_Object *extract_exn_message(Scheme_Object *v);
 static Scheme_Object *do_eval(void *, int noargc, Scheme_Object **noargv);
 static Scheme_Object *do_load(void *, int noargc, Scheme_Object **noargv);
-static Scheme_Object *do_apply(void *, int noargc, Scheme_Object **noargv);
-static void register_vim_exn(Scheme_Env *env);
+static void register_vim_exn(void);
 static vim_mz_buffer *get_buffer_arg(const char *fname, int argnum,
 	int argc, Scheme_Object **argv);
 static vim_mz_window *get_window_arg(const char *fname, int argnum,
 	int argc, Scheme_Object **argv);
-static void add_vim_exn(Scheme_Env *env);
 static int line_in_range(linenr_T, buf_T *);
 static void check_line_range(linenr_T, buf_T *);
 static void mz_fix_cursor(int lo, int hi, int extra);
 
-static int eval_in_namespace(void *, Scheme_Closed_Prim *, Scheme_Env *,
-		Scheme_Object **ret);
-static void make_modules(Scheme_Env *);
+static int eval_with_exn_handling(void *, Scheme_Closed_Prim *,
+	    Scheme_Object **ret);
+static void make_modules(void);
+static void init_exn_catching_apply(void);
+static int mzscheme_env_main(Scheme_Env *env, int argc, char **argv);
+static int mzscheme_init(void);
+#ifdef FEAT_EVAL
+static Scheme_Object *vim_to_mzscheme(typval_T *vim_value, int depth,
+	Scheme_Hash_Table *visited);
+static int mzscheme_to_vim(Scheme_Object *obj, typval_T *tv, int depth,
+	Scheme_Hash_Table *visited);
+#endif
+
+#ifdef MZ_PRECISE_GC
+static int buffer_size_proc(void *obj)
+{
+    return gcBYTES_TO_WORDS(sizeof(vim_mz_buffer));
+}
+static int buffer_mark_proc(void *obj)
+{
+    return buffer_size_proc(obj);
+}
+static int buffer_fixup_proc(void *obj)
+{
+    return buffer_size_proc(obj);
+}
+static int window_size_proc(void *obj)
+{
+    return gcBYTES_TO_WORDS(sizeof(vim_mz_window));
+}
+static int window_mark_proc(void *obj)
+{
+    return window_size_proc(obj);
+}
+static int window_fixup_proc(void *obj)
+{
+    return window_size_proc(obj);
+}
+#endif
 
 #ifdef DYNAMIC_MZSCHEME
 
 static Scheme_Object *dll_scheme_eof;
 static Scheme_Object *dll_scheme_false;
@@ -258,12 +271,10 @@ static Scheme_Object *(*dll_scheme_looku
 	Scheme_Env *env);
 static Scheme_Object *(*dll_scheme_make_closed_prim_w_arity)
     (Scheme_Closed_Prim *prim, void *data, const char *name, mzshort mina,
      mzshort maxa);
 static Scheme_Object *(*dll_scheme_make_integer_value)(long i);
-static Scheme_Object *(*dll_scheme_make_namespace)(int argc,
-	Scheme_Object *argv[]);
 static Scheme_Object *(*dll_scheme_make_pair)(Scheme_Object *car,
 	Scheme_Object *cdr);
 static Scheme_Object *(*dll_scheme_make_prim_w_arity)(Scheme_Prim *prim,
 	const char *name, mzshort mina, mzshort maxa);
 # if MZSCHEME_VERSION_MAJOR < 299
@@ -309,10 +320,21 @@ static Scheme_Config *(*dll_scheme_curre
 static Scheme_Object *(*dll_scheme_char_string_to_byte_string)
     (Scheme_Object *s);
 static Scheme_Object *(*dll_scheme_char_string_to_path)
     (Scheme_Object *s);
 # endif
+static Scheme_Hash_Table *(*dll_scheme_make_hash_table)(int type);
+static void (*dll_scheme_hash_set)(Scheme_Hash_Table *table,
+	Scheme_Object *key, Scheme_Object *value);
+static Scheme_Object *(*dll_scheme_hash_get)(Scheme_Hash_Table *table,
+	Scheme_Object *key);
+static Scheme_Object *(*dll_scheme_make_double)(double d);
+# ifdef INCLUDE_MZSCHEME_BASE
+static Scheme_Object *(*dll_scheme_make_sized_byte_string)(char *chars,
+	long len, int copy);
+static Scheme_Object *(*dll_scheme_namespace_require)(Scheme_Object *req);
+# endif
 
 /* arrays are imported directly */
 # define scheme_eof dll_scheme_eof
 # define scheme_false dll_scheme_false
 # define scheme_void dll_scheme_void
@@ -366,11 +388,10 @@ static Scheme_Object *(*dll_scheme_char_
 # endif
 # define scheme_intern_symbol dll_scheme_intern_symbol
 # define scheme_lookup_global dll_scheme_lookup_global
 # define scheme_make_closed_prim_w_arity dll_scheme_make_closed_prim_w_arity
 # define scheme_make_integer_value dll_scheme_make_integer_value
-# define scheme_make_namespace dll_scheme_make_namespace
 # define scheme_make_pair dll_scheme_make_pair
 # define scheme_make_prim_w_arity dll_scheme_make_prim_w_arity
 # if MZSCHEME_VERSION_MAJOR < 299
 #  define scheme_make_string dll_scheme_make_string
 #  define scheme_make_string_output_port dll_scheme_make_string_output_port
@@ -401,10 +422,18 @@ static Scheme_Object *(*dll_scheme_char_
 #  define scheme_char_string_to_byte_string \
     dll_scheme_char_string_to_byte_string
 #  define scheme_char_string_to_path \
     dll_scheme_char_string_to_path
 # endif
+# define scheme_make_hash_table dll_scheme_make_hash_table
+# define scheme_hash_set dll_scheme_hash_set
+# define scheme_hash_get dll_scheme_hash_get
+# define scheme_make_double dll_scheme_make_double
+# ifdef INCLUDE_MZSCHEME_BASE
+#  define scheme_make_sized_byte_string dll_scheme_make_sized_byte_string
+#  define scheme_namespace_require dll_scheme_namespace_require
+# endif
 
 typedef struct
 {
     char    *name;
     void    **ptr;
@@ -466,11 +495,10 @@ static Thunk_Info mzsch_imports[] = {
     {"scheme_intern_symbol", (void **)&dll_scheme_intern_symbol},
     {"scheme_lookup_global", (void **)&dll_scheme_lookup_global},
     {"scheme_make_closed_prim_w_arity",
 	(void **)&dll_scheme_make_closed_prim_w_arity},
     {"scheme_make_integer_value", (void **)&dll_scheme_make_integer_value},
-    {"scheme_make_namespace", (void **)&dll_scheme_make_namespace},
     {"scheme_make_pair", (void **)&dll_scheme_make_pair},
     {"scheme_make_prim_w_arity", (void **)&dll_scheme_make_prim_w_arity},
 # if MZSCHEME_VERSION_MAJOR < 299
     {"scheme_make_string", (void **)&dll_scheme_make_string},
     {"scheme_make_string_output_port",
@@ -500,13 +528,20 @@ static Thunk_Info mzsch_imports[] = {
 # if MZSCHEME_VERSION_MAJOR >= 299
     {"scheme_set_param", (void **)&dll_scheme_set_param},
     {"scheme_current_config", (void **)&dll_scheme_current_config},
     {"scheme_char_string_to_byte_string",
 	(void **)&dll_scheme_char_string_to_byte_string},
-    {"scheme_char_string_to_path",
-	(void **)&dll_scheme_char_string_to_path},
+    {"scheme_char_string_to_path", (void **)&dll_scheme_char_string_to_path},
 # endif
+    {"scheme_make_hash_table", (void **)&dll_scheme_make_hash_table},
+    {"scheme_hash_set", (void **)&dll_scheme_hash_set},
+    {"scheme_hash_get", (void **)&dll_scheme_hash_get},
+    {"scheme_make_double", (void **)&dll_scheme_make_double},
+# ifdef INCLUDE_MZSCHEME_BASE
+    {"scheme_make_sized_byte_string", (void **)&dll_scheme_make_sized_byte_string},
+    {"scheme_namespace_require", (void **)&dll_scheme_namespace_require},
+#endif
     {NULL, NULL}};
 
 static HINSTANCE hMzGC = 0;
 static HINSTANCE hMzSch = 0;
 
@@ -590,34 +625,42 @@ dynamic_mzscheme_end(void)
 	hMzGC = 0;
     }
 }
 #endif /* DYNAMIC_MZSCHEME */
 
+/* need to put it here for dynamic stuff to work */
+#if defined(INCLUDE_MZSCHEME_BASE)
+# include "mzscheme_base.c"
+#elif MZSCHEME_VERSION_MAJOR >= 400
+# error MzScheme 4.x must include mzscheme_base.c, for MinGW32 you need to define MZSCHEME_GENERATE_BASE=yes
+#endif
+
 /*
  *========================================================================
  *  1. MzScheme interpreter startup
  *========================================================================
  */
 
 static Scheme_Type mz_buffer_type;
 static Scheme_Type mz_window_type;
 
-static int initialized = 0;
+static int initialized = FALSE;
 
 /* global environment */
 static Scheme_Env    *environment = NULL;
 /* output/error handlers */
 static Scheme_Object *curout = NULL;
 static Scheme_Object *curerr = NULL;
-/* vim:exn exception */
+/* exn:vim exception */
 static Scheme_Object *exn_catching_apply = NULL;
 static Scheme_Object *exn_p = NULL;
 static Scheme_Object *exn_message = NULL;
 static Scheme_Object *vim_exn = NULL; /* Vim Error exception */
- /* values for exn:vim - constructor, predicate, accessors etc */
-static Scheme_Object *vim_exn_names = NULL;
-static Scheme_Object *vim_exn_values = NULL;
+
+#if !defined(MZ_PRECISE_GC) || MZSCHEME_VERSION_MAJOR < 400
+static void *stack_base = NULL;
+#endif
 
 static long range_start;
 static long range_end;
 
 /* MzScheme threads scheduling stuff */
@@ -665,15 +708,13 @@ static void remove_timer(void);
 /* timers are presented in GUI only */
 # if defined(FEAT_GUI_W32)
     static void CALLBACK
 timer_proc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
 # elif defined(FEAT_GUI_GTK)
-/*ARGSUSED*/
     static gint
 timer_proc(gpointer data)
 # elif defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA)
-/* ARGSUSED */
     static void
 timer_proc(XtPointer timed_out, XtIntervalId *interval_id)
 # elif defined(FEAT_GUI_MAC)
     pascal void
 timer_proc(EventLoopTimerRef theTimer, void *userData)
@@ -751,203 +792,333 @@ mzscheme_end(void)
 #ifdef DYNAMIC_MZSCHEME
     dynamic_mzscheme_end();
 #endif
 }
 
+    void
+mzscheme_main(void)
+{
+#if defined(MZ_PRECISE_GC) && MZSCHEME_VERSION_MAJOR >= 400
+    /* use trampoline for precise GC in MzScheme >= 4.x */
+    scheme_main_setup(TRUE, mzscheme_env_main, 0, NULL);
+#else
+    mzscheme_env_main(NULL, 0, NULL);
+#endif
+}
+
+    static int
+mzscheme_env_main(Scheme_Env *env, int argc, char **argv)
+{
+    /* neither argument nor return values are used */
+#ifdef MZ_PRECISE_GC
+# if MZSCHEME_VERSION_MAJOR < 400
+    /*
+     * Starting from version 4.x, embedding applications must use
+     * scheme_main_setup/scheme_main_stack_setup trampolines
+     * rather than setting stack base directly with scheme_set_stack_base
+     */
+    Scheme_Object   *dummy = NULL;
+    MZ_GC_DECL_REG(1);
+    MZ_GC_VAR_IN_REG(0, dummy);
+
+    stack_base = &__gc_var_stack__;
+# else
+    /* environment has been created by us by Scheme */
+    environment = env;
+# endif
+    /*
+     * In 4.x, all activities must be performed inside trampoline
+     * so we are forced to initialise GC immediately
+     * This can be postponed in 3.x but I see no point in implementing
+     * a feature which will work in older versions only.
+     * One would better use conservative GC if he needs dynamic MzScheme
+     */
+    mzscheme_init();
+#else
+    int dummy = 0;
+    stack_base = (void *)&dummy;
+#endif
+    main_loop(FALSE, FALSE);
+#if defined(MZ_PRECISE_GC) && MZSCHEME_VERSION_MAJOR < 400
+    /* releasing dummy */
+    MZ_GC_REG();
+    MZ_GC_UNREG();
+#endif
+    return 0;
+}
+
     static void
 startup_mzscheme(void)
 {
-    Scheme_Object *proc_make_security_guard;
-
-    scheme_set_stack_base(NULL, 1);
+#if !defined(MZ_PRECISE_GC) || MZSCHEME_VERSION_MAJOR < 400
+    scheme_set_stack_base(stack_base, 1);
+#endif
 
     MZ_REGISTER_STATIC(environment);
     MZ_REGISTER_STATIC(curout);
     MZ_REGISTER_STATIC(curerr);
     MZ_REGISTER_STATIC(exn_catching_apply);
     MZ_REGISTER_STATIC(exn_p);
     MZ_REGISTER_STATIC(exn_message);
     MZ_REGISTER_STATIC(vim_exn);
-    MZ_REGISTER_STATIC(vim_exn_names);
-    MZ_REGISTER_STATIC(vim_exn_values);
 
+#if !defined(MZ_PRECISE_GC) || MZSCHEME_VERSION_MAJOR < 400
+    /* in newer versions of precise GC the initial env has been created */
     environment = scheme_basic_env();
+#endif
+    MZ_GC_CHECK();
+
+#ifdef INCLUDE_MZSCHEME_BASE
+    {
+	/*
+	 * versions 4.x do not provide Scheme bindings by default
+	 * we need to add them explicitly
+	 */
+	Scheme_Object *scheme_base_symbol = NULL;
+	MZ_GC_DECL_REG(1);
+	MZ_GC_VAR_IN_REG(0, scheme_base_symbol);
+	MZ_GC_REG();
+	/* invoke function from generated and included mzscheme_base.c */
+	declare_modules(environment);
+	scheme_base_symbol = scheme_intern_symbol("scheme/base");
+	MZ_GC_CHECK();
+	scheme_namespace_require(scheme_base_symbol);
+	MZ_GC_CHECK();
+	MZ_GC_UNREG();
+    }
+#endif
+    register_vim_exn();
+    /* use new environment to initialise exception handling */
+    init_exn_catching_apply();
 
     /* redirect output */
     scheme_console_output = do_output;
     scheme_console_printf = do_printf;
 
 #ifdef MZSCHEME_COLLECTS
     /* setup 'current-library-collection-paths' parameter */
-    scheme_set_param(scheme_config, MZCONFIG_COLLECTION_PATHS,
-	    scheme_make_pair(
 # if MZSCHEME_VERSION_MAJOR >= 299
-		scheme_char_string_to_path(
-		    scheme_byte_string_to_char_string(
-			scheme_make_byte_string(MZSCHEME_COLLECTS))),
+    {
+	Scheme_Object	*coll_byte_string = NULL;
+	Scheme_Object	*coll_char_string = NULL;
+	Scheme_Object	*coll_path = NULL;
+	Scheme_Object	*coll_pair = NULL;
+	Scheme_Config	*config = NULL;
+
+	MZ_GC_DECL_REG(5);
+	MZ_GC_VAR_IN_REG(0, coll_byte_string);
+	MZ_GC_VAR_IN_REG(1, coll_char_string);
+	MZ_GC_VAR_IN_REG(2, coll_path);
+	MZ_GC_VAR_IN_REG(3, coll_pair);
+	MZ_GC_VAR_IN_REG(4, config);
+	MZ_GC_REG();
+	coll_byte_string = scheme_make_byte_string(MZSCHEME_COLLECTS);
+	MZ_GC_CHECK();
+	coll_char_string = scheme_byte_string_to_char_string(coll_byte_string);
+	MZ_GC_CHECK();
+	coll_path = scheme_char_string_to_path(coll_char_string);
+	MZ_GC_CHECK();
+	coll_pair = scheme_make_pair(coll_path, scheme_null);
+	MZ_GC_CHECK();
+	config = scheme_config;
+	MZ_GC_CHECK();
+	scheme_set_param(config, MZCONFIG_COLLECTION_PATHS, coll_pair);
+	MZ_GC_CHECK();
+	MZ_GC_UNREG();
+    }
 # else
-		scheme_make_string(MZSCHEME_COLLECTS),
+    {
+	Scheme_Object	*coll_string = NULL;
+	Scheme_Object	*coll_pair = NULL;
+	Scheme_Config	*config = NULL;
+
+	MZ_GC_DECL_REG(3);
+	MZ_GC_VAR_IN_REG(0, coll_string);
+	MZ_GC_VAR_IN_REG(1, coll_pair);
+	MZ_GC_VAR_IN_REG(2, config);
+	MZ_GC_REG();
+	coll_string = scheme_make_string(MZSCHEME_COLLECTS);
+	MZ_GC_CHECK();
+	coll_pair = scheme_make_pair(coll_string, scheme_null);
+	MZ_GC_CHECK();
+	config = scheme_config;
+	MZ_GC_CHECK();
+	scheme_set_param(config, MZCONFIG_COLLECTION_PATHS, coll_pair);
+	MZ_GC_CHECK();
+	MZ_GC_UNREG();
+    }
 # endif
-		scheme_null));
 #endif
 #ifdef HAVE_SANDBOX
-    /* setup sandbox guards */
-    proc_make_security_guard = scheme_lookup_global(
-	    scheme_intern_symbol("make-security-guard"),
-	    environment);
-    if (proc_make_security_guard != NULL)
-    {
-	Scheme_Object *args[3];
-	Scheme_Object *guard;
-	args[0] = scheme_get_param(scheme_config, MZCONFIG_SECURITY_GUARD);
-	args[1] = scheme_make_prim_w_arity(sandbox_file_guard,
-		"sandbox-file-guard", 3, 3);
-	args[2] = scheme_make_prim_w_arity(sandbox_network_guard,
-		"sandbox-network-guard", 4, 4);
-	guard = scheme_apply(proc_make_security_guard, 3, args);
-	scheme_set_param(scheme_config, MZCONFIG_SECURITY_GUARD, guard);
+    {
+	Scheme_Object	*make_security_guard = NULL;
+	MZ_GC_DECL_REG(1);
+	MZ_GC_VAR_IN_REG(0, make_security_guard);
+	MZ_GC_REG();
+
+#if MZSCHEME_VERSION_MAJOR < 400
+	{
+	    Scheme_Object	*make_security_guard_symbol = NULL;
+	    MZ_GC_DECL_REG(1);
+	    MZ_GC_VAR_IN_REG(0, make_security_guard_symbol);
+	    MZ_GC_REG();
+	    make_security_guard_symbol = scheme_intern_symbol("make-security-guard");
+	    MZ_GC_CHECK();
+	    make_security_guard = scheme_lookup_global(
+		    make_security_guard_symbol, environment);
+	    MZ_GC_UNREG();
+	}
+#else
+	make_security_guard = scheme_builtin_value("make-security-guard");
+	MZ_GC_CHECK();
+#endif
+
+	/* setup sandbox guards */
+	if (make_security_guard != NULL)
+	{
+	    Scheme_Object   *args[3] = {NULL, NULL, NULL};
+	    Scheme_Object   *guard = NULL;
+	    Scheme_Config   *config = NULL;
+	    MZ_GC_DECL_REG(5);
+	    MZ_GC_ARRAY_VAR_IN_REG(0, args, 3);
+	    MZ_GC_VAR_IN_REG(3, guard);
+	    MZ_GC_VAR_IN_REG(4, config);
+	    MZ_GC_REG();
+	    config = scheme_config;
+	    MZ_GC_CHECK();
+	    args[0] = scheme_get_param(config, MZCONFIG_SECURITY_GUARD);
+	    MZ_GC_CHECK();
+	    args[1] = scheme_make_prim_w_arity(sandbox_file_guard,
+		    "sandbox-file-guard", 3, 3);
+	    args[2] = scheme_make_prim_w_arity(sandbox_network_guard,
+		    "sandbox-network-guard", 4, 4);
+	    guard = scheme_apply(make_security_guard, 3, args);
+	    MZ_GC_CHECK();
+	    scheme_set_param(config, MZCONFIG_SECURITY_GUARD, guard);
+	    MZ_GC_CHECK();
+	    MZ_GC_UNREG();
+	}
+	MZ_GC_UNREG();
     }
 #endif
     /* Create buffer and window types for use in Scheme code */
     mz_buffer_type = scheme_make_type("<vim-buffer>");
+    MZ_GC_CHECK();
     mz_window_type = scheme_make_type("<vim-window>");
+    MZ_GC_CHECK();
+#ifdef MZ_PRECISE_GC
+    GC_register_traversers(mz_buffer_type,
+	    buffer_size_proc, buffer_mark_proc, buffer_fixup_proc,
+	    TRUE, TRUE);
+    GC_register_traversers(mz_window_type,
+	    window_size_proc, window_mark_proc, window_fixup_proc,
+	    TRUE, TRUE);
+#endif
 
-    register_vim_exn(environment);
-    make_modules(environment);
+    make_modules();
 
     /*
      * setup callback to receive notifications
      * whether thread scheduling is (or not) required
      */
     scheme_notify_multithread = notify_multithread;
-    initialized = 1;
 }
 
 /*
  * This routine is called for each new invocation of MzScheme
  * to make sure things are properly initialized.
  */
     static int
 mzscheme_init(void)
 {
-    int do_require = FALSE;
-
     if (!initialized)
     {
-	do_require = TRUE;
 #ifdef DYNAMIC_MZSCHEME
 	if (!mzscheme_enabled(TRUE))
 	{
-	    EMSG(_("???: Sorry, this command is disabled, the MzScheme library could not be loaded."));
+	    EMSG(_("E815: Sorry, this command is disabled, the MzScheme libraries could not be loaded."));
 	    return -1;
 	}
 #endif
 	startup_mzscheme();
-
-	if (mzscheme_io_init())
-	    return -1;
-
-    }
-    /* recreate ports each call effectivelly clearing these ones */
-    curout = scheme_make_string_output_port();
-    curerr = scheme_make_string_output_port();
-    scheme_set_param(scheme_config, MZCONFIG_OUTPUT_PORT, curout);
-    scheme_set_param(scheme_config, MZCONFIG_ERROR_PORT, curerr);
-
-    if (do_require)
-    {
-	/* auto-instantiate in basic env */
-	eval_in_namespace("(require (prefix vimext: vimext))", do_eval,
-		environment, NULL);
+	initialized = TRUE;
     }
-
-    return 0;
-}
-
-/*
- * This routine fills the namespace with various important routines that can
- * be used within MzScheme.
- */
-    static void
-mzscheme_interface_init(vim_mz_buffer *mzbuff)
-{
-    Scheme_Object   *attach;
-
-    mzbuff->env = (Scheme_Env *)scheme_make_namespace(0, NULL);
-
-    /*
-     * attach instantiated modules from global namespace
-     * so they can be easily instantiated in the buffer namespace
-     */
-    attach = scheme_lookup_global(
-	    scheme_intern_symbol("namespace-attach-module"),
-	    environment);
-
-    if (attach != NULL)
     {
-	Scheme_Object   *ret;
-	Scheme_Object	*args[2];
-
-	args[0] = (Scheme_Object *)environment;
-	args[1] = scheme_intern_symbol("vimext");
-
-	ret = (Scheme_Object *)mzvim_apply(attach, 2, args);
+	Scheme_Config	*config = NULL;
+	MZ_GC_DECL_REG(1);
+	MZ_GC_VAR_IN_REG(0, config);
+	MZ_GC_REG();
+	config = scheme_config;
+	MZ_GC_CHECK();
+	/* recreate ports each call effectively clearing these ones */
+	curout = scheme_make_string_output_port();
+	MZ_GC_CHECK();
+	curerr = scheme_make_string_output_port();
+	MZ_GC_CHECK();
+	scheme_set_param(config, MZCONFIG_OUTPUT_PORT, curout);
+	MZ_GC_CHECK();
+	scheme_set_param(config, MZCONFIG_ERROR_PORT, curerr);
+	MZ_GC_CHECK();
+	MZ_GC_UNREG();
     }
 
-    add_vim_exn(mzbuff->env);
+    return 0;
 }
 
 /*
  *========================================================================
  *  2.  External Interface
  *========================================================================
  */
 
 /*
- * Evaluate command in namespace with exception handling
+ * Evaluate command with exception handling
  */
     static int
-eval_in_namespace(void *data, Scheme_Closed_Prim *what, Scheme_Env *env,
-		Scheme_Object **ret)
+eval_with_exn_handling(void *data, Scheme_Closed_Prim *what, Scheme_Object **ret)
 {
-    Scheme_Object   *value;
-    Scheme_Object   *exn;
-    Cmd_Info	    info;   /* closure info */
-
-    info.data = data;
-    info.env = env;
-
-    scheme_set_param(scheme_config, MZCONFIG_ENV,
-	    (Scheme_Object *) env);
-    /*
-     * ensure all evaluations will be in current buffer namespace,
-     * the second argument to scheme_eval_string isn't enough!
-     */
-    value = _apply_thunk_catch_exceptions(
-	    scheme_make_closed_prim_w_arity(what, &info, "mzvim", 0, 0),
-	    &exn);
+    Scheme_Object   *value = NULL;
+    Scheme_Object   *exn = NULL;
+    Scheme_Object   *prim = NULL;
+
+    MZ_GC_DECL_REG(3);
+    MZ_GC_VAR_IN_REG(0, value);
+    MZ_GC_VAR_IN_REG(1, exn);
+    MZ_GC_VAR_IN_REG(2, prim);
+    MZ_GC_REG();
+
+    prim = scheme_make_closed_prim_w_arity(what, data, "mzvim", 0, 0);
+    MZ_GC_CHECK();
+    value = _apply_thunk_catch_exceptions(prim, &exn);
+    MZ_GC_CHECK();
 
     if (!value)
     {
 	value = extract_exn_message(exn);
 	/* Got an exn? */
 	if (value)
 	{
-	    scheme_display(value, curerr);  /*  Send to stderr-vim */
+	    scheme_display(value, curerr);   /*  Send to stderr-vim */
+	    MZ_GC_CHECK();
 	    do_flush();
 	}
+	MZ_GC_UNREG();
 	/* `raise' was called on some arbitrary value */
 	return FAIL;
     }
 
     if (ret != NULL)	/* if pointer to retval supported give it up */
 	*ret = value;
     /* Print any result, as long as it's not a void */
     else if (!SCHEME_VOIDP(value))
+    {
 	scheme_display(value, curout);  /* Send to stdout-vim */
+	MZ_GC_CHECK();
+    }
 
     do_flush();
+    MZ_GC_UNREG();
     return OK;
 }
 
 /* :mzscheme */
     static int
@@ -957,11 +1128,11 @@ do_mzscheme_command(exarg_T *eap, void *
 	return FAIL;
 
     range_start = eap->line1;
     range_end = eap->line2;
 
-    return eval_in_namespace(data, what, get_vim_curr_buffer()->env, NULL);
+    return eval_with_exn_handling(data, what, NULL);
 }
 
 /*
  * Routine called by VIM when deleting a buffer
  */
@@ -974,10 +1145,11 @@ mzscheme_buffer_free(buf_T *buf)
 
 	bp = buf->b_mzscheme_ref;
 	bp->buf = INVALID_BUFFER_VALUE;
 	buf->b_mzscheme_ref = NULL;
 	scheme_gc_ptr_ok(bp);
+	MZ_GC_CHECK();
     }
 }
 
 /*
  * Routine called by VIM when deleting a Window
@@ -990,10 +1162,11 @@ mzscheme_window_free(win_T *win)
 	vim_mz_window *wp;
 	wp = win->w_mzscheme_ref;
 	wp->win = INVALID_WINDOW_VALUE;
 	win->w_mzscheme_ref = NULL;
 	scheme_gc_ptr_ok(wp);
+	MZ_GC_CHECK();
     }
 }
 
 /*
  * ":mzscheme" (or ":mz")
@@ -1014,80 +1187,67 @@ ex_mzscheme(exarg_T *eap)
 	    vim_free(script);
 	}
     }
 }
 
-/* eval MzScheme string */
-    void *
-mzvim_eval_string(char_u *str)
-{
-    Scheme_Object *ret = NULL;
-    if (mzscheme_init())
-	return FAIL;
-
-    eval_in_namespace(str, do_eval, get_vim_curr_buffer()->env, &ret);
-    return ret;
-}
-
-/*
- * apply MzScheme procedure with arguments,
- * handling errors
- */
-    Scheme_Object *
-mzvim_apply(Scheme_Object *proc, int argc, Scheme_Object **argv)
-{
-    Apply_Info	data;
-    Scheme_Object *ret = NULL;
-
-    if (mzscheme_init())
-	return FAIL;
-
-    data.proc = proc;
-    data.argc = argc;
-    data.argv = argv;
-
-    eval_in_namespace(&data, do_apply, get_vim_curr_buffer()->env, &ret);
-    return ret;
-}
-
     static Scheme_Object *
 do_load(void *data, int noargc, Scheme_Object **noargv)
 {
-    Cmd_Info	    *info = (Cmd_Info *)data;
-    Scheme_Object   *result = scheme_void;
-    Scheme_Object   *expr;
-    char_u	    *file = scheme_malloc_fail_ok(
-					  scheme_malloc_atomic, MAXPATHL + 1);
-    Port_Info	    *pinfo = (Port_Info *)(info->data);
+    Scheme_Object   *expr = NULL;
+    Scheme_Object   *result = NULL;
+    char	    *file = NULL;
+    Port_Info	    *pinfo = (Port_Info *)data;
+
+    MZ_GC_DECL_REG(3);
+    MZ_GC_VAR_IN_REG(0, expr);
+    MZ_GC_VAR_IN_REG(1, result);
+    MZ_GC_VAR_IN_REG(2, file);
+    MZ_GC_REG();
+
+    file = (char *)scheme_malloc_fail_ok(scheme_malloc_atomic, MAXPATHL + 1);
+    MZ_GC_CHECK();
 
     /* make Vim expansion */
-    expand_env((char_u *)pinfo->name, file, MAXPATHL);
-    /* scheme_load looks strange working with namespaces and error handling*/
+    expand_env((char_u *)pinfo->name, (char_u *)file, MAXPATHL);
     pinfo->port = scheme_open_input_file(file, "mzfile");
-    scheme_count_lines(pinfo->port); /* to get accurate read error location*/
+    MZ_GC_CHECK();
+    scheme_count_lines(pinfo->port);  /* to get accurate read error location*/
+    MZ_GC_CHECK();
 
     /* Like REPL but print only last result */
     while (!SCHEME_EOFP(expr = scheme_read(pinfo->port)))
-	result = scheme_eval(expr, info->env);
+    {
+	result = scheme_eval(expr, environment);
+	MZ_GC_CHECK();
+    }
 
-    /* errors will be caught in do_mzscheme_comamnd and ex_mzfile */
+    /* errors will be caught in do_mzscheme_command and ex_mzfile */
     scheme_close_input_port(pinfo->port);
+    MZ_GC_CHECK();
     pinfo->port = NULL;
+    MZ_GC_UNREG();
     return result;
 }
 
 /* :mzfile */
     void
 ex_mzfile(exarg_T *eap)
 {
-    Port_Info	pinfo;
+    Port_Info	pinfo = {NULL, NULL};
+
+    MZ_GC_DECL_REG(1);
+    MZ_GC_VAR_IN_REG(0, pinfo.port);
+    MZ_GC_REG();
 
     pinfo.name = (char *)eap->arg;
-    pinfo.port = NULL;
     if (do_mzscheme_command(eap, &pinfo, do_load) != OK
 	    && pinfo.port != NULL)	/* looks like port was not closed */
+    {
 	scheme_close_input_port(pinfo.port);
+	MZ_GC_CHECK();
+    }
+    MZ_GC_UNREG();
 }
 
 
 /*
  *========================================================================
@@ -1103,18 +1263,16 @@ init_exn_catching_apply(void)
 	char *e =
 	    "(lambda (thunk) "
 		"(with-handlers ([void (lambda (exn) (cons #f exn))]) "
 		"(cons #t (thunk))))";
 
-	/* make sure we have a namespace with the standard syntax: */
-	Scheme_Env *env = (Scheme_Env *)scheme_make_namespace(0, NULL);
-	add_vim_exn(env);
-
-	exn_catching_apply = scheme_eval_string(e, env);
-	exn_p = scheme_lookup_global(scheme_intern_symbol("exn?"), env);
-	exn_message = scheme_lookup_global(
-		scheme_intern_symbol("exn-message"), env);
+	exn_catching_apply = scheme_eval_string(e, environment);
+	MZ_GC_CHECK();
+	exn_p = scheme_builtin_value("exn?");
+	MZ_GC_CHECK();
+	exn_message = scheme_builtin_value("exn-message");
+	MZ_GC_CHECK();
     }
 }
 
 /*
  * This function applies a thunk, returning the Scheme value if there's
@@ -1124,12 +1282,10 @@ init_exn_catching_apply(void)
     static Scheme_Object *
 _apply_thunk_catch_exceptions(Scheme_Object *f, Scheme_Object **exn)
 {
     Scheme_Object *v;
 
-    init_exn_catching_apply();
-
     v = _scheme_apply(exn_catching_apply, 1, &f);
     /* v is a pair: (cons #t value) or (cons #f exn) */
 
     if (SCHEME_TRUEP(SCHEME_CAR(v)))
 	return SCHEME_CDR(v);
@@ -1141,32 +1297,20 @@ _apply_thunk_catch_exceptions(Scheme_Obj
 }
 
     static Scheme_Object *
 extract_exn_message(Scheme_Object *v)
 {
-    init_exn_catching_apply();
-
     if (SCHEME_TRUEP(_scheme_apply(exn_p, 1, &v)))
 	return _scheme_apply(exn_message, 1, &v);
     else
 	return NULL; /* Not an exn structure */
 }
 
     static Scheme_Object *
 do_eval(void *s, int noargc, Scheme_Object **noargv)
 {
-    Cmd_Info	*info = (Cmd_Info *)s;
-
-    return scheme_eval_string_all((char *)(info->data), info->env, TRUE);
-}
-
-    static Scheme_Object *
-do_apply(void *a, int noargc, Scheme_Object **noargv)
-{
-    Apply_Info	*info = (Apply_Info *)(((Cmd_Info *)a)->data);
-
-    return scheme_apply(info->proc, info->argc, info->argv);
+    return scheme_eval_string_all((char *)s, environment, TRUE);
 }
 
 /*
  *========================================================================
  *  3.  MzScheme I/O Handlers
@@ -1219,28 +1363,23 @@ do_flush(void)
 {
     char *buff;
     long length;
 
     buff = scheme_get_sized_string_output(curerr, &length);
+    MZ_GC_CHECK();
     if (length)
     {
 	do_err_output(buff, length);
 	return;
     }
 
     buff = scheme_get_sized_string_output(curout, &length);
+    MZ_GC_CHECK();
     if (length)
 	do_output(buff, length);
 }
 
-    static int
-mzscheme_io_init(void)
-{
-    /* Nothing needed so far... */
-    return 0;
-}
-
 /*
  *========================================================================
  *  4. Implementation of the Vim Features for MzScheme
  *========================================================================
  */
@@ -1263,26 +1402,34 @@ vim_command(void *data, int argc, Scheme
 /* (eval {expr-string}) */
     static Scheme_Object *
 vim_eval(void *data, int argc, Scheme_Object **argv)
 {
 #ifdef FEAT_EVAL
-    Vim_Prim	    *prim = (Vim_Prim *)data;
-    char	    *expr;
-    char	    *str;
-    Scheme_Object   *result;
+    Vim_Prim		*prim = (Vim_Prim *)data;
+    char		*expr;
+    Scheme_Object	*result;
+    /* hash table to store visited values to avoid infinite loops */
+    Scheme_Hash_Table	*visited = NULL;
+    typval_T		*vim_result;
+
+    MZ_GC_DECL_REG(1);
+    MZ_GC_VAR_IN_REG(0, visited);
+    MZ_GC_REG();
 
-    expr = SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
+    visited = scheme_make_hash_table(SCHEME_hash_ptr);
+    MZ_GC_CHECK();
 
-    str = (char *)eval_to_string((char_u *)expr, NULL, TRUE);
+    expr = SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
+    vim_result = eval_expr((char_u *)expr, NULL);
 
-    if (str == NULL)
+    if (vim_result == NULL)
 	raise_vim_exn(_("invalid expression"));
 
-    result = scheme_make_string(str);
-
-    vim_free(str);
+    result = vim_to_mzscheme(vim_result, 1, visited);
+    free_tv(vim_result);
 
+    MZ_GC_UNREG();
     return result;
 #else
     raise_vim_exn(_("expressions disabled at compile time"));
     /* unreachable */
     return scheme_false;
@@ -1318,11 +1465,11 @@ static Scheme_Object *M_global = NULL;
 get_option(void *data, int argc, Scheme_Object **argv)
 {
     Vim_Prim	    *prim = (Vim_Prim *)data;
     char_u	    *name;
     long	    value;
-    char_u	    *strval;
+    char	    *strval;
     int		    rc;
     Scheme_Object   *rval;
     int		    opt_flags = 0;
     buf_T	    *save_curb = curbuf;
     win_T	    *save_curw = curwin;
@@ -1333,10 +1480,11 @@ get_option(void *data, int argc, Scheme_
     {
 	if (M_global == NULL)
 	{
 	    MZ_REGISTER_STATIC(M_global);
 	    M_global = scheme_intern_symbol("global");
+	    MZ_GC_CHECK();
 	}
 
 	if (argv[1] == M_global)
 	    opt_flags = OPT_GLOBAL;
 	else if (SCHEME_VIMBUFFERP(argv[1]))
@@ -1354,20 +1502,21 @@ get_option(void *data, int argc, Scheme_
 	}
 	else
 	    scheme_wrong_type(prim->name, "vim-buffer/window", 1, argc, argv);
     }
 
-    rc = get_option_value(name, &value, &strval, opt_flags);
+    rc = get_option_value(name, &value, (char_u **)&strval, opt_flags);
     curbuf = save_curb;
     curwin = save_curw;
 
     switch (rc)
     {
     case 1:
 	return scheme_make_integer_value(value);
     case 0:
 	rval = scheme_make_string(strval);
+	MZ_GC_CHECK();
 	vim_free(strval);
 	return rval;
     case -1:
     case -2:
 	raise_vim_exn(_("hidden option"));
@@ -1393,10 +1542,11 @@ set_option(void *data, int argc, Scheme_
     {
 	if (M_global == NULL)
 	{
 	    MZ_REGISTER_STATIC(M_global);
 	    M_global = scheme_intern_symbol("global");
+	    MZ_GC_CHECK();
 	}
 
 	if (argv[1] == M_global)
 	    opt_flags = OPT_GLOBAL;
 	else if (SCHEME_VIMBUFFERP(argv[1]))
@@ -1463,19 +1613,26 @@ get_window_list(void *data, int argc, Sc
     buf = get_buffer_arg(prim->name, 0, argc, argv);
     list = scheme_null;
 
     for (w = firstwin; w != NULL; w = w->w_next)
 	if (w->w_buffer == buf->buf)
+	{
 	    list = scheme_make_pair(window_new(w), list);
+	    MZ_GC_CHECK();
+	}
 
     return list;
 }
 
     static Scheme_Object *
 window_new(win_T *win)
 {
-    vim_mz_window *self;
+    vim_mz_window *self = NULL;
+
+    MZ_GC_DECL_REG(1);
+    MZ_GC_VAR_IN_REG(0, self);
+    MZ_GC_REG();
 
     /* We need to handle deletion of windows underneath us.
      * If we add a "w_mzscheme_ref" field to the win_T structure,
      * then we can get at it in win_free() in vim.
      *
@@ -1485,17 +1642,18 @@ window_new(win_T *win)
      */
     if (win->w_mzscheme_ref != NULL)
 	return win->w_mzscheme_ref;
 
     self = scheme_malloc_fail_ok(scheme_malloc, sizeof(vim_mz_window));
-
     vim_memset(self, 0, sizeof(vim_mz_window));
     scheme_dont_gc_ptr(self);	/* because win isn't visible to GC */
+    MZ_GC_CHECK();
     win->w_mzscheme_ref = self;
     self->win = win;
-    self->tag = mz_window_type;
+    self->so.type = mz_window_type;
 
+    MZ_GC_UNREG();
     return (Scheme_Object *)(self);
 }
 
 /* (get-win-num [window]) */
     static Scheme_Object *
@@ -1660,27 +1818,26 @@ set_cursor(void *data, int argc, Scheme_
     return scheme_void;
 }
 /*
  *===========================================================================
  *  6. Vim Buffer-related Manipulation Functions
- *     Note that each buffer should have its own private namespace.
  *===========================================================================
  */
 
 /* (open-buff {filename}) */
     static Scheme_Object *
 mzscheme_open_buffer(void *data, int argc, Scheme_Object **argv)
 {
     Vim_Prim	    *prim = (Vim_Prim *)data;
-    char	    *fname;
+    char_u	    *fname;
     int		    num = 0;
     Scheme_Object   *onum;
 
 #ifdef HAVE_SANDBOX
     sandbox_check();
 #endif
-    fname = SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
+    fname = (char_u *)SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
     /* TODO make open existing file */
     num = buflist_add(fname, BLN_LISTED | BLN_CURBUF);
 
     if (num == 0)
 	raise_vim_exn(_("couldn't open buffer"));
@@ -1712,11 +1869,11 @@ get_buffer_by_name(void *data, int argc,
 {
     Vim_Prim	*prim = (Vim_Prim *)data;
     buf_T	*buf;
     char_u	*fname;
 
-    fname = SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
+    fname = (char_u *)SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
 
     for (buf = firstbuf; buf; buf = buf->b_next)
 	if (buf->b_ffname == NULL || buf->b_sfname == NULL)
 	    /* empty string */
 	{
@@ -1783,11 +1940,11 @@ get_buffer_count(void *data, int argc, S
 get_buffer_name(void *data, int argc, Scheme_Object **argv)
 {
     Vim_Prim	    *prim = (Vim_Prim *)data;
     vim_mz_buffer   *buf = get_buffer_arg(prim->name, 0, argc, argv);
 
-    return scheme_make_string(buf->buf->b_ffname);
+    return scheme_make_string((char *)buf->buf->b_ffname);
 }
 
 /* (curr-buff) */
     static Scheme_Object *
 get_curr_buffer(void *data, int argc, Scheme_Object **argv)
@@ -1796,29 +1953,32 @@ get_curr_buffer(void *data, int argc, Sc
 }
 
     static Scheme_Object *
 buffer_new(buf_T *buf)
 {
-    vim_mz_buffer *self;
+    vim_mz_buffer *self = NULL;
+
+    MZ_GC_DECL_REG(1);
+    MZ_GC_VAR_IN_REG(0, self);
+    MZ_GC_REG();
 
     /* We need to handle deletion of buffers underneath us.
      * If we add a "b_mzscheme_ref" field to the buf_T structure,
      * then we can get at it in buf_freeall() in vim.
      */
     if (buf->b_mzscheme_ref)
 	return buf->b_mzscheme_ref;
 
     self = scheme_malloc_fail_ok(scheme_malloc, sizeof(vim_mz_buffer));
-
     vim_memset(self, 0, sizeof(vim_mz_buffer));
-    scheme_dont_gc_ptr(self);	/* because buf isn't visible to GC */
+    scheme_dont_gc_ptr(self); /* because buf isn't visible to GC */
+    MZ_GC_CHECK();
     buf->b_mzscheme_ref = self;
     self->buf = buf;
-    self->tag = mz_buffer_type;
-
-    mzscheme_interface_init(self);	/* Set up namespace */
+    self->so.type = mz_buffer_type;
 
+    MZ_GC_UNREG();
     return (Scheme_Object *)(self);
 }
 
 /*
  * (get-buff-size [buffer])
@@ -1845,18 +2005,18 @@ get_buffer_size(void *data, int argc, Sc
 get_buffer_line(void *data, int argc, Scheme_Object **argv)
 {
     Vim_Prim	    *prim = (Vim_Prim *)data;
     vim_mz_buffer   *buf;
     int		    linenr;
-    char	    *line;
+    char_u	    *line;
 
     buf = get_buffer_arg(prim->name, 1, argc, argv);
     linenr = SCHEME_INT_VAL(GUARANTEE_INTEGER(prim->name, 0));
     line = ml_get_buf(buf->buf, (linenr_T)linenr, FALSE);
 
     raise_if_error();
-    return scheme_make_string(line);
+    return scheme_make_string((char *)line);
 }
 
 
 /*
  * (get-buff-line-list {start} {end} [buffer])
@@ -1869,11 +2029,15 @@ get_buffer_line(void *data, int argc, Sc
 get_buffer_line_list(void *data, int argc, Scheme_Object **argv)
 {
     Vim_Prim	    *prim = (Vim_Prim *)data;
     vim_mz_buffer   *buf;
     int		    i, hi, lo, n;
-    Scheme_Object   *list;
+    Scheme_Object   *list = NULL;
+
+    MZ_GC_DECL_REG(1);
+    MZ_GC_VAR_IN_REG(0, list);
+    MZ_GC_REG();
 
     buf = get_buffer_arg(prim->name, 2, argc, argv);
     list = scheme_null;
     hi = SCHEME_INT_VAL(GUARANTEE_INTEGER(prim->name, 1));
     lo = SCHEME_INT_VAL(GUARANTEE_INTEGER(prim->name, 0));
@@ -1897,12 +2061,13 @@ get_buffer_line_list(void *data, int arg
 		       (char *)ml_get_buf(buf->buf, (linenr_T)(lo+i), FALSE));
 	raise_if_error();
 
 	/* Set the list item */
 	list = scheme_make_pair(str, list);
+	MZ_GC_CHECK();
     }
-
+    MZ_GC_UNREG();
     return list;
 }
 
 /*
  * (set-buff-line {linenr} {string/#f} [buffer])
@@ -1917,23 +2082,26 @@ get_buffer_line_list(void *data, int arg
  * string changed.
  */
     static Scheme_Object *
 set_buffer_line(void *data, int argc, Scheme_Object **argv)
 {
-    /* First of all, we check the the of the supplied MzScheme object.
+    /* First of all, we check the value of the supplied MzScheme object.
      * There are three cases:
      *	  1. #f - this is a deletion.
      *	  2. A string	   - this is a replacement.
      *	  3. Anything else - this is an error.
      */
     Vim_Prim	    *prim = (Vim_Prim *)data;
     vim_mz_buffer   *buf;
-    Scheme_Object   *line;
+    Scheme_Object   *line = NULL;
     char	    *save;
-    buf_T	    *savebuf;
     int		    n;
 
+    MZ_GC_DECL_REG(1);
+    MZ_GC_VAR_IN_REG(0, line);
+    MZ_GC_REG();
+
 #ifdef HAVE_SANDBOX
     sandbox_check();
 #endif
     n = SCHEME_INT_VAL(GUARANTEE_INTEGER(prim->name, 0));
     if (!SCHEME_STRINGP(argv[1]) && !SCHEME_FALSEP(argv[1]))
@@ -1943,11 +2111,12 @@ set_buffer_line(void *data, int argc, Sc
 
     check_line_range(n, buf->buf);
 
     if (SCHEME_FALSEP(line))
     {
-	savebuf = curbuf;
+	buf_T	    *savebuf = curbuf;
+
 	curbuf = buf->buf;
 
 	if (u_savedel((linenr_T)n, 1L) == FAIL)
 	{
 	    curbuf = savebuf;
@@ -1956,43 +2125,66 @@ set_buffer_line(void *data, int argc, Sc
 	else if (ml_delete((linenr_T)n, FALSE) == FAIL)
 	{
 	    curbuf = savebuf;
 	    raise_vim_exn(_("cannot delete line"));
 	}
-	deleted_lines_mark((linenr_T)n, 1L);
 	if (buf->buf == curwin->w_buffer)
 	    mz_fix_cursor(n, n + 1, -1);
+	deleted_lines_mark((linenr_T)n, 1L);
 
 	curbuf = savebuf;
 
+	MZ_GC_UNREG();
 	raise_if_error();
 	return scheme_void;
     }
+    else
+    {
+	/* Otherwise it's a line */
+	buf_T	    *savebuf = curbuf;
 
-    /* Otherwise it's a line */
-    save = string_to_line(line);
-    savebuf = curbuf;
+	save = string_to_line(line);
 
-    curbuf = buf->buf;
+	curbuf = buf->buf;
+
+	if (u_savesub((linenr_T)n) == FAIL)
+	{
+	    curbuf = savebuf;
+	    vim_free(save);
+	    raise_vim_exn(_("cannot save undo information"));
+	}
+	else if (ml_replace((linenr_T)n, (char_u *)save, TRUE) == FAIL)
+	{
+	    curbuf = savebuf;
+	    vim_free(save);
+	    raise_vim_exn(_("cannot replace line"));
+	}
+	else
+	{
+	    vim_free(save);
+	    changed_bytes((linenr_T)n, 0);
+	}
 
-    if (u_savesub((linenr_T)n) == FAIL)
-    {
-	curbuf = savebuf;
-	raise_vim_exn(_("cannot save undo information"));
-    }
-    else if (ml_replace((linenr_T)n, (char_u *)save, TRUE) == FAIL)
-    {
 	curbuf = savebuf;
-	raise_vim_exn(_("cannot replace line"));
-    }
-    else
-	changed_bytes((linenr_T)n, 0);
 
-    curbuf = savebuf;
+	/* Check that the cursor is not beyond the end of the line now. */
+	if (buf->buf == curwin->w_buffer)
+	    check_cursor_col();
 
-    raise_if_error();
-    return scheme_void;
+	MZ_GC_UNREG();
+	raise_if_error();
+	return scheme_void;
+    }
+}
+
+    static void
+free_array(char **array)
+{
+    char **curr = array;
+    while (*curr != NULL)
+	vim_free(*curr++);
+    vim_free(array);
 }
 
 /*
  * (set-buff-line-list {start} {end} {string-list/#f/null} [buffer])
  *
@@ -2013,19 +2205,19 @@ set_buffer_line_list(void *data, int arg
      *	  1. #f - this is a deletion.
      *	  2. A list	   - this is a replacement.
      *	  3. Anything else - this is an error.
      */
     Vim_Prim	    *prim = (Vim_Prim *)data;
-    vim_mz_buffer   *buf;
-    Scheme_Object   *line_list;
-    Scheme_Object   *line;
-    Scheme_Object   *rest;
-    char	    **array;
-    buf_T	    *savebuf;
+    vim_mz_buffer   *buf = NULL;
+    Scheme_Object   *line_list = NULL;
     int		    i, old_len, new_len, hi, lo;
     long	    extra;
 
+    MZ_GC_DECL_REG(1);
+    MZ_GC_VAR_IN_REG(0, line_list);
+    MZ_GC_REG();
+
 #ifdef HAVE_SANDBOX
     sandbox_check();
 #endif
     lo = SCHEME_INT_VAL(GUARANTEE_INTEGER(prim->name, 0));
     hi = SCHEME_INT_VAL(GUARANTEE_INTEGER(prim->name, 1));
@@ -2047,11 +2239,11 @@ set_buffer_line_list(void *data, int arg
     check_line_range(lo, buf->buf);	    /* inclusive */
     check_line_range(hi - 1, buf->buf);	    /* exclusive */
 
     if (SCHEME_FALSEP(line_list) || SCHEME_NULLP(line_list))
     {
-	savebuf = curbuf;
+	buf_T	*savebuf = curbuf;
 	curbuf = buf->buf;
 
 	if (u_savedel((linenr_T)lo, (long)old_len) == FAIL)
 	{
 	    curbuf = savebuf;
@@ -2063,115 +2255,138 @@ set_buffer_line_list(void *data, int arg
 		if (ml_delete((linenr_T)lo, FALSE) == FAIL)
 		{
 		    curbuf = savebuf;
 		    raise_vim_exn(_("cannot delete line"));
 		}
-	    deleted_lines_mark((linenr_T)lo, (long)old_len);
 	    if (buf->buf == curwin->w_buffer)
 		mz_fix_cursor(lo, hi, -old_len);
+	    deleted_lines_mark((linenr_T)lo, (long)old_len);
 	}
 
 	curbuf = savebuf;
 
+	MZ_GC_UNREG();
 	raise_if_error();
 	return scheme_void;
     }
+    else
+    {
+	buf_T	*savebuf = curbuf;
 
-    /* List */
-    new_len = scheme_proper_list_length(line_list);
-    if (new_len < 0)	/* improper or cyclic list */
-	scheme_wrong_type(prim->name, "proper list",
-		2, argc, argv);
+	/* List */
+	new_len = scheme_proper_list_length(line_list);
+	MZ_GC_CHECK();
+	if (new_len < 0)	/* improper or cyclic list */
+	    scheme_wrong_type(prim->name, "proper list",
+		    2, argc, argv);
+	else
+	{
+	    char		**array = NULL;
+	    Scheme_Object   *line = NULL;
+	    Scheme_Object   *rest = NULL;
+
+	    MZ_GC_DECL_REG(2);
+	    MZ_GC_VAR_IN_REG(0, line);
+	    MZ_GC_VAR_IN_REG(1, rest);
+	    MZ_GC_REG();
 
-    /* Using MzScheme allocator, so we don't need to free this and
-     * can safely keep pointers to GC collected strings
-     */
-    array = (char **)scheme_malloc_fail_ok(scheme_malloc,
-		(unsigned)(new_len * sizeof(char *)));
+	    array = (char **)alloc(new_len * sizeof(char *));
+	    vim_memset(array, 0, new_len * sizeof(char *));
 
-    rest = line_list;
-    for (i = 0; i < new_len; ++i)
-    {
-	line = SCHEME_CAR(rest);
-	rest = SCHEME_CDR(rest);
-	if (!SCHEME_STRINGP(line))
-	    scheme_wrong_type(prim->name, "string-list", 2, argc, argv);
-	array[i] = string_to_line(line);
-    }
+	    rest = line_list;
+	    for (i = 0; i < new_len; ++i)
+	    {
+		line = SCHEME_CAR(rest);
+		rest = SCHEME_CDR(rest);
+		if (!SCHEME_STRINGP(line))
+		{
+		    free_array(array);
+		    scheme_wrong_type(prim->name, "string-list", 2, argc, argv);
+		}
+		array[i] = string_to_line(line);
+	    }
 
-    savebuf = curbuf;
-    curbuf = buf->buf;
+	    curbuf = buf->buf;
 
-    if (u_save((linenr_T)(lo-1), (linenr_T)hi) == FAIL)
-    {
-	curbuf = savebuf;
-	raise_vim_exn(_("cannot save undo information"));
-    }
+	    if (u_save((linenr_T)(lo-1), (linenr_T)hi) == FAIL)
+	    {
+		curbuf = savebuf;
+		free_array(array);
+		raise_vim_exn(_("cannot save undo information"));
+	    }
 
-    /*
-     * If the size of the range is reducing (ie, new_len < old_len) we
-     * need to delete some old_len. We do this at the start, by
-     * repeatedly deleting line "lo".
-     */
-    for (i = 0; i < old_len - new_len; ++i)
-    {
-	if (ml_delete((linenr_T)lo, FALSE) == FAIL)
-	{
-	    curbuf = savebuf;
-	    raise_vim_exn(_("cannot delete line"));
-	}
-	extra--;
-    }
+	    /*
+	     * If the size of the range is reducing (ie, new_len < old_len) we
+	     * need to delete some old_len. We do this at the start, by
+	     * repeatedly deleting line "lo".
+	     */
+	    for (i = 0; i < old_len - new_len; ++i)
+	    {
+		if (ml_delete((linenr_T)lo, FALSE) == FAIL)
+		{
+		    curbuf = savebuf;
+		    free_array(array);
+		    raise_vim_exn(_("cannot delete line"));
+		}
+		extra--;
+	    }
 
-    /*
-     * For as long as possible, replace the existing old_len with the
-     * new old_len. This is a more efficient operation, as it requires
-     * less memory allocation and freeing.
-     */
-    for (i = 0; i < old_len && i < new_len; i++)
-	if (ml_replace((linenr_T)(lo+i), (char_u *)array[i], TRUE) == FAIL)
-	{
-	    curbuf = savebuf;
-	    raise_vim_exn(_("cannot replace line"));
-	}
+	    /*
+	     * For as long as possible, replace the existing old_len with the
+	     * new old_len. This is a more efficient operation, as it requires
+	     * less memory allocation and freeing.
+	     */
+	    for (i = 0; i < old_len && i < new_len; i++)
+		if (ml_replace((linenr_T)(lo+i), (char_u *)array[i], TRUE) == FAIL)
+		{
+		    curbuf = savebuf;
+		    free_array(array);
+		    raise_vim_exn(_("cannot replace line"));
+		}
 
-    /*
-     * Now we may need to insert the remaining new_len.  We don't need to
-     * free the string passed back because MzScheme has control of that
-     * memory.
-     */
-    while (i < new_len)
-    {
-	if (ml_append((linenr_T)(lo + i - 1),
-		(char_u *)array[i], 0, FALSE) == FAIL)
-	{
-	    curbuf = savebuf;
-	    raise_vim_exn(_("cannot insert line"));
+	    /*
+	     * Now we may need to insert the remaining new_len.  We don't need to
+	     * free the string passed back because MzScheme has control of that
+	     * memory.
+	     */
+	    while (i < new_len)
+	    {
+		if (ml_append((linenr_T)(lo + i - 1),
+			    (char_u *)array[i], 0, FALSE) == FAIL)
+		{
+		    curbuf = savebuf;
+		    free_array(array);
+		    raise_vim_exn(_("cannot insert line"));
+		}
+		++i;
+		++extra;
+	    }
+	    MZ_GC_UNREG();
+	    free_array(array);
 	}
-	++i;
-	++extra;
-    }
 
-    /*
-     * Adjust marks. Invalidate any which lie in the
-     * changed range, and move any in the remainder of the buffer.
-     */
-    mark_adjust((linenr_T)lo, (linenr_T)(hi - 1), (long)MAXLNUM, (long)extra);
-    changed_lines((linenr_T)lo, 0, (linenr_T)hi, (long)extra);
+	/*
+	 * Adjust marks. Invalidate any which lie in the
+	 * changed range, and move any in the remainder of the buffer.
+	 */
+	mark_adjust((linenr_T)lo, (linenr_T)(hi - 1), (long)MAXLNUM, (long)extra);
+	changed_lines((linenr_T)lo, 0, (linenr_T)hi, (long)extra);
 
-    if (buf->buf == curwin->w_buffer)
-	mz_fix_cursor(lo, hi, extra);
-    curbuf = savebuf;
+	if (buf->buf == curwin->w_buffer)
+	    mz_fix_cursor(lo, hi, extra);
+	curbuf = savebuf;
 
-    raise_if_error();
-    return scheme_void;
+	MZ_GC_UNREG();
+	raise_if_error();
+	return scheme_void;
+    }
 }
 
 /*
  * (insert-buff-line-list {linenr} {string/string-list} [buffer])
  *
- * Insert a number of lines into the specified buffer after the specifed line.
+ * Insert a number of lines into the specified buffer after the specified line.
  * The line number is in Vim format (1-based). The lines to be inserted are
  * given as an MzScheme list of string objects or as a single string. The lines
  * to be added are checked for validity and correct format. Errors are
  * returned as a value of FAIL.  The return value is OK on success.
  * If OK is returned and len_change is not NULL, *len_change
@@ -2179,19 +2394,19 @@ set_buffer_line_list(void *data, int arg
  */
     static Scheme_Object *
 insert_buffer_line_list(void *data, int argc, Scheme_Object **argv)
 {
     Vim_Prim	    *prim = (Vim_Prim *)data;
-    vim_mz_buffer   *buf;
-    Scheme_Object   *list;
-    Scheme_Object   *line;
-    Scheme_Object   *rest;
-    char	    **array;
-    char	    *str;
-    buf_T	    *savebuf;
+    vim_mz_buffer   *buf = NULL;
+    Scheme_Object   *list = NULL;
+    char	    *str = NULL;
     int		    i, n, size;
 
+    MZ_GC_DECL_REG(1);
+    MZ_GC_VAR_IN_REG(0, list);
+    MZ_GC_REG();
+
 #ifdef HAVE_SANDBOX
     sandbox_check();
 #endif
     /*
      * First of all, we check the type of the supplied MzScheme object.
@@ -2206,93 +2421,103 @@ insert_buffer_line_list(void *data, int
 
     if (n != 0)	    /* 0 can be used in insert */
 	check_line_range(n, buf->buf);
     if (SCHEME_STRINGP(list))
     {
-	str = string_to_line(list);
+	buf_T	    *savebuf = curbuf;
 
-	savebuf = curbuf;
+	str = string_to_line(list);
 	curbuf = buf->buf;
 
 	if (u_save((linenr_T)n, (linenr_T)(n+1)) == FAIL)
 	{
 	    curbuf = savebuf;
+	    vim_free(str);
 	    raise_vim_exn(_("cannot save undo information"));
 	}
 	else if (ml_append((linenr_T)n, (char_u *)str, 0, FALSE) == FAIL)
 	{
 	    curbuf = savebuf;
+	    vim_free(str);
 	    raise_vim_exn(_("cannot insert line"));
 	}
 	else
+	{
+	    vim_free(str);
 	    appended_lines_mark((linenr_T)n, 1L);
+	}
 
 	curbuf = savebuf;
 	update_screen(VALID);
 
+	MZ_GC_UNREG();
 	raise_if_error();
 	return scheme_void;
     }
 
     /* List */
     size = scheme_proper_list_length(list);
+    MZ_GC_CHECK();
     if (size < 0)	/* improper or cyclic list */
 	scheme_wrong_type(prim->name, "proper list",
 		2, argc, argv);
-
-    /* Using MzScheme allocator, so we don't need to free this and
-     * can safely keep pointers to GC collected strings
-     */
-    array = (char **)scheme_malloc_fail_ok(
-	    scheme_malloc, (unsigned)(size * sizeof(char *)));
-
-    rest = list;
-    for (i = 0; i < size; ++i)
+    else
     {
-	line = SCHEME_CAR(rest);
-	rest = SCHEME_CDR(rest);
-	array[i] = string_to_line(line);
-    }
+	Scheme_Object   *line = NULL;
+	Scheme_Object   *rest = NULL;
+	char		**array;
+	buf_T		*savebuf = curbuf;
+
+	MZ_GC_DECL_REG(2);
+	MZ_GC_VAR_IN_REG(0, line);
+	MZ_GC_VAR_IN_REG(1, rest);
+	MZ_GC_REG();
 
-    savebuf = curbuf;
-    curbuf = buf->buf;
+	array = (char **)alloc(size * sizeof(char *));
+	vim_memset(array, 0, size * sizeof(char *));
 
-    if (u_save((linenr_T)n, (linenr_T)(n + 1)) == FAIL)
-    {
-	curbuf = savebuf;
-	raise_vim_exn(_("cannot save undo information"));
-    }
-    else
-    {
+	rest = list;
 	for (i = 0; i < size; ++i)
-	    if (ml_append((linenr_T)(n + i), (char_u *)array[i],
-			0, FALSE) == FAIL)
-	    {
-		curbuf = savebuf;
-		raise_vim_exn(_("cannot insert line"));
-	    }
+	{
+	    line = SCHEME_CAR(rest);
+	    rest = SCHEME_CDR(rest);
+	    array[i] = string_to_line(line);
+	}
 
-	if (i > 0)
-	    appended_lines_mark((linenr_T)n, (long)i);
-    }
+	curbuf = buf->buf;
 
-    curbuf = savebuf;
-    update_screen(VALID);
+	if (u_save((linenr_T)n, (linenr_T)(n + 1)) == FAIL)
+	{
+	    curbuf = savebuf;
+	    free_array(array);
+	    raise_vim_exn(_("cannot save undo information"));
+	}
+	else
+	{
+	    for (i = 0; i < size; ++i)
+		if (ml_append((linenr_T)(n + i), (char_u *)array[i],
+			    0, FALSE) == FAIL)
+		{
+		    curbuf = savebuf;
+		    free_array(array);
+		    raise_vim_exn(_("cannot insert line"));
+		}
 
+	    if (i > 0)
+		appended_lines_mark((linenr_T)n, (long)i);
+	}
+	free_array(array);
+	MZ_GC_UNREG();
+	curbuf = savebuf;
+	update_screen(VALID);
+    }
+
+    MZ_GC_UNREG();
     raise_if_error();
     return scheme_void;
 }
 
-/* (get-buff-namespace [buffer]) */
-    static Scheme_Object *
-get_buffer_namespace(void *data, int argc, Scheme_Object **argv)
-{
-    Vim_Prim	*prim = (Vim_Prim *)data;
-
-    return (Scheme_Object *)get_buffer_arg(prim->name, 0, argc, argv)->env;
-}
-
 /*
  * Predicates
  */
 /* (buff? obj) */
     static Scheme_Object *
@@ -2343,44 +2568,395 @@ vim_window_validp(void *data, int argc,
  */
 
 /*
  * Convert an MzScheme string into a Vim line.
  *
- * The result is in allocated memory. All internal nulls are replaced by
- * newline characters. It is an error for the string to contain newline
- * characters.
+ * All internal nulls are replaced by newline characters.
+ * It is an error for the string to contain newline characters.
  *
+ * Returns pointer to Vim allocated memory
  */
     static char *
 string_to_line(Scheme_Object *obj)
 {
-    char	*str;
+    char	*scheme_str = NULL;
+    char	*vim_str = NULL;
     long	len;
     int		i;
 
-    str = scheme_display_to_string(obj, &len);
+    scheme_str = scheme_display_to_string(obj, &len);
 
     /* Error checking: String must not contain newlines, as we
      * are replacing a single line, and we must replace it with
      * a single line.
      */
-    if (memchr(str, '\n', len))
+    if (memchr(scheme_str, '\n', len))
 	scheme_signal_error(_("string cannot contain newlines"));
 
+    vim_str = (char *)alloc(len + 1);
+
     /* Create a copy of the string, with internal nulls replaced by
      * newline characters, as is the vim convention.
      */
     for (i = 0; i < len; ++i)
     {
-	if (str[i] == '\0')
-	    str[i] = '\n';
+	if (scheme_str[i] == '\0')
+	    vim_str[i] = '\n';
+	else
+	    vim_str[i] = scheme_str[i];
+    }
+
+    vim_str[i] = '\0';
+
+    MZ_GC_CHECK();
+    return vim_str;
+}
+
+#ifdef FEAT_EVAL
+/*
+ * Convert Vim value into MzScheme, adopted from if_python.c
+ */
+    static Scheme_Object *
+vim_to_mzscheme(typval_T *vim_value, int depth, Scheme_Hash_Table *visited)
+{
+    Scheme_Object   *result = NULL;
+    int		    new_value = TRUE;
+
+    MZ_GC_DECL_REG(1);
+    MZ_GC_VAR_IN_REG(0, result);
+    MZ_GC_REG();
+
+    /* Avoid infinite recursion */
+    if (depth > 100)
+    {
+	MZ_GC_UNREG();
+	return scheme_void;
+    }
+
+    /* Check if we run into a recursive loop.  The item must be in visited
+     * then and we can use it again.
+     */
+    result = scheme_hash_get(visited, (Scheme_Object *)vim_value);
+    MZ_GC_CHECK();
+    if (result != NULL) /* found, do nothing */
+	new_value = FALSE;
+    else if (vim_value->v_type == VAR_STRING)
+    {
+	result = scheme_make_string((char *)vim_value->vval.v_string);
+	MZ_GC_CHECK();
+    }
+    else if (vim_value->v_type == VAR_NUMBER)
+    {
+	result = scheme_make_integer((long)vim_value->vval.v_number);
+	MZ_GC_CHECK();
+    }
+# ifdef FEAT_FLOAT
+    else if (vim_value->v_type == VAR_FLOAT)
+    {
+	result = scheme_make_double((double)vim_value->vval.v_float);
+	MZ_GC_CHECK();
+    }
+# endif
+    else if (vim_value->v_type == VAR_LIST)
+    {
+	list_T		*list = vim_value->vval.v_list;
+	listitem_T	*curr;
+
+	if (list == NULL || list->lv_first == NULL)
+	    result = scheme_null;
+	else
+	{
+	    Scheme_Object   *obj = NULL;
+
+	    MZ_GC_DECL_REG(1);
+	    MZ_GC_VAR_IN_REG(0, obj);
+	    MZ_GC_REG();
+
+	    curr = list->lv_last;
+	    obj = vim_to_mzscheme(&curr->li_tv, depth + 1, visited);
+	    result = scheme_make_pair(obj, scheme_null);
+	    MZ_GC_CHECK();
+
+	    while (curr != list->lv_first)
+	    {
+		curr = curr->li_prev;
+		obj = vim_to_mzscheme(&curr->li_tv, depth + 1, visited);
+		result = scheme_make_pair(obj, result);
+		MZ_GC_CHECK();
+	    }
+	}
+	MZ_GC_UNREG();
+    }
+    else if (vim_value->v_type == VAR_DICT)
+    {
+	Scheme_Object	  *key = NULL;
+	Scheme_Object	  *obj = NULL;
+
+	MZ_GC_DECL_REG(2);
+	MZ_GC_VAR_IN_REG(0, key);
+	MZ_GC_VAR_IN_REG(1, obj);
+	MZ_GC_REG();
+
+	result = (Scheme_Object *)scheme_make_hash_table(SCHEME_hash_ptr);
+	MZ_GC_CHECK();
+	if (vim_value->vval.v_dict != NULL)
+	{
+	    hashtab_T	*ht = &vim_value->vval.v_dict->dv_hashtab;
+	    long_u	todo = ht->ht_used;
+	    hashitem_T	*hi;
+	    dictitem_T	*di;
+
+	    for (hi = ht->ht_array; todo > 0; ++hi)
+	    {
+		if (!HASHITEM_EMPTY(hi))
+		{
+		    --todo;
+
+		    di = dict_lookup(hi);
+		    obj = vim_to_mzscheme(&di->di_tv, depth + 1, visited);
+		    key = scheme_make_string((char *)hi->hi_key);
+		    MZ_GC_CHECK();
+		    scheme_hash_set((Scheme_Hash_Table *)result, key, obj);
+		    MZ_GC_CHECK();
+		}
+	    }
+	}
+	MZ_GC_UNREG();
+    }
+    else
+    {
+	result = scheme_void;
+	new_value = FALSE;
+    }
+    if (new_value)
+    {
+	scheme_hash_set(visited, (Scheme_Object *)vim_value, result);
+	MZ_GC_CHECK();
+    }
+    MZ_GC_UNREG();
+    return result;
+}
+
+    static int
+mzscheme_to_vim(Scheme_Object *obj, typval_T *tv, int depth,
+	Scheme_Hash_Table *visited)
+{
+    int		status = OK;
+    typval_T	*found;
+    MZ_GC_CHECK();
+    if (depth > 100) /* limit the deepest recursion level */
+    {
+	tv->v_type = VAR_NUMBER;
+	tv->vval.v_number = 0;
+	return FAIL;
+    }
+
+    found = (typval_T *)scheme_hash_get(visited, obj);
+    if (found != NULL)
+	copy_tv(found, tv);
+    else if (SCHEME_VOIDP(obj))
+    {
+	tv->v_type = VAR_NUMBER;
+	tv->vval.v_number = 0;
+    }
+    else if (SCHEME_INTP(obj))
+    {
+	tv->v_type = VAR_NUMBER;
+	tv->vval.v_number = SCHEME_INT_VAL(obj);
+    }
+    else if (SCHEME_BOOLP(obj))
+    {
+	tv->v_type = VAR_NUMBER;
+	tv->vval.v_number = SCHEME_TRUEP(obj);
+    }
+# ifdef FEAT_FLOAT
+    else if (SCHEME_DBLP(obj))
+    {
+	tv->v_type = VAR_FLOAT;
+	tv->vval.v_float = SCHEME_DBL_VAL(obj);
+    }
+# endif
+    else if (SCHEME_STRINGP(obj))
+    {
+	tv->v_type = VAR_STRING;
+	tv->vval.v_string = vim_strsave((char_u *)SCHEME_STR_VAL(obj));
+    }
+    else if (SCHEME_VECTORP(obj) || SCHEME_NULLP(obj)
+	    || SCHEME_PAIRP(obj) || SCHEME_MUTABLE_PAIRP(obj))
+    {
+	list_T  *list = list_alloc();
+	if (list == NULL)
+	    status = FAIL;
+	else
+	{
+	    int		    i;
+	    Scheme_Object   *curr = NULL;
+	    Scheme_Object   *cval = NULL;
+	    /* temporary var to hold current element of vectors and pairs */
+	    typval_T	    *v;
+
+	    MZ_GC_DECL_REG(2);
+	    MZ_GC_VAR_IN_REG(0, curr);
+	    MZ_GC_VAR_IN_REG(1, cval);
+	    MZ_GC_REG();
+
+	    tv->v_type = VAR_LIST;
+	    tv->vval.v_list = list;
+	    ++list->lv_refcount;
+
+	    v = (typval_T *)alloc(sizeof(typval_T));
+	    if (v == NULL)
+		status = FAIL;
+	    else
+	    {
+		/* add the value in advance to allow handling of self-referencial
+		 * data structures */
+		typval_T    *visited_tv = (typval_T *)alloc(sizeof(typval_T));
+		copy_tv(tv, visited_tv);
+		scheme_hash_set(visited, obj, (Scheme_Object *)visited_tv);
+
+		if (SCHEME_VECTORP(obj))
+		{
+		    for (i = 0; i < SCHEME_VEC_SIZE(obj); ++i)
+		    {
+			cval = SCHEME_VEC_ELS(obj)[i];
+			status = mzscheme_to_vim(cval, v, depth + 1, visited);
+			if (status == FAIL)
+			    break;
+			status = list_append_tv(list, v);
+			clear_tv(v);
+			if (status == FAIL)
+			    break;
+		    }
+		}
+		else if (SCHEME_PAIRP(obj) || SCHEME_MUTABLE_PAIRP(obj))
+		{
+		    for (curr = obj;
+			    SCHEME_PAIRP(curr) || SCHEME_MUTABLE_PAIRP(curr);
+			    curr = SCHEME_CDR(curr))
+		    {
+			cval = SCHEME_CAR(curr);
+			status = mzscheme_to_vim(cval, v, depth + 1, visited);
+			if (status == FAIL)
+			    break;
+			status = list_append_tv(list, v);
+			clear_tv(v);
+			if (status == FAIL)
+			    break;
+		    }
+		    /* impoper list not terminated with null
+		     * need to handle the last element */
+		    if (status == OK && !SCHEME_NULLP(curr))
+		    {
+			status = mzscheme_to_vim(cval, v, depth + 1, visited);
+			if (status == OK)
+			{
+			    status = list_append_tv(list, v);
+			    clear_tv(v);
+			}
+		    }
+		}
+		/* nothing to do for scheme_null */
+		vim_free(v);
+	    }
+	    MZ_GC_UNREG();
+	}
+    }
+    else if (SCHEME_HASHTP(obj))
+    {
+	int		i;
+	dict_T		*dict;
+	Scheme_Object   *key = NULL;
+	Scheme_Object   *val = NULL;
+
+	MZ_GC_DECL_REG(2);
+	MZ_GC_VAR_IN_REG(0, key);
+	MZ_GC_VAR_IN_REG(1, val);
+	MZ_GC_REG();
+
+	dict = dict_alloc();
+	if (dict == NULL)
+	    status = FAIL;
+	else
+	{
+	    typval_T    *visited_tv = (typval_T *)alloc(sizeof(typval_T));
+
+	    tv->v_type = VAR_DICT;
+	    tv->vval.v_dict = dict;
+	    ++dict->dv_refcount;
+
+	    copy_tv(tv, visited_tv);
+	    scheme_hash_set(visited, obj, (Scheme_Object *)visited_tv);
+
+	    for (i = 0; i < ((Scheme_Hash_Table *)obj)->size; ++i)
+	    {
+		if (((Scheme_Hash_Table *) obj)->vals[i] != NULL)
+		{
+		    /* generate item for `diplay'ed Scheme key */
+		    dictitem_T  *item = dictitem_alloc((char_u *)string_to_line(
+				((Scheme_Hash_Table *) obj)->keys[i]));
+		    /* convert Scheme val to Vim and add it to the dict */
+		    if (mzscheme_to_vim(((Scheme_Hash_Table *) obj)->vals[i],
+				    &item->di_tv, depth + 1, visited) == FAIL
+			    || dict_add(dict, item) == FAIL)
+		    {
+			dictitem_free(item);
+			status = FAIL;
+			break;
+		    }
+		}
+
+	    }
+	}
+	MZ_GC_UNREG();
+    }
+    else
+    {
+	/* `display' any other value to string */
+	tv->v_type = VAR_STRING;
+	tv->vval.v_string = (char_u *)string_to_line(obj);
     }
+    return status;
+}
+
+    void
+do_mzeval(char_u *str, typval_T *rettv)
+{
+    int i;
+    Scheme_Object	*ret = NULL;
+    Scheme_Hash_Table	*visited = NULL;
 
-    str[i] = '\0';
+    MZ_GC_DECL_REG(2);
+    MZ_GC_VAR_IN_REG(0, ret);
+    MZ_GC_VAR_IN_REG(0, visited);
+    MZ_GC_REG();
+
+    if (mzscheme_init())
+    {
+	MZ_GC_UNREG();
+	return;
+    }
 
-    return str;
+    MZ_GC_CHECK();
+    visited = scheme_make_hash_table(SCHEME_hash_ptr);
+    MZ_GC_CHECK();
+
+    if (eval_with_exn_handling(str, do_eval, &ret) == OK)
+	mzscheme_to_vim(ret, rettv, 1, visited);
+
+    for (i = 0; i < visited->size; ++i)
+    {
+	/* free up remembered objects */
+	if (visited->vals[i] != NULL)
+	{
+	    free_tv((typval_T *)visited->vals[i]);
+	}
+    }
+
+    MZ_GC_UNREG();
 }
+#endif
 
 /*
  * Check to see whether a Vim error has been reported, or a keyboard
  * interrupt (from vim --> got_int) has been detected.
  */
@@ -2392,82 +2968,119 @@ vim_error_check(void)
 
 /*
  * register Scheme exn:vim
  */
     static void
-register_vim_exn(Scheme_Env *env)
+register_vim_exn(void)
 {
-    Scheme_Object   *exn_name = scheme_intern_symbol("exn:vim");
+    int	nc = 0;
+    int i;
+    Scheme_Object   *struct_exn = NULL;
+    Scheme_Object   *exn_name = NULL;
+
+    MZ_GC_DECL_REG(2);
+    MZ_GC_VAR_IN_REG(0, struct_exn);
+    MZ_GC_VAR_IN_REG(1, exn_name);
+    MZ_GC_REG();
+
+    exn_name = scheme_intern_symbol("exn:vim");
+    MZ_GC_CHECK();
+    struct_exn = scheme_builtin_value("struct:exn");
+    MZ_GC_CHECK();
 
     if (vim_exn == NULL)
 	vim_exn = scheme_make_struct_type(exn_name,
-		scheme_builtin_value("struct:exn"), NULL, 0, 0, NULL, NULL
+		struct_exn, NULL, 0, 0, NULL, NULL
 #if MZSCHEME_VERSION_MAJOR >= 299
 		, NULL
 #endif
 		);
 
-    if (vim_exn_values == NULL)
-    {
-	int	nc = 0;
 
-	Scheme_Object   **exn_names = scheme_make_struct_names(
-		exn_name, scheme_null, 0, &nc);
-	Scheme_Object   **exn_values = scheme_make_struct_values(
-		vim_exn, exn_names, nc, 0);
-
-	vim_exn_names = scheme_make_vector(nc, scheme_false);
-	vim_exn_values = scheme_make_vector(nc, scheme_false);
-	/* remember names and values */
-	mch_memmove(SCHEME_VEC_ELS(vim_exn_names), exn_names,
-		nc * sizeof(Scheme_Object *));
-	mch_memmove(SCHEME_VEC_ELS(vim_exn_values), exn_values,
-		nc * sizeof(Scheme_Object *));
+    {
+	Scheme_Object   **tmp = NULL;
+	Scheme_Object   *exn_names[5] = {NULL, NULL, NULL, NULL, NULL};
+	Scheme_Object   *exn_values[5] = {NULL, NULL, NULL, NULL, NULL};
+	MZ_GC_DECL_REG(6);
+	MZ_GC_ARRAY_VAR_IN_REG(0, exn_names, 5);
+	MZ_GC_ARRAY_VAR_IN_REG(3, exn_values, 5);
+	MZ_GC_REG();
+
+	tmp = scheme_make_struct_names(exn_name, scheme_null, 0, &nc);
+	assert(nc <= 5);
+	mch_memmove(exn_names, tmp, nc * sizeof(Scheme_Object *));
+	MZ_GC_CHECK();
+
+	tmp = scheme_make_struct_values(vim_exn, exn_names, nc, 0);
+	mch_memmove(exn_values, tmp, nc * sizeof(Scheme_Object *));
+	MZ_GC_CHECK();
+
+	for (i = 0; i < nc; i++)
+	{
+	    scheme_add_global_symbol(exn_names[i],
+		    exn_values[i], environment);
+	    MZ_GC_CHECK();
+	}
+	MZ_GC_UNREG();
     }
-
-    add_vim_exn(env);
-}
-
-/*
- * Add stuff of exn:vim to env
- */
-    static void
-add_vim_exn(Scheme_Env *env)
-{
-    int i;
-
-    for (i = 0; i < SCHEME_VEC_SIZE(vim_exn_values); i++)
-	scheme_add_global_symbol(SCHEME_VEC_ELS(vim_exn_names)[i],
-		SCHEME_VEC_ELS(vim_exn_values)[i], env);
+    MZ_GC_UNREG();
 }
 
 /*
  * raise exn:vim, may be with additional info string
  */
     void
 raise_vim_exn(const char *add_info)
 {
-    Scheme_Object   *argv[2];
-    char_u	    *fmt = _("Vim error: ~a");
+    char	    *fmt = _("Vim error: ~a");
+    Scheme_Object   *argv[2] = {NULL, NULL};
+    Scheme_Object   *exn = NULL;
+
+    MZ_GC_DECL_REG(4);
+    MZ_GC_ARRAY_VAR_IN_REG(0, argv, 2);
+    MZ_GC_VAR_IN_REG(3, exn);
+    MZ_GC_REG();
 
     if (add_info != NULL)
     {
-	Scheme_Object   *info = scheme_make_string(add_info);
-	argv[0] = scheme_byte_string_to_char_string(scheme_make_string(
-		scheme_format(fmt, strlen(fmt), 1, &info, NULL)));
+	char		*c_string = NULL;
+	Scheme_Object	*byte_string = NULL;
+	Scheme_Object   *info = NULL;
+
+	MZ_GC_DECL_REG(3);
+	MZ_GC_VAR_IN_REG(0, c_string);
+	MZ_GC_VAR_IN_REG(1, byte_string);
+	MZ_GC_VAR_IN_REG(2, info);
+	MZ_GC_REG();
+
+	info = scheme_make_string(add_info);
+	MZ_GC_CHECK();
+	c_string = scheme_format(fmt, STRLEN(fmt), 1, &info, NULL);
+	MZ_GC_CHECK();
+	byte_string = scheme_make_string(c_string);
+	MZ_GC_CHECK();
+	argv[0] = scheme_byte_string_to_char_string(byte_string);
+	MZ_GC_CHECK();
 	SCHEME_SET_IMMUTABLE(argv[0]);
+	MZ_GC_UNREG();
     }
     else
 	argv[0] = scheme_make_string(_("Vim error"));
+    MZ_GC_CHECK();
 
 #if MZSCHEME_VERSION_MAJOR < 360
     argv[1] = scheme_current_continuation_marks();
+    MZ_GC_CHECK();
 #else
     argv[1] = scheme_current_continuation_marks(NULL);
+    MZ_GC_CHECK();
 #endif
 
-    scheme_raise(scheme_make_struct_instance(vim_exn, 2, argv));
+    exn = scheme_make_struct_instance(vim_exn, 2, argv);
+    MZ_GC_CHECK();
+    scheme_raise(exn);
+    MZ_GC_UNREG();
 }
 
     void
 raise_if_error(void)
 {
@@ -2570,10 +3183,12 @@ mz_fix_cursor(int lo, int hi, int extra)
 	else if (extra < 0)
 	{
 	    curwin->w_cursor.lnum = lo;
 	    check_cursor();
 	}
+	else
+	    check_cursor_col();
 	changed_cline_bef_curs();
     }
     invalidate_botline();
 }
 
@@ -2595,11 +3210,10 @@ static Vim_Prim prims[]=
     {get_next_buffer, "get-next-buff", 0, 1},
     {get_prev_buffer, "get-prev-buff", 0, 1},
     {mzscheme_open_buffer, "open-buff", 1, 1},
     {get_buffer_by_name, "get-buff-by-name", 1, 1},
     {get_buffer_by_num, "get-buff-by-num", 1, 1},
-    {get_buffer_namespace, "get-buff-namespace", 0, 1},
     /*
      * Window-related commands
      */
     {get_curr_win, "curr-win", 0, 0},
     {get_window_count, "win-count", 0, 0},
@@ -2653,27 +3267,39 @@ get_vim_curr_window(void)
     else
 	return (vim_mz_window *)curwin->w_mzscheme_ref;
 }
 
     static void
-make_modules(Scheme_Env *env)
+make_modules()
 {
-    int		i;
-    Scheme_Env	*mod;
-
-    mod = scheme_primitive_module(scheme_intern_symbol("vimext"), env);
+    int		    i;
+    Scheme_Env	    *mod = NULL;
+    Scheme_Object   *vimext_symbol = NULL;
+    Scheme_Object   *closed_prim = NULL;
+
+    MZ_GC_DECL_REG(3);
+    MZ_GC_VAR_IN_REG(0, mod);
+    MZ_GC_VAR_IN_REG(1, vimext_symbol);
+    MZ_GC_VAR_IN_REG(2, closed_prim);
+    MZ_GC_REG();
+
+    vimext_symbol = scheme_intern_symbol("vimext");
+    MZ_GC_CHECK();
+    mod = scheme_primitive_module(vimext_symbol, environment);
+    MZ_GC_CHECK();
     /* all prims made closed so they can access their own names */
-    for (i = 0; i < sizeof(prims)/sizeof(prims[0]); i++)
+    for (i = 0; i < (int)(sizeof(prims)/sizeof(prims[0])); i++)
     {
 	Vim_Prim *prim = prims + i;
-	scheme_add_global(prim->name,
-		scheme_make_closed_prim_w_arity(prim->prim, prim, prim->name,
-		    prim->mina, prim->maxa),
-		mod);
+	closed_prim = scheme_make_closed_prim_w_arity(prim->prim, prim, prim->name,
+			    prim->mina, prim->maxa);
+	scheme_add_global(prim->name, closed_prim, mod);
+	MZ_GC_CHECK();
     }
-    scheme_add_global("global-namespace", (Scheme_Object *)environment, mod);
     scheme_finish_primitive_module(mod);
+    MZ_GC_CHECK();
+    MZ_GC_UNREG();
 }
 
 #ifdef HAVE_SANDBOX
 static Scheme_Object *M_write = NULL;
 static Scheme_Object *M_read = NULL;
@@ -2697,25 +3323,29 @@ sandbox_file_guard(int argc, Scheme_Obje
 
 	if (M_write == NULL)
 	{
 	    MZ_REGISTER_STATIC(M_write);
 	    M_write = scheme_intern_symbol("write");
+	    MZ_GC_CHECK();
 	}
 	if (M_read == NULL)
 	{
 	    MZ_REGISTER_STATIC(M_read);
 	    M_read = scheme_intern_symbol("read");
+	    MZ_GC_CHECK();
 	}
 	if (M_execute == NULL)
 	{
 	    MZ_REGISTER_STATIC(M_execute);
 	    M_execute = scheme_intern_symbol("execute");
+	    MZ_GC_CHECK();
 	}
 	if (M_delete == NULL)
 	{
 	    MZ_REGISTER_STATIC(M_delete);
 	    M_delete = scheme_intern_symbol("delete");
+	    MZ_GC_CHECK();
 	}
 
 	while (!SCHEME_NULLP(requested_access))
 	{
 	    Scheme_Object *item = SCHEME_CAR(requested_access);
--- vim72.orig/src/gui_at_fs.c
+++ vim72/src/gui_at_fs.c
@@ -827,11 +827,11 @@ SFsetText(path)
     text.length = strlen(path);
     text.ptr = path;
     text.format = FMT8BIT;
 
 #ifdef XtNinternational
-    if (_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
+    if ((unsigned long)_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
     {
 	XawTextReplace(selFileField, (XawTextPosition)0,
 				    (XawTextPosition)WcsLen((wchar_t *)&SFtextBuffer[0]), &text);
 	XawTextSetInsertionPoint(selFileField,
 					   (XawTextPosition)WcsLen((wchar_t *)&SFtextBuffer[0]));
@@ -849,21 +849,19 @@ SFsetText(path)
     XawTextSetInsertionPoint(selFileField,
 				       (XawTextPosition)strlen(SFtextBuffer));
 #endif
 }
 
-/* ARGSUSED */
     static void
 SFbuttonPressList(w, n, event)
-    Widget		w;
-    int			n;
-    XButtonPressedEvent	*event;
+    Widget		w UNUSED;
+    int			n UNUSED;
+    XButtonPressedEvent	*event UNUSED;
 {
     SFbuttonPressed = 1;
 }
 
-/* ARGSUSED */
     static void
 SFbuttonReleaseList(w, n, event)
     Widget		 w;
     int			 n;
     XButtonReleasedEvent *event;
@@ -987,15 +985,14 @@ SFcheckFiles(dir)
     }
 
     return result;
 }
 
-/* ARGSUSED */
     static void
 SFdirModTimer(cl, id)
-    XtPointer		cl;
-    XtIntervalId	*id;
+    XtPointer		cl UNUSED;
+    XtIntervalId	*id UNUSED;
 {
     static int		n = -1;
     static int		f = 0;
     char		save;
     SFDir		*dir;
@@ -1594,15 +1591,14 @@ SFscrollTimerInterval()
     return (unsigned long)t;
 }
 
 static void SFscrollTimer __ARGS((XtPointer p, XtIntervalId *id));
 
-/* ARGSUSED */
     static void
 SFscrollTimer(p, id)
     XtPointer		p;
-    XtIntervalId	*id;
+    XtIntervalId	*id UNUSED;
 {
     SFDir	*dir;
     int		save;
     int		n;
 
@@ -1693,14 +1689,13 @@ SFnewInvertEntry(n, event)
 	}
 	return -1;
     }
 }
 
-/* ARGSUSED */
     static void
 SFenterList(w, n, event)
-    Widget		w;
+    Widget		w UNUSED;
     int			n;
     XEnterWindowEvent	*event;
 {
     int			nw;
 
@@ -1717,28 +1712,26 @@ SFenterList(w, n, event)
 	SFcurrentInvert[n] = nw;
 	SFinvertEntry(n);
     }
 }
 
-/* ARGSUSED */
     static void
 SFleaveList(w, n, event)
-    Widget	w;
+    Widget	w UNUSED;
     int		n;
-    XEvent	*event;
+    XEvent	*event UNUSED;
 {
     if (SFcurrentInvert[n] != -1)
     {
 	SFinvertEntry(n);
 	SFcurrentInvert[n] = -1;
     }
 }
 
-/* ARGSUSED */
     static void
 SFmotionList(w, n, event)
-    Widget		w;
+    Widget		w UNUSED;
     int			n;
     XMotionEvent	*event;
 {
     int		nw;
 
@@ -1752,11 +1745,10 @@ SFmotionList(w, n, event)
 	if (nw != -1)
 	    SFinvertEntry(n);
     }
 }
 
-/* ARGSUSED */
     static void
 SFvFloatSliderMovedCallback(w, n, fnew)
     Widget	w;
     XtPointer	n;
     XtPointer	fnew;
@@ -1765,14 +1757,13 @@ SFvFloatSliderMovedCallback(w, n, fnew)
 
     nw = (*(float *)fnew) * SFdirs[SFdirPtr + (int)(long)n].nEntries;
     SFvSliderMovedCallback(w, (int)(long)n, nw);
 }
 
-/* ARGSUSED */
     static void
 SFvSliderMovedCallback(w, n, nw)
-    Widget	w;
+    Widget	w UNUSED;
     int		n;
     int		nw;
 {
     int		old;
     Window	win;
@@ -1851,14 +1842,13 @@ SFvSliderMovedCallback(w, n, nw)
 		False);
 	SFdrawStrings(win, dir, 0, SFlistSize - 1);
     }
 }
 
-/* ARGSUSED */
     static void
 SFvAreaSelectedCallback(w, n, pnew)
-    Widget		w;
+    Widget	w;
     XtPointer	n;
     XtPointer	pnew;
 {
     SFDir	*dir;
     int		nw = (int)(long)pnew;
@@ -1912,14 +1902,13 @@ SFvAreaSelectedCallback(w, n, pnew)
     }
 
     SFvSliderMovedCallback(w, (int)(long)n, nw);
 }
 
-/* ARGSUSED */
     static void
 SFhSliderMovedCallback(w, n, nw)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	n;
     XtPointer	nw;
 {
     SFDir	*dir;
     int	save;
@@ -1931,14 +1920,13 @@ SFhSliderMovedCallback(w, n, nw)
 	return;
 
     SFdrawList((int)(long)n, SF_DO_NOT_SCROLL);
 }
 
-/* ARGSUSED */
     static void
 SFhAreaSelectedCallback(w, n, pnew)
-    Widget		w;
+    Widget	w;
     XtPointer	n;
     XtPointer	pnew;
 {
     SFDir	*dir;
     int		nw = (int)(long)pnew;
@@ -1992,15 +1980,14 @@ SFhAreaSelectedCallback(w, n, pnew)
 
 	SFhSliderMovedCallback(w, n, (XtPointer)&f);
     }
 }
 
-/* ARGSUSED */
     static void
 SFpathSliderMovedCallback(w, client_data, nw)
-    Widget		w;
-    XtPointer	client_data;
+    Widget	w UNUSED;
+    XtPointer	client_data UNUSED;
     XtPointer	nw;
 {
     SFDir		*dir;
     int			n;
     XawTextPosition	pos;
@@ -2029,15 +2016,14 @@ SFpathSliderMovedCallback(w, client_data
     }
 
     XawTextSetInsertionPoint(selFileField, pos);
 }
 
-/* ARGSUSED */
     static void
 SFpathAreaSelectedCallback(w, client_data, pnew)
     Widget	w;
-    XtPointer	client_data;
+    XtPointer	client_data UNUSED;
     XtPointer	pnew;
 {
     int		nw = (int)(long)pnew;
     float	f;
 
@@ -2204,33 +2190,31 @@ static char *oneLineTextEditTranslations
 	Ctrl<Key>M:	redraw-display()\n\
 ";
 
 static void SFexposeList __ARGS((Widget w, XtPointer n, XEvent *event, Boolean *cont));
 
-/* ARGSUSED */
     static void
 SFexposeList(w, n, event, cont)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	n;
     XEvent	*event;
-    Boolean	*cont;
+    Boolean	*cont UNUSED;
 {
     if ((event->type == NoExpose) || event->xexpose.count)
 	return;
 
     SFdrawList((int)(long)n, SF_DO_NOT_SCROLL);
 }
 
 static void SFmodVerifyCallback __ARGS((Widget w, XtPointer client_data, XEvent *event, Boolean *cont));
 
-/* ARGSUSED */
     static void
 SFmodVerifyCallback(w, client_data, event, cont)
-    Widget		w;
-    XtPointer		client_data;
+    Widget		w UNUSED;
+    XtPointer		client_data UNUSED;
     XEvent		*event;
-    Boolean		*cont;
+    Boolean		*cont UNUSED;
 {
     char	buf[2];
 
     if ((XLookupString(&(event->xkey), buf, 2, NULL, NULL) == 1) &&
 	    ((*buf) == '\r'))
@@ -2239,15 +2223,15 @@ SFmodVerifyCallback(w, client_data, even
 	SFstatus = SEL_FILE_TEXT;
 }
 
 static void SFokCallback __ARGS((Widget w, XtPointer cl, XtPointer cd));
 
-/* ARGSUSED */
     static void
 SFokCallback(w, cl, cd)
-    Widget	w;
-    XtPointer	cl, cd;
+    Widget	w UNUSED;
+    XtPointer	cl UNUSED;
+    XtPointer	cd UNUSED;
 {
     SFstatus = SEL_FILE_OK;
 }
 
 static XtCallbackRec SFokSelect[] =
@@ -2256,15 +2240,15 @@ static XtCallbackRec SFokSelect[] =
     { NULL, (XtPointer) NULL },
 };
 
 static void SFcancelCallback __ARGS((Widget w, XtPointer cl, XtPointer cd));
 
-/* ARGSUSED */
     static void
 SFcancelCallback(w, cl, cd)
-    Widget	w;
-    XtPointer	cl, cd;
+    Widget	w UNUSED;
+    XtPointer	cl UNUSED;
+    XtPointer	cd UNUSED;
 {
     SFstatus = SEL_FILE_CANCEL;
 }
 
 static XtCallbackRec SFcancelSelect[] =
@@ -2273,20 +2257,19 @@ static XtCallbackRec SFcancelSelect[] =
     { NULL, (XtPointer) NULL },
 };
 
 static void SFdismissAction __ARGS((Widget w, XEvent *event, String *params, Cardinal *num_params));
 
-/* ARGSUSED */
     static void
 SFdismissAction(w, event, params, num_params)
-    Widget	w;
-    XEvent *event;
-    String *params;
-    Cardinal *num_params;
+    Widget	w UNUSED;
+    XEvent	*event;
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
-    if (event->type == ClientMessage &&
-	    event->xclient.data.l[0] != SFwmDeleteWindow)
+    if (event->type == ClientMessage
+	    && (Atom)event->xclient.data.l[0] != SFwmDeleteWindow)
 	return;
 
     SFstatus = SEL_FILE_CANCEL;
 }
 
@@ -2701,11 +2684,11 @@ SFcreateWidgets(toplevel, prompt, ok, ca
 
     static void
 SFtextChanged()
 {
 #if defined(FEAT_XFONTSET) && defined(XtNinternational)
-    if (_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
+    if ((unsigned long)_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
     {
 	wchar_t *wcbuf=(wchar_t *)SFtextBuffer;
 
 	if ((wcbuf[0] == L'/') || (wcbuf[0] == L'~'))
 	{
@@ -2747,11 +2730,11 @@ SFtextChanged()
 SFgetText()
 {
 #if defined(FEAT_XFONTSET) && defined(XtNinternational)
     char *buf;
 
-    if (_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
+    if ((unsigned long)_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
     {
 	wchar_t *wcbuf;
 	int mbslength;
 
 	XtVaGetValues(selFileField,
--- vim72.orig/src/gui_athena.c
+++ vim72/src/gui_athena.c
@@ -84,14 +84,13 @@ static int		puller_width = 0;
 
 /*
  * Scrollbar callback (XtNjumpProc) for when the scrollbar is dragged with the
  * left or middle mouse button.
  */
-/* ARGSUSED */
     static void
 gui_athena_scroll_cb_jump(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data, call_data;
 {
     scrollbar_T *sb, *sb_info;
     long	value;
 
@@ -120,14 +119,13 @@ gui_athena_scroll_cb_jump(w, client_data
 
 /*
  * Scrollbar callback (XtNscrollProc) for paging up or down with the left or
  * right mouse buttons.
  */
-/* ARGSUSED */
     static void
 gui_athena_scroll_cb_scroll(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data, call_data;
 {
     scrollbar_T *sb, *sb_info;
     long	value;
     int		data = (int)(long)call_data;
@@ -490,11 +488,11 @@ get_toolbar_pixmap(menu, sen)
     }
 
     if (menu->icon_builtin || gui_find_bitmap(menu->name, buf, "xpm") == FAIL)
     {
 	if (menu->iconidx >= 0 && menu->iconidx
-		   < (sizeof(built_in_pixmaps) / sizeof(built_in_pixmaps[0])))
+	      < (int)(sizeof(built_in_pixmaps) / sizeof(built_in_pixmaps[0])))
 	    xpm = built_in_pixmaps[menu->iconidx];
 	else
 	    xpm = tb_blank_xpm;
     }
 
@@ -761,11 +759,11 @@ athena_calculate_ins_pos(widget)
     XtSetArg(args[n], XtNchildren, &children); n++;
     XtSetArg(args[n], XtNnumChildren, &num_children); n++;
     XtGetValues(XtParent(widget), args, n);
 
     retval = num_children;
-    for (i = 0; i < num_children; ++i)
+    for (i = 0; i < (int)num_children; ++i)
     {
 	Widget	current = children[i];
 	vimmenu_T	*menu = NULL;
 
 	for (menu = (a_cur_menu->parent == NULL)
@@ -778,15 +776,14 @@ athena_calculate_ins_pos(widget)
 		retval = i;
     }
     return retval;
 }
 
-/* ARGSUSED */
     void
 gui_mch_add_menu(menu, idx)
     vimmenu_T	*menu;
-    int		idx;
+    int		idx UNUSED;
 {
     char_u	*pullright_name;
     Dimension	height, space, border;
     vimmenu_T	*parent = menu->parent;
 
@@ -867,11 +864,11 @@ gui_mch_add_menu(menu, idx)
 	    int		i;
 
 	    XtVaGetValues(parent->submenu_id, XtNchildren, &children,
 					      XtNnumChildren, &num_children,
 					      NULL);
-	    for (i = 0; i < num_children; ++i)
+	    for (i = 0; i < (int)num_children; ++i)
 	    {
 		XtVaSetValues(children[i],
 			      XtNrightMargin, puller_width,
 			      NULL);
 	    }
@@ -911,11 +908,11 @@ gui_athena_menu_has_submenus(id, ignore)
     int		i;
 
     XtVaGetValues(id, XtNchildren, &children,
 		      XtNnumChildren, &num_children,
 		      NULL);
-    for (i = 0; i < num_children; ++i)
+    for (i = 0; i < (int)num_children; ++i)
     {
 	if (children[i] == ignore)
 	    continue;
 	if (has_submenu(children[i]))
 	    return True;
@@ -1173,15 +1170,14 @@ make_pull_name(name)
 	    *p = '_';
     }
     return pname;
 }
 
-/* ARGSUSED */
     void
 gui_mch_add_menu_item(menu, idx)
     vimmenu_T	*menu;
-    int		idx;
+    int		idx UNUSED;
 {
     vimmenu_T	*parent = menu->parent;
 
     a_cur_menu = menu;
 # ifdef FEAT_TOOLBAR
@@ -1442,11 +1438,11 @@ gui_mch_compute_toolbar_height()
 		XtNborderWidth,	    &shadowThickness,
 		XtNvSpace,	    &marginHeight,
 		XtNchildren,	    &children,
 		XtNnumChildren,	    &numChildren,
 		NULL);
-	for (i = 0; i < numChildren; i++)
+	for (i = 0; i < (int)numChildren; i++)
 	{
 	    whgt = 0;
 
 	    XtVaGetValues(children[i], XtNheight, &whgt, NULL);
 	    if (height < whgt)
@@ -1471,14 +1467,13 @@ gui_mch_get_toolbar_colors(bgp, fgp, bsp
     *hsp = *tsp;
 }
 #endif
 
 
-/* ARGSUSED */
     void
 gui_mch_toggle_tearoffs(enable)
-    int		enable;
+    int		enable UNUSED;
 {
     /* no tearoff menus */
 }
 
     void
@@ -1535,11 +1530,11 @@ gui_mch_destroy_menu(menu)
 	    if (gui_athena_menu_has_submenus(parent, menu->id))
 		right_margin = puller_width;
 	    else
 		get_left_margin = True;
 
-	    for (i = 0; i < num_children; ++i)
+	    for (i = 0; i < (int)num_children; ++i)
 	    {
 		if (children[i] == menu->id)
 		    continue;
 		if (get_left_margin == True)
 		{
@@ -1643,15 +1638,14 @@ gui_mch_destroy_menu(menu)
 	XtDestroyWidget(menu->submenu_id);
 	menu->submenu_id = (Widget)0;
     }
 }
 
-/*ARGSUSED*/
     static void
 gui_athena_menu_timeout(client_data, id)
     XtPointer	    client_data;
-    XtIntervalId    *id;
+    XtIntervalId    *id UNUSED;
 {
     Widget  w = (Widget)client_data;
     Widget  popup;
 
     timer = 0;
@@ -1676,16 +1670,15 @@ gui_athena_menu_timeout(client_data, id)
  * up.  It should appear even with and just slightly to the left of the
  * rightmost end of the menu entry that caused the popup.
  *
  * This is called when XtPopup() is called.
  */
-/*ARGSUSED*/
     static void
 gui_athena_popup_callback(w, client_data, call_data)
     Widget	w;
     XtPointer	client_data;
-    XtPointer	call_data;
+    XtPointer	call_data UNUSED;
 {
     /* Assumption: XtIsSubclass(XtParent(w),simpleMenuWidgetClass) */
     vimmenu_T	*menu = (vimmenu_T *)client_data;
     Dimension	width;
     Position	root_x, root_y;
@@ -1709,11 +1702,10 @@ gui_athena_popup_callback(w, client_data
     XtVaSetValues(w, XtNx, root_x,
 		     XtNy, root_y,
 		     NULL);
 }
 
-/* ARGSUSED */
     static void
 gui_athena_popdown_submenus_action(w, event, args, nargs)
     Widget	w;
     XEvent	*event;
     String	*args;
@@ -1754,11 +1746,10 @@ has_submenu(widget)
 	    return True;
     }
     return False;
 }
 
-/* ARGSUSED */
     static void
 gui_athena_delayed_arm_action(w, event, args, nargs)
     Widget	w;
     XEvent	*event;
     String	*args;
@@ -1835,11 +1826,10 @@ submenu_widget(widget)
     return popup;
     /* Postcondition: (popup != NULL) implies
      * (XtIsSubclass(popup,simpleMenuWidgetClass) == True) */
 }
 
-/* ARGSUSED */
     void
 gui_mch_show_popupmenu(menu)
     vimmenu_T *menu;
 {
     int		rootx, rooty, winx, winy;
@@ -2044,19 +2034,18 @@ gui_x11_get_wid()
 #if defined(FEAT_BROWSE) || defined(PROTO)
 /*
  * Put up a file requester.
  * Returns the selected name in allocated memory, or NULL for Cancel.
  */
-/* ARGSUSED */
     char_u *
 gui_mch_browse(saving, title, dflt, ext, initdir, filter)
-    int		saving;		/* select file to write */
-    char_u	*title;		/* not used (title for the window) */
-    char_u	*dflt;		/* not used (default name) */
-    char_u	*ext;		/* not used (extension added) */
+    int		saving UNUSED;	/* select file to write */
+    char_u	*title;		/* title for the window */
+    char_u	*dflt;		/* default name */
+    char_u	*ext UNUSED;	/* extension added */
     char_u	*initdir;	/* initial directory, NULL for current dir */
-    char_u	*filter;	/* not used (file name filter) */
+    char_u	*filter UNUSED;	/* file name filter */
 {
     Position x, y;
     char_u	dirbuf[MAXPATHL];
 
     /* Concatenate "initdir" and "dflt". */
@@ -2098,17 +2087,16 @@ static void dialog_wm_handler __ARGS((Wi
 
 /*
  * Callback function for the textfield.  When CR is hit this works like
  * hitting the "OK" button, ESC like "Cancel".
  */
-/* ARGSUSED */
     static void
 keyhit_callback(w, client_data, event, cont)
-    Widget		w;
-    XtPointer		client_data;
+    Widget		w UNUSED;
+    XtPointer		client_data UNUSED;
     XEvent		*event;
-    Boolean		*cont;
+    Boolean		*cont UNUSED;
 {
     char	buf[2];
 
     if (XLookupString(&(event->xkey), buf, 2, NULL, NULL) == 1)
     {
@@ -2117,44 +2105,41 @@ keyhit_callback(w, client_data, event, c
 	else if (*buf == ESC)
 	    dialogStatus = 0;
     }
 }
 
-/* ARGSUSED */
     static void
 butproc(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
-    XtPointer	call_data;
+    XtPointer	call_data UNUSED;
 {
     dialogStatus = (int)(long)client_data + 1;
 }
 
 /*
  * Function called when dialog window closed.
  */
-/*ARGSUSED*/
     static void
 dialog_wm_handler(w, client_data, event, dum)
-    Widget	w;
-    XtPointer	client_data;
+    Widget	w UNUSED;
+    XtPointer	client_data UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     if (event->type == ClientMessage
-	    && ((XClientMessageEvent *)event)->data.l[0] == dialogatom)
+	    && (Atom)((XClientMessageEvent *)event)->data.l[0] == dialogatom)
 	dialogStatus = 0;
 }
 
-/* ARGSUSED */
     int
 gui_mch_dialog(type, title, message, buttons, dfltbutton, textfield)
-    int		type;
+    int		type UNUSED;
     char_u	*title;
     char_u	*message;
     char_u	*buttons;
-    int		dfltbutton;
+    int		dfltbutton UNUSED;
     char_u	*textfield;
 {
     char_u		*buts;
     char_u		*p, *next;
     XtAppContext	app;
--- vim72.orig/src/gui_motif.c
+++ vim72/src/gui_motif.c
@@ -115,14 +115,13 @@ static void gui_motif_scroll_colors __AR
 
 /*
  * Call-back routines.
  */
 
-/* ARGSUSED */
     static void
 scroll_cb(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data, call_data;
 {
     scrollbar_T *sb;
     long	value;
     int		dragging;
@@ -134,28 +133,28 @@ scroll_cb(w, client_data, call_data)
 							      (int)XmCR_DRAG);
     gui_drag_scrollbar(sb, value, dragging);
 }
 
 #ifdef FEAT_GUI_TABLINE
-/*ARGSUSED*/
     static void
 tabline_cb(w, client_data, call_data)
-    Widget	w;
-    XtPointer	client_data, call_data;
+    Widget	w UNUSED;
+    XtPointer	client_data UNUSED;
+    XtPointer	call_data;
 {
     XmNotebookCallbackStruct *nptr;
 
     nptr = (XmNotebookCallbackStruct *)call_data;
     if (nptr->reason != (int)XmCR_NONE)
 	send_tabline_event(nptr->page_number);
 }
 
-/*ARGSUSED*/
     static void
 tabline_button_cb(w, client_data, call_data)
     Widget	w;
-    XtPointer	client_data, call_data;
+    XtPointer	client_data UNUSED;
+    XtPointer	call_data UNUSED;
 {
     int		cmd, tab_idx;
 
     XtVaGetValues(w, XmNuserData, &cmd, NULL);
     XtVaGetValues(tabLine_menu, XmNuserData, &tab_idx, NULL);
@@ -164,15 +163,14 @@ tabline_button_cb(w, client_data, call_d
 }
 
 /*
  * Tabline single mouse click timeout handler
  */
-/*ARGSUSED*/
     static void
 motif_tabline_timer_cb (timed_out, interval_id)
     XtPointer		timed_out;
-    XtIntervalId	*interval_id;
+    XtIntervalId	*interval_id UNUSED;
 {
     *((int *)timed_out) = TRUE;
 }
 
 /*
@@ -201,17 +199,16 @@ tabline_scroller_clicked(scroller_name,
 	}
     }
     return FALSE;
 }
 
-/*ARGSUSED*/
     static void
 tabline_menu_cb(w, closure, e, continue_dispatch)
     Widget	w;
-    XtPointer	closure;
+    XtPointer	closure UNUSED;
     XEvent	*e;
-    Boolean	*continue_dispatch;
+    Boolean	*continue_dispatch UNUSED;
 {
     Widget			tab_w;
     XButtonPressedEvent		*event;
     int				tab_idx = 0;
     WidgetList			children;
@@ -275,15 +272,14 @@ tabline_menu_cb(w, closure, e, continue_
     XtManageChildren(children, numChildren);
     XmMenuPosition(tabLine_menu, (XButtonPressedEvent *)e) ;
     XtManageChild(tabLine_menu);
 }
 
-/*ARGSUSED*/
     static void
 tabline_balloon_cb(beval, state)
     BalloonEval	*beval;
-    int		state;
+    int		state UNUSED;
 {
     int		nr;
     tabpage_T	*tp;
 
     if (beval->target == (Widget)0)
@@ -640,17 +636,16 @@ gui_x11_destroy_widgets()
 #ifdef FEAT_MENU
     menuBar = NULL;
 #endif
 }
 
-/*ARGSUSED*/
     void
 gui_mch_set_text_area_pos(x, y, w, h)
-    int	    x;
-    int	    y;
-    int	    w;
-    int	    h;
+    int	    x UNUSED;
+    int	    y UNUSED;
+    int	    w UNUSED;
+    int	    h UNUSED;
 {
 #ifdef FEAT_TOOLBAR
     /* Give keyboard focus to the textArea instead of the toolbar. */
     reset_focus();
 #endif
@@ -1259,11 +1254,11 @@ get_toolbar_pixmap(menu, fname)
     }
 
     if (menu->icon_builtin || gui_find_bitmap(menu->name, buf, "xpm") == FAIL)
     {
 	if (menu->iconidx >= 0 && menu->iconidx
-		   < (sizeof(built_in_pixmaps) / sizeof(built_in_pixmaps[0])))
+	       < (int)(sizeof(built_in_pixmaps) / sizeof(built_in_pixmaps[0])))
 	    xpm = built_in_pixmaps[menu->iconidx];
 	else
 	    xpm = tb_blank_xpm;
     }
 
@@ -1714,14 +1709,13 @@ gui_mch_destroy_menu(menu)
 	}
 #endif
     }
 }
 
-/* ARGSUSED */
     void
 gui_mch_show_popupmenu(menu)
-    vimmenu_T *menu;
+    vimmenu_T *menu UNUSED;
 {
 #ifdef MOTIF_POPUP
     XmMenuPosition(menu->submenu_id, gui_x11_get_last_mouse_event());
     XtManageChild(menu->submenu_id);
 #endif
@@ -2044,13 +2038,12 @@ do_mnemonic(Widget w, unsigned int keyco
 }
 
 /*
  * Callback routine for dialog mnemonic processing.
  */
-/*ARGSUSED*/
     static void
-mnemonic_event(Widget w, XtPointer call_data, XKeyEvent *event)
+mnemonic_event(Widget w, XtPointer call_data UNUSED, XKeyEvent *event)
 {
     do_mnemonic(w, event->keycode);
 }
 
 
@@ -2285,17 +2278,16 @@ set_predefined_fontlist(parent, name)
 
 /*
  * Put up a file requester.
  * Returns the selected name in allocated memory, or NULL for Cancel.
  */
-/* ARGSUSED */
     char_u *
 gui_mch_browse(saving, title, dflt, ext, initdir, filter)
-    int		saving;		/* select file to write */
+    int		saving UNUSED;	/* select file to write */
     char_u	*title;		/* title for the window */
     char_u	*dflt;		/* default name */
-    char_u	*ext;		/* not used (extension added) */
+    char_u	*ext UNUSED;	/* not used (extension added) */
     char_u	*initdir;	/* initial directory, NULL for current dir */
     char_u	*filter;	/* file name filter */
 {
     char_u	dirbuf[MAXPATHL];
     char_u	dfltbuf[MAXPATHL];
@@ -2411,16 +2403,15 @@ gui_mch_browse(saving, title, dflt, ext,
  */
 
 /*
  * Process callback from Dialog cancel actions.
  */
-/* ARGSUSED */
     static void
 DialogCancelCB(w, client_data, call_data)
-    Widget	w;		/*  widget id		*/
-    XtPointer	client_data;	/*  data from application   */
-    XtPointer	call_data;	/*  data from widget class  */
+    Widget	w UNUSED;		/*  widget id		*/
+    XtPointer	client_data UNUSED;	/*  data from application   */
+    XtPointer	call_data UNUSED;	/*  data from widget class  */
 {
     if (browse_fname != NULL)
     {
 	XtFree(browse_fname);
 	browse_fname = NULL;
@@ -2429,16 +2420,15 @@ DialogCancelCB(w, client_data, call_data
 }
 
 /*
  * Process callback from Dialog actions.
  */
-/* ARGSUSED */
     static void
 DialogAcceptCB(w, client_data, call_data)
-    Widget	w;		/*  widget id		*/
-    XtPointer	client_data;	/*  data from application   */
-    XtPointer	call_data;	/*  data from widget class  */
+    Widget	w UNUSED;		/*  widget id		*/
+    XtPointer	client_data UNUSED;	/*  data from application   */
+    XtPointer	call_data;		/*  data from widget class  */
 {
     XmFileSelectionBoxCallbackStruct *fcb;
 
     if (browse_fname != NULL)
     {
@@ -2465,17 +2455,16 @@ static void butproc __ARGS((Widget w, Xt
 
 /*
  * Callback function for the textfield.  When CR is hit this works like
  * hitting the "OK" button, ESC like "Cancel".
  */
-/* ARGSUSED */
     static void
 keyhit_callback(w, client_data, event, cont)
     Widget		w;
-    XtPointer		client_data;
+    XtPointer		client_data UNUSED;
     XEvent		*event;
-    Boolean		*cont;
+    Boolean		*cont UNUSED;
 {
     char	buf[2];
     KeySym	key_sym;
 
     if (XLookupString(&(event->xkey), buf, 2, &key_sym, NULL) == 1)
@@ -2488,16 +2477,15 @@ keyhit_callback(w, client_data, event, c
     if ((key_sym == XK_Left || key_sym == XK_Right)
 	    && !(event->xkey.state & ShiftMask))
 	XmTextFieldClearSelection(w, XtLastTimestampProcessed(gui.dpy));
 }
 
-/* ARGSUSED */
     static void
 butproc(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
-    XtPointer	call_data;
+    XtPointer	call_data UNUSED;
 {
     dialogStatus = (int)(long)client_data + 1;
 }
 
 #ifdef HAVE_XPM
@@ -2565,14 +2553,13 @@ create_pixmap_label(parent, name, data,
 
     return label;
 }
 #endif
 
-/* ARGSUSED */
     int
 gui_mch_dialog(type, title, message, button_names, dfltbutton, textfield)
-    int		type;
+    int		type UNUSED;
     char_u	*title;
     char_u	*message;
     char_u	*button_names;
     int		dfltbutton;
     char_u	*textfield;		/* buffer of size IOSIZE */
@@ -3195,11 +3182,11 @@ gui_mch_compute_toolbar_height()
 		XmNshadowThickness, &tst,
 		XmNmarginHeight, &tmh,
 		XmNchildren, &children,
 		XmNnumChildren, &numChildren, NULL);
 	borders += tst + tmh;
-	for (i = 0; i < numChildren; i++)
+	for (i = 0; i < (int)numChildren; i++)
 	{
 	    whgt = 0;
 	    XtVaGetValues(children[i], XmNheight, &whgt, NULL);
 	    if (height < whgt)
 		height = whgt;
@@ -3235,34 +3222,32 @@ motif_get_toolbar_colors(bgp, fgp, bsp,
 /*
  * The next toolbar enter/leave callbacks should really do balloon help.  But
  * I have to use footer help for backwards compatability.  Hopefully both will
  * get implemented and the user will have a choice.
  */
-/*ARGSUSED*/
     static void
 toolbarbutton_enter_cb(w, client_data, event, cont)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
-    XEvent	*event;
-    Boolean	*cont;
+    XEvent	*event UNUSED;
+    Boolean	*cont UNUSED;
 {
     vimmenu_T	*menu = (vimmenu_T *) client_data;
 
     if (menu->strings[MENU_INDEX_TIP] != NULL)
     {
 	if (vim_strchr(p_go, GO_FOOTER) != NULL)
 	    gui_mch_set_footer(menu->strings[MENU_INDEX_TIP]);
     }
 }
 
-/*ARGSUSED*/
     static void
 toolbarbutton_leave_cb(w, client_data, event, cont)
-    Widget	w;
-    XtPointer	client_data;
-    XEvent	*event;
-    Boolean	*cont;
+    Widget	w UNUSED;
+    XtPointer	client_data UNUSED;
+    XEvent	*event UNUSED;
+    Boolean	*cont UNUSED;
 {
     gui_mch_set_footer((char_u *) "");
 }
 # endif
 #endif
@@ -3490,14 +3475,13 @@ gui_motif_scroll_colors(id)
 }
 
 /*
  * Set the fontlist for Widget "id" to use gui.menu_fontset or gui.menu_font.
  */
-/*ARGSUSED*/
     void
 gui_motif_menu_fontlist(id)
-    Widget  id;
+    Widget  id UNUSED;
 {
 #ifdef FEAT_MENU
 #ifdef FONTSET_ALWAYS
     if (gui.menu_fontset != NOFONTSET)
     {
@@ -3564,63 +3548,59 @@ typedef struct _SharedFindReplace
     Widget undo;	/* 'Undo' action button */
 
     Widget cancel;
 } SharedFindReplace;
 
-static SharedFindReplace find_widgets = { NULL };
-static SharedFindReplace repl_widgets = { NULL };
+static SharedFindReplace find_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
+static SharedFindReplace repl_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
 
 static void find_replace_destroy_callback __ARGS((Widget w, XtPointer client_data, XtPointer call_data));
 static void find_replace_dismiss_callback __ARGS((Widget w, XtPointer client_data, XtPointer call_data));
 static void entry_activate_callback __ARGS((Widget w, XtPointer client_data, XtPointer call_data));
 static void find_replace_callback __ARGS((Widget w, XtPointer client_data, XtPointer call_data));
 static void find_replace_keypress __ARGS((Widget w, SharedFindReplace * frdp, XKeyEvent * event));
 static void find_replace_dialog_create __ARGS((char_u *entry_text, int do_replace));
 
-/*ARGSUSED*/
     static void
 find_replace_destroy_callback(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
-    XtPointer	call_data;
+    XtPointer	call_data UNUSED;
 {
     SharedFindReplace *cd = (SharedFindReplace *)client_data;
 
     if (cd != NULL)
        /* suppress_dialog_mnemonics(cd->dialog); */
 	cd->dialog = (Widget)0;
 }
 
-/*ARGSUSED*/
     static void
 find_replace_dismiss_callback(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
-    XtPointer	call_data;
+    XtPointer	call_data UNUSED;
 {
     SharedFindReplace *cd = (SharedFindReplace *)client_data;
 
     if (cd != NULL)
 	XtUnmanageChild(cd->dialog);
 }
 
-/*ARGSUSED*/
     static void
 entry_activate_callback(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
-    XtPointer	call_data;
+    XtPointer	call_data UNUSED;
 {
     XmProcessTraversal((Widget)client_data, XmTRAVERSE_CURRENT);
 }
 
-/*ARGSUSED*/
     static void
 find_replace_callback(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
-    XtPointer	call_data;
+    XtPointer	call_data UNUSED;
 {
     long_u	flags = (long_u)client_data;
     char	*find_text, *repl_text;
     Boolean	direction_down = TRUE;
     Boolean	wword;
@@ -3666,14 +3646,13 @@ find_replace_callback(w, client_data, ca
 	XtFree(find_text);
     if (repl_text != NULL)
 	XtFree(repl_text);
 }
 
-/*ARGSUSED*/
     static void
 find_replace_keypress(w, frdp, event)
-    Widget		w;
+    Widget		w UNUSED;
     SharedFindReplace	*frdp;
     XKeyEvent		*event;
 {
     KeySym keysym;
 
--- vim72.orig/src/if_ruby.c
+++ vim72/src/if_ruby.c
@@ -37,20 +37,35 @@
 # define rb_cNilClass		(*dll_rb_cNilClass)
 # define rb_cSymbol		(*dll_rb_cSymbol)
 # define rb_cTrueClass		(*dll_rb_cTrueClass)
 # if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
 /*
- * On ver 1.8, all Ruby functions are exported with "__declspce(dllimport)"
- * in ruby.h.  But it cause trouble for these variables, because it is
+ * On ver 1.8, all Ruby functions are exported with "__declspec(dllimport)"
+ * in ruby.h.  But it causes trouble for these variables, because it is
  * defined in this file.  When defined this RUBY_EXPORT it modified to
  * "extern" and be able to avoid this problem.
  */
 #  define RUBY_EXPORT
 # endif
 #endif
 
+/* suggested by Ariya Mizutani */
+#if (_MSC_VER == 1200)
+# undef _WIN32_WINNT
+#endif
+
+#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 19
+/* Ruby 1.9 defines a number of static functions which use rb_num2long and
+ * rb_int2big */
+# define rb_num2long rb_num2long_stub
+# define rb_int2big rb_int2big_stub
+#endif
+
 #include <ruby.h>
+#if defined(RUBY_VERSION) && RUBY_VERSION >= 19
+# include <ruby/encoding.h>
+#endif
 
 #undef EXTERN
 #undef _
 
 /* T_DATA defined both by Ruby and Mac header files, hack around it... */
@@ -58,10 +73,32 @@
 # define __OPENTRANSPORT__
 # define __OPENTRANSPORTPROTOCOL__
 # define __OPENTRANSPORTPROVIDERS__
 #endif
 
+/*
+ * Backward compatiblity for Ruby 1.8 and earlier.
+ * Ruby 1.9 does not provide STR2CSTR, instead StringValuePtr is provided.
+ * Ruby 1.9 does not provide RXXX(s)->len and RXXX(s)->ptr, instead
+ * RXXX_LEN(s) and RXXX_PTR(s) are provided.
+ */
+#ifndef StringValuePtr
+# define StringValuePtr(s) STR2CSTR(s)
+#endif
+#ifndef RARRAY_LEN
+# define RARRAY_LEN(s) RARRAY(s)->len
+#endif
+#ifndef RARRAY_PTR
+# define RARRAY_PTR(s) RARRAY(s)->ptr
+#endif
+#ifndef RSTRING_LEN
+# define RSTRING_LEN(s) RSTRING(s)->len
+#endif
+#ifndef RSTRING_PTR
+# define RSTRING_PTR(s) RSTRING(s)->ptr
+#endif
+
 #include "vim.h"
 #include "version.h"
 
 #if defined(PROTO) && !defined(FEAT_RUBY)
 /* Define these to be able to generate the function prototypes. */
@@ -127,17 +164,37 @@ static void ruby_vim_init(void);
 #define rb_str2cstr			dll_rb_str2cstr
 #define rb_str_cat			dll_rb_str_cat
 #define rb_str_concat			dll_rb_str_concat
 #define rb_str_new			dll_rb_str_new
 #define rb_str_new2			dll_rb_str_new2
-#define ruby_errinfo			(*dll_ruby_errinfo)
+#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
+# define rb_string_value_ptr		dll_rb_string_value_ptr
+# define rb_float_new			dll_rb_float_new
+# define rb_ary_new			dll_rb_ary_new
+# define rb_ary_push			dll_rb_ary_push
+#endif
+#if defined(RUBY_VERSION) && RUBY_VERSION >= 19 \
+    || defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 19
+# define rb_errinfo			dll_rb_errinfo
+#else
+# define ruby_errinfo			(*dll_ruby_errinfo)
+#endif
 #define ruby_init			dll_ruby_init
 #define ruby_init_loadpath		dll_ruby_init_loadpath
+#define NtInitialize			dll_NtInitialize
 #if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
 # define rb_w32_snprintf		dll_rb_w32_snprintf
 #endif
 
+#if defined(RUBY_VERSION) && RUBY_VERSION >= 19
+# define ruby_script			dll_ruby_script
+# define rb_enc_find_index		dll_rb_enc_find_index
+# define rb_enc_find			dll_rb_enc_find
+# define rb_enc_str_new			dll_rb_enc_str_new
+# define rb_sprintf			dll_rb_sprintf
+#endif
+
 /*
  * Pointers for dynamic link
  */
 static VALUE (*dll_rb_assoc_new) (VALUE, VALUE);
 static VALUE *dll_rb_cFalseClass;
@@ -181,17 +238,51 @@ static void (*dll_rb_raise) (VALUE, cons
 static char *(*dll_rb_str2cstr) (VALUE,int*);
 static VALUE (*dll_rb_str_cat) (VALUE, const char*, long);
 static VALUE (*dll_rb_str_concat) (VALUE, VALUE);
 static VALUE (*dll_rb_str_new) (const char*, long);
 static VALUE (*dll_rb_str_new2) (const char*);
+#if defined(RUBY_VERSION) && RUBY_VERSION >= 19 \
+    || defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 19
+static VALUE (*dll_rb_errinfo) (void);
+#else
 static VALUE *dll_ruby_errinfo;
+#endif
 static void (*dll_ruby_init) (void);
 static void (*dll_ruby_init_loadpath) (void);
+static void (*dll_NtInitialize) (int*, char***);
+#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
+static char * (*dll_rb_string_value_ptr) (volatile VALUE*);
+static VALUE (*dll_rb_float_new) (double);
+static VALUE (*dll_rb_ary_new) (void);
+static VALUE (*dll_rb_ary_push) (VALUE, VALUE);
+#endif
+#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 19
+static VALUE (*dll_rb_int2big)(SIGNED_VALUE);
+#endif
 #if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
 static int (*dll_rb_w32_snprintf)(char*, size_t, const char*, ...);
 #endif
 
+#if defined(RUBY_VERSION) && RUBY_VERSION >= 19
+static void (*dll_ruby_script) (const char*);
+static int (*dll_rb_enc_find_index) (const char*);
+static rb_encoding* (*dll_rb_enc_find) (const char*);
+static VALUE (*dll_rb_enc_str_new) (const char*, long, rb_encoding*);
+static VALUE (*dll_rb_sprintf) (const char*, ...);
+#endif
+
+#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 19
+static SIGNED_VALUE rb_num2long_stub(VALUE x)
+{
+    return dll_rb_num2long(x);
+}
+static VALUE rb_int2big_stub(SIGNED_VALUE x)
+{
+    return dll_rb_int2big(x);
+}
+#endif
+
 static HINSTANCE hinstRuby = 0; /* Instance of ruby.dll */
 
 /*
  * Table of name to function pointer of ruby.
  */
@@ -243,16 +334,44 @@ static struct
     {"rb_str2cstr", (RUBY_PROC*)&dll_rb_str2cstr},
     {"rb_str_cat", (RUBY_PROC*)&dll_rb_str_cat},
     {"rb_str_concat", (RUBY_PROC*)&dll_rb_str_concat},
     {"rb_str_new", (RUBY_PROC*)&dll_rb_str_new},
     {"rb_str_new2", (RUBY_PROC*)&dll_rb_str_new2},
+#if defined(RUBY_VERSION) && RUBY_VERSION >= 19 \
+    || defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 19
+    {"rb_errinfo", (RUBY_PROC*)&dll_rb_errinfo},
+#else
     {"ruby_errinfo", (RUBY_PROC*)&dll_ruby_errinfo},
+#endif
     {"ruby_init", (RUBY_PROC*)&dll_ruby_init},
     {"ruby_init_loadpath", (RUBY_PROC*)&dll_ruby_init_loadpath},
+    {
+#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER < 19
+    "NtInitialize",
+#else
+    "ruby_sysinit",
+#endif
+			(RUBY_PROC*)&dll_NtInitialize},
 #if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
     {"rb_w32_snprintf", (RUBY_PROC*)&dll_rb_w32_snprintf},
 #endif
+#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
+    {"rb_string_value_ptr", (RUBY_PROC*)&dll_rb_string_value_ptr},
+    {"rb_float_new", (RUBY_PROC*)&dll_rb_float_new},
+    {"rb_ary_new", (RUBY_PROC*)&dll_rb_ary_new},
+    {"rb_ary_push", (RUBY_PROC*)&dll_rb_ary_push},
+#endif
+#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 19
+    {"rb_int2big", (RUBY_PROC*)&dll_rb_int2big},
+#endif
+#if defined(RUBY_VERSION) && RUBY_VERSION >= 19
+    {"ruby_script", (RUBY_PROC*)&dll_ruby_script},
+    {"rb_enc_find_index", (RUBY_PROC*)&dll_rb_enc_find_index},
+    {"rb_enc_find", (RUBY_PROC*)&dll_rb_enc_find},
+    {"rb_enc_str_new", (RUBY_PROC*)&dll_rb_enc_str_new},
+    {"rb_sprintf", (RUBY_PROC*)&dll_rb_sprintf},
+#endif
     {"", NULL},
 };
 
 /*
  * Free ruby.dll
@@ -338,10 +457,62 @@ void ex_ruby(exarg_T *eap)
 	    error_print(state);
     }
     vim_free(script);
 }
 
+/*
+ *  In Ruby 1.9 or later, ruby String object has encoding.
+ *  conversion buffer string of vim to ruby String object using
+ *  VIM encoding option.
+ */
+    static VALUE
+vim_str2rb_enc_str(const char *s)
+{
+#if defined(RUBY_VERSION) && RUBY_VERSION >= 19
+    int isnum;
+    long lval;
+    char_u *sval;
+    rb_encoding *enc;
+
+    isnum = get_option_value((char_u *)"enc", &lval, &sval, 0);
+    if (isnum == 0)
+    {
+	enc = rb_enc_find((char *)sval);
+	vim_free(sval);
+	if (enc) {
+	    return rb_enc_str_new(s, strlen(s), enc);
+	}
+    }
+#endif
+    return rb_str_new2(s);
+}
+
+    static VALUE
+eval_enc_string_protect(const char *str, int *state)
+{
+#if defined(RUBY_VERSION) && RUBY_VERSION >= 19
+    int isnum;
+    long lval;
+    char_u *sval;
+    rb_encoding *enc;
+    VALUE v;
+
+    isnum = get_option_value((char_u *)"enc", &lval, &sval, 0);
+    if (isnum == 0)
+    {
+	enc = rb_enc_find((char *)sval);
+	vim_free(sval);
+	if (enc)
+	{
+	    v = rb_sprintf("#-*- coding:%s -*-\n%s", rb_enc_name(enc), str);
+	    return rb_eval_string_protect(StringValuePtr(v), state);
+	}
+    }
+#endif
+    return rb_eval_string_protect(str, state);
+}
+
 void ex_rubydo(exarg_T *eap)
 {
     int state;
     linenr_T i;
 
@@ -350,24 +521,24 @@ void ex_rubydo(exarg_T *eap)
 	if (u_save(eap->line1 - 1, eap->line2 + 1) != OK)
 	    return;
 	for (i = eap->line1; i <= eap->line2; i++) {
 	    VALUE line, oldline;
 
-	    line = oldline = rb_str_new2((char *)ml_get(i));
+	    line = oldline = vim_str2rb_enc_str((char *)ml_get(i));
 	    rb_lastline_set(line);
-	    rb_eval_string_protect((char *) eap->arg, &state);
+	    eval_enc_string_protect((char *) eap->arg, &state);
 	    if (state) {
 		error_print(state);
 		break;
 	    }
 	    line = rb_lastline_get();
 	    if (!NIL_P(line)) {
 		if (TYPE(line) != T_STRING) {
 		    EMSG(_("E265: $_ must be an instance of String"));
 		    return;
 		}
-		ml_replace(i, (char_u *) STR2CSTR(line), 1);
+		ml_replace(i, (char_u *) StringValuePtr(line), 1);
 		changed();
 #ifdef SYNTAX_HL
 		syn_changed(i); /* recompute syntax hl. for this line */
 #endif
 	    }
@@ -412,13 +583,28 @@ static int ensure_ruby_initialized(void)
     {
 #ifdef DYNAMIC_RUBY
 	if (ruby_enabled(TRUE))
 	{
 #endif
+#ifdef _WIN32
+	    /* suggested by Ariya Mizutani */
+	    int argc = 1;
+	    char *argv[] = {"gvim.exe"};
+	    NtInitialize(&argc, &argv);
+#endif
+#if defined(RUBY_VERSION) && RUBY_VERSION >= 19
+	    RUBY_INIT_STACK;
+#endif
 	    ruby_init();
+#if defined(RUBY_VERSION) && RUBY_VERSION >= 19
+	    ruby_script("vim-ruby");
+#endif
 	    ruby_init_loadpath();
 	    ruby_io_init();
+#if defined(RUBY_VERSION) && RUBY_VERSION >= 19
+	    rb_enc_find_index("encdb");
+#endif
 	    ruby_vim_init();
 	    ruby_initialized = 1;
 #ifdef DYNAMIC_RUBY
 	}
 	else
@@ -432,12 +618,15 @@ static int ensure_ruby_initialized(void)
 }
 
 static void error_print(int state)
 {
 #ifndef DYNAMIC_RUBY
+#if !(defined(RUBY_VERSION) && RUBY_VERSION >= 19) \
+    && !(defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 19)
     RUBYEXTERN VALUE ruby_errinfo;
 #endif
+#endif
     VALUE eclass;
     VALUE einfo;
     char buff[BUFSIZ];
 
 #define TAG_RETURN	0x1
@@ -466,22 +655,28 @@ static void error_print(int state)
     case TAG_RETRY:
 	EMSG(_("E271: retry outside of rescue clause"));
 	break;
     case TAG_RAISE:
     case TAG_FATAL:
+#if defined(RUBY_VERSION) && RUBY_VERSION >= 19 \
+    || defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 19
+	eclass = CLASS_OF(rb_errinfo());
+	einfo = rb_obj_as_string(rb_errinfo());
+#else
 	eclass = CLASS_OF(ruby_errinfo);
 	einfo = rb_obj_as_string(ruby_errinfo);
-	if (eclass == rb_eRuntimeError && RSTRING(einfo)->len == 0) {
+#endif
+	if (eclass == rb_eRuntimeError && RSTRING_LEN(einfo) == 0) {
 	    EMSG(_("E272: unhandled exception"));
 	}
 	else {
 	    VALUE epath;
 	    char *p;
 
 	    epath = rb_class_path(eclass);
 	    vim_snprintf(buff, BUFSIZ, "%s: %s",
-		     RSTRING(epath)->ptr, RSTRING(einfo)->ptr);
+		     RSTRING_PTR(epath), RSTRING_PTR(einfo));
 	    p = strchr(buff, '\n');
 	    if (p) *p = '\0';
 	    EMSG(buff);
 	}
 	break;
@@ -490,50 +685,118 @@ static void error_print(int state)
 	EMSG(buff);
 	break;
     }
 }
 
-static VALUE vim_message(VALUE self, VALUE str)
+static VALUE vim_message(VALUE self UNUSED, VALUE str)
 {
     char *buff, *p;
 
     str = rb_obj_as_string(str);
-    buff = ALLOCA_N(char, RSTRING(str)->len);
-    strcpy(buff, RSTRING(str)->ptr);
+    buff = ALLOCA_N(char, RSTRING_LEN(str));
+    strcpy(buff, RSTRING_PTR(str));
     p = strchr(buff, '\n');
     if (p) *p = '\0';
     MSG(buff);
     return Qnil;
 }
 
-static VALUE vim_set_option(VALUE self, VALUE str)
+static VALUE vim_set_option(VALUE self UNUSED, VALUE str)
 {
-    do_set((char_u *)STR2CSTR(str), 0);
+    do_set((char_u *)StringValuePtr(str), 0);
     update_screen(NOT_VALID);
     return Qnil;
 }
 
-static VALUE vim_command(VALUE self, VALUE str)
+static VALUE vim_command(VALUE self UNUSED, VALUE str)
 {
-    do_cmdline_cmd((char_u *)STR2CSTR(str));
+    do_cmdline_cmd((char_u *)StringValuePtr(str));
     return Qnil;
 }
 
-static VALUE vim_evaluate(VALUE self, VALUE str)
+#ifdef FEAT_EVAL
+static VALUE vim_to_ruby(typval_T *tv)
+{
+    VALUE result = Qnil;
+
+    if (tv->v_type == VAR_STRING)
+    {
+        result = rb_str_new2((char *)tv->vval.v_string);
+    }
+    else if (tv->v_type == VAR_NUMBER)
+    {
+        result = INT2NUM(tv->vval.v_number);
+    }
+# ifdef FEAT_FLOAT
+    else if (tv->v_type == VAR_FLOAT)
+    {
+        result = rb_float_new(tv->vval.v_float);
+    }
+# endif
+    else if (tv->v_type == VAR_LIST)
+    {
+        list_T      *list = tv->vval.v_list;
+        listitem_T  *curr;
+
+        result = rb_ary_new();
+
+        if (list != NULL)
+        {
+            for (curr = list->lv_first; curr != NULL; curr = curr->li_next)
+            {
+                rb_ary_push(result, vim_to_ruby(&curr->li_tv));
+            }
+        }
+    }
+    else if (tv->v_type == VAR_DICT)
+    {
+        result = rb_hash_new();
+
+        if (tv->vval.v_dict != NULL)
+        {
+            hashtab_T   *ht = &tv->vval.v_dict->dv_hashtab;
+            long_u      todo = ht->ht_used;
+            hashitem_T  *hi;
+            dictitem_T  *di;
+
+            for (hi = ht->ht_array; todo > 0; ++hi)
+            {
+                if (!HASHITEM_EMPTY(hi))
+                {
+                    --todo;
+
+                    di = dict_lookup(hi);
+                    rb_hash_aset(result, rb_str_new2((char *)hi->hi_key),
+						     vim_to_ruby(&di->di_tv));
+                }
+            }
+        }
+    } /* else return Qnil; */
+
+    return result;
+}
+#endif
+
+static VALUE vim_evaluate(VALUE self UNUSED, VALUE str)
 {
 #ifdef FEAT_EVAL
-    char_u *value = eval_to_string((char_u *)STR2CSTR(str), NULL, TRUE);
+    typval_T    *tv;
+    VALUE       result;
 
-    if (value != NULL)
+    tv = eval_expr((char_u *)StringValuePtr(str), NULL);
+    if (tv == NULL)
     {
-	VALUE val = rb_str_new2((char *)value);
-	vim_free(value);
-	return val;
+        return Qnil;
     }
-    else
+    result = vim_to_ruby(tv);
+
+    free_tv(tv);
+
+    return result;
+#else
+    return Qnil;
 #endif
-	return Qnil;
 }
 
 static VALUE buffer_new(buf_T *buf)
 {
     if (buf->b_ruby_ref)
@@ -578,11 +841,11 @@ static VALUE buffer_s_count()
     }
 
     return INT2NUM(n);
 }
 
-static VALUE buffer_s_aref(VALUE self, VALUE num)
+static VALUE buffer_s_aref(VALUE self UNUSED, VALUE num)
 {
     buf_T *b;
     int n = NUM2INT(num);
 
     for (b = firstbuf; b != NULL; b = b->b_next)
@@ -624,14 +887,16 @@ static VALUE buffer_count(VALUE self)
 static VALUE get_buffer_line(buf_T *buf, linenr_T n)
 {
     if (n > 0 && n <= buf->b_ml.ml_line_count)
     {
 	char *line = (char *)ml_get_buf(buf, n, FALSE);
-	return line ? rb_str_new2(line) : Qnil;
+	return line ? vim_str2rb_enc_str(line) : Qnil;
     }
-    rb_raise(rb_eIndexError, "index %d out of buffer", n);
+    rb_raise(rb_eIndexError, "line number %ld out of range", (long)n);
+#ifndef __GNUC__
     return Qnil; /* For stop warning */
+#endif
 }
 
 static VALUE buffer_aref(VALUE self, VALUE num)
 {
     buf_T *buf = get_buf(self);
@@ -641,11 +906,11 @@ static VALUE buffer_aref(VALUE self, VAL
     return Qnil; /* For stop warning */
 }
 
 static VALUE set_buffer_line(buf_T *buf, linenr_T n, VALUE str)
 {
-    char	*line = STR2CSTR(str);
+    char	*line = StringValuePtr(str);
     aco_save_T	aco;
 
     if (n > 0 && n <= buf->b_ml.ml_line_count && line != NULL)
     {
 	/* set curwin/curbuf for "buf" and save some things */
@@ -665,12 +930,14 @@ static VALUE set_buffer_line(buf_T *buf,
 
 	update_curbuf(NOT_VALID);
     }
     else
     {
-	rb_raise(rb_eIndexError, "index %d out of buffer", n);
+	rb_raise(rb_eIndexError, "line number %ld out of range", (long)n);
+#ifndef __GNUC__
 	return Qnil; /* For stop warning */
+#endif
     }
     return str;
 }
 
 static VALUE buffer_aset(VALUE self, VALUE num, VALUE str)
@@ -709,23 +976,26 @@ static VALUE buffer_delete(VALUE self, V
 
 	update_curbuf(NOT_VALID);
     }
     else
     {
-	rb_raise(rb_eIndexError, "index %d out of buffer", n);
+	rb_raise(rb_eIndexError, "line number %ld out of range", n);
     }
     return Qnil;
 }
 
 static VALUE buffer_append(VALUE self, VALUE num, VALUE str)
 {
     buf_T	*buf = get_buf(self);
-    char	*line = STR2CSTR(str);
+    char	*line = StringValuePtr(str);
     long	n = NUM2LONG(num);
     aco_save_T	aco;
 
-    if (n >= 0 && n <= buf->b_ml.ml_line_count && line != NULL)
+    if (line == NULL) {
+	rb_raise(rb_eIndexError, "NULL line");
+    }
+    else if (n >= 0 && n <= buf->b_ml.ml_line_count)
     {
 	/* set curwin/curbuf for "buf" and save some things */
 	aucmd_prepbuf(&aco, buf);
 
 	if (u_inssub(n + 1) == OK) {
@@ -743,11 +1013,11 @@ static VALUE buffer_append(VALUE self, V
 	/* Careful: autocommands may have made "buf" invalid! */
 
 	update_curbuf(NOT_VALID);
     }
     else {
-	rb_raise(rb_eIndexError, "index %d out of buffer", n);
+	rb_raise(rb_eIndexError, "line number %ld out of range", n);
     }
     return str;
 }
 
 static VALUE window_new(win_T *win)
@@ -787,11 +1057,11 @@ static VALUE window_s_current()
 static VALUE line_s_current()
 {
     return get_buffer_line(curbuf, curwin->w_cursor.lnum);
 }
 
-static VALUE set_current_line(VALUE self, VALUE str)
+static VALUE set_current_line(VALUE self UNUSED, VALUE str)
 {
     return set_buffer_line(curbuf, curwin->w_cursor.lnum, str);
 }
 
 static VALUE current_line_number()
@@ -813,11 +1083,11 @@ static VALUE window_s_count()
 #else
     return INT2NUM(1);
 #endif
 }
 
-static VALUE window_s_aref(VALUE self, VALUE num)
+static VALUE window_s_aref(VALUE self UNUSED, VALUE num)
 {
     win_T *w;
     int n = NUM2INT(num);
 
 #ifndef FEAT_WINDOWS
@@ -884,31 +1154,31 @@ static VALUE window_set_cursor(VALUE sel
 {
     VALUE lnum, col;
     win_T *win = get_win(self);
 
     Check_Type(pos, T_ARRAY);
-    if (RARRAY(pos)->len != 2)
+    if (RARRAY_LEN(pos) != 2)
 	rb_raise(rb_eArgError, "array length must be 2");
-    lnum = RARRAY(pos)->ptr[0];
-    col = RARRAY(pos)->ptr[1];
+    lnum = RARRAY_PTR(pos)[0];
+    col = RARRAY_PTR(pos)[1];
     win->w_cursor.lnum = NUM2LONG(lnum);
     win->w_cursor.col = NUM2UINT(col);
     check_cursor();		    /* put cursor on an existing line */
     update_screen(NOT_VALID);
     return Qnil;
 }
 
-static VALUE f_p(int argc, VALUE *argv, VALUE self)
+static VALUE f_p(int argc, VALUE *argv, VALUE self UNUSED)
 {
     int i;
     VALUE str = rb_str_new("", 0);
 
     for (i = 0; i < argc; i++) {
 	if (i > 0) rb_str_cat(str, ", ", 2);
 	rb_str_concat(str, rb_inspect(argv[i]));
     }
-    MSG(RSTRING(str)->ptr);
+    MSG(RSTRING_PTR(str));
     return Qnil;
 }
 
 static void ruby_io_init(void)
 {
--- vim72.orig/src/if_tcl.c
+++ vim72/src/if_tcl.c
@@ -159,11 +159,11 @@ static struct ref refsdeleted;	/* dummy
 # ifndef  DYNAMIC_TCL /* Just generating prototypes */
 typedef int HANDLE;
 # endif
 
 /*
- * Declare HANDLE for perl.dll and function pointers.
+ * Declare HANDLE for tcl.dll and function pointers.
  */
 static HANDLE hTclLib = NULL;
 Tcl_Interp* (*dll_Tcl_CreateInterp)();
 
 /*
@@ -180,11 +180,11 @@ static struct {
 
 /*
  * Make all runtime-links of tcl.
  *
  * 1. Get module handle using LoadLibraryEx.
- * 2. Get pointer to perl function by GetProcAddress.
+ * 2. Get pointer to tcl function by GetProcAddress.
  * 3. Repeat 2, until get all functions will be used.
  *
  * Parameter 'libname' provides name of DLL.
  * Return OK or FAIL.
  */
@@ -288,14 +288,13 @@ tcl_end()
  * we just delete the Tcl interpreter (and create a new one with the next
  * :tcl command).
  */
 #define TCL_EXIT	5
 
-/* ARGSUSED */
     static int
 exitcmd(dummy, interp, objc, objv)
-    ClientData dummy;
+    ClientData dummy UNUSED;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
 {
     int value = 0;
@@ -313,14 +312,13 @@ exitcmd(dummy, interp, objc, objv)
 	    Tcl_WrongNumArgs(interp, 1, objv, "?returnCode?");
     }
     return TCL_ERROR;
 }
 
-/* ARGSUSED */
     static int
 catchcmd(dummy, interp, objc, objv)
-    ClientData	dummy;
+    ClientData	dummy UNUSED;
     Tcl_Interp	*interp;
     int		objc;
     Tcl_Obj	*CONST objv[];
 {
     char    *varname = NULL;
@@ -354,14 +352,13 @@ catchcmd(dummy, interp, objc, objv)
 }
 
 /*
  *  "::vim::beep" - what Vi[m] does best :-)
  */
-/* ARGSUSED */
     static int
 beepcmd(dummy, interp, objc, objv)
-    ClientData dummy;
+    ClientData dummy UNUSED;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
 {
     if (objc != 1)
@@ -376,14 +373,13 @@ beepcmd(dummy, interp, objc, objv)
 /*
  *  "::vim::buffer list" - create a list of buffer commands.
  *  "::vim::buffer {N}" - create buffer command for buffer N.
  *  "::vim::buffer new" - create a new buffer (not implemented)
  */
-/* ARGSUSED */
     static int
 buffercmd(dummy, interp, objc, objv)
-    ClientData dummy;
+    ClientData dummy UNUSED;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
 {
     char	*name;
@@ -473,14 +469,13 @@ buffercmd(dummy, interp, objc, objv)
 }
 
 /*
  * "::vim::window list" - create list of window commands.
  */
-/* ARGSUSED */
     static int
 windowcmd(dummy, interp, objc, objv)
-    ClientData	dummy;
+    ClientData	dummy UNUSED;
     Tcl_Interp	*interp;
     int		objc;
     Tcl_Obj	*CONST objv[];
 {
     char	*what, *string;
@@ -1128,14 +1123,13 @@ winselfcmd(ref, interp, objc, objv)
 
     return err;
 }
 
 
-/* ARGSUSED */
     static int
 commandcmd(dummy, interp, objc, objv)
-    ClientData	dummy;
+    ClientData	dummy UNUSED;
     Tcl_Interp	*interp;
     int		objc;
     Tcl_Obj	*CONST objv[];
 {
     int		err;
@@ -1143,14 +1137,13 @@ commandcmd(dummy, interp, objc, objv)
     err = tcldoexcommand(interp, objc, objv, 1);
     update_screen(VALID);
     return err;
 }
 
-/* ARGSUSED */
     static int
 optioncmd(dummy, interp, objc, objv)
-    ClientData	dummy;
+    ClientData	dummy UNUSED;
     Tcl_Interp	*interp;
     int		objc;
     Tcl_Obj	*CONST objv[];
 {
     int		err;
@@ -1158,14 +1151,13 @@ optioncmd(dummy, interp, objc, objv)
     err = tclsetoption(interp, objc, objv, 1);
     update_screen(VALID);
     return err;
 }
 
-/* ARGSUSED */
     static int
 exprcmd(dummy, interp, objc, objv)
-    ClientData	dummy;
+    ClientData	dummy UNUSED;
     Tcl_Interp	*interp;
     int		objc;
     Tcl_Obj	*CONST objv[];
 {
     return tclvimexpr(interp, objc, objv, 1);
@@ -1582,15 +1574,14 @@ tclsetdelcmd(interp, reflist, vimobj, de
 
 /*******************************************
     I/O Channel
 ********************************************/
 
-/* ARGSUSED */
     static int
 channel_close(instance, interp)
     ClientData	instance;
-    Tcl_Interp	*interp;
+    Tcl_Interp	*interp UNUSED;
 {
     int		err = 0;
 
     /* currently does nothing */
 
@@ -1600,16 +1591,15 @@ channel_close(instance, interp)
 	err = EBADF;
     }
     return err;
 }
 
-/* ARGSUSED */
     static int
 channel_input(instance, buf, bufsiz, errptr)
-    ClientData	instance;
-    char	*buf;
-    int		bufsiz;
+    ClientData	instance UNUSED;
+    char	*buf UNUSED;
+    int		bufsiz UNUSED;
     int		*errptr;
 {
 
     /* input is currently not supported */
 
@@ -1657,43 +1647,56 @@ channel_output(instance, buf, bufsiz, er
     }
     vim_free(str);
     return result;
 }
 
-/* ARGSUSED */
     static void
 channel_watch(instance, mask)
-    ClientData	instance;
-    int		mask;
+    ClientData	instance UNUSED;
+    int		mask UNUSED;
 {
     Tcl_SetErrno(EINVAL);
 }
 
-/* ARGSUSED */
     static int
 channel_gethandle(instance, direction, handleptr)
-    ClientData	instance;
-    int		direction;
-    ClientData	*handleptr;
+    ClientData	instance UNUSED;
+    int		direction UNUSED;
+    ClientData	*handleptr UNUSED;
 {
     Tcl_SetErrno(EINVAL);
     return EINVAL;
 }
 
 
 static Tcl_ChannelType channel_type =
 {
-    "vimmessage",
-    NULL,   /* blockmode */
-    channel_close,
-    channel_input,
-    channel_output,
-    NULL,   /* seek */
-    NULL,   /* set option */
-    NULL,   /* get option */
-    channel_watch,
-    channel_gethandle
+    "vimmessage",	/* typeName */
+    NULL,		/* version */
+    channel_close,	/* closeProc */
+    channel_input,	/* inputProc */
+    channel_output,	/* outputProc */
+    NULL,		/* seekProc */
+    NULL,		/* setOptionProc */
+    NULL,		/* getOptionProc */
+    channel_watch,	/* watchProc */
+    channel_gethandle,	/* getHandleProc */
+    NULL,		/* close2Proc */
+    NULL,		/* blockModeProc */
+#ifdef TCL_CHANNEL_VERSION_2
+    NULL,		/* flushProc */
+    NULL,		/* handlerProc */
+#endif
+#ifdef TCL_CHANNEL_VERSION_3
+    NULL,		/* wideSeekProc */
+#endif
+#ifdef TCL_CHANNEL_VERSION_4
+    NULL,		/* threadActionProc */
+#endif
+#ifdef TCL_CHANNEL_VERSION_5
+    NULL		/* truncateProc */
+#endif
 };
 
 /**********************************
   Interface to vim
  **********************************/
--- vim72.orig/runtime/doc/if_mzsch.txt
+++ vim72/runtime/doc/if_mzsch.txt
@@ -1,18 +1,19 @@
-*if_mzsch.txt*  For Vim version 7.2.  Last change: 2008 Jun 28
+*if_mzsch.txt*  For Vim version 7.2.  Last change: 2010 Jan 19
 
 
 		  VIM REFERENCE MANUAL    by Sergey Khorev
 
 
 The MzScheme Interface to Vim				*mzscheme* *MzScheme*
 
 1. Commands				|mzscheme-commands|
 2. Examples				|mzscheme-examples|
 3. Threads				|mzscheme-threads|
-4. The Vim access procedures		|mzscheme-vim|
-5. Dynamic loading			|mzscheme-dynamic|
+4. Vim access from MzScheme		|mzscheme-vim|
+5. mzeval() Vim function		|mzscheme-mzeval|
+6. Dynamic loading			|mzscheme-dynamic|
 
 {Vi does not have any of these commands}
 
 The MzScheme interface is available only if Vim was compiled with the
 |+mzscheme| feature.
@@ -40,24 +41,18 @@ Note: On FreeBSD you should use the "drs
 			feature wasn't compiled in.  To avoid errors, see
 			|script-here|.
 
 							*:mzfile* *:mzf*
 :[range]mzf[ile] {file}	Execute the MzScheme script in {file}.  {not in Vi}
-			All statements are executed in the namespace of the
-			buffer that was current during :mzfile start.
-			If you want to access other namespaces, use
-			'parameterize'.
 
 All of these commands do essentially the same thing - they execute a piece of
 MzScheme code, with the "current range" set to the given line
 range.
 
 In the case of :mzscheme, the code to execute is in the command-line.
 In the case of :mzfile, the code to execute is the contents of the given file.
 
-Each buffer has its own MzScheme namespace. Global namespace is bound to
-the "global-namespace" value from the 'vimext' module.
 MzScheme interface defines exception exn:vim, derived from exn.
 It is raised for various Vim errors.
 
 During compilation, the MzScheme interface will remember the current MzScheme
 collection path. If you want to specify additional paths use the
@@ -77,79 +72,68 @@ The exn:vim is available without explici
 
 To avoid clashes with MzScheme, consider using prefix when requiring module,
 e.g.: >
 	:mzscheme (require (prefix vim- vimext))
 <
-All the examples below assume this naming scheme.  Note that you need to do
-this again for every buffer.
+All the examples below assume this naming scheme.
 
-The auto-instantiation can be achieved with autocommands, e.g. you can put
-something like this in your .vimrc (EOFs should not have indentation): >
-    function s:MzRequire()
-	if has("mzscheme")
-	    :mz << EOF
-	    (require (prefix vim- vimext))
-	    (let ((buf (vim-get-buff-by-name (vim-eval "expand(\"<afile>\")"))))
-	      (when (and buf (not (eq? buf (vim-curr-buff))))
-		(parameterize ((current-namespace (vim-get-buff-namespace buf)))
-		  (namespace-attach-module vim-global-namespace 'vimext)
-		  (namespace-require '(prefix vim vimext)))))
-    EOF
-	endif
-    endfunction
-
-    function s:MzStartup()
-	if has("mzscheme")
-	    au BufNew,BufNewFile,BufAdd,BufReadPre * :call s:MzRequire()
-	    :mz << EOF
-	    (current-library-collection-paths
-		(cons
-		    (build-path (find-system-path 'addon-dir) (version) "collects")
-		    (current-library-collection-paths)))
-    EOF
-	endif
-    endfunction
-
-    call s:MzStartup()
-<
-
-The global namespace just instantiated this module with the prefix "vimext:".
 							*mzscheme-sandbox*
 When executed in the |sandbox|, access to some filesystem and Vim interface
 procedures is restricted.
 
 ==============================================================================
 2. Examples						*mzscheme-examples*
 >
 	:mzscheme (display "Hello")
+	:mz (display (string-append "Using MzScheme version " (version)))
+	:mzscheme (require (prefix vim- vimext)) ; for MzScheme < 4.x
+	:mzscheme (require (prefix-in vim- 'vimext)) ; MzScheme 4.x
 	:mzscheme (vim-set-buff-line 10 "This is line #10")
 <
 Inline script usage: >
 	function! <SID>SetFirstLine()
 	    :mz << EOF
 	    (display "!!!")
+	    (require (prefix vim- vimext))
+	    ; for newer versions (require (prefix-in vim- 'vimext))
 	    (vim-set-buff-line 1 "This is line #1")
 	    (vim-beep)
-	    EOF
+	EOF
 	endfunction
 
 	nmap <F9> :call <SID>SetFirstLine() <CR>
 <
 File execution: >
 	:mzfile supascript.scm
 <
-Accessing the current buffer namespace from an MzScheme program running in
-another buffer within |:mzfile|-executed script : >
-	; Move to the window below
-	(vim-command "wincmd j")
-	; execute in the context of buffer, to which window belongs
-	; assume that buffer has 'textstring' defined
-	(parameterize ((current-namespace
-			(vim-get-buff-namespace (vim-curr-buff))))
-	 (eval '(vim-set-buff-line 1 textstring)))
-<
+Vim exception handling: >
+	:mz << EOF
+	(require (prefix vim- vimext))
+	; for newer versions (require (prefix-in vim- 'vimext))
+	(with-handlers
+	  ([exn:vim? (lambda (e) (display (exn-message e)))])
+	  (vim-eval "nonsense-string"))
+	EOF
+<
+Auto-instantiation of vimext module (can be placed in your |vimrc|): >
+    function! MzRequire()
+	:redir => l:mzversion
+	:mz (version)
+	:redir END
+	if strpart(l:mzversion, 1, 1) < "4"
+	    " MzScheme versions < 4.x:
+	    :mz (require (prefix vim- vimext))
+	else
+	    " newer versions:
+	    :mz (require (prefix-in vim- 'vimext))
+	endif
+    endfunction
 
+    if has("mzscheme")
+	silent call MzRequire()
+    endif
+<
 ==============================================================================
 3. Threads						*mzscheme-threads*
 
 The MzScheme interface supports threads. They are independent from OS threads,
 thus scheduling is required. The option 'mzquantum' determines how often
@@ -157,24 +141,24 @@ Vim should poll for available MzScheme t
 NOTE
 Thread scheduling in the console version of Vim is less reliable than in the
 GUI version.
 
 ==============================================================================
-5. VIM Functions					*mzscheme-vim*
+4. Vim access from MzScheme				*mzscheme-vim*
 
 							*mzscheme-vimext*
 The 'vimext' module provides access to procedures defined in the MzScheme
 interface.
 
 Common
 ------
     (command {command-string})	    Perform the vim ":Ex" style command.
-    (eval {expr-string})	    Evaluate the vim expression to a string.
-				    A |List| is turned into a string by
-				    joining the items and inserting line
-				    breaks.
-				    NOTE clashes with MzScheme eval
+    (eval {expr-string})	    Evaluate the vim expression into
+				    respective MzScheme object: |Lists| are
+				    represented as Scheme lists,
+				    |Dictionaries| as hash tables.
+				    NOTE the name clashes with MzScheme eval
     (range-start)		    Start/End of the range passed with
     (range-end)			    the Scheme command.
     (beep)			    beep
     (get-option {option-name} [buffer-or-window]) Get Vim option value (either
 				    local or global, see set-option).
@@ -184,11 +168,10 @@ Common
 				    optname+=optval, etc.) When called with
 				    {buffer} or {window} the local option will
 				    be set. The symbol 'global can be passed
 				    as {buffer-or-window}. Then |:setglobal|
 				    will be used.
-    global-namespace		    The MzScheme main namespace.
 
 Buffers							 *mzscheme-buffer*
 -------
     (buff? {object})		    Is object a buffer?
     (buff-valid? {object})	    Is object a valid buffer? (i.e.
@@ -226,11 +209,10 @@ Buffers							 *mzscheme-buffer*
     (open-buff {filename})	    Open a new buffer (for file "name")
     (get-buff-by-name {buffername}) Get a buffer by its filename or #f
 					if there is no such buffer.
     (get-buff-by-num {buffernum})   Get a buffer by its number (return #f if
 				    there is no buffer with this number).
-    (get-buff-namespace [buffer])   Get buffer namespace.
 
 Windows							    *mzscheme-window*
 ------
     (win? {object})		    Is object a window?
     (win-valid? {object})	    Is object a valid window (i.e. corresponds
@@ -248,11 +230,17 @@ Windows							    *mzscheme-window*
     (get-cursor [window])	    Get cursor position in a window as
 				    a pair (linenr . column).
     (set-cursor (line . col) [window])  Set cursor position.
 
 ==============================================================================
-5. Dynamic loading					*mzscheme-dynamic*
+5. mzeval() Vim function				    *mzscheme-mzeval*
+
+To facilitate bi-directional interface, you can use |mzeval| function to
+evaluate MzScheme expressions and pass their values to VimL.
+
+==============================================================================
+6. Dynamic loading				    *mzscheme-dynamic* *E815*
 
 On MS-Windows the MzScheme libraries can be loaded dynamically. The |:version|
 output then includes |+mzscheme/dyn|.
 
 This means that Vim will search for the MzScheme DLL files only when needed.
--- vim72.orig/src/Make_ming.mak
+++ vim72/src/Make_ming.mak
@@ -113,18 +113,31 @@ endif
 
 ifndef MZSCHEME_VER
 MZSCHEME_VER=205_000
 endif
 
+ifndef MZSCHEME_PRECISE_GC
+MZSCHEME_PRECISE_GC=no
+endif
+
+# for version 4.x we need to generate byte-code for Scheme base
+ifndef MZSCHEME_GENERATE_BASE
+MZSCHEME_GENERATE_BASE=no
+endif
+
 ifeq (no,$(DYNAMIC_MZSCHEME))
+ifeq (yes,$(MZSCHEME_PRECISE_GC))
+MZSCHEME_LIB=-lmzsch$(MZSCHEME_VER)
+else
 MZSCHEME_LIB = -lmzsch$(MZSCHEME_VER) -lmzgc$(MZSCHEME_VER)
+endif
 # the modern MinGW can dynamically link to dlls directly.
 # point MZSCHEME_DLLS to where you put libmzschXXXXXXX.dll and libgcXXXXXXX.dll
 ifndef MZSCHEME_DLLS
 MZSCHEME_DLLS=$(MZSCHEME)
 endif
-MZSCHEME_LIBDIR=-L$(MZSCHEME_DLLS)
+MZSCHEME_LIBDIR=-L$(MZSCHEME_DLLS) -L$(MZSCHEME_DLLS)\lib
 endif
 
 endif
 
 # Python support -- works with the ActiveState python 2.0 release (and others
@@ -197,27 +210,29 @@ RUBY_VER = 16
 endif
 ifndef RUBY_VER_LONG
 RUBY_VER_LONG = 1.6
 endif
 
-ifeq ($(RUBY_VER), 16)
 ifndef RUBY_PLATFORM
+ifeq ($(RUBY_VER), 16)
 RUBY_PLATFORM = i586-mswin32
-endif
-ifndef RUBY_INSTALL_NAME
-RUBY_INSTALL_NAME = mswin32-ruby$(RUBY_VER)
-endif
+else ifneq ("X$(wildcard, $(RUBY)/lib/ruby/$(RUBY_VER_LONG)/i386-mingw32)", X)
+RUBY_PLATFORM = i386-mingw32
 else
-ifndef RUBY_PLATFORM
 RUBY_PLATFORM = i386-mswin32
 endif
+endif
+
 ifndef RUBY_INSTALL_NAME
+ifeq ($(RUBY_VER), 16)
+RUBY_INSTALL_NAME = mswin32-ruby$(RUBY_VER)
+else
 RUBY_INSTALL_NAME = msvcrt-ruby$(RUBY_VER)
 endif
 endif
 
-RUBYINC =-I $(RUBY)/lib/ruby/$(RUBY_VER_LONG)/$(RUBY_PLATFORM)
+RUBYINC =-I $(RUBY)/lib/ruby/$(RUBY_VER_LONG)/$(RUBY_PLATFORM) -I $(RUBY)/include/ruby-$(RUBY_VER_LONG) -I $(RUBY)/include/ruby-$(RUBY_VER_LONG)/$(RUBY_PLATFORM)
 ifeq (no, $(DYNAMIC_RUBY))
 RUBYLIB = -L$(RUBY)/lib -l$(RUBY_INSTALL_NAME)
 endif
 
 endif # RUBY
@@ -226,29 +241,30 @@ endif # RUBY
 # Any other defines can be included here.
 DEF_GUI=-DFEAT_GUI_W32 -DFEAT_CLIPBOARD
 DEFINES=-DWIN32 -DWINVER=$(WINVER) -D_WIN32_WINNT=$(WINVER) \
 	-DHAVE_PATHDEF -DFEAT_$(FEATURES)
 ifeq ($(CROSS),yes)
-# cross-compiler:
-CC = i586-pc-mingw32msvc-gcc
+# cross-compiler prefix:
+CROSS_COMPILE = i586-pc-mingw32msvc-
 DEL = rm
 MKDIR = mkdir -p
-WINDRES = i586-pc-mingw32msvc-windres
+DIRSLASH = /
 else
 # normal (Windows) compilation:
-CC = gcc
+CROSS_COMPILE =
 ifneq (sh.exe, $(SHELL))
 DEL = rm
 MKDIR = mkdir -p
 DIRSLASH = /
 else
 DEL = del
 MKDIR = mkdir
 DIRSLASH = \\
 endif
-WINDRES = windres
 endif
+CC := $(CROSS_COMPILE)gcc
+WINDRES := $(CROSS_COMPILE)windres
 
 #>>>>> end of choices
 ###########################################################################
 
 CFLAGS = -Iproto $(DEFINES) -pipe -w -march=$(ARCH) -Wall
@@ -408,10 +424,17 @@ ifdef PERL
 OBJ += $(OUTDIR)/if_perl.o
 endif
 ifdef MZSCHEME
 OBJ += $(OUTDIR)/if_mzsch.o
 MZSCHEME_INCL = if_mzsch.h
+ifeq (yes,$(MZSCHEME_GENERATE_BASE))
+CFLAGS += -DINCLUDE_MZSCHEME_BASE
+MZ_EXTRA_DEP += mzscheme_base.c
+endif
+ifeq (yes,$(MZSCHEME_PRECISE_GC))
+CFLAGS += -DMZ_PRECISE_GC
+endif
 endif
 ifdef PYTHON
 OBJ += $(OUTDIR)/if_python.o
 endif
 ifdef RUBY
@@ -527,24 +550,27 @@ $(TARGET): $(OUTDIR) $(OBJ)
 upx: exes
 	upx gvim.exe
 	upx vim.exe
 
 xxd/xxd.exe: xxd/xxd.c
-	$(MAKE) -C xxd -f Make_cyg.mak
+	$(MAKE) -C xxd -f Make_cyg.mak CC=$(CC)
 
 GvimExt/gvimext.dll: GvimExt/gvimext.cpp GvimExt/gvimext.rc GvimExt/gvimext.h
-	$(MAKE) -C GvimExt -f Make_ming.mak
+	$(MAKE) -C GvimExt -f Make_ming.mak CROSS=$(CROSS) CROSS_COMPILE=$(CROSS_COMPILE)
 
 clean:
 	-$(DEL) $(OUTDIR)$(DIRSLASH)*.o
 	-$(DEL) $(OUTDIR)$(DIRSLASH)*.res
 	-rmdir $(OUTDIR)
 	-$(DEL) *.exe
 	-$(DEL) pathdef.c
 ifdef PERL
 	-$(DEL) if_perl.c
 endif
+ifdef MZSCHEME
+	-$(DEL) mzscheme_base.c
+endif
 	$(MAKE) -C GvimExt -f Make_ming.mak clean
 	$(MAKE) -C xxd -f Make_cyg.mak clean
 
 ###########################################################################
 INCL = vim.h feature.h os_win32.h os_dos.h ascii.h keymap.h term.h macros.h \
@@ -586,10 +612,16 @@ if_perl.c: if_perl.xs typemap
 	     $(PERLLIB)/ExtUtils/typemap if_perl.xs > $@
 
 $(OUTDIR)/netbeans.o:	netbeans.c $(INCL) $(NBDEBUG_INCL) $(NBDEBUG_SRC)
 	$(CC) -c $(CFLAGS) netbeans.c -o $(OUTDIR)/netbeans.o
 
+$(OUTDIR)/if_mzsch.o:	if_mzsch.c $(INCL) if_mzsch.h $(MZ_EXTRA_DEP)
+	$(CC) -c $(CFLAGS) if_mzsch.c -o $(OUTDIR)/if_mzsch.o
+
+mzscheme_base.c:
+	$(MZSCHEME)/mzc --c-mods mzscheme_base.c ++lib scheme/base
+
 pathdef.c: $(INCL)
 ifneq (sh.exe, $(SHELL))
 	@echo creating pathdef.c
 	@echo '/* pathdef.c */' > pathdef.c
 	@echo '#include "vim.h"' >> pathdef.c
--- vim72.orig/src/config.mk.in
+++ vim72/src/config.mk.in
@@ -39,10 +39,12 @@ X_LIBS		= @X_LIB@
 MZSCHEME_LIBS	= @MZSCHEME_LIBS@
 MZSCHEME_SRC	= @MZSCHEME_SRC@
 MZSCHEME_OBJ	= @MZSCHEME_OBJ@
 MZSCHEME_CFLAGS	= @MZSCHEME_CFLAGS@
 MZSCHEME_PRO	= @MZSCHEME_PRO@
+MZSCHEME_EXTRA  = @MZSCHEME_EXTRA@
+MZSCHEME_MZC	= @MZSCHEME_MZC@
 
 PERL		= @vi_cv_path_perl@
 PERLLIB		= @vi_cv_perllib@
 PERL_LIBS	= @PERL_LIBS@
 SHRPENV		= @shrpenv@
--- vim72.orig/src/if_mzsch.h
+++ vim72/src/if_mzsch.h
@@ -9,10 +9,11 @@
 # define __CYGWIN32__
 #endif
 
 /* #ifdef needed for "make depend" */
 #ifdef FEAT_MZSCHEME
+# include <schvers.h>
 # include <scheme.h>
 #endif
 
 #ifdef __MINGW32__
 # undef __CYGWIN32__
@@ -44,6 +45,33 @@
 # define SCHEME_BYTE_STRLEN_VAL SCHEME_STRLEN_VAL
 # define SCHEME_BYTE_STR_VAL SCHEME_STR_VAL
 # define scheme_byte_string_to_char_string(obj) (obj)
 #endif
 
+/* Precise GC macros */
+#ifndef MZ_GC_DECL_REG
+# define MZ_GC_DECL_REG(size)            /* empty */
+#endif
+#ifndef MZ_GC_VAR_IN_REG
+# define MZ_GC_VAR_IN_REG(x, v)          /* empty */
+#endif
+#ifndef MZ_GC_ARRAY_VAR_IN_REG
+# define MZ_GC_ARRAY_VAR_IN_REG(x, v, l) /* empty */
+#endif
+#ifndef MZ_GC_REG
+# define MZ_GC_REG()                     /* empty */
+#endif
+#ifndef MZ_GC_UNREG
+# define MZ_GC_UNREG()                   /* empty */
+#endif
+
+#ifdef MZSCHEME_FORCE_GC
+/*
+ * force garbage collection to check all references are registered
+ * seg faults will indicate not registered refs
+ */
+# define MZ_GC_CHECK() scheme_collect_garbage();
+#else
+# define MZ_GC_CHECK()			/* empty */
+#endif
+
 #endif /* _IF_MZSCH_H_ */
--- vim72.orig/src/proto/if_mzsch.pro
+++ vim72/src/proto/if_mzsch.pro
@@ -11,14 +11,9 @@ void raise_if_error __ARGS((void));
 buf_T *get_valid_buffer __ARGS((void *));
 win_T *get_valid_window __ARGS((void *));
 void mzvim_check_threads __ARGS((void));
 void mzvim_reset_timer __ARGS((void));
 void *mzvim_eval_string __ARGS((char_u *str));
-struct Scheme_Object *mzvim_apply __ARGS((struct Scheme_Object *, int argc,
-    struct Scheme_Object **));
-int mzthreads_allowed (void);
-#ifdef FEAT_GUI_KDE
-void timer_proc (void);
-void mzscheme_kde_start_timer (void);
-void mzscheme_kde_stop_timer (void);
-#endif
+int mzthreads_allowed __ARGS((void));
+void mzscheme_main __ARGS((void));
+void do_mzeval __ARGS((char_u *str, typval_T *rettv));
 /* vim: set ft=c : */
--- vim72.orig/src/msvc2008.bat
+++ vim72/src/msvc2008.bat
@@ -1,5 +1,7 @@
+@echo off
 rem To be used on MS-Windows for Visual C++ 2008 Express Edition
 rem   aka Microsoft Visual Studio 9.0.
 rem See INSTALLpc.txt for information.
+@echo on
 
 call "%VS90COMNTOOLS%%vsvars32.bat"
--- vim72.orig/src/proto/mbyte.pro
+++ vim72/src/proto/mbyte.pro
@@ -5,14 +5,16 @@ int bomb_size __ARGS((void));
 int mb_get_class __ARGS((char_u *p));
 int dbcs_class __ARGS((unsigned lead, unsigned trail));
 int latin_char2len __ARGS((int c));
 int latin_char2bytes __ARGS((int c, char_u *buf));
 int latin_ptr2len __ARGS((char_u *p));
+int latin_ptr2len_len __ARGS((char_u *p, int size));
 int utf_char2cells __ARGS((int c));
 int latin_ptr2cells __ARGS((char_u *p));
 int utf_ptr2cells __ARGS((char_u *p));
 int dbcs_ptr2cells __ARGS((char_u *p));
+int latin_ptr2cells_len __ARGS((char_u *p, int size));
 int latin_char2cells __ARGS((int c));
 int latin_off2cells __ARGS((unsigned off, unsigned max_off));
 int dbcs_off2cells __ARGS((unsigned off, unsigned max_off));
 int utf_off2cells __ARGS((unsigned off, unsigned max_off));
 int latin_ptr2char __ARGS((char_u *p));
@@ -83,10 +85,11 @@ void im_shutdown __ARGS((void));
 int xim_get_status_area_height __ARGS((void));
 int im_get_status __ARGS((void));
 int preedit_get_status __ARGS((void));
 int im_is_preediting __ARGS((void));
 int convert_setup __ARGS((vimconv_T *vcp, char_u *from, char_u *to));
+int convert_setup_ext __ARGS((vimconv_T *vcp, char_u *from, int from_unicode_is_utf8, char_u *to, int to_unicode_is_utf8));
 int convert_input __ARGS((char_u *ptr, int len, int maxlen));
 int convert_input_safe __ARGS((char_u *ptr, int len, int maxlen, char_u **restp, int *restlenp));
 char_u *string_convert __ARGS((vimconv_T *vcp, char_u *ptr, int *lenp));
 char_u *string_convert_ext __ARGS((vimconv_T *vcp, char_u *ptr, int *lenp, int *unconvlenp));
 /* vim: set ft=c : */
--- vim72.orig/src/proto/gui.pro
+++ vim72/src/proto/gui.pro
@@ -41,10 +41,11 @@ int send_tabline_event __ARGS((int nr));
 void send_tabline_menu_event __ARGS((int tabidx, int event));
 void gui_remove_scrollbars __ARGS((void));
 void gui_create_scrollbar __ARGS((scrollbar_T *sb, int type, win_T *wp));
 scrollbar_T *gui_find_scrollbar __ARGS((long ident));
 void gui_drag_scrollbar __ARGS((scrollbar_T *sb, long value, int still_dragging));
+void gui_may_update_scrollbars __ARGS((void));
 void gui_update_scrollbars __ARGS((int force));
 int gui_do_scroll __ARGS((void));
 int gui_do_horiz_scroll __ARGS((void));
 void gui_check_colors __ARGS((void));
 guicolor_T gui_get_color __ARGS((char_u *name));
--- vim72.orig/src/proto/window.pro
+++ vim72/src/proto/window.pro
@@ -1,20 +1,24 @@
 /* window.c */
 void do_window __ARGS((int nchar, long Prenum, int xchar));
 int win_split __ARGS((int size, int flags));
+int win_split_ins __ARGS((int size, int flags, win_T *newwin, int dir));
 int win_valid __ARGS((win_T *win));
 int win_count __ARGS((void));
 int make_windows __ARGS((int count, int vertical));
 void win_move_after __ARGS((win_T *win1, win_T *win2));
 void win_equal __ARGS((win_T *next_curwin, int current, int dir));
 void close_windows __ARGS((buf_T *buf, int keep_curwin));
 void win_close __ARGS((win_T *win, int free_buf));
 void win_close_othertab __ARGS((win_T *win, int free_buf, tabpage_T *tp));
 void win_free_all __ARGS((void));
+win_T *winframe_remove __ARGS((win_T *win, int *dirp, tabpage_T *tp));
 void close_others __ARGS((int message, int forceit));
 void curwin_init __ARGS((void));
+void win_init_empty __ARGS((win_T *wp));
 int win_alloc_first __ARGS((void));
+void win_alloc_aucmd_win __ARGS((void));
 void win_init_size __ARGS((void));
 void free_tabpage __ARGS((tabpage_T *tp));
 int win_new_tabpage __ARGS((int after));
 int may_open_tabpage __ARGS((void));
 int make_tabpages __ARGS((int maxcount));
@@ -28,10 +32,12 @@ void tabpage_move __ARGS((int nr));
 void win_goto __ARGS((win_T *wp));
 win_T *win_find_nr __ARGS((int winnr));
 void win_enter __ARGS((win_T *wp, int undo_sync));
 win_T *buf_jump_open_win __ARGS((buf_T *buf));
 win_T *buf_jump_open_tab __ARGS((buf_T *buf));
+void win_append __ARGS((win_T *after, win_T *wp));
+void win_remove __ARGS((win_T *wp, tabpage_T *tp));
 int win_alloc_lines __ARGS((win_T *wp));
 void win_free_lsize __ARGS((win_T *wp));
 void shell_new_rows __ARGS((void));
 void shell_new_columns __ARGS((void));
 void win_size_save __ARGS((garray_T *gap));
@@ -56,10 +62,12 @@ int path_with_url __ARGS((char_u *fname)
 int vim_isAbsName __ARGS((char_u *name));
 int vim_FullName __ARGS((char_u *fname, char_u *buf, int len, int force));
 int min_rows __ARGS((void));
 int only_one_window __ARGS((void));
 void check_lnums __ARGS((int do_curwin));
+void make_snapshot __ARGS((int idx));
+void restore_snapshot __ARGS((int idx, int close_curwin));
 int win_hasvertsplit __ARGS((void));
 int match_add __ARGS((win_T *wp, char_u *grp, char_u *pat, int prio, int id));
 int match_delete __ARGS((win_T *wp, int id, int perr));
 void clear_matches __ARGS((win_T *wp));
 matchitem_T *get_match __ARGS((win_T *wp, int id));
--- vim72.orig/src/gvim.exe.mnf
+++ vim72/src/gvim.exe.mnf
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
-<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
+<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3" >
   <assemblyIdentity
     processorArchitecture="*"
     version="7.2.0.0"
     type="win32"
     name="Vim"
@@ -27,6 +27,12 @@
           level="asInvoker"
           uiAccess="false"/>
       </requestedPrivileges>
     </security>
   </trustInfo>
+  <!-- Vista High DPI aware -->
+  <asmv3:application>
+    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
+      <dpiAware>true</dpiAware>
+    </asmv3:windowsSettings>
+  </asmv3:application>
 </assembly>
--- vim72.orig/src/xxd/xxd.c
+++ vim72/src/xxd/xxd.c
@@ -62,10 +62,13 @@
 /* Visual Studio 2005 has 'deprecated' many of the standard CRT functions */
 #if _MSC_VER >= 1400
 # define _CRT_SECURE_NO_DEPRECATE
 # define _CRT_NONSTDC_NO_DEPRECATE
 #endif
+#if !defined(CYGWIN) && (defined(CYGWIN32) || defined(__CYGWIN__) || defined(__CYGWIN32__))
+# define CYGWIN
+#endif
 
 #include <stdio.h>
 #ifdef VAXC
 # include <file.h>
 #else
@@ -75,11 +78,12 @@
 # define MSDOS
 #endif
 #if !defined(OS2) && defined(__EMX__)
 # define OS2
 #endif
-#if defined(MSDOS) || defined(WIN32) || defined(OS2) || defined(__BORLANDC__)
+#if defined(MSDOS) || defined(WIN32) || defined(OS2) || defined(__BORLANDC__) \
+  || defined(CYGWIN)
 # include <io.h>	/* for setmode() */
 #else
 # ifdef UNIX
 #  include <unistd.h>
 # endif
@@ -148,13 +152,10 @@ char osver[] = " (dos 16 bit)";
 char osver[] = "";
 #  endif
 # endif
 #endif
 
-#if !defined(CYGWIN) && (defined(CYGWIN32) || defined(__CYGWIN__) || defined(__CYGWIN32__))
-# define CYGWIN
-#endif
 #if defined(MSDOS) || defined(WIN32) || defined(OS2)
 # define BIN_READ(yes)  ((yes) ? "rb" : "rt")
 # define BIN_WRITE(yes) ((yes) ? "wb" : "wt")
 # define BIN_CREAT(yes) ((yes) ? (O_CREAT|O_BINARY) : O_CREAT)
 # define BIN_ASSIGN(fp, yes) setmode(fileno(fp), (yes) ? O_BINARY : O_TEXT)
@@ -228,11 +229,11 @@ char *pname;
 {
   fprintf(stderr, "Usage:\n       %s [options] [infile [outfile]]\n", pname);
   fprintf(stderr, "    or\n       %s -r [-s [-]offset] [-c cols] [-ps] [infile [outfile]]\n", pname);
   fprintf(stderr, "Options:\n");
   fprintf(stderr, "    -a          toggle autoskip: A single '*' replaces nul-lines. Default off.\n");
-  fprintf(stderr, "    -b          binary digit dump (incompatible with -p,-i,-r). Default hex.\n");
+  fprintf(stderr, "    -b          binary digit dump (incompatible with -ps,-i,-r). Default hex.\n");
   fprintf(stderr, "    -c cols     format <cols> octets per line. Default 16 (-i: 12, -ps: 30).\n");
   fprintf(stderr, "    -E          show characters in EBCDIC. Default ASCII.\n");
   fprintf(stderr, "    -g          number of octets per group in normal output. Default 2.\n");
   fprintf(stderr, "    -h          print this summary.\n");
   fprintf(stderr, "    -i          output in C include file style.\n");
@@ -273,15 +274,15 @@ long base_off;
   while ((c = getc(fpi)) != EOF)
     {
       if (c == '\r')	/* Doze style input file? */
 	continue;
 
-#if 0	/* this doesn't work when there is normal text after the hex codes in
-	   the last line that looks like hex */
-      if (c == ' ' || c == '\n' || c == '\t')  /* allow multiple spaces */
+      /* Allow multiple spaces.  This doesn't work when there is normal text
+       * after the hex codes in the last line that looks like hex, thus only
+       * use it for PostScript format. */
+      if (hextype == HEX_POSTSCRIPT && (c == ' ' || c == '\n' || c == '\t'))
 	continue;
-#endif
 
       n3 = n2;
       n2 = n1;
 
       if (c >= '0' && c <= '9')
--- vim72.orig/src/os_mac.h
+++ vim72/src/os_mac.h
@@ -266,13 +266,19 @@
  * version with os_unix.x instead of os_mac.c. Based on the result
  * of ./configure for console MacOS X.
  */
 
 #ifdef MACOS_X_UNIX
-# define SIGPROTOARG	(int)
-# define SIGDEFARG(s)	(s) int s;
-# define SIGDUMMYARG	0
+# ifndef SIGPROTOARG
+#  define SIGPROTOARG	(int)
+# endif
+# ifndef SIGDEFARG
+#  define SIGDEFARG(s)	(s) int s UNUSED;
+# endif
+# ifndef SIGDUMMYARG
+#  define SIGDUMMYARG	0
+# endif
 # undef  HAVE_AVAIL_MEM
 # ifndef HAVE_CONFIG_H
 #  define RETSIGTYPE void
 #  define SIGRETURN  return
 /*# define USE_SYSTEM */  /* Output ship do debugger :(, but ot compile */
@@ -283,11 +289,10 @@
 #  define HAVE_SYS_SELECT_H 1
 #  define HAVE_PUTENV
 #  define HAVE_SETENV
 #  define HAVE_RENAME
 # endif
-# define mch_chdir(s) chdir(s)
 #endif
 
 #if defined(MACOS_X) && !defined(HAVE_CONFIG_H)
 # define HAVE_PUTENV
 #endif
--- vim72.orig/runtime/doc/autocmd.txt
+++ vim72/runtime/doc/autocmd.txt
@@ -333,10 +333,12 @@ BufDelete			Before deleting a buffer fro
 				Also used just before a buffer in the buffer
 				list is renamed.
 				NOTE: When this autocommand is executed, the
 				current buffer "%" may be different from the
 				buffer being deleted "<afile>" and "<abuf>".
+				Don't change to another buffer, it will cause
+				problems.
 							*BufEnter*
 BufEnter			After entering a buffer.  Useful for setting
 				options for a file type.  Also executed when
 				starting to edit a buffer, after the
 				BufReadPost autocommands.
@@ -395,10 +397,12 @@ BufUnload			Before unloading a buffer.
 				BufDelete.  Also used for all buffers that are
 				loaded when Vim is going to exit.
 				NOTE: When this autocommand is executed, the
 				current buffer "%" may be different from the
 				buffer being unloaded "<afile>".
+				Don't change to another buffer, it will cause
+				problems.
 							*BufWinEnter*
 BufWinEnter			After a buffer is displayed in a window.  This
 				can be when the buffer is loaded (after
 				processing the modelines) or when a hidden
 				buffer is displayed in a window (and is no
@@ -426,10 +430,12 @@ BufWipeout			Before completely deleting
 				is renamed (also when it's not in the buffer
 				list).
 				NOTE: When this autocommand is executed, the
 				current buffer "%" may be different from the
 				buffer being deleted "<afile>".
+				Don't change to another buffer, it will cause
+				problems.
 						*BufWrite* *BufWritePre*
 BufWrite or BufWritePre		Before writing the whole buffer to a file.
 							*BufWriteCmd*
 BufWriteCmd			Before writing the whole buffer to a file.
 				Should do the writing of the file and reset
@@ -746,12 +752,14 @@ SwapExists			Detected an existing swap f
 					'd'	delete the swap file
 					'q'	quit, don't edit the file
 					'a'	abort, like hitting CTRL-C
 				When set to an empty string the user will be
 				asked, as if there was no SwapExists autocmd.
-				Note: Do not try to change the buffer, the
-				results are unpredictable.
+							*E812*
+				It is not allowed to change to another buffer,
+				change a buffer name or change directory
+				here.
 							*Syntax*
 Syntax				When the 'syntax' option has been set.  The
 				pattern is matched against the syntax name.
 				<afile> can be used for the name of the file
 				where this option was set, and <amatch> for
--- vim72.orig/src/gui_photon.c
+++ vim72/src/gui_photon.c
@@ -836,11 +836,16 @@ gui_ph_handle_window_open(
 
 /* TODO: Set a clipping rect? */
     static void
 gui_ph_draw_start( void )
 {
+    PhGC_t *gc;
+
+    gc = PgGetGC();
     PgSetRegion( PtWidgetRid( PtFindDisjoint( gui.vimTextArea ) ) );
+    PgClearClippingsCx( gc );
+    PgClearTranslationCx( gc );
 
     PtWidgetOffset( gui.vimTextArea, &gui_ph_raw_offset );
     PhTranslatePoint( &gui_ph_raw_offset, PtWidgetPos( gui.vimTextArea, NULL ) );
 
     PgSetTranslation( &gui_ph_raw_offset, Pg_RELATIVE );
@@ -2968,11 +2973,11 @@ gui_mch_init_font(char_u *vim_font_name,
     PhRect_t extent;
 
     if( vim_font_name == NULL )
     {
 	/* Default font */
-	vim_font_name = "PC Term";
+	vim_font_name = "PC Terminal";
     }
 
     if( STRCMP( vim_font_name, "*" ) == 0 )
     {
 	font_tag = PtFontSelection( gui.vimWindow, NULL, NULL,
--- vim72.orig/src/proto/ui.pro
+++ vim72/src/proto/ui.pro
@@ -46,10 +46,11 @@ void ui_cursor_shape __ARGS((void));
 int check_col __ARGS((int col));
 int check_row __ARGS((int row));
 void open_app_context __ARGS((void));
 void x11_setup_atoms __ARGS((Display *dpy));
 void clip_x11_request_selection __ARGS((Widget myShell, Display *dpy, VimClipboard *cbd));
+void yank_cut_buffer0 __ARGS((Display *dpy, VimClipboard *cbd));
 void clip_x11_lose_selection __ARGS((Widget myShell, VimClipboard *cbd));
 int clip_x11_own_selection __ARGS((Widget myShell, VimClipboard *cbd));
 void clip_x11_set_selection __ARGS((VimClipboard *cbd));
 int jump_to_mouse __ARGS((int flags, int *inclusive, int which_button));
 int mouse_comp_pos __ARGS((win_T *win, int *rowp, int *colp, linenr_T *lnump));
--- vim72.orig/runtime/doc/various.txt
+++ vim72/runtime/doc/various.txt
@@ -372,10 +372,11 @@ m  *+ruby*		Ruby interface |ruby|
 m  *+ruby/dyn*		Ruby interface |ruby-dynamic| |/dyn|
 N  *+scrollbind*	|'scrollbind'|
 B  *+signs*		|:sign|
 N  *+smartindent*	|'smartindent'|
 m  *+sniff*		SniFF interface |sniff|
+N  *+startuptime*	|--startuptime| argument
 N  *+statusline*	Options 'statusline', 'rulerformat' and special
 			formats of 'titlestring' and 'iconstring'
 m  *+sun_workshop*	|workshop|
 N  *+syntax*		Syntax highlighting |syntax|
    *+system()*		Unix only: opposite of |+fork|
@@ -506,10 +507,21 @@ N  *+X11*		Unix only: can restore window
 			":silent menu ..." defines a menu that will not echo a
 			Command-line command.  The command will still produce
 			messages though.  Use ":silent" in the command itself
 			to avoid that: ":silent menu .... :silent command".
 
+						*:uns* *:unsilent*
+:uns[ilent] {command}	Execute {command} not silently.  Only makes a
+			difference when |:silent| was used to get to this
+			command.
+			Use this for giving a message even when |:silent| was
+			used.  In this example |:silent| is used to avoid the
+			message about reading the file and |:unsilent| to be
+			able to list the first line of each file. >
+    		:silent argdo unsilent echo expand('%') . ": " . getline(1)
+<
+
 						*:verb* *:verbose*
 :[count]verb[ose] {command}
 			Execute {command} with 'verbose' set to [count].  If
 			[count] is omitted one is used. ":0verbose" can be
 			used to set 'verbose' to zero.
--- vim72.orig/src/proto/os_unix.pro
+++ vim72/src/proto/os_unix.pro
@@ -1,6 +1,7 @@
 /* os_unix.c */
+int mch_chdir __ARGS((char *path));
 void mch_write __ARGS((char_u *s, int len));
 int mch_inchar __ARGS((char_u *buf, int maxlen, long wtime, int tb_change_cnt));
 int mch_char_avail __ARGS((void));
 long_u mch_total_mem __ARGS((int special));
 void mch_delay __ARGS((long msec, int ignoreinput));
--- vim72.orig/src/os_msdos.c
+++ vim72/src/os_msdos.c
@@ -2037,10 +2037,16 @@ mch_has_wildcard(char_u *p)
     int
 mch_chdir(char *path)
 {
     if (path[0] == NUL)		    /* just checking... */
 	return 0;
+    if (p_verbose >= 5)
+    {
+	verbose_enter();
+	smsg((char_u *)"chdir(%s)", path);
+	verbose_leave();
+    }
     if (path[1] == ':')		    /* has a drive name */
     {
 	if (change_drive(TOLOWER_ASC(path[0]) - 'a' + 1))
 	    return -1;		    /* invalid drive name */
 	path += 2;
--- vim72.orig/src/os_riscos.c
+++ vim72/src/os_riscos.c
@@ -1201,10 +1201,16 @@ mch_chdir(dir)
 {
     int	    length;
     int	    retval;
     char_u  *new_dir;
 
+    if (p_verbose >= 5)
+    {
+	verbose_enter();
+	smsg((char_u *)"chdir(%s)", dir);
+	verbose_leave();
+    }
     length = strlen(dir);
     if (dir[length - 1] != '.')
 	return chdir(dir);	    /* No trailing dots - nothing to do. */
     new_dir = vim_strsave(dir);
     if (new_dir == NULL)
--- vim72.orig/src/Make_cyg.mak
+++ vim72/src/Make_cyg.mak
@@ -1,8 +1,8 @@
 #
 # Makefile for VIM on Win32, using Cygnus gcc
-# Last updated by Dan Sharp.  Last Change: 2007 Sep 29
+# Last updated by Dan Sharp.  Last Change: 2010 Feb 24
 #
 # Also read INSTALLpc.txt!
 #
 # This compiles Vim as a Windows application.  If you want Vim to run as a
 # Cygwin application use the Makefile (just like on Unix).
@@ -30,13 +30,16 @@
 # IME		no or yes: set to yes to include IME support (yes)
 #   DYNAMIC_IME no or yes: set to yes to load imm32.dll dynamically (yes)
 # OLE		no or yes: set to yes to make OLE gvim (no)
 # DEBUG		no or yes: set to yes if you wish a DEBUGging build (no)
 # CPUNR		No longer supported, use ARCH.
-# ARCH		i386 through pentium4: select -march argument to compile with (i386)
+# ARCH		i386 through pentium4: select -march argument to compile with
+#               (i386)
 # USEDLL	no or yes: set to yes to use the Runtime library DLL (no)
 #		For USEDLL=yes the cygwin1.dll is required to run Vim.
+#		"no" does not work with latest version of Cygwin, use
+#		Make_ming.mak instead.  Or set CC to gcc-3.
 # POSTSCRIPT	no or yes: set to yes for PostScript printing (no)
 # FEATURES	TINY, SMALL, NORMAL, BIG or HUGE (BIG)
 # WINVER	Lowest Win32 version to support.  (0x0400)
 # CSCOPE	no or yes: to include cscope interface support (yes)
 # OPTIMIZE	SPACE, SPEED, or MAXSPEED: set optimization level (MAXSPEED)
@@ -97,10 +100,11 @@ endif
 DEFINES = -DWIN32 -DHAVE_PATHDEF -DFEAT_$(FEATURES) \
 	  -DWINVER=$(WINVER) -D_WIN32_WINNT=$(WINVER)
 INCLUDES = -march=$(ARCH) -Iproto
 
 #>>>>> name of the compiler and linker, name of lib directory
+CROSS_COMPILE =
 CC = gcc
 RC = windres
 
 ##############################
 # DYNAMIC_PERL=yes and no both work
@@ -210,17 +214,38 @@ endif
 
 ifndef MZSCHEME_VER
 MZSCHEME_VER = 209_000
 endif
 
+ifndef MZSCHEME_PRECISE_GC
+MZSCHEME_PRECISE_GC=no
+endif
+
+# for version 4.x we need to generate byte-code for Scheme base
+ifndef MZSCHEME_GENERATE_BASE
+MZSCHEME_GENERATE_BASE=no
+endif
+
 ifeq (yes, $(DYNAMIC_MZSCHEME))
 DEFINES += -DDYNAMIC_MZSCHEME -DDYNAMIC_MZSCH_DLL=\"libmzsch$(MZSCHEME_VER).dll\" -DDYNAMIC_MZGC_DLL=\"libmzgc$(MZSCHEME_VER).dll\"
 else
 ifndef MZSCHEME_DLLS
 MZSCHEME_DLLS = $(MZSCHEME)
 endif
-EXTRA_LIBS += -L$(MZSCHEME_DLLS) -lmzsch$(MZSCHEME_VER) -lmzgc$(MZSCHEME_VER)
+ifeq (yes,$(MZSCHEME_PRECISE_GC))
+MZSCHEME_LIB=-lmzsch$(MZSCHEME_VER)
+else
+MZSCHEME_LIB = -lmzsch$(MZSCHEME_VER) -lmzgc$(MZSCHEME_VER)
+endif
+EXTRA_LIBS += -L$(MZSCHEME_DLLS) -L$(MZSCHEME_DLLS)/lib $(MZSCHEME_LIB)
+endif
+ifeq (yes,$(MZSCHEME_GENERATE_BASE))
+DEFINES += -DINCLUDE_MZSCHEME_BASE
+MZ_EXTRA_DEP += mzscheme_base.c
+endif
+ifeq (yes,$(MZSCHEME_PRECISE_GC))
+DEFINES += -DMZ_PRECISE_GC
 endif
 endif
 
 ##############################
 # DYNAMIC_TCL=yes and no both work.
@@ -444,14 +469,14 @@ all: $(EXE) xxd/xxd.exe vimrun.exe insta
 # See /usr/doc/cygwin-doc-1.2/html/faq_toc.html#TOC93 for more information.
 $(EXE): $(OUTDIR) $(OBJ)
 	$(CC) $(CFLAGS) -o $(EXE) $(OBJ) $(LIBS) -luuid -lole32 $(EXTRA_LIBS)
 
 xxd/xxd.exe: xxd/xxd.c
-	$(MAKE) -C xxd -f Make_cyg.mak USEDLL=$(USEDLL)
+	$(MAKE) -C xxd -f Make_cyg.mak CC=$(CC) USEDLL=$(USEDLL)
 
 GvimExt/gvimext.dll: GvimExt/gvimext.cpp GvimExt/gvimext.rc GvimExt/gvimext.h
-	$(MAKE) -C GvimExt -f Make_ming.mak
+	$(MAKE) -C GvimExt -f Make_ming.mak CROSS_COMPILE=$(CROSS_COMPILE)
 
 vimrun.exe: vimrun.c
 	$(CC) $(CFLAGS) -o vimrun.exe vimrun.c  $(LIBS)
 
 install.exe: dosinst.c
@@ -471,10 +496,13 @@ clean:
 	-rmdir $(OUTDIR)
 	-$(DEL) $(EXE) vimrun.exe install.exe uninstal.exe
 ifdef PERL
 	-$(DEL) if_perl.c
 endif
+ifdef MZSCHEME
+	-$(DEL) mzscheme_base.c
+endif
 	-$(DEL) pathdef.c
 	$(MAKE) -C xxd -f Make_cyg.mak clean
 	$(MAKE) -C GvimExt -f Make_ming.mak clean
 
 distclean: clean
@@ -521,13 +549,19 @@ ifeq (16, $(RUBY_VER))
 endif
 
 $(OUTDIR)/netbeans.o:	netbeans.c $(INCL) $(NBDEBUG_DEP)
 	$(CC) -c $(CFLAGS) netbeans.c -o $(OUTDIR)/netbeans.o
 
+$(OUTDIR)/if_mzsch.o:	if_mzsch.c $(INCL) if_mzsch.h $(MZ_EXTRA_DEP)
+	$(CC) -c $(CFLAGS) if_mzsch.c -o $(OUTDIR)/if_mzsch.o
+
 $(OUTDIR)/vimrc.o:	vim.rc version.h gui_w32_rc.h
 	$(RC) $(RCFLAGS) vim.rc -o $(OUTDIR)/vimrc.o
 
+mzscheme_base.c:
+	$(MZSCHEME)/mzc --c-mods mzscheme_base.c ++lib scheme/base
+
 pathdef.c: $(INCL)
 ifneq (sh.exe, $(SHELL))
 	@echo creating pathdef.c
 	@echo '/* pathdef.c */' > pathdef.c
 	@echo '#include "vim.h"' >> pathdef.c
--- vim72.orig/src/po/check.vim
+++ vim72/src/po/check.vim
@@ -21,10 +21,13 @@ func! GetMline()
   endwhile
 
   " remove '%', not used for formatting.
   let idline = substitute(idline, "'%'", '', 'g')
 
+  " remove '%' used for plural forms.
+  let idline = substitute(idline, '\\nPlural-Forms: .\+;\\n', '', '')
+
   " remove everything but % items.
   return substitute(idline, '[^%]*\(%[-+ #''.0-9*]*l\=[dsuxXpoc%]\)\=', '\1', 'g')
 endfunc
 
 " Start at the first "msgid" line.
--- vim72.orig/src/GvimExt/gvimext.cpp
+++ vim72/src/GvimExt/gvimext.cpp
@@ -633,11 +633,13 @@ STDMETHODIMP CShellExt::QueryContextMenu
 		--pos;
 	    *pos = 0;
 	}
 	// Now concatenate
 	strncpy(temp, _("Edit with existing Vim - "), BUFSIZE - 1);
-	strncat(temp, title, BUFSIZE - 1);
+	temp[BUFSIZE - 1] = '\0';
+	strncat(temp, title, BUFSIZE - 1 - strlen(temp));
+	temp[BUFSIZE - 1] = '\0';
 	InsertMenu(hMenu,
 		indexMenu++,
 		MF_STRING|MF_BYPOSITION,
 		idCmd++,
 		temp);
--- /dev/null
+++ vim72/src/testdir/test67.in
@@ -0,0 +1,33 @@
+Test that groups and patterns are tested correctly when calling exists() for
+autocommands.
+
+STARTTEST
+:so small.vim
+:let results=[]
+:augroup auexists
+:augroup END
+:call add(results, "##BufEnter: " . exists("##BufEnter"))
+:call add(results, "#BufEnter: " . exists("#BufEnter"))
+:au BufEnter * let g:entered=1
+:call add(results, "#BufEnter: " . exists("#BufEnter"))
+:call add(results, "#auexists#BufEnter: " . exists("#auexists#BufEnter"))
+:augroup auexists
+:au BufEnter * let g:entered=1
+:augroup END
+:call add(results, "#auexists#BufEnter: " . exists("#auexists#BufEnter"))
+:call add(results, "#BufEnter#*.test: " . exists("#BufEnter#*.test"))
+:au BufEnter *.test let g:entered=1
+:call add(results, "#BufEnter#*.test: " . exists("#BufEnter#*.test"))
+:edit testfile.test
+:call add(results, "#BufEnter#<buffer>: " . exists("#BufEnter#<buffer>"))
+:au BufEnter <buffer> let g:entered=1
+:call add(results, "#BufEnter#<buffer>: " . exists("#BufEnter#<buffer>"))
+:edit testfile2.test
+:call add(results, "#BufEnter#<buffer>: " . exists("#BufEnter#<buffer>"))
+:e test.out
+:call append(0, results)
+:$d
+:w
+:qa!
+ENDTEST
+
--- /dev/null
+++ vim72/src/testdir/test67.ok
@@ -0,0 +1,10 @@
+##BufEnter: 1
+#BufEnter: 0
+#BufEnter: 1
+#auexists#BufEnter: 0
+#auexists#BufEnter: 1
+#BufEnter#*.test: 0
+#BufEnter#*.test: 1
+#BufEnter#<buffer>: 0
+#BufEnter#<buffer>: 1
+#BufEnter#<buffer>: 0
--- vim72.orig/src/proto/gui_gtk_x11.pro
+++ vim72/src/proto/gui_gtk_x11.pro
@@ -14,10 +14,12 @@ void gui_mch_forked __ARGS((void));
 void gui_mch_new_colors __ARGS((void));
 int gui_mch_open __ARGS((void));
 void gui_mch_exit __ARGS((int rc));
 int gui_mch_get_winpos __ARGS((int *x, int *y));
 void gui_mch_set_winpos __ARGS((int x, int y));
+int gui_mch_maximized __ARGS((void));
+void gui_mch_unmaximize __ARGS((void));
 void gui_mch_set_shellsize __ARGS((int width, int height, int min_width, int min_height, int base_width, int base_height, int direction));
 void gui_mch_get_screen_dimensions __ARGS((int *screen_w, int *screen_h));
 void gui_mch_settitle __ARGS((char_u *title, char_u *icon));
 void gui_mch_enable_menu __ARGS((int showit));
 void gui_mch_show_toolbar __ARGS((int showit));
--- vim72.orig/runtime/doc/map.txt
+++ vim72/runtime/doc/map.txt
@@ -222,10 +222,14 @@ define a new mapping or abbreviation, th
 expression is evaluated to obtain the {rhs} that is used.  Example: >
 	:inoremap <expr> . InsertDot()
 The result of the InsertDot() function will be inserted.  It could check the
 text before the cursor and start omni completion when some condition is met.
 
+For abbreviations |v:char| is set to the character that was typed to trigger
+the abbreviation.  You can use this to decide how to expand the {lhs}.  You
+can't change v:char and you should not insert it.
+
 Be very careful about side effects!  The expression is evaluated while
 obtaining characters, you may very well make the command dysfunctional.
 For this reason the following is blocked:
 - Changing the buffer text |textlock|.
 - Editing another buffer.
--- vim72.orig/src/testdir/test45.in
+++ vim72/src/testdir/test45.in
@@ -26,13 +26,20 @@ kYpj:call append("$", foldlevel("."))
 /^2 b
 i  jI    :call append("$", "indent " . foldlevel("."))
 k:call append("$", foldlevel("."))
 :" test syntax folding
 :set fdm=syntax fdl=0
-:syn region Hup start="dd" end="hh" fold
+:syn region Hup start="dd" end="ii" fold contains=Fd1,Fd2,Fd3
+:syn region Fd1 start="ee" end="ff" fold contained
+:syn region Fd2 start="gg" end="hh" fold contained
+:syn region Fd3 start="commentstart" end="commentend" fold contained
 Gzk:call append("$", "folding " . getline("."))
 k:call append("$", getline("."))
+jAcommentstart  Acommentend:set fdl=1
+3j:call append("$", getline("."))
+:set fdl=0
+zOj:call append("$", getline("."))
 :" test expression folding
 :fun Flvl()
   let l = getline(v:lnum)
   if l =~ "bb$"
     return 2
--- vim72.orig/src/testdir/test45.ok
+++ vim72/src/testdir/test45.ok
@@ -6,11 +6,13 @@ marker 2
 1
 1
 0
 indent 2
 1
-folding 8 hh
+folding 9 ii
     3 cc
+7 gg
+8 hh
 expr 2
 1
 2
 0
--- vim72.orig/src/memfile.c
+++ vim72/src/memfile.c
@@ -1341,10 +1341,15 @@ mf_do_open(mfp, fname, flags)
 	mfp->mf_fname = NULL;
 	mfp->mf_ffname = NULL;
     }
     else
     {
+#ifdef HAVE_FD_CLOEXEC
+	int fdflags = fcntl(mfp->mf_fd, F_GETFD);
+	if (fdflags >= 0 && (fdflags & FD_CLOEXEC) == 0)
+	    fcntl(mfp->mf_fd, F_SETFD, fdflags | FD_CLOEXEC);
+#endif
 #ifdef HAVE_SELINUX
 	mch_copy_sec(fname, mfp->mf_fname);
 #endif
 	mch_hide(mfp->mf_fname);    /* try setting the 'hidden' flag */
     }
--- /dev/null
+++ vim72/src/testdir/test68.in
@@ -0,0 +1,56 @@
+Test for text formatting.
+
+Results of test68:
+
+STARTTEST
+:so small.vim
+/^{/+1
+:set noai tw=2 fo=t
+gRa b
+ENDTEST
+
+{
+
+
+}
+
+STARTTEST
+/^{/+1
+:set ai tw=2 fo=tw
+gqgqjjllab
+ENDTEST
+
+{
+a  b
+
+a
+}
+
+STARTTEST
+/^{/+1
+:set tw=3 fo=t
+gqgqo
+a 
+ENDTEST
+
+{
+a 
+}
+
+STARTTEST
+/^{/+1
+:set tw=2 fo=tcq1 comments=:#
+gqgqjgqgqo
+a b
+#a b
+ENDTEST
+
+{
+a b
+#a b
+}
+
+STARTTEST
+:g/^STARTTEST/.,/^ENDTEST/d
+:1;/^Results/,$wq! test.out
+ENDTEST
--- /dev/null
+++ vim72/src/testdir/test68.ok
@@ -0,0 +1,35 @@
+Results of test68:
+
+
+{
+a
+b
+}
+
+
+{
+a
+b
+
+a
+b
+}
+
+
+{
+a
+
+
+a
+
+}
+
+
+{
+a b
+#a b
+
+a b
+#a b
+}
+
--- /dev/null
+++ vim72/src/testdir/test69.in
@@ -0,0 +1,139 @@
+Test for multi-byte text formatting.
+
+STARTTEST
+:so mbyte.vim
+:set encoding=utf-8
+ENDTEST
+
+Results of test69:
+
+STARTTEST
+/^{/+1
+:set tw=2 fo=t
+gqgqjgqgqo
+
+abc 
+ENDTEST
+
+{
+
+abc 
+}
+
+STARTTEST
+/^{/+1
+:set tw=1 fo=tm
+gqgqjgqgqjgqgqjgqgqjgqgqo
+
+a
+ a
+
+ 
+ENDTEST
+
+{
+
+a
+ a
+
+ 
+}
+
+STARTTEST
+/^{/+1
+:set tw=2 fo=tm
+gqgqjgqgqjgqgqjgqgqjgqgqjgqgqjgqgqjgqgqjgqgqjgqgqo
+
+a
+ a
+
+ 
+a
+ab
+abc
+ab c
+ab
+ENDTEST
+
+{
+
+a
+ a
+
+ 
+a
+ab
+abc
+ab c
+ab
+}
+
+STARTTEST
+/^{/+1
+:set ai tw=2 fo=tm
+gqgqjgqgqo
+
+a
+ENDTEST
+
+{
+  
+  a
+}
+
+STARTTEST
+/^{/+1
+:set noai tw=2 fo=tm
+gqgqjgqgqo
+  
+  a
+ENDTEST
+
+{
+  
+  a
+}
+
+STARTTEST
+/^{/+1
+:set tw=2 fo=cqm comments=n:
+gqgqjgqgqjgqgqjgqgqjgqgqjgqgqjgqgqjgqgqjgqgqjgqgqo
+
+a
+a
+
+
+ 
+ 
+
+a
+
+ENDTEST
+
+{
+
+a
+a
+
+
+ 
+ 
+
+a
+
+}
+
+STARTTEST
+/^{/+1
+:set tw=2 fo=tm
+Ra
+ENDTEST
+
+{
+
+}
+
+STARTTEST
+:g/^STARTTEST/.,/^ENDTEST/d
+:1;/^Results/,$wq! test.out
+ENDTEST
--- /dev/null
+++ vim72/src/testdir/test69.ok
@@ -0,0 +1,142 @@
+Results of test69:
+
+
+{
+
+abc
+
+
+
+abc
+
+}
+
+
+{
+
+
+a
+
+a
+
+
+
+
+
+
+
+a
+
+a
+
+
+
+
+}
+
+
+{
+
+
+a
+
+a
+
+
+
+
+a
+
+ab
+
+abc
+
+ab
+
+c
+ab
+
+
+
+
+
+a
+
+a
+
+
+
+
+a
+
+ab
+
+abc
+
+ab
+
+c
+ab
+
+
+}
+
+
+{
+  
+  
+  a
+
+  
+  
+  a
+}
+
+
+{
+  
+  
+a
+
+  
+  
+a
+}
+
+
+{
+
+a
+a
+
+
+
+
+ 
+ 
+ 
+
+a
+
+
+
+a
+a
+
+
+
+
+ 
+ 
+ 
+
+a
+
+}
+
+
+{
+
+a
+}
+
--- vim72.orig/runtime/filetype.vim
+++ vim72/runtime/filetype.vim
@@ -2398,22 +2398,24 @@ au BufNewFile,BufRead /etc/xinetd.d/*		c
 
 " Z-Shell script
 au BufNewFile,BufRead zsh*,zlog*		call s:StarSetf('zsh')
 
 
+
+" Use the filetype detect plugins.  They may overrule any of the previously
+" detected filetypes.
+runtime! ftdetect/*.vim
+
+
 " Generic configuration file (check this last, it's just guessing!)
 au BufNewFile,BufRead,StdinReadPost *
 	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
 	\    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'
 	\	|| getline(4) =~ '^#' || getline(5) =~ '^#') |
 	\   setf conf |
 	\ endif
 
-" Use the plugin-filetype checks last, they may overrule any of the previously
-" detected filetypes.
-runtime! ftdetect/*.vim
-
 augroup END
 
 
 " If the GUI is already running, may still need to install the Syntax menu.
 " Don't do it when the 'M' flag is included in 'guioptions'.
--- vim72.orig/src/proto/misc1.pro
+++ vim72/src/proto/misc1.pro
@@ -83,10 +83,11 @@ int get_lisp_indent __ARGS((void));
 void prepare_to_exit __ARGS((void));
 void preserve_exit __ARGS((void));
 int vim_fexists __ARGS((char_u *fname));
 void line_breakcheck __ARGS((void));
 void fast_breakcheck __ARGS((void));
+int expand_wildcards_eval __ARGS((char_u **pat, int *num_file, char_u ***file, int flags));
 int expand_wildcards __ARGS((int num_pat, char_u **pat, int *num_file, char_u ***file, int flags));
 int match_suffix __ARGS((char_u *fname));
 int unix_expandpath __ARGS((garray_T *gap, char_u *path, int wildoff, int flags, int didstar));
 int gen_expand_wildcards __ARGS((int num_pat, char_u **pat, int *num_file, char_u ***file, int flags));
 void addfile __ARGS((garray_T *gap, char_u *f, int flags));
--- vim72.orig/src/integration.c
+++ vim72/src/integration.c
@@ -76,11 +76,11 @@
 # define NOCATGETS(x) x
 #endif
 
 /* Functions private to this file */
 static void workshop_connection_closed(void);
-static void messageFromEserve(XtPointer clientData, int *NOTUSED1, XtInputId *NOTUSED2);
+static void messageFromEserve(XtPointer clientData, int *dum1, XtInputId *dum2);
 static void workshop_disconnect(void);
 static void workshop_sensitivity(int num, char *table);
 static void adjust_sign_name(char *filename);
 static void process_menuItem(char *);
 static void process_toolbarButton(char *);
@@ -155,13 +155,14 @@ getCommand(void)
 		return NULL;
 	}
 
 }
 
-/*ARGSUSED*/
 void
-messageFromEserve(XtPointer clientData, int *NOTUSED1, XtInputId *NOTUSED2)
+messageFromEserve(XtPointer clientData UNUSED,
+		  int *dum1 UNUSED,
+		  XtInputId *dum2 UNUSED)
 {
 	char	*cmd;		/* the 1st word of the command */
 
 	cmd = getCommand();
 	if (cmd == NULL) {
@@ -197,11 +198,11 @@ messageFromEserve(XtPointer clientData,
 				color++;
 			}
 			if (sign) {
 				sign++;
 			}
-			/* Change sign name to accomodate a different size? */
+			/* Change sign name to accommodate a different size? */
 			adjust_sign_name(sign);
 			workshop_add_mark_type(idx, color, sign);
 		}
 		HANDLE_ERRORS(cmd);
 		break;
@@ -578,11 +579,11 @@ unrecognised_message(
 	/* abort(); */
 }
 #endif
 
 
-/* Change sign name to accomodate a different size:
+/* Change sign name to accommodate a different size:
  * Create the filename based on the height. The filename format
  * of multisize icons are:
  *    x.xpm   : largest icon
  *    x1.xpm  : smaller icon
  *    x2.xpm  : smallest icon */
@@ -612,10 +613,11 @@ adjust_sign_name(char *filename)
 		strcpy(s, "1.xpm");
 	else
 		strcpy(s, ".xpm");
 }
 
+#if 0
 /* Were we invoked by WorkShop? This function can be used early during startup
    if you want to do things differently if the editor is started standalone
    or in WorkShop mode. For example, in standalone mode you may not want to
    add a footer/message area or a sign gutter. */
 int
@@ -625,10 +627,11 @@ workshop_invoked()
 	if (result == -1) {
 		result = (getenv(NOCATGETS("SPRO_EDITOR_SOCKET")) != NULL);
 	}
 	return result;
 }
+#endif
 
 /* Connect back to eserve */
 void	workshop_connect(XtAppContext context)
 {
 #ifdef INET_SOCKETS
@@ -748,10 +751,11 @@ void	workshop_disconnect()
 
 /*
  * Utility functions
  */
 
+#if 0
 /* Set icon for the window */
 void
 workshop_set_icon(Display *display, Widget shell, char **xpmdata,
 		  int width, int height)
 {
@@ -791,10 +795,11 @@ workshop_set_icon(Display *display, Widg
 		XtVaSetValues(shell,
 		    XtNiconWindow, iconWindow, NULL);
 	}
 	XtFree((char *)xpmAttributes.colorsymbols);
 }
+#endif
 
 /* Minimize and maximize shells. From libutil's shell.cc. */
 
 /* utility functions from libutil's shell.cc */
 static Boolean
@@ -925,11 +930,11 @@ Boolean workshop_get_width_height(int *w
 		*height = hgt;
 	}
 	return success;
 }
 
-
+#if 0
 Boolean workshop_get_rows_cols(int *rows, int *cols)
 {
 	static int	r = 0;
 	static int	c = 0;
 	static Boolean	firstTime = True;
@@ -956,10 +961,11 @@ Boolean workshop_get_rows_cols(int *rows
 		*rows = r;
 		*cols = c;
 	}
 	return success;
 }
+#endif
 
 /*
  * Toolbar code
  */
 
@@ -1041,23 +1047,23 @@ void workshop_set_option_first(char *nam
 		workshop_set_option(name, value);
 	}
 }
 
 
-
+#if 0
 /*
  * Send information to eserve on certain editor events
  * You must make sure these are called when necessary
  */
-
 void workshop_file_closed(char *filename)
 {
 	char buffer[2*MAXPATHLEN];
 	vim_snprintf(buffer, sizeof(buffer),
 			NOCATGETS("deletedFile %s\n"), filename);
 	write(sd, buffer, strlen(buffer));
 }
+#endif
 
 void workshop_file_closed_lineno(char *filename, int lineno)
 {
 	char buffer[2*MAXPATHLEN];
 	vim_snprintf(buffer, sizeof(buffer),
@@ -1084,25 +1090,27 @@ void workshop_file_saved(char *filename)
 	/* Let editor report any moved marks that the eserve client
 	 * should deal with (for example, moving location-based breakpoints) */
 	workshop_moved_marks(filename);
 }
 
-void workshop_move_mark(char *filename, int markId, int newLineno)
+#if 0
+void workshop_file_modified(char *filename)
 {
 	char buffer[2*MAXPATHLEN];
 	vim_snprintf(buffer, sizeof(buffer),
-			NOCATGETS("moveMark %s %d %d\n"), filename, markId, newLineno);
+			NOCATGETS("modifiedFile %s\n"), filename);
 	write(sd, buffer, strlen(buffer));
 }
 
-void workshop_file_modified(char *filename)
+void workshop_move_mark(char *filename, int markId, int newLineno)
 {
 	char buffer[2*MAXPATHLEN];
 	vim_snprintf(buffer, sizeof(buffer),
-			NOCATGETS("modifiedFile %s\n"), filename);
+	       NOCATGETS("moveMark %s %d %d\n"), filename, markId, newLineno);
 	write(sd, buffer, strlen(buffer));
 }
+#endif
 
 void workshop_frame_moved(int new_x, int new_y, int new_w, int new_h)
 {
 	char buffer[200];
 
@@ -1177,14 +1185,16 @@ void workshop_perform_verb(char *verb, v
 		}
 	}
 }
 
 /* Send a message to eserve */
+#if defined(NOHANDS_SUPPORT_FUNCTIONS) || defined(FEAT_BEVAL)
 void workshop_send_message(char *buf)
 {
 	write(sd, buf, strlen(buf));
 }
+#endif
 
 /* Some methods, like currentFile, cursorPos, etc. are missing here.
  * But it looks like these are used for NoHands testing only so we
  * won't bother requiring editors to implement these
  */
--- vim72.orig/runtime/tools/README.txt
+++ vim72/runtime/tools/README.txt
@@ -30,6 +30,8 @@ vim_vs_net.cmd: MS-Windows command file
 		later.
 
 xcmdsrv_client.c:  Example for a client program that communicates with a Vim
 		   server through the X-Windows interface.
 
+unicode.vim	Vim script to generate tables for src/mbyte.c.
+
 [xxd (and tee for OS/2) can be found in the src directory]
--- /dev/null
+++ vim72/runtime/tools/unicode.vim
@@ -0,0 +1,290 @@
+" Script to extract tables from Unicode .txt files, to be used in src/mbyte.c.
+" The format of the UnicodeData.txt file is explained here:
+" http://www.unicode.org/Public/5.1.0/ucd/UCD.html
+" For the other files see the header.
+"
+" Usage: Vim -S <this-file>
+"
+" Author: Bram Moolenaar
+" Last Update: 2010 Jan 12
+
+" Parse lines of UnicodeData.txt.  Creates a list of lists in s:dataprops.
+func! ParseDataToProps()
+  let s:dataprops = []
+  let lnum = 1
+  while lnum <= line('$')
+    let l = split(getline(lnum), '\s*;\s*', 1)
+    if len(l) != 15
+      echoerr 'Found ' . len(l) . ' items in line ' . lnum . ', expected 15'
+      return
+    endif
+    call add(s:dataprops, l)
+    let lnum += 1
+  endwhile
+endfunc
+
+" Parse lines of CaseFolding.txt.  Creates a list of lists in s:foldprops.
+func! ParseFoldProps()
+  let s:foldprops = []
+  let lnum = 1
+  while lnum <= line('$')
+    let line = getline(lnum)
+    if line !~ '^#' && line !~ '^\s*$'
+      let l = split(line, '\s*;\s*', 1)
+      if len(l) != 4
+	echoerr 'Found ' . len(l) . ' items in line ' . lnum . ', expected 4'
+	return
+      endif
+      call add(s:foldprops, l)
+    endif
+    let lnum += 1
+  endwhile
+endfunc
+
+" Parse lines of EastAsianWidth.txt.  Creates a list of lists in s:widthprops.
+func! ParseWidthProps()
+  let s:widthprops = []
+  let lnum = 1
+  while lnum <= line('$')
+    let line = getline(lnum)
+    if line !~ '^#' && line !~ '^\s*$'
+      let l = split(line, '\s*;\s*', 1)
+      if len(l) != 2
+	echoerr 'Found ' . len(l) . ' items in line ' . lnum . ', expected 2'
+	return
+      endif
+      call add(s:widthprops, l)
+    endif
+    let lnum += 1
+  endwhile
+endfunc
+
+" Build the toLower or toUpper table in a new buffer.
+" Uses s:dataprops.
+func! BuildCaseTable(name, index)
+  let start = -1
+  let end = -1
+  let step = 0
+  let add = -1
+  let ranges = []
+  for p in s:dataprops
+    if p[a:index] != ''
+      let n = ('0x' . p[0]) + 0
+      let nl = ('0x' . p[a:index]) + 0
+      if start >= 0 && add == nl - n && (step == 0 || n - end == step)
+	" continue with same range.
+	let step = n - end
+	let end = n
+      else
+	if start >= 0
+	  " produce previous range
+	  call Range(ranges, start, end, step, add)
+	endif
+	let start = n
+	let end = n
+	let step = 0
+	let add = nl - n
+      endif
+    endif
+  endfor
+  if start >= 0
+    call Range(ranges, start, end, step, add)
+  endif
+
+  " New buffer to put the result in.
+  new
+  exe "file to" . a:name
+  call setline(1, "static convertStruct to" . a:name . "[] =")
+  call setline(2, "{")
+  call append('$', ranges)
+  call setline('$', getline('$')[:-2])  " remove last comma
+  call setline(line('$') + 1, "};")
+  wincmd p
+endfunc
+
+" Build the foldCase table in a new buffer.
+" Uses s:foldprops.
+func! BuildFoldTable()
+  let start = -1
+  let end = -1
+  let step = 0
+  let add = -1
+  let ranges = []
+  for p in s:foldprops
+    if p[1] == 'C' || p[1] == 'S'
+      let n = ('0x' . p[0]) + 0
+      let nl = ('0x' . p[2]) + 0
+      if start >= 0 && add == nl - n && (step == 0 || n - end == step)
+	" continue with same range.
+	let step = n - end
+	let end = n
+      else
+	if start >= 0
+	  " produce previous range
+	  call Range(ranges, start, end, step, add)
+	endif
+	let start = n
+	let end = n
+	let step = 0
+	let add = nl - n
+      endif
+    endif
+  endfor
+  if start >= 0
+    call Range(ranges, start, end, step, add)
+  endif
+
+  " New buffer to put the result in.
+  new
+  file foldCase
+  call setline(1, "static convertStruct foldCase[] =")
+  call setline(2, "{")
+  call append('$', ranges)
+  call setline('$', getline('$')[:-2])  " remove last comma
+  call setline(line('$') + 1, "};")
+  wincmd p
+endfunc
+
+func! Range(ranges, start, end, step, add)
+  let s = printf("\t{0x%x,0x%x,%d,%d},", a:start, a:end, a:step == 0 ? -1 : a:step, a:add)
+  call add(a:ranges, s)
+endfunc
+
+" Build the combining table.
+" Uses s:dataprops.
+func! BuildCombiningTable()
+  let start = -1
+  let end = -1
+  let ranges = []
+  for p in s:dataprops
+    if p[2] == 'Mn' || p[2] == 'Mc' || p[2] == 'Me'
+      let n = ('0x' . p[0]) + 0
+      if start >= 0 && end + 1 == n
+	" continue with same range.
+	let end = n
+      else
+	if start >= 0
+	  " produce previous range
+	  call add(ranges, printf("\t{0x%04x, 0x%04x},", start, end))
+	endif
+	let start = n
+	let end = n
+      endif
+    endif
+  endfor
+  if start >= 0
+    call add(ranges, printf("\t{0x%04x, 0x%04x},", start, end))
+  endif
+
+  " New buffer to put the result in.
+  new
+  file combining
+  call setline(1, "    static struct interval combining[] =")
+  call setline(2, "    {")
+  call append('$', ranges)
+  call setline('$', getline('$')[:-2])  " remove last comma
+  call setline(line('$') + 1, "    };")
+  wincmd p
+endfunc
+
+" Build the double width or ambiguous width table in a new buffer.
+" Uses s:widthprops and s:dataprops.
+func! BuildWidthTable(pattern, tableName)
+  let start = -1
+  let end = -1
+  let ranges = []
+  let dataidx = 0
+  for p in s:widthprops
+    if p[1][0] =~ a:pattern
+      if p[0] =~ '\.\.'
+	" It is a range.  we don't check for composing char then.
+	let rng = split(p[0], '\.\.')
+	if len(rng) != 2
+	  echoerr "Cannot parse range: '" . p[0] . "' in width table"
+	endif
+	let n = ('0x' . rng[0]) + 0
+	let n_last =  ('0x' . rng[1]) + 0
+      else
+	let n = ('0x' . p[0]) + 0
+	let n_last = n
+      endif
+      " Find this char in the data table.
+      while 1
+	let dn = ('0x' . s:dataprops[dataidx][0]) + 0
+	if dn >= n
+	  break
+	endif
+	let dataidx += 1
+      endwhile
+      if dn != n && n_last == n
+	echoerr "Cannot find character " . n . " in data table"
+      endif
+      " Only use the char when it's not a composing char.
+      " But use all chars from a range.
+      let dp = s:dataprops[dataidx]
+      if n_last > n || (dp[2] != 'Mn' && dp[2] != 'Mc' && dp[2] != 'Me')
+	if start >= 0 && end + 1 == n
+	  " continue with same range.
+	else
+	  if start >= 0
+	    " produce previous range
+	    call add(ranges, printf("\t{0x%04x, 0x%04x},", start, end))
+	  endif
+	  let start = n
+	endif
+	let end = n_last
+      endif
+    endif
+  endfor
+  if start >= 0
+    call add(ranges, printf("\t{0x%04x, 0x%04x},", start, end))
+  endif
+
+  " New buffer to put the result in.
+  new
+  exe "file " . a:tableName
+  call setline(1, "    static struct interval " . a:tableName . "[] =")
+  call setline(2, "    {")
+  call append('$', ranges)
+  call setline('$', getline('$')[:-2])  " remove last comma
+  call setline(line('$') + 1, "    };")
+  wincmd p
+endfunc
+
+
+
+" Edit the Unicode text file.  Requires the netrw plugin.
+edit http://unicode.org/Public/UNIDATA/UnicodeData.txt
+
+" Parse each line, create a list of lists.
+call ParseDataToProps()
+
+" Build the toLower table.
+call BuildCaseTable("Lower", 13)
+
+" Build the toUpper table.
+call BuildCaseTable("Upper", 12)
+
+" Build the ranges of composing chars.
+call BuildCombiningTable()
+
+" Edit the case folding text file.  Requires the netrw plugin.
+edit http://www.unicode.org/Public/UNIDATA/CaseFolding.txt
+
+" Parse each line, create a list of lists.
+call ParseFoldProps()
+
+" Build the foldCase table.
+call BuildFoldTable()
+
+" Edit the width text file.  Requires the netrw plugin.
+edit http://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt
+
+" Parse each line, create a list of lists.
+call ParseWidthProps()
+
+" Build the double width table.
+call BuildWidthTable('[WF]', 'doublewidth')
+
+" Build the ambiguous width table.
+call BuildWidthTable('A', 'ambiguous')
--- vim72.orig/runtime/doc/usr_41.txt
+++ vim72/runtime/doc/usr_41.txt
@@ -866,10 +866,12 @@ Various:
 	setreg()		set contents and type of a register
 
 	taglist()		get list of matching tags
 	tagfiles()		get a list of tags files
 
+	mzeval()		evaluate |MzScheme| expression
+
 ==============================================================================
 *41.7*	Defining a function
 
 Vim enables you to define your own functions.  The basic function declaration
 begins as follows: >
--- vim72.orig/src/testdir/main.aap
+++ vim72/src/testdir/main.aap
@@ -30,15 +30,15 @@ gui:	newlog $Scripts $ScriptsGUI
 	:print ALL DONE
 
 $Scripts $ScriptsGUI: $VimProg
 
 clean:
-	:del {r}{force} *.out test.log tiny.vim small.vim mbyte.vim test.ok X*
+	:del {r}{force} *.out test.log tiny.vim small.vim mbyte.vim mzscheme.vim test.ok X*
 
 # test1 is special, it checks for features
 test1.out: test1.in
-	:del {force} test1.failed tiny.vim small.vim mbyte.vim
+	:del {force} test1.failed tiny.vim small.vim mbyte.vim mzscheme.vim
 	:sys {i} $VimProg -u unix.vim -U NONE --noplugin -s dotest.in test1.in
 	@if os.system("diff test.out test1.ok") != 0:
 		:error test1 FAILED - Something basic is wrong
 	:move {force} test.out test1.out
 	:del {r}{force} X*
--- vim72.orig/src/testdir/test1.in
+++ vim72/src/testdir/test1.in
@@ -11,10 +11,11 @@ If Vim was not compiled with the +window
 set like small.vim above.  tiny.vim is sourced by tests that require the
 +windows feature or other features that are missing in the tiny version.
 
 If Vim was not compiled with the +multi_byte feature, the mbyte.vim script will be set like small.vim above.  mbyte.vim is sourced by tests that require the
 +multi_byte feature.
+Similar logic is applied to the +mzscheme feature, using mzscheme.vim.
 
 STARTTEST
 :" Write a single line to test.out to check if testing works at all.
 :%d
 athis is a test:w! test.out
@@ -23,12 +24,15 @@ athis is a test:w! test.out
 :w! tiny.vim
 ae! test.ok
 w! test.out
 qa!
 :w! mbyte.vim
+:w! mzscheme.vim
 :" If +multi_byte feature supported, make mbyte.vim empty.
 :if has("multi_byte") | sp another | w! mbyte.vim | q | endif
+:" If +mzscheme feature supported, make mzscheme.vim empty.
+:if has("mzscheme") | sp another | w! mzscheme.vim | q | endif
 :" If +eval feature supported quit here, leaving tiny.vim and small.vim empty.
 :" Otherwise write small.vim to skip the test.
 :if 1 | q! | endif
 :w! small.vim
 :" If +windows feature not supported :sp will fail and tiny.vim will be
--- /dev/null
+++ vim72/src/testdir/test70.in
@@ -0,0 +1,53 @@
+Smoke test for MzScheme interface and mzeval() function
+
+STARTTEST
+:so mzscheme.vim
+:set nocompatible viminfo+=nviminfo
+:function! MzRequire()
+:redir => l:mzversion
+:mz (version)
+:redir END
+:if strpart(l:mzversion, 1, 1) < "4"
+:" MzScheme versions < 4.x:
+:mz (require (prefix vim- vimext))
+:else
+:" newer versions:
+:mz (require (prefix-in vim- 'vimext))
+:mz (require r5rs)
+:endif
+:endfunction
+:silent call MzRequire()
+:mz (define l '("item0" "dictionary with list OK" "item2"))
+:mz (define h (make-hash))
+:mz (hash-set! h "list" l)
+/^1
+:" change buffer contents
+:mz (vim-set-buff-line (vim-eval "line('.')") "1 changed line 1")
+:" scalar test
+:let tmp_string = mzeval('"string"')
+:let tmp_1000 = mzeval('1000')
+:if tmp_string . tmp_1000 == "string1000"
+:let scalar_res = "OK"
+:else
+:let scalar_res = "FAILED"
+:endif
+:call append(search("^1"), "scalar test " . scalar_res)
+:" dictionary containing a list
+:let tmp = mzeval("h")["list"][1]
+:/^2/put =tmp
+:" circular list (at the same time test lists containing lists)
+:mz (set-car! (cddr l) l)
+:let l2 = mzeval("h")["list"]
+:if l2[2] == l2
+:let res = "OK"
+:else
+:let res = "FAILED"
+:endif
+:call setline(search("^3"), "circular test " . res)
+:?^1?,$w! test.out
+:qa!
+ENDTEST
+
+1 line 1
+2 line 2
+3 line 3
--- /dev/null
+++ vim72/src/testdir/test70.ok
@@ -0,0 +1,5 @@
+1 changed line 1
+scalar test OK
+2 line 2
+dictionary with list OK
+circular test OK
--- vim72.orig/src/proto/ex_cmds2.pro
+++ vim72/src/proto/ex_cmds2.pro
@@ -22,10 +22,12 @@ void profile_self __ARGS((proftime_T *se
 void profile_get_wait __ARGS((proftime_T *tm));
 void profile_sub_wait __ARGS((proftime_T *tm, proftime_T *tma));
 int profile_equal __ARGS((proftime_T *tm1, proftime_T *tm2));
 int profile_cmp __ARGS((proftime_T *tm1, proftime_T *tm2));
 void ex_profile __ARGS((exarg_T *eap));
+char_u *get_profile_name __ARGS((expand_T *xp, int idx));
+void set_context_in_profile_cmd __ARGS((expand_T *xp, char_u *arg));
 void profile_dump __ARGS((void));
 void script_prof_save __ARGS((proftime_T *tm));
 void script_prof_restore __ARGS((proftime_T *tm));
 void prof_inchar_enter __ARGS((void));
 void prof_inchar_exit __ARGS((void));
--- vim72.orig/src/GvimExt/gvimext.h
+++ vim72/src/GvimExt/gvimext.h
@@ -12,13 +12,13 @@
  */
 
 #if !defined(AFX_STDAFX_H__3389658B_AD83_11D3_9C1E_0090278BBD99__INCLUDED_)
 #define AFX_STDAFX_H__3389658B_AD83_11D3_9C1E_0090278BBD99__INCLUDED_
 
-#if _MSC_VER > 1000
+#if defined(_MSC_VER) && _MSC_VER > 1000
 #pragma once
-#endif // _MSC_VER > 1000
+#endif
 
 // Insert your headers here
 // #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
 
 //--------------------------------------------------------------
@@ -32,21 +32,21 @@
 #endif
 
 #define INC_OLE2	// WIN32, get ole2 from windows.h
 
 /* Visual Studio 2005 has 'deprecated' many of the standard CRT functions */
-#if _MSC_VER >= 1400
+#if defined(_MSC_VER) && _MSC_VER >= 1400
 # define _CRT_SECURE_NO_DEPRECATE
 # define _CRT_NONSTDC_NO_DEPRECATE
 #endif
 
 #include <windows.h>
 #include <windowsx.h>
 #include <shlobj.h>
 
 /* Accommodate old versions of VC that don't have a modern Platform SDK */
-#if _MSC_VER < 1300
+#if defined(_MSC_VER) && _MSC_VER < 1300
 # undef  UINT_PTR
 # define UINT_PTR UINT
 #endif
 
 #define ResultFromShort(i)  ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS, 0, (USHORT)(i)))
--- vim72.orig/src/osdef1.h.in
+++ vim72/src/osdef1.h.in
@@ -23,11 +23,11 @@ extern int	fclose __ARGS((FILE *));
 extern int	fseek __ARGS((FILE *, long, int));
 #ifdef HAVE_FSEEKO
 extern int	fseeko __ARGS((FILE *, off_t, int));
 #endif
 extern long	ftell __ARGS((FILE *));
-#ifdef HAVE_FTELLO
+#ifdef HAVE_FSEEKO
 extern off_t	ftello __ARGS((FILE *));
 #endif
 extern void	rewind __ARGS((FILE *));
 extern int	fread __ARGS((char *, int, int, FILE *));
 extern int	fwrite __ARGS((char *, int, int, FILE *));
--- vim72.orig/src/GvimExt/Make_ming.mak
+++ vim72/src/GvimExt/Make_ming.mak
@@ -18,28 +18,24 @@ CROSS = no
 MINGWOLD = no
 
 ifeq ($(CROSS),yes)
 DEL = rm
 ifeq ($(MINGWOLD),yes)
-CXX = i586-mingw32msvc-g++
 CXXFLAGS := -O2 -mno-cygwin -fvtable-thunks
-WINDRES = i586-mingw32msvc-windres
 else
-CXX = i386-mingw32msvc-g++
 CXXFLAGS := -O2 -mno-cygwin
-WINDRES = i386-mingw32msvc-windres
 endif
 else
-CXX := g++
-WINDRES := windres
 CXXFLAGS := -O2 -mno-cygwin
 ifneq (sh.exe, $(SHELL))
 DEL = rm
 else
 DEL = del
 endif
 endif
+CXX := $(CROSS_COMPILE)g++
+WINDRES := $(CROSS_COMPILE)windres
 LIBS :=  -luuid
 RES  := gvimext.res
 DEFFILE = gvimext_ming.def
 OBJ  := gvimext.o
 
--- vim72.orig/src/INSTALLpc.txt
+++ vim72/src/INSTALLpc.txt
@@ -213,12 +213,13 @@ and you type:
 After churning for a while, you will end up with 'gvim.exe' in the 'vim\src'
 directory.
 
 You should not need to do *any* editing of any files to get vim compiled this
 way.  If, for some reason, you want the console-mode-only version of vim (this
-is NOT recommended on Win32, especially on '95/'98!!!), you need only change
-the 'gvim.exe' to 'vim.exe' in the 'make' commands given above.
+is NOT recommended on Win32, especially on '95/'98!!!), you can use:
+
+    make -f Make_ming.mak GUI=no vim.exe
 
 If you are dismayed by how big the EXE is, I strongly recommend you get 'UPX'
 (also free!) and compress the file (typical compression is 50%). UPX can be
 found at
     http://www.upx.org/
@@ -238,11 +239,11 @@ Use Make_cyg.mak with Cygwin's GCC. See
     http://users.skynet.be/antoine.mechelynck/vim/compile.htm
 
 The Cygnus one many not fully work yet.
 With Cygnus gcc you can use the Unix Makefile instead (you need to get the
 Unix archive then).  Then you get a Cygwin application (feels like Vim is
-runnin on Unix), while with Make_cyg.mak you get a Windows application (like
+running on Unix), while with Make_cyg.mak you get a Windows application (like
 with the other makefiles).
 
 
 4. Borland
 ===========
@@ -257,14 +258,17 @@ Use Make_bc5.mak with Borland C++ 5.x. S
 [Update of 1) needs to be verified]
 
 If you like, you can compile the 'mingw' Win32 version from the comfort of
 your Linux (or other unix) box.  To do this, you need to follow a few steps:
     1) Install the mingw32 cross-compiler. See
+	http://www.mingw.org/wiki/LinuxCrossMinGW
 	http://www.libsdl.org/extras/win32/cross/README.txt
     2) Get and unpack both the Unix sources and the extra archive
     3) in 'Make_ming.mak', set 'CROSS' to 'yes' instead of 'no'.
        Make further changes to 'Make_ming.mak' as you wish.
+       If your cross-compiler prefix differs from the predefined value,
+       set 'CROSS_COMPILE' corresponding.
     4) make -f Make_ming.mak gvim.exe
 
 Now you have created the Windows binary from your Linux box!  Have fun...
 
 
--- vim72.orig/src/xxd/Make_cyg.mak
+++ vim72/src/xxd/Make_cyg.mak
@@ -10,18 +10,19 @@ LIBS    = -lc
 else
 DEFINES = -mno-cygwin
 LIBS    =
 endif
 
+CC = gcc
 CFLAGS = -O2 -Wall -DWIN32 $(DEFINES)
 
 ifneq (sh.exe, $(SHELL))
 DEL = rm
 else
 DEL = del
 endif
 
 xxd.exe: xxd.c
-	gcc $(CFLAGS) -s -o xxd.exe xxd.c $(LIBS)
+	$(CC) $(CFLAGS) -s -o xxd.exe xxd.c $(LIBS)
 
 clean:
 	-$(DEL) xxd.exe
--- vim72.orig/src/option.h
+++ vim72/src/option.h
@@ -31,11 +31,11 @@
 #     define DFLT_EFM	"%A%p^,%C%%CC-%t-%m,%Cat line number %l in file %f,%f|%l| %m"
 #    else /* Unix, probably */
 #     ifdef EBCDIC
 #define DFLT_EFM	"%*[^ ] %*[^ ] %f:%l%*[ ]%m,%*[^\"]\"%f\"%*\\D%l: %m,\"%f\"%*\\D%l: %m,%f:%l:%c:%m,%f(%l):%m,%f:%l:%m,\"%f\"\\, line %l%*\\D%c%*[^ ] %m,%D%*\\a[%*\\d]: Entering directory `%f',%X%*\\a[%*\\d]: Leaving directory `%f',%DMaking %*\\a in %f,%f|%l| %m"
 #     else
-#define DFLT_EFM	"%*[^\"]\"%f\"%*\\D%l: %m,\"%f\"%*\\D%l: %m,%-G%f:%l: (Each undeclared identifier is reported only once,%-G%f:%l: for each function it appears in.),%f:%l:%c:%m,%f(%l):%m,%f:%l:%m,\"%f\"\\, line %l%*\\D%c%*[^ ] %m,%D%*\\a[%*\\d]: Entering directory `%f',%X%*\\a[%*\\d]: Leaving directory `%f',%D%*\\a: Entering directory `%f',%X%*\\a: Leaving directory `%f',%DMaking %*\\a in %f,%f|%l| %m"
+#define DFLT_EFM	"%*[^\"]\"%f\"%*\\D%l: %m,\"%f\"%*\\D%l: %m,%-G%f:%l: (Each undeclared identifier is reported only once,%-G%f:%l: for each function it appears in.),%-GIn file included from %f:%l:%c,%-GIn file included from %f:%l,%-Gfrom %f:%l:%c,%-Gfrom %f:%l,%f:%l:%c:%m,%f(%l):%m,%f:%l:%m,\"%f\"\\, line %l%*\\D%c%*[^ ] %m,%D%*\\a[%*\\d]: Entering directory `%f',%X%*\\a[%*\\d]: Leaving directory `%f',%D%*\\a: Entering directory `%f',%X%*\\a: Leaving directory `%f',%DMaking %*\\a in %f,%f|%l| %m"
 #     endif
 #    endif
 #   endif
 #  endif
 # endif
--- vim72.orig/src/proto/ex_docmd.pro
+++ vim72/src/proto/ex_docmd.pro
@@ -50,6 +50,7 @@ int find_cmdline_var __ARGS((char_u *src
 char_u *eval_vars __ARGS((char_u *src, char_u *srcstart, int *usedlen, linenr_T *lnump, char_u **errormsg, int *escaped));
 char_u *expand_sfile __ARGS((char_u *arg));
 int put_eol __ARGS((FILE *fd));
 int put_line __ARGS((FILE *fd, char *s));
 void dialog_msg __ARGS((char_u *buff, char *format, char_u *fname));
+char_u *get_behave_arg __ARGS((expand_T *xp, int idx));
 /* vim: set ft=c : */
--- vim72.orig/src/os_unixx.h
+++ vim72/src/os_unixx.h
@@ -26,15 +26,10 @@
 
 # if defined(HAVE_SYS_WAIT_H) || defined(HAVE_UNION_WAIT)
 #  include <sys/wait.h>
 # endif
 
-# if defined(HAVE_SYS_SELECT_H) && \
-	(!defined(HAVE_SYS_TIME_H) || defined(SYS_SELECT_WITH_SYS_TIME))
-#  include <sys/select.h>
-# endif
-
 # ifndef WEXITSTATUS
 #  ifdef HAVE_UNION_WAIT
 #   define WEXITSTATUS(stat_val) ((stat_val).w_T.w_Retcode)
 #  else
 #   define WEXITSTATUS(stat_val) (((stat_val) >> 8) & 0377)
@@ -63,20 +58,10 @@
 
 #ifdef HAVE_STRING_H
 # include <string.h>
 #endif
 
-#ifndef HAVE_SELECT
-# ifdef HAVE_SYS_POLL_H
-#  include <sys/poll.h>
-# else
-#  ifdef HAVE_POLL_H
-#   include <poll.h>
-#  endif
-# endif
-#endif
-
 #ifdef HAVE_SYS_STREAM_H
 # include <sys/stream.h>
 #endif
 
 #ifdef HAVE_SYS_UTSNAME_H
--- vim72.orig/runtime/plugin/gzip.vim
+++ vim72/runtime/plugin/gzip.vim
@@ -1,8 +1,8 @@
 " Vim plugin for editing compressed files.
 " Maintainer: Bram Moolenaar <Bram@vim.org>
-" Last Change: 2005 Jul 26
+" Last Change: 2010 Mar 10
 
 " Exit quickly when:
 " - this plugin was already loaded
 " - when 'compatible' is set
 " - some autocommands are already taking care of compressed files
@@ -18,19 +18,27 @@ augroup gzip
   " Enable editing of gzipped files.
   " The functions are defined in autoload/gzip.vim.
   "
   " Set binary mode before reading the file.
   " Use "gzip -d", gunzip isn't always available.
-  autocmd BufReadPre,FileReadPre	*.gz,*.bz2,*.Z setlocal bin
+  autocmd BufReadPre,FileReadPre	*.gz,*.bz2,*.Z,*.lzma,*.xz setlocal bin
   autocmd BufReadPost,FileReadPost	*.gz  call gzip#read("gzip -dn")
   autocmd BufReadPost,FileReadPost	*.bz2 call gzip#read("bzip2 -d")
   autocmd BufReadPost,FileReadPost	*.Z   call gzip#read("uncompress")
+  autocmd BufReadPost,FileReadPost	*.lzma call gzip#read("lzma -d")
+  autocmd BufReadPost,FileReadPost	*.xz  call gzip#read("xz -d")
   autocmd BufWritePost,FileWritePost	*.gz  call gzip#write("gzip")
   autocmd BufWritePost,FileWritePost	*.bz2 call gzip#write("bzip2")
   autocmd BufWritePost,FileWritePost	*.Z   call gzip#write("compress -f")
+  autocmd BufWritePost,FileWritePost	*.lzma call gzip#write("lzma -z")
+  autocmd BufWritePost,FileWritePost	*.xz  call gzip#write("xz -z")
   autocmd FileAppendPre			*.gz  call gzip#appre("gzip -dn")
   autocmd FileAppendPre			*.bz2 call gzip#appre("bzip2 -d")
   autocmd FileAppendPre			*.Z   call gzip#appre("uncompress")
+  autocmd FileAppendPre			*.lzma call gzip#appre("lzma -d")
+  autocmd FileAppendPre			*.xz   call gzip#appre("xz -d")
   autocmd FileAppendPost		*.gz  call gzip#write("gzip")
   autocmd FileAppendPost		*.bz2 call gzip#write("bzip2")
   autocmd FileAppendPost		*.Z   call gzip#write("compress -f")
+  autocmd FileAppendPost		*.lzma call gzip#write("lzma -z")
+  autocmd FileAppendPost		*.xz call gzip#write("xz -z")
 augroup END
