From eff70b6d14cc372944bbeda0dd0afe8599327f96 Mon Sep 17 00:00:00 2001
From: Thomas White <taw@bitwiz.org.uk>
Date: Tue, 20 Oct 2009 16:14:55 +0200
Subject: [PATCH 3/9] Glamo DRM and KMS driver

This adds the Glamo DRM and KMS driver, but not the modifications needed
elsewhere to support it.

Signed-off-by: Thomas White <taw@bitwiz.org.uk>
---
 drivers/mfd/glamo/Kconfig             |   15 +
 drivers/mfd/glamo/Makefile            |    5 +-
 drivers/mfd/glamo/glamo-buffer.c      |  372 ++++++++++++++
 drivers/mfd/glamo/glamo-buffer.h      |   60 +++
 drivers/mfd/glamo/glamo-cmdq.c        |  528 ++++++++++++++++++++
 drivers/mfd/glamo/glamo-cmdq.h        |   49 ++
 drivers/mfd/glamo/glamo-display.c     |  869 +++++++++++++++++++++++++++++++++
 drivers/mfd/glamo/glamo-display.h     |   39 ++
 drivers/mfd/glamo/glamo-drm-drv.c     |  444 +++++++++++++++++
 drivers/mfd/glamo/glamo-drm-private.h |  156 ++++++
 drivers/mfd/glamo/glamo-fence.c       |  330 +++++++++++++
 drivers/mfd/glamo/glamo-fence.h       |   34 ++
 drivers/mfd/glamo/glamo-kms-fb.c      |  540 ++++++++++++++++++++
 drivers/mfd/glamo/glamo-kms-fb.h      |   41 ++
 include/drm/Kbuild                    |    1 +
 include/drm/glamo_drm.h               |  153 ++++++
 16 files changed, 3635 insertions(+), 1 deletions(-)
 create mode 100644 drivers/mfd/glamo/glamo-buffer.c
 create mode 100644 drivers/mfd/glamo/glamo-buffer.h
 create mode 100644 drivers/mfd/glamo/glamo-cmdq.c
 create mode 100644 drivers/mfd/glamo/glamo-cmdq.h
 create mode 100644 drivers/mfd/glamo/glamo-display.c
 create mode 100644 drivers/mfd/glamo/glamo-display.h
 create mode 100644 drivers/mfd/glamo/glamo-drm-drv.c
 create mode 100644 drivers/mfd/glamo/glamo-drm-private.h
 create mode 100644 drivers/mfd/glamo/glamo-fence.c
 create mode 100644 drivers/mfd/glamo/glamo-fence.h
 create mode 100644 drivers/mfd/glamo/glamo-kms-fb.c
 create mode 100644 drivers/mfd/glamo/glamo-kms-fb.h
 create mode 100644 include/drm/glamo_drm.h

diff --git a/drivers/mfd/glamo/Kconfig b/drivers/mfd/glamo/Kconfig
index 3aa4831..214c70e 100644
--- a/drivers/mfd/glamo/Kconfig
+++ b/drivers/mfd/glamo/Kconfig
@@ -40,3 +40,18 @@ config MFD_GLAMO_MCI
 	  neo1973 GTA-02.
 
 	  If unsure, say N.
+
+config MFD_GLAMO_DRM
+	tristate "Glamo direct rendering and kernel modesetting support"
+	depends on MFD_GLAMO && DRM
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  Direct Rendering Manager interface for the S-Media Glamo chip, as
+	  used in Openmoko FreeRunner (GTA02).
+
+	  This DRM driver includes kernel modesetting (KMS) support.  As such,
+	  do not select MFD_GLAMO_FB above if you choose to enable this option.
+
+	  If unsure, say N.
diff --git a/drivers/mfd/glamo/Makefile b/drivers/mfd/glamo/Makefile
index ebf26f7..d5ebf8f 100644
--- a/drivers/mfd/glamo/Makefile
+++ b/drivers/mfd/glamo/Makefile
@@ -1,5 +1,5 @@
 #
-# Makefile for the Smedia Glamo framebuffer driver
+# Makefile for the Smedia Glamo driver(s)
 #
 
 obj-$(CONFIG_MFD_GLAMO)			+= glamo-core.o
@@ -8,4 +8,7 @@ obj-$(CONFIG_MFD_GLAMO_SPI)		+= glamo-spi.o
 
 obj-$(CONFIG_MFD_GLAMO_FB)		+= glamo-fb.o
 obj-$(CONFIG_MFD_GLAMO_MCI)		+= glamo-mci.o
+obj-$(CONFIG_MFD_GLAMO_DRM)		+= glamo-drm.o
 
+glamo-drm-objs	:=  glamo-drm-drv.o glamo-cmdq.o glamo-buffer.o \
+                    glamo-display.o glamo-kms-fb.o glamo-fence.o
diff --git a/drivers/mfd/glamo/glamo-buffer.c b/drivers/mfd/glamo/glamo-buffer.c
new file mode 100644
index 0000000..45500d3
--- /dev/null
+++ b/drivers/mfd/glamo/glamo-buffer.c
@@ -0,0 +1,372 @@
+/*
+ * SMedia Glamo 336x/337x memory management
+ *
+ * Copyright (c) 2009 Thomas White <taw@bitwiz.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ * Memory mapping functions based on i915_gem.c, to which the following
+ * notice applies:
+ *
+ * Copyright © 2008 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Eric Anholt <eric@anholt.net>
+ */
+
+
+#include <drm/drmP.h>
+#include <drm/glamo_drm.h>
+
+#include "glamo-drm-private.h"
+#include "glamo-cmdq.h"	/* For glamo_cmdq_blank() */
+
+
+struct drm_gem_object *glamo_gem_object_alloc(struct drm_device *dev, int size,
+                                              int alignment)
+{
+	struct drm_gem_object *obj;
+	struct glamodrm_handle *gdrm;
+	struct drm_glamo_gem_object *gobj;
+
+	gdrm = dev->dev_private;
+
+	size = roundup(size, PAGE_SIZE);
+
+	obj = drm_gem_object_alloc(dev, size);
+	if (obj == NULL) return NULL;
+
+	/* See glamodrm_gem_init_object() below */
+	gobj = obj->driver_private;
+
+	/* Allocate memory for this object in VRAM */
+	gobj->block = drm_mm_search_free(gdrm->mmgr, size, alignment, 1);
+	if (!gobj->block) {
+		goto fail;
+	}
+	gobj->block = drm_mm_get_block(gobj->block, size, alignment);
+	if (!gobj->block) {
+		goto fail;
+	}
+
+	/* Arrange for the contents to be set to zero */
+	glamo_cmdq_blank(gdrm, obj);
+
+	return obj;
+
+fail:
+	mutex_lock(&dev->struct_mutex);
+	drm_gem_object_unreference(obj);
+	mutex_unlock(&dev->struct_mutex);
+	printk(KERN_INFO "[glamo-drm] Failed to allocate object\n");
+
+	return NULL;
+}
+
+
+int glamo_ioctl_gem_create(struct drm_device *dev, void *data,
+			   struct drm_file *file_priv)
+{
+	struct drm_glamo_gem_create *args = data;
+	struct drm_gem_object *obj;
+	int handle, ret, alignment, size;
+
+	/* Alignment must be a non-zero multiple of 2 */
+	alignment = args->alignment;
+	if ( alignment < 2 ) alignment = 2;
+	if ( alignment % 2 ) alignment *= 2;
+
+	/* Size must be similarly sanitised */
+	size = args->size;
+	if ( size < 2 ) size = 2;
+	if ( size % 2 ) size += 1;
+
+	/* Create an object */
+	obj = glamo_gem_object_alloc(dev, size, alignment);
+	if ( obj == NULL ) return -ENOMEM;
+
+	/* Create a handle for it */
+	ret = drm_gem_handle_create(file_priv, obj, &handle);
+	mutex_lock(&dev->struct_mutex);
+	drm_gem_object_handle_unreference(obj);
+	mutex_unlock(&dev->struct_mutex);
+	if (ret) goto fail;
+
+	/* Return */
+	args->handle = handle;
+	return 0;
+
+fail:
+	mutex_lock(&dev->struct_mutex);
+	drm_gem_object_unreference(obj);
+	mutex_unlock(&dev->struct_mutex);
+	printk(KERN_INFO "[glamo-drm] Failed to allocate object\n");
+	return ret;
+}
+
+
+int glamodrm_gem_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+	struct drm_gem_object *obj = vma->vm_private_data;
+	struct drm_device *dev = obj->dev;
+	struct drm_glamo_gem_object *gobj = obj->driver_private;
+	struct glamodrm_handle *gdrm = dev->dev_private;
+	pgoff_t page_offset;
+	unsigned long pfn;
+	int ret = 0;
+
+	/* We don't use vmf->pgoff since that has the fake offset */
+	page_offset = ((unsigned long)vmf->virtual_address - vma->vm_start) >>
+	               PAGE_SHIFT;
+
+	mutex_lock(&dev->struct_mutex);
+	pfn = ((gdrm->vram->start + GLAMO_OFFSET_FB + gobj->block->start)
+	       >> PAGE_SHIFT) + page_offset;
+	ret = vm_insert_pfn(vma, (unsigned long)vmf->virtual_address, pfn);
+	mutex_unlock(&dev->struct_mutex);
+
+	switch (ret) {
+	case -ENOMEM:
+	case -EAGAIN:
+		return VM_FAULT_OOM;
+	case -EFAULT:
+	case -EBUSY:
+		DRM_ERROR("can't insert pfn??  fault or busy...\n");
+		return VM_FAULT_SIGBUS;
+	default:
+		return VM_FAULT_NOPAGE;
+	}
+}
+
+
+static int glamo_gem_create_mmap_offset(struct drm_gem_object *obj)
+{
+	struct drm_device *dev = obj->dev;
+	struct drm_gem_mm *mm = dev->mm_private;
+	struct drm_glamo_gem_object *gobj = obj->driver_private;
+	struct drm_map_list *list;
+	struct drm_local_map *map;
+	int ret = 0;
+
+	/* Set the object up for mmap'ing */
+	list = &obj->map_list;
+	list->map = kzalloc(sizeof(struct drm_map_list), GFP_KERNEL);
+	if (!list->map)
+		return -ENOMEM;
+
+	map = list->map;
+	map->type = _DRM_GEM;
+	map->size = obj->size;
+	map->handle = obj;
+
+	/* Get a DRM GEM mmap offset allocated... */
+	list->file_offset_node = drm_mm_search_free(&mm->offset_manager,
+	                                            obj->size / PAGE_SIZE, 0, 0);
+	if (!list->file_offset_node) {
+		DRM_ERROR("failed to allocate offset for bo %d\n", obj->name);
+		ret = -ENOMEM;
+		goto out_free_list;
+	}
+
+	list->file_offset_node = drm_mm_get_block(list->file_offset_node,
+						  obj->size / PAGE_SIZE, 0);
+	if (!list->file_offset_node) {
+		ret = -ENOMEM;
+		goto out_free_list;
+	}
+
+	list->hash.key = list->file_offset_node->start;
+	if (drm_ht_insert_item(&mm->offset_hash, &list->hash)) {
+		DRM_ERROR("failed to add to map hash\n");
+		goto out_free_mm;
+	}
+
+	/* By now we should be all set, any drm_mmap request on the offset
+	 * below will get to our mmap & fault handler */
+	gobj->mmap_offset = ((uint64_t) list->hash.key) << PAGE_SHIFT;
+
+	return 0;
+
+out_free_mm:
+	drm_mm_put_block(list->file_offset_node);
+out_free_list:
+	kfree(list->map);
+
+	return ret;
+}
+
+
+int glamo_ioctl_gem_mmap(struct drm_device *dev, void *data,
+			 struct drm_file *file_priv)
+{
+	struct drm_glamo_gem_mmap *args = data;
+	struct drm_gem_object *obj;
+	struct drm_glamo_gem_object *gobj;
+	int ret;
+
+	obj = drm_gem_object_lookup(dev, file_priv, args->handle);
+	if (obj == NULL)
+		return -EBADF;
+
+	mutex_lock(&dev->struct_mutex);
+
+	gobj = obj->driver_private;
+	if (!gobj->mmap_offset) {
+		ret = glamo_gem_create_mmap_offset(obj);
+		if (ret) {
+			mutex_unlock(&dev->struct_mutex);
+			return ret;
+		}
+	}
+
+	args->offset = gobj->mmap_offset;
+
+	drm_gem_object_unreference(obj);
+	mutex_unlock(&dev->struct_mutex);
+
+	return 0;
+}
+
+
+int glamo_ioctl_gem_pin(struct drm_device *dev, void *data,
+			struct drm_file *file_priv)
+{
+	printk(KERN_INFO "glamo_ioctl_gem_pin\n");
+	return 0;
+}
+
+
+int glamo_ioctl_gem_unpin(struct drm_device *dev, void *data,
+			  struct drm_file *file_priv)
+{
+	printk(KERN_INFO "glamo_ioctl_gem_unpin\n");
+	return 0;
+}
+
+
+int glamo_ioctl_gem_pread(struct drm_device *dev, void *data,
+			  struct drm_file *file_priv)
+{
+	printk(KERN_INFO "glamo_ioctl_gem_pread\n");
+	return 0;
+}
+
+
+int glamo_ioctl_gem_pwrite(struct drm_device *dev, void *data,
+			   struct drm_file *file_priv)
+{
+	printk(KERN_INFO "glamo_ioctl_gem_pwrite\n");
+	return 0;
+}
+
+
+int glamodrm_gem_init_object(struct drm_gem_object *obj)
+{
+	struct drm_glamo_gem_object *gobj;
+
+	/* Allocate a private structure */
+	gobj = kzalloc(sizeof(*gobj), GFP_KERNEL);
+	if (!gobj) return -ENOMEM;
+
+	obj->driver_private = gobj;
+	gobj->obj = obj;
+
+	return 0;
+}
+
+
+void glamodrm_gem_free_object(struct drm_gem_object *obj)
+{
+	struct drm_glamo_gem_object *gobj;
+	struct drm_map_list *list;
+	struct drm_device *dev;
+	struct drm_gem_mm *mm;
+	struct drm_local_map *map;
+
+	dev = obj->dev;
+	mm = dev->mm_private;
+	gobj = obj->driver_private;
+
+	/* Free the VRAM */
+	if ( gobj->block != NULL ) {
+		drm_mm_put_block(gobj->block);
+	}
+
+	/* Release mappings */
+	list = &obj->map_list;
+	drm_ht_remove_item(&mm->offset_hash, &list->hash);
+	if (list->file_offset_node) {
+		drm_mm_put_block(list->file_offset_node);
+		list->file_offset_node = NULL;
+	}
+	map = list->map;
+	if (map) {
+		kfree(map);
+		list->map = NULL;
+	}
+
+	/* Free the private structure */
+	kfree(obj->driver_private);
+}
+
+
+/* Memory management initialisation */
+int glamo_buffer_init(struct glamodrm_handle *gdrm)
+{
+	gdrm->mmgr = kzalloc(sizeof(struct drm_mm), GFP_KERNEL);
+	drm_mm_init(gdrm->mmgr, 0, gdrm->vram_size);
+
+	/* Reserve a scratch buffer.  We do this outside the protections
+	 * of the other GEM code.  To do this safely, the allocation must
+	 * be a multiple of PAGE_SIZE. */
+	gdrm->scratch = drm_mm_search_free(gdrm->mmgr, PAGE_SIZE, 4, 1);
+	if ( gdrm->scratch ) {
+		gdrm->scratch = drm_mm_get_block(gdrm->scratch, PAGE_SIZE, 4);
+	}
+	if ( !gdrm->scratch ) {
+		printk(KERN_WARNING "[glamo-drm] Couldn't allocate"
+		                    " scratch buffer!\n");
+	}
+
+	return 0;
+}
+
+
+/* Memory management finalisation */
+int glamo_buffer_final(struct glamodrm_handle *gdrm)
+{
+	drm_mm_takedown(gdrm->mmgr);
+	kfree(gdrm->mmgr);
+	return 0;
+}
diff --git a/drivers/mfd/glamo/glamo-buffer.h b/drivers/mfd/glamo/glamo-buffer.h
new file mode 100644
index 0000000..41f18fd
--- /dev/null
+++ b/drivers/mfd/glamo/glamo-buffer.h
@@ -0,0 +1,60 @@
+/*
+ * SMedia Glamo 336x/337x memory management
+ *
+ * Copyright (c) 2009 Thomas White <taw@bitwiz.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef __GLAMO_BUFFER_H
+#define __GLAMO_BUFFER_H
+
+#include <drm/drmP.h>
+
+#include "glamo-drm-private.h"
+
+extern int glamo_buffer_init(struct glamodrm_handle *gdrm);
+extern int glamo_buffer_final(struct glamodrm_handle *gdrm);
+
+extern int glamodrm_gem_fault(struct vm_area_struct *vma, struct vm_fault *vmf);
+
+extern int glamodrm_gem_init_object(struct drm_gem_object *obj);
+
+extern void glamodrm_gem_free_object(struct drm_gem_object *obj);
+
+extern struct drm_gem_object *glamo_gem_object_alloc(struct drm_device *dev,
+                                                     int size, int alignment);
+
+extern int glamo_ioctl_gem_create(struct drm_device *dev, void *data,
+				  struct drm_file *file_priv);
+
+extern int glamo_ioctl_gem_mmap(struct drm_device *dev, void *data,
+				struct drm_file *file_priv);
+
+extern int glamo_ioctl_gem_pin(struct drm_device *dev, void *data,
+			       struct drm_file *file_priv);
+
+extern int glamo_ioctl_gem_unpin(struct drm_device *dev, void *data,
+				 struct drm_file *file_priv);
+
+extern int glamo_ioctl_gem_pread(struct drm_device *dev, void *data,
+				 struct drm_file *file_priv);
+
+extern int glamo_ioctl_gem_pwrite(struct drm_device *dev, void *data,
+				  struct drm_file *file_priv);
+
+#endif /* __GLAMO_BUFFER_H */
diff --git a/drivers/mfd/glamo/glamo-cmdq.c b/drivers/mfd/glamo/glamo-cmdq.c
new file mode 100644
index 0000000..caedc27
--- /dev/null
+++ b/drivers/mfd/glamo/glamo-cmdq.c
@@ -0,0 +1,528 @@
+/*
+ * SMedia Glamo 336x/337x command queue handling
+ *
+ * Copyright (C) 2008-2009 Thomas White <taw@bitwiz.org.uk>
+ * Copyright (C) 2009 Andreas Pokorny <andreas.pokorny@gmail.com>
+ * Based on xf86-video-glamo (see below for details)
+ *
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Command queue handling functions based on those from xf86-video-glamo, to
+ * which the following licence applies:
+ *
+ * Copyright  2007 OpenMoko, Inc.
+ * Copyright © 2009 Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * This driver is based on Xati,
+ * Copyright  2004 Eric Anholt
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+
+#include <drm/drmP.h>
+#include <drm/glamo_drm.h>
+
+#include "glamo-core.h"
+#include "glamo-drm-private.h"
+#include "glamo-regs.h"
+
+
+static inline void reg_write(struct glamodrm_handle *gdrm,
+                             u_int16_t reg, u_int16_t val)
+{
+	iowrite16(val, gdrm->reg_base + reg);
+}
+
+
+static inline u16 reg_read(struct glamodrm_handle *gdrm, u_int16_t reg)
+{
+	return ioread16(gdrm->reg_base + reg);
+}
+
+
+static u32 glamo_get_read(struct glamodrm_handle *gdrm)
+{
+	/* we could turn off clock here */
+	u32 ring_read = reg_read(gdrm, GLAMO_REG_CMDQ_READ_ADDRL);
+	ring_read |= (reg_read(gdrm, GLAMO_REG_CMDQ_READ_ADDRH) & 0x7) << 16;
+
+	return ring_read;
+}
+
+
+static u32 glamo_get_write(struct glamodrm_handle *gdrm)
+{
+	u32 ring_write = reg_read(gdrm, GLAMO_REG_CMDQ_WRITE_ADDRL);
+	ring_write |= (reg_read(gdrm, GLAMO_REG_CMDQ_WRITE_ADDRH) & 0x7) << 16;
+
+	return ring_write;
+}
+
+
+/* Add commands to the ring buffer */
+int glamo_add_to_ring(struct glamodrm_handle *gdrm, u16 *addr,
+                      unsigned int count)
+{
+	size_t ring_write, ring_read;
+	size_t new_ring_write;
+
+	if ( count >= GLAMO_CMDQ_SIZE ) {
+		printk(KERN_WARNING "[glamo-drm] CmdQ submission too large\n");
+		return -EINVAL;
+	}
+
+	down(&gdrm->add_to_ring);
+
+	ring_write = glamo_get_write(gdrm);
+
+	/* Calculate where we'll end up */
+	new_ring_write = (ring_write + count) % GLAMO_CMDQ_SIZE;
+
+	/* Wait until there is enough space to queue the cmd buffer */
+	if (new_ring_write > ring_write) {
+		/* Loop while the read pointer is between the old and new
+		 * positions */
+		do {
+			ring_read = glamo_get_read(gdrm);
+		} while (ring_read > ring_write && ring_read < new_ring_write);
+	} else {
+		/* Same, but kind of inside-out */
+		do {
+			ring_read = glamo_get_read(gdrm);
+		} while (ring_read > ring_write || ring_read < new_ring_write);
+	}
+
+	/* Are we about to wrap around? */
+	if (ring_write >= new_ring_write) {
+
+		u32 rest_size;
+
+		/* Wrap around */
+		rest_size = GLAMO_CMDQ_SIZE - ring_write; /* Space left */
+
+		/* Write from current position to end */
+		memcpy_toio(gdrm->cmdq_base+ring_write, addr, rest_size);
+
+		/* Write from start */
+		memcpy_toio(gdrm->cmdq_base, addr+(rest_size>>1),
+		            count - rest_size);
+
+		/* ring_write being 0 will result in a deadlock because the
+		 * cmdq read will never stop. To avoid such an behaviour insert
+		 * an empty instruction. */
+		if (new_ring_write == 0) {
+			iowrite16(0x0000, gdrm->cmdq_base);
+			iowrite16(0x0000, gdrm->cmdq_base + 2);
+			new_ring_write = 4;
+		}
+
+	} else {
+
+		memcpy_toio(gdrm->cmdq_base+ring_write, addr, count);
+
+	}
+
+	reg_write(gdrm, GLAMO_REG_CMDQ_WRITE_ADDRH,
+			(new_ring_write >> 16) & 0x7f);
+	reg_write(gdrm, GLAMO_REG_CMDQ_WRITE_ADDRL,
+			new_ring_write & 0xffff);
+
+	if ( !(reg_read(gdrm, GLAMO_REG_CMDQ_STATUS) & 1<<3)  ) {
+		printk(KERN_ERR "[glamo-drm] CmdQ decode failure.\n");
+	}
+
+	up(&gdrm->add_to_ring);
+
+	return 0;
+}
+
+
+/* Return true for a legal sequence of commands, otherwise false */
+static int glamo_sanitize_buffer(u16 *cmds, unsigned int count)
+{
+	/* XXX FIXME TODO: Implementation... */
+	return 1;
+}
+
+
+/* Substitute the real addresses in VRAM for any required buffer objects */
+static int glamo_do_relocation(struct glamodrm_handle *gdrm,
+                               drm_glamo_cmd_buffer_t *cbuf, u16 *cmds,
+                               struct drm_device *dev,
+                               struct drm_file *file_priv)
+{
+	u32 *handles;
+	int *offsets;
+	int nobjs =  cbuf->nobjs;
+	int i;
+
+	if ( nobjs > 32 ) return -EINVAL;	/* Get real... */
+
+	handles = kmalloc(nobjs*sizeof(u32), GFP_KERNEL);
+	if ( handles == NULL ) return -1;
+	if ( copy_from_user(handles, cbuf->objs, nobjs*sizeof(u32)) )
+		return -1;
+
+	offsets = kmalloc(nobjs*sizeof(int), GFP_KERNEL);
+	if ( offsets == NULL ) return -1;
+	if ( copy_from_user(offsets, cbuf->obj_pos, nobjs*sizeof(int)) )
+		return -1;
+
+	for ( i=0; i<nobjs; i++ ) {
+
+		u32 handle = handles[i];
+		int offset = offsets[i];
+		struct drm_gem_object *obj;
+		struct drm_glamo_gem_object *gobj;
+		u32 addr;
+		u16 addr_low, addr_high;
+
+		if ( offset > cbuf->bufsz ) {
+			printk(KERN_WARNING "[glamo-drm] Offset out of range"
+			                    " for this relocation!\n");
+			goto fail;
+		}
+
+		obj = drm_gem_object_lookup(dev, file_priv, handle);
+		if ( obj == NULL ) return -1;
+
+		/* Unref the object now, or it'll never get freed.
+		 * This should really happen after the GPU has finished
+		 * the commands which are about to be submitted. */
+		drm_gem_object_unreference(obj);
+
+		gobj = obj->driver_private;
+		if ( gobj == NULL ) {
+			printk(KERN_WARNING "[glamo-drm] This object has no"
+			                    " private data!\n");
+			goto fail;
+		}
+
+		addr = GLAMO_OFFSET_FB + gobj->block->start;
+		addr_low = addr & 0xffff;
+		addr_high = (addr >> 16) & 0x7f;
+
+		/* FIXME: Should really check that the register is a
+		 * valid one for this relocation. */
+
+		*(cmds+(offset/2)+1) = addr_low;
+		*(cmds+(offset/2)+3) = addr_high;
+
+	}
+
+	kfree(handles);
+	kfree(offsets);
+	return 0;
+
+fail:
+	kfree(handles);
+	kfree(offsets);
+	return -1;
+}
+
+
+/* This is DRM_IOCTL_GLAMO_CMDBUF */
+int glamo_ioctl_cmdbuf(struct drm_device *dev, void *data,
+                       struct drm_file *file_priv)
+{
+	int ret = 0;
+	struct glamodrm_handle *gdrm;
+	unsigned int count;
+	drm_glamo_cmd_buffer_t *cbuf = data;
+	u16 *cmds;
+
+	gdrm = dev->dev_private;
+
+	count = cbuf->bufsz;
+
+	if ( count > PAGE_SIZE ) return -EINVAL;
+
+	cmds = kmalloc(count, GFP_KERNEL);
+	if ( cmds == NULL ) return -ENOMEM;
+	if ( copy_from_user(cmds, cbuf->buf, count) ) 	{
+		printk(KERN_WARNING "[glamo-drm] copy from user failed\n");
+		ret = -EINVAL;
+		goto cleanup;
+	}
+
+	/* Check the buffer isn't going to tell Glamo to enact naughtiness */
+	if ( !glamo_sanitize_buffer(cmds, count) ) {
+		printk(KERN_WARNING "[glamo-drm] sanitize buffer failed\n");
+		ret = -EINVAL;
+		goto cleanup;
+	}
+
+	/* Perform relocation, if necessary */
+	if ( cbuf->nobjs ) {
+		if ( glamo_do_relocation(gdrm, cbuf, cmds, dev, file_priv) )
+		{
+			printk(KERN_WARNING "[glamo-drm] Relocation failed\n");
+			ret = -EINVAL;
+			goto cleanup;
+		}
+	}
+
+	glamo_add_to_ring(gdrm, cmds, count);
+
+cleanup:
+	kfree(cmds);
+
+	return ret;
+}
+
+
+/* Return true for a legal sequence of commands, otherwise false */
+static int glamo_sanitize_burst(u16 base, u16 *cmds, unsigned int count)
+{
+	/* XXX FIXME TODO: Implementation... */
+	return 1;
+}
+
+
+static int glamo_relocate_burst(struct glamodrm_handle *gdrm,
+                                drm_glamo_cmd_burst_t *cbuf, u16 *data,
+                                struct drm_device *dev,
+                                struct drm_file *file_priv)
+{
+	u32 *handles;
+	int *offsets;
+	int nobjs =  cbuf->nobjs;
+	int i;
+
+	if ( nobjs > 32 ) return -EINVAL;	/* Get real... */
+
+	handles = kmalloc(nobjs*sizeof(u32), GFP_KERNEL);
+	if ( handles == NULL ) return -1;
+	if ( copy_from_user(handles, cbuf->objs, nobjs*sizeof(u32)) )
+		return -1;
+
+	offsets = kmalloc(nobjs*sizeof(int), GFP_KERNEL);
+	if ( offsets == NULL ) return -1;
+	if ( copy_from_user(offsets, cbuf->obj_pos, nobjs*sizeof(int)) )
+		return -1;
+
+	for ( i=0; i<nobjs; i++ ) {
+
+		u32 handle = handles[i];
+		int offset = offsets[i];
+		struct drm_gem_object *obj;
+		struct drm_glamo_gem_object *gobj;
+		u32 addr;
+		u16 addr_low, addr_high;
+
+		if ( offset > cbuf->bufsz ) {
+			printk(KERN_WARNING "[glamo-drm] Offset out of range"
+			                    " for this relocation!\n");
+			goto fail;
+		}
+
+		obj = drm_gem_object_lookup(dev, file_priv, handle);
+		if ( obj == NULL ) return -1;
+
+		/* Unref the object now, or it'll never get freed.
+		 * FIXME: This should really happen after the GPU has
+		 * finished executing these commands. */
+		drm_gem_object_unreference(obj);
+
+		gobj = obj->driver_private;
+		if ( gobj == NULL ) {
+			printk(KERN_WARNING "[glamo-drm] This object has no"
+			                    " private data!\n");
+			goto fail;
+		}
+
+		addr = GLAMO_OFFSET_FB + gobj->block->start;
+		addr_low = addr & 0xffff;
+		addr_high = (addr >> 16) & 0x7f;
+
+		/* FIXME: Should really check that the register is a
+		 * valid one for this relocation. */
+
+		*(data+(offset/2)+0) = addr_low;
+		*(data+(offset/2)+1) = addr_high;
+
+	}
+
+	kfree(handles);
+	kfree(offsets);
+	return 0;
+
+fail:
+	kfree(handles);
+	kfree(offsets);
+	return -1;
+}
+
+
+/* This is DRM_IOCTL_GLAMO_CMDBURST */
+int glamo_ioctl_cmdburst(struct drm_device *dev, void *data,
+                         struct drm_file *file_priv)
+{
+	int ret = 0;
+	struct glamodrm_handle *gdrm;
+	drm_glamo_cmd_burst_t *cbuf = data;
+	u16 *burst;
+	size_t burst_size;
+	size_t data_size;
+
+	gdrm = dev->dev_private;
+
+	data_size = cbuf->bufsz;
+	if ( data_size % 4 ) data_size += 2;
+	if ( data_size % 4 ) return -EINVAL;
+	burst_size = data_size + 4;  /* Add space for header */
+	if ( burst_size > PAGE_SIZE ) return -EINVAL;
+
+	burst = kmalloc(burst_size, GFP_KERNEL);
+	if ( burst == NULL ) return -ENOMEM;
+
+	/* Get data from userspace */
+	if ( copy_from_user(burst+2, cbuf->data, cbuf->bufsz) ) 	{
+		printk(KERN_WARNING "[glamo-drm] copy from user failed\n");
+		ret = -EINVAL;
+		goto cleanup;
+	}
+
+	/* Sanitise */
+	if ( !glamo_sanitize_burst(cbuf->base, burst+2, cbuf->bufsz) ) {
+		printk(KERN_WARNING "[glamo-drm] sanitize buffer failed\n");
+		ret = -EINVAL;
+		goto cleanup;
+	}
+
+	/* Relocate */
+	if ( cbuf->nobjs ) {
+		if ( glamo_relocate_burst(gdrm, cbuf, burst+2, dev, file_priv) )
+		{
+			printk(KERN_WARNING "[glamo-drm] Relocation failed\n");
+			ret = -EINVAL;
+			goto cleanup;
+		}
+	}
+
+	/* Add burst header */
+	burst[0] = 1<<15 | cbuf->base;
+	burst[1] = data_size / 2;  /* -> 2-byte words */
+	if ( burst[1] & 0x01 ) {
+		printk(KERN_CRIT "Burst not aligned!\n");
+		goto cleanup;
+	}
+
+	/* Zero-pad if necessary */
+	if ( data_size % 4 ) {
+		burst[burst_size-1] = 0x0000;
+	}
+
+	/* Add to command queue */
+	glamo_add_to_ring(gdrm, burst, burst_size);
+
+cleanup:
+	kfree(burst);
+
+	return ret;
+}
+
+
+int glamo_cmdq_init(struct glamodrm_handle *gdrm)
+{
+	unsigned int i;
+
+	init_MUTEX(&gdrm->add_to_ring);
+
+	/* Enable 2D and 3D */
+	glamo_engine_enable(gdrm->glamo_core, GLAMO_ENGINE_2D);
+	glamo_engine_reset(gdrm->glamo_core, GLAMO_ENGINE_2D);
+
+	/* Start by zeroing the command queue memory */
+	for ( i=0; i<GLAMO_CMDQ_SIZE; i+=2 ) {
+		iowrite16(0x0000, gdrm->cmdq_base+i);
+	}
+
+	glamo_engine_enable(gdrm->glamo_core, GLAMO_ENGINE_CMDQ);
+	glamo_engine_reset(gdrm->glamo_core, GLAMO_ENGINE_CMDQ);
+
+	/* Set up command queue location */
+	reg_write(gdrm, GLAMO_REG_CMDQ_BASE_ADDRL,
+					GLAMO_OFFSET_CMDQ & 0xffff);
+	reg_write(gdrm, GLAMO_REG_CMDQ_BASE_ADDRH,
+					(GLAMO_OFFSET_CMDQ >> 16) & 0x7f);
+
+	/* Length of command queue in 1k blocks, minus one */
+	reg_write(gdrm, GLAMO_REG_CMDQ_LEN, (GLAMO_CMDQ_SIZE >> 10)-1);
+	reg_write(gdrm, GLAMO_REG_CMDQ_WRITE_ADDRH, 0);
+	reg_write(gdrm, GLAMO_REG_CMDQ_WRITE_ADDRL, 0);
+	reg_write(gdrm, GLAMO_REG_CMDQ_CONTROL,
+	                                 1 << 12 |   /* Turbo flip (?) */
+	                                 5 << 8  |   /* no interrupt */
+	                                 8 << 4);    /* HQ threshold */
+
+	return 0;
+}
+
+
+int glamo_cmdq_shutdown(struct glamodrm_handle *gdrm)
+{
+	return 0;
+}
+
+
+void glamo_cmdq_suspend(struct glamodrm_handle *gdrm)
+{
+	/* Placeholder... */
+}
+
+
+void glamo_cmdq_resume(struct glamodrm_handle *gdrm)
+{
+	glamo_cmdq_init(gdrm);
+}
+
+
+/* Initialise an object's contents to zero.
+ * This is in glamo-cmdq.c in the hope that we can accelerate it later. */
+void glamo_cmdq_blank(struct glamodrm_handle *gdrm, struct drm_gem_object *obj)
+{
+	char __iomem *cookie;
+	struct drm_glamo_gem_object *gobj;
+	int i;
+
+	gobj = obj->driver_private;
+
+	cookie = ioremap(gdrm->vram->start + gobj->block->start, obj->size);
+	for ( i=0; i<obj->size; i+=2 ) {
+		iowrite16(0, cookie+i);
+	}
+	iounmap(cookie);
+}
diff --git a/drivers/mfd/glamo/glamo-cmdq.h b/drivers/mfd/glamo/glamo-cmdq.h
new file mode 100644
index 0000000..510d195
--- /dev/null
+++ b/drivers/mfd/glamo/glamo-cmdq.h
@@ -0,0 +1,49 @@
+/* Smedia Glamo 336x/337x command queue handling
+ *
+ * Copyright (c) 2008-2009 Thomas White <taw@bitwiz.org.uk>
+ * Copyright (c) 2009 Andreas Pokorny <andreas.pokorny@gmail.com>
+ * Based on xf86-video-glamo
+ * Copyright  2007 OpenMoko, Inc.
+ * Copyright © 2009 Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __GLAMO_CMDQ_H
+#define __GLAMO_CMDQ_H
+
+#include <drm/drmP.h>
+
+#include "glamo-drm-private.h"
+
+extern int glamo_ioctl_cmdbuf(struct drm_device *dev, void *data,
+			      struct drm_file *file_priv);
+extern int glamo_ioctl_cmdburst(struct drm_device *dev, void *data,
+			        struct drm_file *file_priv);
+extern void glamo_cmdq_blank(struct glamodrm_handle *gdrm,
+                             struct drm_gem_object *obj);
+
+extern int glamo_cmdq_init(struct glamodrm_handle *gdrm);
+extern int glamo_cmdq_shutdown(struct glamodrm_handle *gdrm);
+extern void glamo_cmdq_suspend(struct glamodrm_handle *gdrm);
+extern void glamo_cmdq_resume(struct glamodrm_handle *gdrm);
+
+extern int glamo_add_to_ring(struct glamodrm_handle *gdrm, u16 *addr,
+                             unsigned int count);
+
+#endif /* __GLAMO_CMDQ_H */
diff --git a/drivers/mfd/glamo/glamo-display.c b/drivers/mfd/glamo/glamo-display.c
new file mode 100644
index 0000000..34a665a
--- /dev/null
+++ b/drivers/mfd/glamo/glamo-display.c
@@ -0,0 +1,869 @@
+/*
+ * SMedia Glamo 336x/337x display
+ *
+ * Copyright (C) 2008-2009 Thomas White <taw@bitwiz.org.uk>
+ *
+ * Based on glamo-fb.c (C) 2007-2008 by Openmoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ *
+ * Based on intel_display.c and intel_crt.c from drivers/gpu/drm/i915
+ *  to which the following licence applies:
+ *
+ * Copyright © 2006-2007 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *	Eric Anholt <eric@anholt.net>
+ *
+ */
+
+#define DEBUG 1
+
+#include <drm/drmP.h>
+#include <drm/glamo_drm.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_crtc.h>
+
+#include "glamo-core.h"
+#include "glamo-drm-private.h"
+#include "glamo-regs.h"
+#include "glamo-kms-fb.h"
+#include "glamo-display.h"
+#include <linux/glamofb.h>
+
+
+#define GLAMO_LCD_WIDTH_MASK 0x03FF
+#define GLAMO_LCD_HEIGHT_MASK 0x03FF
+#define GLAMO_LCD_PITCH_MASK 0x07FE
+#define GLAMO_LCD_HV_TOTAL_MASK 0x03FF
+#define GLAMO_LCD_HV_RETR_START_MASK 0x03FF
+#define GLAMO_LCD_HV_RETR_END_MASK 0x03FF
+#define GLAMO_LCD_HV_RETR_DISP_START_MASK 0x03FF
+#define GLAMO_LCD_HV_RETR_DISP_END_MASK 0x03FF
+
+
+struct glamofb_par {
+	struct drm_device *dev;
+	struct drm_display_mode *our_mode;
+	struct glamo_framebuffer *glamo_fb;
+	int crtc_count;
+	/* crtc currently bound to this */
+	uint32_t crtc_ids[2];
+};
+
+
+static int reg_read_lcd(struct glamodrm_handle *gdrm, u_int16_t reg)
+{
+	int i = 0;
+
+	for (i = 0; i != 2; i++)
+		nop();
+
+	return ioread16(gdrm->lcd_base + reg);
+}
+
+
+static void reg_write_lcd(struct glamodrm_handle *gdrm,
+                          u_int16_t reg, u_int16_t val)
+{
+	int i = 0;
+
+	for (i = 0; i != 2; i++)
+		nop();
+
+	iowrite16(val, gdrm->lcd_base + reg);
+}
+
+
+static void reg_set_bit_mask_lcd(struct glamodrm_handle *gdrm,
+                                 u_int16_t reg, u_int16_t mask,
+                                 u_int16_t val)
+{
+	u_int16_t tmp;
+
+	val &= mask;
+
+	tmp = reg_read_lcd(gdrm, reg);
+	tmp &= ~mask;
+	tmp |= val;
+	reg_write_lcd(gdrm, reg, tmp);
+}
+
+
+/* Note that this has nothing at all to do with the engine command queue
+ * in glamo-cmdq.c */
+static inline int glamo_lcd_cmdq_empty(struct glamodrm_handle *gdrm)
+{
+	/* DGCMdQempty -- 1 == command queue is empty */
+	return reg_read_lcd(gdrm, GLAMO_REG_LCD_STATUS1) & (1 << 15);
+}
+
+
+/* call holding gfb->lock_cmd  when locking, until you unlock */
+int glamo_lcd_cmd_mode(struct glamodrm_handle *gdrm, int on)
+{
+	int timeout = 2000000;
+
+	dev_dbg(gdrm->dev, "glamofb_cmd_mode(on=%d)\n", on);
+	if (on) {
+
+		while ((!glamo_lcd_cmdq_empty(gdrm)) && (timeout--))
+			/* yield() */;
+		if (timeout < 0) {
+			printk(KERN_ERR "*************"
+			                " LCD command queue never got empty "
+			                "*************\n");
+			return -EIO;
+		}
+
+		/* display the entire frame then switch to command */
+		reg_write_lcd(gdrm, GLAMO_REG_LCD_COMMAND1,
+			  GLAMO_LCD_CMD_TYPE_DISP |
+			  GLAMO_LCD_CMD_DATA_FIRE_VSYNC);
+
+		/* wait until lcd idle */
+		timeout = 2000000;
+		while ((!reg_read_lcd(gdrm, GLAMO_REG_LCD_STATUS2) & (1 << 12))
+		          && (timeout--))
+			/* yield() */;
+		if (timeout < 0) {
+			printk(KERN_ERR"*************"
+				       " LCD never idle "
+				       "*************\n");
+			return -EIO;
+		}
+
+		mdelay(100);
+
+	} else {
+		/* RGB interface needs vsync/hsync */
+		int mode;
+		mode = reg_read_lcd(gdrm, GLAMO_REG_LCD_MODE3);
+		if ( mode & GLAMO_LCD_MODE3_RGB)
+			reg_write_lcd(gdrm, GLAMO_REG_LCD_COMMAND1,
+				  GLAMO_LCD_CMD_TYPE_DISP |
+				  GLAMO_LCD_CMD_DATA_DISP_SYNC);
+
+		reg_write_lcd(gdrm, GLAMO_REG_LCD_COMMAND1,
+			  GLAMO_LCD_CMD_TYPE_DISP |
+			  GLAMO_LCD_CMD_DATA_DISP_FIRE);
+	}
+
+	return 0;
+}
+
+
+static struct glamo_script lcd_init_script[] = {
+	{ GLAMO_REG_LCD_MODE1, 0x0020 },
+	/* no display rotation, no hardware cursor, no dither, no gamma,
+	 * no retrace flip, vsync low-active, hsync low active,
+	 * no TVCLK, no partial display, hw dest color from fb,
+	 * no partial display mode, LCD1, software flip,  */
+	{ GLAMO_REG_LCD_MODE2, 0x9020 },
+	  /* video flip, no ptr, no ptr, dhclk off,
+	   * normal mode,  no cpuif,
+	   * res, serial msb first, single fb, no fr ctrl,
+	   * cpu if bits all zero, no crc
+	   * 0000 0000 0010  0000 */
+	{ GLAMO_REG_LCD_MODE3, 0x0b40 },
+	  /* src data rgb565, res, 18bit rgb666
+	   * 000 01 011 0100 0000 */
+	{ GLAMO_REG_LCD_POLARITY, 0x440c },
+	  /* DE high active, no cpu/lcd if, cs0 force low, a0 low active,
+	   * np cpu if, 9bit serial data, sclk rising edge latch data
+	   * 01 00 0 100 0 000 01 0 0 */
+	/* The following values assume 640*480@16bpp */
+	/* FIXME: fb0 has not yet been allocated! */
+	{ GLAMO_REG_LCD_A_BASE1, PAGE_SIZE }, /* display A base address 15:0 */
+	{ GLAMO_REG_LCD_A_BASE2, 0x0000 }, /* display A base address 22:16 */
+	{ GLAMO_REG_LCD_B_BASE1, 0x6000 }, /* display B base address 15:0 */
+	{ GLAMO_REG_LCD_B_BASE2, 0x0009 }, /* display B base address 22:16 */
+	{ GLAMO_REG_LCD_CURSOR_BASE1, 0xC000 }, /* cursor base address 15:0 */
+	{ GLAMO_REG_LCD_CURSOR_BASE2, 0x0012 }, /* cursor base address 22:16 */
+	{ GLAMO_REG_LCD_COMMAND2, 0x0000 }, /* display page A */
+};
+
+
+static int glamo_run_lcd_script(struct glamodrm_handle *gdrm,
+                                struct glamo_script *script, int len)
+{
+	int i;
+
+	for (i = 0; i < len; i++) {
+		struct glamo_script *line = &script[i];
+
+		if (line->reg == 0xffff)
+			return 0;
+		else if (line->reg == 0xfffe)
+			msleep(line->val);
+		else
+			reg_write_lcd(gdrm, script[i].reg, script[i].val);
+	}
+
+	return 0;
+}
+
+
+extern void jbt6k74_action(int val);
+
+/* Power on/off */
+static void glamo_crtc_dpms(struct drm_crtc *crtc, int mode)
+{
+}
+
+
+static bool glamo_crtc_mode_fixup(struct drm_crtc *crtc,
+                                  struct drm_display_mode *mode,
+                                  struct drm_display_mode *adjusted_mode)
+{
+	return true;
+}
+
+
+static int glamo_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
+                                    struct drm_framebuffer *old_fb)
+{
+	struct glamodrm_handle *gdrm;
+	struct glamo_crtc *gcrtc;
+	struct glamo_framebuffer *gfb;
+	struct drm_gem_object *obj;
+	struct drm_glamo_gem_object *gobj;
+	u32 addr;
+	u16 addr_low, addr_high;
+
+	if (!crtc->fb) {
+		DRM_DEBUG("No FB bound\n");
+		return -EINVAL;
+	}
+
+	/* Dig out our handle */
+	gcrtc = to_glamo_crtc(crtc);
+	gdrm = gcrtc->gdrm;	/* Here it is! */
+
+	gfb = to_glamo_framebuffer(crtc->fb);
+	obj = gfb->obj;
+	gobj = obj->driver_private;
+
+	addr = GLAMO_OFFSET_FB + gobj->block->start;
+	addr_low = addr & 0xffff;
+	addr_high = ((addr >> 16) & 0x7f) | 0x4000;
+
+	glamo_lcd_cmd_mode(gdrm, 1);
+	reg_write_lcd(gdrm, GLAMO_REG_LCD_A_BASE1, addr_low);
+	reg_write_lcd(gdrm, GLAMO_REG_LCD_A_BASE2, addr_high);
+	glamo_lcd_cmd_mode(gdrm, 0);
+
+	return 0;
+}
+
+
+static int glamo_crtc_mode_set(struct drm_crtc *crtc,
+                               struct drm_display_mode *mode,
+                               struct drm_display_mode *adjusted_mode,
+                               int x, int y,
+                               struct drm_framebuffer *old_fb)
+{
+	struct glamodrm_handle *gdrm;
+	struct glamo_crtc *gcrtc;
+	int retr_start, retr_end, disp_start, disp_end;
+
+	/* Dig out our handle */
+	gcrtc = to_glamo_crtc(crtc);
+	gdrm = gcrtc->gdrm;	/* Here it is! */
+
+	glamo_lcd_cmd_mode(gdrm, 1);
+
+	glamo_engine_reclock(gdrm->glamo_core, GLAMO_ENGINE_LCD, mode->clock);
+	gdrm->saved_clock = mode->clock;
+
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_WIDTH,
+	                     GLAMO_LCD_WIDTH_MASK, mode->hdisplay);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_HEIGHT,
+	                     GLAMO_LCD_HEIGHT_MASK, mode->vdisplay);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_PITCH,
+	                     GLAMO_LCD_PITCH_MASK, mode->hdisplay*2);
+
+	/* Convert "X modeline timings" into "Glamo timings" */
+	retr_start = 0;
+	retr_end = retr_start + mode->hsync_end - mode->hsync_start;
+	disp_start = mode->htotal - mode->hsync_start;
+	disp_end = disp_start + mode->hdisplay;
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_HORIZ_TOTAL,
+	                     GLAMO_LCD_HV_TOTAL_MASK, mode->htotal);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_HORIZ_RETR_START,
+	                     GLAMO_LCD_HV_RETR_START_MASK, retr_start);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_HORIZ_RETR_END,
+	                     GLAMO_LCD_HV_RETR_END_MASK, retr_end);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_HORIZ_DISP_START,
+	                     GLAMO_LCD_HV_RETR_DISP_START_MASK, disp_start);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_HORIZ_DISP_END,
+	                     GLAMO_LCD_HV_RETR_DISP_END_MASK, disp_end);
+
+	/* The same in the vertical direction */
+	retr_start = 0;
+	retr_end = retr_start + mode->vsync_end - mode->vsync_start;
+	disp_start = mode->vtotal - mode->vsync_start;
+	disp_end = disp_start + mode->vdisplay;
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_VERT_TOTAL,
+	                     GLAMO_LCD_HV_TOTAL_MASK, mode->vtotal);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_VERT_RETR_START,
+	                     GLAMO_LCD_HV_RETR_START_MASK, retr_start);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_VERT_RETR_END,
+	                     GLAMO_LCD_HV_RETR_END_MASK, retr_end);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_VERT_DISP_START,
+	                     GLAMO_LCD_HV_RETR_DISP_START_MASK, disp_start);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_VERT_DISP_END,
+	                     GLAMO_LCD_HV_RETR_DISP_END_MASK, disp_end);
+
+	glamo_lcd_cmd_mode(gdrm, 0);
+
+	glamo_crtc_mode_set_base(crtc, 0, 0, old_fb);
+
+	return 0;
+}
+
+
+static void glamo_crtc_prepare(struct drm_crtc *crtc)
+{
+}
+
+
+static void glamo_crtc_commit(struct drm_crtc *crtc)
+{
+}
+
+
+static int glamo_crtc_cursor_set(struct drm_crtc *crtc,
+                                 struct drm_file *file_priv,
+                                 uint32_t handle,
+                                 uint32_t width, uint32_t height)
+{
+	return 0;
+}
+
+
+static int glamo_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)
+{
+	return 0;
+}
+
+
+static void glamo_crtc_gamma_set(struct drm_crtc *crtc, u16 *red, u16 *green,
+                                 u16 *blue, uint32_t size)
+{
+}
+
+
+static void glamo_crtc_destroy(struct drm_crtc *crtc)
+{
+	struct glamo_crtc *glamo_crtc = to_glamo_crtc(crtc);
+	drm_crtc_cleanup(crtc);
+	kfree(glamo_crtc);
+}
+
+
+static enum drm_connector_status
+glamo_connector_detect(struct drm_connector *connector)
+{
+	/* One hopes it hasn't been de-soldered... */
+	return connector_status_connected;
+}
+
+
+static void glamo_connector_destroy(struct drm_connector *connector)
+{
+	drm_sysfs_connector_remove(connector);
+	drm_connector_cleanup(connector);
+	kfree(connector);
+}
+
+
+static int glamo_connector_get_modes(struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+	struct glamo_fb_platform_data *fb_info;
+	struct glamo_output *goutput = to_glamo_output(connector);
+	struct glamodrm_handle *gdrm = goutput->gdrm;
+
+	/* Dig out the record which will tell us about the hardware */
+	fb_info = gdrm->glamo_core->pdata->fb_data;
+
+	mode = drm_mode_create(connector->dev);
+	if (!mode)
+		return 0;
+	/* Fill in 'mode' here */
+	mode->type = DRM_MODE_TYPE_DEFAULT | DRM_MODE_TYPE_PREFERRED;
+
+	/* Convert framebuffer timings into KMS timings */
+	mode->clock = 1000000000UL / fb_info->modes[0].pixclock; /* ps -> kHz */
+	mode->clock *= 1000; /* kHz -> Hz */
+	mode->hdisplay = fb_info->modes[0].xres;
+	mode->hsync_start = fb_info->modes[0].right_margin + mode->hdisplay;
+	mode->hsync_end = mode->hsync_start + fb_info->modes[0].hsync_len;
+	mode->htotal = mode->hsync_end + fb_info->modes[0].left_margin;
+	mode->hskew = 0;
+
+	mode->vdisplay = fb_info->modes[0].yres;
+	mode->vsync_start = fb_info->modes[0].lower_margin + mode->vdisplay;
+	mode->vsync_end = mode->vsync_start + fb_info->modes[0].vsync_len;
+	mode->vtotal = mode->vsync_end + fb_info->modes[0].upper_margin;
+	mode->vscan = 0;
+
+	/* Physical size */
+	mode->width_mm = fb_info->width;
+	mode->height_mm = fb_info->height;
+
+	drm_mode_set_name(mode);
+	drm_mode_probed_add(connector, mode);
+
+	return 1;	/* one mode, for now */
+}
+
+
+static int glamo_connector_set_property(struct drm_connector *connector,
+				  struct drm_property *property,
+				  uint64_t value)
+{
+	return 0;
+}
+
+
+static int glamo_connector_mode_valid(struct drm_connector *connector,
+                                      struct drm_display_mode *mode)
+{
+	if (mode->flags & DRM_MODE_FLAG_DBLSCAN)
+		return MODE_NO_DBLESCAN;
+
+	return MODE_OK;
+}
+
+
+struct drm_encoder *
+glamo_connector_best_encoder(struct drm_connector *connector)
+{
+	struct glamo_output *glamo_output = to_glamo_output(connector);
+	return &glamo_output->enc;
+}
+
+
+static void glamo_encoder_dpms(struct drm_encoder *encoder, int mode)
+{
+}
+
+
+static bool glamo_encoder_mode_fixup(struct drm_encoder *encoder,
+                                 struct drm_display_mode *mode,
+                                 struct drm_display_mode *adjusted_mode)
+{
+	return true;
+}
+
+
+void glamo_encoder_prepare(struct drm_encoder *encoder)
+{
+}
+
+
+void glamo_encoder_commit(struct drm_encoder *encoder)
+{
+}
+
+
+static void glamo_encoder_mode_set(struct drm_encoder *encoder,
+                               struct drm_display_mode *mode,
+                               struct drm_display_mode *adjusted_mode)
+{
+}
+
+
+static void glamo_encoder_destroy(struct drm_encoder *encoder)
+{
+	drm_encoder_cleanup(encoder);
+}
+
+
+static void glamo_framebuffer_destroy(struct drm_framebuffer *fb)
+{
+	struct glamo_framebuffer *glamo_fb = to_glamo_framebuffer(fb);
+	struct drm_device *dev = fb->dev;
+
+	drm_framebuffer_cleanup(fb);
+	mutex_lock(&dev->struct_mutex);
+	drm_gem_object_unreference(glamo_fb->obj);
+	mutex_unlock(&dev->struct_mutex);
+
+	kfree(glamo_fb);
+}
+
+static int glamo_framebuffer_create_handle(struct drm_framebuffer *fb,
+						struct drm_file *file_priv,
+						unsigned int *handle)
+{
+	struct glamo_framebuffer *glamo_fb = to_glamo_framebuffer(fb);
+	struct drm_gem_object *object = glamo_fb->obj;
+
+	return drm_gem_handle_create(file_priv, object, handle);
+}
+
+
+static const struct drm_framebuffer_funcs glamo_fb_funcs = {
+	.destroy = glamo_framebuffer_destroy,
+	.create_handle = glamo_framebuffer_create_handle,
+};
+
+
+int glamo_framebuffer_create(struct drm_device *dev,
+			     struct drm_mode_fb_cmd *mode_cmd,
+			     struct drm_framebuffer **fb,
+			     struct drm_gem_object *obj)
+{
+	struct glamo_framebuffer *glamo_fb;
+	int ret;
+
+	glamo_fb = kzalloc(sizeof(*glamo_fb), GFP_KERNEL);
+	if (!glamo_fb)
+		return -ENOMEM;
+
+	ret = drm_framebuffer_init(dev, &glamo_fb->base, &glamo_fb_funcs);
+	if (ret) {
+		DRM_ERROR("framebuffer init failed %d\n", ret);
+		return ret;
+	}
+
+	drm_helper_mode_fill_fb_struct(&glamo_fb->base, mode_cmd);
+
+	glamo_fb->obj = obj;
+
+	*fb = &glamo_fb->base;
+
+	return 0;
+}
+
+
+static struct drm_framebuffer *
+glamo_user_framebuffer_create(struct drm_device *dev,
+			      struct drm_file *filp,
+			      struct drm_mode_fb_cmd *mode_cmd)
+{
+	struct drm_gem_object *obj;
+	struct drm_framebuffer *fb;
+	int ret;
+
+	obj = drm_gem_object_lookup(dev, filp, mode_cmd->handle);
+	if (!obj)
+		return NULL;
+
+	ret = glamo_framebuffer_create(dev, mode_cmd, &fb, obj);
+	if (ret) {
+		drm_gem_object_unreference(obj);
+		return NULL;
+	}
+
+	return fb;
+}
+
+
+int glamo_fbchanged(struct drm_device *dev)
+{
+	return 0;
+}
+
+
+/* CRTC functions */
+static const struct drm_crtc_funcs glamo_crtc_funcs = {
+	.cursor_set = glamo_crtc_cursor_set,
+	.cursor_move = glamo_crtc_cursor_move,
+	.gamma_set = glamo_crtc_gamma_set,
+	.set_config = drm_crtc_helper_set_config,
+	.destroy = glamo_crtc_destroy,
+};
+
+
+/* CRTC helper functions */
+static const struct drm_crtc_helper_funcs glamo_crtc_helper_funcs = {
+	.dpms = glamo_crtc_dpms,
+	.mode_fixup = glamo_crtc_mode_fixup,
+	.mode_set = glamo_crtc_mode_set,
+	.mode_set_base = glamo_crtc_mode_set_base,
+	.prepare = glamo_crtc_prepare,
+	.commit = glamo_crtc_commit,
+};
+
+
+/* Connector functions */
+static const struct drm_connector_funcs glamo_connector_funcs = {
+	.detect = glamo_connector_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = glamo_connector_destroy,
+	.set_property = glamo_connector_set_property,
+};
+
+
+/* Connector helper functions */
+static const struct drm_connector_helper_funcs glamo_connector_helper_funcs = {
+	.mode_valid = glamo_connector_mode_valid,
+	.get_modes = glamo_connector_get_modes,
+	.best_encoder = glamo_connector_best_encoder,
+};
+
+
+/* Encoder functions */
+static const struct drm_encoder_funcs glamo_encoder_funcs = {
+	.destroy = glamo_encoder_destroy,
+};
+
+
+/* Encoder helper functions */
+static const struct drm_encoder_helper_funcs glamo_encoder_helper_funcs = {
+	.dpms = glamo_encoder_dpms,
+	.mode_fixup = glamo_encoder_mode_fixup,
+	.prepare = glamo_encoder_prepare,
+	.commit = glamo_encoder_commit,
+	.mode_set = glamo_encoder_mode_set,
+};
+
+
+/* Mode functions */
+static const struct drm_mode_config_funcs glamo_mode_funcs = {
+	.fb_create = glamo_user_framebuffer_create,
+	.fb_changed = glamo_fbchanged
+};
+
+
+static struct drm_mode_set kernelfb_mode;
+
+
+/* Restore's the kernel's fbcon mode, used for panic path */
+void glamo_display_restore(void)
+{
+	drm_crtc_helper_set_config(&kernelfb_mode);
+}
+
+
+static int glamo_display_panic(struct notifier_block *n, unsigned long ununsed,
+                               void *panic_str)
+{
+	DRM_ERROR("panic occurred, switching back to text console\n");
+
+	glamo_display_restore();
+	return 0;
+}
+
+
+static struct notifier_block paniced = {
+	.notifier_call = glamo_display_panic,
+};
+
+
+int glamo_display_init(struct drm_device *dev)
+{
+	struct glamodrm_handle *gdrm;
+	struct glamo_crtc *glamo_crtc;
+	struct glamo_output *glamo_output;
+	struct drm_connector *connector;
+	struct glamo_framebuffer *glamo_fb;
+	struct fb_info *info;
+	struct glamofb_par *par;
+	struct drm_mode_set *modeset;
+
+	gdrm = dev->dev_private;
+
+	/* Initial setup of the LCD controller */
+	glamo_engine_enable(gdrm->glamo_core, GLAMO_ENGINE_LCD);
+	glamo_engine_reset(gdrm->glamo_core, GLAMO_ENGINE_LCD);
+
+	glamo_run_lcd_script(gdrm, lcd_init_script,
+	                           ARRAY_SIZE(lcd_init_script));
+
+	drm_mode_config_init(dev);
+
+	dev->mode_config.min_width = 240;
+	dev->mode_config.min_height = 320;
+	dev->mode_config.max_width = 480;
+	dev->mode_config.max_height = 640;
+
+	dev->mode_config.funcs = (void *)&glamo_mode_funcs;
+
+	/* Initialise our CRTC object.
+	 * Only one connector per CRTC.  We know this: it's kind of soldered. */
+	glamo_crtc = kzalloc(sizeof(struct glamo_crtc)
+	                   + sizeof(struct drm_connector *), GFP_KERNEL);
+	if (glamo_crtc == NULL) return 1;
+	glamo_crtc->gdrm = gdrm;
+	glamo_crtc->blank_mode = DRM_MODE_DPMS_OFF;
+	drm_crtc_init(dev, &glamo_crtc->base, &glamo_crtc_funcs);
+	drm_crtc_helper_add(&glamo_crtc->base, &glamo_crtc_helper_funcs);
+
+	glamo_crtc->mode_set.crtc = &glamo_crtc->base;
+	glamo_crtc->mode_set.connectors =
+	                              (struct drm_connector **)(glamo_crtc + 1);
+	glamo_crtc->mode_set.num_connectors = 0;
+
+	/* Create our "output" object: consists of an output and an encoder */
+	glamo_output = kzalloc(sizeof(struct glamo_output), GFP_KERNEL);
+	if (glamo_output == NULL) return 1;
+	connector = &glamo_output->base;
+	glamo_output->gdrm = gdrm;
+
+	/* Initialise the connector */
+	drm_connector_init(dev, connector, &glamo_connector_funcs,
+	                   DRM_MODE_CONNECTOR_Unknown);
+	drm_sysfs_connector_add(connector);
+	connector->interlace_allowed = 0;
+	connector->doublescan_allowed = 0;
+
+	/* Initialise the encoder */
+	drm_encoder_init(dev, &glamo_output->enc, &glamo_encoder_funcs,
+	                 DRM_MODE_ENCODER_DAC);
+	glamo_output->enc.possible_crtcs = 1 << 0;
+	drm_mode_connector_attach_encoder(&glamo_output->base,
+	                                  &glamo_output->enc);
+
+	drm_encoder_helper_add(&glamo_output->enc, &glamo_encoder_helper_funcs);
+	drm_connector_helper_add(connector, &glamo_connector_helper_funcs);
+
+	drm_helper_initial_config(dev);
+
+	if (list_empty(&dev->mode_config.fb_kernel_list)) {
+		int ret, cols, cols_g;
+		cols_g = reg_read_lcd(gdrm, GLAMO_REG_LCD_MODE3) & 0xc000;
+		switch ( cols_g ) {
+		case GLAMO_LCD_SRC_RGB565 :
+			cols = GLAMO_FB_RGB565; break;
+		case GLAMO_LCD_SRC_ARGB1555 :
+			cols = GLAMO_FB_ARGB1555; break;
+		case GLAMO_LCD_SRC_ARGB4444 :
+			cols = GLAMO_FB_ARGB4444; break;
+		default :
+			printk(KERN_WARNING "Unrecognised LCD colour mode\n");
+			cols = GLAMO_FB_RGB565; break; /* Take a guess */
+		}
+		ret = glamofb_create(dev, 480, 640, 480, 640, cols, &glamo_fb);
+		if (ret) return -EINVAL;
+	}
+
+	info = glamo_fb->base.fbdev;
+	par = info->par;
+
+	modeset = &glamo_crtc->mode_set;
+	modeset->fb = &glamo_fb->base;
+	modeset->connectors[0] = connector;
+
+	par->crtc_ids[0] = glamo_crtc->base.base.id;
+
+	modeset->num_connectors = 1;
+	modeset->mode = modeset->crtc->desired_mode;
+
+	par->crtc_count = 1;
+
+	if (register_framebuffer(info) < 0)
+		return -EINVAL;
+
+	printk(KERN_INFO "[glamo-drm] fb%d: %s frame buffer device\n",
+	       info->node, info->fix.id);
+
+	/* Switch back to kernel console on panic */
+	kernelfb_mode = *modeset;
+	atomic_notifier_chain_register(&panic_notifier_list, &paniced);
+	printk(KERN_INFO "[glamo-drm] Registered panic notifier\n");
+
+	return 0;
+}
+
+
+void glamo_display_suspend(struct glamodrm_handle *gdrm)
+{
+	gdrm->saved_width = reg_read_lcd(gdrm, GLAMO_REG_LCD_WIDTH);
+	gdrm->saved_height = reg_read_lcd(gdrm, GLAMO_REG_LCD_HEIGHT);
+	gdrm->saved_pitch = reg_read_lcd(gdrm, GLAMO_REG_LCD_PITCH);
+	gdrm->saved_htotal = reg_read_lcd(gdrm, GLAMO_REG_LCD_HORIZ_TOTAL);
+	gdrm->saved_hrtrst = reg_read_lcd(gdrm, GLAMO_REG_LCD_HORIZ_RETR_START);
+	gdrm->saved_hrtren = reg_read_lcd(gdrm, GLAMO_REG_LCD_HORIZ_RETR_END);
+	gdrm->saved_hdspst = reg_read_lcd(gdrm, GLAMO_REG_LCD_HORIZ_DISP_START);
+	gdrm->saved_hdspen = reg_read_lcd(gdrm, GLAMO_REG_LCD_HORIZ_DISP_END);
+	gdrm->saved_vtotal = reg_read_lcd(gdrm, GLAMO_REG_LCD_VERT_TOTAL);
+	gdrm->saved_vrtrst = reg_read_lcd(gdrm, GLAMO_REG_LCD_VERT_RETR_START);
+	gdrm->saved_vrtren = reg_read_lcd(gdrm, GLAMO_REG_LCD_VERT_RETR_END);
+	gdrm->saved_vdspst = reg_read_lcd(gdrm, GLAMO_REG_LCD_VERT_DISP_START);
+	gdrm->saved_vdspen = reg_read_lcd(gdrm, GLAMO_REG_LCD_VERT_DISP_END);
+}
+
+
+void glamo_display_resume(struct glamodrm_handle *gdrm)
+{
+	glamo_engine_enable(gdrm->glamo_core, GLAMO_ENGINE_LCD);
+	glamo_engine_reset(gdrm->glamo_core, GLAMO_ENGINE_LCD);
+	glamo_run_lcd_script(gdrm, lcd_init_script,
+	                           ARRAY_SIZE(lcd_init_script));
+
+	/* Restore timings */
+	glamo_lcd_cmd_mode(gdrm, 1);
+	glamo_engine_reclock(gdrm->glamo_core, GLAMO_ENGINE_LCD,
+	                     gdrm->saved_clock);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_WIDTH, GLAMO_LCD_WIDTH_MASK,
+	                     gdrm->saved_width);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_HEIGHT, GLAMO_LCD_HEIGHT_MASK,
+	                     gdrm->saved_height);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_PITCH, GLAMO_LCD_PITCH_MASK,
+	                     gdrm->saved_pitch);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_HORIZ_TOTAL,
+	                     GLAMO_LCD_HV_TOTAL_MASK, gdrm->saved_htotal);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_HORIZ_RETR_START,
+	                     GLAMO_LCD_HV_RETR_START_MASK, gdrm->saved_hrtrst);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_HORIZ_RETR_END,
+	                     GLAMO_LCD_HV_RETR_END_MASK, gdrm->saved_hrtren);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_HORIZ_DISP_START,
+	                     GLAMO_LCD_HV_RETR_DISP_START_MASK,
+	                     gdrm->saved_hdspst);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_HORIZ_DISP_END,
+	                     GLAMO_LCD_HV_RETR_DISP_END_MASK,
+	                     gdrm->saved_hdspen);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_VERT_TOTAL,
+	                     GLAMO_LCD_HV_TOTAL_MASK, gdrm->saved_vtotal);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_VERT_RETR_START,
+	                     GLAMO_LCD_HV_RETR_START_MASK, gdrm->saved_vrtrst);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_VERT_RETR_END,
+	                     GLAMO_LCD_HV_RETR_END_MASK, gdrm->saved_vrtren);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_VERT_DISP_START,
+	                     GLAMO_LCD_HV_RETR_DISP_START_MASK,
+	                     gdrm->saved_vdspst);
+	reg_set_bit_mask_lcd(gdrm, GLAMO_REG_LCD_VERT_DISP_END,
+	                     GLAMO_LCD_HV_RETR_DISP_END_MASK,
+	                     gdrm->saved_vdspen);
+	glamo_lcd_cmd_mode(gdrm, 0);
+}
diff --git a/drivers/mfd/glamo/glamo-display.h b/drivers/mfd/glamo/glamo-display.h
new file mode 100644
index 0000000..d6f21bc
--- /dev/null
+++ b/drivers/mfd/glamo/glamo-display.h
@@ -0,0 +1,39 @@
+/* Smedia Glamo 336x/337x Display
+ *
+ * Copyright (c) 2008-2009 Thomas White <taw@bitwiz.org.uk>
+ *
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __GLAMO_DISPLAY_H
+#define __GLAMO_DISPLAY_H
+
+#include <drm/drmP.h>
+#include "glamo-drm-private.h"
+
+extern int glamo_display_init(struct drm_device *dev);
+
+extern int glamo_framebuffer_create(struct drm_device *dev,
+                                    struct drm_mode_fb_cmd *mode_cmd,
+                                    struct drm_framebuffer **fb,
+                                    struct drm_gem_object *obj);
+
+extern void glamo_display_suspend(struct glamodrm_handle *gdrm);
+extern void glamo_display_resume(struct glamodrm_handle *gdrm);
+
+#endif /* __GLAMO_DISPLAY_H */
diff --git a/drivers/mfd/glamo/glamo-drm-drv.c b/drivers/mfd/glamo/glamo-drm-drv.c
new file mode 100644
index 0000000..f30097e
--- /dev/null
+++ b/drivers/mfd/glamo/glamo-drm-drv.c
@@ -0,0 +1,444 @@
+/* Smedia Glamo 336x/337x Graphics Driver
+ *
+ * Copyright (C) 2009 Openmoko, Inc. Jorge Luis Zapata <turran@openmoko.com>
+ * Copyright (C) 2008-2009 Thomas White <taw@bitwiz.org.uk>
+ * Copyright (C) 2009 Andreas Pokorny <andreas.pokorny@gmail.com>
+ *
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <drm/drmP.h>
+#include <drm/glamo_drm.h>
+#include <linux/glamofb.h>
+
+#include "glamo-core.h"
+#include "glamo-cmdq.h"
+#include "glamo-buffer.h"
+#include "glamo-drm-private.h"
+#include "glamo-display.h"
+#include "glamo-kms-fb.h"
+#include "glamo-fence.h"
+
+#define DRIVER_AUTHOR           "Openmoko, Inc."
+#define DRIVER_NAME             "glamo-drm"
+#define DRIVER_DESC             "SMedia Glamo 3362"
+#define DRIVER_DATE             "20090614"
+
+
+static int glamo_ioctl_swap(struct drm_device *dev, void *data,
+			    struct drm_file *file_priv)
+{
+	printk(KERN_INFO "glamo_ioctl_swap\n");
+	return 0;
+}
+
+
+static int glamo_ioctl_gem_info(struct drm_device *dev, void *data,
+				struct drm_file *file_priv)
+{
+	printk(KERN_INFO "glamo_ioctl_gem_info\n");
+	return 0;
+}
+
+
+struct drm_ioctl_desc glamo_ioctls[] = {
+	DRM_IOCTL_DEF(DRM_GLAMO_CMDBUF, glamo_ioctl_cmdbuf, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_GLAMO_SWAP, glamo_ioctl_swap, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_GLAMO_CMDBURST, glamo_ioctl_cmdburst, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_GLAMO_GEM_INFO, glamo_ioctl_gem_info, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_GLAMO_GEM_CREATE, glamo_ioctl_gem_create, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_GLAMO_GEM_MMAP, glamo_ioctl_gem_mmap, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_GLAMO_GEM_PIN, glamo_ioctl_gem_pin, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_GLAMO_GEM_UNPIN, glamo_ioctl_gem_unpin, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_GLAMO_GEM_PREAD, glamo_ioctl_gem_pread, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_GLAMO_GEM_PWRITE, glamo_ioctl_gem_pwrite, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_GLAMO_GEM_WAIT_RENDERING,
+	              glamo_ioctl_wait_rendering, DRM_AUTH),
+};
+
+
+static int glamodrm_firstopen(struct drm_device *dev)
+{
+	DRM_DEBUG("\n");
+	return 0;
+}
+
+
+static int glamodrm_open(struct drm_device *dev, struct drm_file *fh)
+{
+	DRM_DEBUG("\n");
+	return 0;
+}
+
+
+static void glamodrm_preclose(struct drm_device *dev, struct drm_file *fh)
+{
+	DRM_DEBUG("\n");
+}
+
+static void glamodrm_postclose(struct drm_device *dev, struct drm_file *fh)
+{
+	DRM_DEBUG("\n");
+}
+
+
+static void glamodrm_lastclose(struct drm_device *dev)
+{
+	DRM_DEBUG("\n");
+}
+
+
+static int glamodrm_master_create(struct drm_device *dev,
+				  struct drm_master *master)
+{
+	DRM_DEBUG("\n");
+
+        return 0;
+}
+
+
+static void glamodrm_master_destroy(struct drm_device *dev,
+				    struct drm_master *master)
+{
+	DRM_DEBUG("\n");
+}
+
+
+static int glamodrm_load(struct drm_device *dev, unsigned long flags)
+{
+	struct glamodrm_handle *gdrm;
+	gdrm = dev->dev_private;
+
+	glamo_buffer_init(gdrm);
+	glamo_cmdq_init(gdrm);
+	glamo_fence_init(gdrm);
+	glamo_display_init(dev);
+
+	return 0;
+}
+
+
+static int glamodrm_unload(struct drm_device *dev)
+{
+	struct glamodrm_handle *gdrm;
+
+	gdrm = dev->dev_private;
+
+	glamo_engine_disable(gdrm->glamo_core, GLAMO_ENGINE_2D);
+	glamo_engine_disable(gdrm->glamo_core, GLAMO_ENGINE_3D);
+	glamo_buffer_final(gdrm);
+	glamo_fence_shutdown(gdrm);
+
+	return 0;
+}
+
+
+static struct vm_operations_struct glamodrm_gem_vm_ops = {
+	.fault = glamodrm_gem_fault,
+};
+
+static struct drm_driver glamodrm_drm_driver = {
+	.driver_features = DRIVER_IS_PLATFORM | DRIVER_GEM | DRIVER_MODESET,
+	.firstopen = glamodrm_firstopen,
+	.load = glamodrm_load,
+	.unload = glamodrm_unload,
+	.open = glamodrm_open,
+	.preclose = glamodrm_preclose,
+	.postclose = glamodrm_postclose,
+	.lastclose = glamodrm_lastclose,
+	.reclaim_buffers = drm_core_reclaim_buffers,
+	.get_map_ofs = drm_core_get_map_ofs,
+	.get_reg_ofs = drm_core_get_reg_ofs,
+	.master_create = glamodrm_master_create,
+	.master_destroy = glamodrm_master_destroy,
+	.gem_init_object = glamodrm_gem_init_object,
+	.gem_free_object = glamodrm_gem_free_object,
+	.gem_vm_ops = &glamodrm_gem_vm_ops,
+	.ioctls = glamo_ioctls,
+	.fops = {
+		.owner = THIS_MODULE,
+		.open = drm_open,
+		.release = drm_release,
+		.ioctl = drm_ioctl,
+		.mmap = drm_gem_mmap,
+		.poll = drm_poll,
+		.fasync = drm_fasync,
+	},
+	.major = 0,
+	.minor = 1,
+	.patchlevel = 0,
+	.name = DRIVER_NAME,
+	.desc = DRIVER_DESC,
+	.date = DRIVER_DATE,
+};
+
+
+static int glamodrm_probe(struct platform_device *pdev)
+{
+	int rc;
+	struct glamodrm_handle *gdrm;
+	struct glamo_core *core = dev_get_drvdata(pdev->dev.parent);
+
+	printk(KERN_INFO "[glamo-drm] SMedia Glamo Direct Rendering Support\n");
+
+	gdrm = kzalloc(sizeof(*gdrm), GFP_KERNEL);
+	if ( !gdrm )
+		return -ENOMEM;
+	platform_set_drvdata(pdev, gdrm);
+	gdrm->glamo_core = core;
+	gdrm->dev = &pdev->dev;
+
+	/* Find the command queue registers */
+	gdrm->reg = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+	                                         "glamo-cmdq-regs");
+	if ( !gdrm->reg ) {
+		dev_err(&pdev->dev, "Unable to find cmdq registers.\n");
+		rc = -ENOENT;
+		goto out_free;
+	}
+	gdrm->reg = request_mem_region(gdrm->reg->start,
+					  resource_size(gdrm->reg), pdev->name);
+	if ( !gdrm->reg ) {
+		dev_err(&pdev->dev, "failed to request MMIO region\n");
+		rc = -ENOENT;
+		goto out_free;
+	}
+	gdrm->reg_base = ioremap_nocache(gdrm->reg->start,
+	                                 resource_size(gdrm->reg));
+	if ( !gdrm->reg_base ) {
+		dev_err(&pdev->dev, "failed to ioremap() MMIO registers\n");
+		rc = -ENOENT;
+		goto out_release_regs;
+	}
+
+	/* Find the command queue itself */
+	gdrm->cmdq = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+	                                          "glamo-command-queue");
+	if ( !gdrm->cmdq ) {
+		dev_err(&pdev->dev, "Unable to find command queue.\n");
+		rc = -ENOENT;
+		goto out_unmap_regs;
+	}
+	gdrm->cmdq = request_mem_region(gdrm->cmdq->start,
+	                                resource_size(gdrm->cmdq), pdev->name);
+	if ( !gdrm->cmdq ) {
+		dev_err(&pdev->dev, "failed to request command queue region\n");
+		rc = -ENOENT;
+		goto out_unmap_regs;
+	}
+	gdrm->cmdq_base = ioremap_nocache(gdrm->cmdq->start,
+	                                  resource_size(gdrm->cmdq));
+	if ( !gdrm->cmdq_base ) {
+		dev_err(&pdev->dev, "failed to ioremap() command queue\n");
+		rc = -ENOENT;
+		goto out_release_cmdq;
+	}
+
+	/* Find the VRAM */
+	gdrm->vram = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+	                                          "glamo-fb-mem");
+	if ( !gdrm->vram ) {
+		dev_err(&pdev->dev, "Unable to find VRAM.\n");
+		rc = -ENOENT;
+		goto out_unmap_cmdq;
+	}
+	gdrm->vram = request_mem_region(gdrm->vram->start,
+	                                resource_size(gdrm->vram), pdev->name);
+	if ( !gdrm->vram ) {
+		dev_err(&pdev->dev, "failed to request VRAM region\n");
+		rc = -ENOENT;
+		goto out_unmap_cmdq;
+	}
+
+	/* Find the LCD controller */
+	gdrm->lcd_regs = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+	                                              "glamo-fb-regs");
+	if ( !gdrm->lcd_regs ) {
+		dev_err(&pdev->dev, "Unable to find LCD registers.\n");
+		rc = -ENOENT;
+		goto out_release_vram;
+	}
+	gdrm->lcd_regs = request_mem_region(gdrm->lcd_regs->start,
+	                                    resource_size(gdrm->lcd_regs),
+	                                    pdev->name);
+	if ( !gdrm->lcd_regs ) {
+		dev_err(&pdev->dev, "failed to request LCD registers\n");
+		rc = -ENOENT;
+		goto out_release_vram;
+	}
+	gdrm->lcd_base = ioremap_nocache(gdrm->lcd_regs->start,
+	                                 resource_size(gdrm->lcd_regs));
+	if ( !gdrm->lcd_base ) {
+		dev_err(&pdev->dev, "failed to ioremap() LCD registers\n");
+		rc = -ENOENT;
+		goto out_release_lcd;
+	}
+
+	/* Find the 2D engine */
+	gdrm->twod_regs = platform_get_resource(pdev, IORESOURCE_MEM, 4);
+	if ( !gdrm->twod_regs ) {
+		dev_err(&pdev->dev, "Unable to find 2D registers.\n");
+		rc = -ENOENT;
+		goto out_unmap_lcd;
+	}
+	gdrm->twod_regs = request_mem_region(gdrm->twod_regs->start,
+	                                     resource_size(gdrm->twod_regs),
+	                                     pdev->name);
+	if ( !gdrm->twod_regs ) {
+		dev_err(&pdev->dev, "failed to request 2D registers\n");
+		rc = -ENOENT;
+		goto out_unmap_lcd;
+	}
+	gdrm->twod_base = ioremap(gdrm->twod_regs->start,
+	                          resource_size(gdrm->twod_regs));
+	if ( !gdrm->twod_base ) {
+		dev_err(&pdev->dev, "failed to ioremap() 2D registers\n");
+		rc = -ENOENT;
+		goto out_release_2d;
+	}
+
+	/* Hook up IRQ handle for fence processing */
+	gdrm->twod_irq = platform_get_irq_byname(pdev, "glamo-2d-irq");
+
+	gdrm->vram_size = GLAMO_FB_SIZE;
+	printk(KERN_INFO "[glamo-drm] %lli bytes of VRAM\n",
+	                 (long long int)gdrm->vram_size);
+
+	/* Initialise DRM */
+	drm_platform_init(&glamodrm_drm_driver, pdev, (void *)gdrm);
+
+	return 0;
+
+out_release_2d:
+	release_mem_region(gdrm->twod_regs->start,
+	                   resource_size(gdrm->twod_regs));
+out_unmap_lcd:
+	iounmap(gdrm->lcd_base);
+out_release_lcd:
+	release_mem_region(gdrm->lcd_regs->start,
+	                   resource_size(gdrm->lcd_regs));
+out_release_vram:
+	release_mem_region(gdrm->vram->start, resource_size(gdrm->vram));
+out_unmap_cmdq:
+	iounmap(gdrm->cmdq_base);
+out_release_cmdq:
+	release_mem_region(gdrm->cmdq->start, resource_size(gdrm->cmdq));
+out_unmap_regs:
+	iounmap(gdrm->reg_base);
+out_release_regs:
+	release_mem_region(gdrm->reg->start, resource_size(gdrm->reg));
+out_free:
+	kfree(gdrm);
+	pdev->dev.driver_data = NULL;
+	return rc;
+}
+
+
+static int glamodrm_remove(struct platform_device *pdev)
+{
+	struct glamodrm_handle *gdrm = platform_get_drvdata(pdev);
+
+	glamo_buffer_final(gdrm);
+	glamo_cmdq_shutdown(gdrm);
+
+	drm_exit(&glamodrm_drm_driver);
+
+	platform_set_drvdata(pdev, NULL);
+
+	/* Release registers */
+	iounmap(gdrm->reg_base);
+	release_mem_region(gdrm->reg->start, resource_size(gdrm->reg));
+
+	/* Release VRAM */
+	release_mem_region(gdrm->vram->start, resource_size(gdrm->vram));
+
+	/* Release command queue */
+	iounmap(gdrm->cmdq_base);
+	release_mem_region(gdrm->cmdq->start, resource_size(gdrm->cmdq));
+
+	/* Release 2D engine  */
+	iounmap(gdrm->twod_base);
+	release_mem_region(gdrm->twod_regs->start,
+	                   resource_size(gdrm->twod_regs));
+
+	kfree(gdrm);
+
+	return 0;
+}
+
+
+static int glamodrm_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct glamodrm_handle *gdrm = platform_get_drvdata(pdev);
+
+	glamo_kmsfb_suspend(gdrm);
+	glamo_display_suspend(gdrm);
+	glamo_cmdq_suspend(gdrm);
+
+	/* glamo_core.c will suspend the engines for us */
+
+	return 0;
+}
+
+
+static int glamodrm_resume(struct platform_device *pdev)
+{
+	struct glamodrm_handle *gdrm = platform_get_drvdata(pdev);
+
+	glamo_cmdq_resume(gdrm);
+	glamo_display_resume(gdrm);
+	glamo_kmsfb_resume(gdrm);
+
+	return 0;
+}
+
+
+static struct platform_driver glamodrm_driver = {
+	.probe          = glamodrm_probe,
+	.remove         = glamodrm_remove,
+	.suspend	= glamodrm_suspend,
+	.resume		= glamodrm_resume,
+	.driver         = {
+		.name   = "glamo-fb",
+		.owner  = THIS_MODULE,
+	},
+};
+
+
+static int __devinit glamodrm_init(void)
+{
+	glamodrm_drm_driver.num_ioctls = DRM_ARRAY_SIZE(glamo_ioctls);
+	return platform_driver_register(&glamodrm_driver);
+}
+
+
+static void __exit glamodrm_exit(void)
+{
+	platform_driver_unregister(&glamodrm_driver);
+}
+
+
+module_init(glamodrm_init);
+module_exit(glamodrm_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
diff --git a/drivers/mfd/glamo/glamo-drm-private.h b/drivers/mfd/glamo/glamo-drm-private.h
new file mode 100644
index 0000000..7949a2e
--- /dev/null
+++ b/drivers/mfd/glamo/glamo-drm-private.h
@@ -0,0 +1,156 @@
+/* Smedia Glamo 336x/337x DRM private bits
+ *
+ * Copyright (C) 2008-2009 Thomas White <taw@bitwiz.org.uk>
+ * Copyright (C) 2009 Andreas Pokorny <andreas.pokorny@gmail.com>
+ * Based on xf86-video-glamo
+ * Copyright  2007 OpenMoko, Inc.
+ * Copyright © 2009 Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __GLAMO_DRMPRIV_H
+#define __GLAMO_DRMPRIV_H
+
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/semaphore.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+
+#include "glamo-core.h"
+
+
+/* Memory to allocate for the framebuffer.
+ * The rest is reserved for the DRM memory manager */
+#define GLAMO_FRAMEBUFFER_ALLOCATION (2*480*640)
+
+
+struct glamodrm_handle {
+
+	/* This device */
+	struct device *dev;
+
+	/* The parent device handle */
+	struct glamo_core *glamo_core;
+
+	/* Framebuffer handle for the console (i.e. /dev/fb0) */
+	struct fb_info *fb;
+
+	/* Command queue registers */
+	struct resource *reg;
+	char __iomem *reg_base;
+
+	/* VRAM region */
+	struct resource *vram;
+
+	/* Command queue region */
+	struct resource *cmdq;
+	char __iomem *cmdq_base;
+
+	/* LCD controller registers */
+	struct resource *lcd_regs;
+	char __iomem *lcd_base;
+
+	/* 2D engine registers and IRQ */
+	struct resource *twod_regs;
+	char __iomem *twod_base;
+	unsigned int twod_irq;
+
+	ssize_t vram_size;
+
+	/* Memory management */
+	struct drm_mm *mmgr;
+
+	/* semaphore against concurrent ioctl */
+	struct semaphore add_to_ring;
+
+	/* Saved state */
+	u_int16_t saved_clock;
+	u_int16_t saved_width;
+	u_int16_t saved_height;
+	u_int16_t saved_pitch;
+	u_int16_t saved_htotal;
+	u_int16_t saved_hrtrst;
+	u_int16_t saved_hrtren;
+	u_int16_t saved_hdspst;
+	u_int16_t saved_hdspen;
+	u_int16_t saved_vtotal;
+	u_int16_t saved_vrtrst;
+	u_int16_t saved_vrtren;
+	u_int16_t saved_vdspst;
+	u_int16_t saved_vdspen;
+
+	/* Fencing */
+	atomic_t curr_seq;              /* The last used stamp number */
+	struct list_head fence_list;    /* List of active fences */
+	rwlock_t fence_list_lock;       /* Lock to protect fence_list */
+	wait_queue_head_t fence_queue;  /* Waitqueue */
+	struct tasklet_struct fence_tl; /* Tasklet for fence IRQ */
+
+	/* A scratch block */
+	struct drm_mm_node *scratch;
+};
+
+
+/* Private data.  This is where we keep our memory management bits */
+struct drm_glamo_gem_object {
+	struct drm_gem_object *obj;	/* The GEM object this refers to */
+	struct drm_mm_node *block;	/* Block handle for drm_mm */
+	uint64_t mmap_offset;
+};
+
+
+struct glamo_crtc {
+	struct drm_crtc base;
+	struct glamodrm_handle *gdrm;
+	/* a mode_set for fbdev users on this crtc */
+	struct drm_mode_set mode_set;
+	int blank_mode;
+};
+
+
+struct glamo_framebuffer {
+	struct drm_framebuffer base;
+	struct drm_gem_object *obj;
+};
+
+
+struct glamo_output {
+	struct drm_connector base;
+	struct drm_encoder enc;
+	struct glamodrm_handle *gdrm;
+};
+
+
+/* Colour mode for KMS framebuffer */
+enum {
+	GLAMO_FB_RGB565,
+	GLAMO_FB_ARGB1555,
+	GLAMO_FB_ARGB4444
+};
+
+
+#define to_glamo_crtc(x) container_of(x, struct glamo_crtc, base)
+#define to_glamo_output(x) container_of(x, struct glamo_output, base)
+#define enc_to_glamo_output(x) container_of(x, struct glamo_output, enc)
+#define to_glamo_framebuffer(x) container_of(x, struct glamo_framebuffer, base)
+
+
+#endif /* __GLAMO_DRMPRIV_H */
diff --git a/drivers/mfd/glamo/glamo-fence.c b/drivers/mfd/glamo/glamo-fence.c
new file mode 100644
index 0000000..9119675
--- /dev/null
+++ b/drivers/mfd/glamo/glamo-fence.c
@@ -0,0 +1,330 @@
+/*
+ * SMedia Glamo 336x/337x fence objects
+ *
+ * Copyright (c) 2009 Thomas White <taw@bitwiz.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ * Loosely based on radeon_fence.c, to which the following notice applies:
+ *
+ * Copyright 2009 Jerome Glisse.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ */
+/*
+ * Authors:
+ *    Jerome Glisse <glisse@freedesktop.org>
+ *    Dave Airlie
+ */
+
+
+#include <drm/drmP.h>
+#include <drm/glamo_drm.h>
+#include <linux/kernel.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/lockdep.h>
+
+#include "glamo-drm-private.h"
+#include "glamo-regs.h"
+#include "glamo-core.h"
+#include "glamo-cmdq.h"
+
+
+static struct lock_class_key glamo_fence_lock_key;
+
+
+struct glamo_fence
+{
+	struct list_head list;
+	uint16_t               seq;       /* Wait for at least this ID */
+	int                    signalled; /* Non-zero when fence has passed */
+	struct glamodrm_handle *gdrm;
+};
+
+
+static void glamo_fence_emit(struct glamo_fence *fence)
+{
+	u16 fring[6];
+
+	fring[0] = 0x8000 | GLAMO_REG_2D_ID1;
+	fring[1] = 3;
+	fence->seq = atomic_inc_return(&fence->gdrm->curr_seq);
+	if ( fence->seq > 1<<14 ) {
+		atomic_set(&fence->gdrm->curr_seq, 0);
+		fence->seq = atomic_inc_return(&fence->gdrm->curr_seq);
+	}
+	fring[2] = 1<<15 | fence->seq;
+	fring[3] = 0;  /* Unused */
+	fring[4] = 0;  /* Unused */
+	fring[5] = 0;  /* Padding */
+
+	glamo_add_to_ring(fence->gdrm, fring, 12);
+}
+
+
+static void glamo_fence_enable(struct glamodrm_handle *gdrm)
+{
+	enable_irq( GLAMO_IRQ_2D);
+}
+
+
+static inline u16 reg_read_2d(struct glamodrm_handle *gdrm, u_int16_t reg)
+{
+	/* For command queue, the address is given relative to
+	 * the overall base of Glamo.  This isn't the case here. */
+	return ioread16(gdrm->twod_base + reg-GLAMO_REGOFS_2D);
+}
+
+
+static inline u16 reg_read_cmdq(struct glamodrm_handle *gdrm, u_int16_t reg)
+{
+	return ioread16(gdrm->reg_base + reg);
+}
+
+
+static void glamo_cmdq_wait(struct glamodrm_handle *gdrm,
+                            enum glamo_engine engine)
+{
+	u16 mask, val, status;
+	int i;
+
+	switch (engine)
+	{
+		case GLAMO_ENGINE_ALL:
+			mask = 1 << 2;
+			val  = mask;
+			break;
+		default:
+			return;
+	}
+
+	for ( i=0; i<1000; i++ ) {
+		status = reg_read_cmdq(gdrm, GLAMO_REG_CMDQ_STATUS);
+		if ((status & mask) == val) break;
+		mdelay(1);
+	}
+	if ( i == 1000 ) {
+		size_t ring_read;
+		printk(KERN_WARNING "[glamo-drm] CmdQ timeout!\n");
+		printk(KERN_WARNING "[glamo-drm] status = %x\n", status);
+		ring_read = reg_read_cmdq(gdrm, GLAMO_REG_CMDQ_READ_ADDRL);
+		ring_read |= ((reg_read_cmdq(gdrm, GLAMO_REG_CMDQ_READ_ADDRH)
+				& 0x7) << 16);
+		printk(KERN_INFO "[glamo-drm] ring_read now 0x%x\n",
+				 ring_read);
+	}
+}
+
+
+static irqreturn_t glamo_fence_irq_handler(int irq, void *data)
+{
+	struct glamodrm_handle *gdrm = data;
+	if (!gdrm) return IRQ_NONE;
+	tasklet_schedule(&gdrm->fence_tl);
+	return IRQ_HANDLED;
+}
+
+
+/* This is nasty.  I'm sorry. */
+static void glamo_fence_debodge(struct glamodrm_handle *gdrm)
+{
+	struct list_head *tmp;
+
+	printk(KERN_ERR "[glamo-drm] Attempting to recover...\n");
+
+	glamo_cmdq_wait(gdrm, GLAMO_ENGINE_ALL);
+	glamo_engine_reset(gdrm->glamo_core, GLAMO_ENGINE_2D);
+
+	read_lock(&gdrm->fence_list_lock);
+	list_for_each(tmp, &gdrm->fence_list) {
+
+		struct glamo_fence *fence;
+
+		fence = list_entry(tmp, struct glamo_fence, list);
+
+		if ( fence->signalled != 1 ) {
+			printk(KERN_ERR "[glamo-drm] Fence seq#%i was not"
+			                " signalled\n", fence->seq);
+		}
+		fence->signalled = 1;
+
+	}
+	read_unlock(&gdrm->fence_list_lock);
+
+	wake_up_all(&gdrm->fence_queue);
+}
+
+
+static void glamo_fence_tl(unsigned long data)
+{
+	struct glamodrm_handle *gdrm = (struct glamodrm_handle *)data;
+	int wake = 0;
+	u16 seq;
+	struct list_head *tmp;
+
+	seq = reg_read_2d(gdrm, GLAMO_REG_2D_ID1) & 0x7fff;
+
+	read_lock(&gdrm->fence_list_lock);
+	list_for_each(tmp, &gdrm->fence_list) {
+
+		struct glamo_fence *fence;
+
+		fence = list_entry(tmp, struct glamo_fence, list);
+		if ( seq >= fence->seq ) {
+			fence->signalled = 1;
+			wake = 1;
+		}
+
+	}
+	read_unlock(&gdrm->fence_list_lock);
+
+	if ( wake ) wake_up_all(&gdrm->fence_queue);
+}
+
+
+static struct glamo_fence *glamo_fence_new(struct glamodrm_handle *gdrm)
+{
+	struct glamo_fence *fence;
+	unsigned long irq_flags;
+
+	fence = kmalloc(sizeof(*fence), GFP_KERNEL);
+	fence->signalled = 0;
+	fence->gdrm = gdrm;
+
+	/* Add to list */
+	write_lock_irqsave(&gdrm->fence_list_lock, irq_flags);
+	list_add(&fence->list, &gdrm->fence_list);
+	write_unlock_irqrestore(&gdrm->fence_list_lock, irq_flags);
+
+	return fence;
+}
+
+
+static struct glamo_fence *glamo_fence_destroy(struct glamo_fence *fence)
+{
+	unsigned long irq_flags;
+	struct glamodrm_handle *gdrm = fence->gdrm;
+
+	/* Remove from list */
+	write_lock_irqsave(&gdrm->fence_list_lock, irq_flags);
+	list_del(&fence->list);
+	write_unlock_irqrestore(&gdrm->fence_list_lock, irq_flags);
+
+	kfree(fence);
+
+	return fence;
+}
+
+
+int glamo_ioctl_wait_rendering(struct drm_device *dev, void *data,
+                               struct drm_file *file_priv)
+{
+	struct glamodrm_handle *gdrm;
+	struct drm_glamo_gem_wait_rendering *args = data;
+	struct glamo_fence *fence;
+	int r;
+
+	gdrm = dev->dev_private;
+
+	if ( !args->have_handle ) {
+		glamo_cmdq_wait(gdrm, GLAMO_ENGINE_ALL);
+		return 0;
+	}
+
+	fence = glamo_fence_new(gdrm);
+	if ( fence == NULL ) {
+		printk(KERN_WARNING "[glamo-drm] Couldn't allocate fence -"
+		                    " falling back to busy wait.\n");
+		glamo_cmdq_wait(gdrm, GLAMO_ENGINE_ALL);
+		return 0;
+	}
+
+	glamo_fence_emit(fence);
+
+	/* Wait... */
+	r = wait_event_interruptible_timeout(gdrm->fence_queue,
+	                                     fence->signalled, HZ);
+	if ( r == 0 ) {
+		printk(KERN_ERR "[glamo-drm] Timeout!\n");
+		glamo_fence_debodge(gdrm);
+	}
+
+	glamo_fence_destroy(fence);
+
+	return 0;
+}
+
+
+void glamo_fence_init(struct glamodrm_handle *gdrm)
+{
+	unsigned long irq_flags;
+	int r;
+
+	if ( gdrm->twod_irq == 0 ) {
+		printk(KERN_ERR "[glamo-drm] Don't know which IRQ to use!\n");
+		return;
+	}
+
+	gdrm->fence_list_lock = __RW_LOCK_UNLOCKED(gdrm->fence_list_lock);
+	lockdep_set_class(&gdrm->fence_list_lock, &glamo_fence_lock_key);
+	init_waitqueue_head(&gdrm->fence_queue);
+
+	atomic_set(&gdrm->curr_seq, 0);
+
+	write_lock_irqsave(&gdrm->fence_list_lock, irq_flags);
+	INIT_LIST_HEAD(&gdrm->fence_list);
+	write_unlock_irqrestore(&gdrm->fence_list_lock, irq_flags);
+
+	tasklet_init(&gdrm->fence_tl, glamo_fence_tl, (unsigned long)gdrm);
+
+	r = request_irq(gdrm->twod_irq, glamo_fence_irq_handler,
+	                IRQF_SHARED, "glamo-fence", gdrm);
+	if ( r ) {
+		printk(KERN_ERR "[glamo-drm] Failed to register irq.\n");
+		return;
+	}
+
+	glamo_fence_enable(gdrm);
+}
+
+
+void glamo_fence_shutdown(struct glamodrm_handle *gdrm)
+{
+	free_irq(gdrm->twod_irq, gdrm);
+	wake_up_all(&gdrm->fence_queue);
+	tasklet_kill(&gdrm->fence_tl);
+}
diff --git a/drivers/mfd/glamo/glamo-fence.h b/drivers/mfd/glamo/glamo-fence.h
new file mode 100644
index 0000000..deda995
--- /dev/null
+++ b/drivers/mfd/glamo/glamo-fence.h
@@ -0,0 +1,34 @@
+/*
+ * SMedia Glamo 336x/337x fence objects
+ *
+ * Copyright (c) 2009 Thomas White <taw@bitwiz.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __GLAMO_FENCE_H
+#define __GLAMO_FENCE_H
+
+#include <drm/drmP.h>
+
+#include "glamo-drm-private.h"
+
+extern void glamo_fence_init(struct glamodrm_handle *gdrm);
+extern void glamo_fence_shutdown(struct glamodrm_handle *gdrm);
+
+extern int glamo_ioctl_wait_rendering(struct drm_device *dev, void *data,
+                                      struct drm_file *file_priv);
+
+#endif /* __GLAMO_FENCE_H */
diff --git a/drivers/mfd/glamo/glamo-kms-fb.c b/drivers/mfd/glamo/glamo-kms-fb.c
new file mode 100644
index 0000000..61cd605
--- /dev/null
+++ b/drivers/mfd/glamo/glamo-kms-fb.c
@@ -0,0 +1,540 @@
+/*
+ * SMedia Glamo 336x/337x KMS Framebuffer
+ *
+ * Copyright (C) 2009 Thomas White <taw@bitwiz.org.uk>
+ *
+ * Based on glamo-fb.c (C) 2007-2008 by Openmoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ *
+ * Based on intel_fb.c from drivers/gpu/drm/i915
+ *  to which the following licence applies:
+ *
+ * Copyright © 2006-2007 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *	Eric Anholt <eric@anholt.net>
+ *
+ */
+
+
+#include <drm/drmP.h>
+#include <drm/glamo_drm.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_crtc.h>
+
+#include "glamo-core.h"
+#include "glamo-drm-private.h"
+#include "glamo-display.h"
+#include "glamo-buffer.h"
+
+
+struct glamofb_par {
+	struct drm_device *dev;
+	struct drm_display_mode *our_mode;
+	struct glamo_framebuffer *glamo_fb;
+	int crtc_count;
+	/* crtc currently bound to this */
+	uint32_t crtc_ids[2];
+};
+
+
+static int glamofb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			unsigned blue, unsigned transp,
+			struct fb_info *info)
+{
+	struct glamofb_par *par = info->par;
+	struct drm_device *dev = par->dev;
+	struct drm_crtc *crtc;
+	int i;
+
+	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+		struct glamo_crtc *glamo_crtc = to_glamo_crtc(crtc);
+		struct drm_mode_set *modeset = &glamo_crtc->mode_set;
+		struct drm_framebuffer *fb = modeset->fb;
+
+		for (i = 0; i < par->crtc_count; i++)
+			if (crtc->base.id == par->crtc_ids[i])
+				break;
+
+		if (i == par->crtc_count)
+			continue;
+
+
+		if (regno > 255)
+			return 1;
+
+		if (regno < 16) {
+			switch (fb->depth) {
+			case 15:
+				fb->pseudo_palette[regno] = ((red & 0xf800) >> 1) |
+					((green & 0xf800) >>  6) |
+					((blue & 0xf800) >> 11);
+				break;
+			case 16:
+				fb->pseudo_palette[regno] = (red & 0xf800) |
+					((green & 0xfc00) >>  5) |
+					((blue  & 0xf800) >> 11);
+				break;
+			case 24:
+			case 32:
+				fb->pseudo_palette[regno] = ((red & 0xff00) << 8) |
+					(green & 0xff00) |
+					((blue  & 0xff00) >> 8);
+				break;
+			}
+		}
+	}
+	return 0;
+}
+
+static int glamofb_check_var(struct fb_var_screeninfo *var,
+			struct fb_info *info)
+{
+	struct glamofb_par *par = info->par;
+	struct glamo_framebuffer *glamo_fb = par->glamo_fb;
+	struct drm_framebuffer *fb = &glamo_fb->base;
+	int depth;
+
+	/* Need to resize the fb object !!! */
+	if (var->xres > fb->width || var->yres > fb->height) {
+		DRM_ERROR("Cannot resize framebuffer object (%dx%d > %dx%d)\n",
+		          var->xres,var->yres,fb->width,fb->height);
+		DRM_ERROR("Need resizing code.\n");
+		return -EINVAL;
+	}
+
+	switch (var->bits_per_pixel) {
+	case 16:
+		depth = (var->green.length == 6) ? 16 : 15;
+		break;
+	case 32:
+		depth = (var->transp.length > 0) ? 32 : 24;
+		break;
+	default:
+		depth = var->bits_per_pixel;
+		break;
+	}
+
+	switch (depth) {
+	case 16:
+		var->red.offset = 11;
+		var->green.offset = 5;
+		var->blue.offset = 0;
+		var->red.length = 5;
+		var->green.length = 6;
+		var->blue.length = 5;
+		var->transp.length = 0;
+		var->transp.offset = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* this will let fbcon do the mode init */
+/* FIXME: take mode config lock? */
+static int glamofb_set_par(struct fb_info *info)
+{
+	struct glamofb_par *par = info->par;
+	struct drm_device *dev = par->dev;
+	struct fb_var_screeninfo *var = &info->var;
+	int i;
+
+	DRM_DEBUG("%d %d\n", var->xres, var->pixclock);
+
+	if (var->pixclock != -1) {
+
+		DRM_ERROR("PIXEL CLOCK SET\n");
+		return -EINVAL;
+	} else {
+		struct drm_crtc *crtc;
+		int ret;
+
+		list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+			struct glamo_crtc *glamo_crtc = to_glamo_crtc(crtc);
+
+			for (i = 0; i < par->crtc_count; i++)
+				if (crtc->base.id == par->crtc_ids[i])
+					break;
+
+			if (i == par->crtc_count)
+				continue;
+
+			if (crtc->fb == glamo_crtc->mode_set.fb) {
+				mutex_lock(&dev->mode_config.mutex);
+				ret = crtc->funcs->set_config(&glamo_crtc->mode_set);
+				mutex_unlock(&dev->mode_config.mutex);
+				if (ret)
+					return ret;
+			}
+		}
+		return 0;
+	}
+}
+
+static int glamofb_pan_display(struct fb_var_screeninfo *var,
+				struct fb_info *info)
+{
+	struct glamofb_par *par = info->par;
+	struct drm_device *dev = par->dev;
+	struct drm_mode_set *modeset;
+	struct drm_crtc *crtc;
+	struct glamo_crtc *glamo_crtc;
+	int ret = 0;
+	int i;
+
+	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+		for (i = 0; i < par->crtc_count; i++)
+			if (crtc->base.id == par->crtc_ids[i])
+				break;
+
+		if (i == par->crtc_count)
+			continue;
+
+		glamo_crtc = to_glamo_crtc(crtc);
+		modeset = &glamo_crtc->mode_set;
+
+		modeset->x = var->xoffset;
+		modeset->y = var->yoffset;
+
+		if (modeset->num_connectors) {
+			mutex_lock(&dev->mode_config.mutex);
+			ret = crtc->funcs->set_config(modeset);
+			mutex_unlock(&dev->mode_config.mutex);
+			if (!ret) {
+				info->var.xoffset = var->xoffset;
+				info->var.yoffset = var->yoffset;
+			}
+		}
+	}
+
+	return ret;
+}
+
+static void glamofb_on(struct fb_info *info)
+{
+	struct glamofb_par *par = info->par;
+	struct drm_device *dev = par->dev;
+	struct drm_crtc *crtc;
+	struct drm_encoder *encoder;
+	int i;
+
+	/*
+	 * For each CRTC in this fb, find all associated encoders
+	 * and turn them off, then turn off the CRTC.
+	 */
+	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+		struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;
+
+		for (i = 0; i < par->crtc_count; i++)
+			if (crtc->base.id == par->crtc_ids[i])
+				break;
+
+		crtc_funcs->dpms(crtc, DRM_MODE_DPMS_ON);
+
+		/* Found a CRTC on this fb, now find encoders */
+		list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
+			if (encoder->crtc == crtc) {
+				struct drm_encoder_helper_funcs *encoder_funcs;
+				encoder_funcs = encoder->helper_private;
+				encoder_funcs->dpms(encoder, DRM_MODE_DPMS_ON);
+			}
+		}
+	}
+}
+
+static void glamofb_off(struct fb_info *info, int dpms_mode)
+{
+	struct glamofb_par *par = info->par;
+	struct drm_device *dev = par->dev;
+	struct drm_crtc *crtc;
+	struct drm_encoder *encoder;
+	int i;
+
+	/*
+	 * For each CRTC in this fb, find all associated encoders
+	 * and turn them off, then turn off the CRTC.
+	 */
+	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+		struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;
+
+		for (i = 0; i < par->crtc_count; i++)
+			if (crtc->base.id == par->crtc_ids[i])
+				break;
+
+		/* Found a CRTC on this fb, now find encoders */
+		list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
+			if (encoder->crtc == crtc) {
+				struct drm_encoder_helper_funcs *encoder_funcs;
+				encoder_funcs = encoder->helper_private;
+				encoder_funcs->dpms(encoder, dpms_mode);
+			}
+		}
+		if (dpms_mode == DRM_MODE_DPMS_OFF)
+			crtc_funcs->dpms(crtc, dpms_mode);
+	}
+}
+
+static int glamofb_blank(int blank, struct fb_info *info)
+{
+	switch (blank) {
+	case FB_BLANK_UNBLANK:
+		glamofb_on(info);
+		break;
+	case FB_BLANK_NORMAL:
+		glamofb_off(info, DRM_MODE_DPMS_STANDBY);
+		break;
+	case FB_BLANK_HSYNC_SUSPEND:
+		glamofb_off(info, DRM_MODE_DPMS_STANDBY);
+		break;
+	case FB_BLANK_VSYNC_SUSPEND:
+		glamofb_off(info, DRM_MODE_DPMS_SUSPEND);
+		break;
+	case FB_BLANK_POWERDOWN:
+		glamofb_off(info, DRM_MODE_DPMS_OFF);
+		break;
+	}
+	return 0;
+}
+
+static struct fb_ops glamofb_ops = {
+	.owner = THIS_MODULE,
+	.fb_check_var = glamofb_check_var,
+	.fb_set_par = glamofb_set_par,
+	.fb_setcolreg = glamofb_setcolreg,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	.fb_pan_display = glamofb_pan_display,
+	.fb_blank = glamofb_blank,
+};
+
+
+#define RESSIZE(ressource) (((ressource)->end - (ressource)->start)+1)
+
+
+/* Here, we create a GEM object of the correct size, and then turn it into
+ * /dev/fbX so that the kernel can put a console on it. */
+int glamofb_create(struct drm_device *dev, uint32_t fb_width,
+                   uint32_t fb_height, uint32_t surface_width,
+                   uint32_t surface_height, int colour_mode,
+                   struct glamo_framebuffer **glamo_fb_p)
+{
+	struct fb_info *info;
+	struct glamofb_par *par;
+	struct drm_framebuffer *fb;
+	struct glamo_framebuffer *glamo_fb;
+	struct drm_mode_fb_cmd mode_cmd;
+	struct drm_gem_object *fbo = NULL;
+	struct drm_glamo_gem_object *gobj;
+	struct device *device = &dev->platform_dev->dev;
+	struct glamodrm_handle *gdrm;
+	int size, ret;
+	unsigned long offs;
+
+	gdrm = dev->dev_private;
+
+	mode_cmd.width = surface_width;
+	mode_cmd.height = surface_height;
+
+	mode_cmd.bpp = 16;
+	mode_cmd.pitch = ALIGN(mode_cmd.width * ((mode_cmd.bpp + 1) / 8), 64);
+	mode_cmd.depth = 16;
+
+	size = mode_cmd.pitch * mode_cmd.height;
+	size = ALIGN(size, PAGE_SIZE);
+	if ( size > GLAMO_FRAMEBUFFER_ALLOCATION ) {
+		printk(KERN_ERR "[glamo-drm] Not enough memory for fb\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+	fbo = glamo_gem_object_alloc(dev, GLAMO_FRAMEBUFFER_ALLOCATION, 2);
+	if (!fbo) {
+		printk(KERN_ERR "[glamo-drm] Failed to allocate framebuffer\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+	gobj = fbo->driver_private;
+
+	mutex_lock(&dev->struct_mutex);
+
+	ret = glamo_framebuffer_create(dev, &mode_cmd, &fb, fbo);
+	if (ret) {
+		DRM_ERROR("failed to allocate fb.\n");
+		goto out_unref;
+	}
+
+	list_add(&fb->filp_head, &dev->mode_config.fb_kernel_list);
+
+	glamo_fb = to_glamo_framebuffer(fb);
+	*glamo_fb_p = glamo_fb;
+
+	info = framebuffer_alloc(sizeof(struct glamofb_par), device);
+	if (!info) {
+		ret = -ENOMEM;
+		goto out_unref;
+	}
+
+	par = info->par;
+
+	strcpy(info->fix.id, "glamodrmfb");
+	info->fix.type = FB_TYPE_PACKED_PIXELS;
+	info->fix.visual = FB_VISUAL_TRUECOLOR;
+	info->fix.type_aux = 0;
+	info->fix.xpanstep = 1; /* doing it in hw */
+	info->fix.ypanstep = 1; /* doing it in hw */
+	info->fix.ywrapstep = 0;
+	info->fix.accel = FB_ACCEL_GLAMO;
+	info->fix.type_aux = 0;
+	info->flags = FBINFO_DEFAULT;
+
+	info->fbops = &glamofb_ops;
+
+	info->fix.line_length = fb->pitch;
+	info->fix.smem_start = dev->mode_config.fb_base
+	                        + (unsigned long) gdrm->vram->start;
+	info->fix.smem_len = size;
+
+	info->flags = FBINFO_DEFAULT;
+
+	offs = gobj->block->start;
+	info->screen_base = ioremap(gdrm->vram->start + offs + GLAMO_OFFSET_FB,
+	                            GLAMO_FRAMEBUFFER_ALLOCATION);
+	if (!info->screen_base) {
+		printk(KERN_ERR "[glamo-drm] Couldn't map framebuffer!\n");
+		ret = -ENOSPC;
+		goto out_unref;
+	}
+	info->screen_size = size;
+
+	info->pseudo_palette = fb->pseudo_palette;
+	info->var.xres_virtual = fb->width;
+	info->var.yres_virtual = fb->height;
+	info->var.bits_per_pixel = fb->bits_per_pixel;
+	info->var.xoffset = 0;
+	info->var.yoffset = 0;
+	info->var.activate = FB_ACTIVATE_NOW;
+	info->var.height = -1;
+	info->var.width = -1;
+	info->var.xres = fb_width;
+	info->var.yres = fb_height;
+
+	info->fix.mmio_start = 0;
+	info->fix.mmio_len = 0;
+
+	info->pixmap.size = 64*1024;
+	info->pixmap.buf_align = 8;
+	info->pixmap.access_align = 32;
+	info->pixmap.flags = FB_PIXMAP_SYSTEM;
+	info->pixmap.scan_align = 1;
+
+	switch (fb->depth) {
+	case 16:
+		switch ( colour_mode ) {
+		case GLAMO_FB_RGB565:
+			info->var.red.offset	= 11;
+			info->var.green.offset	= 5;
+			info->var.blue.offset	= 0;
+			info->var.red.length	= 5;
+			info->var.green.length	= 6;
+			info->var.blue.length	= 5;
+			info->var.transp.length	= 0;
+			break;
+		case GLAMO_FB_ARGB1555:
+			info->var.transp.offset	= 15;
+			info->var.red.offset	= 10;
+			info->var.green.offset	= 5;
+			info->var.blue.offset	= 0;
+			info->var.transp.length	= 1;
+			info->var.red.length	= 5;
+			info->var.green.length	= 5;
+			info->var.blue.length	= 5;
+			break;
+		case GLAMO_FB_ARGB4444:
+			info->var.transp.offset	= 12;
+			info->var.red.offset	= 8;
+			info->var.green.offset	= 4;
+			info->var.blue.offset	= 0;
+			info->var.transp.length	= 4;
+			info->var.red.length	= 4;
+			info->var.green.length	= 4;
+			info->var.blue.length	= 4;
+			break;
+		}
+		break;
+	case 24:
+	case 32:
+	default:
+		/* The Smedia Glamo doesn't support anything but 16bit color */
+		printk(KERN_ERR "[glamo-drm] Only 16bpp is supported.\n");
+		return -EINVAL;
+	}
+
+	fb->fbdev = info;
+	par->glamo_fb = glamo_fb;
+	par->dev = dev;
+	gdrm->fb = info;
+
+	info->var.pixclock = -1;
+
+	printk(KERN_INFO "[glamo-drm] Allocated %dx%d fb: bo %p\n",
+	       glamo_fb->base.width, glamo_fb->base.height, fbo);
+	mutex_unlock(&dev->struct_mutex);
+	return 0;
+
+out_unref:
+	drm_gem_object_unreference(fbo);
+	mutex_unlock(&dev->struct_mutex);
+out:
+	return ret;
+}
+
+
+void glamo_kmsfb_suspend(struct glamodrm_handle *gdrm)
+{
+	fb_set_suspend(gdrm->fb, 1);
+}
+
+
+void glamo_kmsfb_resume(struct glamodrm_handle *gdrm)
+{
+	fb_set_suspend(gdrm->fb, 0);
+}
diff --git a/drivers/mfd/glamo/glamo-kms-fb.h b/drivers/mfd/glamo/glamo-kms-fb.h
new file mode 100644
index 0000000..1960e76
--- /dev/null
+++ b/drivers/mfd/glamo/glamo-kms-fb.h
@@ -0,0 +1,41 @@
+/*
+ * SMedia Glamo 336x/337x KMS framebuffer
+ *
+ * Copyright (C) 2009 Thomas White <taw@bitwiz.org.uk>
+ *
+ * Based on glamo-fb.c (C) 2007-2008 by Openmoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef __GLAMO_KMS_FB_H
+#define __GLAMO_KMS_FB_H
+
+#include <drm/drmP.h>
+#include "glamo-drm-private.h"
+
+extern int glamofb_create(struct drm_device *dev, uint32_t fb_width,
+                          uint32_t fb_height, uint32_t surface_width,
+                          uint32_t surface_height, int colour_mode,
+                          struct glamo_framebuffer **glamo_fb_p);
+
+extern void glamo_kmsfb_suspend(struct glamodrm_handle *gdrm);
+extern void glamo_kmsfb_resume(struct glamodrm_handle *gdrm);
+
+#endif /* __GLAMO_KMS_FB_H */
diff --git a/include/drm/Kbuild b/include/drm/Kbuild
index b940fdf..48b7b55 100644
--- a/include/drm/Kbuild
+++ b/include/drm/Kbuild
@@ -8,3 +8,4 @@ unifdef-y += radeon_drm.h
 unifdef-y += sis_drm.h
 unifdef-y += savage_drm.h
 unifdef-y += via_drm.h
+unifdef-y += glamo_drm.h
diff --git a/include/drm/glamo_drm.h b/include/drm/glamo_drm.h
new file mode 100644
index 0000000..4c194dc
--- /dev/null
+++ b/include/drm/glamo_drm.h
@@ -0,0 +1,153 @@
+/* glamo_drm.h -- Public header for the Glamo driver
+ *
+ * Copyright 2009 Thomas White
+ * Copyright 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Fremont, California.
+ * Copyright 2002 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Thomas White <taw@bitwiz.org.uk>
+ *    Kevin E. Martin <martin@valinux.com>
+ *    Gareth Hughes <gareth@valinux.com>
+ *    Keith Whitwell <keith@tungstengraphics.com>
+ */
+
+#ifndef __GLAMO_DRM_H__
+#define __GLAMO_DRM_H__
+
+#include "drm.h"
+
+#define GLAMO_GEM_DOMAIN_VRAM (0x1)
+
+/* Glamo specific ioctls */
+#define DRM_GLAMO_CMDBUF     0x01
+#define DRM_GLAMO_SWAP       0x02
+#define DRM_GLAMO_CMDBURST   0x03
+
+#define DRM_GLAMO_GEM_INFO     0x1c
+#define DRM_GLAMO_GEM_CREATE   0x1d
+#define DRM_GLAMO_GEM_MMAP     0x1e
+#define DRM_GLAMO_GEM_PIN      0x1f
+#define DRM_GLAMO_GEM_UNPIN    0x20
+#define DRM_GLAMO_GEM_PREAD    0x21
+#define DRM_GLAMO_GEM_PWRITE   0x22
+#define DRM_GLAMO_GEM_WAIT_RENDERING 0x24
+
+#define DRM_IOCTL_GLAMO_CMDBUF     DRM_IOW(DRM_COMMAND_BASE + DRM_GLAMO_CMDBUF, drm_glamo_cmd_buffer_t)
+#define DRM_IOCTL_GLAMO_SWAP       DRM_IO(DRM_COMMAND_BASE + DRM_GLAMO_SWAP)
+#define DRM_IOCTL_GLAMO_CMDBURST     DRM_IOW(DRM_COMMAND_BASE + DRM_GLAMO_CMDBURST, drm_glamo_cmd_burst_t)
+
+#define DRM_IOCTL_GLAMO_GEM_INFO   DRM_IOWR(DRM_COMMAND_BASE + DRM_GLAMO_GEM_INFO, struct drm_glamo_gem_info)
+#define DRM_IOCTL_GLAMO_GEM_CREATE DRM_IOWR(DRM_COMMAND_BASE + DRM_GLAMO_GEM_CREATE, struct drm_glamo_gem_create)
+#define DRM_IOCTL_GLAMO_GEM_MMAP   DRM_IOWR(DRM_COMMAND_BASE + DRM_GLAMO_GEM_MMAP, struct drm_glamo_gem_mmap)
+#define DRM_IOCTL_GLAMO_GEM_PIN    DRM_IOWR(DRM_COMMAND_BASE + DRM_GLAMO_GEM_PIN, struct drm_glamo_gem_pin)
+#define DRM_IOCTL_GLAMO_GEM_UNPIN  DRM_IOWR(DRM_COMMAND_BASE + DRM_GLAMO_GEM_UNPIN, struct drm_glamo_gem_unpin)
+#define DRM_IOCTL_GLAMO_GEM_PREAD  DRM_IOWR(DRM_COMMAND_BASE + DRM_GLAMO_GEM_PREAD, struct drm_glamo_gem_pread)
+#define DRM_IOCTL_GLAMO_GEM_PWRITE DRM_IOWR(DRM_COMMAND_BASE + DRM_GLAMO_GEM_PWRITE, struct drm_glamo_gem_pwrite)
+#define DRM_IOCTL_GLAMO_GEM_WAIT_RENDERING DRM_IOW(DRM_COMMAND_BASE + DRM_GLAMO_GEM_WAIT_RENDERING, struct drm_glamo_gem_wait_rendering)
+
+
+/* Simple command submission - a list of 16-bit address-data pairs */
+typedef struct drm_glamo_cmd_buffer {
+	unsigned int bufsz;	/* Size of buffer, in bytes */
+	char __user *buf;	/* Buffer of stuff to go onto the ring buffer */
+	unsigned int *obj_pos;	/* Offsets (in bytes) at which to put objs */
+	uint32_t *objs;		/* List of buffer object (handles) to use */
+	unsigned int nobjs;	/* Number of objects referenced */
+	int nbox;
+	struct drm_clip_rect __user *boxes;
+} drm_glamo_cmd_buffer_t;
+
+
+/* Burst command submission - base address and data:
+ *  - Data can be 32-bit (more easily)
+ *  - Easier for the kernel to validate */
+typedef struct drm_glamo_cmd_burst {
+	uint16_t base;		/* Base address (command) */
+	int bufsz;		/* Size of data, in bytes */
+	uint16_t *data;		/* Pointer to data */
+	unsigned int *obj_pos;	/* Offsets (in bytes) at which to put objs */
+	uint32_t *objs;		/* List of buffer object (handles) to use */
+	unsigned int nobjs;	/* Number of objects referenced */
+} drm_glamo_cmd_burst_t;
+
+struct drm_glamo_gem_info {
+	uint64_t vram_start;
+	uint64_t vram_size;
+};
+
+struct drm_glamo_gem_create {
+	uint64_t size;
+	uint64_t alignment;
+	uint32_t handle;
+	uint32_t initial_domain; // to allow VRAM to be created
+	uint32_t no_backing_store;
+};
+
+struct drm_glamo_gem_mmap {
+	uint32_t handle;	/* Handle goes in... */
+	uint64_t offset;	/* ...offset comes out */
+};
+
+struct drm_glamo_gem_wait_rendering {
+	uint32_t handle;
+	int have_handle;
+};
+
+struct drm_glamo_gem_pin {
+	uint32_t handle;
+	uint32_t pin_domain;
+	uint64_t alignment;
+	uint64_t offset;
+};
+
+struct drm_glamo_gem_unpin {
+	uint32_t handle;
+	uint32_t pad;
+};
+
+struct drm_glamo_gem_pread {
+	/** Handle for the object being read. */
+	uint32_t handle;
+	uint32_t pad;
+	/** Offset into the object to read from */
+	uint64_t offset;
+	/** Length of data to read */
+	uint64_t size;
+	/** Pointer to write the data into. */
+	uint64_t data_ptr;	/* void *, but pointers are not 32/64 compatible */
+};
+
+struct drm_glamo_gem_pwrite {
+	/** Handle for the object being written to. */
+	uint32_t handle;
+	uint32_t pad;
+	/** Offset into the object to write to */
+	uint64_t offset;
+	/** Length of data to write */
+	uint64_t size;
+	/** Pointer to read the data from. */
+	uint64_t data_ptr;	/* void *, but pointers are not 32/64 compatible */
+};
+
+#endif
-- 
1.6.6.1

