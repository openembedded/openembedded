From 6b2cdbe52ff2e459d0469f30f9e2f4a15f95bd3b Mon Sep 17 00:00:00 2001
From: Tanmay Upadhyay <tanmay.upadhyay@einfochips.com>
Date: Wed, 2 Dec 2009 10:54:13 +0530
Subject: [PATCH] OpenRD-Client: Volari Z11 driver added

The code is the same as the one present in 2.6.22.18 kernel. Compilation is a
bit noisy. But this is a temporary stuff to get going till XGI provides the
mail line driver.

Signed-off-by: Tanmay Upadhyay <tanmay.upadhyay@einfochips.com>
---
 drivers/video/Kconfig            |   12 +
 drivers/video/Makefile           |    1 +
 drivers/video/xgi/Makefile       |    4 +
 drivers/video/xgi/XGI.h          |   10 +
 drivers/video/xgi/XGI_accel.c    |  596 +++
 drivers/video/xgi/XGI_accel.h    |  511 ++
 drivers/video/xgi/XGI_main.h     | 1042 ++++
 drivers/video/xgi/XGI_main_26.c  | 3790 +++++++++++++
 drivers/video/xgi/XGIfb.h        |  215 +
 drivers/video/xgi/floatlib.c     |  946 ++++
 drivers/video/xgi/osdef.h        |  153 +
 drivers/video/xgi/vb_def.h       | 1017 ++++
 drivers/video/xgi/vb_ext.c       | 1375 +++++
 drivers/video/xgi/vb_ext.h       |   32 +
 drivers/video/xgi/vb_init.c      | 3376 ++++++++++++
 drivers/video/xgi/vb_init.h      |    7 +
 drivers/video/xgi/vb_release.txt |   44 +
 drivers/video/xgi/vb_setmode.c   |10829 ++++++++++++++++++++++++++++++++++++++
 drivers/video/xgi/vb_setmode.h   |   40 +
 drivers/video/xgi/vb_struct.h    |  518 ++
 drivers/video/xgi/vb_table.h     | 4406 ++++++++++++++++
 drivers/video/xgi/vb_util.c      |  287 +
 drivers/video/xgi/vb_util.h      |   16 +
 drivers/video/xgi/vgatypes.h     |  325 ++
 24 files changed, 29552 insertions(+), 0 deletions(-)
 create mode 100644 drivers/video/xgi/Makefile
 create mode 100644 drivers/video/xgi/XGI.h
 create mode 100644 drivers/video/xgi/XGI_accel.c
 create mode 100644 drivers/video/xgi/XGI_accel.h
 create mode 100644 drivers/video/xgi/XGI_main.h
 create mode 100644 drivers/video/xgi/XGI_main_26.c
 create mode 100644 drivers/video/xgi/XGIfb.h
 create mode 100644 drivers/video/xgi/floatlib.c
 create mode 100644 drivers/video/xgi/osdef.h
 create mode 100644 drivers/video/xgi/vb_def.h
 create mode 100644 drivers/video/xgi/vb_ext.c
 create mode 100644 drivers/video/xgi/vb_ext.h
 create mode 100644 drivers/video/xgi/vb_init.c
 create mode 100644 drivers/video/xgi/vb_init.h
 create mode 100644 drivers/video/xgi/vb_release.txt
 create mode 100644 drivers/video/xgi/vb_setmode.c
 create mode 100644 drivers/video/xgi/vb_setmode.h
 create mode 100644 drivers/video/xgi/vb_struct.h
 create mode 100644 drivers/video/xgi/vb_table.h
 create mode 100644 drivers/video/xgi/vb_util.c
 create mode 100644 drivers/video/xgi/vb_util.h
 create mode 100644 drivers/video/xgi/vgatypes.h

diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 5a5c303..f47305c 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -1488,6 +1488,18 @@ config FB_SIS_315
 	  (315/H/PRO, 55x, 650, 651, 740, 330, 661, 741, 760, 761) as well
 	  as XGI V3XT, V5, V8 and Z7.
 
+config FB_XGI
+	tristate "XGI display support"
+	depends on FB && PCI
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  This driver supports notebooks with XGI PCI chips.
+	  Say Y if you have such a graphics card.
+	  To compile this driver as a module, choose M here: the
+	  module will be called XGIfb.
+
 config FB_VIA
        tristate "VIA UniChrome (Pro) and Chrome9 display support"
        depends on FB && PCI
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index 4ecb30c..36efbdd 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -42,6 +42,7 @@ obj-$(CONFIG_FB_ATY)		  += aty/ macmodes.o
 obj-$(CONFIG_FB_ATY128)		  += aty/ macmodes.o
 obj-$(CONFIG_FB_RADEON)		  += aty/
 obj-$(CONFIG_FB_SIS)		  += sis/
+obj-$(CONFIG_FB_XGI)		  += xgi/
 obj-$(CONFIG_FB_VIA)		  += via/
 obj-$(CONFIG_FB_KYRO)             += kyro/
 obj-$(CONFIG_FB_SAVAGE)		  += savage/
diff --git a/drivers/video/xgi/Makefile b/drivers/video/xgi/Makefile
new file mode 100644
index 0000000..b5375fc
--- /dev/null
+++ b/drivers/video/xgi/Makefile
@@ -0,0 +1,4 @@
+obj-$(CONFIG_FB_XGI)  += XGIfb.o
+
+XGIfb-objs := XGI_main_26.o XGI_accel.o vb_init.o vb_setmode.o vb_util.o vb_ext.o floatlib.o
+
diff --git a/drivers/video/xgi/XGI.h b/drivers/video/xgi/XGI.h
new file mode 100644
index 0000000..87803dd
--- /dev/null
+++ b/drivers/video/xgi/XGI.h
@@ -0,0 +1,10 @@
+#ifndef _XGI_H
+#define _XGI_H
+
+#if 1
+#define TWDEBUG(x)
+#else
+#define TWDEBUG(x) printk(KERN_INFO x "\n");
+#endif
+
+#endif
diff --git a/drivers/video/xgi/XGI_accel.c b/drivers/video/xgi/XGI_accel.c
new file mode 100644
index 0000000..6bbb3bf
--- /dev/null
+++ b/drivers/video/xgi/XGI_accel.c
@@ -0,0 +1,596 @@
+/*
+ * XGI 300/630/730/540/315/550/650/740 frame buffer driver
+ * for Linux kernels 2.4.x and 2.5.x
+ *
+ * 2D acceleration part
+ *
+ * Based on the X driver's XGI300_accel.c which is
+ *     Copyright Xavier Ducoin <x.ducoin@lectra.com>
+ *     Copyright 2002 by Thomas Winischhofer, Vienna, Austria
+ * and XGI310_accel.c which is
+ *     Copyright 2002 by Thomas Winischhofer, Vienna, Austria
+ *
+ * Author: Thomas Winischhofer <thomas@winischhofer.net>
+ *			(see http://www.winischhofer.net/
+ *			for more information and updates)
+ */
+
+//#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+#include <linux/selection.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/vt_kern.h>
+#include <linux/capability.h>
+#include <linux/fs.h>
+#include <linux/agp_backend.h>
+
+#include <linux/types.h>
+/*
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#include <linux/XGIfb.h>
+#else
+#include <video/XGIfb.h>
+#endif
+*/
+#include <asm/io.h>
+
+#ifdef CONFIG_MTRR
+#include <asm/mtrr.h>
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#include <video/fbcon.h>
+#include <video/fbcon-cfb8.h>
+#include <video/fbcon-cfb16.h>
+#include <video/fbcon-cfb24.h>
+#include <video/fbcon-cfb32.h>
+#endif
+
+#include "osdef.h"
+#include "vgatypes.h"
+#include "vb_struct.h"
+#include "XGIfb.h"
+#include "XGI_accel.h"
+
+
+extern struct     video_info xgi_video_info;
+extern int XGIfb_accel;
+
+static const int XGIALUConv[] =
+{
+    0x00,       /* dest = 0;            0,      GXclear,        0 */
+    0x88,       /* dest &= src;         DSa,    GXand,          0x1 */
+    0x44,       /* dest = src & ~dest;  SDna,   GXandReverse,   0x2 */
+    0xCC,       /* dest = src;          S,      GXcopy,         0x3 */
+    0x22,       /* dest &= ~src;        DSna,   GXandInverted,  0x4 */
+    0xAA,       /* dest = dest;         D,      GXnoop,         0x5 */
+    0x66,       /* dest = ^src;         DSx,    GXxor,          0x6 */
+    0xEE,       /* dest |= src;         DSo,    GXor,           0x7 */
+    0x11,       /* dest = ~src & ~dest; DSon,   GXnor,          0x8 */
+    0x99,       /* dest ^= ~src ;       DSxn,   GXequiv,        0x9 */
+    0x55,       /* dest = ~dest;        Dn,     GXInvert,       0xA */
+    0xDD,       /* dest = src|~dest ;   SDno,   GXorReverse,    0xB */
+    0x33,       /* dest = ~src;         Sn,     GXcopyInverted, 0xC */
+    0xBB,       /* dest |= ~src;        DSno,   GXorInverted,   0xD */
+    0x77,       /* dest = ~src|~dest;   DSan,   GXnand,         0xE */
+    0xFF,       /* dest = 0xFF;         1,      GXset,          0xF */
+};
+/* same ROP but with Pattern as Source */
+static const int XGIPatALUConv[] =
+{
+    0x00,       /* dest = 0;            0,      GXclear,        0 */
+    0xA0,       /* dest &= src;         DPa,    GXand,          0x1 */
+    0x50,       /* dest = src & ~dest;  PDna,   GXandReverse,   0x2 */
+    0xF0,       /* dest = src;          P,      GXcopy,         0x3 */
+    0x0A,       /* dest &= ~src;        DPna,   GXandInverted,  0x4 */
+    0xAA,       /* dest = dest;         D,      GXnoop,         0x5 */
+    0x5A,       /* dest = ^src;         DPx,    GXxor,          0x6 */
+    0xFA,       /* dest |= src;         DPo,    GXor,           0x7 */
+    0x05,       /* dest = ~src & ~dest; DPon,   GXnor,          0x8 */
+    0xA5,       /* dest ^= ~src ;       DPxn,   GXequiv,        0x9 */
+    0x55,       /* dest = ~dest;        Dn,     GXInvert,       0xA */
+    0xF5,       /* dest = src|~dest ;   PDno,   GXorReverse,    0xB */
+    0x0F,       /* dest = ~src;         Pn,     GXcopyInverted, 0xC */
+    0xAF,       /* dest |= ~src;        DPno,   GXorInverted,   0xD */
+    0x5F,       /* dest = ~src|~dest;   DPan,   GXnand,         0xE */
+    0xFF,       /* dest = 0xFF;         1,      GXset,          0xF */
+};
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,34)
+static const unsigned char myrops[] = {
+   	3, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
+   };
+#endif
+
+/* 300 series */
+
+static void
+XGI300Sync(void)
+{
+	XGI300Idle
+}
+
+static void
+XGI310Sync(void)
+{
+	XGI310Idle
+}
+
+static void
+XGI300SetupForScreenToScreenCopy(int xdir, int ydir, int rop,
+                                unsigned int planemask, int trans_color)
+{
+	XGI300SetupDSTColorDepth(xgi_video_info.DstColor);
+	XGI300SetupSRCPitch(xgi_video_info.video_linelength)
+	XGI300SetupDSTRect(xgi_video_info.video_linelength, 0xFFF)
+
+	if(trans_color != -1) {
+		XGI300SetupROP(0x0A)
+		XGI300SetupSRCTrans(trans_color)
+		XGI300SetupCMDFlag(TRANSPARENT_BITBLT)
+	} else {
+	        XGI300SetupROP(XGIALUConv[rop])
+	}
+	if(xdir > 0) {
+		XGI300SetupCMDFlag(X_INC)
+	}
+	if(ydir > 0) {
+		XGI300SetupCMDFlag(Y_INC)
+	}
+}
+
+static void
+XGI300SubsequentScreenToScreenCopy(int src_x, int src_y, int dst_x, int dst_y,
+                                int width, int height)
+{
+	long srcbase, dstbase;
+
+	srcbase = dstbase = 0;
+	if (src_y >= 2048) {
+		srcbase = xgi_video_info.video_linelength * src_y;
+		src_y = 0;
+	}
+	if (dst_y >= 2048) {
+		dstbase = xgi_video_info.video_linelength * dst_y;
+		dst_y = 0;
+	}
+
+	XGI300SetupSRCBase(srcbase);
+	XGI300SetupDSTBase(dstbase);
+
+	if(!(xgi_video_info.CommandReg & X_INC))  {
+		src_x += width-1;
+		dst_x += width-1;
+	}
+	if(!(xgi_video_info.CommandReg & Y_INC))  {
+		src_y += height-1;
+		dst_y += height-1;
+	}
+	XGI300SetupRect(width, height)
+	XGI300SetupSRCXY(src_x, src_y)
+	XGI300SetupDSTXY(dst_x, dst_y)
+	XGI300DoCMD
+}
+
+static void
+XGI300SetupForSolidFill(int color, int rop, unsigned int planemask)
+{
+	XGI300SetupPATFG(color)
+	XGI300SetupDSTRect(xgi_video_info.video_linelength, 0xFFF)
+	XGI300SetupDSTColorDepth(xgi_video_info.DstColor);
+	XGI300SetupROP(XGIPatALUConv[rop])
+	XGI300SetupCMDFlag(PATFG)
+}
+
+static void
+XGI300SubsequentSolidFillRect(int x, int y, int w, int h)
+{
+	long dstbase;
+
+	dstbase = 0;
+	if(y >= 2048) {
+		dstbase = xgi_video_info.video_linelength * y;
+		y = 0;
+	}
+	XGI300SetupDSTBase(dstbase)
+	XGI300SetupDSTXY(x,y)
+	XGI300SetupRect(w,h)
+	XGI300SetupCMDFlag(X_INC | Y_INC | BITBLT)
+	XGI300DoCMD
+}
+
+/* 310/325 series ------------------------------------------------ */
+
+static void
+XGI310SetupForScreenToScreenCopy(int xdir, int ydir, int rop,
+                                unsigned int planemask, int trans_color)
+{
+	XGI310SetupDSTColorDepth(xgi_video_info.DstColor);
+	XGI310SetupSRCPitch(xgi_video_info.video_linelength)
+	XGI310SetupDSTRect(xgi_video_info.video_linelength, 0xFFF)
+	if (trans_color != -1) {
+		XGI310SetupROP(0x0A)
+		XGI310SetupSRCTrans(trans_color)
+		XGI310SetupCMDFlag(TRANSPARENT_BITBLT)
+	} else {
+	        XGI310SetupROP(XGIALUConv[rop])
+		/* Set command - not needed, both 0 */
+		/* XGISetupCMDFlag(BITBLT | SRCVIDEO) */
+	}
+	XGI310SetupCMDFlag(xgi_video_info.XGI310_AccelDepth)
+	/* TW: The 310/325 series is smart enough to know the direction */
+}
+
+static void
+XGI310SubsequentScreenToScreenCopy(int src_x, int src_y, int dst_x, int dst_y,
+                                int width, int height)
+{
+	long srcbase, dstbase;
+	int mymin, mymax;
+
+	srcbase = dstbase = 0;
+	mymin = min(src_y, dst_y);
+	mymax = max(src_y, dst_y);
+	
+	/* Although the chip knows the direction to use
+	 * if the source and destination areas overlap, 
+	 * that logic fails if we fiddle with the bitmap
+	 * addresses. Therefore, we check if the source
+	 * and destination blitting areas overlap and 
+	 * adapt the bitmap addresses synchronously 
+	 * if the coordinates exceed the valid range.
+	 * The the areas do not overlap, we do our 
+	 * normal check.
+	 */
+	if((mymax - mymin) < height) { 
+	   if((src_y >= 2048) || (dst_y >= 2048)) {	      
+	      srcbase = xgi_video_info.video_linelength * mymin;
+	      dstbase = xgi_video_info.video_linelength * mymin;
+	      src_y -= mymin;
+	      dst_y -= mymin;
+	   }
+	} else {
+	   if(src_y >= 2048) {
+	      srcbase = xgi_video_info.video_linelength * src_y;
+	      src_y = 0;
+	   }
+	   if(dst_y >= 2048) {
+	      dstbase = xgi_video_info.video_linelength * dst_y;
+	      dst_y = 0;
+	   }
+	}
+
+	XGI310SetupSRCBase(srcbase);
+	XGI310SetupDSTBase(dstbase);
+	XGI310SetupRect(width, height)
+	XGI310SetupSRCXY(src_x, src_y)
+	XGI310SetupDSTXY(dst_x, dst_y)
+	XGI310DoCMD
+}
+
+static void
+XGI310SetupForSolidFill(int color, int rop, unsigned int planemask)
+{
+	XGI310SetupPATFG(color)
+	XGI310SetupDSTRect(xgi_video_info.video_linelength, 0xFFF)
+	XGI310SetupDSTColorDepth(xgi_video_info.DstColor);
+	XGI310SetupROP(XGIPatALUConv[rop])
+	XGI310SetupCMDFlag(PATFG | xgi_video_info.XGI310_AccelDepth)
+}
+
+static void
+XGI310SubsequentSolidFillRect(int x, int y, int w, int h)
+{
+	long dstbase;
+
+	dstbase = 0;
+	if(y >= 2048) {
+		dstbase = xgi_video_info.video_linelength * y;
+		y = 0;
+	}
+	XGI310SetupDSTBase(dstbase)
+	XGI310SetupDSTXY(x,y)
+	XGI310SetupRect(w,h)
+	XGI310SetupCMDFlag(BITBLT)
+	XGI310DoCMD
+}
+
+/* --------------------------------------------------------------------- */
+
+/* The exported routines */
+
+int XGIfb_initaccel(void)
+{
+#ifdef XGIFB_USE_SPINLOCKS
+    spin_lock_init(&xgi_video_info.lockaccel);
+#endif
+    return(0);
+}
+
+void XGIfb_syncaccel(void)
+{
+    
+    XGI310Sync();
+    
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,34)  /* --- KERNEL 2.5.34 and later --- */
+
+int fbcon_XGI_sync(struct fb_info *info)
+{
+    if(!XGIfb_accel) return 0;
+    CRITFLAGS
+
+    XGI310Sync();
+
+   CRITEND
+   return 0;
+}
+
+void fbcon_XGI_fillrect(struct fb_info *info, const struct fb_fillrect *rect)
+{
+   int col=0;
+   CRITFLAGS
+
+   
+   if(!rect->width || !rect->height)
+   	return;
+
+   if(!XGIfb_accel) {
+	cfb_fillrect(info, rect);
+	return;
+   }
+   
+   switch(info->var.bits_per_pixel) {
+		case 8: col = rect->color;
+			break;
+		case 16: col = ((u32 *)(info->pseudo_palette))[rect->color];
+			 break;
+		case 32: col = ((u32 *)(info->pseudo_palette))[rect->color];
+			 break;
+	}	
+
+   
+	   CRITBEGIN
+	   XGI310SetupForSolidFill(col, myrops[rect->rop], 0);
+	   XGI310SubsequentSolidFillRect(rect->dx, rect->dy, rect->width, rect->height);
+	   CRITEND
+	   XGI310Sync();
+   
+
+}
+
+void fbcon_XGI_copyarea(struct fb_info *info, const struct fb_copyarea *area)
+{
+   int xdir, ydir;
+   CRITFLAGS
+
+
+   if(!XGIfb_accel) {
+   	cfb_copyarea(info, area);
+	return;
+   } 
+
+   if(!area->width || !area->height)
+   	return;
+
+   if(area->sx < area->dx) xdir = 0;
+   else                    xdir = 1;
+   if(area->sy < area->dy) ydir = 0;
+   else                    ydir = 1;
+   
+      CRITBEGIN
+      XGI310SetupForScreenToScreenCopy(xdir, ydir, 3, 0, -1);
+      XGI310SubsequentScreenToScreenCopy(area->sx, area->sy, area->dx, area->dy, area->width, area->height);
+      CRITEND
+      XGI310Sync();
+   
+}
+
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,5,33)  /* ------ KERNEL <2.5.34 ------ */
+
+void fbcon_XGI_bmove(struct display *p, int srcy, int srcx,
+			    int dsty, int dstx, int height, int width)
+{
+        int xdir, ydir;
+	CRITFLAGS
+
+	if(!xgi_video_info.accel) {
+	    switch(xgi_video_info.video_bpp) {
+	    case 8:
+#ifdef FBCON_HAS_CFB8
+	       fbcon_cfb8_bmove(p, srcy, srcx, dsty, dstx, height, width);
+#endif
+	       break;
+	    case 16:
+#ifdef FBCON_HAS_CFB16
+	       fbcon_cfb16_bmove(p, srcy, srcx, dsty, dstx, height, width);
+#endif
+	       break;
+	    case 32:
+#ifdef FBCON_HAS_CFB32
+	       fbcon_cfb32_bmove(p, srcy, srcx, dsty, dstx, height, width);
+#endif
+	       break;
+            }
+	    return;
+	}
+
+	srcx *= fontwidth(p);
+	srcy *= fontheight(p);
+	dstx *= fontwidth(p);
+	dsty *= fontheight(p);
+	width *= fontwidth(p);
+	height *= fontheight(p);
+
+	if(srcx < dstx) xdir = 0;
+	else            xdir = 1;
+	if(srcy < dsty) ydir = 0;
+	else            ydir = 1;
+
+	
+	   CRITBEGIN
+	   XGI310SetupForScreenToScreenCopy(xdir, ydir, 3, 0, -1);
+	   XGI310SubsequentScreenToScreenCopy(srcx, srcy, dstx, dsty, width, height);
+	   CRITEND
+	   XGI310Sync();
+#if 0	   
+	   printk(KERN_INFO "XGI_bmove sx %d sy %d dx %d dy %d w %d h %d\n",
+		srcx, srcy, dstx, dsty, width, height);
+#endif		
+	
+}
+
+
+static void fbcon_XGI_clear(struct vc_data *conp, struct display *p,
+			int srcy, int srcx, int height, int width, int color)
+{
+	CRITFLAGS
+
+	srcx *= fontwidth(p);
+	srcy *= fontheight(p);
+	width *= fontwidth(p);
+	height *= fontheight(p);
+
+	
+	   CRITBEGIN
+	   XGI310SetupForSolidFill(color, 3, 0);
+	   XGI310SubsequentSolidFillRect(srcx, srcy, width, height);
+	   CRITEND
+	   XGI310Sync();
+	
+}
+
+void fbcon_XGI_clear8(struct vc_data *conp, struct display *p,
+			int srcy, int srcx, int height, int width)
+{
+	u32 bgx;
+
+	if(!xgi_video_info.accel) {
+#ifdef FBCON_HAS_CFB8
+	    fbcon_cfb8_clear(conp, p, srcy, srcx, height, width);
+#endif
+	    return;
+	}
+
+	bgx = attr_bgcol_ec(p, conp);
+	fbcon_XGI_clear(conp, p, srcy, srcx, height, width, bgx);
+}
+
+void fbcon_XGI_clear16(struct vc_data *conp, struct display *p,
+			int srcy, int srcx, int height, int width)
+{
+	u32 bgx;
+	if(!xgi_video_info.accel) {
+#ifdef FBCON_HAS_CFB16
+	    fbcon_cfb16_clear(conp, p, srcy, srcx, height, width);
+#endif
+	    return;
+	}
+
+	bgx = ((u_int16_t*)p->dispsw_data)[attr_bgcol_ec(p, conp)];
+	fbcon_XGI_clear(conp, p, srcy, srcx, height, width, bgx);
+}
+
+void fbcon_XGI_clear32(struct vc_data *conp, struct display *p,
+			int srcy, int srcx, int height, int width)
+{
+	u32 bgx;
+
+	if(!xgi_video_info.accel) {
+#ifdef FBCON_HAS_CFB32
+	    fbcon_cfb32_clear(conp, p, srcy, srcx, height, width);
+#endif
+	    return;
+	}
+
+	bgx = ((u_int32_t*)p->dispsw_data)[attr_bgcol_ec(p, conp)];
+	fbcon_XGI_clear(conp, p, srcy, srcx, height, width, bgx);
+}
+
+void fbcon_XGI_revc(struct display *p, int srcx, int srcy)
+{
+	CRITFLAGS
+
+	if(!xgi_video_info.accel) {
+	    switch(xgi_video_info.video_bpp) {
+	    case 16:
+#ifdef FBCON_HAS_CFB16
+	       fbcon_cfb16_revc(p, srcx, srcy);
+#endif
+	       break;
+	    case 32:
+#ifdef FBCON_HAS_CFB32
+	       fbcon_cfb32_revc(p, srcx, srcy);
+#endif
+	       break;
+            }
+	    return;
+	}
+
+	srcx *= fontwidth(p);
+	srcy *= fontheight(p);
+
+	
+	   CRITBEGIN
+	   XGI310SetupForSolidFill(0, 0x0a, 0);
+	   XGI310SubsequentSolidFillRect(srcx, srcy, fontwidth(p), fontheight(p));
+	   CRITEND
+	   XGI310Sync();
+	
+}
+
+#ifdef FBCON_HAS_CFB8
+struct display_switch fbcon_XGI8 = {
+	setup:			fbcon_cfb8_setup,
+	bmove:			fbcon_XGI_bmove,
+	clear:			fbcon_XGI_clear8,
+	putc:			fbcon_cfb8_putc,
+	putcs:			fbcon_cfb8_putcs,
+	revc:			fbcon_cfb8_revc,
+	clear_margins:		fbcon_cfb8_clear_margins,
+	fontwidthmask:		FONTWIDTH(4)|FONTWIDTH(8)|FONTWIDTH(12)|FONTWIDTH(16)
+};
+#endif
+#ifdef FBCON_HAS_CFB16
+struct display_switch fbcon_XGI16 = {
+	setup:			fbcon_cfb16_setup,
+	bmove:			fbcon_XGI_bmove,
+	clear:			fbcon_XGI_clear16,
+	putc:			fbcon_cfb16_putc,
+	putcs:			fbcon_cfb16_putcs,
+	revc:			fbcon_XGI_revc,
+	clear_margins:		fbcon_cfb16_clear_margins,
+	fontwidthmask:		FONTWIDTH(4)|FONTWIDTH(8)|FONTWIDTH(12)|FONTWIDTH(16)
+};
+#endif
+#ifdef FBCON_HAS_CFB32
+struct display_switch fbcon_XGI32 = {
+	setup:			fbcon_cfb32_setup,
+	bmove:			fbcon_XGI_bmove,
+	clear:			fbcon_XGI_clear32,
+	putc:			fbcon_cfb32_putc,
+	putcs:			fbcon_cfb32_putcs,
+	revc:			fbcon_XGI_revc,
+	clear_margins:		fbcon_cfb32_clear_margins,
+	fontwidthmask:		FONTWIDTH(4)|FONTWIDTH(8)|FONTWIDTH(12)|FONTWIDTH(16)
+};
+#endif
+
+#endif /* KERNEL VERSION */
+
+
diff --git a/drivers/video/xgi/XGI_accel.h b/drivers/video/xgi/XGI_accel.h
new file mode 100644
index 0000000..04e1267
--- /dev/null
+++ b/drivers/video/xgi/XGI_accel.h
@@ -0,0 +1,511 @@
+/*
+ * XGI 300/630/730/540/315/550/650/740 frame buffer driver
+ * for Linux kernels 2.4.x and 2.5.x
+ *
+ * 2D acceleration part
+ *
+ * Based on the X driver's XGI300_accel.h which is
+ *     Copyright Xavier Ducoin <x.ducoin@lectra.com>
+ *     Copyright 2002 by Thomas Winischhofer, Vienna, Austria
+ * and XGI310_accel.h which is
+ *     Copyright 2002 by Thomas Winischhofer, Vienna, Austria
+ *
+ * Author:   Thomas Winischhofer <thomas@winischhofer.net>:
+ *			(see http://www.winischhofer.net/
+ *			for more information and updates)
+ */
+
+#ifndef _XGIFB_ACCEL_H
+#define _XGIFB_ACCEL_H
+
+/* Guard accelerator accesses with spin_lock_irqsave? Works well without. */
+#undef XGIFB_USE_SPINLOCKS
+
+#ifdef XGIFB_USE_SPINLOCKS
+#include <linux/spinlock.h>
+#define CRITBEGIN  spin_lock_irqsave(&xgi_video_info.lockaccel), critflags);
+#define CRITEND	   spin_unlock_irqrestore(&xgi_video_info.lockaccel), critflags);
+#define CRITFLAGS  unsigned long critflags;
+#else
+#define CRITBEGIN
+#define CRITEND
+#define CRITFLAGS
+#endif
+
+/* Definitions for the XGI engine communication. */
+
+#define PATREGSIZE      384  /* Pattern register size. 384 bytes @ 0x8300 */
+#define BR(x)   (0x8200 | (x) << 2)
+#define PBR(x)  (0x8300 | (x) << 2)
+
+/* XGI300 engine commands */
+#define BITBLT                  0x00000000  /* Blit */
+#define COLOREXP                0x00000001  /* Color expand */
+#define ENCOLOREXP              0x00000002  /* Enhanced color expand */
+#define MULTIPLE_SCANLINE       0x00000003  /* ? */
+#define LINE                    0x00000004  /* Draw line */
+#define TRAPAZOID_FILL          0x00000005  /* Fill trapezoid */
+#define TRANSPARENT_BITBLT      0x00000006  /* Transparent Blit */
+
+/* Additional engine commands for 310/325 */
+#define ALPHA_BLEND		0x00000007  /* Alpha blend ? */
+#define A3D_FUNCTION		0x00000008  /* 3D command ? */
+#define	CLEAR_Z_BUFFER		0x00000009  /* ? */
+#define GRADIENT_FILL		0x0000000A  /* Gradient fill */
+#define STRETCH_BITBLT		0x0000000B  /* Stretched Blit */
+
+/* source select */
+#define SRCVIDEO                0x00000000  /* source is video RAM */
+#define SRCSYSTEM               0x00000010  /* source is system memory */
+#define SRCCPUBLITBUF           SRCSYSTEM   /* source is CPU-driven BitBuffer (for color expand) */
+#define SRCAGP                  0x00000020  /* source is AGP memory (?) */
+
+/* Pattern flags */
+#define PATFG                   0x00000000  /* foreground color */
+#define PATPATREG               0x00000040  /* pattern in pattern buffer (0x8300) */
+#define PATMONO                 0x00000080  /* mono pattern */
+
+/* blitting direction (300 series only) */
+#define X_INC                   0x00010000
+#define X_DEC                   0x00000000
+#define Y_INC                   0x00020000
+#define Y_DEC                   0x00000000
+
+/* Clipping flags */
+#define NOCLIP                  0x00000000
+#define NOMERGECLIP             0x04000000
+#define CLIPENABLE              0x00040000
+#define CLIPWITHOUTMERGE        0x04040000
+
+/* Transparency */
+#define OPAQUE                  0x00000000
+#define TRANSPARENT             0x00100000
+
+/* ? */
+#define DSTAGP                  0x02000000
+#define DSTVIDEO                0x02000000
+
+/* Line */
+#define LINE_STYLE              0x00800000
+#define NO_RESET_COUNTER        0x00400000
+#define NO_LAST_PIXEL           0x00200000
+
+/* Subfunctions for Color/Enhanced Color Expansion (310/325 only) */
+#define COLOR_TO_MONO		0x00100000
+#define AA_TEXT			0x00200000
+
+/* Some general registers for 310/325 series */
+#define SRC_ADDR		0x8200
+#define SRC_PITCH		0x8204
+#define AGP_BASE		0x8206 /* color-depth dependent value */
+#define SRC_Y			0x8208
+#define SRC_X			0x820A
+#define DST_Y			0x820C
+#define DST_X			0x820E
+#define DST_ADDR		0x8210
+#define DST_PITCH		0x8214
+#define DST_HEIGHT		0x8216
+#define RECT_WIDTH		0x8218
+#define RECT_HEIGHT		0x821A
+#define PAT_FGCOLOR		0x821C
+#define PAT_BGCOLOR		0x8220
+#define SRC_FGCOLOR		0x8224
+#define SRC_BGCOLOR		0x8228
+#define MONO_MASK		0x822C
+#define LEFT_CLIP		0x8234
+#define TOP_CLIP		0x8236
+#define RIGHT_CLIP		0x8238
+#define BOTTOM_CLIP		0x823A
+#define COMMAND_READY		0x823C
+#define FIRE_TRIGGER      	0x8240
+
+#define PATTERN_REG		0x8300  /* 384 bytes pattern buffer */
+
+/* Line registers */
+#define LINE_X0			SRC_Y
+#define LINE_X1			DST_Y
+#define LINE_Y0			SRC_X
+#define LINE_Y1			DST_X
+#define LINE_COUNT		RECT_WIDTH
+#define LINE_STYLE_PERIOD	RECT_HEIGHT
+#define LINE_STYLE_0		MONO_MASK
+#define LINE_STYLE_1		0x8230
+#define LINE_XN			PATTERN_REG
+#define LINE_YN			PATTERN_REG+2
+
+/* Transparent bitblit registers */
+#define TRANS_DST_KEY_HIGH	PAT_FGCOLOR
+#define TRANS_DST_KEY_LOW	PAT_BGCOLOR
+#define TRANS_SRC_KEY_HIGH	SRC_FGCOLOR
+#define TRANS_SRC_KEY_LOW	SRC_BGCOLOR
+
+/* Queue */
+#define Q_BASE_ADDR		0x85C0  /* Base address of software queue (?) */
+#define Q_WRITE_PTR		0x85C4  /* Current write pointer (?) */
+#define Q_READ_PTR		0x85C8  /* Current read pointer (?) */
+#define Q_STATUS		0x85CC  /* queue status */
+
+
+#define MMIO_IN8(base, offset) \
+	*(volatile u8 *)(((u8*)(base)) + (offset))
+#define MMIO_IN16(base, offset) \
+	*(volatile u16 *)(void *)(((u8*)(base)) + (offset))
+#define MMIO_IN32(base, offset) \
+	*(volatile u32 *)(void *)(((u8*)(base)) + (offset))
+#define MMIO_OUT8(base, offset, val) \
+	*(volatile u8 *)(((u8*)(base)) + (offset)) = (val)
+#define MMIO_OUT16(base, offset, val) \
+	*(volatile u16 *)(void *)(((u8*)(base)) + (offset)) = (val)
+#define MMIO_OUT32(base, offset, val) \
+	*(volatile u32 *)(void *)(((u8*)(base)) + (offset)) = (val)
+
+
+
+/* ------------- XGI 300 series -------------- */
+
+/* Macros to do useful things with the XGI BitBLT engine */
+
+/* BR(16) (0x8420):
+
+   bit 31 2D engine: 1 is idle,
+   bit 30 3D engine: 1 is idle,
+   bit 29 Command queue: 1 is empty
+
+   bits 28:24: Current CPU driven BitBlt buffer stage bit[4:0]
+
+   bits 15:0:  Current command queue length
+
+*/
+
+/* TW: BR(16)+2 = 0x8242 */
+
+int     xgiCmdQueLen;
+
+#define XGI300Idle \
+  { \
+  while( (MMIO_IN16(xgi_video_info.mmio_vbase, BR(16)+2) & 0xE000) != 0xE000){}; \
+  while( (MMIO_IN16(xgi_video_info.mmio_vbase, BR(16)+2) & 0xE000) != 0xE000){}; \
+  while( (MMIO_IN16(xgi_video_info.mmio_vbase, BR(16)+2) & 0xE000) != 0xE000){}; \
+  xgiCmdQueLen=MMIO_IN16(xgi_video_info.mmio_vbase, 0x8240); \
+  }
+/* TW: (do three times, because 2D engine seems quite unsure about whether or not it's idle) */
+
+#define XGI300SetupSRCBase(base) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(0), base);\
+                xgiCmdQueLen --;
+
+#define XGI300SetupSRCPitch(pitch) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT16(xgi_video_info.mmio_vbase, BR(1), pitch);\
+                xgiCmdQueLen --;
+
+#define XGI300SetupSRCXY(x,y) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(2), (x)<<16 | (y) );\
+                xgiCmdQueLen --;
+
+#define XGI300SetupDSTBase(base) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(4), base);\
+                xgiCmdQueLen --;
+
+#define XGI300SetupDSTXY(x,y) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(3), (x)<<16 | (y) );\
+                xgiCmdQueLen --;
+
+#define XGI300SetupDSTRect(x,y) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(5), (y)<<16 | (x) );\
+                xgiCmdQueLen --;
+
+#define XGI300SetupDSTColorDepth(bpp) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT16(xgi_video_info.mmio_vbase, BR(1)+2, bpp);\
+                xgiCmdQueLen --;
+
+#define XGI300SetupRect(w,h) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(6), (h)<<16 | (w) );\
+                xgiCmdQueLen --;
+
+#define XGI300SetupPATFG(color) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(7), color);\
+                xgiCmdQueLen --;
+
+#define XGI300SetupPATBG(color) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(8), color);\
+                xgiCmdQueLen --;
+
+#define XGI300SetupSRCFG(color) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(9), color);\
+                xgiCmdQueLen --;
+
+#define XGI300SetupSRCBG(color) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(10), color);\
+                xgiCmdQueLen --;
+
+/* 0x8224 src colorkey high */
+/* 0x8228 src colorkey low */
+/* 0x821c dest colorkey high */
+/* 0x8220 dest colorkey low */
+#define XGI300SetupSRCTrans(color) \
+                if (xgiCmdQueLen <= 1)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, 0x8224, color);\
+		MMIO_OUT32(xgi_video_info.mmio_vbase, 0x8228, color);\
+		xgiCmdQueLen -= 2;
+
+#define XGI300SetupDSTTrans(color) \
+		if (xgiCmdQueLen <= 1)  XGI300Idle;\
+		MMIO_OUT32(xgi_video_info.mmio_vbase, 0x821C, color); \
+		MMIO_OUT32(xgi_video_info.mmio_vbase, 0x8220, color); \
+                xgiCmdQueLen -= 2;
+
+#define XGI300SetupMONOPAT(p0,p1) \
+                if (xgiCmdQueLen <= 1)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(11), p0);\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(12), p1);\
+                xgiCmdQueLen -= 2;
+
+#define XGI300SetupClipLT(left,top) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(13), ((left) & 0xFFFF) | (top)<<16 );\
+                xgiCmdQueLen--;
+
+#define XGI300SetupClipRB(right,bottom) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(14), ((right) & 0xFFFF) | (bottom)<<16 );\
+                xgiCmdQueLen--;
+
+/* General */
+#define XGI300SetupROP(rop) \
+                xgi_video_info.CommandReg = (rop) << 8;
+
+#define XGI300SetupCMDFlag(flags) \
+                xgi_video_info.CommandReg |= (flags);
+
+#define XGI300DoCMD \
+                if (xgiCmdQueLen <= 1)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(15), xgi_video_info.CommandReg); \
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(16), 0);\
+                xgiCmdQueLen -= 2;
+
+/* Line */
+#define XGI300SetupX0Y0(x,y) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(2), (y)<<16 | (x) );\
+                xgiCmdQueLen--;
+
+#define XGI300SetupX1Y1(x,y) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(3), (y)<<16 | (x) );\
+                xgiCmdQueLen--;
+
+#define XGI300SetupLineCount(c) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT16(xgi_video_info.mmio_vbase, BR(6), c);\
+                xgiCmdQueLen--;
+
+#define XGI300SetupStylePeriod(p) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT16(xgi_video_info.mmio_vbase, BR(6)+2, p);\
+                xgiCmdQueLen--;
+
+#define XGI300SetupStyleLow(ls) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(11), ls);\
+                xgiCmdQueLen--;
+
+#define XGI300SetupStyleHigh(ls) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(12), ls);\
+                xgiCmdQueLen--;
+
+
+
+/* ----------- XGI 310/325 series --------------- */
+
+/* Q_STATUS:
+   bit 31 = 1: All engines idle and all queues empty
+   bit 30 = 1: Hardware Queue (=HW CQ, 2D queue, 3D queue) empty
+   bit 29 = 1: 2D engine is idle
+   bit 28 = 1: 3D engine is idle
+   bit 27 = 1: HW command queue empty
+   bit 26 = 1: 2D queue empty
+   bit 25 = 1: 3D queue empty
+   bit 24 = 1: SW command queue empty
+   bits 23:16: 2D counter 3
+   bits 15:8:  2D counter 2
+   bits 7:0:   2D counter 1
+
+   Where is the command queue length (current amount of commands the queue
+   can accept) on the 310/325 series? (The current implementation is taken
+   from 300 series and certainly wrong...)
+*/
+
+/* TW: FIXME: xgiCmdQueLen is... where....? */
+#define XGI310Idle \
+  { \
+  while( (MMIO_IN16(xgi_video_info.mmio_vbase, Q_STATUS+2) & 0x8000) != 0x8000){}; \
+  while( (MMIO_IN16(xgi_video_info.mmio_vbase, Q_STATUS+2) & 0x8000) != 0x8000){}; \
+  xgiCmdQueLen=MMIO_IN16(xgi_video_info.mmio_vbase, Q_STATUS); \
+  }
+
+#define XGI310SetupSRCBase(base) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, SRC_ADDR, base);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupSRCPitch(pitch) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT16(xgi_video_info.mmio_vbase, SRC_PITCH, pitch);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupSRCXY(x,y) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, SRC_Y, (x)<<16 | (y) );\
+      xgiCmdQueLen--;
+
+#define XGI310SetupDSTBase(base) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, DST_ADDR, base);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupDSTXY(x,y) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, DST_Y, (x)<<16 | (y) );\
+      xgiCmdQueLen--;
+
+#define XGI310SetupDSTRect(x,y) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, DST_PITCH, (y)<<16 | (x) );\
+      xgiCmdQueLen--;
+
+#define XGI310SetupDSTColorDepth(bpp) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT16(xgi_video_info.mmio_vbase, AGP_BASE, bpp);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupRect(w,h) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, RECT_WIDTH, (h)<<16 | (w) );\
+      xgiCmdQueLen--;
+
+#define XGI310SetupPATFG(color) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, PAT_FGCOLOR, color);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupPATBG(color) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, PAT_BGCOLOR, color);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupSRCFG(color) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, SRC_FGCOLOR, color);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupSRCBG(color) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, SRC_BGCOLOR, color);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupSRCTrans(color) \
+      if (xgiCmdQueLen <= 1)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, TRANS_SRC_KEY_HIGH, color);\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, TRANS_SRC_KEY_LOW, color);\
+      xgiCmdQueLen -= 2;
+
+#define XGI310SetupDSTTrans(color) \
+      if (xgiCmdQueLen <= 1)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, TRANS_DST_KEY_HIGH, color); \
+      MMIO_OUT32(xgi_video_info.mmio_vbase, TRANS_DST_KEY_LOW, color); \
+      xgiCmdQueLen -= 2;
+
+#define XGI310SetupMONOPAT(p0,p1) \
+      if (xgiCmdQueLen <= 1)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, MONO_MASK, p0);\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, MONO_MASK+4, p1);\
+      xgiCmdQueLen -= 2;
+
+#define XGI310SetupClipLT(left,top) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, LEFT_CLIP, ((left) & 0xFFFF) | (top)<<16 );\
+      xgiCmdQueLen--;
+
+#define XGI310SetupClipRB(right,bottom) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, RIGHT_CLIP, ((right) & 0xFFFF) | (bottom)<<16 );\
+      xgiCmdQueLen--;
+
+#define XGI310SetupROP(rop) \
+      xgi_video_info.CommandReg = (rop) << 8;
+
+#define XGI310SetupCMDFlag(flags) \
+      xgi_video_info.CommandReg |= (flags);
+
+#define XGI310DoCMD \
+      if (xgiCmdQueLen <= 1)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, COMMAND_READY, xgi_video_info.CommandReg); \
+      MMIO_OUT32(xgi_video_info.mmio_vbase, FIRE_TRIGGER, 0); \
+      xgiCmdQueLen -= 2;
+
+#define XGI310SetupX0Y0(x,y) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, LINE_X0, (y)<<16 | (x) );\
+      xgiCmdQueLen--;
+
+#define XGI310SetupX1Y1(x,y) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, LINE_X1, (y)<<16 | (x) );\
+      xgiCmdQueLen--;
+
+#define XGI310SetupLineCount(c) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT16(xgi_video_info.mmio_vbase, LINE_COUNT, c);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupStylePeriod(p) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT16(xgi_video_info.mmio_vbase, LINE_STYLE_PERIOD, p);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupStyleLow(ls) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, LINE_STYLE_0, ls);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupStyleHigh(ls) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, LINE_STYLE_1, ls);\
+      xgiCmdQueLen--;
+
+int  XGIfb_initaccel(void);
+void XGIfb_syncaccel(void);
+
+extern struct video_info xgi_video_info;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,5,33)
+void fbcon_XGI_bmove(struct display *p, int srcy, int srcx, int dsty,
+                     int dstx, int height, int width);
+void fbcon_XGI_revc(struct display *p, int srcy, int srcx);
+void fbcon_XGI_clear8(struct vc_data *conp, struct display *p, int srcy,
+                      int srcx, int height, int width);
+void fbcon_XGI_clear16(struct vc_data *conp, struct display *p, int srcy,
+                       int srcx, int height, int width);
+void fbcon_XGI_clear32(struct vc_data *conp, struct display *p, int srcy,
+                       int srcx, int height, int width);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,34)
+extern int XGIfb_accel;
+void fbcon_XGI_fillrect(struct fb_info *info, const struct fb_fillrect *rect);
+void fbcon_XGI_copyarea(struct fb_info *info, const struct fb_copyarea *area);
+#endif
+
+#endif
diff --git a/drivers/video/xgi/XGI_main.h b/drivers/video/xgi/XGI_main.h
new file mode 100644
index 0000000..1d73cd5
--- /dev/null
+++ b/drivers/video/xgi/XGI_main.h
@@ -0,0 +1,1042 @@
+#ifndef _XGIFB_MAIN
+#define _XGIFB_MAIN
+
+
+/* ------------------- Constant Definitions ------------------------- */
+
+
+#include "XGIfb.h"
+#include "vb_struct.h"
+#include "vb_def.h"
+
+//#define LINUXBIOS   /* turn this on when compiling for LINUXBIOS */
+#define AGPOFF     /* default is turn off AGP */
+
+#define XGIFAIL(x) do { printk(x "\n"); return -EINVAL; } while(0)
+
+#define VER_MAJOR                 0
+#define VER_MINOR                 8
+#define VER_LEVEL                 1
+
+#define DRIVER_DESC  "XGI Volari Frame Buffer Module Version 0.8.1"
+
+#ifndef PCI_VENDOR_ID_XG
+#define PCI_VENDOR_ID_XG          0x18CA
+#endif
+                                                                                
+#ifndef PCI_DEVICE_ID_XG_40
+#define PCI_DEVICE_ID_XG_40      0x040
+#endif
+#ifndef PCI_DEVICE_ID_XG_41
+#define PCI_DEVICE_ID_XG_41      0x041
+#endif
+#ifndef PCI_DEVICE_ID_XG_42
+#define PCI_DEVICE_ID_XG_42      0x042
+#endif
+#ifndef PCI_DEVICE_ID_XG_20
+#define PCI_DEVICE_ID_XG_20      0x020
+#endif
+#ifndef PCI_DEVICE_ID_XG_27
+#define PCI_DEVICE_ID_XG_27      0x027
+#endif
+
+
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+#define XGI_IOTYPE1 void __iomem
+#define XGI_IOTYPE2 __iomem
+#define XGIINITSTATIC static
+#else
+#define XGI_IOTYPE1 unsigned char
+#define XGI_IOTYPE2
+#define XGIINITSTATIC
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+static struct pci_device_id __devinitdata xgifb_pci_table[] = {
+
+	{ PCI_VENDOR_ID_XG, PCI_DEVICE_ID_XG_20, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{ PCI_VENDOR_ID_XG, PCI_DEVICE_ID_XG_27, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1},
+	{ PCI_VENDOR_ID_XG, PCI_DEVICE_ID_XG_40, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 2},
+	{ PCI_VENDOR_ID_XG, PCI_DEVICE_ID_XG_42, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 3},
+	{ 0 }
+};
+
+MODULE_DEVICE_TABLE(pci, xgifb_pci_table);
+#endif 
+/* To be included in fb.h */
+#ifndef FB_ACCEL_XGI_GLAMOUR_2
+#define FB_ACCEL_XGI_GLAMOUR_2  40	/* XGI 315, 650, 740		*/
+#endif
+#ifndef FB_ACCEL_XGI_XABRE
+#define FB_ACCEL_XGI_XABRE      41	/* XGI 330 ("Xabre")		*/
+#endif
+
+#define MAX_ROM_SCAN              0x10000
+
+#define HW_CURSOR_CAP             0x80
+#define TURBO_QUEUE_CAP           0x40
+#define AGP_CMD_QUEUE_CAP         0x20
+#define VM_CMD_QUEUE_CAP          0x10
+#define MMIO_CMD_QUEUE_CAP        0x08
+
+
+
+/* For 315 series */
+
+#define COMMAND_QUEUE_AREA_SIZE   0x80000 /* 512K */
+#define COMMAND_QUEUE_THRESHOLD   0x1F
+
+
+/* TW */
+#define HW_CURSOR_AREA_SIZE_315   0x4000  /* 16K */
+#define HW_CURSOR_AREA_SIZE_300   0x1000  /* 4K */
+
+#define OH_ALLOC_SIZE             4000
+#define SENTINEL                  0x7fffffff
+
+#define SEQ_ADR                   0x14
+#define SEQ_DATA                  0x15
+#define DAC_ADR                   0x18
+#define DAC_DATA                  0x19
+#define CRTC_ADR                  0x24
+#define CRTC_DATA                 0x25
+#define DAC2_ADR                  (0x16-0x30)
+#define DAC2_DATA                 (0x17-0x30)
+#define VB_PART1_ADR              (0x04-0x30)
+#define VB_PART1_DATA             (0x05-0x30)
+#define VB_PART2_ADR              (0x10-0x30)
+#define VB_PART2_DATA             (0x11-0x30)
+#define VB_PART3_ADR              (0x12-0x30)
+#define VB_PART3_DATA             (0x13-0x30)
+#define VB_PART4_ADR              (0x14-0x30)
+#define VB_PART4_DATA             (0x15-0x30)
+
+#define XGISR			  XGI_Pr.P3c4
+#define XGICR                     XGI_Pr.P3d4
+#define XGIDACA                   XGI_Pr.P3c8
+#define XGIDACD                   XGI_Pr.P3c9
+#define XGIPART1                  XGI_Pr.Part1Port
+#define XGIPART2                  XGI_Pr.Part2Port
+#define XGIPART3                  XGI_Pr.Part3Port
+#define XGIPART4                  XGI_Pr.Part4Port
+#define XGIPART5                  XGI_Pr.Part5Port
+#define XGIDAC2A                  XGIPART5
+#define XGIDAC2D                  (XGIPART5 + 1)
+#define XGIMISCR                  (XGI_Pr.RelIO + 0x1c)
+#define XGIINPSTAT		  (XGI_Pr.RelIO + 0x2a)  
+
+#define IND_XGI_PASSWORD          0x05  /* SRs */
+#define IND_XGI_COLOR_MODE        0x06
+#define IND_XGI_RAMDAC_CONTROL    0x07
+#define IND_XGI_DRAM_SIZE         0x14
+#define IND_XGI_SCRATCH_REG_16    0x16
+#define IND_XGI_SCRATCH_REG_17    0x17
+#define IND_XGI_SCRATCH_REG_1A    0x1A
+#define IND_XGI_MODULE_ENABLE     0x1E
+#define IND_XGI_PCI_ADDRESS_SET   0x20
+#define IND_XGI_TURBOQUEUE_ADR    0x26
+#define IND_XGI_TURBOQUEUE_SET    0x27
+#define IND_XGI_POWER_ON_TRAP     0x38
+#define IND_XGI_POWER_ON_TRAP2    0x39
+#define IND_XGI_CMDQUEUE_SET      0x26
+#define IND_XGI_CMDQUEUE_THRESHOLD  0x27
+
+#define IND_XGI_SCRATCH_REG_CR30  0x30  /* CRs */
+#define IND_XGI_SCRATCH_REG_CR31  0x31
+#define IND_XGI_SCRATCH_REG_CR32  0x32
+#define IND_XGI_SCRATCH_REG_CR33  0x33
+#define IND_XGI_LCD_PANEL         0x36
+#define IND_XGI_SCRATCH_REG_CR37  0x37
+#define IND_XGI_AGP_IO_PAD        0x48
+
+#define IND_BRI_DRAM_STATUS       0x63 /* PCI config memory size offset */
+
+#define MMIO_QUEUE_PHYBASE        0x85C0
+#define MMIO_QUEUE_WRITEPORT      0x85C4
+#define MMIO_QUEUE_READPORT       0x85C8
+
+#define IND_XGI_CRT2_WRITE_ENABLE_300 0x24
+#define IND_XGI_CRT2_WRITE_ENABLE_315 0x2F
+
+#define XGI_PASSWORD              0x86  /* SR05 */
+#define XGI_INTERLACED_MODE       0x20  /* SR06 */
+#define XGI_8BPP_COLOR_MODE       0x0 
+#define XGI_15BPP_COLOR_MODE      0x1 
+#define XGI_16BPP_COLOR_MODE      0x2 
+#define XGI_32BPP_COLOR_MODE      0x4 
+
+#define XGI_DRAM_SIZE_MASK     0xF0  /*SR14 */
+#define XGI_DRAM_SIZE_1MB      0x00
+#define XGI_DRAM_SIZE_2MB      0x01
+#define XGI_DRAM_SIZE_4MB      0x02
+#define XGI_DRAM_SIZE_8MB      0x03
+#define XGI_DRAM_SIZE_16MB     0x04
+#define XGI_DRAM_SIZE_32MB     0x05
+#define XGI_DRAM_SIZE_64MB     0x06
+#define XGI_DRAM_SIZE_128MB    0x07
+#define XGI_DRAM_SIZE_256MB    0x08
+#define XGI_DATA_BUS_MASK      0x02
+#define XGI_DATA_BUS_64        0x00
+#define XGI_DATA_BUS_128       0x01
+#define XGI_DUAL_CHANNEL_MASK  0x0C
+#define XGI_SINGLE_CHANNEL_1_RANK  	0x0
+#define XGI_SINGLE_CHANNEL_2_RANK  	0x1
+#define XGI_ASYM_DDR		  	0x02
+#define XGI_DUAL_CHANNEL_1_RANK    	0x3
+
+#define XGI550_DRAM_SIZE_MASK     0x3F  /* 550/650/740 SR14 */
+#define XGI550_DRAM_SIZE_4MB      0x00
+#define XGI550_DRAM_SIZE_8MB      0x01
+#define XGI550_DRAM_SIZE_16MB     0x03
+#define XGI550_DRAM_SIZE_24MB     0x05
+#define XGI550_DRAM_SIZE_32MB     0x07
+#define XGI550_DRAM_SIZE_64MB     0x0F
+#define XGI550_DRAM_SIZE_96MB     0x17
+#define XGI550_DRAM_SIZE_128MB    0x1F
+#define XGI550_DRAM_SIZE_256MB    0x3F
+
+#define XGI_SCRATCH_REG_1A_MASK   0x10
+
+#define XGI_ENABLE_2D             0x40  /* SR1E */
+
+#define XGI_MEM_MAP_IO_ENABLE     0x01  /* SR20 */
+#define XGI_PCI_ADDR_ENABLE       0x80
+
+#define XGI_AGP_CMDQUEUE_ENABLE   0x80  /* 315/650/740 SR26 */
+#define XGI_VRAM_CMDQUEUE_ENABLE  0x40
+#define XGI_MMIO_CMD_ENABLE       0x20
+#define XGI_CMD_QUEUE_SIZE_512k   0x00
+#define XGI_CMD_QUEUE_SIZE_1M     0x04
+#define XGI_CMD_QUEUE_SIZE_2M     0x08
+#define XGI_CMD_QUEUE_SIZE_4M     0x0C
+#define XGI_CMD_QUEUE_RESET       0x01
+#define XGI_CMD_AUTO_CORR	  0x02
+
+#define XGI_SIMULTANEOUS_VIEW_ENABLE  0x01  /* CR30 */
+#define XGI_MODE_SELECT_CRT2      0x02
+#define XGI_VB_OUTPUT_COMPOSITE   0x04
+#define XGI_VB_OUTPUT_SVIDEO      0x08
+#define XGI_VB_OUTPUT_SCART       0x10
+#define XGI_VB_OUTPUT_LCD         0x20
+#define XGI_VB_OUTPUT_CRT2        0x40
+#define XGI_VB_OUTPUT_HIVISION    0x80
+
+#define XGI_VB_OUTPUT_DISABLE     0x20  /* CR31 */
+#define XGI_DRIVER_MODE           0x40
+
+#define XGI_VB_COMPOSITE          0x01  /* CR32 */
+#define XGI_VB_SVIDEO             0x02
+#define XGI_VB_SCART              0x04
+#define XGI_VB_LCD                0x08
+#define XGI_VB_CRT2               0x10
+#define XGI_CRT1                  0x20
+#define XGI_VB_HIVISION           0x40
+#define XGI_VB_YPBPR                0x80
+#define XGI_VB_TV                 (XGI_VB_COMPOSITE | XGI_VB_SVIDEO | \
+                                   XGI_VB_SCART | XGI_VB_HIVISION|XGI_VB_YPBPR)
+
+#define XGI_EXTERNAL_CHIP_MASK    	   0x0E  /* CR37 */
+#define XGI_EXTERNAL_CHIP_XGI301           0x01  /* in CR37 << 1 ! */
+#define XGI_EXTERNAL_CHIP_LVDS             0x02  /* in CR37 << 1 ! */
+#define XGI_EXTERNAL_CHIP_TRUMPION         0x03  /* in CR37 << 1 ! */
+#define XGI_EXTERNAL_CHIP_LVDS_CHRONTEL    0x04  /* in CR37 << 1 ! */
+#define XGI_EXTERNAL_CHIP_CHRONTEL         0x05  /* in CR37 << 1 ! */
+#define XGI310_EXTERNAL_CHIP_LVDS          0x02  /* in CR37 << 1 ! */
+#define XGI310_EXTERNAL_CHIP_LVDS_CHRONTEL 0x03  /* in CR37 << 1 ! */
+
+#define XGI_AGP_2X                0x20  /* CR48 */
+
+#define BRI_DRAM_SIZE_MASK        0x70  /* PCI bridge config data */
+#define BRI_DRAM_SIZE_2MB         0x00
+#define BRI_DRAM_SIZE_4MB         0x01
+#define BRI_DRAM_SIZE_8MB         0x02
+#define BRI_DRAM_SIZE_16MB        0x03
+#define BRI_DRAM_SIZE_32MB        0x04
+#define BRI_DRAM_SIZE_64MB        0x05
+
+#define HW_DEVICE_EXTENSION	  XGI_HW_DEVICE_INFO
+#define PHW_DEVICE_EXTENSION      PXGI_HW_DEVICE_INFO
+
+#define SR_BUFFER_SIZE            5
+#define CR_BUFFER_SIZE            5
+
+/* Useful macros */
+#define inXGIREG(base)          inb(base)
+#define outXGIREG(base,val)     outb(val,base)
+#define orXGIREG(base,val)      do { \
+                                  unsigned char __Temp = inb(base); \
+                                  outXGIREG(base, __Temp | (val)); \
+                                } while (0)
+#define andXGIREG(base,val)     do { \
+                                  unsigned char __Temp = inb(base); \
+                                  outXGIREG(base, __Temp & (val)); \
+                                } while (0)
+#define inXGIIDXREG(base,idx,var)   do { \
+                                      outb(idx,base); var=inb((base)+1); \
+                                    } while (0)
+#define outXGIIDXREG(base,idx,val)  do { \
+                                      outb(idx,base); outb((val),(base)+1); \
+                                    } while (0)
+#define orXGIIDXREG(base,idx,val)   do { \
+                                      unsigned char __Temp; \
+                                      outb(idx,base);   \
+                                      __Temp = inb((base)+1)|(val); \
+                                      outXGIIDXREG(base,idx,__Temp); \
+                                    } while (0)
+#define andXGIIDXREG(base,idx,and)  do { \
+                                      unsigned char __Temp; \
+                                      outb(idx,base);   \
+                                      __Temp = inb((base)+1)&(and); \
+                                      outXGIIDXREG(base,idx,__Temp); \
+                                    } while (0)
+#define setXGIIDXREG(base,idx,and,or)   do { \
+                                          unsigned char __Temp; \
+                                          outb(idx,base);   \
+                                          __Temp = (inb((base)+1)&(and))|(or); \
+                                          outXGIIDXREG(base,idx,__Temp); \
+                                        } while (0)
+
+/* ------------------- Global Variables ----------------------------- */
+
+/* Fbcon variables */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+static struct fb_info* fb_info;
+#else
+static struct fb_info XGI_fb_info;
+#endif
+
+
+static int    video_type = FB_TYPE_PACKED_PIXELS;
+
+static struct fb_var_screeninfo default_var = {
+	.xres		= 0,
+	.yres		= 0,
+	.xres_virtual	= 0,
+	.yres_virtual	= 0,
+	.xoffset	= 0,
+	.yoffset	= 0,
+	.bits_per_pixel	= 0,
+	.grayscale	= 0,
+	.red		= {0, 8, 0},
+	.green		= {0, 8, 0},
+	.blue		= {0, 8, 0},
+	.transp		= {0, 0, 0},
+	.nonstd		= 0,
+	.activate	= FB_ACTIVATE_NOW,
+	.height		= -1,
+	.width		= -1,
+	.accel_flags	= 0,
+	.pixclock	= 0,
+	.left_margin	= 0,
+	.right_margin	= 0,
+	.upper_margin	= 0,
+	.lower_margin	= 0,
+	.hsync_len	= 0,
+	.vsync_len	= 0,
+	.sync		= 0,
+	.vmode		= FB_VMODE_NONINTERLACED,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)	
+	.reserved	= {0, 0, 0, 0, 0, 0}
+#endif	
+};
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+static struct fb_fix_screeninfo XGIfb_fix = {
+	.id		= "XGI",
+	.type		= FB_TYPE_PACKED_PIXELS,
+	.xpanstep	= 1,
+	.ypanstep	= 1,
+};
+static char myid[20];
+static u32 pseudo_palette[17];
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+static struct display XGI_disp;
+
+static struct display_switch XGIfb_sw;	
+
+static struct {
+	u16 blue, green, red, pad;
+} XGI_palette[256];
+
+static union {
+#ifdef FBCON_HAS_CFB16
+	u16 cfb16[16];
+#endif
+#ifdef FBCON_HAS_CFB32
+	u32 cfb32[16];
+#endif
+} XGI_fbcon_cmap;
+
+static int XGIfb_inverse = 0;
+#endif
+
+/* display status */
+static int XGIfb_off = 0;
+static int XGIfb_crt1off = 0;
+static int XGIfb_forcecrt1 = -1;
+static int XGIvga_enabled = 0;
+static int XGIfb_userom = 0;
+//static int XGIfb_useoem = -1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+static int currcon = 0;
+#endif
+
+/* global flags */
+static int XGIfb_registered;
+static int XGIfb_tvmode = 0;
+static int XGIfb_mem = 0;
+static int XGIfb_pdc = 0;
+static int enable_dstn = 0;
+static int XGIfb_ypan = -1;
+
+
+int 	   XGIfb_accel = 0;
+
+
+static int XGIfb_hwcursor_size = 0;
+static int XGIfb_CRT2_write_enable = 0;
+
+int XGIfb_crt2type  = -1;	/* TW: CRT2 type (for overriding autodetection) */
+int XGIfb_tvplug    = -1;	/* PR: Tv plug type (for overriding autodetection) */
+
+int XGIfb_queuemode = -1; 	/* TW: Use MMIO queue mode by default (310/325 series only) */
+
+unsigned char XGIfb_detectedpdc = 0;
+
+unsigned char XGIfb_detectedlcda = 0xff;
+
+
+
+
+/* TW: For ioctl XGIFB_GET_INFO */
+/* XGIfb_info XGIfbinfo; */
+
+/* TW: Hardware extension; contains data on hardware */
+HW_DEVICE_EXTENSION XGIhw_ext = {
+	NULL, NULL, FALSE, NULL, NULL,
+	0, 0, 0, 0, 0, 0, 0, 0, 0,
+	NULL, NULL, NULL, NULL,
+	{0, 0, 0, 0},
+	0
+};
+
+/* TW: XGI private structure */
+VB_DEVICE_INFO  XGI_Pr;
+
+/* card parameters */
+static unsigned long XGIfb_mmio_size = 0;
+static u8            XGIfb_caps = 0;
+
+typedef enum _XGI_CMDTYPE {
+	MMIO_CMD = 0,
+	AGP_CMD_QUEUE,
+	VM_CMD_QUEUE,
+} XGI_CMDTYPE;
+
+/* Supported XGI Chips list */
+static struct board {
+	u16 vendor, device;
+	const char *name;
+} XGIdev_list[] = {
+	{PCI_VENDOR_ID_XG, PCI_DEVICE_ID_XG_20,     "XG20"},
+	{PCI_VENDOR_ID_XG, PCI_DEVICE_ID_XG_27,     "XG27"},
+	{PCI_VENDOR_ID_XG, PCI_DEVICE_ID_XG_40,     "XGI 340"},
+    {PCI_VENDOR_ID_XG, PCI_DEVICE_ID_XG_42,     "XGI 342"},
+	{0, 0, NULL}
+};
+
+#define MD_XGI300 1
+#define MD_XGI315 2
+
+/* mode table */
+/* NOT const - will be patched for 1280x960 mode number chaos reasons */
+struct _XGIbios_mode {
+	char name[15];
+	u8 mode_no;
+	u16 vesa_mode_no_1;  /* "XGI defined" VESA mode number */
+	u16 vesa_mode_no_2;  /* Real VESA mode numbers */
+	u16 xres;
+	u16 yres;
+	u16 bpp;
+	u16 rate_idx;
+	u16 cols;
+	u16 rows;
+	u8  chipset;
+} XGIbios_mode[] = {
+#define MODE_INDEX_NONE           0  /* TW: index for mode=none */
+	{"none",         0xFF, 0x0000, 0x0000,    0,    0,  0, 0,   0,  0, MD_XGI300|MD_XGI315},  /* TW: for mode "none" */
+	{"320x240x16",   0x56, 0x0000, 0x0000,  320,  240, 16, 1,  40, 15,           MD_XGI315},
+	{"320x480x8",    0x5A, 0x0000, 0x0000,  320,  480,  8, 1,  40, 30,           MD_XGI315},  /* TW: FSTN */
+	{"320x480x16",   0x5B, 0x0000, 0x0000,  320,  480, 16, 1,  40, 30,           MD_XGI315},  /* TW: FSTN */
+	{"640x480x8",    0x2E, 0x0101, 0x0101,  640,  480,  8, 1,  80, 30, MD_XGI300|MD_XGI315},
+	{"640x480x16",   0x44, 0x0111, 0x0111,  640,  480, 16, 1,  80, 30, MD_XGI300|MD_XGI315},
+	{"640x480x24",   0x62, 0x013a, 0x0112,  640,  480, 32, 1,  80, 30, MD_XGI300|MD_XGI315},  /* TW: That's for people who mix up color- and fb depth */
+	{"640x480x32",   0x62, 0x013a, 0x0112,  640,  480, 32, 1,  80, 30, MD_XGI300|MD_XGI315},
+	{"720x480x8",    0x31, 0x0000, 0x0000,  720,  480,  8, 1,  90, 30, MD_XGI300|MD_XGI315},
+	{"720x480x16",   0x33, 0x0000, 0x0000,  720,  480, 16, 1,  90, 30, MD_XGI300|MD_XGI315},
+	{"720x480x24",   0x35, 0x0000, 0x0000,  720,  480, 32, 1,  90, 30, MD_XGI300|MD_XGI315},
+	{"720x480x32",   0x35, 0x0000, 0x0000,  720,  480, 32, 1,  90, 30, MD_XGI300|MD_XGI315},
+	{"720x576x8",    0x32, 0x0000, 0x0000,  720,  576,  8, 1,  90, 36, MD_XGI300|MD_XGI315},
+	{"720x576x16",   0x34, 0x0000, 0x0000,  720,  576, 16, 1,  90, 36, MD_XGI300|MD_XGI315},
+	{"720x576x24",   0x36, 0x0000, 0x0000,  720,  576, 32, 1,  90, 36, MD_XGI300|MD_XGI315},
+	{"720x576x32",   0x36, 0x0000, 0x0000,  720,  576, 32, 1,  90, 36, MD_XGI300|MD_XGI315},
+	{"800x480x8",    0x70, 0x0000, 0x0000,  800,  480,  8, 1, 100, 30, MD_XGI300|MD_XGI315},
+	{"800x480x16",   0x7a, 0x0000, 0x0000,  800,  480, 16, 1, 100, 30, MD_XGI300|MD_XGI315},
+	{"800x480x24",   0x76, 0x0000, 0x0000,  800,  480, 32, 1, 100, 30, MD_XGI300|MD_XGI315},
+	{"800x480x32",   0x76, 0x0000, 0x0000,  800,  480, 32, 1, 100, 30, MD_XGI300|MD_XGI315},
+#define DEFAULT_MODE              33 /* TW: index for 800x600x8 */
+#define DEFAULT_LCDMODE           33 /* TW: index for 800x600x8 */
+#define DEFAULT_TVMODE            33 /* TW: index for 800x600x8 */
+	{"800x600x8",    0x30, 0x0103, 0x0103,  800,  600,  8, 1, 100, 37, MD_XGI300|MD_XGI315},
+	{"800x600x16",   0x47, 0x0114, 0x0114,  800,  600, 16, 1, 100, 37, MD_XGI300|MD_XGI315},
+	{"800x600x24",   0x63, 0x013b, 0x0115,  800,  600, 32, 1, 100, 37, MD_XGI300|MD_XGI315},
+	{"800x600x32",   0x63, 0x013b, 0x0115,  800,  600, 32, 1, 100, 37, MD_XGI300|MD_XGI315},
+	{"1024x576x8",   0x71, 0x0000, 0x0000, 1024,  576,  8, 1, 128, 36, MD_XGI300|MD_XGI315},
+	{"1024x576x16",  0x74, 0x0000, 0x0000, 1024,  576, 16, 1, 128, 36, MD_XGI300|MD_XGI315},
+	{"1024x576x24",  0x77, 0x0000, 0x0000, 1024,  576, 32, 1, 128, 36, MD_XGI300|MD_XGI315},
+	{"1024x576x32",  0x77, 0x0000, 0x0000, 1024,  576, 32, 1, 128, 36, MD_XGI300|MD_XGI315},
+	{"1024x600x8",   0x20, 0x0000, 0x0000, 1024,  600,  8, 1, 128, 37, MD_XGI300          },  /* TW: 300 series only */
+	{"1024x600x16",  0x21, 0x0000, 0x0000, 1024,  600, 16, 1, 128, 37, MD_XGI300          },
+	{"1024x600x24",  0x22, 0x0000, 0x0000, 1024,  600, 32, 1, 128, 37, MD_XGI300          },
+	{"1024x600x32",  0x22, 0x0000, 0x0000, 1024,  600, 32, 1, 128, 37, MD_XGI300          },
+	{"1024x768x8",   0x38, 0x0105, 0x0105, 1024,  768,  8, 1, 128, 48, MD_XGI300|MD_XGI315},
+	{"1024x768x16",  0x4A, 0x0117, 0x0117, 1024,  768, 16, 1, 128, 48, MD_XGI300|MD_XGI315},
+	{"1024x768x24",  0x64, 0x013c, 0x0118, 1024,  768, 32, 1, 128, 48, MD_XGI300|MD_XGI315},
+	{"1024x768x32",  0x64, 0x013c, 0x0118, 1024,  768, 32, 1, 128, 48, MD_XGI300|MD_XGI315},
+	{"1152x768x8",   0x23, 0x0000, 0x0000, 1152,  768,  8, 1, 144, 48, MD_XGI300          },  /* TW: 300 series only */
+	{"1152x768x16",  0x24, 0x0000, 0x0000, 1152,  768, 16, 1, 144, 48, MD_XGI300          },
+	{"1152x768x24",  0x25, 0x0000, 0x0000, 1152,  768, 32, 1, 144, 48, MD_XGI300          },
+	{"1152x768x32",  0x25, 0x0000, 0x0000, 1152,  768, 32, 1, 144, 48, MD_XGI300          },
+	{"1280x720x8",   0x79, 0x0000, 0x0000, 1280,  720,  8, 1, 160, 45, MD_XGI300|MD_XGI315},
+	{"1280x720x16",  0x75, 0x0000, 0x0000, 1280,  720, 16, 1, 160, 45, MD_XGI300|MD_XGI315},
+	{"1280x720x24",  0x78, 0x0000, 0x0000, 1280,  720, 32, 1, 160, 45, MD_XGI300|MD_XGI315},
+	{"1280x720x32",  0x78, 0x0000, 0x0000, 1280,  720, 32, 1, 160, 45, MD_XGI300|MD_XGI315},
+	{"1280x768x8",   0x23, 0x0000, 0x0000, 1280,  768,  8, 1, 160, 48,           MD_XGI315},  /* TW: 310/325 series only */
+	{"1280x768x16",  0x24, 0x0000, 0x0000, 1280,  768, 16, 1, 160, 48,           MD_XGI315},
+	{"1280x768x24",  0x25, 0x0000, 0x0000, 1280,  768, 32, 1, 160, 48,           MD_XGI315},
+	{"1280x768x32",  0x25, 0x0000, 0x0000, 1280,  768, 32, 1, 160, 48,           MD_XGI315},
+#define MODEINDEX_1280x960 48
+	{"1280x960x8",   0x7C, 0x0000, 0x0000, 1280,  960,  8, 1, 160, 60, MD_XGI300|MD_XGI315},  /* TW: Modenumbers being patched */
+	{"1280x960x16",  0x7D, 0x0000, 0x0000, 1280,  960, 16, 1, 160, 60, MD_XGI300|MD_XGI315},
+	{"1280x960x24",  0x7E, 0x0000, 0x0000, 1280,  960, 32, 1, 160, 60, MD_XGI300|MD_XGI315},
+	{"1280x960x32",  0x7E, 0x0000, 0x0000, 1280,  960, 32, 1, 160, 60, MD_XGI300|MD_XGI315},
+	{"1280x1024x8",  0x3A, 0x0107, 0x0107, 1280, 1024,  8, 1, 160, 64, MD_XGI300|MD_XGI315},
+	{"1280x1024x16", 0x4D, 0x011a, 0x011a, 1280, 1024, 16, 1, 160, 64, MD_XGI300|MD_XGI315},
+	{"1280x1024x24", 0x65, 0x013d, 0x011b, 1280, 1024, 32, 1, 160, 64, MD_XGI300|MD_XGI315},
+	{"1280x1024x32", 0x65, 0x013d, 0x011b, 1280, 1024, 32, 1, 160, 64, MD_XGI300|MD_XGI315},
+	{"1400x1050x8",  0x26, 0x0000, 0x0000, 1400, 1050,  8, 1, 175, 65,           MD_XGI315},  /* TW: 310/325 series only */
+	{"1400x1050x16", 0x27, 0x0000, 0x0000, 1400, 1050, 16, 1, 175, 65,           MD_XGI315},
+	{"1400x1050x24", 0x28, 0x0000, 0x0000, 1400, 1050, 32, 1, 175, 65,           MD_XGI315},
+	{"1400x1050x32", 0x28, 0x0000, 0x0000, 1400, 1050, 32, 1, 175, 65,           MD_XGI315},
+	{"1600x1200x8",  0x3C, 0x0130, 0x011c, 1600, 1200,  8, 1, 200, 75, MD_XGI300|MD_XGI315},
+	{"1600x1200x16", 0x3D, 0x0131, 0x011e, 1600, 1200, 16, 1, 200, 75, MD_XGI300|MD_XGI315},
+	{"1600x1200x24", 0x66, 0x013e, 0x011f, 1600, 1200, 32, 1, 200, 75, MD_XGI300|MD_XGI315},
+	{"1600x1200x32", 0x66, 0x013e, 0x011f, 1600, 1200, 32, 1, 200, 75, MD_XGI300|MD_XGI315},
+	{"1920x1440x8",  0x68, 0x013f, 0x0000, 1920, 1440,  8, 1, 240, 75, MD_XGI300|MD_XGI315},
+	{"1920x1440x16", 0x69, 0x0140, 0x0000, 1920, 1440, 16, 1, 240, 75, MD_XGI300|MD_XGI315},
+	{"1920x1440x24", 0x6B, 0x0141, 0x0000, 1920, 1440, 32, 1, 240, 75, MD_XGI300|MD_XGI315},
+	{"1920x1440x32", 0x6B, 0x0141, 0x0000, 1920, 1440, 32, 1, 240, 75, MD_XGI300|MD_XGI315},
+	{"2048x1536x8",  0x6c, 0x0000, 0x0000, 2048, 1536,  8, 1, 256, 96,           MD_XGI315},  /* TW: 310/325 series only */
+	{"2048x1536x16", 0x6d, 0x0000, 0x0000, 2048, 1536, 16, 1, 256, 96,           MD_XGI315},
+	{"2048x1536x24", 0x6e, 0x0000, 0x0000, 2048, 1536, 32, 1, 256, 96,           MD_XGI315},
+	{"2048x1536x32", 0x6e, 0x0000, 0x0000, 2048, 1536, 32, 1, 256, 96,           MD_XGI315},
+	{"\0", 0x00, 0, 0, 0, 0, 0, 0, 0}
+};
+
+/* mode-related variables */
+#ifdef MODULE
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+static int xgifb_mode_idx = 1;
+#else
+static int XGIfb_mode_idx = MODE_INDEX_NONE;  /* Don't use a mode by default if we are a module */
+#endif
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+static int xgifb_mode_idx = -1;               /* Use a default mode if we are inside the kernel */
+#else
+static int XGIfb_mode_idx = -1;
+#endif
+#endif
+u8  XGIfb_mode_no  = 0;
+u8  XGIfb_rate_idx = 0;
+
+/* TW: CR36 evaluation */
+const USHORT XGI300paneltype[] =
+    { LCD_UNKNOWN,   LCD_800x600,  LCD_1024x768,  LCD_1280x1024,
+      LCD_1280x960,  LCD_640x480,  LCD_1024x600,  LCD_1152x768,
+       LCD_1024x768, LCD_1024x768,  LCD_1024x768,
+      LCD_1024x768,  LCD_1024x768, LCD_1024x768,  LCD_1024x768 };
+
+const USHORT XGI310paneltype[] =
+    { LCD_UNKNOWN,   LCD_800x600,  LCD_1024x768,  LCD_1280x1024,
+      LCD_640x480,   LCD_1024x600, LCD_1152x864,  LCD_1280x960,
+      LCD_1152x768,  LCD_1400x1050,LCD_1280x768,  LCD_1600x1200,
+      LCD_1024x768, LCD_1024x768,  LCD_1024x768 };
+
+static const struct _XGI_crt2type {
+	char name[10];
+	int type_no;
+	int tvplug_no;
+} XGI_crt2type[] = {
+	{"NONE", 	0, 		-1},
+	{"LCD",  	DISPTYPE_LCD, 	-1},
+	{"TV",   	DISPTYPE_TV, 	-1},
+	{"VGA",  	DISPTYPE_CRT2, 	-1},
+	{"SVIDEO", 	DISPTYPE_TV, 	TVPLUG_SVIDEO},
+	{"COMPOSITE", 	DISPTYPE_TV, 	TVPLUG_COMPOSITE},
+	{"SCART", 	DISPTYPE_TV, 	TVPLUG_SCART},
+	{"none", 	0, 		-1},
+	{"lcd",  	DISPTYPE_LCD, 	-1},
+	{"tv",   	DISPTYPE_TV, 	-1},
+	{"vga",  	DISPTYPE_CRT2, 	-1},
+	{"svideo", 	DISPTYPE_TV, 	TVPLUG_SVIDEO},
+	{"composite", 	DISPTYPE_TV, 	TVPLUG_COMPOSITE},
+	{"scart", 	DISPTYPE_TV, 	TVPLUG_SCART},
+	{"\0",  	-1, 		-1}
+};
+
+/* Queue mode selection for 310 series */
+static const struct _XGI_queuemode {
+	char name[6];
+	int type_no;
+} XGI_queuemode[] = {
+	{"AGP",  	AGP_CMD_QUEUE},
+	{"VRAM", 	VM_CMD_QUEUE},
+	{"MMIO", 	MMIO_CMD},
+	{"agp",  	AGP_CMD_QUEUE},
+	{"vram", 	VM_CMD_QUEUE},
+	{"mmio", 	MMIO_CMD},
+	{"\0",   	-1}
+};
+
+/* TV standard */
+static const struct _XGI_tvtype {
+	char name[6];
+	int type_no;
+} XGI_tvtype[] = {
+	{"PAL",  	1},
+	{"NTSC", 	2},
+	{"pal", 	1},
+	{"ntsc",  	2},
+	{"\0",   	-1}
+};
+
+static const struct _XGI_vrate {
+	u16 idx;
+	u16 xres;
+	u16 yres;
+	u16 refresh;
+} XGIfb_vrate[] = {
+	{1,  640,  480, 60}, {2,  640,  480,  72}, {3, 640,   480,  75}, {4,  640, 480,  85},
+	{5,  640,  480,100}, {6,  640,  480, 120}, {7, 640,   480, 160}, {8,  640, 480, 200},
+	{1,  720,  480, 60},
+	{1,  720,  576, 58},
+	{1,  800,  480, 60}, {2,  800,  480,  75}, {3, 800,   480,  85},
+        {1,  800,  600,  60}, {2, 800,   600,  72}, {3,  800, 600,  75},
+	{4,  800,  600, 85}, {5,  800,  600, 100}, {6, 800,   600, 120}, {7,  800, 600, 160},
+	{1, 1024,  768,  60}, {2, 1024,  768,  70}, {3, 1024, 768,  75},
+	{4, 1024,  768, 85}, {5, 1024,  768, 100}, {6, 1024,  768, 120},
+	{1, 1024,  576, 60}, {2, 1024,  576,  75}, {3, 1024,  576,  85},
+	{1, 1024,  600, 60},
+	{1, 1152,  768, 60},
+	{1, 1280,  720, 60}, {2, 1280,  720,  75}, {3, 1280,  720,  85},
+	{1, 1280,  768, 60},
+        {1, 1280, 1024,  60}, {2, 1280, 1024,  75}, {3, 1280, 1024,  85},
+	{1, 1280,  960, 70},
+	{1, 1400, 1050, 60},
+	{1, 1600, 1200, 60}, {2, 1600, 1200,  65}, {3, 1600, 1200,  70}, {4, 1600, 1200,  75},
+	{5, 1600, 1200, 85}, {6, 1600, 1200, 100}, {7, 1600, 1200, 120},
+	{1, 1920, 1440, 60}, {2, 1920, 1440,  65}, {3, 1920, 1440,  70}, {4, 1920, 1440,  75},
+	{5, 1920, 1440, 85}, {6, 1920, 1440, 100},
+	{1, 2048, 1536, 60}, {2, 2048, 1536,  65}, {3, 2048, 1536,  70}, {4, 2048, 1536,  75},
+	{5, 2048, 1536, 85},
+	{0, 0, 0, 0}
+};
+
+static const struct _chswtable {
+    int subsysVendor;
+    int subsysCard;
+    char *vendorName;
+    char *cardName;
+} mychswtable[] = {
+        { 0x1631, 0x1002, "Mitachi", "0x1002" },
+	{ 0,      0,      ""       , ""       }
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+/* Offscreen layout */
+typedef struct _XGI_GLYINFO {
+	unsigned char ch;
+	int fontwidth;
+	int fontheight;
+	u8 gmask[72];
+	int ngmask;
+} XGI_GLYINFO;
+#endif
+
+typedef struct _XGI_OH {
+	struct _XGI_OH *poh_next;
+	struct _XGI_OH *poh_prev;
+	unsigned long offset;
+	unsigned long size;
+} XGI_OH;
+
+typedef struct _XGI_OHALLOC {
+	struct _XGI_OHALLOC *poha_next;
+	XGI_OH aoh[1];
+} XGI_OHALLOC;
+
+typedef struct _XGI_HEAP {
+	XGI_OH oh_free;
+	XGI_OH oh_used;
+	XGI_OH *poh_freelist;
+	XGI_OHALLOC *poha_chain;
+	unsigned long max_freesize;
+} XGI_HEAP;
+
+static unsigned long XGIfb_hwcursor_vbase;
+
+static unsigned long XGIfb_heap_start;
+static unsigned long XGIfb_heap_end;
+static unsigned long XGIfb_heap_size;
+static XGI_HEAP      XGIfb_heap;
+
+// Eden Chen
+static const struct _XGI_TV_filter {
+	u8 filter[9][4];
+} XGI_TV_filter[] = {
+	{ {{0x00,0x00,0x00,0x40},  /* NTSCFilter_0 */
+	   {0x00,0xE0,0x10,0x60},
+	   {0x00,0xEE,0x10,0x44},
+	   {0x00,0xF4,0x10,0x38},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xFC,0xFB,0x14,0x2A},
+	   {0x00,0x00,0x10,0x20},
+	   {0x00,0x04,0x10,0x18}, 
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* NTSCFilter_1 */
+	   {0x00,0xE0,0x10,0x60},
+	   {0x00,0xEE,0x10,0x44},
+	   {0x00,0xF4,0x10,0x38},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xFC,0xFB,0x14,0x2A},
+	   {0x00,0x00,0x10,0x20},
+	   {0x00,0x04,0x10,0x18}, 
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* NTSCFilter_2 */
+	   {0xF5,0xEE,0x1B,0x44},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xEB,0x04,0x25,0x18},
+	   {0xF1,0x05,0x1F,0x16},
+	   {0xF6,0x06,0x1A,0x14},
+	   {0xFA,0x06,0x16,0x14},
+	   {0x00,0x04,0x10,0x18}, 
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* NTSCFilter_3 */
+	   {0xF1,0x04,0x1F,0x18},
+	   {0xEE,0x0D,0x22,0x06},
+	   {0xF7,0x06,0x19,0x14},
+	   {0xF4,0x0B,0x1C,0x0A},
+	   {0xFA,0x07,0x16,0x12},
+	   {0xF9,0x0A,0x17,0x0C},
+	   {0x00,0x07,0x10,0x12}, 
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* NTSCFilter_4 */
+	   {0x00,0xE0,0x10,0x60},
+	   {0x00,0xEE,0x10,0x44},
+	   {0x00,0xF4,0x10,0x38},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xFC,0xFB,0x14,0x2A},
+	   {0x00,0x00,0x10,0x20},
+	   {0x00,0x04,0x10,0x18}, 
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* NTSCFilter_5 */
+	   {0xF5,0xEE,0x1B,0x44},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xEB,0x04,0x25,0x18},
+	   {0xF1,0x05,0x1F,0x16},
+	   {0xF6,0x06,0x1A,0x14},
+	   {0xFA,0x06,0x16,0x14},
+	   {0x00,0x04,0x10,0x18}, 
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* NTSCFilter_6 */
+	   {0xEB,0x04,0x25,0x18},
+	   {0xE7,0x0E,0x29,0x04},
+	   {0xEE,0x0C,0x22,0x08},
+	   {0xF6,0x0B,0x1A,0x0A},
+	   {0xF9,0x0A,0x17,0x0C},
+	   {0xFC,0x0A,0x14,0x0C},
+	   {0x00,0x08,0x10,0x10}, 
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* NTSCFilter_7 */
+	   {0xEC,0x02,0x24,0x1C},
+	   {0xF2,0x04,0x1E,0x18},
+	   {0xEB,0x15,0x25,0xF6},
+	   {0xF4,0x10,0x1C,0x00},
+	   {0xF8,0x0F,0x18,0x02},
+	   {0x00,0x04,0x10,0x18},
+	   {0x01,0x06,0x0F,0x14}, 
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* PALFilter_0 */
+	   {0x00,0xE0,0x10,0x60},
+	   {0x00,0xEE,0x10,0x44},
+	   {0x00,0xF4,0x10,0x38},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xFC,0xFB,0x14,0x2A},
+	   {0x00,0x00,0x10,0x20},
+	   {0x00,0x04,0x10,0x18}, 
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* PALFilter_1 */
+	   {0x00,0xE0,0x10,0x60},
+	   {0x00,0xEE,0x10,0x44},
+	   {0x00,0xF4,0x10,0x38},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xFC,0xFB,0x14,0x2A},
+	   {0x00,0x00,0x10,0x20},
+	   {0x00,0x04,0x10,0x18}, 
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* PALFilter_2 */
+	   {0xF5,0xEE,0x1B,0x44},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xF1,0xF7,0x01,0x32},
+	   {0xF5,0xFB,0x1B,0x2A},
+	   {0xF9,0xFF,0x17,0x22},
+	   {0xFB,0x01,0x15,0x1E},
+	   {0x00,0x04,0x10,0x18}, 
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* PALFilter_3 */
+	   {0xF5,0xFB,0x1B,0x2A},
+	   {0xEE,0xFE,0x22,0x24},
+	   {0xF3,0x00,0x1D,0x20},
+	   {0xF9,0x03,0x17,0x1A},
+	   {0xFB,0x02,0x14,0x1E},
+	   {0xFB,0x04,0x15,0x18},
+	   {0x00,0x06,0x10,0x14}, 
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* PALFilter_4 */
+	   {0x00,0xE0,0x10,0x60},
+	   {0x00,0xEE,0x10,0x44},
+	   {0x00,0xF4,0x10,0x38},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xFC,0xFB,0x14,0x2A},
+	   {0x00,0x00,0x10,0x20},
+	   {0x00,0x04,0x10,0x18}, 
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* PALFilter_5 */
+	   {0xF5,0xEE,0x1B,0x44},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xF1,0xF7,0x1F,0x32},
+	   {0xF5,0xFB,0x1B,0x2A},
+	   {0xF9,0xFF,0x17,0x22},
+	   {0xFB,0x01,0x15,0x1E},
+	   {0x00,0x04,0x10,0x18}, 
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* PALFilter_6 */
+	   {0xF5,0xEE,0x1B,0x2A},
+	   {0xEE,0xFE,0x22,0x24},
+	   {0xF3,0x00,0x1D,0x20},
+	   {0xF9,0x03,0x17,0x1A},
+	   {0xFB,0x02,0x14,0x1E},
+	   {0xFB,0x04,0x15,0x18},
+	   {0x00,0x06,0x10,0x14}, 
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* PALFilter_7 */
+	   {0xF5,0xEE,0x1B,0x44},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xFC,0xFB,0x14,0x2A},
+	   {0xEB,0x05,0x25,0x16},
+	   {0xF1,0x05,0x1F,0x16},
+	   {0xFA,0x07,0x16,0x12},
+	   {0x00,0x07,0x10,0x12}, 
+	   {0xFF,0xFF,0xFF,0xFF} }}
+};
+
+static int           filter = -1;
+static unsigned char filter_tb;
+
+
+/* ---------------------- Routine prototypes ------------------------- */
+
+/* Interface used by the world */
+#ifndef MODULE
+XGIINITSTATIC             XGIfb_setup(char *options);
+#endif
+
+/* Interface to the low level console driver */
+
+
+
+/* fbdev routines */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+       int	XGIfb_init(void);
+static int      XGIfb_get_fix(struct fb_fix_screeninfo *fix, 
+			      int con,
+			      struct fb_info *info);
+static int      XGIfb_get_var(struct fb_var_screeninfo *var, 
+			      int con,
+			      struct fb_info *info);
+static int      XGIfb_set_var(struct fb_var_screeninfo *var, 
+			      int con,
+			      struct fb_info *info);
+static void     XGIfb_crtc_to_var(struct fb_var_screeninfo *var);			      
+static int      XGIfb_get_cmap(struct fb_cmap *cmap, 
+			       int kspc, 
+			       int con,
+			       struct fb_info *info);
+static int      XGIfb_set_cmap(struct fb_cmap *cmap, 
+			       int kspc, 
+			       int con,
+			       struct fb_info *info);			
+static int      XGIfb_update_var(int con, 
+				 struct fb_info *info);
+static int      XGIfb_switch(int con, 
+			     struct fb_info *info);
+static void     XGIfb_blank(int blank, 
+			    struct fb_info *info);
+static void     XGIfb_set_disp(int con, 
+			       struct fb_var_screeninfo *var, 
+                               struct fb_info *info);
+static int      XGI_getcolreg(unsigned regno, unsigned *red, unsigned *green,
+			      unsigned *blue, unsigned *transp,
+			      struct fb_info *fb_info);
+static void     XGIfb_do_install_cmap(int con, 
+                                      struct fb_info *info);
+static void     XGI_get_glyph(struct fb_info *info, 
+                              XGI_GLYINFO *gly);
+static int 	XGIfb_mmap(struct fb_info *info, struct file *file,
+		           struct vm_area_struct *vma);	
+static int      XGIfb_ioctl(struct inode *inode, struct file *file,
+		       	    unsigned int cmd, unsigned long arg, int con,
+		       	    struct fb_info *info);		      
+#endif			
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+XGIINITSTATIC             xgifb_init(void);
+static int      XGIfb_set_par(struct fb_info *info);
+static int      XGIfb_blank(int blank, 
+                            struct fb_info *info);			
+/*static int 	XGIfb_mmap(struct fb_info *info, struct file *file,
+		           struct vm_area_struct *vma);			    
+*/
+extern void     fbcon_XGI_fillrect(struct fb_info *info, 
+                                   const struct fb_fillrect *rect);
+extern void     fbcon_XGI_copyarea(struct fb_info *info, 
+                                   const struct fb_copyarea *area);
+#if 0				   
+extern void     cfb_imageblit(struct fb_info *info, 
+                              const struct fb_image *image);
+#endif			      
+extern int      fbcon_XGI_sync(struct fb_info *info);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
+static int XGIfb_ioctl(struct fb_info *info, unsigned int cmd,
+			    unsigned long arg);
+#else
+static int      XGIfb_ioctl(struct inode *inode, 
+	 		    struct file *file,
+		       	    unsigned int cmd, 
+			    unsigned long arg, 
+		       	    struct fb_info *info);
+#endif
+
+/*
+extern int	XGIfb_mode_rate_to_dclock(VB_DEVICE_INFO *XGI_Pr, 
+			      PXGI_HW_DEVICE_INFO HwDeviceExtension,
+			      unsigned char modeno, unsigned char rateindex);	
+extern int      XGIfb_mode_rate_to_ddata(VB_DEVICE_INFO *XGI_Pr, PXGI_HW_DEVICE_INFO HwDeviceExtension,
+			 unsigned char modeno, unsigned char rateindex,
+			 unsigned int *left_margin, unsigned int *right_margin, 
+			 unsigned int *upper_margin, unsigned int *lower_margin,
+			 unsigned int *hsync_len, unsigned int *vsync_len,
+			 unsigned int *sync, unsigned int *vmode);		
+*/	      		    			      
+#endif
+			extern   BOOLEAN  XGI_SearchModeID( USHORT ModeNo,USHORT  *ModeIdIndex, PVB_DEVICE_INFO );
+static int      XGIfb_get_fix(struct fb_fix_screeninfo *fix, int con,
+			      struct fb_info *info);
+
+/* Internal 2D accelerator functions */
+extern int      XGIfb_initaccel(void);
+extern void     XGIfb_syncaccel(void);
+
+/* Internal general routines */
+static void     XGIfb_search_mode(const char *name);
+static int      XGIfb_validate_mode(int modeindex);
+static u8       XGIfb_search_refresh_rate(unsigned int rate);
+static int      XGIfb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			unsigned blue, unsigned transp,
+			struct fb_info *fb_info);
+static int      XGIfb_do_set_var(struct fb_var_screeninfo *var, int isactive,
+		      	struct fb_info *info);
+static void     XGIfb_pre_setmode(void);
+static void     XGIfb_post_setmode(void);
+
+static char *   XGI_find_rom(void);
+static BOOLEAN  XGIfb_CheckVBRetrace(void);
+static BOOLEAN  XGIfbcheckvretracecrt2(void);
+static BOOLEAN  XGIfbcheckvretracecrt1(void);
+static BOOLEAN  XGIfb_bridgeisslave(void);
+
+struct XGI_memreq {
+	unsigned long offset;
+	unsigned long size;
+};
+
+/* XGI-specific Export functions */
+void            XGI_dispinfo(struct ap_data *rec);
+void            XGI_malloc(struct XGI_memreq *req);
+void            XGI_free(unsigned long base);
+
+/* Internal hardware access routines */
+void            XGIfb_set_reg4(u16 port, unsigned long data);
+u32             XGIfb_get_reg3(u16 port);
+
+/* Chipset-dependent internal routines */
+
+
+static int      XGIfb_get_dram_size(void);
+static void     XGIfb_detect_VB(void);
+static void     XGIfb_get_VB_type(void);
+static int      XGIfb_has_VB(void);
+
+
+/* Internal heap routines */
+static int      XGIfb_heap_init(void);
+static XGI_OH   *XGIfb_poh_new_node(void);
+static XGI_OH   *XGIfb_poh_allocate(unsigned long size);
+static void     XGIfb_delete_node(XGI_OH *poh);
+static void     XGIfb_insert_node(XGI_OH *pohList, XGI_OH *poh);
+static XGI_OH   *XGIfb_poh_free(unsigned long base);
+static void     XGIfb_free_node(XGI_OH *poh);
+
+/* Internal routines to access PCI configuration space */
+BOOLEAN         XGIfb_query_VGA_config_space(PXGI_HW_DEVICE_INFO pXGIhw_ext,
+	          	unsigned long offset, unsigned long set, unsigned long *value);
+//BOOLEAN         XGIfb_query_north_bridge_space(PXGI_HW_DEVICE_INFO pXGIhw_ext,
+//	         	unsigned long offset, unsigned long set, unsigned long *value);
+
+
+/* Routines from init.c/init301.c */
+extern void     InitTo330Pointer(UCHAR,PVB_DEVICE_INFO pVBInfo);
+extern BOOLEAN  XGIInitNew(PXGI_HW_DEVICE_INFO HwDeviceExtension);
+extern BOOLEAN  XGISetModeNew(PXGI_HW_DEVICE_INFO HwDeviceExtension, USHORT ModeNo);
+//extern void     XGI_SetEnableDstn(VB_DEVICE_INFO *XGI_Pr);
+extern void     XGI_LongWait(VB_DEVICE_INFO *XGI_Pr);
+extern USHORT   XGI_GetRatePtrCRT2( PXGI_HW_DEVICE_INFO pXGIHWDE, USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo );
+/* TW: Chrontel TV functions */
+extern USHORT 	XGI_GetCH700x(VB_DEVICE_INFO *XGI_Pr, USHORT tempbx);
+extern void 	XGI_SetCH700x(VB_DEVICE_INFO *XGI_Pr, USHORT tempbx);
+extern USHORT 	XGI_GetCH701x(VB_DEVICE_INFO *XGI_Pr, USHORT tempbx);
+extern void 	XGI_SetCH701x(VB_DEVICE_INFO *XGI_Pr, USHORT tempbx);
+extern void     XGI_SetCH70xxANDOR(VB_DEVICE_INFO *XGI_Pr, USHORT tempax,USHORT tempbh);
+extern void     XGI_DDC2Delay(VB_DEVICE_INFO *XGI_Pr, USHORT delaytime);
+
+/* TW: Sensing routines */
+void            XGI_Sense30x(void);
+int             XGIDoSense(int tempbl, int tempbh, int tempcl, int tempch);
+
+			
+#endif
diff --git a/drivers/video/xgi/XGI_main_26.c b/drivers/video/xgi/XGI_main_26.c
new file mode 100644
index 0000000..c243d60
--- /dev/null
+++ b/drivers/video/xgi/XGI_main_26.c
@@ -0,0 +1,3790 @@
+/*
+ * XG20, XG21, XG40, XG42 frame buffer device
+ * for Linux kernels  2.5.x, 2.6.x
+ * Base on TW's sis fbdev code.
+ */
+
+//#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+#include <linux/selection.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/vmalloc.h>
+#include <linux/vt_kern.h>
+#include <linux/capability.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+
+
+#include "osdef.h"
+
+
+#ifndef XGIFB_PAN
+#define XGIFB_PAN
+#endif
+
+#include <asm/io.h>
+#ifdef CONFIG_MTRR
+#include <asm/mtrr.h>
+#endif
+
+#include "XGIfb.h"
+#include "vgatypes.h"
+#include "XGI_main.h"
+
+
+
+#define Index_CR_GPIO_Reg1 0x48
+#define Index_CR_GPIO_Reg2 0x49
+#define Index_CR_GPIO_Reg3 0x4a
+
+#define GPIOG_EN    (1<<6)
+#define GPIOG_WRITE (1<<6)
+#define GPIOG_READ  (1<<1)
+
+/* -------------------- Macro definitions ---------------------------- */
+
+#undef XGIFBDEBUG 	
+
+#ifdef XGIFBDEBUG
+#define DPRINTK(fmt, args...) printk(KERN_DEBUG "%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+void dumpVGAReg()
+{
+    u8 i,reg;
+
+outXGIIDXREG(XGISR, 0x05, 0x86);
+/*
+outXGIIDXREG(XGISR, 0x08, 0x4f);
+outXGIIDXREG(XGISR, 0x0f, 0x20);
+outXGIIDXREG(XGISR, 0x11, 0x4f);
+outXGIIDXREG(XGISR, 0x13, 0x45);
+outXGIIDXREG(XGISR, 0x14, 0x51);
+outXGIIDXREG(XGISR, 0x1e, 0x41);
+outXGIIDXREG(XGISR, 0x1f, 0x0);
+outXGIIDXREG(XGISR, 0x20, 0xa1);
+outXGIIDXREG(XGISR, 0x22, 0xfb);
+outXGIIDXREG(XGISR, 0x26, 0x22);
+outXGIIDXREG(XGISR, 0x3e, 0x07);
+*/
+
+//outXGIIDXREG(XGICR, 0x19, 0x00);
+//outXGIIDXREG(XGICR, 0x1a, 0x3C);
+//outXGIIDXREG(XGICR, 0x22, 0xff);
+//outXGIIDXREG(XGICR, 0x3D, 0x10);
+
+//outXGIIDXREG(XGICR, 0x4a, 0xf3);
+
+//outXGIIDXREG(XGICR, 0x57, 0x0);
+//outXGIIDXREG(XGICR, 0x7a, 0x2c);
+
+//outXGIIDXREG(XGICR, 0x82, 0xcc);
+//outXGIIDXREG(XGICR, 0x8c, 0x0);
+/*
+outXGIIDXREG(XGICR, 0x99, 0x1);
+outXGIIDXREG(XGICR, 0x41, 0x40);
+*/
+
+    for(i=0; i < 0x4f; i++)
+    {
+        inXGIIDXREG(XGISR, i, reg);
+        printk("\no 3c4 %x",i);
+        printk("\ni 3c5 => %x",reg);
+    }
+
+    for(i=0; i < 0xF0; i++)
+    {   
+        inXGIIDXREG(XGICR, i, reg);
+        printk("\no 3d4 %x",i);
+        printk("\ni 3d5 => %x",reg);
+    }
+/*
+    
+    outXGIIDXREG(XGIPART1,0x2F,1);    
+    for(i=1; i < 0x50; i++)
+    {
+        inXGIIDXREG(XGIPART1, i, reg);
+        printk("\no d004 %x",i);
+        printk("\ni d005 => %x",reg);
+    }
+    
+    for(i=0; i < 0x50; i++)
+    {
+        inXGIIDXREG(XGIPART2, i, reg);
+        printk("\no d010 %x",i);
+        printk("\ni d011 => %x",reg);
+    }
+    for(i=0; i < 0x50; i++)
+    {
+        inXGIIDXREG(XGIPART3, i, reg);
+        printk("\no d012 %x",i);
+        printk("\ni d013 => %x",reg);
+    }
+    for(i=0; i < 0x50; i++)
+    {
+        inXGIIDXREG(XGIPART4, i, reg);
+        printk("\no d014 %x",i);
+        printk("\ni d015 => %x",reg);
+    }
+*/
+}
+
+
+/* data for XGI components */
+extern struct video_info ;
+struct video_info  xgi_video_info;
+
+
+#if 1
+#define DEBUGPRN(x)
+#else
+#define DEBUGPRN(x) printk(KERN_INFO x "\n");
+#endif
+
+
+/* --------------- Hardware Access Routines -------------------------- */
+
+#ifdef LINUX_KERNEL
+int
+XGIfb_mode_rate_to_dclock(VB_DEVICE_INFO *XGI_Pr, PXGI_HW_DEVICE_INFO HwDeviceExtension,
+			  unsigned char modeno, unsigned char rateindex)
+{
+    USHORT ModeNo = modeno;
+    USHORT ModeIdIndex = 0, ClockIndex = 0;
+    USHORT RefreshRateTableIndex = 0;
+    
+    ULONG  temp = 0;
+    int    Clock;
+    XGI_Pr->ROMAddr  = HwDeviceExtension->pjVirtualRomBase;
+    InitTo330Pointer( HwDeviceExtension->jChipType, XGI_Pr ) ;
+
+    RefreshRateTableIndex = XGI_GetRatePtrCRT2( HwDeviceExtension, ModeNo , ModeIdIndex, XGI_Pr ) ;
+
+/*    
+    temp = XGI_SearchModeID( ModeNo , &ModeIdIndex,  XGI_Pr ) ;
+    if(!temp) {
+    	printk(KERN_ERR "Could not find mode %x\n", ModeNo);
+    	return 65000;
+    }
+    
+    RefreshRateTableIndex = XGI_Pr->EModeIDTable[ModeIdIndex].REFindex;
+    RefreshRateTableIndex += (rateindex - 1);
+
+*/
+    ClockIndex = XGI_Pr->RefIndex[RefreshRateTableIndex].Ext_CRTVCLK;
+    if(HwDeviceExtension->jChipType < XGI_315H) {
+       ClockIndex &= 0x3F;
+    }
+    Clock = XGI_Pr->VCLKData[ClockIndex].CLOCK * 1000 ;
+    
+    return(Clock);
+}
+
+int
+XGIfb_mode_rate_to_ddata(VB_DEVICE_INFO *XGI_Pr, PXGI_HW_DEVICE_INFO HwDeviceExtension,
+			 unsigned char modeno, unsigned char rateindex,
+			 ULONG *left_margin, ULONG *right_margin, 
+			 ULONG *upper_margin, ULONG *lower_margin,
+			 ULONG *hsync_len, ULONG *vsync_len,
+			 ULONG *sync, ULONG *vmode)
+{
+    USHORT ModeNo = modeno;
+    USHORT ModeIdIndex = 0, index = 0;
+    USHORT RefreshRateTableIndex = 0;
+    
+    unsigned short VRE, VBE, VRS, VBS, VDE, VT;
+    unsigned short HRE, HBE, HRS, HBS, HDE, HT;
+    unsigned char  sr_data, cr_data, cr_data2, cr_data3;
+    int            A, B, C, D, E, F, temp, j;
+    XGI_Pr->ROMAddr  = HwDeviceExtension->pjVirtualRomBase;
+    InitTo330Pointer( HwDeviceExtension->jChipType, XGI_Pr ) ;
+  RefreshRateTableIndex = XGI_GetRatePtrCRT2( HwDeviceExtension, ModeNo , ModeIdIndex, XGI_Pr ) ; 
+/*   
+    temp = XGI_SearchModeID( ModeNo, &ModeIdIndex, XGI_Pr);
+    if(!temp) return 0;
+    
+    RefreshRateTableIndex = XGI_Pr->EModeIDTable[ModeIdIndex].REFindex;
+    RefreshRateTableIndex += (rateindex - 1);
+*/
+    index = XGI_Pr->RefIndex[RefreshRateTableIndex].Ext_CRT1CRTC;
+
+    sr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[5];
+
+    cr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[0];
+
+    /* Horizontal total */
+    HT = (cr_data & 0xff) |
+         ((unsigned short) (sr_data & 0x03) << 8);
+    A = HT + 5;
+
+    /*cr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[1];
+	
+     Horizontal display enable end 
+    HDE = (cr_data & 0xff) |
+          ((unsigned short) (sr_data & 0x0C) << 6);*/
+    HDE = (XGI_Pr->RefIndex[RefreshRateTableIndex].XRes >> 3) -1;      
+    E = HDE + 1;
+
+    cr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[3];
+	
+    /* Horizontal retrace (=sync) start */
+    HRS = (cr_data & 0xff) |
+          ((unsigned short) (sr_data & 0xC0) << 2);
+    F = HRS - E - 3;
+
+    cr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[1];
+	
+    /* Horizontal blank start */
+    HBS = (cr_data & 0xff) |
+          ((unsigned short) (sr_data & 0x30) << 4);
+
+    sr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[6];
+	
+    cr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[2];
+
+    cr_data2 = XGI_Pr->XGINEWUB_CRT1Table[index].CR[4];
+	
+    /* Horizontal blank end */
+    HBE = (cr_data & 0x1f) |
+          ((unsigned short) (cr_data2 & 0x80) >> 2) |
+	  ((unsigned short) (sr_data & 0x03) << 6);
+
+    /* Horizontal retrace (=sync) end */
+    HRE = (cr_data2 & 0x1f) | ((sr_data & 0x04) << 3);
+
+    temp = HBE - ((E - 1) & 255);
+    B = (temp > 0) ? temp : (temp + 256);
+
+    temp = HRE - ((E + F + 3) & 63);
+    C = (temp > 0) ? temp : (temp + 64);
+
+    D = B - F - C;
+    
+    *left_margin = D * 8;
+    *right_margin = F * 8;
+    *hsync_len = C * 8;
+
+    sr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[14];
+
+    cr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[8];
+    
+    cr_data2 = XGI_Pr->XGINEWUB_CRT1Table[index].CR[9];
+    
+    /* Vertical total */
+    VT = (cr_data & 0xFF) |
+         ((unsigned short) (cr_data2 & 0x01) << 8) |
+	 ((unsigned short)(cr_data2 & 0x20) << 4) |
+	 ((unsigned short) (sr_data & 0x01) << 10);
+    A = VT + 2;
+
+    //cr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[10];
+	
+    /* Vertical display enable end */
+/*    VDE = (cr_data & 0xff) |
+          ((unsigned short) (cr_data2 & 0x02) << 7) |
+	  ((unsigned short) (cr_data2 & 0x40) << 3) |
+	  ((unsigned short) (sr_data & 0x02) << 9); */
+    VDE = XGI_Pr->RefIndex[RefreshRateTableIndex].YRes  -1;
+    E = VDE + 1;
+
+    cr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[10];
+
+    /* Vertical retrace (=sync) start */
+    VRS = (cr_data & 0xff) |
+          ((unsigned short) (cr_data2 & 0x04) << 6) |
+	  ((unsigned short) (cr_data2 & 0x80) << 2) |
+	  ((unsigned short) (sr_data & 0x08) << 7);
+    F = VRS + 1 - E;
+
+    cr_data =  XGI_Pr->XGINEWUB_CRT1Table[index].CR[12];
+
+    cr_data3 = (XGI_Pr->XGINEWUB_CRT1Table[index].CR[14] & 0x80) << 5;
+
+    /* Vertical blank start */
+    VBS = (cr_data & 0xff) |
+          ((unsigned short) (cr_data2 & 0x08) << 5) |
+	  ((unsigned short) (cr_data3 & 0x20) << 4) |
+	  ((unsigned short) (sr_data & 0x04) << 8);
+
+    cr_data =  XGI_Pr->XGINEWUB_CRT1Table[index].CR[13];
+
+    /* Vertical blank end */
+    VBE = (cr_data & 0xff) |
+          ((unsigned short) (sr_data & 0x10) << 4);
+    temp = VBE - ((E - 1) & 511);
+    B = (temp > 0) ? temp : (temp + 512);
+
+    cr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[11];
+
+    /* Vertical retrace (=sync) end */
+    VRE = (cr_data & 0x0f) | ((sr_data & 0x20) >> 1);
+    temp = VRE - ((E + F - 1) & 31);
+    C = (temp > 0) ? temp : (temp + 32);
+
+    D = B - F - C;
+      
+    *upper_margin = D;
+    *lower_margin = F;
+    *vsync_len = C;
+
+    if(XGI_Pr->RefIndex[RefreshRateTableIndex].Ext_InfoFlag & 0x8000)
+       *sync &= ~FB_SYNC_VERT_HIGH_ACT;
+    else
+       *sync |= FB_SYNC_VERT_HIGH_ACT;
+
+    if(XGI_Pr->RefIndex[RefreshRateTableIndex].Ext_InfoFlag & 0x4000)       
+       *sync &= ~FB_SYNC_HOR_HIGH_ACT;
+    else
+       *sync |= FB_SYNC_HOR_HIGH_ACT;
+		
+    *vmode = FB_VMODE_NONINTERLACED;       
+    if(XGI_Pr->RefIndex[RefreshRateTableIndex].Ext_InfoFlag & 0x0080)
+       *vmode = FB_VMODE_INTERLACED;
+    else {
+      j = 0;
+      while(XGI_Pr->EModeIDTable[j].Ext_ModeID != 0xff) {
+          if(XGI_Pr->EModeIDTable[j].Ext_ModeID ==
+	                  XGI_Pr->RefIndex[RefreshRateTableIndex].ModeID) {
+              if(XGI_Pr->EModeIDTable[j].Ext_ModeFlag & DoubleScanMode) {
+	      	  *vmode = FB_VMODE_DOUBLE;
+              }
+	      break;
+          }
+	  j++;
+      }
+    }       
+       
+#if 0  /* That's bullshit, only the resolution needs to be shifted */    
+    if((*vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {
+       *upper_margin <<= 1;
+       *lower_margin <<= 1;
+       *vsync_len <<= 1;
+    } else if((*vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE) {
+       *upper_margin >>= 1;
+       *lower_margin >>= 1;
+       *vsync_len >>= 1;
+    }  
+#endif
+          
+    return 1;       
+}			  
+
+#endif
+
+
+
+void XGIRegInit(VB_DEVICE_INFO *XGI_Pr, ULONG BaseAddr)
+{
+   XGI_Pr->P3c4 = BaseAddr + 0x14;
+   XGI_Pr->P3d4 = BaseAddr + 0x24;
+   XGI_Pr->P3c0 = BaseAddr + 0x10;
+   XGI_Pr->P3ce = BaseAddr + 0x1e;
+   XGI_Pr->P3c2 = BaseAddr + 0x12;
+   XGI_Pr->P3ca = BaseAddr + 0x1a;
+   XGI_Pr->P3c6 = BaseAddr + 0x16;
+   XGI_Pr->P3c7 = BaseAddr + 0x17;
+   XGI_Pr->P3c8 = BaseAddr + 0x18;
+   XGI_Pr->P3c9 = BaseAddr + 0x19;
+   XGI_Pr->P3da = BaseAddr + 0x2A;
+   XGI_Pr->Part1Port = BaseAddr + XGI_CRT2_PORT_04;   /* Digital video interface registers (LCD) */
+   XGI_Pr->Part2Port = BaseAddr + XGI_CRT2_PORT_10;   /* 301 TV Encoder registers */
+   XGI_Pr->Part3Port = BaseAddr + XGI_CRT2_PORT_12;   /* 301 Macrovision registers */
+   XGI_Pr->Part4Port = BaseAddr + XGI_CRT2_PORT_14;   /* 301 VGA2 (and LCD) registers */
+   XGI_Pr->Part5Port = BaseAddr + XGI_CRT2_PORT_14+2; /* 301 palette address port registers */
+  
+}
+
+
+void XGIfb_set_reg4(u16 port, unsigned long data)
+{
+	outl((u32) (data & 0xffffffff), port);
+}
+
+u32 XGIfb_get_reg3(u16 port)
+{
+	u32 data;
+
+	data = inl(port);
+	return (data);
+}
+
+/* ------------ Interface for init & mode switching code ------------- */
+
+BOOLEAN
+XGIfb_query_VGA_config_space(PXGI_HW_DEVICE_INFO pXGIhw_ext,
+	unsigned long offset, unsigned long set, unsigned long *value)
+{
+	static struct pci_dev *pdev = NULL;
+	static unsigned char init = 0, valid_pdev = 0;
+
+	if (!set)
+		DPRINTK("XGIfb: Get VGA offset 0x%lx\n", offset);
+	else
+		DPRINTK("XGIfb: Set offset 0x%lx to 0x%lx\n", offset, *value);
+
+	if (!init) {
+		init = TRUE;
+		pdev = pci_find_device(PCI_VENDOR_ID_XG, xgi_video_info.chip_id, pdev);
+		if (pdev)
+			valid_pdev = TRUE;
+	}
+
+	if (!valid_pdev) {
+		printk(KERN_DEBUG "XGIfb: Can't find XGI %d VGA device.\n",
+				xgi_video_info.chip_id);
+		return FALSE;
+	}
+
+	if (set == 0)
+		pci_read_config_dword(pdev, offset, (u32 *)value);
+	else
+		pci_write_config_dword(pdev, offset, (u32)(*value));
+
+	return TRUE;
+}
+
+/*BOOLEAN XGIfb_query_north_bridge_space(PXGI_HW_DEVICE_INFO pXGIhw_ext,
+	unsigned long offset, unsigned long set, unsigned long *value)
+{
+	static struct pci_dev *pdev = NULL;
+	static unsigned char init = 0, valid_pdev = 0;
+	u16 nbridge_id = 0;
+
+	if (!init) {
+		init = TRUE;
+		switch (xgi_video_info.chip) {
+		case XGI_540:
+			nbridge_id = PCI_DEVICE_ID_XG_540;
+			break;
+		case XGI_630:
+			nbridge_id = PCI_DEVICE_ID_XG_630;
+			break;
+		case XGI_730:
+			nbridge_id = PCI_DEVICE_ID_XG_730;
+			break;
+		case XGI_550:
+			nbridge_id = PCI_DEVICE_ID_XG_550;
+			break;
+		case XGI_650:
+			nbridge_id = PCI_DEVICE_ID_XG_650;
+			break;
+		case XGI_740:			
+			nbridge_id = PCI_DEVICE_ID_XG_740;
+			break;
+		default:
+			nbridge_id = 0;
+			break;
+		}
+
+		pdev = pci_find_device(PCI_VENDOR_ID_SI, nbridge_id, pdev);
+		if (pdev)
+			valid_pdev = TRUE;
+	}
+
+	if (!valid_pdev) {
+		printk(KERN_DEBUG "XGIfb: Can't find XGI %d North Bridge device.\n",
+				nbridge_id);
+		return FALSE;
+	}
+
+	if (set == 0)
+		pci_read_config_dword(pdev, offset, (u32 *)value);
+	else
+		pci_write_config_dword(pdev, offset, (u32)(*value));
+
+	return TRUE;
+}
+*/
+/* ------------------ Internal helper routines ----------------- */
+
+static void XGIfb_search_mode(const char *name)
+{
+	int i = 0, j = 0;
+
+	if(name == NULL) {
+	   printk(KERN_ERR "XGIfb: Internal error, using default mode.\n");
+	   xgifb_mode_idx = DEFAULT_MODE;
+	   return;
+	}
+		
+
+        if (!strcmp(name, XGIbios_mode[MODE_INDEX_NONE].name)) {
+	   printk(KERN_ERR "XGIfb: Mode 'none' not supported anymore. Using default.\n");
+	   xgifb_mode_idx = DEFAULT_MODE;
+	   return;
+	}
+
+	while(XGIbios_mode[i].mode_no != 0) {
+		if (!strcmp(name, XGIbios_mode[i].name)) {
+			xgifb_mode_idx = i;
+			j = 1;
+			break;
+		}
+		i++;
+	}
+	if(!j) printk(KERN_INFO "XGIfb: Invalid mode '%s'\n", name);
+}
+
+static void XGIfb_search_vesamode(unsigned int vesamode)
+{
+	int i = 0, j = 0;
+
+	if(vesamode == 0) {
+
+		printk(KERN_ERR "XGIfb: Mode 'none' not supported anymore. Using default.\n");
+		xgifb_mode_idx = DEFAULT_MODE;
+
+		return;
+	}
+
+	vesamode &= 0x1dff;  /* Clean VESA mode number from other flags */
+
+	while(XGIbios_mode[i].mode_no != 0) {
+		if( (XGIbios_mode[i].vesa_mode_no_1 == vesamode) ||
+		    (XGIbios_mode[i].vesa_mode_no_2 == vesamode) ) {
+			xgifb_mode_idx = i;
+			j = 1;
+			break;
+		}
+		i++;
+	}
+	if(!j) printk(KERN_INFO "XGIfb: Invalid VESA mode 0x%x'\n", vesamode);
+}
+
+static int XGIfb_validate_mode(int myindex)
+{
+   u16 xres, yres;
+
+
+
+
+    return myindex;  //yilin allow all mode for now.
+    if(!(XGIbios_mode[myindex].chipset & MD_XGI315)) {
+        return(-1);
+    }
+   
+
+   switch (xgi_video_info.disp_state & DISPTYPE_DISP2) {
+     case DISPTYPE_LCD:
+	switch (XGIhw_ext.ulCRT2LCDType) {
+	case LCD_640x480:
+		xres =  640; yres =  480;  break;
+	case LCD_800x600:
+		xres =  800; yres =  600;  break;
+        case LCD_1024x600:
+		xres = 1024; yres =  600;  break;		
+	case LCD_1024x768:
+	 	xres = 1024; yres =  768;  break;
+	case LCD_1152x768:
+		xres = 1152; yres =  768;  break;		
+	case LCD_1280x960:
+	        xres = 1280; yres =  960;  break;		
+	case LCD_1280x768:
+		xres = 1280; yres =  768;  break;
+	case LCD_1280x1024:
+		xres = 1280; yres = 1024;  break;
+	case LCD_1400x1050:
+		xres = 1400; yres = 1050;  break;		
+	case LCD_1600x1200:
+		xres = 1600; yres = 1200;  break;
+//	case LCD_320x480:				// TW: FSTN 
+//		xres =  320; yres =  480;  break;
+	default:
+	        xres =    0; yres =    0;  break;
+	}
+	if(XGIbios_mode[myindex].xres > xres) {
+	        return(-1);
+	}
+        if(XGIbios_mode[myindex].yres > yres) {
+	        return(-1);
+	}
+	if((XGIhw_ext.ulExternalChip == 0x01) ||   // LVDS 
+           (XGIhw_ext.ulExternalChip == 0x05))    // LVDS+Chrontel 
+	{	
+	   switch (XGIbios_mode[myindex].xres) {
+	   	case 512:
+	       		if(XGIbios_mode[myindex].yres != 512) return -1;
+			if(XGIhw_ext.ulCRT2LCDType == LCD_1024x600) return -1;
+	       		break;
+	   	case 640:
+		       	if((XGIbios_mode[myindex].yres != 400) &&
+	           	   (XGIbios_mode[myindex].yres != 480))
+		          	return -1;
+	       		break;
+	   	case 800:
+		       	if(XGIbios_mode[myindex].yres != 600) return -1;
+	       		break;
+	   	case 1024:
+		       	if((XGIbios_mode[myindex].yres != 600) &&
+	           	   (XGIbios_mode[myindex].yres != 768))
+		          	return -1;
+			if((XGIbios_mode[myindex].yres == 600) &&
+			   (XGIhw_ext.ulCRT2LCDType != LCD_1024x600))
+			   	return -1;
+			break;
+		case 1152:
+			if((XGIbios_mode[myindex].yres) != 768) return -1;
+			if(XGIhw_ext.ulCRT2LCDType != LCD_1152x768) return -1;
+			break;
+	   	case 1280:
+		   	if((XGIbios_mode[myindex].yres != 768) &&
+	           	   (XGIbios_mode[myindex].yres != 1024))
+		          	return -1;
+			if((XGIbios_mode[myindex].yres == 768) &&
+			   (XGIhw_ext.ulCRT2LCDType != LCD_1280x768))
+			   	return -1;				
+			break;
+	   	case 1400:
+		   	if(XGIbios_mode[myindex].yres != 1050) return -1;
+			break;
+	   	case 1600:
+		   	if(XGIbios_mode[myindex].yres != 1200) return -1;
+			break;
+	   	default:
+		        return -1;		
+	   }
+	} else {
+	   switch (XGIbios_mode[myindex].xres) {
+	   	case 512:
+	       		if(XGIbios_mode[myindex].yres != 512) return -1;
+	       		break;
+	   	case 640:
+		       	if((XGIbios_mode[myindex].yres != 400) &&
+	           	   (XGIbios_mode[myindex].yres != 480))
+		          	return -1;
+	       		break;
+	   	case 800:
+		       	if(XGIbios_mode[myindex].yres != 600) return -1;
+	       		break;
+	   	case 1024:
+		       	if(XGIbios_mode[myindex].yres != 768) return -1;
+			break;
+	   	case 1280:
+		   	if((XGIbios_mode[myindex].yres != 960) &&
+	           	   (XGIbios_mode[myindex].yres != 1024))
+		          	return -1;
+			if(XGIbios_mode[myindex].yres == 960) {
+			    if(XGIhw_ext.ulCRT2LCDType == LCD_1400x1050) 
+			   	return -1;
+			}
+			break;
+	   	case 1400:
+		   	if(XGIbios_mode[myindex].yres != 1050) return -1;
+			break;
+	   	case 1600:
+		   	if(XGIbios_mode[myindex].yres != 1200) return -1;
+			break;
+	   	default:
+		        return -1;		
+	   }
+	}
+	break;
+     case DISPTYPE_TV:
+	switch (XGIbios_mode[myindex].xres) {
+	case 512:
+	case 640:
+	case 800:
+		break;
+	case 720:
+		if (xgi_video_info.TV_type == TVMODE_NTSC) {
+			if (XGIbios_mode[myindex].yres != 480) {
+				return(-1);
+			}
+		} else if (xgi_video_info.TV_type == TVMODE_PAL) {
+			if (XGIbios_mode[myindex].yres != 576) {
+				return(-1);
+			}
+		}
+		// TW: LVDS/CHRONTEL does not support 720 
+		if (xgi_video_info.hasVB == HASVB_LVDS_CHRONTEL ||
+					xgi_video_info.hasVB == HASVB_CHRONTEL) {
+				return(-1);
+		}
+		break;
+	case 1024:
+		if (xgi_video_info.TV_type == TVMODE_NTSC) {
+			if(XGIbios_mode[myindex].bpp == 32) {
+			       return(-1);
+			}
+		}
+		// TW: LVDS/CHRONTEL only supports < 800 (1024 on 650/Ch7019)
+		if (xgi_video_info.hasVB == HASVB_LVDS_CHRONTEL ||
+					xgi_video_info.hasVB == HASVB_CHRONTEL) {
+		    if(xgi_video_info.chip < XGI_315H) {
+				return(-1);
+		    }
+		}
+		break;
+	default:
+		return(-1);
+	}
+	break;
+     case DISPTYPE_CRT2:	
+        if(XGIbios_mode[myindex].xres > 1280) return -1;
+	break;	
+     }
+     return(myindex);
+
+}
+
+static void XGIfb_search_crt2type(const char *name)
+{
+	int i = 0;
+
+	if(name == NULL)
+		return;
+
+	while(XGI_crt2type[i].type_no != -1) {
+		if (!strcmp(name, XGI_crt2type[i].name)) {
+			XGIfb_crt2type = XGI_crt2type[i].type_no;
+			XGIfb_tvplug = XGI_crt2type[i].tvplug_no;
+			break;
+		}
+		i++;
+	}
+	if(XGIfb_crt2type < 0)
+		printk(KERN_INFO "XGIfb: Invalid CRT2 type: %s\n", name);
+}
+
+static void XGIfb_search_queuemode(const char *name)
+{
+	int i = 0;
+
+	if(name == NULL)
+		return;
+
+	while (XGI_queuemode[i].type_no != -1) {
+		if (!strcmp(name, XGI_queuemode[i].name)) {
+			XGIfb_queuemode = XGI_queuemode[i].type_no;
+			break;
+		}
+		i++;
+	}
+	if (XGIfb_queuemode < 0)
+		printk(KERN_INFO "XGIfb: Invalid queuemode type: %s\n", name);
+}
+
+static u8 XGIfb_search_refresh_rate(unsigned int rate)
+{
+	u16 xres, yres;
+	int i = 0;
+
+	xres = XGIbios_mode[xgifb_mode_idx].xres;
+	yres = XGIbios_mode[xgifb_mode_idx].yres;
+
+	XGIfb_rate_idx = 0;
+	while ((XGIfb_vrate[i].idx != 0) && (XGIfb_vrate[i].xres <= xres)) {
+		if ((XGIfb_vrate[i].xres == xres) && (XGIfb_vrate[i].yres == yres)) {
+			if (XGIfb_vrate[i].refresh == rate) {
+				XGIfb_rate_idx = XGIfb_vrate[i].idx;
+				break;
+			} else if (XGIfb_vrate[i].refresh > rate) {
+				if ((XGIfb_vrate[i].refresh - rate) <= 3) {
+					DPRINTK("XGIfb: Adjusting rate from %d up to %d\n",
+						rate, XGIfb_vrate[i].refresh);
+					XGIfb_rate_idx = XGIfb_vrate[i].idx;
+					xgi_video_info.refresh_rate = XGIfb_vrate[i].refresh;
+				} else if (((rate - XGIfb_vrate[i-1].refresh) <= 2)
+						&& (XGIfb_vrate[i].idx != 1)) {
+					DPRINTK("XGIfb: Adjusting rate from %d down to %d\n",
+						rate, XGIfb_vrate[i-1].refresh);
+					XGIfb_rate_idx = XGIfb_vrate[i-1].idx;
+					xgi_video_info.refresh_rate = XGIfb_vrate[i-1].refresh;
+				} 
+				break;
+			} else if((rate - XGIfb_vrate[i].refresh) <= 2) {
+				DPRINTK("XGIfb: Adjusting rate from %d down to %d\n",
+						rate, XGIfb_vrate[i].refresh);
+	           		XGIfb_rate_idx = XGIfb_vrate[i].idx;
+		   		break;
+	       		}
+		}
+		i++;
+	}
+	if (XGIfb_rate_idx > 0) {
+		return XGIfb_rate_idx;
+	} else {
+		printk(KERN_INFO
+			"XGIfb: Unsupported rate %d for %dx%d\n", rate, xres, yres);
+		return 0;
+	}
+}
+
+static void XGIfb_search_tvstd(const char *name)
+{
+	int i = 0;
+
+	if(name == NULL)
+		return;
+
+	while (XGI_tvtype[i].type_no != -1) {
+		if (!strcmp(name, XGI_tvtype[i].name)) {
+			XGIfb_tvmode = XGI_tvtype[i].type_no;
+			break;
+		}
+		i++;
+	}
+}
+
+static BOOLEAN XGIfb_bridgeisslave(void)
+{
+   unsigned char usScratchP1_00;
+
+   if(xgi_video_info.hasVB == HASVB_NONE) return FALSE;
+
+   inXGIIDXREG(XGIPART1,0x00,usScratchP1_00);
+   if( (usScratchP1_00 & 0x50) == 0x10)  {
+	   return TRUE;
+   } else {
+           return FALSE;
+   }
+}
+
+static BOOLEAN XGIfbcheckvretracecrt1(void)
+{
+   unsigned char temp;
+
+   inXGIIDXREG(XGICR,0x17,temp);
+   if(!(temp & 0x80)) return FALSE;
+   
+
+   inXGIIDXREG(XGISR,0x1f,temp);
+   if(temp & 0xc0) return FALSE;
+   
+
+   if(inXGIREG(XGIINPSTAT) & 0x08) return TRUE;
+   else 			   return FALSE;
+}
+
+static BOOLEAN XGIfbcheckvretracecrt2(void)
+{
+   unsigned char temp;
+   if(xgi_video_info.hasVB == HASVB_NONE) return FALSE;
+   inXGIIDXREG(XGIPART1, 0x30, temp);
+   if(temp & 0x02) return FALSE;
+   else 	   return TRUE;
+}
+
+static BOOLEAN XGIfb_CheckVBRetrace(void) 
+{
+   if(xgi_video_info.disp_state & DISPTYPE_DISP2) {
+      if(XGIfb_bridgeisslave()) {
+         return(XGIfbcheckvretracecrt1());
+      } else {
+         return(XGIfbcheckvretracecrt2());
+      }
+   } 
+   return(XGIfbcheckvretracecrt1());
+}
+
+/* ----------- FBDev related routines for all series ----------- */
+
+
+static void XGIfb_bpp_to_var(struct fb_var_screeninfo *var)
+{
+	switch(var->bits_per_pixel) {
+	   case 8:
+	   	var->red.offset = var->green.offset = var->blue.offset = 0;
+		var->red.length = var->green.length = var->blue.length = 6;
+		xgi_video_info.video_cmap_len = 256;
+		break;
+	   case 16:
+		var->red.offset = 11;
+		var->red.length = 5;
+		var->green.offset = 5;
+		var->green.length = 6;
+		var->blue.offset = 0;
+		var->blue.length = 5;
+		var->transp.offset = 0;
+		var->transp.length = 0;
+		xgi_video_info.video_cmap_len = 16;
+		break;
+	   case 32:
+		var->red.offset = 16;
+		var->red.length = 8;
+		var->green.offset = 8;
+		var->green.length = 8;
+		var->blue.offset = 0;
+		var->blue.length = 8;
+		var->transp.offset = 24;
+		var->transp.length = 8;
+		xgi_video_info.video_cmap_len = 16;
+		break;
+	}
+}
+
+
+
+static int XGIfb_do_set_var(struct fb_var_screeninfo *var, int isactive,
+		      struct fb_info *info)
+{
+
+	unsigned int htotal = var->left_margin + var->xres + 
+		var->right_margin + var->hsync_len;
+	unsigned int vtotal = var->upper_margin + var->yres + 
+		var->lower_margin + var->vsync_len;
+        u8 sr_data, cr_data;
+	unsigned int drate = 0, hrate = 0;
+	int found_mode = 0;
+	int old_mode;
+//	unsigned char reg,reg1;
+	
+	DEBUGPRN("Inside do_set_var");
+//        printk(KERN_DEBUG "XGIfb:var->yres=%d, var->upper_margin=%d, var->lower_margin=%d, var->vsync_len=%d\n", var->yres,var->upper_margin,var->lower_margin,var->vsync_len);
+
+        info->var.xres_virtual = var->xres_virtual;
+        info->var.yres_virtual = var->yres_virtual;
+        info->var.bits_per_pixel = var->bits_per_pixel;
+
+	if ((var->vmode & FB_VMODE_MASK) == FB_VMODE_NONINTERLACED) 
+		vtotal <<= 1;
+	else if ((var->vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE)
+		vtotal <<= 2;
+	else if ((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED)
+	{	
+//		vtotal <<= 1;
+//		var->yres <<= 1;
+	}
+
+	if(!htotal || !vtotal) {
+		DPRINTK("XGIfb: Invalid 'var' information\n");
+		return -EINVAL;
+	}
+        printk(KERN_DEBUG "XGIfb: var->pixclock=%d, htotal=%d, vtotal=%d\n",
+                var->pixclock,htotal,vtotal);
+
+
+
+	if(var->pixclock && htotal && vtotal) {
+		drate = 1000000000 / var->pixclock;
+		hrate = (drate * 1000) / htotal;
+		xgi_video_info.refresh_rate = (unsigned int) (hrate * 2 / vtotal);
+/*
+printk("yilin: XGIfb_do_set_var: pixclock = %d ,htotal=%d, vtotal=%d \n drate=%d, hrate=%d, refresh_rate=%d\n", var->pixclock, htotal, vtotal, drate, hrate, xgi_video_info.refresh_rate);
+*/
+	} else {
+		xgi_video_info.refresh_rate = 60;
+	}
+
+xgi_video_info.refresh_rate = 60;
+
+	printk(KERN_DEBUG "XGIfb: Change mode to %dx%dx%d-%dHz\n",
+		var->xres,var->yres,var->bits_per_pixel,xgi_video_info.refresh_rate);
+
+	old_mode = xgifb_mode_idx;
+	xgifb_mode_idx = 0;
+
+	while( (XGIbios_mode[xgifb_mode_idx].mode_no != 0) &&
+	       (XGIbios_mode[xgifb_mode_idx].xres <= var->xres) ) {
+		if( (XGIbios_mode[xgifb_mode_idx].xres == var->xres) &&
+		    (XGIbios_mode[xgifb_mode_idx].yres == var->yres) &&
+		    (XGIbios_mode[xgifb_mode_idx].bpp == var->bits_per_pixel)) {
+			XGIfb_mode_no = XGIbios_mode[xgifb_mode_idx].mode_no;
+			found_mode = 1;
+			break;
+		}
+		xgifb_mode_idx++;
+	}
+
+	if(found_mode)
+		xgifb_mode_idx = XGIfb_validate_mode(xgifb_mode_idx);
+	else
+		xgifb_mode_idx = -1;
+
+       	if(xgifb_mode_idx < 0) {
+		printk(KERN_ERR "XGIfb: Mode %dx%dx%d not supported\n", var->xres,
+		       var->yres, var->bits_per_pixel);
+		xgifb_mode_idx = old_mode;
+		return -EINVAL;
+	}
+
+	if(XGIfb_search_refresh_rate(xgi_video_info.refresh_rate) == 0) {
+		XGIfb_rate_idx = XGIbios_mode[xgifb_mode_idx].rate_idx;
+		xgi_video_info.refresh_rate = 60;
+	}
+
+	if(isactive) {
+
+		
+		XGIfb_pre_setmode();
+		if(XGISetModeNew( &XGIhw_ext, XGIfb_mode_no) == 0) {
+			printk(KERN_ERR "XGIfb: Setting mode[0x%x] failed\n", XGIfb_mode_no);
+			return -EINVAL;
+		}
+	info->fix.line_length = ((info->var.xres_virtual * info->var.bits_per_pixel)>>6);
+ 
+	outXGIIDXREG(XGISR,IND_XGI_PASSWORD,XGI_PASSWORD);
+
+		outXGIIDXREG(XGICR,0x13,(info->fix.line_length & 0x00ff));
+		outXGIIDXREG(XGISR,0x0E,(info->fix.line_length & 0xff00)>>8);
+
+		XGIfb_post_setmode();
+
+		DPRINTK("XGIfb: Set new mode: %dx%dx%d-%d \n",
+			XGIbios_mode[xgifb_mode_idx].xres,
+			XGIbios_mode[xgifb_mode_idx].yres,
+			XGIbios_mode[xgifb_mode_idx].bpp,
+			xgi_video_info.refresh_rate);
+
+		xgi_video_info.video_bpp = XGIbios_mode[xgifb_mode_idx].bpp;
+		xgi_video_info.video_vwidth = info->var.xres_virtual;
+		xgi_video_info.video_width = XGIbios_mode[xgifb_mode_idx].xres;
+		xgi_video_info.video_vheight = info->var.yres_virtual;
+		xgi_video_info.video_height = XGIbios_mode[xgifb_mode_idx].yres;
+		xgi_video_info.org_x = xgi_video_info.org_y = 0;
+		xgi_video_info.video_linelength = info->var.xres_virtual * (xgi_video_info.video_bpp >> 3);
+		xgi_video_info.accel = 0;
+		if(XGIfb_accel) {
+		   xgi_video_info.accel = (var->accel_flags & FB_ACCELF_TEXT) ? -1 : 0;
+		}
+		switch(xgi_video_info.video_bpp) 
+		{
+        	case 8:
+           		xgi_video_info.DstColor = 0x0000;
+	    		xgi_video_info.XGI310_AccelDepth = 0x00000000;
+ 			    xgi_video_info.video_cmap_len = 256;
+#if defined(__powerpc__)
+                inXGIIDXREG (XGICR, 0x4D, cr_data);
+                outXGIIDXREG(XGICR, 0x4D, (cr_data & 0xE0));
+#endif
+                break;
+        	case 16:
+            	xgi_video_info.DstColor = 0x8000;
+            	xgi_video_info.XGI310_AccelDepth = 0x00010000;
+#if defined(__powerpc__)
+                inXGIIDXREG (XGICR, 0x4D, cr_data);
+                outXGIIDXREG(XGICR, 0x4D, ((cr_data & 0xE0) | 0x0B));
+#endif
+			    xgi_video_info.video_cmap_len = 16;
+            	break;
+        	case 32:
+            	xgi_video_info.DstColor = 0xC000;
+	    		xgi_video_info.XGI310_AccelDepth = 0x00020000;
+			    xgi_video_info.video_cmap_len = 16;
+#if defined(__powerpc__)
+                inXGIIDXREG (XGICR, 0x4D, cr_data);
+                outXGIIDXREG(XGICR, 0x4D, ((cr_data & 0xE0) | 0x15));
+#endif
+            	break;
+		    default:
+			    xgi_video_info.video_cmap_len = 16;
+		        printk(KERN_ERR "XGIfb: Unsupported depth %d", xgi_video_info.video_bpp);
+			    xgi_video_info.accel = 0;
+			    break;
+    	}
+	}
+	XGIfb_bpp_to_var(var); /*update ARGB info*/
+	DEBUGPRN("End of do_set_var");
+
+//	dumpVGAReg();
+	return 0;
+}
+
+#ifdef XGIFB_PAN
+static int XGIfb_pan_var(struct fb_var_screeninfo *var)
+{
+	unsigned int base;
+
+//	printk("Inside pan_var");
+	
+	if (var->xoffset > (var->xres_virtual - var->xres)) {
+//	        printk( "Pan: xo: %d xv %d xr %d\n",
+//			var->xoffset, var->xres_virtual, var->xres);
+		return -EINVAL;
+	}
+	if(var->yoffset > (var->yres_virtual - var->yres)) {
+//		printk( "Pan: yo: %d yv %d yr %d\n",
+//			var->yoffset, var->yres_virtual, var->yres);
+		return -EINVAL;
+	}
+        base = var->yoffset * var->xres_virtual + var->xoffset;
+
+        /* calculate base bpp dep. */
+        switch(var->bits_per_pixel) {
+        case 16:
+        	base >>= 1;
+        	break;
+	case 32:
+            	break;
+	case 8:
+        default:
+        	base >>= 2;
+            	break;
+        }
+	
+	outXGIIDXREG(XGISR, IND_XGI_PASSWORD, XGI_PASSWORD);
+
+        outXGIIDXREG(XGICR, 0x0D, base & 0xFF);
+	outXGIIDXREG(XGICR, 0x0C, (base >> 8) & 0xFF);
+	outXGIIDXREG(XGISR, 0x0D, (base >> 16) & 0xFF);
+        outXGIIDXREG(XGISR, 0x37, (base >> 24) & 0x03);
+	setXGIIDXREG(XGISR, 0x37, 0xDF, (base >> 21) & 0x04);
+
+        if(xgi_video_info.disp_state & DISPTYPE_DISP2) {
+		orXGIIDXREG(XGIPART1, XGIfb_CRT2_write_enable, 0x01);
+        	outXGIIDXREG(XGIPART1, 0x06, (base & 0xFF));
+        	outXGIIDXREG(XGIPART1, 0x05, ((base >> 8) & 0xFF));
+        	outXGIIDXREG(XGIPART1, 0x04, ((base >> 16) & 0xFF));
+		setXGIIDXREG(XGIPART1, 0x02, 0x7F, ((base >> 24) & 0x01) << 7);
+        }
+//	printk("End of pan_var");
+	return 0;
+}
+#endif
+
+
+void XGI_dispinfo(struct ap_data *rec)
+{
+	rec->minfo.bpp    = xgi_video_info.video_bpp;
+	rec->minfo.xres   = xgi_video_info.video_width;
+	rec->minfo.yres   = xgi_video_info.video_height;
+	rec->minfo.v_xres = xgi_video_info.video_vwidth;
+	rec->minfo.v_yres = xgi_video_info.video_vheight;
+	rec->minfo.org_x  = xgi_video_info.org_x;
+	rec->minfo.org_y  = xgi_video_info.org_y;
+	rec->minfo.vrate  = xgi_video_info.refresh_rate;
+	rec->iobase       = xgi_video_info.vga_base - 0x30;
+	rec->mem_size     = xgi_video_info.video_size;
+	rec->disp_state   = xgi_video_info.disp_state; 
+	rec->version      = (VER_MAJOR << 24) | (VER_MINOR << 16) | VER_LEVEL; 
+	rec->hasVB        = xgi_video_info.hasVB; 
+	rec->TV_type      = xgi_video_info.TV_type; 
+	rec->TV_plug      = xgi_video_info.TV_plug; 
+	rec->chip         = xgi_video_info.chip;
+}
+
+
+
+
+static int XGIfb_open(struct fb_info *info, int user)
+{
+    return 0;
+}
+
+static int XGIfb_release(struct fb_info *info, int user)
+{
+    return 0;
+}
+
+static int XGIfb_get_cmap_len(const struct fb_var_screeninfo *var)
+{
+	int rc = 16;		
+
+	switch(var->bits_per_pixel) {
+	case 8:
+		rc = 256;	
+		break;
+	case 16:
+		rc = 16;	
+		break;		
+	case 32:
+		rc = 16;
+		break;	
+	}
+	return rc;
+}
+
+static int XGIfb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue,
+                           unsigned transp, struct fb_info *info)
+{
+	if (regno >= XGIfb_get_cmap_len(&info->var))
+		return 1;
+
+	switch (info->var.bits_per_pixel) {
+	case 8:
+	        outXGIREG(XGIDACA, regno);
+		outXGIREG(XGIDACD, (red >> 10));
+		outXGIREG(XGIDACD, (green >> 10));
+		outXGIREG(XGIDACD, (blue >> 10));
+		if (xgi_video_info.disp_state & DISPTYPE_DISP2) {
+		        outXGIREG(XGIDAC2A, regno);
+			outXGIREG(XGIDAC2D, (red >> 8));
+			outXGIREG(XGIDAC2D, (green >> 8));
+			outXGIREG(XGIDAC2D, (blue >> 8));
+		}
+		break;
+	case 16:
+		((u32 *)(info->pseudo_palette))[regno] =
+		    ((red & 0xf800)) | ((green & 0xfc00) >> 5) | ((blue & 0xf800) >> 11);
+		break;
+	case 32:
+		red >>= 8;
+		green >>= 8;
+		blue >>= 8;
+		((u32 *) (info->pseudo_palette))[regno] = 
+			(red << 16) | (green << 8) | (blue);
+		break;
+	}
+	return 0;
+}
+
+static int XGIfb_set_par(struct fb_info *info)
+{
+	int err;
+
+//	printk("XGIfb: inside set_par\n");
+        if((err = XGIfb_do_set_var(&info->var, 1, info)))
+		return err;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+	XGIfb_get_fix(&info->fix, info->currcon, info);
+#else
+	XGIfb_get_fix(&info->fix, -1, info);
+#endif
+//	printk("XGIfb:end of set_par\n");
+	return 0;
+}
+
+static int XGIfb_check_var(struct fb_var_screeninfo *var,
+                           struct fb_info *info)
+{
+	unsigned int htotal =
+		var->left_margin + var->xres + var->right_margin +
+		var->hsync_len;
+	unsigned int vtotal = 0;
+	unsigned int drate = 0, hrate = 0;
+	int found_mode = 0;
+	int refresh_rate, search_idx;
+
+	DEBUGPRN("Inside check_var");
+
+	if((var->vmode & FB_VMODE_MASK) == FB_VMODE_NONINTERLACED) {
+		vtotal = var->upper_margin + var->yres + var->lower_margin +
+		         var->vsync_len;   
+		vtotal <<= 1;
+	} else if((var->vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE) {
+		vtotal = var->upper_margin + var->yres + var->lower_margin +
+		         var->vsync_len;   
+		vtotal <<= 2;
+	} else if((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {
+		vtotal = var->upper_margin + (var->yres/2) + var->lower_margin +
+		         var->vsync_len;   
+	} else 	vtotal = var->upper_margin + var->yres + var->lower_margin +
+		         var->vsync_len;
+
+	if(!(htotal) || !(vtotal)) {
+		XGIFAIL("XGIfb: no valid timing data");
+	}
+
+
+        if(var->pixclock && htotal && vtotal) {
+                drate = 1000000000 / var->pixclock;
+                hrate = (drate * 1000) / htotal;
+                xgi_video_info.refresh_rate = (unsigned int) (hrate * 2 / vtotal);
+printk("yilin: XGIfb_check_var: pixclock = %d ,htotal=%d, vtotal=%d \n drate=%d, hrate=%d, refresh_rate=%d", var->pixclock, htotal, vtotal, drate, hrate, xgi_video_info.refresh_rate);
+        } else {
+                xgi_video_info.refresh_rate = 60;
+        }
+
+/*	
+	if((var->pixclock) && (htotal)) {
+	   drate = 1E12 / var->pixclock;
+	   hrate = drate / htotal;
+	   refresh_rate = (unsigned int) (hrate / vtotal * 2 + 0.5);
+	} else refresh_rate = 60;
+/*
+	/* TW: Calculation wrong for 1024x600 - force it to 60Hz */
+	if((var->xres == 1024) && (var->yres == 600)) refresh_rate = 60;
+
+	search_idx = 0;
+	while((XGIbios_mode[search_idx].mode_no != 0) && 
+	       (XGIbios_mode[search_idx].xres <= var->xres) ) {
+	    if((XGIbios_mode[search_idx].xres == var->xres) &&
+	       (XGIbios_mode[search_idx].yres == var->yres) &&
+		    (XGIbios_mode[search_idx].bpp == var->bits_per_pixel)) {
+		        if(XGIfb_validate_mode(search_idx) > 0) {
+		    found_mode = 1;
+		    break;
+	        }
+	    }
+		search_idx++;
+	}
+
+	if(!found_mode) {
+	
+		printk(KERN_ERR "XGIfb: %dx%dx%d is no valid mode\n", 
+			var->xres, var->yres, var->bits_per_pixel);
+			
+                search_idx = 0;
+		while(XGIbios_mode[search_idx].mode_no != 0) {
+		       
+		   if( (var->xres <= XGIbios_mode[search_idx].xres) &&
+		       (var->yres <= XGIbios_mode[search_idx].yres) && 
+		       (var->bits_per_pixel == XGIbios_mode[search_idx].bpp) ) {
+		          if(XGIfb_validate_mode(search_idx) > 0) {
+			     found_mode = 1;
+			     break;
+			  }
+		   }
+		   search_idx++;
+	        }			
+		if(found_mode) {
+			var->xres = XGIbios_mode[search_idx].xres;
+		      	var->yres = XGIbios_mode[search_idx].yres;
+		      	printk(KERN_DEBUG "XGIfb: Adapted to mode %dx%dx%d\n",
+		   		var->xres, var->yres, var->bits_per_pixel);
+		   
+		} else {
+		   	printk(KERN_ERR "XGIfb: Failed to find similar mode to %dx%dx%d\n", 
+				var->xres, var->yres, var->bits_per_pixel);
+		   	return -EINVAL;
+		}
+	}
+
+	/* TW: TODO: Check the refresh rate */		
+	
+	/* Adapt RGB settings */
+	XGIfb_bpp_to_var(var);	
+	
+	/* Sanity check for offsets */
+	if (var->xoffset < 0)
+		var->xoffset = 0;
+	if (var->yoffset < 0)
+		var->yoffset = 0;
+
+
+	if(!XGIfb_ypan) {
+		if(var->xres != var->xres_virtual)
+			 var->xres_virtual = var->xres;
+		if(var->yres != var->yres_virtual)
+			var->yres_virtual = var->yres;
+	}/* else {
+	   // TW: Now patch yres_virtual if we use panning 
+	   // May I do this? 
+	   var->yres_virtual = xgi_video_info.heapstart / (var->xres * (var->bits_per_pixel >> 3));
+	    if(var->yres_virtual <= var->yres) {
+	    	// TW: Paranoia check 
+	        var->yres_virtual = var->yres;
+	    }
+	}*/
+
+	/* Truncate offsets to maximum if too high */
+	if (var->xoffset > var->xres_virtual - var->xres)
+		var->xoffset = var->xres_virtual - var->xres - 1;
+
+	if (var->yoffset > var->yres_virtual - var->yres)
+		var->yoffset = var->yres_virtual - var->yres - 1;
+	
+	/* Set everything else to 0 */
+	var->red.msb_right = 
+	    var->green.msb_right =
+	    var->blue.msb_right =
+	    var->transp.offset = var->transp.length = var->transp.msb_right = 0;		
+		
+	DEBUGPRN("end of check_var");
+	return 0;
+}
+
+#ifdef XGIFB_PAN
+static int XGIfb_pan_display( struct fb_var_screeninfo *var, 
+				 struct fb_info* info)
+{
+	int err;
+	
+//	printk("\nInside pan_display:");
+	
+	if (var->xoffset > (var->xres_virtual - var->xres))
+		return -EINVAL;
+	if (var->yoffset > (var->yres_virtual - var->yres))
+		return -EINVAL;
+
+	if (var->vmode & FB_VMODE_YWRAP) {
+		if (var->yoffset < 0
+		    || var->yoffset >= info->var.yres_virtual
+		    || var->xoffset) return -EINVAL;
+	} else {
+		if (var->xoffset + info->var.xres > info->var.xres_virtual ||
+		    var->yoffset + info->var.yres > info->var.yres_virtual)
+			return -EINVAL;
+	}
+    
+	if((err = XGIfb_pan_var(var)) < 0) return err;
+
+	info->var.xoffset = var->xoffset;
+	info->var.yoffset = var->yoffset;
+	if (var->vmode & FB_VMODE_YWRAP)
+		info->var.vmode |= FB_VMODE_YWRAP;
+	else
+		info->var.vmode &= ~FB_VMODE_YWRAP;
+
+//	printk(" End of pan_display");
+	return 0;
+}
+#endif
+
+#if 0
+static int XGIfb_mmap(struct fb_info *info, struct file *file,
+		      struct vm_area_struct *vma)
+{
+	unsigned long start;
+	unsigned long off;
+	u32 len, mmio_off;
+
+	DEBUGPRN("inside mmap");
+	if(vma->vm_pgoff > (~0UL >> PAGE_SHIFT))  return -EINVAL;
+
+	off = vma->vm_pgoff << PAGE_SHIFT;
+
+	start = (unsigned long) xgi_video_info.video_base;
+	len = PAGE_ALIGN((start & ~PAGE_MASK) + xgi_video_info.video_size);
+	start &= PAGE_MASK;
+#if 0
+	if (off >= len) {
+		off -= len;
+#endif
+	/* By Jake Page: Treat mmap request with offset beyond heapstart
+	 *               as request for mapping the mmio area 
+	 */
+	#if 1
+	mmio_off = PAGE_ALIGN((start & ~PAGE_MASK) + xgi_video_info.heapstart);
+	if(off >= mmio_off) {
+		off -= mmio_off;		
+		if(info->var.accel_flags) return -EINVAL;
+
+		start = (unsigned long) xgi_video_info.mmio_base;
+		len = PAGE_ALIGN((start & ~PAGE_MASK) + XGIfb_mmio_size);
+	}
+	start &= PAGE_MASK;
+	#endif
+	if((vma->vm_end - vma->vm_start + off) > len)	return -EINVAL;
+
+	off += start;
+	vma->vm_pgoff = off >> PAGE_SHIFT;
+	vma->vm_flags |= VM_IO;   /* by Jake Page; is that really needed? */
+
+#if defined(__i386__) || defined(__x86_64__)
+	if (boot_cpu_data.x86 > 3)
+		pgprot_val(vma->vm_page_prot) |= _PAGE_PCD;
+#endif
+	if (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT, vma->vm_end - vma->vm_start,
+				vma->vm_page_prot))
+		return -EAGAIN;
+
+        DEBUGPRN("end of mmap");
+	return 0;
+}
+#endif
+static int XGIfb_blank(int blank, struct fb_info *info)
+{
+	u8 reg;
+
+	inXGIIDXREG(XGICR, 0x17, reg);
+
+	if(blank > 0)
+		reg &= 0x7f;
+	else
+		reg |= 0x80;
+
+        outXGIIDXREG(XGICR, 0x17, reg);		
+	outXGIIDXREG(XGISR, 0x00, 0x01);    /* Synchronous Reset */
+	outXGIIDXREG(XGISR, 0x00, 0x03);    /* End Reset */
+        return(0);
+}
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
+static int XGIfb_ioctl(struct fb_info *info, unsigned int cmd,
+			    unsigned long arg)
+#else
+static int XGIfb_ioctl(struct inode *inode, struct file *file,
+		       unsigned int cmd, unsigned long arg, 
+		       struct fb_info *info)
+#endif
+
+{
+	DEBUGPRN("inside ioctl");
+	switch (cmd) {
+	   case FBIO_ALLOC:
+		if (!capable(CAP_SYS_RAWIO))
+			return -EPERM;
+		XGI_malloc((struct XGI_memreq *) arg);
+		break;
+	   case FBIO_FREE:
+		if (!capable(CAP_SYS_RAWIO))
+			return -EPERM;
+		XGI_free(*(unsigned long *) arg);
+		break;
+	   case FBIOGET_HWCINFO:
+		{
+			unsigned long *hwc_offset = (unsigned long *) arg;
+
+			if (XGIfb_caps & HW_CURSOR_CAP)
+				*hwc_offset = XGIfb_hwcursor_vbase -
+				    (unsigned long) xgi_video_info.video_vbase;
+			else
+				*hwc_offset = 0;
+
+			break;
+		}
+	   case FBIOPUT_MODEINFO:
+		{
+			struct mode_info *x = (struct mode_info *)arg;
+
+			xgi_video_info.video_bpp        = x->bpp;
+			xgi_video_info.video_width      = x->xres;
+			xgi_video_info.video_height     = x->yres;
+			xgi_video_info.video_vwidth     = x->v_xres;
+			xgi_video_info.video_vheight    = x->v_yres;
+			xgi_video_info.org_x            = x->org_x;
+			xgi_video_info.org_y            = x->org_y;
+			xgi_video_info.refresh_rate     = x->vrate;
+			xgi_video_info.video_linelength = xgi_video_info.video_vwidth * (xgi_video_info.video_bpp >> 3);
+			switch(xgi_video_info.video_bpp) {
+        		case 8:
+            			xgi_video_info.DstColor = 0x0000;
+	    			xgi_video_info.XGI310_AccelDepth = 0x00000000;
+				xgi_video_info.video_cmap_len = 256;
+            			break;
+        		case 16:
+            			xgi_video_info.DstColor = 0x8000;
+            			xgi_video_info.XGI310_AccelDepth = 0x00010000;
+				xgi_video_info.video_cmap_len = 16;
+            			break;
+        		case 32:
+            			xgi_video_info.DstColor = 0xC000;
+	    			xgi_video_info.XGI310_AccelDepth = 0x00020000;
+				xgi_video_info.video_cmap_len = 16;
+            			break;
+			default:
+				xgi_video_info.video_cmap_len = 16;
+		       	 	printk(KERN_ERR "XGIfb: Unsupported accel depth %d", xgi_video_info.video_bpp);
+				xgi_video_info.accel = 0;
+				break;
+    			}
+
+			break;
+		}
+	   case FBIOGET_DISPINFO:
+		XGI_dispinfo((struct ap_data *)arg);
+		break;
+	   case XGIFB_GET_INFO:  /* TW: New for communication with X driver */
+	        {
+			XGIfb_info *x = (XGIfb_info *)arg;
+
+			//x->XGIfb_id = XGIFB_ID;
+			x->XGIfb_version = VER_MAJOR;
+			x->XGIfb_revision = VER_MINOR;
+			x->XGIfb_patchlevel = VER_LEVEL;
+			x->chip_id = xgi_video_info.chip_id;
+			x->memory = xgi_video_info.video_size / 1024;
+			x->heapstart = xgi_video_info.heapstart / 1024;
+			x->fbvidmode = XGIfb_mode_no;
+			x->XGIfb_caps = XGIfb_caps;
+			x->XGIfb_tqlen = 512; /* yet unused */
+			x->XGIfb_pcibus = xgi_video_info.pcibus;
+			x->XGIfb_pcislot = xgi_video_info.pcislot;
+			x->XGIfb_pcifunc = xgi_video_info.pcifunc;
+			x->XGIfb_lcdpdc = XGIfb_detectedpdc;
+			x->XGIfb_lcda = XGIfb_detectedlcda;
+	                break;
+		}
+	   case XGIFB_GET_VBRSTATUS:
+	        {
+			unsigned long *vbrstatus = (unsigned long *) arg;
+			if(XGIfb_CheckVBRetrace()) *vbrstatus = 1;
+			else		           *vbrstatus = 0;
+		}
+	   default:
+		return -EINVAL;
+	}
+	DEBUGPRN("end of ioctl");
+	return 0;
+
+}
+
+
+
+/* ----------- FBDev related routines for all series ---------- */
+
+static int XGIfb_get_fix(struct fb_fix_screeninfo *fix, int con,
+			 struct fb_info *info)
+{
+	DEBUGPRN("inside get_fix");
+	memset(fix, 0, sizeof(struct fb_fix_screeninfo));
+
+	strcpy(fix->id, myid);
+
+	fix->smem_start = xgi_video_info.video_base;
+
+	fix->smem_len = xgi_video_info.video_size;
+	
+
+/*        if((!XGIfb_mem) || (XGIfb_mem > (xgi_video_info.video_size/1024))) {
+	    if (xgi_video_info.video_size > 0x1000000) {
+	        fix->smem_len = 0xD00000;
+	    } else if (xgi_video_info.video_size > 0x800000)
+		fix->smem_len = 0x800000;
+	    else
+		fix->smem_len = 0x400000;
+        } else
+		fix->smem_len = XGIfb_mem * 1024;
+*/
+	fix->type        = video_type;
+	fix->type_aux    = 0;
+	if(xgi_video_info.video_bpp == 8)
+		fix->visual = FB_VISUAL_PSEUDOCOLOR;
+	else
+		fix->visual = FB_VISUAL_DIRECTCOLOR;
+	fix->xpanstep    = 0;
+#ifdef XGIFB_PAN
+        if(XGIfb_ypan) 	 fix->ypanstep = 1;
+#endif
+	fix->ywrapstep   = 0;
+	fix->line_length = xgi_video_info.video_linelength;
+	fix->mmio_start  = xgi_video_info.mmio_base;
+	fix->mmio_len    = XGIfb_mmio_size;
+    if(xgi_video_info.chip >= XG40)
+	   fix->accel    = FB_ACCEL_XGI_XABRE;
+	else 
+	   fix->accel    = FB_ACCEL_XGI_GLAMOUR_2;
+	
+
+	DEBUGPRN("end of get_fix");
+	return 0;
+}
+
+
+static struct fb_ops XGIfb_ops = {
+	.owner        =	THIS_MODULE,
+	.fb_open      = XGIfb_open,
+	.fb_release   = XGIfb_release,
+	.fb_check_var = XGIfb_check_var,
+	.fb_set_par   = XGIfb_set_par,
+	.fb_setcolreg = XGIfb_setcolreg,
+#ifdef XGIFB_PAN
+        .fb_pan_display = XGIfb_pan_display,
+#endif	
+        .fb_blank     = XGIfb_blank,
+	.fb_fillrect  = fbcon_XGI_fillrect,
+	.fb_copyarea  = fbcon_XGI_copyarea,
+	.fb_imageblit = cfb_imageblit,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+	.fb_cursor    = soft_cursor,	
+#endif
+	.fb_sync      = fbcon_XGI_sync,
+	.fb_ioctl     =	XGIfb_ioctl,
+//	.fb_mmap      =	XGIfb_mmap,
+};
+
+/* ---------------- Chip generation dependent routines ---------------- */
+
+
+/* for XGI 315/550/650/740/330 */
+
+static int XGIfb_get_dram_size(void)
+{
+	
+	u8  ChannelNum,tmp;
+	u8  reg = 0;
+
+	        inXGIIDXREG(XGISR, IND_XGI_DRAM_SIZE, reg);
+		switch ((reg & XGI_DRAM_SIZE_MASK) >> 4) {
+		   case XGI_DRAM_SIZE_1MB:
+			xgi_video_info.video_size = 0x100000;
+			break;
+		   case XGI_DRAM_SIZE_2MB:
+			xgi_video_info.video_size = 0x200000;
+			break;
+		   case XGI_DRAM_SIZE_4MB:
+			xgi_video_info.video_size = 0x400000;
+			break;
+		   case XGI_DRAM_SIZE_8MB:
+			xgi_video_info.video_size = 0x800000;
+			break;
+		   case XGI_DRAM_SIZE_16MB:
+			xgi_video_info.video_size = 0x1000000;
+			break;
+		   case XGI_DRAM_SIZE_32MB:
+			xgi_video_info.video_size = 0x2000000;
+			break;
+		   case XGI_DRAM_SIZE_64MB:
+			xgi_video_info.video_size = 0x4000000;
+			break;
+		   case XGI_DRAM_SIZE_128MB:
+			xgi_video_info.video_size = 0x8000000;
+			break;
+		   case XGI_DRAM_SIZE_256MB:
+			xgi_video_info.video_size = 0x10000000;
+			break;
+		   default:
+			return -1;
+		}
+		
+		tmp = (reg & 0x0c) >> 2;
+		switch(xgi_video_info.chip)
+		{
+		    case XG20:
+                         XG21:
+		        ChannelNum = 1;
+		        break;
+		        
+		    case XG42:
+		        if(reg & 0x04)
+		            ChannelNum = 2;
+		        else
+		            ChannelNum = 1;
+		        break;
+		        
+		    case XG45:
+		        if(tmp == 1)
+                    ChannelNum = 2;		    
+                else 
+                if(tmp == 2)
+                    ChannelNum = 3;
+                else
+                if(tmp == 3)
+                    ChannelNum = 4;
+                else
+                    ChannelNum = 1;
+		        break;
+
+		    case XG40:
+		    default:
+                if(tmp == 2)
+                    ChannelNum = 2;		    
+                else 
+                if(tmp == 3)
+                    ChannelNum = 3;
+                else
+                    ChannelNum = 1;
+		        break;
+		}
+		
+		
+		xgi_video_info.video_size = xgi_video_info.video_size * ChannelNum;
+		//PLiad fixed for benchmarking and fb set
+		xgi_video_info.video_size = 0x200000;//1024x768x16
+		//xgi_video_info.video_size = 0x1000000;//benchmark
+		
+		printk("XGIfb: SR14=%x DramSzie %x ChannelNum %x\n",reg,xgi_video_info.video_size ,ChannelNum );
+		return 0;
+
+}
+
+static void XGIfb_detect_VB(void)
+{
+	u8 cr32, temp=0;
+
+	xgi_video_info.TV_plug = xgi_video_info.TV_type = 0;
+
+        switch(xgi_video_info.hasVB) {
+	  case HASVB_LVDS_CHRONTEL:
+	  case HASVB_CHRONTEL:
+	     break;
+	  case HASVB_301:
+	  case HASVB_302:
+//	     XGI_Sense30x(); //Yi-Lin TV Sense?
+	     break;
+	}
+
+	inXGIIDXREG(XGICR, IND_XGI_SCRATCH_REG_CR32, cr32);
+
+	if ((cr32 & XGI_CRT1) && !XGIfb_crt1off)
+		XGIfb_crt1off = 0;
+	else {
+		if (cr32 & 0x5F)   
+			XGIfb_crt1off = 1;
+		else
+			XGIfb_crt1off = 0;
+	}
+
+	if (XGIfb_crt2type != -1)
+		/* TW: Override with option */
+		xgi_video_info.disp_state = XGIfb_crt2type;
+	else if (cr32 & XGI_VB_TV)
+		xgi_video_info.disp_state = DISPTYPE_TV;		
+	else if (cr32 & XGI_VB_LCD)
+		xgi_video_info.disp_state = DISPTYPE_LCD;		
+	else if (cr32 & XGI_VB_CRT2)
+		xgi_video_info.disp_state = DISPTYPE_CRT2;
+	else
+		xgi_video_info.disp_state = 0;
+
+	if(XGIfb_tvplug != -1)
+		/* PR/TW: Override with option */
+	        xgi_video_info.TV_plug = XGIfb_tvplug;
+	else if (cr32 & XGI_VB_HIVISION) {
+		xgi_video_info.TV_type = TVMODE_HIVISION;
+		xgi_video_info.TV_plug = TVPLUG_SVIDEO;
+	}
+	else if (cr32 & XGI_VB_SVIDEO)
+		xgi_video_info.TV_plug = TVPLUG_SVIDEO;
+	else if (cr32 & XGI_VB_COMPOSITE)
+		xgi_video_info.TV_plug = TVPLUG_COMPOSITE;
+	else if (cr32 & XGI_VB_SCART)
+		xgi_video_info.TV_plug = TVPLUG_SCART;
+
+	if(xgi_video_info.TV_type == 0) {
+	    /* TW: PAL/NTSC changed for 650 */
+	    if((xgi_video_info.chip <= XGI_315PRO) || (xgi_video_info.chip >= XGI_330)) {
+
+                inXGIIDXREG(XGICR, 0x38, temp);
+		if(temp & 0x10)
+			xgi_video_info.TV_type = TVMODE_PAL;
+		else
+			xgi_video_info.TV_type = TVMODE_NTSC;
+
+	    } else {
+
+	        inXGIIDXREG(XGICR, 0x79, temp);
+		if(temp & 0x20)
+			xgi_video_info.TV_type = TVMODE_PAL;
+		else
+			xgi_video_info.TV_type = TVMODE_NTSC;
+	    }
+	}
+
+	/* TW: Copy forceCRT1 option to CRT1off if option is given */
+    	if (XGIfb_forcecrt1 != -1) {
+    		if (XGIfb_forcecrt1) XGIfb_crt1off = 0;
+		else   	             XGIfb_crt1off = 1;
+    	}
+}
+
+static void XGIfb_get_VB_type(void)
+{
+	u8 reg;
+
+	if (!XGIfb_has_VB()) {
+	        inXGIIDXREG(XGICR, IND_XGI_SCRATCH_REG_CR37, reg);
+		switch ((reg & XGI_EXTERNAL_CHIP_MASK) >> 1) {
+	 	   case XGI310_EXTERNAL_CHIP_LVDS:
+			xgi_video_info.hasVB = HASVB_LVDS;
+			break;
+		   case XGI310_EXTERNAL_CHIP_LVDS_CHRONTEL:
+			xgi_video_info.hasVB = HASVB_LVDS_CHRONTEL;
+			break;
+		   default:
+			break;
+		}
+	}
+}
+
+
+static int XGIfb_has_VB(void)
+{
+	u8 vb_chipid;
+
+	inXGIIDXREG(XGIPART4, 0x00, vb_chipid);
+	switch (vb_chipid) {
+	   case 0x01:
+		xgi_video_info.hasVB = HASVB_301;
+		break;
+	   case 0x02:
+		xgi_video_info.hasVB = HASVB_302;
+		break;
+	   default:
+		xgi_video_info.hasVB = HASVB_NONE;
+		return FALSE;
+	}
+	return TRUE;
+}
+
+
+
+/* ------------------ Sensing routines ------------------ */
+
+/* TW: Determine and detect attached devices on XGI30x */
+int
+XGIDoSense(int tempbl, int tempbh, int tempcl, int tempch)
+{
+    int temp,i;
+
+    outXGIIDXREG(XGIPART4,0x11,tempbl);
+    temp = tempbh | tempcl;
+    setXGIIDXREG(XGIPART4,0x10,0xe0,temp);
+    for(i=0; i<10; i++) XGI_LongWait(&XGI_Pr);
+    tempch &= 0x7f;
+    inXGIIDXREG(XGIPART4,0x03,temp);
+    temp ^= 0x0e;
+    temp &= tempch;
+    return(temp);
+}
+
+void
+XGI_Sense30x(void)
+{
+  u8 backupP4_0d;
+  u8 testsvhs_tempbl, testsvhs_tempbh;
+  u8 testsvhs_tempcl, testsvhs_tempch;
+  u8 testcvbs_tempbl, testcvbs_tempbh;
+  u8 testcvbs_tempcl, testcvbs_tempch;
+  u8 testvga2_tempbl, testvga2_tempbh;
+  u8 testvga2_tempcl, testvga2_tempch;
+  int myflag, result;
+
+  inXGIIDXREG(XGIPART4,0x0d,backupP4_0d);
+  outXGIIDXREG(XGIPART4,0x0d,(backupP4_0d | 0x04));
+
+
+
+	testvga2_tempbh = 0x00; testvga2_tempbl = 0xd1;
+        testsvhs_tempbh = 0x00; testsvhs_tempbl = 0xb9;
+	testcvbs_tempbh = 0x00; testcvbs_tempbl = 0xb3;
+	if((XGIhw_ext.ujVBChipID != VB_CHIP_301) &&
+	   (XGIhw_ext.ujVBChipID != VB_CHIP_302)) {
+	      testvga2_tempbh = 0x01; testvga2_tempbl = 0x90;
+	      testsvhs_tempbh = 0x01; testsvhs_tempbl = 0x6b;
+	      testcvbs_tempbh = 0x01; testcvbs_tempbl = 0x74;
+	      if(XGIhw_ext.ujVBChipID == VB_CHIP_301LV ||
+	         XGIhw_ext.ujVBChipID == VB_CHIP_302LV) {
+	         testvga2_tempbh = 0x00; testvga2_tempbl = 0x00;
+	         testsvhs_tempbh = 0x02; testsvhs_tempbl = 0x00;
+	         testcvbs_tempbh = 0x01; testcvbs_tempbl = 0x00;
+	      }
+	}
+	if(XGIhw_ext.ujVBChipID != VB_CHIP_301LV &&
+	   XGIhw_ext.ujVBChipID != VB_CHIP_302LV) {
+	   inXGIIDXREG(XGIPART4,0x01,myflag);
+	   if(myflag & 0x04) {
+	      testvga2_tempbh = 0x00; testvga2_tempbl = 0xfd;
+	      testsvhs_tempbh = 0x00; testsvhs_tempbl = 0xdd;
+	      testcvbs_tempbh = 0x00; testcvbs_tempbl = 0xee;
+	   }
+	}
+	if((XGIhw_ext.ujVBChipID == VB_CHIP_301LV) ||
+	   (XGIhw_ext.ujVBChipID == VB_CHIP_302LV) ) {
+	   testvga2_tempbh = 0x00; testvga2_tempbl = 0x00;
+	   testvga2_tempch = 0x00; testvga2_tempcl = 0x00;
+	   testsvhs_tempch = 0x04; testsvhs_tempcl = 0x08;
+	   testcvbs_tempch = 0x08; testcvbs_tempcl = 0x08;
+	} else {
+	   testvga2_tempch = 0x0e; testvga2_tempcl = 0x08;
+	   testsvhs_tempch = 0x06; testsvhs_tempcl = 0x04;
+	   testcvbs_tempch = 0x08; testcvbs_tempcl = 0x04;
+	}
+
+
+    if(testvga2_tempch || testvga2_tempcl || testvga2_tempbh || testvga2_tempbl) {
+        result = XGIDoSense(testvga2_tempbl, testvga2_tempbh,
+                            testvga2_tempcl, testvga2_tempch);
+ 	if(result) {
+        	printk(KERN_INFO "XGIfb: Detected secondary VGA connection\n");
+		orXGIIDXREG(XGICR, 0x32, 0x10);
+	}
+    }
+    
+    result = XGIDoSense(testsvhs_tempbl, testsvhs_tempbh,
+                        testsvhs_tempcl, testsvhs_tempch);
+    if(result) {
+        printk(KERN_INFO "XGIfb: Detected TV connected to SVHS output\n");
+        /* TW: So we can be sure that there IS a SVHS output */
+	xgi_video_info.TV_plug = TVPLUG_SVIDEO;
+	orXGIIDXREG(XGICR, 0x32, 0x02);
+    }
+
+    if(!result) {
+        result = XGIDoSense(testcvbs_tempbl, testcvbs_tempbh,
+	                    testcvbs_tempcl, testcvbs_tempch);
+	if(result) {
+	    printk(KERN_INFO "XGIfb: Detected TV connected to CVBS output\n");
+	    /* TW: So we can be sure that there IS a CVBS output */
+	    xgi_video_info.TV_plug = TVPLUG_COMPOSITE;
+	    orXGIIDXREG(XGICR, 0x32, 0x01);
+	}
+    }
+    XGIDoSense(0, 0, 0, 0);
+
+    outXGIIDXREG(XGIPART4,0x0d,backupP4_0d);
+}
+
+
+
+/* ------------------------ Heap routines -------------------------- */
+
+static int XGIfb_heap_init(void)
+{
+	XGI_OH *poh;
+	u8 temp=0;
+
+	int            agp_enabled = 1;
+	u32            agp_size;
+	unsigned long *cmdq_baseport = 0;
+	unsigned long *read_port = 0;
+	unsigned long *write_port = 0;
+	XGI_CMDTYPE    cmd_type;
+#ifndef AGPOFF
+	struct agp_kern_info  *agp_info;
+	struct agp_memory     *agp;
+	u32            agp_phys;
+#endif
+
+/* TW: The heap start is either set manually using the "mem" parameter, or
+ *     defaults as follows:
+ *     -) If more than 16MB videoRAM available, let our heap start at 12MB.
+ *     -) If more than  8MB videoRAM available, let our heap start at  8MB.
+ *     -) If 4MB or less is available, let it start at 4MB.
+ *     This is for avoiding a clash with X driver which uses the beginning
+ *     of the videoRAM. To limit size of X framebuffer, use Option MaxXFBMem
+ *     in XF86Config-4.
+ *     The heap start can also be specified by parameter "mem" when starting the XGIfb
+ *     driver. XGIfb mem=1024 lets heap starts at 1MB, etc.
+ */
+     if ((!XGIfb_mem) || (XGIfb_mem > (xgi_video_info.video_size/1024))) {
+        if (xgi_video_info.video_size > 0x1000000) {
+	        xgi_video_info.heapstart = 0xD00000;
+	} else if (xgi_video_info.video_size > 0x800000) {
+	        xgi_video_info.heapstart = 0x800000;
+	} else {
+		xgi_video_info.heapstart = 0x400000;
+	}
+     } else {
+           xgi_video_info.heapstart = XGIfb_mem * 1024;
+     }
+     XGIfb_heap_start =
+	       (unsigned long) (xgi_video_info.video_vbase + xgi_video_info.heapstart);
+     printk(KERN_INFO "XGIfb: Memory heap starting at %dK\n",
+     					(int)(xgi_video_info.heapstart / 1024));
+
+     XGIfb_heap_end = (unsigned long) xgi_video_info.video_vbase + xgi_video_info.video_size;
+     XGIfb_heap_size = XGIfb_heap_end - XGIfb_heap_start;
+
+
+ 
+        /* TW: Now initialize the 310 series' command queue mode.
+	 * On 310/325, there are three queue modes available which
+	 * are chosen by setting bits 7:5 in SR26:
+	 * 1. MMIO queue mode (bit 5, 0x20). The hardware will keep
+	 *    track of the queue, the FIFO, command parsing and so
+	 *    on. This is the one comparable to the 300 series.
+	 * 2. VRAM queue mode (bit 6, 0x40). In this case, one will
+	 *    have to do queue management himself. Register 0x85c4 will
+	 *    hold the location of the next free queue slot, 0x85c8
+	 *    is the "queue read pointer" whose way of working is
+	 *    unknown to me. Anyway, this mode would require a
+	 *    translation of the MMIO commands to some kind of
+	 *    accelerator assembly and writing these commands
+	 *    to the memory location pointed to by 0x85c4.
+	 *    We will not use this, as nobody knows how this
+	 *    "assembly" works, and as it would require a complete
+	 *    re-write of the accelerator code.
+	 * 3. AGP queue mode (bit 7, 0x80). Works as 2., but keeps the
+	 *    queue in AGP memory space.
+	 *
+	 * SR26 bit 4 is called "Bypass H/W queue".
+	 * SR26 bit 1 is called "Enable Command Queue Auto Correction"
+	 * SR26 bit 0 resets the queue
+	 * Size of queue memory is encoded in bits 3:2 like this:
+	 *    00  (0x00)  512K
+	 *    01  (0x04)  1M
+	 *    10  (0x08)  2M
+	 *    11  (0x0C)  4M
+	 * The queue location is to be written to 0x85C0.
+	 *
+         */
+	cmdq_baseport = (unsigned long *)(xgi_video_info.mmio_vbase + MMIO_QUEUE_PHYBASE);
+	write_port    = (unsigned long *)(xgi_video_info.mmio_vbase + MMIO_QUEUE_WRITEPORT);
+	read_port     = (unsigned long *)(xgi_video_info.mmio_vbase + MMIO_QUEUE_READPORT);
+
+	DPRINTK("AGP base: 0x%p, read: 0x%p, write: 0x%p\n", cmdq_baseport, read_port, write_port);
+
+	agp_size  = COMMAND_QUEUE_AREA_SIZE;
+
+#ifndef AGPOFF
+	if (XGIfb_queuemode == AGP_CMD_QUEUE) {
+		agp_info = vmalloc(sizeof(*agp_info));
+		memset((void*)agp_info, 0x00, sizeof(*agp_info));
+		agp_copy_info(agp_info);
+
+		agp_backend_acquire();
+
+		agp = agp_allocate_memory(COMMAND_QUEUE_AREA_SIZE/PAGE_SIZE,
+					  AGP_NORMAL_MEMORY);
+		if (agp == NULL) {
+			DPRINTK("XGIfb: Allocating AGP buffer failed.\n");
+			agp_enabled = 0;
+		} else {
+			if (agp_bind_memory(agp, agp->pg_start) != 0) {
+				DPRINTK("XGIfb: AGP: Failed to bind memory\n");
+				/* TODO: Free AGP memory here */
+				agp_enabled = 0;
+			} else {
+				agp_enable(0);
+			}
+		}
+	}
+#else
+	agp_enabled = 0;
+#endif
+
+	/* TW: Now select the queue mode */
+
+	if ((agp_enabled) && (XGIfb_queuemode == AGP_CMD_QUEUE)) {
+		cmd_type = AGP_CMD_QUEUE;
+		printk(KERN_INFO "XGIfb: Using AGP queue mode\n");
+/*	} else if (XGIfb_heap_size >= COMMAND_QUEUE_AREA_SIZE)  */
+        } else if (XGIfb_queuemode == VM_CMD_QUEUE) {
+		cmd_type = VM_CMD_QUEUE;
+		printk(KERN_INFO "XGIfb: Using VRAM queue mode\n");
+	} else {
+		printk(KERN_INFO "XGIfb: Using MMIO queue mode\n");
+		cmd_type = MMIO_CMD;
+	}
+
+	switch (agp_size) {
+	   case 0x80000:
+		temp = XGI_CMD_QUEUE_SIZE_512k;
+		break;
+	   case 0x100000:
+		temp = XGI_CMD_QUEUE_SIZE_1M;
+		break;
+	   case 0x200000:
+		temp = XGI_CMD_QUEUE_SIZE_2M;
+		break;
+	   case 0x400000:
+		temp = XGI_CMD_QUEUE_SIZE_4M;
+		break;
+	}
+
+	switch (cmd_type) {
+	   case AGP_CMD_QUEUE:
+#ifndef AGPOFF
+		DPRINTK("XGIfb: AGP buffer base = 0x%lx, offset = 0x%x, size = %dK\n",
+			agp_info->aper_base, agp->physical, agp_size/1024);
+
+		agp_phys = agp_info->aper_base + agp->physical;
+
+		outXGIIDXREG(XGICR,  IND_XGI_AGP_IO_PAD, 0);
+		outXGIIDXREG(XGICR,  IND_XGI_AGP_IO_PAD, XGI_AGP_2X);
+
+                outXGIIDXREG(XGISR, IND_XGI_CMDQUEUE_THRESHOLD, COMMAND_QUEUE_THRESHOLD);
+
+		outXGIIDXREG(XGISR, IND_XGI_CMDQUEUE_SET, XGI_CMD_QUEUE_RESET);
+
+		*write_port = *read_port;
+
+		temp |= XGI_AGP_CMDQUEUE_ENABLE;
+		outXGIIDXREG(XGISR, IND_XGI_CMDQUEUE_SET, temp);
+
+		*cmdq_baseport = agp_phys;
+
+		XGIfb_caps |= AGP_CMD_QUEUE_CAP;
+#endif
+		break;
+
+	   case VM_CMD_QUEUE:
+		XGIfb_heap_end -= COMMAND_QUEUE_AREA_SIZE;
+		XGIfb_heap_size -= COMMAND_QUEUE_AREA_SIZE;
+
+		outXGIIDXREG(XGISR, IND_XGI_CMDQUEUE_THRESHOLD, COMMAND_QUEUE_THRESHOLD);
+
+		outXGIIDXREG(XGISR, IND_XGI_CMDQUEUE_SET, XGI_CMD_QUEUE_RESET);
+
+		*write_port = *read_port;
+
+		temp |= XGI_VRAM_CMDQUEUE_ENABLE;
+		outXGIIDXREG(XGISR, IND_XGI_CMDQUEUE_SET, temp);
+
+		*cmdq_baseport = xgi_video_info.video_size - COMMAND_QUEUE_AREA_SIZE;
+
+		XGIfb_caps |= VM_CMD_QUEUE_CAP;
+
+		DPRINTK("XGIfb: VM Cmd Queue offset = 0x%lx, size is %dK\n",
+			*cmdq_baseport, COMMAND_QUEUE_AREA_SIZE/1024);
+		break;
+
+	   default:  /* MMIO */
+
+//		printk("%s:%d - I'm here\n", __FUNCTION__, __LINE__);
+	   	/* TW: This previously only wrote XGI_MMIO_CMD_ENABLE
+		 * to IND_XGI_CMDQUEUE_SET. I doubt that this is
+		 * enough. Reserve memory in any way.
+		 */
+// FIXME 	   	XGIfb_heap_end -= COMMAND_QUEUE_AREA_SIZE;
+// FIXME 		XGIfb_heap_size -= COMMAND_QUEUE_AREA_SIZE;
+// FIXME 
+// FIXME 		outXGIIDXREG(XGISR, IND_XGI_CMDQUEUE_THRESHOLD, COMMAND_QUEUE_THRESHOLD);
+// FIXME 		outXGIIDXREG(XGISR, IND_XGI_CMDQUEUE_SET, XGI_CMD_QUEUE_RESET);
+// FIXME 
+// FIXME 		*write_port = *read_port;
+// FIXME 
+// FIXME 		/* TW: Set Auto_Correction bit */
+// FIXME 		temp |= (XGI_MMIO_CMD_ENABLE | XGI_CMD_AUTO_CORR);
+// FIXME 		// FIXME outXGIIDXREG(XGISR, IND_XGI_CMDQUEUE_SET, temp);
+// FIXME 
+// FIXME 		*cmdq_baseport = xgi_video_info.video_size - COMMAND_QUEUE_AREA_SIZE;
+// FIXME 
+// FIXME 		XGIfb_caps |= MMIO_CMD_QUEUE_CAP;
+// FIXME 
+// FIXME 		DPRINTK("XGIfb: MMIO Cmd Queue offset = 0x%lx, size is %dK\n",
+// FIXME 			*cmdq_baseport, COMMAND_QUEUE_AREA_SIZE/1024);
+		break;
+	}
+
+
+
+
+     /* TW: Now reserve memory for the HWCursor. It is always located at the very
+            top of the videoRAM, right below the TB memory area (if used). */
+     if (XGIfb_heap_size >= XGIfb_hwcursor_size) {
+		XGIfb_heap_end -= XGIfb_hwcursor_size;
+		XGIfb_heap_size -= XGIfb_hwcursor_size;
+		XGIfb_hwcursor_vbase = XGIfb_heap_end;
+
+		XGIfb_caps |= HW_CURSOR_CAP;
+
+		DPRINTK("XGIfb: Hardware Cursor start at 0x%lx, size is %dK\n",
+			XGIfb_heap_end, XGIfb_hwcursor_size/1024);
+     }
+
+     XGIfb_heap.poha_chain = NULL;
+     XGIfb_heap.poh_freelist = NULL;
+
+     poh = XGIfb_poh_new_node();
+
+     if(poh == NULL)  return 1;
+	
+     poh->poh_next = &XGIfb_heap.oh_free;
+     poh->poh_prev = &XGIfb_heap.oh_free;
+     poh->size = XGIfb_heap_end - XGIfb_heap_start + 1;
+     poh->offset = XGIfb_heap_start - (unsigned long) xgi_video_info.video_vbase;
+
+     DPRINTK("XGIfb: Heap start:0x%p, end:0x%p, len=%dk\n",
+		(char *) XGIfb_heap_start, (char *) XGIfb_heap_end,
+		(unsigned int) poh->size / 1024);
+
+     DPRINTK("XGIfb: First Node offset:0x%x, size:%dk\n",
+		(unsigned int) poh->offset, (unsigned int) poh->size / 1024);
+
+     XGIfb_heap.oh_free.poh_next = poh;
+     XGIfb_heap.oh_free.poh_prev = poh;
+     XGIfb_heap.oh_free.size = 0;
+     XGIfb_heap.max_freesize = poh->size;
+
+     XGIfb_heap.oh_used.poh_next = &XGIfb_heap.oh_used;
+     XGIfb_heap.oh_used.poh_prev = &XGIfb_heap.oh_used;
+     XGIfb_heap.oh_used.size = SENTINEL;
+
+     return 0;
+}
+
+static XGI_OH *XGIfb_poh_new_node(void)
+{
+	int           i;
+	unsigned long cOhs;
+	XGI_OHALLOC   *poha;
+	XGI_OH        *poh;
+
+	if (XGIfb_heap.poh_freelist == NULL) {
+		poha = kmalloc(OH_ALLOC_SIZE, GFP_KERNEL);
+		if(!poha) return NULL;
+
+		poha->poha_next = XGIfb_heap.poha_chain;
+		XGIfb_heap.poha_chain = poha;
+
+		cOhs = (OH_ALLOC_SIZE - sizeof(XGI_OHALLOC)) / sizeof(XGI_OH) + 1;
+
+		poh = &poha->aoh[0];
+		for (i = cOhs - 1; i != 0; i--) {
+			poh->poh_next = poh + 1;
+			poh = poh + 1;
+		}
+
+		poh->poh_next = NULL;
+		XGIfb_heap.poh_freelist = &poha->aoh[0];
+	}
+
+	poh = XGIfb_heap.poh_freelist;
+	XGIfb_heap.poh_freelist = poh->poh_next;
+
+	return (poh);
+}
+
+static XGI_OH *XGIfb_poh_allocate(unsigned long size)
+{
+	XGI_OH *pohThis;
+	XGI_OH *pohRoot;
+	int     bAllocated = 0;
+
+	if (size > XGIfb_heap.max_freesize) {
+		DPRINTK("XGIfb: Can't allocate %dk size on offscreen\n",
+			(unsigned int) size / 1024);
+		return (NULL);
+	}
+
+	pohThis = XGIfb_heap.oh_free.poh_next;
+
+	while (pohThis != &XGIfb_heap.oh_free) {
+		if (size <= pohThis->size) {
+			bAllocated = 1;
+			break;
+		}
+		pohThis = pohThis->poh_next;
+	}
+
+	if (!bAllocated) {
+		DPRINTK("XGIfb: Can't allocate %dk size on offscreen\n",
+			(unsigned int) size / 1024);
+		return (NULL);
+	}
+
+	if (size == pohThis->size) {
+		pohRoot = pohThis;
+		XGIfb_delete_node(pohThis);
+	} else {
+		pohRoot = XGIfb_poh_new_node();
+
+		if (pohRoot == NULL) {
+			return (NULL);
+		}
+
+		pohRoot->offset = pohThis->offset;
+		pohRoot->size = size;
+
+		pohThis->offset += size;
+		pohThis->size -= size;
+	}
+
+	XGIfb_heap.max_freesize -= size;
+
+	pohThis = &XGIfb_heap.oh_used;
+	XGIfb_insert_node(pohThis, pohRoot);
+
+	return (pohRoot);
+}
+
+static void XGIfb_delete_node(XGI_OH *poh)
+{
+	XGI_OH *poh_prev;
+	XGI_OH *poh_next;
+
+	poh_prev = poh->poh_prev;
+	poh_next = poh->poh_next;
+
+	poh_prev->poh_next = poh_next;
+	poh_next->poh_prev = poh_prev;
+
+}
+
+static void XGIfb_insert_node(XGI_OH *pohList, XGI_OH *poh)
+{
+	XGI_OH *pohTemp;
+
+	pohTemp = pohList->poh_next;
+
+	pohList->poh_next = poh;
+	pohTemp->poh_prev = poh;
+
+	poh->poh_prev = pohList;
+	poh->poh_next = pohTemp;
+}
+
+static XGI_OH *XGIfb_poh_free(unsigned long base)
+{
+	XGI_OH *pohThis;
+	XGI_OH *poh_freed;
+	XGI_OH *poh_prev;
+	XGI_OH *poh_next;
+	unsigned long ulUpper;
+	unsigned long ulLower;
+	int foundNode = 0;
+
+	poh_freed = XGIfb_heap.oh_used.poh_next;
+
+	while(poh_freed != &XGIfb_heap.oh_used) {
+		if(poh_freed->offset == base) {
+			foundNode = 1;
+			break;
+		}
+
+		poh_freed = poh_freed->poh_next;
+	}
+
+	if (!foundNode)  return (NULL);
+
+	XGIfb_heap.max_freesize += poh_freed->size;
+
+	poh_prev = poh_next = NULL;
+	ulUpper = poh_freed->offset + poh_freed->size;
+	ulLower = poh_freed->offset;
+
+	pohThis = XGIfb_heap.oh_free.poh_next;
+
+	while (pohThis != &XGIfb_heap.oh_free) {
+		if (pohThis->offset == ulUpper) {
+			poh_next = pohThis;
+		}
+			else if ((pohThis->offset + pohThis->size) ==
+				 ulLower) {
+			poh_prev = pohThis;
+		}
+		pohThis = pohThis->poh_next;
+	}
+
+	XGIfb_delete_node(poh_freed);
+
+	if (poh_prev && poh_next) {
+		poh_prev->size += (poh_freed->size + poh_next->size);
+		XGIfb_delete_node(poh_next);
+		XGIfb_free_node(poh_freed);
+		XGIfb_free_node(poh_next);
+		return (poh_prev);
+	}
+
+	if (poh_prev) {
+		poh_prev->size += poh_freed->size;
+		XGIfb_free_node(poh_freed);
+		return (poh_prev);
+	}
+
+	if (poh_next) {
+		poh_next->size += poh_freed->size;
+		poh_next->offset = poh_freed->offset;
+		XGIfb_free_node(poh_freed);
+		return (poh_next);
+	}
+
+	XGIfb_insert_node(&XGIfb_heap.oh_free, poh_freed);
+
+	return (poh_freed);
+}
+
+static void XGIfb_free_node(XGI_OH *poh)
+{
+	if(poh == NULL) return;
+
+	poh->poh_next = XGIfb_heap.poh_freelist;
+	XGIfb_heap.poh_freelist = poh;
+
+}
+
+void XGI_malloc(struct XGI_memreq *req)
+{
+	XGI_OH *poh;
+
+	poh = XGIfb_poh_allocate(req->size);
+
+	if(poh == NULL) {
+		req->offset = 0;
+		req->size = 0;
+		DPRINTK("XGIfb: Video RAM allocation failed\n");
+	} else {
+		DPRINTK("XGIfb: Video RAM allocation succeeded: 0x%p\n",
+			(char *) (poh->offset + (unsigned long) xgi_video_info.video_vbase));
+
+		req->offset = poh->offset;
+		req->size = poh->size;
+	}
+
+}
+
+void XGI_free(unsigned long base)
+{
+	XGI_OH *poh;
+
+	poh = XGIfb_poh_free(base);
+
+	if(poh == NULL) {
+		DPRINTK("XGIfb: XGIfb_poh_free() failed at base 0x%x\n",
+			(unsigned int) base);
+	}
+}
+
+/* --------------------- SetMode routines ------------------------- */
+
+static void XGIfb_pre_setmode(void)
+{
+	u8 cr30 = 0, cr31 = 0;
+
+	inXGIIDXREG(XGICR, 0x31, cr31);
+	cr31 &= ~0x60;
+
+	switch (xgi_video_info.disp_state & DISPTYPE_DISP2) {
+	   case DISPTYPE_CRT2:
+		cr30 = (XGI_VB_OUTPUT_CRT2 | XGI_SIMULTANEOUS_VIEW_ENABLE);
+		cr31 |= XGI_DRIVER_MODE;
+		break;
+	   case DISPTYPE_LCD:
+		cr30  = (XGI_VB_OUTPUT_LCD | XGI_SIMULTANEOUS_VIEW_ENABLE);
+		cr31 |= XGI_DRIVER_MODE;
+		break;
+	   case DISPTYPE_TV:
+		if (xgi_video_info.TV_type == TVMODE_HIVISION)
+			cr30 = (XGI_VB_OUTPUT_HIVISION | XGI_SIMULTANEOUS_VIEW_ENABLE);
+		else if (xgi_video_info.TV_plug == TVPLUG_SVIDEO)
+			cr30 = (XGI_VB_OUTPUT_SVIDEO | XGI_SIMULTANEOUS_VIEW_ENABLE);
+		else if (xgi_video_info.TV_plug == TVPLUG_COMPOSITE)
+			cr30 = (XGI_VB_OUTPUT_COMPOSITE | XGI_SIMULTANEOUS_VIEW_ENABLE);
+		else if (xgi_video_info.TV_plug == TVPLUG_SCART)
+			cr30 = (XGI_VB_OUTPUT_SCART | XGI_SIMULTANEOUS_VIEW_ENABLE);
+		cr31 |= XGI_DRIVER_MODE;
+
+	        if (XGIfb_tvmode == 1 || xgi_video_info.TV_type == TVMODE_PAL)
+			cr31 |= 0x01;
+                else
+                        cr31 &= ~0x01;
+		break;
+	   default:	/* disable CRT2 */
+		cr30 = 0x00;
+		cr31 |= (XGI_DRIVER_MODE | XGI_VB_OUTPUT_DISABLE);
+	}
+
+	outXGIIDXREG(XGICR, IND_XGI_SCRATCH_REG_CR30, cr30);
+	outXGIIDXREG(XGICR, IND_XGI_SCRATCH_REG_CR31, cr31);
+        outXGIIDXREG(XGICR, IND_XGI_SCRATCH_REG_CR33, (XGIfb_rate_idx & 0x0F));
+
+	if(xgi_video_info.accel) XGIfb_syncaccel();
+
+	
+}
+
+static void XGIfb_post_setmode(void)
+{
+	u8 reg;
+	BOOLEAN doit = TRUE;
+#if 0	/* TW: Wrong: Is not in MMIO space, but in RAM */
+	/* Backup mode number to MMIO space */
+	if(xgi_video_info.mmio_vbase) {
+	  *(volatile u8 *)(((u8*)xgi_video_info.mmio_vbase) + 0x449) = (unsigned char)XGIfb_mode_no;
+	}
+#endif	
+/*	outXGIIDXREG(XGISR,IND_XGI_PASSWORD,XGI_PASSWORD);
+	outXGIIDXREG(XGICR,0x13,0x00);
+	setXGIIDXREG(XGISR,0x0E,0xF0,0x01);
+*test**/
+	if (xgi_video_info.video_bpp == 8) {
+		/* TW: We can't switch off CRT1 on LVDS/Chrontel in 8bpp Modes */
+		if ((xgi_video_info.hasVB == HASVB_LVDS) || (xgi_video_info.hasVB == HASVB_LVDS_CHRONTEL)) {
+			doit = FALSE;
+		}
+		/* TW: We can't switch off CRT1 on 301B-DH in 8bpp Modes if using LCD */
+		if  (xgi_video_info.disp_state & DISPTYPE_LCD)  {
+	        	doit = FALSE;
+	        }
+	}
+
+	/* TW: We can't switch off CRT1 if bridge is in slave mode */
+	if(xgi_video_info.hasVB != HASVB_NONE) {
+		inXGIIDXREG(XGIPART1, 0x00, reg);
+
+
+		if((reg & 0x50) == 0x10) {
+			doit = FALSE;
+		}
+
+	} else XGIfb_crt1off = 0;
+
+	inXGIIDXREG(XGICR, 0x17, reg);
+	if((XGIfb_crt1off) && (doit))
+		reg &= ~0x80;
+	else 	      
+		reg |= 0x80;
+	outXGIIDXREG(XGICR, 0x17, reg);
+
+        andXGIIDXREG(XGISR, IND_XGI_RAMDAC_CONTROL, ~0x04);
+
+	if((xgi_video_info.disp_state & DISPTYPE_TV) && (xgi_video_info.hasVB == HASVB_301)) {
+
+	   inXGIIDXREG(XGIPART4, 0x01, reg);
+
+	   if(reg < 0xB0) {        	/* Set filter for XGI301 */
+
+		switch (xgi_video_info.video_width) {
+		   case 320:
+			filter_tb = (xgi_video_info.TV_type == TVMODE_NTSC) ? 4 : 12;
+			break;
+		   case 640:
+			filter_tb = (xgi_video_info.TV_type == TVMODE_NTSC) ? 5 : 13;
+			break;
+		   case 720:
+			filter_tb = (xgi_video_info.TV_type == TVMODE_NTSC) ? 6 : 14;
+			break;
+		   case 800:
+			filter_tb = (xgi_video_info.TV_type == TVMODE_NTSC) ? 7 : 15;
+			break;
+		   default:
+			filter = -1;
+			break;
+		}
+
+		orXGIIDXREG(XGIPART1, XGIfb_CRT2_write_enable, 0x01);
+
+		if(xgi_video_info.TV_type == TVMODE_NTSC) {
+
+		        andXGIIDXREG(XGIPART2, 0x3a, 0x1f);
+
+			if (xgi_video_info.TV_plug == TVPLUG_SVIDEO) {
+
+			        andXGIIDXREG(XGIPART2, 0x30, 0xdf);
+
+			} else if (xgi_video_info.TV_plug == TVPLUG_COMPOSITE) {
+
+			        orXGIIDXREG(XGIPART2, 0x30, 0x20);
+
+				switch (xgi_video_info.video_width) {
+				case 640:
+				        outXGIIDXREG(XGIPART2, 0x35, 0xEB);
+					outXGIIDXREG(XGIPART2, 0x36, 0x04);
+					outXGIIDXREG(XGIPART2, 0x37, 0x25);
+					outXGIIDXREG(XGIPART2, 0x38, 0x18);
+					break;
+				case 720:
+					outXGIIDXREG(XGIPART2, 0x35, 0xEE);
+					outXGIIDXREG(XGIPART2, 0x36, 0x0C);
+					outXGIIDXREG(XGIPART2, 0x37, 0x22);
+					outXGIIDXREG(XGIPART2, 0x38, 0x08);
+					break;
+				case 800:
+					outXGIIDXREG(XGIPART2, 0x35, 0xEB);
+					outXGIIDXREG(XGIPART2, 0x36, 0x15);
+					outXGIIDXREG(XGIPART2, 0x37, 0x25);
+					outXGIIDXREG(XGIPART2, 0x38, 0xF6);
+					break;
+				}
+			}
+
+		} else if(xgi_video_info.TV_type == TVMODE_PAL) {
+
+			andXGIIDXREG(XGIPART2, 0x3A, 0x1F);
+
+			if (xgi_video_info.TV_plug == TVPLUG_SVIDEO) {
+
+			        andXGIIDXREG(XGIPART2, 0x30, 0xDF);
+
+			} else if (xgi_video_info.TV_plug == TVPLUG_COMPOSITE) {
+
+			        orXGIIDXREG(XGIPART2, 0x30, 0x20);
+
+				switch (xgi_video_info.video_width) {
+				case 640:
+					outXGIIDXREG(XGIPART2, 0x35, 0xF1);
+					outXGIIDXREG(XGIPART2, 0x36, 0xF7);
+					outXGIIDXREG(XGIPART2, 0x37, 0x1F);
+					outXGIIDXREG(XGIPART2, 0x38, 0x32);
+					break;
+				case 720:
+					outXGIIDXREG(XGIPART2, 0x35, 0xF3);
+					outXGIIDXREG(XGIPART2, 0x36, 0x00);
+					outXGIIDXREG(XGIPART2, 0x37, 0x1D);
+					outXGIIDXREG(XGIPART2, 0x38, 0x20);
+					break;
+				case 800:
+					outXGIIDXREG(XGIPART2, 0x35, 0xFC);
+					outXGIIDXREG(XGIPART2, 0x36, 0xFB);
+					outXGIIDXREG(XGIPART2, 0x37, 0x14);
+					outXGIIDXREG(XGIPART2, 0x38, 0x2A);
+					break;
+				}
+			}
+		}
+
+		if ((filter >= 0) && (filter <=7)) {
+			DPRINTK("FilterTable[%d]-%d: %02x %02x %02x %02x\n", filter_tb, filter, 
+				XGI_TV_filter[filter_tb].filter[filter][0],
+				XGI_TV_filter[filter_tb].filter[filter][1],
+				XGI_TV_filter[filter_tb].filter[filter][2],
+				XGI_TV_filter[filter_tb].filter[filter][3]
+			);
+			outXGIIDXREG(XGIPART2, 0x35, (XGI_TV_filter[filter_tb].filter[filter][0]));
+			outXGIIDXREG(XGIPART2, 0x36, (XGI_TV_filter[filter_tb].filter[filter][1]));
+			outXGIIDXREG(XGIPART2, 0x37, (XGI_TV_filter[filter_tb].filter[filter][2]));
+			outXGIIDXREG(XGIPART2, 0x38, (XGI_TV_filter[filter_tb].filter[filter][3]));
+		}
+
+	     }
+	  
+	}
+
+}
+
+#ifndef MODULE
+XGIINITSTATIC int __init XGIfb_setup(char *options)
+{
+	char *this_opt;
+	
+
+
+	xgi_video_info.refresh_rate = 0;
+
+        printk(KERN_INFO "XGIfb: Options %s\n", options);
+
+	if (!options || !*options)
+		return 0;
+
+	while((this_opt = strsep(&options, ",")) != NULL) {
+
+		if (!*this_opt)	continue;
+
+		if (!strncmp(this_opt, "mode:", 5)) {
+			XGIfb_search_mode(this_opt + 5);
+		} else if (!strncmp(this_opt, "vesa:", 5)) {
+			XGIfb_search_vesamode(simple_strtoul(this_opt + 5, NULL, 0));
+		} else if (!strncmp(this_opt, "mode:", 5)) {
+			XGIfb_search_mode(this_opt + 5);
+		} else if (!strncmp(this_opt, "vesa:", 5)) {
+			XGIfb_search_vesamode(simple_strtoul(this_opt + 5, NULL, 0));
+		} else if (!strncmp(this_opt, "vrate:", 6)) {
+			xgi_video_info.refresh_rate = simple_strtoul(this_opt + 6, NULL, 0);
+		} else if (!strncmp(this_opt, "rate:", 5)) {
+			xgi_video_info.refresh_rate = simple_strtoul(this_opt + 5, NULL, 0);
+		} else if (!strncmp(this_opt, "off", 3)) {
+			XGIfb_off = 1;
+		} else if (!strncmp(this_opt, "crt1off", 7)) {
+			XGIfb_crt1off = 1;
+		} else if (!strncmp(this_opt, "filter:", 7)) {
+			filter = (int)simple_strtoul(this_opt + 7, NULL, 0);
+		} else if (!strncmp(this_opt, "forcecrt2type:", 14)) {
+			XGIfb_search_crt2type(this_opt + 14);
+		} else if (!strncmp(this_opt, "forcecrt1:", 10)) {
+			XGIfb_forcecrt1 = (int)simple_strtoul(this_opt + 10, NULL, 0);
+                } else if (!strncmp(this_opt, "tvmode:",7)) {
+		        XGIfb_search_tvstd(this_opt + 7);
+                } else if (!strncmp(this_opt, "tvstandard:",11)) {
+			XGIfb_search_tvstd(this_opt + 7);
+                } else if (!strncmp(this_opt, "mem:",4)) {
+		        XGIfb_mem = simple_strtoul(this_opt + 4, NULL, 0);
+                } else if (!strncmp(this_opt, "dstn", 4)) {
+			enable_dstn = 1;
+			/* TW: DSTN overrules forcecrt2type */
+			XGIfb_crt2type = DISPTYPE_LCD;
+		} else if (!strncmp(this_opt, "queuemode:", 10)) {
+			XGIfb_search_queuemode(this_opt + 10);
+		} else if (!strncmp(this_opt, "pdc:", 4)) {
+		        XGIfb_pdc = simple_strtoul(this_opt + 4, NULL, 0);
+		        if(XGIfb_pdc & ~0x3c) {
+			   printk(KERN_INFO "XGIfb: Illegal pdc parameter\n");
+			   XGIfb_pdc = 0;
+		        }
+		} else if (!strncmp(this_opt, "noaccel", 7)) {
+			XGIfb_accel = 0;
+		} else if (!strncmp(this_opt, "noypan", 6)) {
+		        XGIfb_ypan = 0;
+		} else if (!strncmp(this_opt, "userom:", 7)) {
+			XGIfb_userom = (int)simple_strtoul(this_opt + 7, NULL, 0);
+//		} else if (!strncmp(this_opt, "useoem:", 7)) {
+//			XGIfb_useoem = (int)simple_strtoul(this_opt + 7, NULL, 0);
+		} else {
+			printk(KERN_INFO "XGIfb: Invalid option %s\n", this_opt);
+		}
+
+		/* TW: Acceleration only with MMIO mode */
+		if((XGIfb_queuemode != -1) && (XGIfb_queuemode != MMIO_CMD)) {
+			XGIfb_ypan = 0;
+			XGIfb_accel = 0;
+		}
+		/* TW: Panning only with acceleration */
+		if(XGIfb_accel == 0) XGIfb_ypan = 0;
+
+	}
+	printk("\nxgifb: outa xgifb_setup 3450");
+	return 0;
+}
+#endif
+
+static unsigned char VBIOS_BUF[65535];
+
+unsigned char* attempt_map_rom(struct pci_dev *dev,void *copy_address)
+{
+    u32 rom_size      = 0;
+    u32 rom_address   = 0;
+    u32 bar_size      = 0;
+    u32 bar_backup    = 0;
+    int i,j;
+    void *image       = 0;
+    u32 image_size    = 0;
+    int did_correct   = 0;
+    u32 prefetch_addr = 0;
+    u32 prefetch_size = 0;
+    u32 prefetch_idx  = 0;
+
+    /*  Get the size of the expansion rom */
+    pci_write_config_dword(dev, PCI_ROM_ADDRESS, 0xFFFFFFFF);
+    pci_read_config_dword(dev, PCI_ROM_ADDRESS, &rom_size);
+    if ((rom_size & 0x01) == 0)
+    {
+		printk("No ROM\n");
+		return NULL;
+    }
+
+    rom_size &= 0xFFFFF800;
+    rom_size = (~rom_size)+1;
+
+    rom_address = pci_resource_start(dev, 0);
+    if (rom_address == 0 || rom_address == 0xFFFFFFF0)
+    {
+		printk("No suitable rom address found\n"); return NULL;
+    }
+
+    printk("ROM Size is %dK, Address is %x\n", rom_size/1024, rom_address);
+
+    /*  Map ROM */
+    pci_write_config_dword(dev, PCI_ROM_ADDRESS, rom_address | PCI_ROM_ADDRESS_ENABLE);
+
+    /* memcpy(copy_address, rom_address, rom_size); */
+    {
+		unsigned char *virt_addr = ioremap(rom_address, 0x8000000);
+
+		unsigned char *from = (unsigned char *)virt_addr;
+		unsigned char *to = (unsigned char *)copy_address;
+		for (j=0; j<65536 /*rom_size*/; j++) *to++ = *from++;
+// DEL 		
+// DEL 		iounmap(virt_addr);
+	}
+
+	pci_write_config_dword(dev, PCI_ROM_ADDRESS, 0);
+	
+    printk("Copy is done\n");
+
+	return copy_address;
+}
+
+static char *XGI_find_rom(void)
+{
+#if defined(__i386__)
+        u32  segstart;
+        unsigned char *rom_base;
+        unsigned char *rom;
+        int  stage;
+        int  i;
+        char XGI_rom_sig[] = "XGI Technology, Inc.";
+        
+        char *XGI_sig[5] = {
+          "Volari GPU", "XG41","XG42", "XG45", "Volari Z7"
+        };
+	
+	unsigned short XGI_nums[5] = {
+	    XG40, XG41, XG42, XG45, XG20
+	};
+
+        for(segstart=0x000c0000; segstart<0x000f0000; segstart+=0x00001000) {
+
+                stage = 1;
+
+                rom_base = (char *)ioremap(segstart, 0x1000);
+
+                if ((*rom_base == 0x55) && (((*(rom_base + 1)) & 0xff) == 0xaa))
+                   stage = 2;
+
+                if (stage != 2) {
+                   iounmap(rom_base);
+                   continue;
+                }
+
+
+		rom = rom_base + (unsigned short)(*(rom_base + 0x12) | (*(rom_base + 0x13) << 8));
+                if(strncmp(XGI_rom_sig, rom, strlen(XGI_rom_sig)) == 0) {
+                    stage = 3;
+		}
+                if(stage != 3) {
+                    iounmap(rom_base);
+                    continue;
+                }
+
+		rom = rom_base + (unsigned short)(*(rom_base + 0x14) | (*(rom_base + 0x15) << 8));
+        for(i = 0;(i < 5) && (stage != 4); i++) {
+            if(strncmp(XGI_sig[i], rom, strlen(XGI_sig[i])) == 0) {
+		        if(XGI_nums[i] == xgi_video_info.chip) {
+                    stage = 4;
+                    break;
+			    }
+            }
+        }
+		
+
+        if(stage != 4) {
+            iounmap(rom_base);
+            continue;
+        }
+
+        return rom_base;
+        }
+#endif
+        return NULL;
+}
+
+/* ------------------------- duzhongkai's code start here -------------------------- */
+
+static struct proc_dir_entry *v3xt_proc_entry = NULL;
+
+static int v3xt_proc_read(char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	sprintf(page, "I'm here\n");
+	
+	dumpVGAReg();
+	return strlen(page);
+}
+
+static int v3xt_proc_write(struct file *file, 
+		const char *buffer, unsigned long count, void *data)
+{
+	char *cmd_line = buffer;;
+
+	if (strncmp("inb", cmd_line, 3) == 0) {
+		unsigned char val = inb(simple_strtol(&cmd_line[4], NULL, 16));
+		printk(" inb(%x) = %x \n", simple_strtol(&cmd_line[4], NULL, 16), val);
+	}
+	else if (strncmp("outb", cmd_line, 4) == 0) {
+		unsigned short addr = simple_strtol(&cmd_line[5], NULL, 16);
+		unsigned char val = simple_strtol(&cmd_line[10], NULL, 16);
+		outb(val, addr);
+		
+		printk(" outb(%x, %x) \n", addr, val);
+	}
+	else if (strncmp("inw", cmd_line, 3) == 0) {
+	}
+	else if (strncmp("outw", cmd_line, 4) == 0) {
+	}
+	else if (strncmp("inl", cmd_line, 3) == 0) {
+	}
+	else if (strncmp("outl", cmd_line, 4) == 0) {
+	}
+	
+	return (strlen(buffer));
+}
+
+/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
+
+int __devinit xgifb_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	u16 reg16;
+	u8  reg, reg1;
+
+	if (XGIfb_off)
+		return -ENXIO;
+
+	XGIfb_registered = 0;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,3))
+	  fb_info = framebuffer_alloc(sizeof(struct fb_info), &pdev->dev);
+	  if(!fb_info) return -ENOMEM;
+#else
+	  XGI_fb_info = kmalloc( sizeof(struct fb_info), GFP_KERNEL);
+	  if(!XGI_fb_info) return -ENOMEM;
+	  memset(XGI_fb_info, 0,  sizeof(struct fb_info));
+#endif
+	
+	/* duzhongkai's code begin */
+
+	  {
+	v3xt_proc_entry = create_proc_entry("v3xt_io", 0, NULL);
+	if (NULL != v3xt_proc_entry) {
+		v3xt_proc_entry->write_proc = &v3xt_proc_write;
+		v3xt_proc_entry->read_proc = &v3xt_proc_read;
+	}
+	  }
+
+	/* duzhongkai's code end */
+	
+  	xgi_video_info.chip_id = pdev->device;
+	  pci_read_config_byte(pdev, PCI_REVISION_ID,&xgi_video_info.revision_id);
+	  pci_read_config_word(pdev, PCI_COMMAND, &reg16);
+	  XGIhw_ext.jChipRevision = xgi_video_info.revision_id;
+	  XGIvga_enabled = reg16 & 0x01;
+	
+	  xgi_video_info.pcibus = pdev->bus->number;
+	  xgi_video_info.pcislot = PCI_SLOT(pdev->devfn);
+	  xgi_video_info.pcifunc = PCI_FUNC(pdev->devfn);
+	  xgi_video_info.subsysvendor = pdev->subsystem_vendor;
+	  xgi_video_info.subsysdevice = pdev->subsystem_device;
+	
+	
+	switch (xgi_video_info.chip_id) {
+
+
+	   case PCI_DEVICE_ID_XG_20:
+		xgi_video_info.chip = XG20;
+		XGIfb_hwcursor_size = HW_CURSOR_AREA_SIZE_315 * 2;
+		XGIfb_CRT2_write_enable = IND_XGI_CRT2_WRITE_ENABLE_315;
+		break;
+	    case PCI_DEVICE_ID_XG_40:
+		xgi_video_info.chip = XG40;
+		XGIfb_hwcursor_size = HW_CURSOR_AREA_SIZE_315 * 2;
+		XGIfb_CRT2_write_enable = IND_XGI_CRT2_WRITE_ENABLE_315;
+		break;
+	    case PCI_DEVICE_ID_XG_41:
+		xgi_video_info.chip = XG41;
+		XGIfb_hwcursor_size = HW_CURSOR_AREA_SIZE_315 * 2;
+		XGIfb_CRT2_write_enable = IND_XGI_CRT2_WRITE_ENABLE_315;
+		break;
+	    case PCI_DEVICE_ID_XG_42:
+		xgi_video_info.chip = XG42;
+		XGIfb_hwcursor_size = HW_CURSOR_AREA_SIZE_315 * 2;
+		XGIfb_CRT2_write_enable = IND_XGI_CRT2_WRITE_ENABLE_315;
+		break;
+	    case PCI_DEVICE_ID_XG_27:
+		xgi_video_info.chip = XG27;
+		XGIfb_hwcursor_size = HW_CURSOR_AREA_SIZE_315 * 2;
+		XGIfb_CRT2_write_enable = IND_XGI_CRT2_WRITE_ENABLE_315;
+		break;
+
+
+           default:
+	        return -ENODEV;
+	}
+//	  printk("XGIfb:chipid = %x\n",xgi_video_info.chip);
+	  XGIhw_ext.jChipType = xgi_video_info.chip;
+	
+	  xgi_video_info.video_base = pci_resource_start(pdev, 0);
+	  xgi_video_info.mmio_base = pci_resource_start(pdev, 1);
+	  XGIhw_ext.pjIOAddress = xgi_video_info.vga_base =
+    XGI_Pr.RelIO  = pci_resource_start(pdev, 2) + 0x30;
+//    XGI_Pr.RelIO  = ioremap(pci_resource_start(pdev, 2), 128) + 0x30;
+    printk("XGIfb: Relocate IO address: %lx [%08x] \n", pci_resource_start(pdev, 2), XGI_Pr.RelIO);
+	  XGIfb_mmio_size =  pci_resource_len(pdev, 1);
+
+//	  if(!XGIvga_enabled) {
+	      printk("XGIfb: Enable PCI device\n");
+	      
+	      if (pci_enable_device(pdev))   
+	          return -EIO;
+//	  }
+
+	
+    XGIRegInit(&XGI_Pr, XGIhw_ext.pjIOAddress);
+	
+    outXGIIDXREG(XGISR, IND_XGI_PASSWORD, XGI_PASSWORD);
+    inXGIIDXREG(XGISR, IND_XGI_PASSWORD, reg1);
+    
+    if(reg1 != 0xa1) /*I/O error */
+    {
+         printk("\nXGIfb: I/O error!!!");
+         return  -EIO;
+    }
+
+//determine XG21 or not
+    if(xgi_video_info.chip == XG20)
+    {
+/*        orXGIIDXREG(XGICR, Index_CR_GPIO_Reg3, GPIOG_EN) ;
+        inXGIIDXREG(XGICR, Index_CR_GPIO_Reg1, reg1) ;
+        if(reg1 & GPIOG_READ)
+        {
+*/
+            xgi_video_info.chip = XG21;
+            XGIhw_ext.jChipType = XG21;
+//        }
+   
+    }
+
+
+	
+		switch (xgi_video_info.chip) {
+		   case XG40:
+		   case XG41:
+		   case XG42:
+		   case XG45:
+		   case XG20:
+		   case XG21:
+                   case XG27:
+                   XGIhw_ext.bIntegratedMMEnabled = TRUE;
+			break;
+
+		   default:
+			break;
+		}
+	
+
+	  XGIhw_ext.pDevice = NULL;
+	  if(XGIfb_userom) 
+	  {
+	      //XGIhw_ext.pjVirtualRomBase = XGI_find_rom();
+	      XGIhw_ext.pjVirtualRomBase = attempt_map_rom(pdev, VBIOS_BUF);
+		  
+	      if(XGIhw_ext.pjVirtualRomBase) 
+	      {
+            printk(KERN_INFO "XGIfb: Video ROM found and mapped to %p\n",XGIhw_ext.pjVirtualRomBase);
+
+	      } else  
+	      {
+
+	          printk(KERN_INFO "XGIfb: Video ROM not found\n");
+	      }
+    } else 
+    {
+	      XGIhw_ext.pjVirtualRomBase = NULL;
+        printk(KERN_INFO "XGIfb: Video ROM usage disabled\n");
+	  }
+	  XGIhw_ext.pjCustomizedROMImage = NULL;
+	  XGIhw_ext.bSkipDramSizing = 0;
+	  XGIhw_ext.pQueryVGAConfigSpace = &XGIfb_query_VGA_config_space;
+//	XGIhw_ext.pQueryNorthBridgeSpace = &XGIfb_query_north_bridge_space;
+	  strcpy(XGIhw_ext.szVBIOSVer, "0.84");
+
+
+    XGIhw_ext.pSR = vmalloc(sizeof(XGI_DSReg) * SR_BUFFER_SIZE);
+	  if (XGIhw_ext.pSR == NULL) 
+	  {
+		    printk(KERN_ERR "XGIfb: Fatal error: Allocating SRReg space failed.\n");
+		    return -ENODEV;
+	  }
+	  XGIhw_ext.pSR[0].jIdx = XGIhw_ext.pSR[0].jVal = 0xFF;
+
+	  XGIhw_ext.pCR = vmalloc(sizeof(XGI_DSReg) * CR_BUFFER_SIZE);
+	  if (XGIhw_ext.pCR == NULL) 
+	  {
+	      vfree(XGIhw_ext.pSR);
+		    printk(KERN_ERR "XGIfb: Fatal error: Allocating CRReg space failed.\n");
+		    return -ENODEV;
+	  }
+	  XGIhw_ext.pCR[0].jIdx = XGIhw_ext.pCR[0].jVal = 0xFF;
+
+
+
+	
+	if (!XGIvga_enabled) 
+	{
+			/* Mapping Max FB Size for 315 Init */
+	    XGIhw_ext.pjVideoMemoryAddress = ioremap(xgi_video_info.video_base, 0x10000000);
+	    if((xgifb_mode_idx < 0) || ((XGIbios_mode[xgifb_mode_idx].mode_no) != 0xFF)) 
+	    { 
+#ifdef LINUXBIOS
+		printk("XGIfb: XGIInit() ...");
+		/* XGIInitNewt for LINUXBIOS only */
+		if(XGIInitNew(&XGIhw_ext))
+		{
+			printk("OK\n");
+		}	
+		else
+		{
+		    printk("Fail\n");
+		}
+#endif
+
+		outXGIIDXREG(XGISR, IND_XGI_PASSWORD, XGI_PASSWORD);
+			
+	
+	    }
+	}
+#ifdef LINUXBIOS
+	else 
+	{
+	    XGIhw_ext.pjVideoMemoryAddress = ioremap(xgi_video_info.video_base, 0x10000000);
+	    if((xgifb_mode_idx < 0) || ((XGIbios_mode[xgifb_mode_idx].mode_no) != 0xFF)) 
+	    { 
+				  
+		outXGIIDXREG(XGISR, IND_XGI_PASSWORD, XGI_PASSWORD);
+		
+		// yilin Because no VBIOS DRAM Sizing, Dram size will error.
+		// Set SR13 ,14 temporarily for UDtech 
+		outXGIIDXREG(XGISR, 0x13, 0x45);
+		outXGIIDXREG(XGISR, 0x14, 0x51);
+            
+
+	    }
+	}
+#endif
+	if (XGIfb_get_dram_size()) 
+	{
+	    vfree(XGIhw_ext.pSR);
+	    vfree(XGIhw_ext.pCR);
+	    printk(KERN_INFO "XGIfb: Fatal error: Unable to determine RAM size.\n");
+	    return -ENODEV;
+	}
+	
+
+
+	  if((xgifb_mode_idx < 0) || ((XGIbios_mode[xgifb_mode_idx].mode_no) != 0xFF)) 
+	  { 
+	       /* Enable PCI_LINEAR_ADDRESSING and MMIO_ENABLE  */
+        orXGIIDXREG(XGISR, IND_XGI_PCI_ADDRESS_SET, (XGI_PCI_ADDR_ENABLE | XGI_MEM_MAP_IO_ENABLE));
+         /* Enable 2D accelerator engine */
+        orXGIIDXREG(XGISR, IND_XGI_MODULE_ENABLE, XGI_ENABLE_2D);
+    }
+
+	  XGIhw_ext.ulVideoMemorySize = xgi_video_info.video_size;
+
+	  if (!request_mem_region(xgi_video_info.video_base, xgi_video_info.video_size, "XGIfb FB")) 
+	  {         printk("unable request memory size %x",xgi_video_info.video_size);
+		    printk(KERN_ERR "XGIfb: Fatal error: Unable to reserve frame buffer memory\n");
+		    printk(KERN_ERR "XGIfb: Is there another framebuffer driver active?\n");
+		    vfree(XGIhw_ext.pSR);
+		    vfree(XGIhw_ext.pCR);
+		    return -ENODEV;
+	  }
+
+	  if (!request_mem_region(xgi_video_info.mmio_base, XGIfb_mmio_size, "XGIfb MMIO")) 
+	  {
+		    printk(KERN_ERR "XGIfb: Fatal error: Unable to reserve MMIO region\n");
+		    release_mem_region(xgi_video_info.video_base, xgi_video_info.video_size);
+		    vfree(XGIhw_ext.pSR);
+		    vfree(XGIhw_ext.pCR);
+		    return -ENODEV;
+	  }
+
+	  xgi_video_info.video_vbase = XGIhw_ext.pjVideoMemoryAddress = 
+		ioremap(xgi_video_info.video_base, xgi_video_info.video_size);
+	  xgi_video_info.mmio_vbase = ioremap(xgi_video_info.mmio_base, XGIfb_mmio_size);
+
+	  printk(KERN_INFO "XGIfb: Framebuffer at 0x%lx, mapped to 0x%p, size %dk\n",
+	      xgi_video_info.video_base, xgi_video_info.video_vbase,xgi_video_info.video_size / 1024);
+
+	  printk(KERN_INFO "XGIfb: MMIO at 0x%lx, mapped to 0x%p, size %ldk\n",
+	      xgi_video_info.mmio_base, xgi_video_info.mmio_vbase,XGIfb_mmio_size / 1024);
+          printk("XGIfb: XGIInitNew() ...");		  
+	  if(XGIInitNew(&XGIhw_ext))
+	  {
+		  printk("OK\n");
+	  }	
+	  else
+	  {
+		printk("Fail\n");
+	  }
+
+	  if(XGIfb_heap_init()) 
+	  {
+		    printk(KERN_WARNING "XGIfb: Failed to initialize offscreen memory heap\n");
+	  }
+
+
+	  xgi_video_info.mtrr = (unsigned int) 0;
+
+	  if((xgifb_mode_idx < 0) || ((XGIbios_mode[xgifb_mode_idx].mode_no) != 0xFF)) 
+	  { 
+	      xgi_video_info.hasVB = HASVB_NONE;            
+        if((xgi_video_info.chip == XG20)||(xgi_video_info.chip == XG21)||(xgi_video_info.chip == XG27))
+{
+
+            xgi_video_info.hasVB = HASVB_NONE;            
+}        else
+		    XGIfb_get_VB_type();
+
+		    XGIhw_ext.ujVBChipID = VB_CHIP_UNKNOWN;
+
+		    XGIhw_ext.ulExternalChip = 0;
+
+		switch (xgi_video_info.hasVB) {
+		case HASVB_301:
+		        inXGIIDXREG(XGIPART4, 0x01, reg);
+			if (reg >= 0xE0) {
+				XGIhw_ext.ujVBChipID = VB_CHIP_302LV;
+				printk(KERN_INFO "XGIfb: XGI302LV bridge detected (revision 0x%02x)\n",reg);
+	  		} else if (reg >= 0xD0) {
+				XGIhw_ext.ujVBChipID = VB_CHIP_301LV;
+				printk(KERN_INFO "XGIfb: XGI301LV bridge detected (revision 0x%02x)\n",reg);
+	  		} 
+			/* else if (reg >= 0xB0) {
+				XGIhw_ext.ujVBChipID = VB_CHIP_301B;
+				inXGIIDXREG(XGIPART4,0x23,reg1);
+			       printk("XGIfb: XGI301B bridge detected\n");	
+			}*/
+			else {
+				XGIhw_ext.ujVBChipID = VB_CHIP_301;
+				printk("XGIfb: XGI301 bridge detected\n");
+			}
+			break;
+		case HASVB_302:
+		        inXGIIDXREG(XGIPART4, 0x01, reg);
+			if (reg >= 0xE0) {
+				XGIhw_ext.ujVBChipID = VB_CHIP_302LV;
+				printk(KERN_INFO "XGIfb: XGI302LV bridge detected (revision 0x%02x)\n",reg);
+	  		} else if (reg >= 0xD0) {
+				XGIhw_ext.ujVBChipID = VB_CHIP_301LV;
+				printk(KERN_INFO "XGIfb: XGI302LV bridge detected (revision 0x%02x)\n",reg);
+	  		} else if (reg >= 0xB0) {
+				inXGIIDXREG(XGIPART4,0x23,reg1);
+
+			        XGIhw_ext.ujVBChipID = VB_CHIP_302B;
+
+			} else {
+			        XGIhw_ext.ujVBChipID = VB_CHIP_302;
+				printk(KERN_INFO "XGIfb: XGI302 bridge detected\n");
+			}
+			break;
+		case HASVB_LVDS:
+			XGIhw_ext.ulExternalChip = 0x1;
+			printk(KERN_INFO "XGIfb: LVDS transmitter detected\n");
+			break;
+/*		case HASVB_TRUMPION:
+			XGIhw_ext.ulExternalChip = 0x2;
+			printk(KERN_INFO "XGIfb: Trumpion Zurac LVDS scaler detected\n");
+			break;
+		case HASVB_CHRONTEL:
+			XGIhw_ext.ulExternalChip = 0x4;
+			printk(KERN_INFO "XGIfb: Chrontel TV encoder detected\n");
+			break;
+		case HASVB_LVDS_CHRONTEL:
+			XGIhw_ext.ulExternalChip = 0x5;
+			printk(KERN_INFO "XGIfb: LVDS transmitter and Chrontel TV encoder detected\n");
+			break;
+*/
+ 		default:
+			printk(KERN_INFO "XGIfb: No or unknown bridge type detected\n");
+			break;
+		}
+
+		if (xgi_video_info.hasVB != HASVB_NONE) {
+		    XGIfb_detect_VB();
+    }
+
+		if (xgi_video_info.disp_state & DISPTYPE_DISP2) {
+			if (XGIfb_crt1off)
+				xgi_video_info.disp_state |= DISPMODE_SINGLE;
+			else
+				xgi_video_info.disp_state |= (DISPMODE_MIRROR | DISPTYPE_CRT1);
+		} else {
+			xgi_video_info.disp_state = DISPMODE_SINGLE | DISPTYPE_CRT1;
+		}
+
+		if (xgi_video_info.disp_state & DISPTYPE_LCD) {
+		    if (!enable_dstn) {
+		        inXGIIDXREG(XGICR, IND_XGI_LCD_PANEL, reg);
+			    reg &= 0x0f;
+			    XGIhw_ext.ulCRT2LCDType = XGI310paneltype[reg];
+			
+		    } else {
+		        // TW: FSTN/DSTN 
+			XGIhw_ext.ulCRT2LCDType = LCD_320x480;
+		    }
+		}
+		
+		XGIfb_detectedpdc = 0;
+
+	        XGIfb_detectedlcda = 0xff;
+#ifndef LINUXBIOS
+
+                /* TW: Try to find about LCDA */
+		
+        if((XGIhw_ext.ujVBChipID == VB_CHIP_302B) ||
+	       (XGIhw_ext.ujVBChipID == VB_CHIP_301LV) ||
+	       (XGIhw_ext.ujVBChipID == VB_CHIP_302LV)) 
+	    {
+	       int tmp;
+	       inXGIIDXREG(XGICR,0x34,tmp);
+	       if(tmp <= 0x13) 
+	       {	
+	          // Currently on LCDA? (Some BIOSes leave CR38) 
+	          inXGIIDXREG(XGICR,0x38,tmp);
+		      if((tmp & 0x03) == 0x03) 
+		      {
+//		          XGI_Pr.XGI_UseLCDA = TRUE;
+		      }else
+		      {
+		     //  Currently on LCDA? (Some newer BIOSes set D0 in CR35) 
+		         inXGIIDXREG(XGICR,0x35,tmp);
+		         if(tmp & 0x01) 
+		         {
+//		              XGI_Pr.XGI_UseLCDA = TRUE;
+		           }else
+		           {
+		               inXGIIDXREG(XGICR,0x30,tmp);
+		               if(tmp & 0x20) 
+		               {
+		                   inXGIIDXREG(XGIPART1,0x13,tmp);
+			               if(tmp & 0x04) 
+			               {
+//			                XGI_Pr.XGI_UseLCDA = TRUE;
+			               }
+		               }
+		           }
+		        }
+	         } 
+
+        }
+		
+
+#endif
+
+		if (xgifb_mode_idx >= 0)
+			xgifb_mode_idx = XGIfb_validate_mode(xgifb_mode_idx);
+
+		if (xgifb_mode_idx < 0) {
+			switch (xgi_video_info.disp_state & DISPTYPE_DISP2) {
+			   case DISPTYPE_LCD:
+				xgifb_mode_idx = DEFAULT_LCDMODE;
+				break;
+			   case DISPTYPE_TV:
+				xgifb_mode_idx = DEFAULT_TVMODE;
+				break;
+			   default:
+				xgifb_mode_idx = DEFAULT_MODE;
+				break;
+			}
+		}
+
+		XGIfb_mode_no = XGIbios_mode[xgifb_mode_idx].mode_no;
+
+
+                if( xgi_video_info.refresh_rate == 0)
+		    xgi_video_info.refresh_rate = 60; /*yilin set default refresh rate */
+	        if(XGIfb_search_refresh_rate(xgi_video_info.refresh_rate) == 0)
+                {
+		    XGIfb_rate_idx = XGIbios_mode[xgifb_mode_idx].rate_idx;
+		    xgi_video_info.refresh_rate = 60;
+	        }
+
+		xgi_video_info.video_bpp = XGIbios_mode[xgifb_mode_idx].bpp;
+		xgi_video_info.video_vwidth = xgi_video_info.video_width = XGIbios_mode[xgifb_mode_idx].xres;
+		xgi_video_info.video_vheight = xgi_video_info.video_height = XGIbios_mode[xgifb_mode_idx].yres;
+		xgi_video_info.org_x = xgi_video_info.org_y = 0;
+		xgi_video_info.video_linelength = xgi_video_info.video_width * (xgi_video_info.video_bpp >> 3);
+		switch(xgi_video_info.video_bpp) {
+        	case 8:
+            		xgi_video_info.DstColor = 0x0000;
+	    		xgi_video_info.XGI310_AccelDepth = 0x00000000;
+			xgi_video_info.video_cmap_len = 256;
+            		break;
+        	case 16:
+            		xgi_video_info.DstColor = 0x8000;
+            		xgi_video_info.XGI310_AccelDepth = 0x00010000;
+			xgi_video_info.video_cmap_len = 16;
+            		break;
+        	case 32:
+            		xgi_video_info.DstColor = 0xC000;
+	    		xgi_video_info.XGI310_AccelDepth = 0x00020000;
+			xgi_video_info.video_cmap_len = 16;
+            		break;
+		default:
+			xgi_video_info.video_cmap_len = 16;
+		        printk(KERN_INFO "XGIfb: Unsupported depth %d", xgi_video_info.video_bpp);
+			break;
+    		}
+		
+
+
+		printk(KERN_INFO "XGIfb: Default mode is %dx%dx%d (%dHz)\n",
+	       		xgi_video_info.video_width, xgi_video_info.video_height, xgi_video_info.video_bpp,
+			xgi_video_info.refresh_rate);
+			
+		default_var.xres = default_var.xres_virtual = xgi_video_info.video_width;
+		default_var.yres = default_var.yres_virtual = xgi_video_info.video_height;
+		default_var.bits_per_pixel = xgi_video_info.video_bpp;
+		
+		XGIfb_bpp_to_var(&default_var);
+		
+		default_var.pixclock = (u32) (1000000000 /
+				XGIfb_mode_rate_to_dclock(&XGI_Pr, &XGIhw_ext,
+						XGIfb_mode_no, XGIfb_rate_idx));
+
+		if(XGIfb_mode_rate_to_ddata(&XGI_Pr, &XGIhw_ext,
+			 XGIfb_mode_no, XGIfb_rate_idx,
+			 &default_var.left_margin, &default_var.right_margin, 
+			 &default_var.upper_margin, &default_var.lower_margin,
+			 &default_var.hsync_len, &default_var.vsync_len,
+			 &default_var.sync, &default_var.vmode)) {
+
+		   if((default_var.vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {
+		      default_var.yres <<= 1;
+		      default_var.yres_virtual <<= 1;
+		   } else if((default_var.vmode	& FB_VMODE_MASK) == FB_VMODE_DOUBLE) {
+		      default_var.pixclock >>= 1;
+		      default_var.yres >>= 1;
+		      default_var.yres_virtual >>= 1;
+		   }
+		   
+	        }
+
+
+#if 0
+#ifdef XGIFB_PAN
+		if(XGIfb_ypan) {
+	    		default_var.yres_virtual = 
+				xgi_video_info.heapstart / (default_var.xres * (default_var.bits_per_pixel >> 3));
+	    		if(default_var.yres_virtual <= default_var.yres) {
+	        		default_var.yres_virtual = default_var.yres;
+	    		}
+		} 
+#endif
+#endif		
+
+
+		xgi_video_info.accel = 0;
+		if(XGIfb_accel) {
+		   xgi_video_info.accel = -1;
+		   default_var.accel_flags |= FB_ACCELF_TEXT;
+		   XGIfb_initaccel();
+		}
+
+		fb_info->flags = FBINFO_FLAG_DEFAULT;
+		fb_info->var = default_var;
+		fb_info->fix = XGIfb_fix;
+		fb_info->par = &xgi_video_info;
+		fb_info->screen_base = xgi_video_info.video_vbase;
+		fb_info->fbops = &XGIfb_ops;
+		XGIfb_get_fix(&fb_info->fix, -1, fb_info);
+		fb_info->pseudo_palette = pseudo_palette;
+		
+		fb_alloc_cmap(&fb_info->cmap, 256 , 0);
+
+
+#ifdef CONFIG_MTRR
+		xgi_video_info.mtrr = mtrr_add((unsigned int) xgi_video_info.video_base,
+				(unsigned int) xgi_video_info.video_size,
+				MTRR_TYPE_WRCOMB, 1);
+		if(xgi_video_info.mtrr) {
+			printk(KERN_INFO "XGIfb: Added MTRRs\n");
+		}
+#endif
+
+		if(register_framebuffer(fb_info) < 0)
+    {
+			return -EINVAL;
+    }
+			
+		XGIfb_registered = 1;			
+
+		printk(KERN_INFO "XGIfb: Installed XGIFB_GET_INFO ioctl (%x)\n", XGIFB_GET_INFO);
+		
+/*		printk(KERN_INFO "XGIfb: 2D acceleration is %s, scrolling mode %s\n",
+		     XGIfb_accel ? "enabled" : "disabled",
+		     XGIfb_ypan  ? "ypan" : "redraw");
+*/
+		printk(KERN_INFO "fb%d: %s frame buffer device, Version %d.%d.%02d\n",
+	       		fb_info->node, myid, VER_MAJOR, VER_MINOR, VER_LEVEL);			     
+
+
+	}
+
+//	dumpVGAReg();
+
+	return 0;
+}
+
+
+/*****************************************************/
+/*                PCI DEVICE HANDLING                */
+/*****************************************************/
+
+static void __devexit xgifb_remove(struct pci_dev *pdev)
+{
+	/* Unregister the framebuffer */
+//	if(xgi_video_info.registered) {
+		unregister_framebuffer(fb_info);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,3))
+		framebuffer_release(fb_info);
+#else
+		kfree(fb_info);
+#endif
+//	}
+
+	pci_set_drvdata(pdev, NULL);
+
+};
+
+static struct pci_driver xgifb_driver = {
+	.name		= "xgifb",
+	.id_table 	= xgifb_pci_table,
+	.probe 		= xgifb_probe,
+	.remove 	= __devexit_p(xgifb_remove)
+};
+
+XGIINITSTATIC int __init xgifb_init(void)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+#ifndef MODULE
+	char *option = NULL;
+
+	if (fb_get_options("Xgifb", &option))
+		return -ENODEV;
+	XGIfb_setup(option);
+#endif
+#endif
+	return(pci_register_driver(&xgifb_driver));
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+#ifndef MODULE
+module_init(xgifb_init);
+#endif
+#endif
+
+/*****************************************************/
+/*                      MODULE                       */
+/*****************************************************/
+
+#ifdef MODULE
+
+static char         *mode = NULL;
+static int          vesa = 0;
+static unsigned int rate = 0;
+static unsigned int crt1off = 1;
+static unsigned int mem = 0;
+static char         *forcecrt2type = NULL;
+static int          forcecrt1 = -1;
+static int          pdc = -1;
+static int          pdc1 = -1;
+static int          noaccel = -1;
+static int          noypan  = -1;
+static int	    nomax = -1;
+static int          userom = 1;
+static int          useoem = -1;
+static char         *tvstandard = NULL;
+static int	    nocrt2rate = 0;
+static int          scalelcd = -1;
+static char	    *specialtiming = NULL;
+static int	    lvdshl = -1;
+static int	    tvxposoffset = 0, tvyposoffset = 0;
+#if !defined(__i386__) && !defined(__x86_64__)
+static int	    resetcard = 0;
+static int	    videoram = 0;
+#endif
+
+MODULE_DESCRIPTION("Z7 Z9 Z9S Z11 framebuffer device driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("XGITECH , Others");
+
+
+
+module_param(mem, int, 0);
+module_param(noaccel, int, 0);
+module_param(noypan, int, 0);
+module_param(nomax, int, 0);
+module_param(userom, int, 0);
+module_param(useoem, int, 0);
+module_param(mode, charp, 0);
+module_param(vesa, int, 0);
+module_param(rate, int, 0);
+module_param(forcecrt1, int, 0);
+module_param(forcecrt2type, charp, 0);
+module_param(scalelcd, int, 0);
+module_param(pdc, int, 0);
+module_param(pdc1, int, 0);
+module_param(specialtiming, charp, 0);
+module_param(lvdshl, int, 0);
+module_param(tvstandard, charp, 0);
+module_param(tvxposoffset, int, 0);
+module_param(tvyposoffset, int, 0);
+module_param(filter, int, 0);
+module_param(nocrt2rate, int, 0);
+#if !defined(__i386__) && !defined(__x86_64__)
+module_param(resetcard, int, 0);
+module_param(videoram, int, 0);
+#endif
+
+
+MODULE_PARM_DESC(mem,
+	"\nDetermines the beginning of the video memory heap in KB. This heap is used\n"
+	  "for video RAM management for eg. DRM/DRI. On 300 series, the default depends\n"
+	  "on the amount of video RAM available. If 8MB of video RAM or less is available,\n"
+	  "the heap starts at 4096KB, if between 8 and 16MB are available at 8192KB,\n"
+	  "otherwise at 12288KB. On 315 and Xabre series, the heap size is 32KB by default.\n"
+	  "The value is to be specified without 'KB' and must match the MaxXFBMem setting\n"
+	  "for XFree86 4.x/X.org 6.7 and later.\n");
+
+MODULE_PARM_DESC(noaccel,
+        "\nIf set to anything other than 0, 2D acceleration will be disabled.\n"
+	  "(default: 0)\n");
+
+MODULE_PARM_DESC(noypan,
+        "\nIf set to anything other than 0, y-panning will be disabled and scrolling\n"
+ 	  "will be performed by redrawing the screen. (default: 0)\n");
+
+MODULE_PARM_DESC(nomax,
+        "\nIf y-panning is enabled, xgifb will by default use the entire available video\n"
+	  "memory for the virtual screen in order to optimize scrolling performance. If\n"
+	  "this is set to anything other than 0, xgifb will not do this and thereby \n"
+	  "enable the user to positively specify a virtual Y size of the screen using\n"
+	  "fbset. (default: 0)\n");
+
+
+
+MODULE_PARM_DESC(mode,
+       "\nSelects the desired default display mode in the format XxYxDepth,\n"
+         "eg. 1024x768x16. Other formats supported include XxY-Depth and\n"
+	 "XxY-Depth@Rate. If the parameter is only one (decimal or hexadecimal)\n"
+	 "number, it will be interpreted as a VESA mode number. (default: 800x600x8)\n");
+
+MODULE_PARM_DESC(vesa,
+       "\nSelects the desired default display mode by VESA defined mode number, eg.\n"
+         "0x117 (default: 0x0103)\n");
+
+
+MODULE_PARM_DESC(rate,
+	"\nSelects the desired vertical refresh rate for CRT1 (external VGA) in Hz.\n"
+	  "If the mode is specified in the format XxY-Depth@Rate, this parameter\n"
+	  "will be ignored (default: 60)\n");
+
+MODULE_PARM_DESC(forcecrt1,
+	"\nNormally, the driver autodetects whether or not CRT1 (external VGA) is \n"
+	  "connected. With this option, the detection can be overridden (1=CRT1 ON,\n"
+	  "0=CRT1 OFF) (default: [autodetected])\n");
+
+MODULE_PARM_DESC(forcecrt2type,
+	"\nIf this option is omitted, the driver autodetects CRT2 output devices, such as\n"
+	  "LCD, TV or secondary VGA. With this option, this autodetection can be\n"
+	  "overridden. Possible parameters are LCD, TV, VGA or NONE. NONE disables CRT2.\n"
+	  "On systems with a SiS video bridge, parameters SVIDEO, COMPOSITE or SCART can\n"
+	  "be used instead of TV to override the TV detection. Furthermore, on systems\n"
+	  "with a SiS video bridge, SVIDEO+COMPOSITE, HIVISION, YPBPR480I, YPBPR480P,\n"
+	  "YPBPR720P and YPBPR1080I are understood. However, whether or not these work\n"
+	  "depends on the very hardware in use. (default: [autodetected])\n");
+
+MODULE_PARM_DESC(scalelcd,
+	"\nSetting this to 1 will force the driver to scale the LCD image to the panel's\n"
+	  "native resolution. Setting it to 0 will disable scaling; LVDS panels will\n"
+	  "show black bars around the image, TMDS panels will probably do the scaling\n"
+	  "themselves. Default: 1 on LVDS panels, 0 on TMDS panels\n");
+
+MODULE_PARM_DESC(pdc,
+        "\nThis is for manually selecting the LCD panel delay compensation. The driver\n"
+	  "should detect this correctly in most cases; however, sometimes this is not\n"
+	  "possible. If you see 'small waves' on the LCD, try setting this to 4, 32 or 24\n"
+	  "on a 300 series chipset; 6 on a 315 series chipset. If the problem persists,\n"
+	  "try other values (on 300 series: between 4 and 60 in steps of 4; on 315 series:\n"
+	  "any value from 0 to 31). (default: autodetected, if LCD is active during start)\n");
+
+MODULE_PARM_DESC(pdc1,
+        "\nThis is same as pdc, but for LCD-via CRT1. Hence, this is for the 315/330\n"
+	  "series only. (default: autodetected if LCD is in LCD-via-CRT1 mode during\n"
+	  "startup) - Note: currently, this has no effect because LCD-via-CRT1 is not\n"
+	  "implemented yet.\n");
+
+MODULE_PARM_DESC(specialtiming,
+	"\nPlease refer to documentation for more information on this option.\n");
+
+MODULE_PARM_DESC(lvdshl,
+	"\nPlease refer to documentation for more information on this option.\n");
+
+MODULE_PARM_DESC(tvstandard,
+	"\nThis allows overriding the BIOS default for the TV standard. Valid choices are\n"
+	  "pal, ntsc, palm and paln. (default: [auto; pal or ntsc only])\n");
+
+MODULE_PARM_DESC(tvxposoffset,
+	"\nRelocate TV output horizontally. Possible parameters: -32 through 32.\n"
+	  "Default: 0\n");
+
+MODULE_PARM_DESC(tvyposoffset,
+	"\nRelocate TV output vertically. Possible parameters: -32 through 32.\n"
+	  "Default: 0\n");
+
+MODULE_PARM_DESC(filter,
+	"\nSelects TV flicker filter type (only for systems with a SiS301 video bridge).\n"
+	  "(Possible values 0-7, default: [no filter])\n");
+
+MODULE_PARM_DESC(nocrt2rate,
+	"\nSetting this to 1 will force the driver to use the default refresh rate for\n"
+	  "CRT2 if CRT2 type is VGA. (default: 0, use same rate as CRT1)\n");
+
+
+
+
+int __init xgifb_init_module(void)
+{
+        printk("\nXGIfb_init_module");
+	if(mode)
+		XGIfb_search_mode(mode);
+	else if (vesa != -1)
+		XGIfb_search_vesamode(vesa);
+
+        return(xgifb_init());
+}
+
+static void __exit xgifb_remove_module(void)
+{
+	pci_unregister_driver(&xgifb_driver);
+	printk(KERN_DEBUG "xgifb: Module unloaded\n");
+}
+
+module_init(xgifb_init_module);
+module_exit(xgifb_remove_module);
+
+#endif 	   /*  /MODULE  */
+
+EXPORT_SYMBOL(XGI_malloc);
+EXPORT_SYMBOL(XGI_free);
+                                                      
diff --git a/drivers/video/xgi/XGIfb.h b/drivers/video/xgi/XGIfb.h
new file mode 100644
index 0000000..74f7269
--- /dev/null
+++ b/drivers/video/xgi/XGIfb.h
@@ -0,0 +1,215 @@
+#ifndef _LINUX_XGIFB
+#define _LINUX_XGIFB
+#include <linux/spinlock.h>
+#include <asm/ioctl.h>
+#include <asm/types.h>
+
+#define DISPTYPE_CRT1       0x00000008L
+#define DISPTYPE_CRT2       0x00000004L
+#define DISPTYPE_LCD        0x00000002L
+#define DISPTYPE_TV         0x00000001L
+#define DISPTYPE_DISP1      DISPTYPE_CRT1
+#define DISPTYPE_DISP2      (DISPTYPE_CRT2 | DISPTYPE_LCD | DISPTYPE_TV)
+#define DISPMODE_SINGLE	    0x00000020L
+#define DISPMODE_MIRROR	    0x00000010L
+#define DISPMODE_DUALVIEW   0x00000040L
+
+#define HASVB_NONE      	0x00
+#define HASVB_301       	0x01
+#define HASVB_LVDS      	0x02
+#define HASVB_TRUMPION  	0x04
+#define HASVB_LVDS_CHRONTEL	0x10
+#define HASVB_302       	0x20
+#define HASVB_303       	0x40
+#define HASVB_CHRONTEL  	0x80
+
+#ifndef XGIFB_ID
+#define XGIFB_ID          0x53495346    /* Identify myself with 'XGIF' */
+#endif
+
+typedef enum _XGI_CHIP_TYPE {
+    XGI_VGALegacy = 0,
+    XGI_300,
+    XGI_630,
+    XGI_730,
+    XGI_540,
+    XGI_315H,   
+    XGI_315,
+    XGI_315PRO, 
+    XGI_550,
+    XGI_640,
+    XGI_740,
+    XGI_650,
+    XGI_650M,
+    XGI_330 = 16,
+    XGI_660,
+    XGI_661,
+    XGI_760,
+    XG40 = 32,
+    XG41,
+    XG42,
+    XG45,
+    XG20 = 48,
+    XG21,
+    XG27,
+    MAX_XGI_CHIP
+} XGI_CHIP_TYPE;
+
+typedef enum _TVTYPE {
+	TVMODE_NTSC = 0,
+	TVMODE_PAL,
+	TVMODE_HIVISION,
+	TVTYPE_PALM,	// vicki@030226
+    	TVTYPE_PALN,	// vicki@030226
+    	TVTYPE_NTSCJ,	// vicki@030226	
+	TVMODE_TOTAL
+} XGI_TV_TYPE;
+
+
+typedef struct _XGIFB_INFO XGIfb_info;
+struct _XGIFB_INFO {
+
+unsigned long XGIfb_id;         
+ 	int    chip_id;			/* PCI ID of detected chip */
+	int    memory;			/* video memory in KB which XGIfb manages */
+	int    heapstart;               /* heap start (= XGIfb "mem" argument) in KB */
+	unsigned char fbvidmode;	/* current XGIfb mode */
+	
+	unsigned char XGIfb_version;
+	unsigned char XGIfb_revision;
+	unsigned char XGIfb_patchlevel;
+
+	unsigned char XGIfb_caps;	/* XGIfb capabilities */
+
+	int    XGIfb_tqlen;		/* turbo queue length (in KB) */
+
+	unsigned int XGIfb_pcibus;      /* The card's PCI ID */
+	unsigned int XGIfb_pcislot;
+	unsigned int XGIfb_pcifunc;
+
+	unsigned char XGIfb_lcdpdc;	/* PanelDelayCompensation */
+	
+	unsigned char XGIfb_lcda;	/* Detected status of LCDA for low res/text modes */
+
+	char reserved[235]; 		/* for future use */
+};
+
+
+
+
+typedef enum _TVPLUGTYPE {	// vicki@030226
+//	TVPLUG_Legacy = 0,
+//	TVPLUG_COMPOSITE,
+//	TVPLUG_SVIDEO,
+//	TVPLUG_SCART,
+//	TVPLUG_TOTAL
+    	TVPLUG_UNKNOWN = 0,
+    	TVPLUG_COMPOSITE = 1,
+    	TVPLUG_SVIDEO = 2,
+    	TVPLUG_COMPOSITE_AND_SVIDEO = 3,
+    	TVPLUG_SCART = 4,
+    	TVPLUG_YPBPR_525i = 5,
+    	TVPLUG_YPBPR_525P = 6,
+    	TVPLUG_YPBPR_750P = 7,
+    	TVPLUG_YPBPR_1080i = 8,
+	TVPLUG_TOTAL
+} XGI_TV_PLUG;
+
+
+struct mode_info {
+	int    bpp;
+	int    xres;
+	int    yres;
+	int    v_xres;
+	int    v_yres;
+	int    org_x;
+	int    org_y;
+	unsigned int  vrate;
+};
+
+struct ap_data {
+	struct mode_info minfo;
+	unsigned long iobase;
+	unsigned int  mem_size;
+	unsigned long disp_state;    	
+	XGI_CHIP_TYPE chip;
+	unsigned char hasVB;
+	XGI_TV_TYPE TV_type;
+	XGI_TV_PLUG TV_plug;
+	unsigned long version;
+	char reserved[256];
+};
+
+
+
+/*     If changing this, vgatypes.h must also be changed (for X driver)    */
+
+
+/*
+ * NOTE! The ioctl types used to be "size_t" by mistake, but were
+ * really meant to be __u32. Changed to "__u32" even though that
+ * changes the value on 64-bit architectures, because the value
+ * (with a 4-byte size) is also hardwired in vgatypes.h for user
+ * space exports. So "__u32" is actually more compatible, duh!
+ */
+#define XGIFB_GET_INFO	  	_IOR('n',0xF8,__u32)
+#define XGIFB_GET_VBRSTATUS  	_IOR('n',0xF9,__u32)
+
+
+
+struct video_info{
+        int           chip_id;
+        unsigned int  video_size;
+        unsigned long video_base;
+        char  *       video_vbase;
+        unsigned long mmio_base;
+        char  *       mmio_vbase;
+        unsigned long vga_base;
+        unsigned long mtrr;
+        unsigned long heapstart;
+                                                                                
+        int    video_bpp;
+        int    video_cmap_len;
+        int    video_width;
+        int    video_height;
+        int    video_vwidth;
+        int    video_vheight;
+        int    org_x;
+        int    org_y;
+        int    video_linelength;
+        unsigned int refresh_rate;
+                                                                                
+        unsigned long disp_state;
+        unsigned char hasVB;
+        unsigned char TV_type;
+        unsigned char TV_plug;
+                                                                                
+        XGI_CHIP_TYPE chip;
+        unsigned char revision_id;
+                                                                                
+        unsigned short DstColor;             
+        unsigned long  XGI310_AccelDepth;
+        unsigned long  CommandReg;
+                                                                                
+        spinlock_t     lockaccel;
+                                                                                
+        unsigned int   pcibus;
+        unsigned int   pcislot;
+        unsigned int   pcifunc;
+                                                                                
+        int            accel;
+        unsigned short subsysvendor;
+        unsigned short subsysdevice;
+                                                                                
+        char reserved[236];
+};
+
+
+extern struct video_info xgi_video_info;
+                                                                                
+#ifdef __KERNEL__
+//extern void xgi_malloc(struct xgi_memreq *req);
+extern void xgi_free(unsigned long base);
+extern void xgi_dispinfo(struct ap_data *rec);
+#endif
+#endif
diff --git a/drivers/video/xgi/floatlib.c b/drivers/video/xgi/floatlib.c
new file mode 100644
index 0000000..2a4446b
--- /dev/null
+++ b/drivers/video/xgi/floatlib.c
@@ -0,0 +1,946 @@
+/*
+** libgcc support for software floating point.
+** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
+** Permission is granted to do *anything* you want with this file,
+** commercial or otherwise, provided this message remains intact.  So there!
+** I would appreciate receiving any updates/patches/changes that anyone
+** makes, and am willing to be the repository for said changes (am I
+** making a big mistake?).
+
+Warning! Only single-precision is actually implemented.  This file
+won't really be much use until double-precision is supported.
+
+However, once that is done, this file might eventually become a
+replacement for libgcc1.c.  It might also make possible
+cross-compilation for an IEEE target machine from a non-IEEE
+host such as a VAX.
+
+If you'd like to work on completing this, please talk to rms@gnu.ai.mit.edu.
+
+--> Double precision floating support added by James Carlson on 20 April 1998.
+
+**
+** Pat Wood
+** Pipeline Associates, Inc.
+** pipeline!phw@motown.com or
+** sun!pipeline!phw or
+** uunet!motown!pipeline!phw
+**
+** 05/01/91 -- V1.0 -- first release to gcc mailing lists
+** 05/04/91 -- V1.1 -- added float and double prototypes and return values
+**                  -- fixed problems with adding and subtracting zero
+**                  -- fixed rounding in truncdfsf2
+**                  -- fixed SWAP define and tested on 386
+*/
+
+/*
+** The following are routines that replace the libgcc soft floating point
+** routines that are called automatically when -msoft-float is selected.
+** The support single and double precision IEEE format, with provisions
+** for byte-swapped machines (tested on 386).  Some of the double-precision
+** routines work at full precision, but most of the hard ones simply punt
+** and call the single precision routines, producing a loss of accuracy.
+** long long support is not assumed or included.
+** Overall accuracy is close to IEEE (actually 68882) for single-precision
+** arithmetic.  I think there may still be a 1 in 1000 chance of a bit
+** being rounded the wrong way during a multiply.  I'm not fussy enough to
+** bother with it, but if anyone is, knock yourself out.
+**
+** Efficiency has only been addressed where it was obvious that something
+** would make a big difference.  Anyone who wants to do this right for
+** best speed should go in and rewrite in assembler.
+**
+** I have tested this only on a 68030 workstation and 386/ix integrated
+** in with -msoft-float.
+*/
+
+/* the following deal with IEEE single-precision numbers */
+#define EXCESS		126
+#define SIGNBIT		0x80000000
+#define HIDDEN		(1 << 23)
+#define SIGN(fp)	((fp) & SIGNBIT)
+#define EXP(fp)		(((fp) >> 23) & 0xFF)
+#define MANT(fp)	(((fp) & 0x7FFFFF) | HIDDEN)
+#define PACK(s,e,m)	((s) | ((e) << 23) | (m))
+
+/* the following deal with IEEE double-precision numbers */
+#define EXCESSD		1022
+#define HIDDEND		(1 << 20)
+#define EXPD(fp)	(((fp.l.upper) >> 20) & 0x7FF)
+#define SIGND(fp)	((fp.l.upper) & SIGNBIT)
+#define MANTD(fp)	(((((fp.l.upper) & 0xFFFFF) | HIDDEND) << 10) | \
+				(fp.l.lower >> 22))
+#define HIDDEND_LL	((long long)1 << 52)
+#define MANTD_LL(fp)	((fp.ll & (HIDDEND_LL-1)) | HIDDEND_LL)
+#define PACKD_LL(s,e,m)	(((long long)((s)+((e)<<20))<<32)|(m))
+
+/* define SWAP for 386/960 reverse-byte-order brain-damaged CPUs */
+union double_long {
+    double d;
+#ifdef SWAP
+    struct {
+      unsigned long lower;
+      long upper;
+    } l;
+#else
+    struct {
+      long upper;
+      unsigned long lower;
+    } l;
+#endif
+    long long ll;
+};
+
+union float_long
+  {
+    float f;
+    long l;
+  };
+
+/* add two floats */
+float
+__addsf3 (float a1, float a2)
+{
+  register long mant1, mant2;
+  register union float_long fl1, fl2;
+  register int exp1, exp2;
+  int sign = 0;
+
+  fl1.f = a1;
+  fl2.f = a2;
+
+  /* check for zero args */
+  if (!fl1.l) {
+      fl1.f = fl2.f;
+      goto test_done;
+  }
+  if (!fl2.l)
+      goto test_done;
+
+  exp1 = EXP (fl1.l);
+  exp2 = EXP (fl2.l);
+
+  if (exp1 > exp2 + 25)
+      goto test_done;
+  if (exp2 > exp1 + 25) {
+      fl1.f = fl2.f;
+      goto test_done;
+  }
+
+  /* do everything in excess precision so's we can round later */
+  mant1 = MANT (fl1.l) << 6;
+  mant2 = MANT (fl2.l) << 6;
+
+  if (SIGN (fl1.l))
+    mant1 = -mant1;
+  if (SIGN (fl2.l))
+    mant2 = -mant2;
+
+  if (exp1 > exp2)
+    {
+      mant2 >>= exp1 - exp2;
+    }
+  else
+    {
+      mant1 >>= exp2 - exp1;
+      exp1 = exp2;
+    }
+  mant1 += mant2;
+
+  if (mant1 < 0)
+    {
+      mant1 = -mant1;
+      sign = SIGNBIT;
+    }
+  else if (!mant1) {
+      fl1.f = 0;
+      goto test_done;
+  }
+
+  /* normalize up */
+  while (!(mant1 & 0xE0000000))
+    {
+      mant1 <<= 1;
+      exp1--;
+    }
+
+  /* normalize down? */
+  if (mant1 & (1 << 30))
+    {
+      mant1 >>= 1;
+      exp1++;
+    }
+
+  /* round to even */
+  mant1 += (mant1 & 0x40) ? 0x20 : 0x1F;
+
+  /* normalize down? */
+  if (mant1 & (1 << 30))
+    {
+      mant1 >>= 1;
+      exp1++;
+    }
+
+  /* lose extra precision */
+  mant1 >>= 6;
+
+  /* turn off hidden bit */
+  mant1 &= ~HIDDEN;
+
+  /* pack up and go home */
+  fl1.l = PACK (sign, exp1, mant1);
+test_done:
+  return (fl1.f);
+}
+
+/* subtract two floats */
+float
+__subsf3 (float a1, float a2)
+{
+  register union float_long fl1, fl2;
+
+  fl1.f = a1;
+  fl2.f = a2;
+
+  /* check for zero args */
+  if (!fl2.l)
+    return (fl1.f);
+  if (!fl1.l)
+    return (-fl2.f);
+
+  /* twiddle sign bit and add */
+  fl2.l ^= SIGNBIT;
+  return __addsf3 (a1, fl2.f);
+}
+
+/* compare two floats */
+long
+__cmpsf2 (float a1, float a2)
+{
+  register union float_long fl1, fl2;
+
+  fl1.f = a1;
+  fl2.f = a2;
+
+  if (SIGN (fl1.l) && SIGN (fl2.l))
+    {
+      fl1.l ^= SIGNBIT;
+      fl2.l ^= SIGNBIT;
+    }
+  if (fl1.l < fl2.l)
+    return (-1);
+  if (fl1.l > fl2.l)
+    return (1);
+  return (0);
+}
+
+/* multiply two floats */
+float
+__mulsf3 (float a1, float a2)
+{
+  register union float_long fl1, fl2;
+  register unsigned long result;
+  register int exp;
+  int sign;
+
+  fl1.f = a1;
+  fl2.f = a2;
+
+  if (!fl1.l || !fl2.l) {
+      fl1.f = 0;
+      goto test_done;
+  }
+
+  /* compute sign and exponent */
+  sign = SIGN (fl1.l) ^ SIGN (fl2.l);
+  exp = EXP (fl1.l) - EXCESS;
+  exp += EXP (fl2.l);
+
+  fl1.l = MANT (fl1.l);
+  fl2.l = MANT (fl2.l);
+
+  /* the multiply is done as one 16x16 multiply and two 16x8 multiples */
+  result = (fl1.l >> 8) * (fl2.l >> 8);
+  result += ((fl1.l & 0xFF) * (fl2.l >> 8)) >> 8;
+  result += ((fl2.l & 0xFF) * (fl1.l >> 8)) >> 8;
+
+  result >>= 2;
+  if (result & 0x20000000)
+    {
+      /* round */
+      result += 0x20;
+      result >>= 6;
+    }
+  else
+    {
+      /* round */
+      result += 0x10;
+      result >>= 5;
+      exp--;
+    }
+  if (result & (HIDDEN<<1)) {
+    result >>= 1;
+    exp++;
+  }
+
+  result &= ~HIDDEN;
+
+  /* pack up and go home */
+  fl1.l = PACK (sign, exp, result);
+test_done:
+  return (fl1.f);
+}
+
+/* divide two floats */
+float
+__divsf3 (float a1, float a2)
+{
+  register union float_long fl1, fl2;
+  register int result;
+  register int mask;
+  register int exp, sign;
+
+  fl1.f = a1;
+  fl2.f = a2;
+
+  /* subtract exponents */
+  exp = EXP (fl1.l) - EXP (fl2.l) + EXCESS;
+
+  /* compute sign */
+  sign = SIGN (fl1.l) ^ SIGN (fl2.l);
+
+  /* divide by zero??? */
+  if (!fl2.l)
+    /* return NaN or -NaN */
+    return (sign ? 0xFFFFFFFF : 0x7FFFFFFF);
+
+  /* numerator zero??? */
+  if (!fl1.l)
+    return (0);
+
+  /* now get mantissas */
+  fl1.l = MANT (fl1.l);
+  fl2.l = MANT (fl2.l);
+
+  /* this assures we have 25 bits of precision in the end */
+  if (fl1.l < fl2.l)
+    {
+      fl1.l <<= 1;
+      exp--;
+    }
+
+  /* now we perform repeated subtraction of fl2.l from fl1.l */
+  mask = 0x1000000;
+  result = 0;
+  while (mask)
+    {
+      if (fl1.l >= fl2.l)
+	{
+	  result |= mask;
+	  fl1.l -= fl2.l;
+	}
+      fl1.l <<= 1;
+      mask >>= 1;
+    }
+
+  /* round */
+  result += 1;
+
+  /* normalize down */
+  exp++;
+  result >>= 1;
+
+  result &= ~HIDDEN;
+
+  /* pack up and go home */
+  fl1.l = PACK (sign, exp, result);
+  return (fl1.f);
+}
+
+/* convert int to double */
+double
+__floatsidf (register long a1)
+{
+  register int sign = 0, exp = 31 + EXCESSD;
+  union double_long dl;
+
+  if (!a1)
+    {
+      dl.l.upper = dl.l.lower = 0;
+      return (dl.d);
+    }
+
+  if (a1 < 0)
+    {
+      sign = SIGNBIT;
+      a1 = -a1;
+    }
+
+  while (a1 < 0x1000000)
+    {
+      a1 <<= 4;
+      exp -= 4;
+    }
+
+  while (a1 < 0x40000000)
+    {
+      a1 <<= 1;
+      exp--;
+    }
+
+  /* pack up and go home */
+  dl.l.upper = sign;
+  dl.l.upper |= exp << 20;
+  dl.l.upper |= (a1 >> 10) & ~HIDDEND;
+  dl.l.lower = a1 << 22;
+
+  return (dl.d);
+}
+
+double
+__floatdidf (register long long a1)
+{
+    register int exp = 63 + EXCESSD;
+    union double_long dl;
+
+    dl.l.upper = dl.l.lower = 0;
+    if (a1 == 0)
+	return (dl.d);
+
+    if (a1 < 0) {
+	dl.l.upper = SIGNBIT;
+	a1 = -a1;
+    }
+
+    while (a1 < (long long)1<<54) {
+	a1 <<= 8;
+	exp -= 8;
+    }
+    while (a1 < (long long)1<<62) {
+	a1 <<= 1;
+	exp -= 1;
+    }
+
+  /* pack up and go home */
+    dl.ll |= (a1 >> 10) & ~HIDDEND_LL;
+    dl.l.upper |= exp << 20;
+
+    return (dl.d);
+}
+
+float
+__floatsisf (register long a1)
+{
+    (float)__floatsidf(a1);
+}
+
+float
+__floatdisf (register long long a1)
+{
+    (float)__floatdidf(a1);
+}
+
+/* negate a float */
+float
+__negsf2 (float a1)
+{
+  register union float_long fl1;
+
+  fl1.f = a1;
+  if (!fl1.l)
+    return (0);
+
+  fl1.l ^= SIGNBIT;
+  return (fl1.f);
+}
+
+/* negate a double */
+double
+__negdf2 (double a1)
+{
+  register union double_long dl1;
+
+  dl1.d = a1;
+
+  if (!dl1.l.upper && !dl1.l.lower)
+      return (dl1.d);
+
+  dl1.l.upper ^= SIGNBIT;
+  return (dl1.d);
+}
+
+/* convert float to double */
+double
+__extendsfdf2 (float a1)
+{
+  register union float_long fl1;
+  register union double_long dl;
+  register int exp;
+
+  fl1.f = a1;
+
+  if (!fl1.l)
+    {
+      dl.l.upper = dl.l.lower = 0;
+      return (dl.d);
+    }
+
+  dl.l.upper = SIGN (fl1.l);
+  exp = EXP (fl1.l) - EXCESS + EXCESSD;
+  dl.l.upper |= exp << 20;
+  dl.l.upper |= (MANT (fl1.l) & ~HIDDEN) >> 3;
+  dl.l.lower = MANT (fl1.l) << 29;
+
+  return (dl.d);
+}
+
+/* convert double to float */
+float
+__truncdfsf2 (double a1)
+{
+  register int exp;
+  register long mant;
+  register union float_long fl;
+  register union double_long dl1;
+
+  dl1.d = a1;
+
+  if (!dl1.l.upper && !dl1.l.lower)
+    return (float)(0);
+
+  exp = EXPD (dl1) - EXCESSD + EXCESS;
+
+  /* shift double mantissa 6 bits so we can round */
+  mant = MANTD (dl1) >> 6;
+
+  /* now round and shift down */
+  mant += 1;
+  mant >>= 1;
+
+  /* did the round overflow? */
+  if (mant & 0xFE000000)
+    {
+      mant >>= 1;
+      exp++;
+    }
+
+  mant &= ~HIDDEN;
+
+  /* pack up and go home */
+  fl.l = PACK (SIGND (dl1), exp, mant);
+  return (fl.f);
+}
+
+/* compare two doubles */
+long
+__cmpdf2 (double a1, double a2)
+{
+  register union double_long dl1, dl2;
+
+  dl1.d = a1;
+  dl2.d = a2;
+
+  if (SIGND (dl1) && SIGND (dl2))
+    {
+      dl1.l.upper ^= SIGNBIT;
+      dl2.l.upper ^= SIGNBIT;
+    }
+  if (dl1.l.upper < dl2.l.upper)
+    return (-1);
+  if (dl1.l.upper > dl2.l.upper)
+    return (1);
+  if (dl1.l.lower < dl2.l.lower)
+    return (-1);
+  if (dl1.l.lower > dl2.l.lower)
+    return (1);
+  return (0);
+}
+
+/* convert double to int */
+long
+__fixdfsi (double a1)
+{
+  register union double_long dl1;
+  register int exp;
+  register long l;
+
+  dl1.d = a1;
+
+  if (!dl1.l.upper && !dl1.l.lower)
+    return (0);
+
+  exp = EXPD (dl1) - EXCESSD - 31;
+  l = MANTD (dl1);
+
+  if (exp > 0)
+      return SIGND(dl1) ? (1<<31) : ((1ul<<31)-1);
+
+  /* shift down until exp = 0 or l = 0 */
+  if (exp < 0 && exp > -32 && l)
+    l >>= -exp;
+  else
+    return (0);
+
+  return (SIGND (dl1) ? -l : l);
+}
+
+/* convert double to int */
+long long
+__fixdfdi (double a1)
+{
+    register union double_long dl1;
+    register int exp;
+    register long long l;
+
+    dl1.d = a1;
+
+    if (!dl1.l.upper && !dl1.l.lower)
+	return (0);
+
+    exp = EXPD (dl1) - EXCESSD - 64;
+    l = MANTD_LL(dl1);
+
+    if (exp > 0) {
+	l = (long long)1<<63;
+	if (!SIGND(dl1))
+	    l--;
+	return l;
+    }
+
+    /* shift down until exp = 0 or l = 0 */
+    if (exp < 0 && exp > -64 && l)
+	l >>= -exp;
+    else
+	return (0);
+
+    return (SIGND (dl1) ? -l : l);
+}
+
+/* convert double to unsigned int */
+unsigned long
+__fixunsdfsi (double a1)
+{
+  register union double_long dl1;
+  register int exp;
+  register unsigned long l;
+
+  dl1.d = a1;
+
+  if (!dl1.l.upper && !dl1.l.lower)
+    return (0);
+
+  exp = EXPD (dl1) - EXCESSD - 32;
+  l = (((((dl1.l.upper) & 0xFFFFF) | HIDDEND) << 11) | (dl1.l.lower >> 21));
+
+  if (exp > 0)
+    return (0xFFFFFFFFul);	/* largest integer */
+
+  /* shift down until exp = 0 or l = 0 */
+  if (exp < 0 && exp > -32 && l)
+    l >>= -exp;
+  else
+    return (0);
+
+  return (l);
+}
+
+/* convert double to unsigned int */
+unsigned long long
+__fixunsdfdi (double a1)
+{
+    register union double_long dl1;
+    register int exp;
+    register unsigned long long l;
+
+    dl1.d = a1;
+
+    if (dl1.ll == 0)
+	return (0);
+
+    exp = EXPD (dl1) - EXCESSD - 64;
+
+    l = dl1.ll;
+
+    if (exp > 0)
+	return (unsigned long long)-1;
+
+    /* shift down until exp = 0 or l = 0 */
+    if (exp < 0 && exp > -64 && l)
+	l >>= -exp;
+    else
+	return (0);
+
+    return (l);
+}
+
+/* addtwo doubles */
+double
+__adddf3 (double a1, double a2)
+{
+    register long long mant1, mant2;
+    register union double_long fl1, fl2;
+    register int exp1, exp2;
+    int sign = 0;
+
+    fl1.d = a1;
+    fl2.d = a2;
+
+    /* check for zero args */
+    if (!fl2.ll)
+	goto test_done;
+    if (!fl1.ll) {
+	fl1.d = fl2.d;
+	goto test_done;
+    }
+
+    exp1 = EXPD(fl1);
+    exp2 = EXPD(fl2);
+
+    if (exp1 > exp2 + 54)
+	goto test_done;
+    if (exp2 > exp1 + 54) {
+	fl1.d = fl2.d;
+	goto test_done;
+    }
+
+    /* do everything in excess precision so's we can round later */
+    mant1 = MANTD_LL(fl1) << 9;
+    mant2 = MANTD_LL(fl2) << 9;
+
+    if (SIGND(fl1))
+	mant1 = -mant1;
+    if (SIGND(fl2))
+	mant2 = -mant2;
+
+    if (exp1 > exp2)
+	mant2 >>= exp1 - exp2;
+    else {
+	mant1 >>= exp2 - exp1;
+	exp1 = exp2;
+    }
+    mant1 += mant2;
+
+    if (mant1 < 0) {
+	mant1 = -mant1;
+	sign = SIGNBIT;
+    } else if (!mant1) {
+	fl1.d = 0;
+	goto test_done;
+    }
+
+    /* normalize up */
+    while (!(mant1 & ((long long)7<<61))) {
+	mant1 <<= 1;
+	exp1--;
+    }
+
+    /* normalize down? */
+    if (mant1 & ((long long)3<<62)) {
+	mant1 >>= 1;
+	exp1++;
+    }
+
+    /* round to even */
+    mant1 += (mant1 & (1<<9)) ? (1<<8) : ((1<<8)-1);
+
+    /* normalize down? */
+    if (mant1 & ((long long)3<<62)) {
+	mant1 >>= 1;
+	exp1++;
+    }
+
+    /* lose extra precision */
+    mant1 >>= 9;
+
+    /* turn off hidden bit */
+    mant1 &= ~HIDDEND_LL;
+
+    /* pack up and go home */
+    fl1.ll = PACKD_LL(sign,exp1,mant1);
+
+test_done:
+    return (fl1.d);
+}
+
+/* subtract two doubles */
+double
+__subdf3 (double a1, double a2)
+{
+    register union double_long fl1, fl2;
+
+    fl1.d = a1;
+    fl2.d = a2;
+
+    /* check for zero args */
+    if (!fl2.ll)
+	return (fl1.d);
+    /* twiddle sign bit and add */
+    fl2.l.upper ^= SIGNBIT;
+    if (!fl1.ll)
+	return (fl2.d);
+    return __adddf3 (a1, fl2.d);
+}
+
+/* multiply two doubles */
+double
+__muldf3 (double a1, double a2)
+{
+    register union double_long fl1, fl2;
+    register unsigned long long result;
+    register int exp;
+    int sign;
+
+    fl1.d = a1;
+    fl2.d = a2;
+
+    if (!fl1.ll || !fl2.ll) {
+	fl1.d = 0;
+	goto test_done;
+    }
+
+    /* compute sign and exponent */
+    sign = SIGND(fl1) ^ SIGND(fl2);
+    exp = EXPD(fl1) - EXCESSD;
+    exp += EXPD(fl2);
+
+    fl1.ll = MANTD_LL(fl1);
+    fl2.ll = MANTD_LL(fl2);
+
+  /* the multiply is done as one 31x31 multiply and two 31x21 multiples */
+    result = (fl1.ll >> 21) * (fl2.ll >> 21);
+    result += ((fl1.ll & 0x1FFFFF) * (fl2.ll >> 21)) >> 21;
+    result += ((fl2.ll & 0x1FFFFF) * (fl1.ll >> 21)) >> 21;
+
+    result >>= 2;
+    if (result & ((long long)1<<61)) {
+	/* round */
+	result += 1<<8;
+	result >>= 9;
+    } else {
+	/* round */
+	result += 1<<7;
+	result >>= 8;
+	exp--;
+    }
+    if (result & (HIDDEND_LL<<1)) {
+	result >>= 1;
+	exp++;
+    }
+
+    result &= ~HIDDEND_LL;
+
+    /* pack up and go home */
+    fl1.ll = PACKD_LL(sign,exp,result);
+test_done:
+    return (fl1.d);
+}
+
+/* divide two doubles */
+double
+__divdf3 (double a1, double a2)
+{
+    register union double_long fl1, fl2;
+    register long long mask,result;
+    register int exp, sign;
+
+    fl1.d = a1;
+    fl2.d = a2;
+
+    /* subtract exponents */
+    exp = EXPD(fl1) - EXPD(fl2) + EXCESSD;
+
+    /* compute sign */
+    sign = SIGND(fl1) ^ SIGND(fl2);
+
+    /* numerator zero??? */
+    if (fl1.ll == 0) {
+	/* divide by zero??? */
+	if (fl2.ll == 0)
+	    fl1.ll = ((unsigned long long)1<<63)-1;	/* NaN */
+	else
+	    fl1.ll = 0;
+	goto test_done;
+    }
+
+    /* return +Inf or -Inf */
+    if (fl2.ll == 0) {
+	fl1.ll = PACKD_LL(SIGND(fl1),2047,0);
+	goto test_done;
+    }
+
+
+    /* now get mantissas */
+    fl1.ll = MANTD_LL(fl1);
+    fl2.ll = MANTD_LL(fl2);
+
+    /* this assures we have 54 bits of precision in the end */
+    if (fl1.ll < fl2.ll) {
+	fl1.ll <<= 1;
+	exp--;
+    }
+
+    /* now we perform repeated subtraction of fl2.ll from fl1.ll */
+    mask = (long long)1<<53;
+    result = 0;
+    while (mask) {
+	if (fl1.ll >= fl2.ll)
+	{
+	    result |= mask;
+	    fl1.ll -= fl2.ll;
+	}
+	fl1.ll <<= 1;
+	mask >>= 1;
+    }
+
+    /* round */
+    result += 1;
+
+    /* normalize down */
+    exp++;
+    result >>= 1;
+
+    result &= ~HIDDEND_LL;
+
+    /* pack up and go home */
+    fl1.ll = PACKD_LL(sign, exp, result);
+
+test_done:
+    return (fl1.d);
+}
+
+int
+__gtdf2 (double a1, double a2)
+{
+    return __cmpdf2 ( a1, a2) > 0;
+}
+
+int
+__gedf2 (double a1, double a2)
+{
+    return (__cmpdf2 ( a1, a2) >= 0) - 1;
+}
+
+int
+__ltdf2 (double a1, double a2)
+{
+    return - (__cmpdf2 ( a1, a2) < 0);
+}
+
+int
+__ledf2 (double a1, double a2)
+{
+    return __cmpdf2 ( a1, a2) > 0;
+}
+
+int
+__eqdf2 (double a1, double a2)
+{
+    return *(long long *) &a1 == *(long long *) &a2;
+}
+
+int
+__nedf2 (double a1, double a2)
+{
+    return *(long long *) &a1 != *(long long *) &a2;
+}
+
diff --git a/drivers/video/xgi/osdef.h b/drivers/video/xgi/osdef.h
new file mode 100644
index 0000000..d506cc3
--- /dev/null
+++ b/drivers/video/xgi/osdef.h
@@ -0,0 +1,153 @@
+#ifndef _OSDEF_H_
+#define _OSDEF_H_
+
+/* #define WINCE_HEADER*/
+/*#define WIN2000*/
+/* #define TC */
+#define LINUX_KERNEL 
+/* #define LINUX_XF86 */
+
+/**********************************************************************/
+#ifdef LINUX_KERNEL
+//#include <linux/config.h>
+#endif
+
+
+/**********************************************************************/
+#ifdef TC
+#endif
+#ifdef WIN2000
+#endif
+#ifdef WINCE_HEADER
+#endif
+#ifdef LINUX_XF86
+#define LINUX
+#endif
+#ifdef LINUX_KERNEL
+#define LINUX
+#endif
+
+/**********************************************************************/
+#ifdef TC
+#define XGI_SetMemory(MemoryAddress,MemorySize,value) memset(MemoryAddress, value, MemorySize);
+#endif
+#ifdef WIN2000
+#define XGI_SetMemory(MemoryAddress,MemorySize,value) MemFill((PVOID) MemoryAddress,(ULONG) MemorySize,(UCHAR) value);
+#endif
+#ifdef WINCE_HEADER
+#define XGI_SetMemory(MemoryAddress,MemorySize,value) memset(MemoryAddress, value, MemorySize);
+#endif
+#ifdef LINUX_XF86
+#define XGI_SetMemory(MemoryAddress,MemorySize,value) memset(MemoryAddress, value, MemorySize)
+#endif
+#ifdef LINUX_KERNEL
+#define XGI_SetMemory(MemoryAddress,MemorySize,value) memset(MemoryAddress, value, MemorySize)
+#endif
+/**********************************************************************/
+
+/**********************************************************************/
+
+#ifdef TC
+#define XGI_MemoryCopy(Destination,Soruce,Length) memmove(Destination, Soruce, Length);
+#endif
+#ifdef WIN2000
+#define XGI_MemoryCopy(Destination,Soruce,Length)  /*VideoPortMoveMemory((PUCHAR)Destination , Soruce,length);*/
+#endif
+#ifdef WINCE_HEADER
+#define XGI_MemoryCopy(Destination,Soruce,Length) memmove(Destination, Soruce, Length);
+#endif
+#ifdef LINUX_XF86
+#define XGI_MemoryCopy(Destination,Soruce,Length) memcpy(Destination,Soruce,Length)
+#endif
+#ifdef LINUX_KERNEL
+#define XGI_MemoryCopy(Destination,Soruce,Length) memcpy(Destination,Soruce,Length)
+#endif
+
+/**********************************************************************/
+
+#ifdef OutPortByte
+#undef OutPortByte
+#endif /* OutPortByte */
+
+#ifdef OutPortWord
+#undef OutPortWord
+#endif /* OutPortWord */
+
+#ifdef OutPortLong
+#undef OutPortLong
+#endif /* OutPortLong */
+
+#ifdef InPortByte
+#undef InPortByte
+#endif /* InPortByte */
+
+#ifdef InPortWord
+#undef InPortWord
+#endif /* InPortWord */
+
+#ifdef InPortLong
+#undef InPortLong
+#endif /* InPortLong */
+
+/**********************************************************************/
+/*  TC                                                                */
+/**********************************************************************/
+
+#ifdef TC
+#define OutPortByte(p,v) outp((unsigned short)(p),(unsigned char)(v))
+#define OutPortWord(p,v) outp((unsigned short)(p),(unsigned short)(v))
+#define OutPortLong(p,v) outp((unsigned short)(p),(unsigned long)(v))
+#define InPortByte(p)    inp((unsigned short)(p))
+#define InPortWord(p)    inp((unsigned short)(p))
+#define InPortLong(p)    ((inp((unsigned short)(p+2))<<16) | inp((unsigned short)(p)))
+#endif
+
+/**********************************************************************/
+/*  LINUX XF86                                                        */
+/**********************************************************************/
+
+#ifdef LINUX_XF86
+#define OutPortByte(p,v) outb((CARD16)(p),(CARD8)(v))
+#define OutPortWord(p,v) outw((CARD16)(p),(CARD16)(v))
+#define OutPortLong(p,v) outl((CARD16)(p),(CARD32)(v))
+#define InPortByte(p)    inb((CARD16)(p))
+#define InPortWord(p)    inw((CARD16)(p))
+#define InPortLong(p)    inl((CARD16)(p))
+#endif
+
+#ifdef LINUX_KERNEL
+#define OutPortByte(p,v) outb((u8)(v),(p))
+#define OutPortWord(p,v) outw((u16)(v),(p))
+#define OutPortLong(p,v) outl((u32)(v),(p))
+#define InPortByte(p)    inb(p)
+#define InPortWord(p)    inw(p)
+#define InPortLong(p)    inl(p)
+#endif
+
+/**********************************************************************/
+/*  WIN 2000                                                          */
+/**********************************************************************/
+
+#ifdef WIN2000
+#define OutPortByte(p,v) VideoPortWritePortUchar ((PUCHAR) (p), (UCHAR) (v))
+#define OutPortWord(p,v) VideoPortWritePortUshort((PUSHORT) (p), (USHORT) (v))
+#define OutPortLong(p,v) VideoPortWritePortUlong ((PULONG) (p), (ULONG) (v))
+#define InPortByte(p)    VideoPortReadPortUchar  ((PUCHAR) (p))
+#define InPortWord(p)    VideoPortReadPortUshort ((PUSHORT) (p))
+#define InPortLong(p)    VideoPortReadPortUlong  ((PULONG) (p))
+#endif
+
+
+/**********************************************************************/
+/*  WIN CE                                                          */
+/**********************************************************************/
+
+#ifdef WINCE_HEADER
+#define OutPortByte(p,v) WRITE_PORT_UCHAR ((PUCHAR) (p), (UCHAR) (v))
+#define OutPortWord(p,v) WRITE_PORT_USHORT((PUSHORT) (p), (USHORT) (v))
+#define OutPortLong(p,v) WRITE_PORT_ULONG ((PULONG) (p), (ULONG) (v))
+#define InPortByte(p)    READ_PORT_UCHAR  ((PUCHAR) (p))
+#define InPortWord(p)    READ_PORT_USHORT ((PUSHORT) (p))
+#define InPortLong(p)    READ_PORT_ULONG  ((PULONG) (p))
+#endif
+#endif // _OSDEF_H_
diff --git a/drivers/video/xgi/vb_def.h b/drivers/video/xgi/vb_def.h
new file mode 100644
index 0000000..17a7ada
--- /dev/null
+++ b/drivers/video/xgi/vb_def.h
@@ -0,0 +1,1017 @@
+/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/xgi/initdef.h,v 1.4 2000/12/02 01:16:17 dawes Exp $ */
+#ifndef _INITDEF_
+#define _INITDEF_
+
+#ifndef NewScratch
+#define NewScratch
+#endif
+/* shampoo */
+#ifdef LINUX_KERNEL
+#define SEQ_ADDRESS_PORT	  0x0014
+#define SEQ_DATA_PORT		  0x0015
+#define MISC_OUTPUT_REG_READ_PORT 0x001C
+#define MISC_OUTPUT_REG_WRITE_PORT 0x0012
+#define GRAPH_DATA_PORT		  0x1F
+#define GRAPH_ADDRESS_PORT	  0x1E
+#define XGI_MASK_DUAL_CHIP	  0x04  /* SR3A */
+#define CRTC_ADDRESS_PORT_COLOR   0x0024
+#define VIDEO_SUBSYSTEM_ENABLE_PORT 0x0013
+#define PCI_COMMAND		0x04
+#endif
+/* ~shampoo */
+
+
+#define VB_XGI301	      0x0001  /*301b*/
+#define VB_XGI301B        0x0002
+#define VB_XGI302B        0x0004
+#define VB_XGI301LV     0x0008 /*301lv*/
+#define VB_XGI302LV     0x0010
+#define VB_XGI301C      0x0020       /* for 301C */
+#define  VB_NoLCD        0x8000
+/*end 301b*/
+
+#define VB_YPbPrInfo     0x07          /*301lv*/
+#define VB_YPbPr525i     0x00
+#define VB_YPbPr525p     0x01
+#define VB_YPbPr750p     0x02
+#define VB_YPbPr1080i    0x03
+
+/* #define CRT1Len 17 */
+#define LVDSCRT1Len             15
+#define CHTVRegDataLen          5
+
+/* #define ModeInfoFlag 0x07 */
+/* #define IsTextMode 0x07 */
+/* #define ModeText 0x00 */
+/* #define ModeCGA 0x01 */
+/* #define ModeEGA 0x02 */
+/* #define ModeVGA 0x03 */
+/* #define Mode15Bpp 0x04 */
+/* #define Mode16Bpp 0x05 */
+/* #define Mode24Bpp 0x06 */
+/* #define Mode32Bpp 0x07 */
+
+/* #define DACInfoFlag 0x18 */
+/* #define MemoryInfoFlag 0x1E0 */
+/* #define MemorySizeShift 0x05 */
+
+#define Charx8Dot               0x0200
+#define LineCompareOff          0x0400
+#define CRT2Mode                0x0800
+#define HalfDCLK                0x1000
+#define NoSupportSimuTV         0x2000
+#define DoubleScanMode          0x8000
+
+#define SupportAllCRT2          0x0078
+#define SupportTV               0x0008
+#define SupportHiVisionTV       0x0010
+#define SupportLCD              0x0020
+#define SupportRAMDAC2          0x0040
+#define NoSupportTV             0x0070
+#define NoSupportHiVisionTV     0x0060
+#define NoSupportLCD            0x0058
+#define SupportCHTV 		0x0800
+#define SupportCRT2in301C       0x0100       /* for 301C */
+#define SupportTV1024           0x0800  /*301b*/
+#define SupportYPbPr            0x1000  /*301lv*/
+#define InterlaceMode           0x0080
+#define SyncPP                  0x0000
+#define SyncPN                  0x4000
+#define SyncNP                  0x8000
+/* #define SyncNN 0xc000 */
+#define ECLKindex0              0x0000
+#define ECLKindex1              0x0100
+#define ECLKindex2              0x0200
+#define ECLKindex3              0x0300
+#define ECLKindex4              0x0400
+
+#define SetSimuScanMode         0x0001
+#define SwitchToCRT2            0x0002
+/* #define SetCRT2ToTV 0x009C */
+#define SetCRT2ToAVIDEO         0x0004
+#define SetCRT2ToSVIDEO         0x0008
+#define SetCRT2ToSCART          0x0010
+#define SetCRT2ToLCD            0x0020
+#define SetCRT2ToRAMDAC         0x0040
+#define SetCRT2ToHiVisionTV     0x0080
+#define SetNTSCTV               0x0000
+/* #define SetPALTV 0x0100 */
+#define SetInSlaveMode          0x0200
+#define SetNotSimuMode          0x0400
+#define SetNotSimuTVMode        0x0400
+#define SetDispDevSwitch        0x0800
+#define LoadDACFlag             0x1000
+#define DisableCRT2Display      0x2000
+#define DriverMode              0x4000
+#define HotKeySwitch            0x8000
+#define SetCHTVOverScan  	0x8000
+/* #define SetCRT2ToLCDA 0x8000 301b */
+#define PanelRGB18Bit           0x0100
+#define PanelRGB24Bit           0x0000
+
+#define TVOverScan              0x10
+#define TVOverScanShift         4
+#define ClearBufferFlag         0x20
+#define EnableDualEdge 		0x01		/*301b*/
+#define SetToLCDA		0x02
+
+#define YPbPrModeInfo           0x38
+/* #define YPbPrMode525i 0x00 */
+/* #define YPbPrMode525p 0x08 */
+/* #define YPbPrMode750p 0x10 */
+/* #define YPbPrMode1080i 0x18 */
+
+#define SetSCARTOutput          0x01
+#define BoardTVType             0x02
+#define  EnablePALMN           0x40
+/* #define ProgrammingCRT2 0x01 */
+/* #define TVSimuMode 0x02 */
+/* #define RPLLDIV2XO 0x04 */
+/* #define LCDVESATiming 0x08 */
+/* #define EnableLVDSDDA 0x10 */
+#define SetDispDevSwitchFlag    0x20
+#define CheckWinDos             0x40
+#define SetJDOSMode             0x80
+
+#define Panel320x480              0x07/*fstn*/
+/* [ycchen] 02/12/03 Modify for Multi-Sync. LCD Support */
+#define PanelResInfo            0x1F	/* CR36 Panel Type/LCDResInfo */
+#define PanelRefInfo            0x60
+#define Panel800x600            0x01
+#define Panel1024x768           0x02
+#define Panel1024x768x75        0x22
+#define Panel1280x1024          0x03
+#define Panel1280x1024x75       0x23
+#define Panel640x480            0x04
+#define Panel1024x600           0x05
+#define Panel1152x864           0x06
+#define Panel1280x960           0x07
+#define Panel1152x768           0x08
+#define Panel1400x1050          0x09
+#define Panel1280x768           0x0A
+#define Panel1600x1200          0x0B
+
+#define PanelRef60Hz            0x00
+#define PanelRef75Hz            0x20
+#define LCDRGB18Bit             0x01
+
+#define ExtChipTrumpion         0x06
+#define ExtChipCH7005           0x08
+#define ExtChipMitacTV          0x0a
+#define LCDNonExpanding         0x10
+#define LCDNonExpandingShift    4
+#define LCDSync                 0x20
+#define LCDSyncBit              0xe0
+#define LCDSyncShift            6
+
+/* #define DDC2DelayTime 300 */
+
+#define CRT2DisplayFlag         0x2000
+/* #define LCDDataLen 8 */
+/* #define HiTVDataLen 12 */
+/* #define TVDataLen 16 */
+/* #define SetPALTV 0x0100 */
+#define HalfDCLK                0x1000
+#define NTSCHT                  1716
+#define NTSCVT                  525
+#define PALHT                   1728
+#define PALVT                   625
+#define StHiTVHT                892
+#define StHiTVVT                1126
+#define StHiTextTVHT            1000
+#define StHiTextTVVT            1126
+#define ExtHiTVHT               2100
+#define ExtHiTVVT               1125
+
+#define St750pTVHT              1716
+#define St750pTVVT               525
+#define Ext750pTVHT             1716
+#define Ext750pTVVT              525
+#define St525pTVHT              1716
+#define St525pTVVT               525
+#define Ext525pTVHT             1716
+#define Ext525pTVVT              525
+#define St525iTVHT              1716
+#define St525iTVVT               525
+#define Ext525iTVHT             1716
+#define Ext525iTVVT              525
+
+#define VCLKStartFreq           25
+#define SoftDramType            0x80
+#define VCLK40                  0x04
+
+#define VCLK162             	0x21
+
+#define LCDRGB18Bit             0x01
+#define LoadDACFlag             0x1000
+#define AfterLockCRT2           0x4000
+#define SetCRT2ToAVIDEO         0x0004
+#define SetCRT2ToSCART          0x0010
+#define Ext2StructSize          5
+
+
+#define YPbPr525iVCLK           0x03B
+#define YPbPr525iVCLK_2         0x03A
+
+#define SwitchToCRT2            0x0002
+/* #define LCDVESATiming 0x08 */
+#define SetSCARTOutput          0x01
+#define AVIDEOSense             0x01
+#define SVIDEOSense             0x02
+#define SCARTSense              0x04
+#define LCDSense                0x08
+#define Monitor1Sense           0x20
+#define Monitor2Sense           0x10
+#define HiTVSense               0x40
+#define BoardTVType             0x02
+#define HotPlugFunction         0x08
+#define StStructSize            0x06
+
+
+#define XGI_CRT2_PORT_00        0x00 - 0x030
+#define XGI_CRT2_PORT_04        0x04 - 0x030
+#define XGI_CRT2_PORT_10        0x10 - 0x30
+#define XGI_CRT2_PORT_12        0x12 - 0x30
+#define XGI_CRT2_PORT_14        0x14 - 0x30
+
+
+#define LCDNonExpanding         0x10
+#define ADR_CRT2PtrData         0x20E
+#define offset_Zurac            0x210
+#define ADR_LVDSDesPtrData      0x212
+#define ADR_LVDSCRT1DataPtr     0x214
+#define ADR_CHTVVCLKPtr         0x216
+#define ADR_CHTVRegDataPtr      0x218
+
+#define LVDSDataLen             6
+/* #define EnableLVDSDDA 0x10 */
+/* #define LVDSDesDataLen 3 */
+#define ActiveNonExpanding      0x40
+#define ActiveNonExpandingShift 6
+/* #define ActivePAL 0x20 */
+#define ActivePALShift          5
+/* #define ModeSwitchStatus 0x0F */
+#define SoftTVType              0x40
+#define SoftSettingAddr         0x52
+#define ModeSettingAddr         0x53
+
+/* #define SelectCRT1Rate 0x4 */
+
+#define _PanelType00             0x00
+#define _PanelType01             0x08
+#define _PanelType02             0x10
+#define _PanelType03             0x18
+#define _PanelType04             0x20
+#define _PanelType05             0x28
+#define _PanelType06             0x30
+#define _PanelType07             0x38
+#define _PanelType08             0x40
+#define _PanelType09             0x48
+#define _PanelType0A             0x50
+#define _PanelType0B             0x58
+#define _PanelType0C             0x60
+#define _PanelType0D             0x68
+#define _PanelType0E             0x70
+#define _PanelType0F             0x78
+
+
+#define PRIMARY_VGA       0     /* 1: XGI is primary vga 0:XGI is secondary vga */
+#define BIOSIDCodeAddr          0x235
+#define OEMUtilIDCodeAddr       0x237
+#define VBModeIDTableAddr       0x239
+#define OEMTVPtrAddr            0x241
+#define PhaseTableAddr          0x243
+#define NTSCFilterTableAddr     0x245
+#define PALFilterTableAddr      0x247
+#define OEMLCDPtr_1Addr         0x249
+#define OEMLCDPtr_2Addr         0x24B
+#define LCDHPosTable_1Addr      0x24D
+#define LCDHPosTable_2Addr      0x24F
+#define LCDVPosTable_1Addr      0x251
+#define LCDVPosTable_2Addr      0x253
+#define OEMLCDPIDTableAddr      0x255
+
+#define VBModeStructSize        5
+#define PhaseTableSize          4
+#define FilterTableSize         4
+#define LCDHPosTableSize        7
+#define LCDVPosTableSize        5
+#define OEMLVDSPIDTableSize     4
+#define LVDSHPosTableSize       4
+#define LVDSVPosTableSize       6
+
+#define VB_ModeID               0
+#define VB_TVTableIndex         1
+#define VB_LCDTableIndex        2
+#define VB_LCDHIndex            3
+#define VB_LCDVIndex            4
+
+#define OEMLCDEnable            0x0001
+#define OEMLCDDelayEnable       0x0002
+#define OEMLCDPOSEnable         0x0004
+#define OEMTVEnable             0x0100
+#define OEMTVDelayEnable        0x0200
+#define OEMTVFlickerEnable      0x0400
+#define OEMTVPhaseEnable        0x0800
+#define OEMTVFilterEnable       0x1000
+
+#define OEMLCDPanelIDSupport    0x0080
+
+/* #define LCDVESATiming 0x0001 //LCD Info CR37 */
+/* #define EnableLVDSDDA 0x0002 */
+#define EnableScalingLCD        0x0008
+#define SetPWDEnable            0x0004
+#define SetLCDtoNonExpanding    0x0010
+/* #define SetLCDPolarity 0x00E0 */
+#define SetLCDDualLink          0x0100
+#define SetLCDLowResolution     0x0200
+#define SetLCDStdMode           0x0400
+#define SetTVStdMode            0x0200
+#define SetTVLowResolution      0x0400
+/* =============================================================
+   for 310
+============================================================== */
+#define SoftDRAMType        0x80
+#define SoftSetting_OFFSET  0x52
+#define SR07_OFFSET  0x7C
+#define SR15_OFFSET  0x7D
+#define SR16_OFFSET  0x81
+#define SR17_OFFSET  0x85
+#define SR19_OFFSET  0x8D
+#define SR1F_OFFSET  0x99
+#define SR21_OFFSET  0x9A
+#define SR22_OFFSET  0x9B
+#define SR23_OFFSET  0x9C
+#define SR24_OFFSET  0x9D
+#define SR25_OFFSET  0x9E
+#define SR31_OFFSET  0x9F
+#define SR32_OFFSET  0xA0
+#define SR33_OFFSET  0xA1
+
+#define CR40_OFFSET  0xA2
+#define SR25_1_OFFSET  0xF6
+#define CR49_OFFSET  0xF7
+
+#define VB310Data_1_2_Offset  0xB6
+#define VB310Data_4_D_Offset  0xB7
+#define VB310Data_4_E_Offset  0xB8
+#define VB310Data_4_10_Offset 0xBB
+
+#define RGBSenseDataOffset    0xBD
+#define YCSenseDataOffset     0xBF
+#define VideoSenseDataOffset  0xC1
+#define OutputSelectOffset    0xF3
+
+#define ECLK_MCLK_DISTANCE  0x14
+#define VBIOSTablePointerStart    0x200
+#define StandTablePtrOffset       VBIOSTablePointerStart+0x02
+#define EModeIDTablePtrOffset     VBIOSTablePointerStart+0x04
+#define CRT1TablePtrOffset        VBIOSTablePointerStart+0x06
+#define ScreenOffsetPtrOffset     VBIOSTablePointerStart+0x08
+#define VCLKDataPtrOffset         VBIOSTablePointerStart+0x0A
+#define MCLKDataPtrOffset         VBIOSTablePointerStart+0x0E
+#define CRT2PtrDataPtrOffset      VBIOSTablePointerStart+0x10
+#define TVAntiFlickPtrOffset      VBIOSTablePointerStart+0x12
+#define TVDelayPtr1Offset         VBIOSTablePointerStart+0x14
+#define TVPhaseIncrPtr1Offset     VBIOSTablePointerStart+0x16
+#define TVYFilterPtr1Offset       VBIOSTablePointerStart+0x18
+#define LCDDelayPtr1Offset        VBIOSTablePointerStart+0x20
+#define TVEdgePtr1Offset          VBIOSTablePointerStart+0x24
+#define CRT2Delay1Offset          VBIOSTablePointerStart+0x28
+#define LCDDataDesOffset     VBIOSTablePointerStart-0x02
+#define LCDDataPtrOffset          VBIOSTablePointerStart+0x2A
+#define LCDDesDataPtrOffset     VBIOSTablePointerStart+0x2C
+#define LCDDataList		VBIOSTablePointerStart+0x22	/* add for GetLCDPtr */
+#define TVDataList		VBIOSTablePointerStart+0x36	/* add for GetTVPtr */
+/*  */
+/* Modify from 310.inc */
+/*  */
+/*  */
+
+
+#define		ShowMsgFlag                  0x20               /* SoftSetting */
+#define		ShowVESAFlag                 0x10
+#define		HotPlugFunction              0x08
+#define		ModeSoftSetting              0x04
+#define		TVSoftSetting                0x02
+#define		LCDSoftSetting               0x01
+
+#define		GatingCRTinLCDA              0x10
+#define		SetHiTVOutput                0x08
+#define		SetYPbPrOutput               0x04
+#define		BoardTVType                  0x02
+#define		SetSCARTOutput               0x01
+
+#define		ModeSettingYPbPr             0x02               /* TVModeSetting, Others as same as CR30 */
+
+/* TVModeSetting same as CR35 */
+
+/* LCDModeSetting same as CR37 */
+
+#define		EnableNewTVFont              0x10               /* MiscCapability */
+
+#define		EnableLCDOutput              0x80               /* LCDCfgSetting */
+
+#define		SoftDRAMType                 0x80               /* DRAMSetting */
+#define		SoftDRAMConfig               0x40
+#define		MosSelDRAMType               0x20
+#define		SDRAM                        000h
+#define		SGRAM                        0x01
+#define		ESDRAM                       0x02
+
+#define		EnableAGPCfgSetting          0x01               /* AGPCfgSetting */
+
+/* ---------------- SetMode Stack */
+#define		CRT1Len                      15
+#define		VCLKLen                      4
+#define		DefThreshold                 0x0100
+#define		ExtRegsSize                  (57+8+37+70+63+28+768+1)/64+1
+
+#define		VGA_XGI315                   0x0001       /* VGA Type Info */
+#define		VGA_SNewis315e                  0x0002       /* 315 series */
+#define		VGA_XGI550                   0x0004
+#define		VGA_XGI640                   0x0008
+#define		VGA_XGI740                   0x0010
+#define		VGA_XGI650                   0x0020
+#define		VGA_XGI650M                  0x0040
+#define		VGA_XGI651                   0x0080
+#define		VGA_XGI340                   0x0001       /* 340 series */
+#define		VGA_XGI330                   0x0001       /* 330 series */
+#define		VGA_XGI660                   0x0001       /* 660 series */
+
+#define		VB_XGI301                    0x0001       /* VB Type Info */
+#define		VB_XGI301B                   0x0002       /* 301 series */
+#define		VB_XGI302B                   0x0004
+#define		VB_NoLCD                     0x8000
+#define		VB_XGI301LV                  0x0008
+#define		VB_XGI302LV                  0x0010
+#define		VB_LVDS_NS                   0x0001       /* 3rd party chip */
+#define		VB_CH7017                    0x0002
+#define         VB_CH7007                    0x0080       /* [Billy] 07/05/03 */
+/* #define VB_LVDS_SI 0x0004 */
+
+#define		ModeInfoFlag                 0x0007
+#define		IsTextMode                   0x0007
+#define		ModeText                     0x0000
+#define		ModeCGA                      0x0001
+#define		ModeEGA                      0x0002       /* 16 colors mode */
+#define		ModeVGA                      0x0003       /* 256 colors mode */
+#define		Mode15Bpp                    0x0004       /* 15 Bpp Color Mode */
+#define		Mode16Bpp                    0x0005       /* 16 Bpp Color Mode */
+#define		Mode24Bpp                    0x0006       /* 24 Bpp Color Mode */
+#define		Mode32Bpp                    0x0007       /* 32 Bpp Color Mode */
+
+#define		DACInfoFlag                  0x0018
+#define		MONODAC                      0x0000
+#define		CGADAC                       0x0008
+#define		EGADAC                       0x0010
+#define		VGADAC                       0x0018
+
+#define		MemoryInfoFlag               0x01e0
+#define		MemorySizeShift              5
+#define		Need1MSize                   0x0000
+#define		Need2MSize                   0x0020
+#define		Need4MSize                   0x0060
+#define		Need8MSize                   0x00e0
+#define		Need16MSize                  0x01e0
+
+#define		Charx8Dot                    0x0200
+#define		LineCompareOff               0x0400
+#define		CRT2Mode                     0x0800
+#define		HalfDCLK                     0x1000
+#define		NoSupportSimuTV              0x2000
+#define		DoubleScanMode               0x8000
+
+/* -------------- Ext_InfoFlag */
+#define		SupportModeInfo              0x0007
+#define		Support256                   0x0003
+#define		Support15Bpp                 0x0004
+#define		Support16Bpp                 0x0005
+#define		Support24Bpp                 0x0006
+#define		Support32Bpp                 0x0007
+
+#define		SupportAllCRT2               0x0078
+#define		SupportTV                    0x0008
+#define		SupportHiVisionTV            0x0010
+#define		SupportLCD                   0x0020
+#define		SupportRAMDAC2               0x0040
+#define		NoSupportTV                  0x0070
+#define		NoSupportHiVisionTV          0x0060
+#define		NoSupportLCD                 0x0058
+#define		SupportTV1024                0x0800       /* 301btest */
+#define		SupportYPbPr                 0x1000       /* 301lv */
+#define		InterlaceMode                0x0080
+#define		SyncPP                       0x0000
+#define		SyncPN                       0x4000
+#define		SyncNP                       0x8000
+#define		SyncNN                       0xC000
+
+/* -------------- SetMode Stack/Scratch */
+#define		SetSimuScanMode              0x0001       /* VBInfo/CR30 & CR31 */
+#define		SwitchToCRT2                 0x0002
+#define		SetCRT2ToTV1                 0x009C
+#define		SetCRT2ToTV                  0x089C
+#define		SetCRT2ToAVIDEO              0x0004
+#define		SetCRT2ToSVIDEO              0x0008
+#define		SetCRT2ToSCART               0x0010
+#define		SetCRT2ToLCD                 0x0020
+#define		SetCRT2ToRAMDAC              0x0040
+#define		SetCRT2ToHiVisionTV          0x0080
+#define		SetCRT2ToLCDA                0x0100
+#define		SetInSlaveMode               0x0200
+#define		SetNotSimuMode               0x0400
+#define		HKEventMode                  0x0800
+#define		SetCRT2ToYPbPr               0x0800
+#define		LoadDACFlag                  0x1000
+#define		DisableCRT2Display           0x2000
+#define		DriverMode                   0x4000
+#define		SetCRT2ToDualEdge            0x8000
+#define		HotKeySwitch                 0x8000
+
+#define		ProgrammingCRT2              0x0001       /* Set Flag */
+#define		EnableVCMode                 0x0002
+#define		SetHKEventMode               0x0004
+#define		ReserveTVOption              0x0008
+#define		DisableRelocateIO            0x0010
+#define		Win9xDOSMode                 0x0020
+#define		JDOSMode                     0x0040
+/* #define SetWin9xforJap 0x0080 // not used now */
+/* #define SetWin9xforKorea 0x0100 // not used now */
+#define		GatingCRT                    0x0800
+#define		DisableChB                   0x1000
+#define		EnableChB                    0x2000
+#define		DisableChA                   0x4000
+#define		EnableChA                    0x8000
+
+#define		SetNTSCTV                    0x0000       /* TV Info */
+#define		SetPALTV                     0x0001
+#define		SetNTSCJ                     0x0002
+#define		SetPALMTV                    0x0004
+#define		SetPALNTV                    0x0008
+#define		SetCHTVUnderScan             0x0000
+/* #define SetCHTVOverScan 0x0010 */
+#define		SetYPbPrMode525i             0x0020
+#define		SetYPbPrMode525p             0x0040
+#define		SetYPbPrMode750p             0x0080
+#define		SetYPbPrMode1080i            0x0100
+#define		SetTVStdMode                 0x0200
+#define		SetTVLowResolution           0x0400
+#define		SetTVSimuMode                0x0800
+#define		TVSimuMode                   0x0800
+#define		RPLLDIV2XO                   0x1000
+#define		NTSC1024x768                 0x2000
+#define		SetTVLockMode                0x4000
+
+#define		LCDVESATiming                0x0001       /* LCD Info/CR37 */
+#define		EnableLVDSDDA                0x0002
+#define		EnableScalingLCD             0x0008
+#define		SetPWDEnable                 0x0004
+#define		SetLCDtoNonExpanding         0x0010
+#define		SetLCDPolarity               0x00e0
+#define		SetLCDDualLink               0x0100
+#define		SetLCDLowResolution          0x0200
+#define		SetLCDStdMode                0x0400
+
+#define		DefaultLCDCap                0x80ea       /* LCD Capability shampoo */
+#define		RLVDSDHL00                   0x0000
+#define		RLVDSDHL01                   0x0001
+#define		RLVDSDHL10                   0x0002       /* default */
+#define		RLVDSDHL11                   0x0003
+#define		EnableLCD24bpp               0x0004       /* default */
+#define		DisableLCD24bpp              0x0000
+#define		RLVDSClkSFT0                 0x0000
+#define		RLVDSClkSFT1                 0x0008       /* default */
+#define		EnableLVDSDCBal              0x0010
+#define		DisableLVDSDCBal             0x0000       /* default */
+#define		SinglePolarity               0x0020       /* default */
+#define		MultiPolarity                0x0000
+#define		LCDPolarity                  0x00c0       /* default: SyncNN */
+#define		LCDSingleLink                0x0000       /* default */
+#define		LCDDualLink                  0x0100
+#define		EnableSpectrum               0x0200
+#define		DisableSpectrum              0x0000       /* default */
+#define		PWDEnable                    0x0400
+#define		PWDDisable                   0x0000       /* default */
+#define		PWMEnable                    0x0800
+#define		PWMDisable                   0x0000       /* default */
+#define		EnableVBCLKDRVLOW            0x4000
+#define		EnableVBCLKDRVHigh           0x0000       /* default */
+#define		EnablePLLSPLOW               0x8000
+#define		EnablePLLSPHigh              0x0000       /* default */
+
+#define		LCDBToA                      0x20               /* LCD SetFlag */
+#define		StLCDBToA                    0x40
+#define		LockLCDBToA                  0x80
+#define 	LCDToFull             	     0x10
+#define		AVIDEOSense                  0x01               /* CR32 */
+#define		SVIDEOSense                  0x02
+#define		SCARTSense                   0x04
+#define		LCDSense                     0x08
+#define		Monitor2Sense                0x10
+#define		Monitor1Sense                0x20
+#define		HiTVSense                    0x40
+
+#ifdef                   NewScratch
+#define		YPbPrSense                   0x80    /* NEW SCRATCH */
+#endif
+
+#define		TVSense                      0xc7
+
+#define		TVOverScan                   0x10               /* CR35 */
+#define		TVOverScanShift              4
+
+#ifdef                   NewScratch
+#define		NTSCMode                     0x00
+#define		PALMode                      0x00
+#define		NTSCJMode                    0x02
+#define		PALMNMode                    0x0c
+#define		YPbPrMode                    0xe0
+#define		YPbPrMode525i                0x00
+#define		YPbPrMode525p                0x20
+#define		YPbPrMode750p                0x40
+#define		YPbPrMode1080i               0x60
+#else                    /* Old Scratch */
+#define		ClearBufferFlag              0x20
+#endif
+
+
+#define		LCDRGB18Bit                  0x01               /* CR37 */
+#define		LCDNonExpanding              0x10
+#define		LCDNonExpandingShift         4
+#define		LCDSync                      0x20
+#define		LCDSyncBit                   0xe0               /* H/V polarity & sync ID */
+#define		LCDSyncShift                 6
+
+#ifdef                   NewScratch
+#define		ScalingLCD                   0x08
+#else                    /* Old Scratch */
+#define		ExtChipType                  0x0e
+#define		ExtChip301                   0x02
+#define		ExtChipLVDS                  0x04
+#define		ExtChipCH7019                0x06
+#define		ScalingLCD                   0x10
+#endif
+
+#define		EnableDualEdge               0x01               /* CR38 */
+#define		SetToLCDA                    0x02
+#ifdef                   NewScratch
+#define		SetYPbPr                     0x04
+#define		DisableChannelA              0x08
+#define		DisableChannelB              0x10
+#define		ExtChipType                  0xe0
+#define		ExtChip301                   0x20
+#define		ExtChipLVDS                  0x40
+#define		ExtChipCH7019                0x60
+#else                    /* Old Scratch */
+#define		YPbPrSense                   0x04
+#define		SetYPbPr                     0x08
+#define		YPbPrMode                    0x30
+#define		YPbPrMode525i                0x00
+#define		YPbPrMode525p                0x10
+#define		YPbPrMode750p                0x20
+#define		YPbPrMode1080i               0x30
+#define		PALMNMode                    0xc0
+#endif
+
+#define		BacklightControlBit          0x01               /* CR3A */
+#define		Win9xforJap                  0x40
+#define		Win9xforKorea                0x80
+
+#define		ForceMDBits                  0x07               /* CR3B */
+#define		ForceMD_JDOS                 0x00
+#define		ForceMD_640x400T             0x01
+#define		ForceMD_640x350T             0x02
+#define		ForceMD_720x400T             0x03
+#define		ForceMD_640x480E             0x04
+#define		ForceMD_640x400E             0x05
+#define		ForceP1Bit                   0x10
+#define		ForceP2Bit                   0x20
+#define		EnableForceMDinBIOS          0x40
+#define		EnableForceMDinDrv           0x80
+
+#ifdef                   NewScratch                      /* New Scratch */
+/* ---------------------- VUMA Information */
+#define		LCDSettingFromCMOS           0x04               /* CR3C */
+#define		TVSettingFromCMOS            0x08
+#define		DisplayDeviceFromCMOS        0x10
+#define		HKSupportInSBIOS             0x20
+#define		OSDSupportInSBIOS            0x40
+#define		DisableLogo                  0x80
+
+/* ---------------------- HK Evnet Definition */
+#define		HKEvent                      0x0f               /* CR3D */
+#define		HK_ModeSwitch                0x01
+#define		HK_Expanding                 0x02
+#define		HK_OverScan                  0x03
+#define		HK_Brightness                0x04
+#define		HK_Contrast                  0x05
+#define		HK_Mute                      0x06
+#define		HK_Volume                    0x07
+#define		ModeSwitchStatus             0xf0
+#define		ActiveCRT1                   0x10
+#define		ActiveLCD                    0x0020
+#define		ActiveTV                     0x40
+#define		ActiveCRT2                   0x80
+
+#define		TVSwitchStatus               0x1f               /* CR3E */
+#define		ActiveAVideo                 0x01
+#define		ActiveSVideo                 0x02
+#define		ActiveSCART                  0x04
+#define		ActiveHiTV                   0x08
+#define		ActiveYPbPr                  0x10
+
+#define		EnableHKEvent                0x01               /* CR3F */
+#define		EnableOSDEvent               0x02
+#define		StartOSDEvent                0x04
+#define		IgnoreHKEvent                0x08
+#define		IgnoreOSDEvent               0x10
+#else                    /* Old Scratch */
+#define		OSD_SBIOS                    0x02       /* SR17 */
+#define		DisableLogo                  0x04
+#define		SelectKDOS                   0x08
+#define		KorWinMode                   0x10
+#define		KorMode3Bit                  0x0020
+#define		PSCCtrlBit                  0x40
+#define		NPSCCtrlBitShift             6
+#define		BlueScreenBit                0x80
+
+#define		HKEvent                      0x0f       /* CR79 */
+#define		HK_ModeSwitch                0x01
+#define		HK_Expanding                 0x02
+#define		HK_OverScan                  0x03
+#define		HK_Brightness                0x04
+#define		HK_Contrast                  0x05
+#define		HK_Mute                      0x06
+#define		HK_Volume                    0x07
+#define		ActivePAL                    0x0020
+#define		ActivePALShift               5
+#define		ActiveNonExpanding           0x40
+#define		ActiveNonExpandingShift      6
+#define		ActiveOverScan               0x80
+#define		ActiveOverScanShift          7
+
+#define		ModeSwitchStatus             0x0b       /* SR15 */
+#define		ActiveCRT1                   0x01
+#define		ActiveLCD                    0x02
+#define		ActiveCRT2                   0x08
+
+#define		TVSwitchStatus               0xf0       /* SR16 */
+#define		TVConfigShift                3
+#define		ActiveTV                     0x01
+#define		ActiveYPbPr                  0x04
+#define		ActiveAVideo                 0x10
+#define		ActiveSVideo                 0x0020
+#define		ActiveSCART                  0x40
+#define		ActiveHiTV                   0x80
+
+#define		EnableHKEvent                0x01       /* CR7A */
+#define		EnableOSDEvent               0x02
+#define		StartOSDEvent                0x04
+#define		CMOSSupport                  0x08
+#define		HotKeySupport                0x10
+#define		IngoreHKOSDEvent             0x20
+#endif
+
+/* //------------- Misc. Definition */
+#define		SelectCRT1Rate               00h
+/* #define SelectCRT2Rate 04h */
+
+#define		DDC1DelayTime                1000
+#ifdef           TRUMPION
+#define		DDC2DelayTime                15
+#else
+#define		DDC2DelayTime                150
+#endif
+
+#define		R_FACTOR                     04Dh
+#define		G_FACTOR                     097h
+#define		B_FACTOR                     01Ch
+/* --------------------------------------------------------- */
+/* translated from asm code 301def.h */
+/*  */
+/* --------------------------------------------------------- */
+#define		LCDDataLen                   8
+#define		HiTVDataLen                  12
+#define		TVDataLen                    12
+#define		LVDSCRT1Len_H                8
+#define		LVDSCRT1Len_V                7
+#define		LVDSDataLen                  6
+#define		LVDSDesDataLen               6
+#define		LCDDesDataLen                6
+#define		LVDSDesDataLen2              8
+#define		LCDDesDataLen2               8
+#define		CHTVRegLen                   16
+#define		CHLVRegLen                   12
+
+#define		StHiTVHT                     892
+#define		StHiTVVT                     1126
+#define		StHiTextTVHT                 1000
+#define		StHiTextTVVT                 1126
+#define		ExtHiTVHT                    2100
+#define		ExtHiTVVT                    1125
+#define		NTSCHT                       1716
+#define		NTSCVT                        525
+#define		NTSC1024x768HT               1908
+#define		NTSC1024x768VT                525
+#define		PALHT                        1728
+#define		PALVT                         625
+
+#define		YPbPrTV525iHT                1716            /* YPbPr */
+#define		YPbPrTV525iVT                 525
+#define		YPbPrTV525pHT                1716
+#define		YPbPrTV525pVT                 525
+#define		YPbPrTV750pHT                1650
+#define		YPbPrTV750pVT                 750
+
+#define		CRT2VCLKSel                  0xc0
+
+#define		CRT2Delay1      	     0x04            /* XGI301 */
+#define		CRT2Delay2      	     0x0A            /* 301B,302 */
+
+
+#define		VCLK25_175           0x00
+#define		VCLK28_322           0x01
+#define		VCLK31_5             0x02
+#define		VCLK36               0x03
+#define		VCLK40               0x04
+#define		VCLK43_163           0x05
+#define		VCLK44_9             0x06
+#define		VCLK49_5             0x07
+#define		VCLK50               0x08
+#define		VCLK52_406           0x09
+#define		VCLK56_25            0x0A
+#define		VCLK65               0x0B
+#define		VCLK67_765           0x0C
+#define		VCLK68_179           0x0D
+#define		VCLK72_852           0x0E
+#define		VCLK75               0x0F
+#define		VCLK75_8             0x10
+#define		VCLK78_75            0x11
+#define		VCLK79_411           0x12
+#define		VCLK83_95            0x13
+#define		VCLK84_8             0x14
+#define		VCLK86_6             0x15
+#define		VCLK94_5             0x16
+#define		VCLK104_998          0x17
+#define		VCLK105_882          0x18
+#define		VCLK108_2            0x19
+#define		VCLK109_175          0x1A
+#define		VCLK113_309          0x1B
+#define		VCLK116_406          0x1C
+#define		VCLK132_258          0x1D
+#define		VCLK135_5            0x1E
+#define		VCLK139_054          0x1F
+#define		VCLK157_5            0x20
+#define		VCLK162              0x21
+#define		VCLK175              0x22
+#define		VCLK189              0x23
+#define		VCLK194_4            0x24
+#define		VCLK202_5            0x25
+#define		VCLK229_5            0x26
+#define		VCLK234              0x27
+#define		VCLK252_699          0x28
+#define		VCLK254_817          0x29
+#define		VCLK265_728          0x2A
+#define		VCLK266_952          0x2B
+#define		VCLK269_655          0x2C
+#define		VCLK272_042          0x2D
+#define		VCLK277_015          0x2E
+#define		VCLK286_359          0x2F
+#define		VCLK291_132          0x30
+#define		VCLK291_766          0x31
+#define		VCLK309_789          0x32
+#define		VCLK315_195          0x33
+#define		VCLK323_586          0x34
+#define		VCLK330_615          0x35
+#define		VCLK332_177          0x36
+#define		VCLK340_477          0x37
+#define		VCLK375_847          0x38
+#define		VCLK388_631          0x39
+#define		VCLK125_999          0x51
+#define		VCLK148_5            0x52
+#define		VCLK178_992          0x54
+#define		VCLK217_325          0x55
+#define		VCLK299_505          0x56
+#define		YPbPr750pVCLK        0x57
+
+#define		TVVCLKDIV2              0x3A
+#define		TVVCLK                  0x3B
+#define		HiTVVCLKDIV2          0x3C
+#define		HiTVVCLK              0x3D
+#define		HiTVSimuVCLK          0x3E
+#define		HiTVTextVCLK          0x3F
+#define		VCLK39_77              0x40
+/* #define YPbPr750pVCLK 0x0F */
+#define		YPbPr525pVCLK           0x3A
+/* #define ;;YPbPr525iVCLK 0x3B */
+/* #define ;;YPbPr525iVCLK_2 0x3A */
+#define		NTSC1024VCLK         0x41
+#define		VCLK25_175_41        0x42                  /* ; ScaleLCD */
+#define		VCLK25_175_42        0x43
+#define		VCLK28_322_43        0x44
+#define		VCLK40_44            0x45
+#define		VCLKQVGA_1           0x46                   /* ; QVGA */
+#define		VCLKQVGA_2           0x47
+#define		VCLKQVGA_3           0x48
+#define		VCLK35_2             0x49                    /* ; 800x480 */
+#define		VCLK122_61           0x4A
+#define		VCLK80_350           0x4B
+#define		VCLK107_385          0x4C
+
+#define		CHTVVCLK30_2         0x50                 /* ;;CHTV */
+#define		CHTVVCLK28_1         0x51
+#define		CHTVVCLK43_6         0x52
+#define		CHTVVCLK26_4         0x53
+#define		CHTVVCLK24_6         0x54
+#define		CHTVVCLK47_8         0x55
+#define		CHTVVCLK31_5         0x56
+#define		CHTVVCLK26_2         0x57
+#define		CHTVVCLK39           0x58
+#define		CHTVVCLK36           0x59
+
+#define		CH7007TVVCLK30_2     0x00                 /* [Billy] 2007/05/18 For CH7007 */
+#define		CH7007TVVCLK28_1     0x01
+#define		CH7007TVVCLK43_6     0x02
+#define		CH7007TVVCLK26_4     0x03
+#define		CH7007TVVCLK24_6     0x04
+#define		CH7007TVVCLK47_8     0x05
+#define		CH7007TVVCLK31_5     0x06
+#define		CH7007TVVCLK26_2     0x07
+#define		CH7007TVVCLK39       0x08
+#define		CH7007TVVCLK36       0x09
+
+#define		RES320x200                   0x00
+#define		RES320x240                   0x01
+#define		RES400x300                   0x02
+#define		RES512x384                   0x03
+#define		RES640x400                   0x04
+#define		RES640x480x60                0x05
+#define		RES640x480x72                0x06
+#define		RES640x480x75                0x07
+#define		RES640x480x85                0x08
+#define		RES640x480x100               0x09
+#define		RES640x480x120               0x0A
+#define		RES640x480x160               0x0B
+#define		RES640x480x200               0x0C
+#define		RES800x600x56                0x0D
+#define		RES800x600x60                0x0E
+#define		RES800x600x72                0x0F
+#define		RES800x600x75                0x10
+#define		RES800x600x85                0x11
+#define		RES800x600x100               0x12
+#define		RES800x600x120               0x13
+#define		RES800x600x160               0x14
+#define		RES1024x768x43               0x15
+#define		RES1024x768x60               0x16
+#define		RES1024x768x70               0x17
+#define		RES1024x768x75               0x18
+#define		RES1024x768x85               0x19
+#define		RES1024x768x100              0x1A
+#define		RES1024x768x120              0x1B
+#define		RES1280x1024x43              0x1C
+#define		RES1280x1024x60              0x1D
+#define		RES1280x1024x75              0x1E
+#define		RES1280x1024x85              0x1F
+#define		RES1600x1200x60              0x20
+#define		RES1600x1200x65              0x21
+#define		RES1600x1200x70              0x22
+#define		RES1600x1200x75              0x23
+#define		RES1600x1200x85              0x24
+#define		RES1600x1200x100             0x25
+#define		RES1600x1200x120             0x26
+#define		RES1920x1440x60              0x27
+#define		RES1920x1440x65              0x28
+#define		RES1920x1440x70              0x29
+#define		RES1920x1440x75              0x2A
+#define		RES1920x1440x85              0x2B
+#define		RES1920x1440x100             0x2C
+#define		RES2048x1536x60              0x2D
+#define		RES2048x1536x65              0x2E
+#define		RES2048x1536x70              0x2F
+#define		RES2048x1536x75              0x30
+#define		RES2048x1536x85              0x31
+#define		RES800x480x60                0x32
+#define		RES800x480x75                0x33
+#define		RES800x480x85                0x34
+#define		RES1024x576x60               0x35
+#define		RES1024x576x75               0x36
+#define		RES1024x576x85               0x37
+#define		RES1280x720x60               0x38
+#define		RES1280x720x75               0x39
+#define		RES1280x720x85               0x3A
+#define		RES1280x960x60               0x3B
+#define		RES720x480x60                0x3C
+#define		RES720x576x56                0x3D
+#define		RES856x480x79I               0x3E
+#define		RES856x480x60                0x3F
+#define		RES1280x768x60               0x40
+#define		RES1400x1050x60              0x41
+#define		RES1152x864x60               0x42
+#define		RES1152x864x75               0x43
+#define		RES1024x768x160              0x44
+#define		RES1280x960x75               0x45
+#define		RES1280x960x85               0x46
+#define		RES1280x960x120              0x47
+
+#define 	LFBDRAMTrap                  0x30
+#endif
diff --git a/drivers/video/xgi/vb_ext.c b/drivers/video/xgi/vb_ext.c
new file mode 100644
index 0000000..b463ee7
--- /dev/null
+++ b/drivers/video/xgi/vb_ext.c
@@ -0,0 +1,1375 @@
+#include "osdef.h"
+
+
+
+
+#ifdef WIN2000
+
+#include <dderror.h>
+#include <devioctl.h>
+#include <miniport.h>
+#include <ntddvdeo.h>
+#include <video.h>
+#include "xgiv.h"
+#include "dd_i2c.h"
+#include "tools.h"
+#endif /* WIN2000 */
+
+#ifdef LINUX_XF86
+#include "xf86.h"
+#include "xf86PciInfo.h"
+#include "xgi.h"
+#include "xgi_regs.h"
+#endif
+
+#ifdef LINUX_KERNEL
+#include <linux/version.h>
+#include <asm/io.h>
+#include <linux/types.h>
+#include "XGIfb.h"
+/*#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#include <video/XGIfb.h>
+#else
+#include <linux/XGIfb.h>
+#endif*/
+#endif
+
+
+
+#include "vb_def.h"
+#include "vgatypes.h"
+#include "vb_struct.h"
+#include "vb_util.h"
+#include "vb_setmode.h"
+#include "vb_ext.h"
+extern   UCHAR XGI330_SoftSetting;
+extern   UCHAR XGI330_OutputSelect;
+extern   USHORT XGI330_RGBSenseData2;
+extern   USHORT XGI330_YCSenseData2;
+extern   USHORT XGI330_VideoSenseData2;
+#ifdef WIN2000
+extern   UCHAR SenseCHTV(PHW_DEVICE_EXTENSION pHWDE);       /* 2007/05/17 Billy */
+#endif
+void     XGI_GetSenseStatus( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo );
+BOOLEAN  XGINew_GetPanelID(PVB_DEVICE_INFO pVBInfo);
+USHORT   XGINew_SenseLCD(PXGI_HW_DEVICE_INFO,PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGINew_GetLCDDDCInfo(PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO pVBInfo);
+void XGISetDPMS( PXGI_HW_DEVICE_INFO pXGIHWDE , ULONG VESA_POWER_STATE ) ;
+BOOLEAN  XGINew_BridgeIsEnable(PXGI_HW_DEVICE_INFO,PVB_DEVICE_INFO pVBInfo );
+BOOLEAN  XGINew_Sense(USHORT tempbx,USHORT tempcx, PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGINew_SenseHiTV( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo ) ;
+
+/**************************************************************
+	Dynamic Sense
+*************************************************************/
+
+void XGI_WaitDisplay(void);
+BOOLEAN XGI_Is301C(PVB_DEVICE_INFO);
+BOOLEAN XGI_Is301LV(PVB_DEVICE_INFO);
+
+#ifdef WIN2000
+UCHAR XGI_SenseLCD(PHW_DEVICE_EXTENSION, PVB_DEVICE_INFO);
+UCHAR XGI_GetLCDDDCInfo(PHW_DEVICE_EXTENSION,PVB_DEVICE_INFO);
+
+extern BOOL bGetDdcInfo(
+PHW_DEVICE_EXTENSION  pHWDE,
+ULONG                 ulWhichOne,
+PUCHAR                pjQueryBuffer,
+ULONG                 ulBufferSize
+   );
+
+#endif
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_Is301B */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGINew_Is301B( PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT flag ;
+
+    flag = XGINew_GetReg1( pVBInfo->Part4Port , 0x01 ) ;
+
+    if ( flag > 0x0B0 )
+        return( 0 ) ;	/* 301b */
+    else
+        return( 1 ) ;
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_Is301C */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_Is301C( PVB_DEVICE_INFO pVBInfo )
+{
+    if ( ( XGINew_GetReg1( pVBInfo->Part4Port , 0x01 ) & 0xF0 ) == 0xC0 )
+        return( 1 ) ;
+
+    if ( XGINew_GetReg1( pVBInfo->Part4Port , 0x01 ) >= 0xD0 )
+    {
+        if ( XGINew_GetReg1( pVBInfo->Part4Port , 0x39 ) == 0xE0 )
+            return( 1 ) ;
+    }
+
+    return( 0 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_Is301LV */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_Is301LV( PVB_DEVICE_INFO pVBInfo )
+{
+    if ( XGINew_GetReg1( pVBInfo->Part4Port , 0x01 ) >= 0xD0 )
+    {
+        if ( XGINew_GetReg1( pVBInfo->Part4Port , 0x39 ) == 0xFF )
+        {
+            return( 1 ) ;
+        }
+    }
+    return( 0 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_Sense */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGINew_Sense(  USHORT tempbx , USHORT tempcx, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT temp , i , tempch ;
+
+    temp = tempbx & 0xFF ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x11 , temp ) ;
+    temp = ( tempbx & 0xFF00 ) >> 8 ;
+    temp |= ( tempcx & 0x00FF ) ;
+    XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x10 , ~0x1F , temp ) ;
+
+    for( i = 0 ; i < 10 ; i++ )
+        XGI_LongWait( pVBInfo) ;
+
+    tempch = ( tempcx & 0x7F00 ) >> 8 ;
+    temp = XGINew_GetReg1( pVBInfo->Part4Port , 0x03 ) ;
+    temp = temp ^ ( 0x0E ) ;
+    temp &= tempch ;
+
+    if ( temp > 0 )
+        return( 1 ) ;
+    else
+        return( 0 ) ;
+}
+
+#ifdef WIN2000
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SenseLCD */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+UCHAR XGI_SenseLCD( PHW_DEVICE_EXTENSION pHWDE, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempax , tempbx , tempcx ;
+    UCHAR SoftSetting = XGI330_SoftSetting ;
+
+    if ( pVBInfo->VBType & ( VB_XGI301LV | VB_XGI302LV ) )
+        return( 1 ) ;
+
+
+    if ( SoftSetting & HotPlugFunction )	/* Hot Plug Detection */
+    {
+        XGINew_SetRegAND( pVBInfo->Part4Port , 0x0F , 0x3F ) ;
+        tempbx = 0 ;
+        tempcx = 0x9010 ;
+        if ( XGINew_Sense( tempbx , tempcx, pVBInfo ) )
+            return( 1 ) ;
+
+        return( 0 ) ;
+    }
+    else	/* Get LCD Info from EDID */
+        return(XGI_GetLCDDDCInfo(pHWDE, pVBInfo));
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetLCDDDCInfo */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+UCHAR XGI_GetLCDDDCInfo( PHW_DEVICE_EXTENSION pHWDE , PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR tempah , tempbl , tempbh ;
+    USHORT tempbx , temp ;
+    UCHAR pjEDIDBuf[ 256 ] ;
+    ULONG ulBufferSize = 256 ;
+    UCHAR bMASK_OUTPUTSTATE_CRT2LCD = 2 ; /* 0423 shampoo */
+
+    bGetDdcInfo( pHWDE , MASK_OUTPUTSTATE_CRT2LCD , pjEDIDBuf , ulBufferSize ) ;
+    if ( ( *( ( PULONG )pjEDIDBuf ) == 0xFFFFFF00 ) && ( *( ( PULONG )( pjEDIDBuf + 4 ) ) == 0x00FFFFFF ) )
+    {
+        tempah = Panel1024x768 ;
+        tempbl=( *( pjEDIDBuf + 0x3A ) ) & 0xf0 ;
+
+        if ( tempbl != 0x40 )
+        {
+            tempah = Panel1600x1200 ;
+            if ( tempbl != 0x60 )
+            {
+                tempah = Panel1280x1024 ;
+                tempbh = ( *( pjEDIDBuf + 0x3B ) ) ;
+                if ( tempbh != 0x00 )
+                {
+                    tempah = Panel1280x960 ;
+                    if ( tempbh != 0x0C0 )
+                    {
+                        tempbx = ( ( *( pjEDIDBuf + 0x24 ) ) << 8 ) | ( *( pjEDIDBuf + 0x23 ) ) ;
+                        tempah = Panel1280x1024 ;
+                        if ( !( tempbx & 0x0100 ) )
+                        {
+                            tempah = Panel1024x768 ;
+                            if ( !( tempbx & 0x0E00 ) )
+                            {
+                                tempah = Panel1280x1024 ;
+                            }
+                        }
+                    }
+
+                    if ( tempbx & 0x00FF )
+                    {
+                        temp = ScalingLCD ;
+                        XGINew_SetRegOR( pVBInfo->P3d4 , 0x37 , temp ) ;
+                    }
+                }
+            }
+        }
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x36 , ( ~0x07 ) , tempah ) ;
+        tempah = ( ( *( pjEDIDBuf + 0x47 ) ) & 0x06 ) ;		/* Polarity */
+        tempah = ( tempah ^ 0x06 ) << 4 ;
+        tempah |= LCDSync ;
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x37 , ( ~LCDSyncBit ) , tempah ) ;
+        tempbh= XGINew_GetReg1( pVBInfo->P3d4 , 0x36 ) ;
+        tempbh &= 0x07 ;
+        if ( tempbh == Panel1280x960 )
+            XGINew_SetRegAND( pVBInfo->P3d4 , 0x37 , 0x0E ) ;
+    }
+    else if ( *pjEDIDBuf == 0x20 )
+    {
+        tempah = Panel1024x768 ;
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x36 , ( ~0x07 ) , tempah ) ;
+    }
+    else
+    {
+        return( 0 ) ;
+    }
+
+    return( 1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_DySense */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_DySense( PHW_DEVICE_EXTENSION pHWDE , PUCHAR ujConnectStatus)
+{
+    UCHAR pre_CRD,pre_SR1E , pre_Part2_0 , pre_Part4_D ;
+    USHORT tempax , tempbx , tempcx , pushax , temp ;
+    VB_DEVICE_INFO VBINF;
+    PVB_DEVICE_INFO pVBInfo = &VBINF;
+    UCHAR OutputSelect = XGI330_OutputSelect ;
+    PXGI_HW_DEVICE_INFO HwDeviceExtension= pHWDE->pXGIHWDE ;
+    UCHAR   bConnectStatus = 0 ;
+    pVBInfo->BaseAddr = HwDeviceExtension->pjIOAddress ;
+    pVBInfo->ROMAddr  = pHWDE->pjVirtualRomBase ;
+
+    pVBInfo->P3c2 = pVBInfo->BaseAddr + 0x12 ;
+    pVBInfo->P3c4 = pVBInfo->BaseAddr + 0x14 ;
+    pVBInfo->P3d4 = pVBInfo->BaseAddr + 0x24 ;
+    pVBInfo->Part2Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_10 ;
+    pVBInfo->Part4Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 ;
+    pushax = XGINew_GetReg1( pVBInfo->P3d4 , 0x17 ) ;	/* 0512 Fix Dysense hanged */
+    temp = ( pushax & 0x00FF ) | 0x80 ;
+    XGINew_SetRegOR( pVBInfo->P3d4 , 0x17 , temp ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x05 , 0x86 ) ;
+    /* beginning of dynamic sense CRT1 */
+
+    pVBInfo->IF_DEF_CH7007 = 0;
+    if (pHWDE->bCH7007)
+    {
+    	InitTo330Pointer( pHWDE->pXGIHWDE->jChipType, pVBInfo ) ;
+        HwDeviceExtension->pDevice = (PVOID)pHWDE;
+        pVBInfo->IF_DEF_CH7007 = 1;
+        /* [Billy] 2007/05/14 For CH7007 */
+        if ( pVBInfo->IF_DEF_CH7007 == 1 )  
+        {        
+           bConnectStatus = SenseCHTV(HwDeviceExtension->pDevice) ; /* 07/05/28 */ 
+           XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x32 , ~0x03 , (UCHAR)bConnectStatus ) ;
+        } 
+    }
+    if(( pHWDE->jChipID >= XG40 ) || ( pHWDE->jChipID >= XG20 ))
+    {
+
+        if ( pHWDE->jChipID >= XG40 )
+    	    XGINew_SetReg1( pVBInfo->P3d4 , 0x57 , 0x4A ) ;	/* write sense pattern 30->4a */
+    	else
+            XGINew_SetReg1( pVBInfo->P3d4 , 0x57 , 0x5F ) ;	/* write sense pattern */
+
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x53 , 0xFF , 0x02 ) ;	/* enable sense DAC */
+        XGI_WaitDisply(pVBInfo) ;
+
+        if(XGINew_GetReg2( pVBInfo->P3c2 ) & 0x10 )
+            bConnectStatus |= Monitor1Sense ;
+
+        XGINew_SetRegAND( pVBInfo->P3d4 , 0x53 , 0xFD ) ;	/* disable sense DAC */
+        XGINew_SetRegAND( pVBInfo->P3d4 , 0x57 , 0x00 ) ;	/* clear sense pattern */
+
+
+        /* ---------- End of dynamic sense CRT1 ----------- */
+
+        /* ---------- beginning of dynamic sense VB ------------ */
+        pre_SR1E = XGINew_GetReg1( pVBInfo->P3c4 , 0x1E ) ;
+        XGINew_SetRegOR( pVBInfo->P3c4 , 0x1E , 0x20 ) ;	/* Enable CRT2,work-a-round for 301B/301LV/302LV */
+        pre_Part2_0 = XGINew_GetReg1( pVBInfo->Part2Port , 0x00 ) ;
+        pre_Part4_D = XGINew_GetReg1( pVBInfo->Part4Port , 0x0D ) ;
+
+        if ( XGI_Is301C( pVBInfo ) )	/* 301C only */
+            XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x0D , ~0x07 , 0x01 ) ;	/* Set Part4 0x0D D[2:0] to 001b */
+
+        /* tempax = 0 ; */
+        if ( !XGI_Is301LV( pVBInfo ) )
+        {
+           tempbx = XGI330_RGBSenseData2 ;
+            tempcx = 0x0E08 ;
+            if(XGINew_Sense( tempbx , tempcx, pVBInfo ) )
+            {
+                bConnectStatus |= Monitor2Sense ;
+                if ( OutputSelect & SetSCARTOutput )
+                {
+                    bConnectStatus ^= ( Monitor2Sense | SCARTSense ) ;
+                }
+            }
+        }
+        if ( XGI_Is301C( pVBInfo ) )	/* 301C only */
+            XGINew_SetRegOR( pVBInfo->Part4Port , 0x0D , 0x04 ) ;	/* Set Part4 0x0D D[2]=1 for dynamic sense */
+
+        if ( ( XGINew_Is301B( pVBInfo ) ) )
+            XGINew_SetRegOR( pVBInfo->Part2Port , 0x00 , 0x0C ) ;    /* ????????? */
+
+	if ( XGINew_SenseHiTV( HwDeviceExtension , pVBInfo) )		/* add by kuku for Dysense HiTV //start */
+	{
+	    bConnectStatus|= YPbPrSense ;
+	}
+	else
+	{
+        tempbx = XGI330_YCSenseData2 ;	/* Y/C Sense Data Ptr */
+        tempcx = 0x0604 ;
+        if ( XGINew_Sense( tempbx , tempcx , pVBInfo) )
+            bConnectStatus |= SVIDEOSense ;
+
+        if ( OutputSelect & BoardTVType )
+        {
+            tempbx = XGI330_VideoSenseData2 ;
+            tempcx = 0x0804 ;
+            if ( XGINew_Sense(tempbx , tempcx, pVBInfo) )
+                bConnectStatus|= AVIDEOSense ;
+        }
+        else
+        {
+            if ( !( bConnectStatus & SVIDEOSense ) )
+            {
+                tempbx = XGI330_VideoSenseData2 ;
+                tempcx = 0x0804 ;
+                if ( XGINew_Sense( tempbx , tempcx, pVBInfo ) )
+                    bConnectStatus |= AVIDEOSense ;
+            }
+        }
+    	} /* end */
+        /* DySenseVBCnt */
+
+        tempbx = 0 ;
+        tempcx = 0 ;
+        XGINew_Sense(tempbx , tempcx, pVBInfo ) ;
+
+        if ( !( bConnectStatus & Monitor2Sense ) )
+        {
+            if ( XGI_SenseLCD( pHWDE , pVBInfo ) )
+                bConnectStatus |= LCDSense ;
+        }
+
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x32 , ~( AVIDEOSense | SVIDEOSense | LCDSense | Monitor2Sense | Monitor1Sense ) , bConnectStatus ) ;
+
+        XGINew_SetReg1( pVBInfo->Part4Port , 0x0D , pre_Part4_D ) ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x00 , pre_Part2_0 ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x1E , pre_SR1E ) ;
+
+        if ( XGI_Is301C( pVBInfo ) )	/* 301C only */
+        {
+            tempax = XGINew_GetReg1( pVBInfo->Part2Port , 0x00 ) ;
+            if ( tempax & 0x20 )
+            {
+                /* Reset VBPro */
+                for( tempcx = 2 ; tempcx > 0 ; tempcx-- )
+                {
+                    tempax ^= 0x20 ;
+                    XGINew_SetReg1( pVBInfo->Part2Port , 0x00 , tempax ) ;
+                }
+            }
+        }
+        /* End of dynamic sense VB */
+    }
+    else
+    {
+        XGI_SenseCRT1(pVBInfo) ;
+        XGI_GetSenseStatus( HwDeviceExtension, pVBInfo ) ;	/* sense CRT2 */
+        bConnectStatus = XGINew_GetReg1( pVBInfo->P3d4 , 0x32 ) ;
+    }
+    temp = pushax & 0x00FF ;		/* 0512 Fix Dysense hanged */
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x17 , temp ) ;
+    if ( bConnectStatus )
+    {
+        *ujConnectStatus = bConnectStatus ;
+        return( 1 ) ;
+    }
+    else
+        return( 0 ) ;
+}
+
+#endif /* WIN2000 */
+
+/* --------------------------------------------------------------------- */
+/* Function : XGISetDPMS */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+VOID XGISetDPMS( PXGI_HW_DEVICE_INFO pXGIHWDE , ULONG VESA_POWER_STATE )
+{
+    USHORT ModeNo, ModeIdIndex ;
+    UCHAR  temp ;
+    VB_DEVICE_INFO VBINF;
+    PVB_DEVICE_INFO pVBInfo = &VBINF;
+    pVBInfo->BaseAddr = pXGIHWDE->pjIOAddress ;
+    pVBInfo->ROMAddr  = pXGIHWDE->pjVirtualRomBase ;
+
+
+    pVBInfo->IF_DEF_LVDS = 0 ;
+    pVBInfo->IF_DEF_CH7005 = 0 ;
+    pVBInfo->IF_DEF_HiVision = 1 ;
+    pVBInfo->IF_DEF_LCDA = 1 ;
+    pVBInfo->IF_DEF_CH7017 = 0 ;
+    pVBInfo->IF_DEF_YPbPr = 1 ;
+    pVBInfo->IF_DEF_CRT2Monitor = 0 ;
+    pVBInfo->IF_DEF_VideoCapture = 0 ;
+    pVBInfo->IF_DEF_ScaleLCD = 0 ;
+    pVBInfo->IF_DEF_OEMUtil = 0 ;
+    pVBInfo->IF_DEF_PWD = 0 ;
+
+    InitTo330Pointer( pXGIHWDE->jChipType,  pVBInfo ) ;
+    ReadVBIOSTablData( pXGIHWDE->jChipType , pVBInfo) ;
+
+    pVBInfo->P3c4 = pVBInfo->BaseAddr + 0x14 ;
+    pVBInfo->P3d4 = pVBInfo->BaseAddr + 0x24 ;
+    pVBInfo->P3c0 = pVBInfo->BaseAddr + 0x10 ;
+    pVBInfo->P3ce = pVBInfo->BaseAddr + 0x1e ;
+    pVBInfo->P3c2 = pVBInfo->BaseAddr + 0x12 ;
+    pVBInfo->P3ca = pVBInfo->BaseAddr + 0x1a ;
+    pVBInfo->P3c6 = pVBInfo->BaseAddr + 0x16 ;
+    pVBInfo->P3c7 = pVBInfo->BaseAddr + 0x17 ;
+    pVBInfo->P3c8 = pVBInfo->BaseAddr + 0x18 ;
+    pVBInfo->P3c9 = pVBInfo->BaseAddr + 0x19 ;
+    pVBInfo->P3da = pVBInfo->BaseAddr + 0x2A ;
+    pVBInfo->Part0Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_00 ;
+    pVBInfo->Part1Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_04 ;
+    pVBInfo->Part2Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_10 ;
+    pVBInfo->Part3Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_12 ;
+    pVBInfo->Part4Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 ;
+    pVBInfo->Part5Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 + 2 ;
+
+    if ( pXGIHWDE->jChipType == XG27 )
+    {
+        if ( ( XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) & 0xE0 ) == 0xC0 )
+        {
+          if ( XGINew_GetReg1( pVBInfo->P3d4 , 0x30 ) & 0x20 )
+          {
+            pVBInfo->IF_DEF_LVDS = 1 ;
+          }
+        }
+    }
+
+    if ( pVBInfo->IF_DEF_CH7007 == 0 )
+    {
+        XGINew_SetModeScratch ( pXGIHWDE , pVBInfo ) ;
+    }
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x05 , 0x86 ) ;	/* 1.Openkey */
+    XGI_UnLockCRT2( pXGIHWDE , pVBInfo) ;
+    ModeNo = XGINew_GetReg1( pVBInfo->P3d4 , 0x34 ) ;
+    XGI_SearchModeID( ModeNo , &ModeIdIndex, pVBInfo ) ;
+    XGI_GetVGAType( pXGIHWDE , pVBInfo ) ;
+
+    if ( ( pXGIHWDE->ujVBChipID == VB_CHIP_301 ) || ( pXGIHWDE->ujVBChipID == VB_CHIP_302 ) || ( pVBInfo->IF_DEF_CH7007 == 1 ))
+    {
+        XGI_GetVBType( pVBInfo ) ;
+        XGI_GetVBInfo( ModeNo , ModeIdIndex , pXGIHWDE, pVBInfo ) ;
+        XGI_GetTVInfo( ModeNo , ModeIdIndex, pVBInfo ) ;
+        XGI_GetLCDInfo( ModeNo , ModeIdIndex, pVBInfo ) ;
+    }
+
+    if ( VESA_POWER_STATE == 0x00000400 )
+      XGINew_SetReg1( pVBInfo->Part4Port , 0x31 , ( UCHAR )( XGINew_GetReg1( pVBInfo->Part4Port , 0x31 ) & 0xFE ) ) ;
+    else
+      XGINew_SetReg1( pVBInfo->Part4Port , 0x31 , ( UCHAR )( XGINew_GetReg1( pVBInfo->Part4Port , 0x31 ) | 0x01 ) ) ;
+
+    temp = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x1f ) ;
+    temp &= 0x3f ;
+    switch ( VESA_POWER_STATE )
+    {
+        case 0x00000000: /* on */
+            if ( ( pXGIHWDE->ujVBChipID == VB_CHIP_301 ) || ( pXGIHWDE->ujVBChipID == VB_CHIP_302 ) )
+            {
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x1f , ( UCHAR )( temp | 0x00 ) ) ;
+                XGI_EnableBridge( pXGIHWDE, pVBInfo ) ;
+            }
+            else
+            {
+               if ( pXGIHWDE->jChipType == XG21 )
+               {
+                 if ( pVBInfo->IF_DEF_LVDS == 1 )
+                 {
+                   XGI_XG21BLSignalVDD( 0x01 , 0x01, pVBInfo ) ; /* LVDS VDD on */
+                   XGI_XG21SetPanelDelay( 2,pVBInfo ) ;
+                 }
+               }
+               if ( pXGIHWDE->jChipType == XG27 )
+               {
+                 if ( pVBInfo->IF_DEF_LVDS == 1 )
+                 {
+                   XGI_XG27BLSignalVDD( 0x01 , 0x01, pVBInfo ) ; /* LVDS VDD on */
+                   XGI_XG21SetPanelDelay( 2,pVBInfo ) ;
+                 }
+               }
+               XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x1F , ~0xC0 , 0x00 ) ;
+               XGINew_SetRegAND( pVBInfo->P3c4 , 0x01 , ~0x20 ) ;		/* CRT on */
+               
+               if ( pXGIHWDE->jChipType == XG21 )
+               {
+                 temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) ;
+                 if ( temp & 0xE0 )
+                 {
+                   XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x09 , ~0x80 , 0x80 ) ;	/* DVO ON */
+                   XGI_SetXG21FPBits( pVBInfo );
+                   XGINew_SetRegAND( pVBInfo->P3d4 , 0x4A , ~0x20 ) ; 		/* Enable write GPIOF */
+                   /*XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x48 , ~0x20 , 0x20 ) ;*/ 	/* LCD Display ON */
+                 }
+                 XGI_XG21BLSignalVDD( 0x20 , 0x20, pVBInfo ) ; /* LVDS signal on */
+                 XGI_DisplayOn( pXGIHWDE, pVBInfo );
+               } 
+               if ( pXGIHWDE->jChipType == XG27 )
+               {
+                 temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) ;
+                 if ( temp & 0xE0 )
+                 {
+                   XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x09 , ~0x80 , 0x80 ) ;	/* DVO ON */
+                   XGI_SetXG27FPBits( pVBInfo );
+                   XGINew_SetRegAND( pVBInfo->P3d4 , 0x4A , ~0x20 ) ; 		/* Enable write GPIOF */
+                   /*XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x48 , ~0x20 , 0x20 ) ;*/ 	/* LCD Display ON */
+                 }
+                 XGI_XG27BLSignalVDD( 0x20 , 0x20, pVBInfo ) ; /* LVDS signal on */
+                 XGI_DisplayOn( pXGIHWDE, pVBInfo );
+               } 
+            }
+            break ;
+        case 0x00000100: /* standby */
+            if ( pXGIHWDE->jChipType >= XG21 )
+            {
+                XGI_DisplayOff( pXGIHWDE, pVBInfo );
+            }
+            
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x1f , ( UCHAR )( temp | 0x40 ) ) ;
+            break ;
+        case 0x00000200: /* suspend */
+            if ( pXGIHWDE->jChipType == XG21 )
+            {
+                XGI_DisplayOff( pXGIHWDE, pVBInfo );
+                XGI_XG21BLSignalVDD( 0x20 , 0x00, pVBInfo ) ; /* LVDS signal off */
+            }
+            if ( pXGIHWDE->jChipType == XG27 )
+            {
+                XGI_DisplayOff( pXGIHWDE, pVBInfo );
+                XGI_XG27BLSignalVDD( 0x20 , 0x00, pVBInfo ) ; /* LVDS signal off */
+            }
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x1f , ( UCHAR )( temp | 0x80 ) ) ;
+            break ;
+        case 0x00000400: /* off */
+            if ( (pXGIHWDE->ujVBChipID == VB_CHIP_301 ) || ( pXGIHWDE->ujVBChipID == VB_CHIP_302 ) )
+            {
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x1f , ( UCHAR )( temp | 0xc0 ) ) ;
+                XGI_DisableBridge( pXGIHWDE, pVBInfo ) ;
+            }
+            else
+            {
+               if ( pXGIHWDE->jChipType == XG21 )
+               {
+                 XGI_DisplayOff( pXGIHWDE, pVBInfo );
+                 
+                 XGI_XG21BLSignalVDD( 0x20 , 0x00, pVBInfo ) ; /* LVDS signal off */
+
+                 temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) ;
+                 if ( temp & 0xE0 )
+                 {
+                   XGINew_SetRegAND( pVBInfo->P3c4 , 0x09 , ~0x80 ) ;		/* DVO Off */
+                   XGINew_SetRegAND( pVBInfo->P3d4 , 0x4A , ~0x20 ) ; 		/* Enable write GPIOF */
+                   /*XGINew_SetRegAND( pVBInfo->P3d4 , 0x48 , ~0x20 ) ;*/ 		/* LCD Display OFF */
+                 }
+               }
+               if ( pXGIHWDE->jChipType == XG27 )
+               {
+                 XGI_DisplayOff( pXGIHWDE, pVBInfo );
+                 
+                 XGI_XG27BLSignalVDD( 0x20 , 0x00, pVBInfo ) ; /* LVDS signal off */
+
+                 temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) ;
+                 if ( temp & 0xE0 )
+                 {
+                   XGINew_SetRegAND( pVBInfo->P3c4 , 0x09 , ~0x80 ) ;		/* DVO Off */
+                 }
+               }
+               XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x1F , ~0xC0 , 0xC0 ) ;
+               XGINew_SetRegOR( pVBInfo->P3c4 , 0x01 , 0x20 ) ;		/* CRT Off */
+               
+               if ( ( pXGIHWDE->jChipType == XG21 ) && ( pVBInfo->IF_DEF_LVDS == 1 ) )
+               {
+                 XGI_XG21SetPanelDelay( 4,pVBInfo ) ;
+                 XGI_XG21BLSignalVDD( 0x01 , 0x00, pVBInfo ) ; /* LVDS VDD off */
+                 XGI_XG21SetPanelDelay( 5,pVBInfo ) ;
+               }
+               if ( ( pXGIHWDE->jChipType == XG27 ) && ( pVBInfo->IF_DEF_LVDS == 1 ) )
+               {
+                 XGI_XG21SetPanelDelay( 4,pVBInfo ) ;
+                 XGI_XG27BLSignalVDD( 0x01 , 0x00, pVBInfo ) ; /* LVDS VDD off */
+                 XGI_XG21SetPanelDelay( 5,pVBInfo ) ;
+               }
+            }
+            break ;
+
+        default:
+            break ;
+    }
+    XGI_LockCRT2( pXGIHWDE , pVBInfo ) ;
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetSenseStatus */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetSenseStatus( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempax = 0 , tempbx , tempcx , temp ,
+           P2reg0 = 0 , SenseModeNo = 0 , OutputSelect = *pVBInfo->pOutputSelect ,
+           ModeIdIndex , i ;
+    pVBInfo->BaseAddr = HwDeviceExtension->pjIOAddress ;
+
+    if ( pVBInfo->IF_DEF_LVDS == 1 )
+    {
+        tempax = XGINew_GetReg1( pVBInfo->P3c4 , 0x1A ) ;	/* ynlai 02/27/2002 */
+        tempbx = XGINew_GetReg1( pVBInfo->P3c4 , 0x1B ) ;
+        tempax = ( ( tempax & 0xFE ) >> 1 ) | ( tempbx << 8 ) ;
+        if ( tempax == 0x00 )
+        {		/* Get Panel id from DDC */
+            temp = XGINew_GetLCDDDCInfo( HwDeviceExtension, pVBInfo ) ;
+            if ( temp == 1 )
+            {		/* LCD connect */
+                XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x39 , 0xFF , 0x01 ) ;	/* set CR39 bit0="1" */
+                XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x37 , 0xEF , 0x00 ) ;	/* clean CR37 bit4="0" */
+                temp = LCDSense ;
+            }
+            else
+            {		/* LCD don't connect */
+                temp = 0 ;
+            }
+        }
+        else
+        {
+            XGINew_GetPanelID(pVBInfo) ;
+            temp = LCDSense ;
+        }
+
+        tempbx = ~( LCDSense | AVIDEOSense | SVIDEOSense ) ;
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x32 , tempbx , temp ) ;
+    }
+    else
+    {		/* for 301 */
+        if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+        {	/* for HiVision */
+            tempax = XGINew_GetReg1( pVBInfo->P3c4 , 0x38 ) ;
+            temp = tempax & 0x01 ;
+            tempax = XGINew_GetReg1( pVBInfo->P3c4 , 0x3A ) ;
+            temp = temp | ( tempax & 0x02 ) ;
+            XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x32 , 0xA0 , temp ) ;
+        }
+        else
+        {
+            if ( XGI_BridgeIsOn( pVBInfo ) )
+            {
+                P2reg0 = XGINew_GetReg1( pVBInfo->Part2Port , 0x00 ) ;
+                if ( !XGINew_BridgeIsEnable( HwDeviceExtension, pVBInfo ) )
+                {
+                    SenseModeNo = 0x2e ;
+                    /* XGINew_SetReg1( pVBInfo->P3d4 , 0x30 , 0x41 ) ; */
+                    /* XGISetModeNew( HwDeviceExtension , 0x2e ) ; // ynlai InitMode */
+
+                    temp = XGI_SearchModeID( SenseModeNo , &ModeIdIndex, pVBInfo ) ;
+                    XGI_GetVGAType( HwDeviceExtension , pVBInfo) ;
+                    XGI_GetVBType( pVBInfo ) ;
+                    pVBInfo->SetFlag = 0x00 ;
+                    pVBInfo->ModeType = ModeVGA ;
+                    pVBInfo->VBInfo = SetCRT2ToRAMDAC | LoadDACFlag | SetInSlaveMode ;
+                    XGI_GetLCDInfo( 0x2e , ModeIdIndex, pVBInfo ) ;
+                    XGI_GetTVInfo(  0x2e , ModeIdIndex, pVBInfo ) ;
+                    XGI_EnableBridge( HwDeviceExtension, pVBInfo ) ;
+                    XGI_SetCRT2Group301( SenseModeNo , HwDeviceExtension, pVBInfo ) ;
+                    XGI_SetCRT2ModeRegs( 0x2e , HwDeviceExtension, pVBInfo ) ;
+                    /* XGI_DisableBridge( HwDeviceExtension, pVBInfo ) ; */
+                    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x01 , 0xDF , 0x20 ) ;	/* Display Off 0212 */
+                    for( i = 0 ; i < 20 ; i++ )
+                    {
+                        XGI_LongWait(pVBInfo) ;
+                    }
+                }
+                XGINew_SetReg1( pVBInfo->Part2Port , 0x00 , 0x1c ) ;
+                tempax = 0 ;
+                tempbx = *pVBInfo->pRGBSenseData ;
+
+                if ( !( XGINew_Is301B( pVBInfo ) ) )
+                {
+                    tempbx = *pVBInfo->pRGBSenseData2 ;
+                }
+
+                tempcx = 0x0E08 ;
+                if ( XGINew_Sense(tempbx , tempcx, pVBInfo ) )
+                {
+                    if ( XGINew_Sense(tempbx , tempcx, pVBInfo ) )
+                    {
+                        tempax |= Monitor2Sense ;
+                    }
+                }
+
+                if ( pVBInfo->VBType & VB_XGI301C)
+                {
+                    XGINew_SetRegOR( pVBInfo->Part4Port , 0x0d , 0x04 ) ;
+                }
+
+		if ( XGINew_SenseHiTV( HwDeviceExtension , pVBInfo) )		/* add by kuku for Multi-adapter sense HiTV */
+		{
+		    tempax |= HiTVSense ;
+                    if ( ( pVBInfo->VBType & VB_XGI301C ) )
+                    {
+                	tempax ^= ( HiTVSense | YPbPrSense ) ;
+                    }
+                }
+
+		if ( !( tempax & ( HiTVSense | YPbPrSense ) ) )		/* start */
+                {
+
+                    tempbx = *pVBInfo->pYCSenseData ;
+
+                    if ( !( XGINew_Is301B(  pVBInfo ) ) )
+                    {
+                      tempbx=*pVBInfo->pYCSenseData2;
+                    }
+
+                    tempcx = 0x0604 ;
+                    if ( XGINew_Sense(tempbx , tempcx, pVBInfo ) )
+                    {
+                      if ( XGINew_Sense(tempbx , tempcx, pVBInfo ) )
+                      {
+                          tempax |= SVIDEOSense ;
+                      }
+                    }
+
+                    if ( OutputSelect & BoardTVType )
+                    {
+                      tempbx = *pVBInfo->pVideoSenseData ;
+
+                      if ( !( XGINew_Is301B( pVBInfo ) ) )
+                      {
+                          tempbx = *pVBInfo->pVideoSenseData2 ;
+                      }
+
+                      tempcx = 0x0804 ;
+                      if ( XGINew_Sense(tempbx , tempcx, pVBInfo ) )
+                      {
+                          if ( XGINew_Sense(tempbx , tempcx, pVBInfo ) )
+                          {
+                              tempax |= AVIDEOSense ;
+                          }
+                      }
+                    }
+                    else
+                    {
+                      if ( !( tempax & SVIDEOSense ) )
+                      {
+                        tempbx = *pVBInfo->pVideoSenseData ;
+
+                        if ( !( XGINew_Is301B( pVBInfo ) ) )
+                        {
+                            tempbx=*pVBInfo->pVideoSenseData2;
+                        }
+
+                        tempcx = 0x0804 ;
+                        if ( XGINew_Sense(tempbx , tempcx, pVBInfo ) )
+                        {
+                            if ( XGINew_Sense(tempbx , tempcx, pVBInfo ) )
+                            {
+                                tempax |= AVIDEOSense ;
+                            }
+                        }
+                      }
+                    }
+                }
+    	    } /* end */
+            if ( !( tempax & Monitor2Sense ) )
+            {
+                if ( XGINew_SenseLCD( HwDeviceExtension, pVBInfo ) )
+                {
+                    tempax |= LCDSense ;
+                }
+            }
+            tempbx = 0 ;
+            tempcx = 0 ;
+            XGINew_Sense(tempbx , tempcx, pVBInfo ) ;
+
+            XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x32 , ~0xDF , tempax ) ;
+            XGINew_SetReg1( pVBInfo->Part2Port , 0x00 , P2reg0 ) ;
+
+            if ( !( P2reg0 & 0x20 ) )
+            {
+                pVBInfo->VBInfo = DisableCRT2Display ;
+                /* XGI_SetCRT2Group301( SenseModeNo , HwDeviceExtension, pVBInfo ) ; */
+            }
+        }
+    }
+    XGI_DisableBridge( HwDeviceExtension, pVBInfo ) ;		/* shampoo 0226 */
+    
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SenseLCD */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT XGINew_SenseLCD( PXGI_HW_DEVICE_INFO HwDeviceExtension ,PVB_DEVICE_INFO pVBInfo)
+{
+    /* USHORT SoftSetting ; */
+    USHORT temp ;
+
+    if ( ( HwDeviceExtension->jChipType >= XG20 ) || ( HwDeviceExtension->jChipType >= XG40 ) )
+        temp = 0 ;
+    else
+        temp=XGINew_GetPanelID(pVBInfo) ;
+
+    if( !temp )
+        temp = XGINew_GetLCDDDCInfo( HwDeviceExtension, pVBInfo ) ;
+
+    return( temp ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_GetLCDDDCInfo */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGINew_GetLCDDDCInfo( PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT temp ;
+
+    /* add lcd sense */
+    if ( HwDeviceExtension->ulCRT2LCDType == LCD_UNKNOWN )
+    {
+        return( 0 ) ;
+    }
+    else
+    {
+        temp = ( USHORT )HwDeviceExtension->ulCRT2LCDType ;
+        switch( HwDeviceExtension->ulCRT2LCDType )
+        {
+            case LCD_INVALID:
+            case LCD_800x600:
+            case LCD_1024x768:
+            case LCD_1280x1024:
+                break ;
+
+            case LCD_640x480:
+            case LCD_1024x600:
+            case LCD_1152x864:
+            case LCD_1280x960:
+            case LCD_1152x768:
+                temp = 0 ;
+                break ;
+
+            case LCD_1400x1050:
+            case LCD_1280x768:
+            case LCD_1600x1200:
+                break ;
+
+            case LCD_1920x1440:
+            case LCD_2048x1536:
+                temp = 0 ;
+                break ;
+
+            default:
+                break ;
+        }
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x36 , 0xF0 , temp ) ;
+        return( 1 ) ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGINew_GetPanelID(PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT PanelTypeTable[ 16 ] = { SyncNN | PanelRGB18Bit | Panel800x600  | _PanelType00 ,
+                                    SyncNN | PanelRGB18Bit | Panel1024x768 | _PanelType01 ,
+                                    SyncNN | PanelRGB18Bit | Panel800x600  | _PanelType02 ,
+                                    SyncNN | PanelRGB18Bit | Panel640x480  | _PanelType03 ,
+                                    SyncNN | PanelRGB18Bit | Panel1024x768 | _PanelType04 ,
+                                    SyncNN | PanelRGB18Bit | Panel1024x768 | _PanelType05 ,
+                                    SyncNN | PanelRGB18Bit | Panel1024x768 | _PanelType06 ,
+                                    SyncNN | PanelRGB24Bit | Panel1024x768 | _PanelType07 ,
+                                    SyncNN | PanelRGB18Bit | Panel800x600  | _PanelType08 ,
+                                    SyncNN | PanelRGB18Bit | Panel1024x768 | _PanelType09 ,
+                                    SyncNN | PanelRGB18Bit | Panel800x600  | _PanelType0A ,
+                                    SyncNN | PanelRGB18Bit | Panel1024x768 | _PanelType0B ,
+                                    SyncNN | PanelRGB18Bit | Panel1024x768 | _PanelType0C ,
+                                    SyncNN | PanelRGB24Bit | Panel1024x768 | _PanelType0D ,
+                                    SyncNN | PanelRGB18Bit | Panel1024x768 | _PanelType0E ,
+                                    SyncNN | PanelRGB18Bit | Panel1024x768 | _PanelType0F } ;
+    USHORT tempax , tempbx , temp ;
+    /* USHORT return_flag ; */
+
+    tempax = XGINew_GetReg1( pVBInfo->P3c4 , 0x1A ) ;
+    tempbx = tempax & 0x1E ;
+
+    if ( tempax == 0 )
+        return( 0 ) ;
+    else
+    {
+/*
+        if ( !( tempax & 0x10 ) )
+        {
+            if ( pVBInfo->IF_DEF_LVDS == 1 )
+            {
+                tempbx = 0 ;
+                temp = XGINew_GetReg1( pVBInfo->P3c4 , 0x38 ) ;
+                if ( temp & 0x40 )
+                    tempbx |= 0x08 ;
+                if ( temp & 0x20 )
+                    tempbx |= 0x02 ;
+                if ( temp & 0x01 )
+                    tempbx |= 0x01 ;
+
+                temp = XGINew_GetReg1( pVBInfo->P3c4 , 0x39 ) ;
+                if ( temp & 0x80 )
+                    tempbx |= 0x04 ;
+            }
+            else
+            {
+                return( 0 ) ;
+            }
+        }
+*/
+
+        tempbx = tempbx >> 1 ;
+        temp = tempbx & 0x00F ;
+        XGINew_SetReg1( pVBInfo->P3d4 , 0x36 , temp ) ;
+        tempbx-- ;
+        tempbx = PanelTypeTable[ tempbx ] ;
+
+        temp = ( tempbx & 0xFF00 ) >> 8 ;
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x37 , ~( LCDSyncBit | LCDRGB18Bit ) , temp ) ;
+        return( 1 ) ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_BridgeIsEnable */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGINew_BridgeIsEnable( PXGI_HW_DEVICE_INFO HwDeviceExtension ,PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT flag ;
+
+    if ( XGI_BridgeIsOn( pVBInfo ) == 0 )
+    {
+        flag = XGINew_GetReg1( pVBInfo->Part1Port , 0x0 ) ;
+
+        if ( flag & 0x050 )
+        {
+            return( 1 ) ;
+        }
+        else
+        {
+            return( 0 ) ;
+        }
+
+    }
+    return( 0 ) ;
+}
+
+/* ------------------------------------------------------ */
+/* Function : XGINew_SenseHiTV */
+/* Input : */
+/* Output : */
+/* Description : */
+/* ------------------------------------------------------ */
+BOOLEAN XGINew_SenseHiTV( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempbx , tempcx , temp , i , tempch;
+#ifndef LINUX_XF86
+    USHORT tempax ;
+#endif
+
+    tempbx = *pVBInfo->pYCSenseData2 ;
+
+    tempcx = 0x0604 ;
+
+    temp = tempbx & 0xFF ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x11 , temp ) ;
+    temp = ( tempbx & 0xFF00 ) >> 8 ;
+    temp |= ( tempcx & 0x00FF ) ;
+    XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x10 , ~0x1F , temp ) ;
+
+    for( i = 0 ; i < 10 ; i++ )
+        XGI_LongWait(pVBInfo) ;
+
+    tempch = ( tempcx & 0xFF00 ) >> 8;
+    temp = XGINew_GetReg1( pVBInfo->Part4Port , 0x03 ) ;
+    temp = temp ^ ( 0x0E ) ;
+    temp &= tempch ;
+
+    if ( temp !=  tempch )
+        return( 0 ) ;
+
+    tempbx = *pVBInfo->pVideoSenseData2 ;
+
+    tempcx = 0x0804 ;
+    temp = tempbx & 0xFF ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x11 , temp ) ;
+    temp = ( tempbx & 0xFF00 ) >> 8 ;
+    temp |= ( tempcx & 0x00FF ) ;
+    XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x10 , ~0x1F , temp ) ;
+
+    for( i = 0 ; i < 10 ; i++ )
+        XGI_LongWait(pVBInfo) ;
+
+    tempch = ( tempcx & 0xFF00 ) >> 8;
+    temp = XGINew_GetReg1( pVBInfo->Part4Port , 0x03 ) ;
+    temp = temp ^ ( 0x0E ) ;
+    temp &= tempch ;
+
+    if ( temp !=  tempch )
+        return( 0 ) ;
+    else
+    {
+      tempbx = 0x3FF ;
+      tempcx = 0x0804 ;
+      temp = tempbx & 0xFF ;
+      XGINew_SetReg1( pVBInfo->Part4Port , 0x11 , temp ) ;
+      temp = ( tempbx & 0xFF00 ) >> 8 ;
+      temp |= ( tempcx & 0x00FF ) ;
+      XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x10 , ~0x1F , temp ) ;
+
+      for( i = 0 ; i < 10 ; i++ )
+          XGI_LongWait(pVBInfo) ;
+
+      tempch = ( tempcx & 0xFF00 ) >> 8;
+      temp = XGINew_GetReg1( pVBInfo->Part4Port , 0x03 ) ;
+      temp = temp ^ ( 0x0E ) ;
+      temp &= tempch ;
+
+      if ( temp != tempch )
+          return( 1 ) ;
+      else
+	  return( 0 ) ;
+    }
+}
+
+
+
+/*
+;-----------------------------------------------------------------------------
+;       Description: Get Panel support
+;	O/P	   : 
+;            BL: Panel ID=81h for no scaler LVDS
+;		     BH: Panel enhanced Mode Count
+;		     CX: Panel H. resolution
+;		     DX: PAnel V. resolution
+;-----------------------------------------------------------------------------
+*/
+void XGI_XG21Fun14Sub70( PVB_DEVICE_INFO pVBInfo , PX86_REGS pBiosArguments )
+{
+    
+    USHORT ModeIdIndex;
+    USHORT ModeNo;
+
+    USHORT EModeCount;
+    USHORT lvdstableindex;
+    
+    lvdstableindex = XGI_GetLVDSOEMTableIndex( pVBInfo );
+    pBiosArguments->h.bl = 0x81;
+    pBiosArguments->x.cx = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHDE;
+    pBiosArguments->x.dx = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVDE;
+    EModeCount = 0;
+    
+    pBiosArguments->x.ax = 0x0014;
+    for( ModeIdIndex = 0 ; ;  ModeIdIndex ++ )
+    {
+        ModeNo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeID;
+        if ( pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeID == 0xFF )
+        {
+            pBiosArguments->h.bh = (UCHAR) EModeCount;
+            return;
+        }
+        if ( !XGI_XG21CheckLVDSMode( ModeNo , ModeIdIndex, pVBInfo) )
+        {
+          continue;
+        }
+        EModeCount++ ;
+    }
+}
+/*(
+;-----------------------------------------------------------------------------
+;
+;       Description: Get Panel mode ID for enhanced mode
+;	I/P	   : BH: EModeIndex ( which < Panel enhanced Mode Count )
+;	O/P	   : 
+;            BL: Mode ID
+;		     CX: H. resolution of the assigned by the index
+;		     DX: V. resolution of the assigned by the index
+;
+;-----------------------------------------------------------------------------
+*/
+void XGI_XG21Fun14Sub71( PVB_DEVICE_INFO pVBInfo , PX86_REGS pBiosArguments )
+{
+    
+    USHORT EModeCount;
+    USHORT ModeIdIndex,resindex;
+    USHORT ModeNo;
+    USHORT EModeIndex = pBiosArguments->h.bh;
+
+    EModeCount = 0;
+    for( ModeIdIndex = 0 ; ;  ModeIdIndex ++ )
+    {
+        ModeNo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeID;
+        if ( pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeID == 0xFF )
+        {
+            pBiosArguments->x.ax = 0x0114;
+            return;
+        }
+        if ( !XGI_XG21CheckLVDSMode( ModeNo , ModeIdIndex, pVBInfo) )
+        {
+          continue;
+        }
+        if (EModeCount == EModeIndex)
+        {
+            resindex = XGI_GetResInfo( ModeNo , ModeIdIndex, pVBInfo ) ;
+            pBiosArguments->h.bl = (UCHAR) ModeNo;
+            pBiosArguments->x.cx = pVBInfo->ModeResInfo[ resindex ].HTotal ;			  /* xres->ax */
+            pBiosArguments->x.dx = pVBInfo->ModeResInfo[ resindex ].VTotal ;			  /* yres->bx */
+            pBiosArguments->x.ax = 0x0014;
+        }
+        EModeCount++ ;
+        
+    }
+    
+}
+/*
+;-----------------------------------------------------------------------------
+;
+;       Description: Validate Panel modes ID support
+;	I/P	   : 
+;            BL: ModeID
+;	O/P	   : 
+;		     CX: H. resolution of the assigned by the index
+;		     DX: V. resolution of the assigned by the index
+;
+;-----------------------------------------------------------------------------
+*/
+void XGI_XG21Fun14Sub72( PVB_DEVICE_INFO pVBInfo , PX86_REGS pBiosArguments )
+{
+    
+    USHORT EModeCount;
+    USHORT ModeIdIndex,resindex;
+    USHORT ModeNo;
+
+
+    ModeNo = pBiosArguments->h.bl ;
+    XGI_SearchModeID( ModeNo, &ModeIdIndex, pVBInfo);
+    if ( !XGI_XG21CheckLVDSMode( ModeNo , ModeIdIndex, pVBInfo) )
+    {
+        pBiosArguments->x.cx = 0;
+        pBiosArguments->x.dx = 0;
+        pBiosArguments->x.ax = 0x0114;
+        return;
+    }
+    resindex = XGI_GetResInfo( ModeNo , ModeIdIndex, pVBInfo ) ;
+    if ( ModeNo <= 0x13 )
+    {
+        pBiosArguments->x.cx = pVBInfo->StResInfo[ resindex ].HTotal ;
+        pBiosArguments->x.dx = pVBInfo->StResInfo[ resindex ].VTotal ;
+    }
+    else
+    {
+        pBiosArguments->x.cx = pVBInfo->ModeResInfo[ resindex ].HTotal ;			  /* xres->ax */
+        pBiosArguments->x.dx = pVBInfo->ModeResInfo[ resindex ].VTotal ;			  /* yres->bx */
+    }
+
+    pBiosArguments->x.ax = 0x0014;
+    
+}
+
+/*
+;-----------------------------------------------------------------------------
+;	Description: Get Customized Panel misc. information support
+;	I/P	   : Select
+;		     to get panel horizontal timing
+;			 to get panel vertical timing
+;			 to get channel clock parameter
+;            to get panel misc information
+;
+;	O/P	   : 
+;		     BL: for input Select = 0 ;		     
+;                       BX: *Value1 = Horizontal total
+;                       CX: *Value2 = Horizontal front porch
+;                       DX: *Value2 = Horizontal sync width  
+;		     BL: for input Select = 1 ;
+;                       BX: *Value1 = Vertical total
+;                       CX: *Value2 = Vertical front porch
+;                       DX: *Value2 = Vertical sync width    
+;            BL: for input Select = 2 ;
+;                       BX: Value1 = The first CLK parameter
+;                       CX: Value2 = The second CLK parameter
+;		     BL: for input Select = 4 ;
+;                       BX[15]: *Value1 D[15] VESA V. Polarity
+;                       BX[14]: *Value1 D[14] VESA H. Polarity
+;                       BX[7]: *Value1 D[7] Panel V. Polarity
+;                       BX[6]: *Value1 D[6] Panel H. Polarity
+;-----------------------------------------------------------------------------
+*/
+void XGI_XG21Fun14Sub73( PVB_DEVICE_INFO pVBInfo , PX86_REGS pBiosArguments )
+{
+    UCHAR Select;
+    
+    USHORT lvdstableindex;
+    
+    lvdstableindex = XGI_GetLVDSOEMTableIndex( pVBInfo );
+    Select = pBiosArguments->h.bl;
+
+    switch (Select)
+    {
+        case 0: 
+                pBiosArguments->x.bx = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHT;
+                pBiosArguments->x.cx = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHFP;
+                pBiosArguments->x.dx = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHSYNC;
+                break;
+        case 1: 
+                pBiosArguments->x.bx = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVT;
+                pBiosArguments->x.cx = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVFP;
+                pBiosArguments->x.dx = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVSYNC;
+                break;
+        case 2: 
+                pBiosArguments->x.bx = pVBInfo->XG21_LVDSCapList[lvdstableindex].VCLKData1;
+                pBiosArguments->x.cx = pVBInfo->XG21_LVDSCapList[lvdstableindex].VCLKData2;
+                break;
+        case 4: 
+                pBiosArguments->x.bx = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDS_Capability;
+                break;
+    }
+    
+    pBiosArguments->x.ax = 0x0014;
+}
+
+
+void XGI_XG21Fun14( PXGI_HW_DEVICE_INFO pXGIHWDE, PX86_REGS pBiosArguments)
+{
+    VB_DEVICE_INFO VBINF;
+    PVB_DEVICE_INFO pVBInfo = &VBINF;
+
+    pVBInfo->IF_DEF_LVDS = 0 ;
+    pVBInfo->IF_DEF_CH7005 = 0 ;
+    pVBInfo->IF_DEF_HiVision = 1 ;
+    pVBInfo->IF_DEF_LCDA = 1 ;
+    pVBInfo->IF_DEF_CH7017 = 0 ;
+    pVBInfo->IF_DEF_YPbPr = 1 ;
+    pVBInfo->IF_DEF_CRT2Monitor = 0 ;
+    pVBInfo->IF_DEF_VideoCapture = 0 ;
+    pVBInfo->IF_DEF_ScaleLCD = 0 ;
+    pVBInfo->IF_DEF_OEMUtil = 0 ;
+    pVBInfo->IF_DEF_PWD = 0 ;
+
+    InitTo330Pointer( pXGIHWDE->jChipType,  pVBInfo ) ;
+    ReadVBIOSTablData( pXGIHWDE->jChipType , pVBInfo) ;
+
+    pVBInfo->P3c4 = pVBInfo->BaseAddr + 0x14 ;
+    pVBInfo->P3d4 = pVBInfo->BaseAddr + 0x24 ;
+    pVBInfo->P3c0 = pVBInfo->BaseAddr + 0x10 ;
+    pVBInfo->P3ce = pVBInfo->BaseAddr + 0x1e ;
+    pVBInfo->P3c2 = pVBInfo->BaseAddr + 0x12 ;
+    pVBInfo->P3ca = pVBInfo->BaseAddr + 0x1a ;
+    pVBInfo->P3c6 = pVBInfo->BaseAddr + 0x16 ;
+    pVBInfo->P3c7 = pVBInfo->BaseAddr + 0x17 ;
+    pVBInfo->P3c8 = pVBInfo->BaseAddr + 0x18 ;
+    pVBInfo->P3c9 = pVBInfo->BaseAddr + 0x19 ;
+    pVBInfo->P3da = pVBInfo->BaseAddr + 0x2A ;
+    pVBInfo->Part0Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_00 ;
+    pVBInfo->Part1Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_04 ;
+    pVBInfo->Part2Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_10 ;
+    pVBInfo->Part3Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_12 ;
+    pVBInfo->Part4Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 ;
+    pVBInfo->Part5Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 + 2 ;
+    
+    switch(pBiosArguments->x.ax)
+    {
+    case 0x1470:
+         XGI_XG21Fun14Sub70( pVBInfo , pBiosArguments ) ;
+         break;
+    case 0x1471:
+         XGI_XG21Fun14Sub71( pVBInfo , pBiosArguments ) ;
+         break;
+    case 0x1472:
+         XGI_XG21Fun14Sub72( pVBInfo , pBiosArguments ) ;
+         break;
+    case 0x1473:
+         XGI_XG21Fun14Sub73( pVBInfo , pBiosArguments ) ;
+         break;
+    }
+}
diff --git a/drivers/video/xgi/vb_ext.h b/drivers/video/xgi/vb_ext.h
new file mode 100644
index 0000000..54557a8
--- /dev/null
+++ b/drivers/video/xgi/vb_ext.h
@@ -0,0 +1,32 @@
+#ifndef  _VBEXT_
+#define  _VBEXT_
+
+struct DWORDREGS {
+    ULONG    Eax, Ebx, Ecx, Edx, Esi, Edi, Ebp;
+};
+
+struct WORDREGS {
+    USHORT    ax, hi_ax, bx, hi_bx, cx, hi_cx, dx, hi_dx, si, hi_si, di ,hi_di, bp, hi_bp;
+};
+
+struct BYTEREGS {
+    UCHAR   al, ah, hi_al, hi_ah, bl, bh, hi_bl, hi_bh, cl, ch, hi_cl, hi_ch, dl, dh, hi_dl, hi_dh;
+};
+
+typedef union   _X86_REGS    {
+    struct  DWORDREGS e;    
+    struct  WORDREGS x;
+    struct  BYTEREGS h;
+} X86_REGS, *PX86_REGS;
+
+extern   void     XGI_XG21Fun14( PXGI_HW_DEVICE_INFO pXGIHWDE, PX86_REGS pBiosArguments);
+extern   void     XGISetDPMS( PXGI_HW_DEVICE_INFO pXGIHWDE , ULONG VESA_POWER_STATE ) ;
+extern   void     XGI_GetSenseStatus( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo );
+extern   void     XGINew_SetModeScratch ( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo ) ;
+extern   void 	  ReadVBIOSTablData( UCHAR ChipType , PVB_DEVICE_INFO pVBInfo);
+extern   USHORT   XGINew_SenseLCD(PXGI_HW_DEVICE_INFO,PVB_DEVICE_INFO pVBInfo);
+#ifdef WIN2000
+extern   BOOLEAN  XGI_DySense( PHW_DEVICE_EXTENSION pHWDE , PUCHAR ujConnectStatus );
+#endif /* WIN2000 */
+
+#endif
diff --git a/drivers/video/xgi/vb_init.c b/drivers/video/xgi/vb_init.c
new file mode 100644
index 0000000..22c02b8
--- /dev/null
+++ b/drivers/video/xgi/vb_init.c
@@ -0,0 +1,3376 @@
+#include "osdef.h"
+#include "vgatypes.h"
+
+
+#ifdef LINUX_KERNEL
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/delay.h> /* udelay */
+#include "XGIfb.h"
+/*#if LINUX_VERSxION_CODE >= KERNEL_VERSION(2,5,0)
+#include <video/XGIfb.h>
+#else
+#include <linux/XGIfb.h>
+#endif */
+#endif
+
+#ifdef WIN2000
+#include <dderror.h>
+#include <devioctl.h>
+#include <miniport.h>
+#include <ntddvdeo.h>
+#include <video.h>
+#include "xgiv.h"
+#include "dd_i2c.h"
+#include "tools.h"
+#endif
+
+#include "vb_def.h"
+#include "vb_struct.h"
+#include "vb_util.h"
+#include "vb_setmode.h"
+#include "vb_init.h"
+#include "vb_ext.h"
+
+#ifdef LINUX_XF86
+#include "xf86.h"
+#include "xf86PciInfo.h"
+#include "xgi.h"
+#include "xgi_regs.h"
+#endif
+
+#ifdef LINUX_KERNEL
+#include <asm/io.h>
+#include <linux/types.h>
+#endif
+
+
+
+
+UCHAR    XGINew_ChannelAB,XGINew_DataBusWidth;
+
+USHORT XGINew_DRAMType[17][5]={{0x0C,0x0A,0x02,0x40,0x39},{0x0D,0x0A,0x01,0x40,0x48},
+                     {0x0C,0x09,0x02,0x20,0x35},{0x0D,0x09,0x01,0x20,0x44},
+                     {0x0C,0x08,0x02,0x10,0x31},{0x0D,0x08,0x01,0x10,0x40},
+                     {0x0C,0x0A,0x01,0x20,0x34},{0x0C,0x09,0x01,0x08,0x32},
+                     {0x0B,0x08,0x02,0x08,0x21},{0x0C,0x08,0x01,0x08,0x30},
+                     {0x0A,0x08,0x02,0x04,0x11},{0x0B,0x0A,0x01,0x10,0x28},
+                     {0x09,0x08,0x02,0x02,0x01},{0x0B,0x09,0x01,0x08,0x24},
+                     {0x0B,0x08,0x01,0x04,0x20},{0x0A,0x08,0x01,0x02,0x10},
+                     {0x09,0x08,0x01,0x01,0x00}};
+
+USHORT XGINew_SDRDRAM_TYPE[13][5]=
+{
+{ 2,12, 9,64,0x35},
+{ 1,13, 9,64,0x44},
+{ 2,12, 8,32,0x31},
+{ 2,11, 9,32,0x25},
+{ 1,12, 9,32,0x34},
+{ 1,13, 8,32,0x40},
+{ 2,11, 8,16,0x21},
+{ 1,12, 8,16,0x30},
+{ 1,11, 9,16,0x24},
+{ 1,11, 8, 8,0x20},
+{ 2, 9, 8, 4,0x01},
+{ 1,10, 8, 4,0x10},
+{ 1, 9, 8, 2,0x00}
+};
+
+USHORT XGINew_DDRDRAM_TYPE[4][5]=
+{
+{ 2,12, 9,64,0x35},
+{ 2,12, 8,32,0x31},
+{ 2,11, 8,16,0x21},
+{ 2, 9, 8, 4,0x01}
+};
+USHORT XGINew_DDRDRAM_TYPE340[4][5]=
+{
+{ 2,13, 9,64,0x45},
+{ 2,12, 9,32,0x35},
+{ 2,12, 8,16,0x31},
+{ 2,11, 8, 8,0x21}
+};
+USHORT XGINew_DDRDRAM_TYPE20[12][5]=
+{
+{ 2,14,11,128,0x5D},
+{ 2,14,10,64,0x59},
+{ 2,13,11,64,0x4D},
+{ 2,14, 9,32,0x55},
+{ 2,13,10,32,0x49},
+{ 2,12,11,32,0x3D},
+{ 2,14, 8,16,0x51},
+{ 2,13, 9,16,0x45},
+{ 2,12,10,16,0x39},
+{ 2,13, 8, 8,0x41},
+{ 2,12, 9, 8,0x35},
+{ 2,12, 8, 4,0x31}
+};
+
+void     XGINew_SetDRAMSize_340(PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO);
+void     XGINew_SetDRAMSize_310(PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO);
+void     XGINew_SetMemoryClock(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO );
+void     XGINew_SetDRAMModeRegister(PVB_DEVICE_INFO );
+void     XGINew_SetDRAMModeRegister340( PXGI_HW_DEVICE_INFO HwDeviceExtension );
+void 	 XGINew_SetDRAMDefaultRegister340(PXGI_HW_DEVICE_INFO HwDeviceExtension, ULONG, PVB_DEVICE_INFO );
+UCHAR    XGINew_GetXG20DRAMType( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGIInitNew( PXGI_HW_DEVICE_INFO HwDeviceExtension) ;
+
+int      XGINew_DDRSizing340( PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO );
+void     XGINew_DisableRefresh( PXGI_HW_DEVICE_INFO ,PVB_DEVICE_INFO) ;
+void     XGINew_CheckBusWidth_310( PVB_DEVICE_INFO) ;
+int      XGINew_SDRSizing(PVB_DEVICE_INFO);
+int      XGINew_DDRSizing( PVB_DEVICE_INFO );
+void     XGINew_EnableRefresh( PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO);
+int      XGINew_RAMType;                  /*int      ModeIDOffset,StandTable,CRT1Table,ScreenOffset,REFIndex;*/
+ULONG	 UNIROM;			  /* UNIROM */
+BOOLEAN  ChkLFB( PVB_DEVICE_INFO );
+void     XGINew_Delay15us(ULONG);
+void     SetPowerConsume (PXGI_HW_DEVICE_INFO HwDeviceExtension,ULONG XGI_P3d4Port);
+void 	 ReadVBIOSTablData( UCHAR ChipType , PVB_DEVICE_INFO pVBInfo);
+void 	 XGINew_DDR1x_MRS_XG20( ULONG P3c4 , PVB_DEVICE_INFO pVBInfo);
+void     XGINew_SetDRAMModeRegister_XG20( PXGI_HW_DEVICE_INFO HwDeviceExtension );
+void     XGINew_SetDRAMModeRegister_XG27( PXGI_HW_DEVICE_INFO HwDeviceExtension );
+void 	 XGINew_ChkSenseStatus ( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo ) ;
+void     XGINew_SetModeScratch ( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo ) ;
+void     XGINew_GetXG21Sense(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo) ;
+UCHAR    GetXG21FPBits(PVB_DEVICE_INFO pVBInfo);
+void     XGINew_GetXG27Sense(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo) ;
+UCHAR    GetXG27FPBits(PVB_DEVICE_INFO pVBInfo);
+
+#ifdef WIN2000
+/* [Billy] 2007/05/20 For CH7007 */
+extern  UCHAR CH7007TVReg_UNTSC[][8],CH7007TVReg_ONTSC[][8],CH7007TVReg_UPAL[][8],CH7007TVReg_OPAL[][8];
+extern  UCHAR XGI7007_CHTVVCLKUNTSC[],XGI7007_CHTVVCLKONTSC[],XGI7007_CHTVVCLKUPAL[],XGI7007_CHTVVCLKOPAL[];
+#endif
+
+#ifdef LINUX_KERNEL
+void DelayUS(ULONG MicroSeconds)
+{
+	udelay(MicroSeconds);
+}
+#endif
+
+/* --------------------------------------------------------------------- */
+/* Function : XGIInitNew */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGIInitNew( PXGI_HW_DEVICE_INFO HwDeviceExtension )
+{
+
+    VB_DEVICE_INFO VBINF;
+    PVB_DEVICE_INFO pVBInfo = &VBINF;
+#ifndef LINUX_XF86
+    USHORT Mclockdata[ 30 ] , Eclockdata[ 30 ] ;
+    UCHAR  j , SR11 , SR17 = 0 , SR18 = 0 , SR19 = 0 ;
+    UCHAR  CR37 = 0 , CR38 = 0 , CR79 = 0 , CR7A = 0 ,
+           CR7B = 0 , CR36 = 0 , CR78 = 0 , CR3C = 0 ,
+           CR3D = 0 , CR3E = 0 , CR3F = 0 , CR35 = 0 ;
+#endif
+    UCHAR   i , temp = 0 , temp1 ;
+     //       VBIOSVersion[ 5 ] ;
+    ULONG   base,ChipsetID,VendorID,GraphicVendorID;
+    PUCHAR  volatile pVideoMemory;
+
+    /* ULONG j, k ; */
+
+    PXGI_DSReg pSR ;
+
+    ULONG Temp ;
+
+    pVBInfo->ROMAddr = HwDeviceExtension->pjVirtualRomBase ;
+
+    pVBInfo->FBAddr = HwDeviceExtension->pjVideoMemoryAddress ;
+
+    pVBInfo->BaseAddr = HwDeviceExtension->pjIOAddress ;
+
+    pVideoMemory = ( PUCHAR )pVBInfo->ROMAddr;
+
+
+//    Newdebugcode( 0x99 ) ;
+
+
+   /* if ( pVBInfo->ROMAddr == 0 ) */
+   /* return( FALSE ) ; */
+
+    if ( pVBInfo->FBAddr == 0 )
+{
+       printk("\n pVBInfo->FBAddr == 0 "); 
+       return( FALSE ) ;
+}
+printk("1"); 
+    if ( pVBInfo->BaseAddr == 0 )
+{
+       printk("\npVBInfo->BaseAddr == 0 ");
+        return( FALSE ) ;
+}
+printk("2");
+
+    XGINew_SetReg3( ( pVBInfo->BaseAddr + 0x12 ) , 0x67 ) ;	/* 3c2 <- 67 ,ynlai */
+
+    pVBInfo->ISXPDOS = 0 ;
+printk("3");
+
+if ( !HwDeviceExtension->bIntegratedMMEnabled )
+{
+        return( FALSE ) ;	/* alan */
+}
+printk("4");
+
+//    XGI_MemoryCopy( VBIOSVersion , HwDeviceExtension->szVBIOSVer , 4 ) ;
+
+ //   VBIOSVersion[ 4 ] = 0x0 ;
+
+    /* 09/07/99 modify by domao */
+
+    pVBInfo->P3c4 = pVBInfo->BaseAddr + 0x14 ;
+    pVBInfo->P3d4 = pVBInfo->BaseAddr + 0x24 ;
+    pVBInfo->P3c0 = pVBInfo->BaseAddr + 0x10 ;
+    pVBInfo->P3ce = pVBInfo->BaseAddr + 0x1e ;
+    pVBInfo->P3c2 = pVBInfo->BaseAddr + 0x12 ;
+    pVBInfo->P3ca = pVBInfo->BaseAddr + 0x1a ;
+    pVBInfo->P3c6 = pVBInfo->BaseAddr + 0x16 ;
+    pVBInfo->P3c7 = pVBInfo->BaseAddr + 0x17 ;
+    pVBInfo->P3c8 = pVBInfo->BaseAddr + 0x18 ;
+    pVBInfo->P3c9 = pVBInfo->BaseAddr + 0x19 ;
+    pVBInfo->P3da = pVBInfo->BaseAddr + 0x2A ;
+    pVBInfo->Part0Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_00 ;
+    pVBInfo->Part1Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_04 ;
+    pVBInfo->Part2Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_10 ;
+    pVBInfo->Part3Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_12 ;
+    pVBInfo->Part4Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 ;
+    pVBInfo->Part5Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 + 2 ;
+printk("5");
+
+    if ( HwDeviceExtension->jChipType < XG20 )			/* kuku 2004/06/25 */
+    XGI_GetVBType( pVBInfo ) ;         /* Run XGI_GetVBType before InitTo330Pointer */
+
+    InitTo330Pointer( HwDeviceExtension->jChipType,  pVBInfo ) ;
+
+    /* ReadVBIOSData */
+    ReadVBIOSTablData( HwDeviceExtension->jChipType , pVBInfo) ;
+
+    /* 1.Openkey */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x05 , 0x86 ) ;
+printk("6");
+
+    /* GetXG21Sense (GPIO) */
+    if ( HwDeviceExtension->jChipType == XG21 )
+    {
+    	XGINew_GetXG21Sense(HwDeviceExtension, pVBInfo) ;
+    }
+    if ( HwDeviceExtension->jChipType == XG27 )
+    {
+    	XGINew_GetXG27Sense(HwDeviceExtension, pVBInfo) ;
+    }
+printk("7");
+
+    /* 2.Reset Extended register */
+
+    for( i = 0x06 ; i < 0x20 ; i++ )
+        XGINew_SetReg1( pVBInfo->P3c4 , i , 0 ) ;
+
+    for( i = 0x21 ; i <= 0x27 ; i++ )
+        XGINew_SetReg1( pVBInfo->P3c4 , i , 0 ) ;
+
+    /* for( i = 0x06 ; i <= 0x27 ; i++ ) */
+    /* XGINew_SetReg1( pVBInfo->P3c4 , i , 0 ) ; */
+
+printk("8");
+
+    if(( HwDeviceExtension->jChipType >= XG20 ) || ( HwDeviceExtension->jChipType >= XG40))
+    {
+        for( i = 0x31 ; i <= 0x3B ; i++ )
+            XGINew_SetReg1( pVBInfo->P3c4 , i , 0 ) ;
+    }
+    else
+    {
+        for( i = 0x31 ; i <= 0x3D ; i++ )
+            XGINew_SetReg1( pVBInfo->P3c4 , i , 0 ) ;
+    }
+printk("9");
+
+    if ( HwDeviceExtension->jChipType == XG42 )			/* [Hsuan] 2004/08/20 Auto over driver for XG42 */
+      XGINew_SetReg1( pVBInfo->P3c4 , 0x3B , 0xC0 ) ;
+
+    /* for( i = 0x30 ; i <= 0x3F ; i++ ) */
+    /* XGINew_SetReg1( pVBInfo->P3d4 , i , 0 ) ; */
+
+    for( i = 0x79 ; i <= 0x7C ; i++ )
+        XGINew_SetReg1( pVBInfo->P3d4 , i , 0 ) ;		/* shampoo 0208 */
+
+printk("10");
+
+    if ( HwDeviceExtension->jChipType >= XG20 )
+        XGINew_SetReg1( pVBInfo->P3d4 , 0x97 , *pVBInfo->pXGINew_CR97 ) ;
+
+    /* 3.SetMemoryClock
+
+    if ( HwDeviceExtension->jChipType >= XG40 )
+        XGINew_RAMType = ( int )XGINew_GetXG20DRAMType( HwDeviceExtension , pVBInfo) ;
+
+    if ( HwDeviceExtension->jChipType < XG40 )
+        XGINew_SetMemoryClock( HwDeviceExtension , pVBInfo ) ;  */
+
+printk("11");
+
+    /* 4.SetDefExt1Regs begin */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x07 , *pVBInfo->pSR07 ) ;
+    if ( HwDeviceExtension->jChipType == XG27 )
+    {
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x40 , *pVBInfo->pSR40 ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x41 , *pVBInfo->pSR41 ) ;
+    }
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x11 , 0x0F ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1F , *pVBInfo->pSR1F ) ;
+    /* XGINew_SetReg1( pVBInfo->P3c4 , 0x20 , 0x20 ) ; */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x20 , 0xA0 ) ;	/* alan, 2001/6/26 Frame buffer can read/write SR20 */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x36 , 0x70 ) ;	/* Hsuan, 2006/01/01 H/W request for slow corner chip */
+    if ( HwDeviceExtension->jChipType == XG27 )         /* Alan 12/07/2006 */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x36 , *pVBInfo->pSR36 ) ;
+
+    /* SR11 = 0x0F ; */
+    /* XGINew_SetReg1( pVBInfo->P3c4 , 0x11 , SR11 ) ; */
+
+printk("12");
+
+   if ( HwDeviceExtension->jChipType < XG20 )		/* kuku 2004/06/25 */
+    {
+//    /* Set AGP Rate */
+//    temp1 = XGINew_GetReg1( pVBInfo->P3c4 , 0x3B ) ;
+//    temp1 &= 0x02 ;
+//    if ( temp1 == 0x02 )
+//    {
+//        XGINew_SetReg4( 0xcf8 , 0x80000000 ) ;
+//       ChipsetID = XGINew_GetReg3( 0x0cfc ) ;
+//        XGINew_SetReg4( 0xcf8 , 0x8000002C ) ;
+//        VendorID = XGINew_GetReg3( 0x0cfc ) ;
+//        VendorID &= 0x0000FFFF ;
+//        XGINew_SetReg4( 0xcf8 , 0x8001002C ) ;
+//        GraphicVendorID = XGINew_GetReg3( 0x0cfc ) ;
+//        GraphicVendorID &= 0x0000FFFF;
+//
+//        if ( ChipsetID == 0x7301039 )
+///            XGINew_SetReg1( pVBInfo->P3d4 , 0x5F , 0x09 ) ;
+//
+//        ChipsetID &= 0x0000FFFF ;
+///
+//        if ( ( ChipsetID == 0x700E ) || ( ChipsetID == 0x1022 ) || ( ChipsetID == 0x1106 ) || ( ChipsetID == 0x10DE ) )
+//        {
+//            if ( ChipsetID == 0x1106 )
+//            {
+//                if ( ( VendorID == 0x1019 ) && ( GraphicVendorID == 0x1019 ) )
+//                    XGINew_SetReg1( pVBInfo->P3d4 , 0x5F , 0x0D ) ;
+//                else
+//                    XGINew_SetReg1( pVBInfo->P3d4 , 0x5F , 0x0B ) ;
+//            }
+//            else
+//                XGINew_SetReg1( pVBInfo->P3d4 , 0x5F , 0x0B ) ;
+//        }
+//    }
+
+printk("13");
+
+    if ( HwDeviceExtension->jChipType >= XG40 )
+    {
+        /* Set AGP customize registers (in SetDefAGPRegs) Start */
+        for( i = 0x47 ; i <= 0x4C ; i++ )
+            XGINew_SetReg1( pVBInfo->P3d4 , i , pVBInfo->AGPReg[ i - 0x47 ] ) ;
+
+        for( i = 0x70 ; i <= 0x71 ; i++ )
+            XGINew_SetReg1( pVBInfo->P3d4 , i , pVBInfo->AGPReg[ 6 + i - 0x70 ] ) ;
+
+        for( i = 0x74 ; i <= 0x77 ; i++ )
+            XGINew_SetReg1( pVBInfo->P3d4 , i , pVBInfo->AGPReg[ 8 + i - 0x74 ] ) ;
+        /* Set AGP customize registers (in SetDefAGPRegs) End */
+        /*[Hsuan]2004/12/14 AGP Input Delay Adjustment on 850 */
+//        XGINew_SetReg4( 0xcf8 , 0x80000000 ) ;
+//        ChipsetID = XGINew_GetReg3( 0x0cfc ) ;
+//        if ( ChipsetID == 0x25308086 )
+//            XGINew_SetReg1( pVBInfo->P3d4 , 0x77 , 0xF0 ) ;
+
+        HwDeviceExtension->pQueryVGAConfigSpace( HwDeviceExtension , 0x50 , 0 , &Temp ) ;	/* Get */
+        Temp >>= 20 ;
+        Temp &= 0xF ;
+
+        if ( Temp == 1 )
+            XGINew_SetReg1( pVBInfo->P3d4 , 0x48 , 0x20 ) ;	/* CR48 */
+    }
+printk("14");
+
+    if ( HwDeviceExtension->jChipType < XG40 )
+        XGINew_SetReg1( pVBInfo->P3d4 , 0x49 , pVBInfo->CR49[ 0 ] ) ;
+    }	/* != XG20 */
+
+    /* Set PCI */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x23 , *pVBInfo->pSR23 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x24 , *pVBInfo->pSR24 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x25 , pVBInfo->SR25[ 0 ] ) ;
+printk("15");
+
+    if ( HwDeviceExtension->jChipType < XG20 )		/* kuku 2004/06/25 */
+    {
+    /* Set VB */
+    XGI_UnLockCRT2( HwDeviceExtension, pVBInfo) ;
+    XGINew_SetRegANDOR( pVBInfo->Part0Port , 0x3F , 0xEF , 0x00 ) ;	/* alan, disable VideoCapture */
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x00 , 0x00 ) ;
+    temp1 = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x7B ) ;		/* chk if BCLK>=100MHz */
+    temp = ( UCHAR )( ( temp1 >> 4 ) & 0x0F ) ;
+
+
+        XGINew_SetReg1( pVBInfo->Part1Port , 0x02 , ( *pVBInfo->pCRT2Data_1_2 ) ) ;
+
+printk("16");
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x2E , 0x08 ) ;	/* use VB */
+    } /* != XG20 */
+
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x27 , 0x1F ) ;
+
+    if ( ( HwDeviceExtension->jChipType == XG42 ) && XGINew_GetXG20DRAMType( HwDeviceExtension , pVBInfo) != 0 )	/* Not DDR */
+    {
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x31 , ( *pVBInfo->pSR31 & 0x3F ) | 0x40 ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x32 , ( *pVBInfo->pSR32 & 0xFC ) | 0x01 ) ;
+    }
+    else
+    {
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x31 , *pVBInfo->pSR31 ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x32 , *pVBInfo->pSR32 ) ;
+    }
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x33 , *pVBInfo->pSR33 ) ;
+printk("17");
+
+/*
+    if ( HwDeviceExtension->jChipType >= XG40 )
+      SetPowerConsume ( HwDeviceExtension , pVBInfo->P3c4);	*/
+
+    if ( HwDeviceExtension->jChipType < XG20 )		/* kuku 2004/06/25 */
+    {
+    if ( XGI_BridgeIsOn( pVBInfo ) == 1 )
+    {
+        if ( pVBInfo->IF_DEF_LVDS == 0 )
+        {
+            XGINew_SetReg1( pVBInfo->Part2Port , 0x00 , 0x1C ) ;
+            XGINew_SetReg1( pVBInfo->Part4Port , 0x0D , *pVBInfo->pCRT2Data_4_D ) ;
+            XGINew_SetReg1( pVBInfo->Part4Port , 0x0E , *pVBInfo->pCRT2Data_4_E ) ;
+            XGINew_SetReg1( pVBInfo->Part4Port , 0x10 , *pVBInfo->pCRT2Data_4_10 ) ;
+            XGINew_SetReg1( pVBInfo->Part4Port , 0x0F , 0x3F ) ;
+        }
+
+        XGI_LockCRT2( HwDeviceExtension, pVBInfo ) ;
+    }
+    }	/* != XG20 */
+printk("18");
+
+    if ( HwDeviceExtension->jChipType < XG40 )
+        XGINew_SetReg1( pVBInfo->P3d4 , 0x83 , 0x00 ) ;
+printk("181");
+
+    if ( HwDeviceExtension->bSkipSense == FALSE )
+    {
+printk("182");
+
+        XGI_SenseCRT1(pVBInfo) ;
+
+printk("183");
+        /* XGINew_DetectMonitor( HwDeviceExtension ) ; */
+pVBInfo->IF_DEF_CH7007 = 0;
+        if ( ( HwDeviceExtension->jChipType == XG21 ) && (pVBInfo->IF_DEF_CH7007) )
+        {
+printk("184");
+           XGI_GetSenseStatus( HwDeviceExtension , pVBInfo ) ; 	/* sense CRT2 */
+printk("185");
+
+        }
+        if ( HwDeviceExtension->jChipType == XG21 )
+        {
+printk("186");
+
+          XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x32 , ~Monitor1Sense , Monitor1Sense ) ;	/* Z9 default has CRT */
+       	  temp = GetXG21FPBits( pVBInfo ) ;
+          XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x37 , ~0x01, temp ) ;
+printk("187");
+
+          }
+        if ( HwDeviceExtension->jChipType == XG27 )
+        {
+          XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x32 , ~Monitor1Sense , Monitor1Sense ) ;	/* Z9 default has CRT */
+       	  temp = GetXG27FPBits( pVBInfo ) ;
+          XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x37 , ~0x03, temp ) ;
+        }
+    }
+printk("19");
+
+    if ( HwDeviceExtension->jChipType >= XG40 )
+    {
+        if ( HwDeviceExtension->jChipType >= XG40 )
+        {
+          XGINew_RAMType = ( int )XGINew_GetXG20DRAMType( HwDeviceExtension , pVBInfo ) ;
+         }
+
+        XGINew_SetDRAMDefaultRegister340( HwDeviceExtension ,  pVBInfo->P3d4,  pVBInfo ) ;
+
+        if ( HwDeviceExtension->bSkipDramSizing == TRUE )
+        {
+            pSR = HwDeviceExtension->pSR ;
+            if ( pSR!=NULL )
+            {
+                while( pSR->jIdx != 0xFF )
+                {
+                    XGINew_SetReg1( pVBInfo->P3c4 , pSR->jIdx , pSR->jVal ) ;
+                    pSR++ ;
+                }
+            }
+            /* XGINew_SetDRAMModeRegister340( pVBInfo ) ; */
+        }   	/* SkipDramSizing */
+        else
+        {
+#if 0
+           if ( HwDeviceExtension->jChipType == XG20 )
+            {
+            	XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , pVBInfo->SR15[0][XGINew_RAMType] ) ;
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , pVBInfo->SR15[1][XGINew_RAMType] ) ;
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x20 , 0x20 ) ;
+            }
+            else
+#endif
+{
+printk("20");
+
+               XGINew_SetDRAMSize_340( HwDeviceExtension , pVBInfo) ;
+}
+printk("21");
+
+        }
+    }		/* XG40 */
+
+printk("22");
+
+
+    /* SetDefExt2Regs begin */
+/*
+    AGP = 1 ;
+    temp =( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x3A ) ;
+    temp &= 0x30 ;
+    if ( temp == 0x30 )
+        AGP = 0 ;
+
+    if ( AGP == 0 )
+        *pVBInfo->pSR21 &= 0xEF ;
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x21 , *pVBInfo->pSR21 ) ;
+    if ( AGP == 1 )
+        *pVBInfo->pSR22 &= 0x20 ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x22 , *pVBInfo->pSR22 ) ;
+*/
+
+//    base = 0x80000000 ;
+//    OutPortLong( 0xcf8 , base ) ;
+//    Temp = ( InPortLong( 0xcfc ) & 0xFFFF ) ;
+//    if ( Temp == 0x1039 )
+//    {
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x22 , ( UCHAR )( ( *pVBInfo->pSR22 ) & 0xFE ) ) ;
+//    }
+//    else
+//    {
+//        XGINew_SetReg1( pVBInfo->P3c4 , 0x22 , *pVBInfo->pSR22 ) ;
+//    }
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x21 , *pVBInfo->pSR21 ) ;
+
+printk("23");
+
+
+    XGINew_ChkSenseStatus ( HwDeviceExtension , pVBInfo ) ;
+    XGINew_SetModeScratch ( HwDeviceExtension , pVBInfo ) ;
+
+printk("24");
+
+
+XGINew_SetReg1( pVBInfo->P3d4 , 0x8c , 0x87);
+XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x31);
+printk("25");
+
+    return( TRUE ) ;
+} /* end of init */
+
+
+
+
+
+/* ============== alan ====================== */
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_GetXG20DRAMType */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+UCHAR XGINew_GetXG20DRAMType( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR data, temp ;
+
+    if ( HwDeviceExtension->jChipType < XG20 )
+    {
+        if ( *pVBInfo->pSoftSetting & SoftDRAMType )
+        {
+            data = *pVBInfo->pSoftSetting & 0x07 ;
+            return( data ) ;
+        }
+        else
+        {
+            data = XGINew_GetReg1( pVBInfo->P3c4 , 0x39 ) & 0x02 ;
+
+            if ( data == 0 )
+                data = ( XGINew_GetReg1( pVBInfo->P3c4 , 0x3A ) & 0x02 ) >> 1 ;
+
+            return( data ) ;
+        }
+    }
+    else if ( HwDeviceExtension->jChipType == XG27 )
+    {
+        if ( *pVBInfo->pSoftSetting & SoftDRAMType )
+        {
+            data = *pVBInfo->pSoftSetting & 0x07 ;
+            return( data ) ;
+        }
+        temp = XGINew_GetReg1( pVBInfo->P3c4 , 0x3B ) ;
+
+     	if (( temp & 0x88 )==0x80)		/* SR3B[7][3]MAA15 MAA11 (Power on Trapping) */
+       	  data = 0 ;					/*DDR*/
+        else
+       	  data = 1 ; 					/*DDRII*/
+       	return( data ) ;
+    }
+    else if ( HwDeviceExtension->jChipType == XG21 )
+    {
+        XGINew_SetRegAND( pVBInfo->P3d4 , 0xB4 , ~0x02 ) ;     		/* Independent GPIO control */
+     	DelayUS(800);
+        XGINew_SetRegOR( pVBInfo->P3d4 , 0x4A , 0x80 ) ;		/* Enable GPIOH read */
+        temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x48 ) ;       		/* GPIOF 0:DVI 1:DVO */
+// HOTPLUG_SUPPORT    
+// for current XG20 & XG21, GPIOH is floating, driver will fix DDR temporarily 	
+     	if ( temp & 0x01 )						/* DVI read GPIOH */
+       	  data = 1 ;							/*DDRII*/
+        else
+       	  data = 0 ; 							/*DDR*/      	
+//~HOTPLUG_SUPPORT         	  
+       	XGINew_SetRegOR( pVBInfo->P3d4 , 0xB4 , 0x02 ) ;
+       	return( data ) ;
+    }
+    else
+    {
+    	data = XGINew_GetReg1( pVBInfo->P3d4 , 0x97 ) & 0x01 ;
+
+    	if ( data == 1 )
+            data ++ ;
+
+    	return( data );
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_Get310DRAMType */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+UCHAR XGINew_Get310DRAMType(PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR data ;
+
+  /* index = XGINew_GetReg1( pVBInfo->P3c4 , 0x1A ) ; */
+  /* index &= 07 ; */
+
+    if ( *pVBInfo->pSoftSetting & SoftDRAMType )
+        data = *pVBInfo->pSoftSetting & 0x03 ;
+    else
+        data = XGINew_GetReg1( pVBInfo->P3c4 , 0x3a ) & 0x03 ;
+
+    return( data ) ;
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_Delay15us */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+/*
+void XGINew_Delay15us(ULONG ulMicrsoSec)
+{
+}
+*/
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SDR_MRS */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SDR_MRS(  PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT data ;
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x16 ) ;
+    data &= 0x3F ;          /* SR16 D7=0,D6=0 */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , data ) ;   /* enable mode register set(MRS) low */
+    /* XGINew_Delay15us( 0x100 ) ; */
+    data |= 0x80 ;          /* SR16 D7=1,D6=0 */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , data ) ;   /* enable mode register set(MRS) high */
+    /* XGINew_Delay15us( 0x100 ) ; */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDR1x_MRS_340 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DDR1x_MRS_340( ULONG P3c4 , PVB_DEVICE_INFO pVBInfo)
+{
+    XGINew_SetReg1( P3c4 , 0x18 , 0x01 ) ;
+    XGINew_SetReg1( P3c4 , 0x19 , 0x20 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+
+    if ( *pVBInfo->pXGINew_DRAMTypeDefinition != 0x0C )	/* Samsung F Die */
+    {
+        DelayUS( 3000 ) ;	/* Delay 67 x 3 Delay15us */
+        XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;
+        XGINew_SetReg1( P3c4 , 0x19 , 0x20 ) ;
+        XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;
+        XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+    }
+
+    DelayUS( 60 ) ;
+    XGINew_SetReg1( P3c4 , 0x18 , pVBInfo->SR15[ 2 ][ XGINew_RAMType ] ) ;	/* SR18 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x01 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , pVBInfo->SR16[ 0 ] ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , pVBInfo->SR16[ 1 ] ) ;
+    DelayUS( 1000 ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x03 ) ;
+    DelayUS( 500 ) ;
+    XGINew_SetReg1( P3c4 , 0x18 , pVBInfo->SR15[ 2 ][ XGINew_RAMType ] ) ;	/* SR18 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x00 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , pVBInfo->SR16[ 2 ] ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , pVBInfo->SR16[ 3 ] ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x00 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDR2x_MRS_340 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DDR2x_MRS_340( ULONG P3c4 , PVB_DEVICE_INFO pVBInfo)
+{
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;
+    XGINew_SetReg1( P3c4 , 0x19 , 0x20 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+    DelayUS( 60 ) ;
+    XGINew_SetReg1( P3c4 , 0x18 , pVBInfo->SR15[ 2 ][ XGINew_RAMType ] ) ;	/* SR18 */
+    /* XGINew_SetReg1( P3c4 , 0x18 , 0x31 ) ; */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x01 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x05 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x85 ) ;
+    DelayUS( 1000 ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x03 ) ;
+    DelayUS( 500 ) ;
+    /* XGINew_SetReg1( P3c4 , 0x18 , 0x31 ) ; */
+    XGINew_SetReg1( P3c4 , 0x18 , pVBInfo->SR15[ 2 ][ XGINew_RAMType ] ) ;	/* SR18 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x00 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x05 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x85 ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x00 ) ;
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDRII_Bootup_XG27 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DDRII_Bootup_XG27( PXGI_HW_DEVICE_INFO HwDeviceExtension ,  ULONG P3c4 , PVB_DEVICE_INFO pVBInfo)
+{
+    ULONG P3d4 = P3c4 + 0x10 ;
+    UCHAR data ;
+    XGINew_RAMType = ( int )XGINew_GetXG20DRAMType( HwDeviceExtension , pVBInfo ) ;
+    XGINew_SetMemoryClock( HwDeviceExtension , pVBInfo ) ;
+
+   /* Set Double Frequency */
+    /* XGINew_SetReg1( P3d4 , 0x97 , 0x11 ) ; */		/* CR97 */
+    XGINew_SetReg1( P3d4 , 0x97 , *pVBInfo->pXGINew_CR97 ) ;    /* CR97 */
+
+    DelayUS( 200 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;   /* Set SR18 */ //EMRS2
+    XGINew_SetReg1( P3c4 , 0x19 , 0x80 ) ;   /* Set SR19 */ 
+    XGINew_SetReg1( P3c4 , 0x16 , 0x20 ) ;   /* Set SR16 */
+    DelayUS( 15 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0xA0 ) ;   /* Set SR16 */  
+    DelayUS( 15 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;   /* Set SR18 */ //EMRS3
+    XGINew_SetReg1( P3c4 , 0x19 , 0xC0 ) ;   /* Set SR19 */ 
+    XGINew_SetReg1( P3c4 , 0x16 , 0x20 ) ;   /* Set SR16 */
+    DelayUS( 15 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0xA0 ) ;   /* Set SR16 */  
+    DelayUS( 15) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;   /* Set SR18 */ //EMRS1
+    XGINew_SetReg1( P3c4 , 0x19 , 0x40 ) ;   /* Set SR19 */ 
+    XGINew_SetReg1( P3c4 , 0x16 , 0x20 ) ;   /* Set SR16 */
+    DelayUS( 30 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0xA0 ) ;   /* Set SR16 */  
+    DelayUS( 15 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x42 ) ;   /* Set SR18 */ //MRS, DLL Enable
+    XGINew_SetReg1( P3c4 , 0x19 , 0x0A ) ;   /* Set SR19 */ 
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;   /* Set SR16 */
+    DelayUS( 30 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;   /* Set SR16 */
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;   /* Set SR16 */  
+    /* DelayUS( 15 ) ; */
+
+    XGINew_SetReg1( P3c4 , 0x1B , 0x04 ) ;   /* Set SR1B */ 
+    DelayUS( 60 ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x00 ) ;   /* Set SR1B */ 
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x42 ) ;   /* Set SR18 */ //MRS, DLL Reset
+    XGINew_SetReg1( P3c4 , 0x19 , 0x08 ) ;   /* Set SR19 */ 
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;   /* Set SR16 */
+    
+    DelayUS( 30 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x83 ) ;   /* Set SR16 */  
+    DelayUS( 15 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x80 ) ;   /* Set SR18 */ //MRS, ODT
+    XGINew_SetReg1( P3c4 , 0x19 , 0x46 ) ;   /* Set SR19 */ 
+    XGINew_SetReg1( P3c4 , 0x16 , 0x20 ) ;   /* Set SR16 */
+    DelayUS( 30 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0xA0 ) ;   /* Set SR16 */  
+    DelayUS( 15 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;   /* Set SR18 */ //EMRS
+    XGINew_SetReg1( P3c4 , 0x19 , 0x40 ) ;   /* Set SR19 */ 
+    XGINew_SetReg1( P3c4 , 0x16 , 0x20 ) ;   /* Set SR16 */
+    DelayUS( 30 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0xA0 ) ;   /* Set SR16 */  
+    DelayUS( 15 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x1B , 0x04 ) ;   /* Set SR1B refresh control 000:close; 010:open */ 
+    DelayUS( 200 ) ;
+
+	
+}
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDR2_MRS_XG20 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DDR2_MRS_XG20( PXGI_HW_DEVICE_INFO HwDeviceExtension ,  ULONG P3c4 , PVB_DEVICE_INFO pVBInfo)
+{
+    ULONG P3d4 = P3c4 + 0x10 ;
+    UCHAR data ;
+
+    XGINew_RAMType = ( int )XGINew_GetXG20DRAMType( HwDeviceExtension , pVBInfo ) ;
+    XGINew_SetMemoryClock( HwDeviceExtension , pVBInfo ) ;
+
+    XGINew_SetReg1( P3d4 , 0x97 , 0x11 ) ;			/* CR97 */
+   
+    DelayUS( 200 ) ;
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;			/* EMRS2 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x80 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x05 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x85 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;			/* EMRS3 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0xC0 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x05 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x85 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;			/* EMRS1 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x40 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x05 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x85 ) ;
+
+   // XGINew_SetReg1( P3c4 , 0x18 , 0x52 ) ;			/* MRS1 */
+    XGINew_SetReg1( P3c4 , 0x18 , 0x42 ) ;			/* MRS1 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x02 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x05 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x85 ) ;
+
+    DelayUS( 15 ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x04 ) ;			/* SR1B */
+    DelayUS( 30 ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x00 ) ;			/* SR1B */
+    DelayUS( 100 ) ;
+
+    //XGINew_SetReg1( P3c4 , 0x18 , 0x52 ) ;			/* MRS2 */
+    XGINew_SetReg1( P3c4 , 0x18 , 0x42 ) ;			/* MRS1 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x00 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x05 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x85 ) ;
+
+    DelayUS( 200 ) ;
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDR2_MRS_XG20 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DDR2_MRS_XG27( PXGI_HW_DEVICE_INFO HwDeviceExtension ,  ULONG P3c4 , PVB_DEVICE_INFO pVBInfo)
+{
+    ULONG P3d4 = P3c4 + 0x10 ;
+    UCHAR data ;
+
+     XGINew_RAMType = ( int )XGINew_GetXG20DRAMType( HwDeviceExtension , pVBInfo ) ;
+     XGINew_SetMemoryClock( HwDeviceExtension , pVBInfo ) ;
+
+    XGINew_SetReg1( P3d4 , 0x97 , 0x11 ) ;			/* CR97 */
+    DelayUS( 200 ) ;
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;			/* EMRS2 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x80 ) ;
+    
+    XGINew_SetReg1( P3c4 , 0x16 , 0x10 ) ;
+    DelayUS( 15 ) ;                          ////06/11/23 XG27 A0 for CKE enable
+    XGINew_SetReg1( P3c4 , 0x16 , 0x90 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;			/* EMRS3 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0xC0 ) ;
+    
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;
+    DelayUS( 15 ) ;                          ////06/11/22 XG27 A0
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+ 
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;			/* EMRS1 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x40 ) ;
+    
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;
+    DelayUS( 15 ) ;                          ////06/11/22 XG27 A0   
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+ 
+    XGINew_SetReg1( P3c4 , 0x18 , 0x42 ) ;			/* MRS1 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x06 ) ;   ////[Billy]06/11/22 DLL Reset for XG27 Hynix DRAM
+    
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;
+    DelayUS( 15 ) ;                          ////06/11/23 XG27 A0
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+
+    DelayUS( 30 ) ;                          ////06/11/23 XG27 A0 Start Auto-PreCharge
+    XGINew_SetReg1( P3c4 , 0x1B , 0x04 ) ;			/* SR1B */
+    DelayUS( 60 ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x00 ) ;			/* SR1B */
+
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x42 ) ;			/* MRS1 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x04 ) ;   //// DLL without Reset for XG27 Hynix DRAM
+
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;
+    DelayUS( 30 ) ; 
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x80 );     ////XG27 OCD ON
+    XGINew_SetReg1( P3c4 , 0x19 , 0x46 );
+   
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;        
+    DelayUS( 30 ) ; 
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+ 
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 );    
+    XGINew_SetReg1( P3c4 , 0x19 , 0x40 );
+
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;
+    DelayUS( 30 ) ; 
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+
+    DelayUS( 15 ) ;                         ////Start Auto-PreCharge
+    XGINew_SetReg1( P3c4 , 0x1B , 0x04 ) ;			/* SR1B */
+    DelayUS( 200 ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x03 ) ;			/* SR1B */
+
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDR1x_DefaultRegister */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DDR1x_DefaultRegister( PXGI_HW_DEVICE_INFO HwDeviceExtension ,  ULONG Port , PVB_DEVICE_INFO pVBInfo)
+{
+    ULONG P3d4 = Port ,
+           P3c4 = Port - 0x10 ;
+
+#ifndef LINUX_XF86
+    UCHAR  data ;
+#endif
+
+    if ( HwDeviceExtension->jChipType >= XG20 )
+    {
+        XGINew_SetMemoryClock( HwDeviceExtension , pVBInfo ) ;
+        XGINew_SetReg1( P3d4 , 0x82 , pVBInfo->CR40[ 11 ][ XGINew_RAMType ] ) ;	/* CR82 */
+        XGINew_SetReg1( P3d4 , 0x85 , pVBInfo->CR40[ 12 ][ XGINew_RAMType ] ) ;	/* CR85 */
+        XGINew_SetReg1( P3d4 , 0x86 , pVBInfo->CR40[ 13 ][ XGINew_RAMType ] ) ;	/* CR86 */
+
+        XGINew_SetReg1( P3d4 , 0x98 , 0x01 ) ;
+        XGINew_SetReg1( P3d4 , 0x9A , 0x02 ) ;
+
+        XGINew_DDR1x_MRS_XG20( P3c4 , pVBInfo) ;
+    }
+    else
+    {
+        XGINew_SetMemoryClock( HwDeviceExtension , pVBInfo ) ;
+
+        switch( HwDeviceExtension->jChipType )
+        {
+            case XG41:
+            case XG42:
+                XGINew_SetReg1( P3d4 , 0x82 , pVBInfo->CR40[ 11 ][ XGINew_RAMType ] ) ;	/* CR82 */
+                XGINew_SetReg1( P3d4 , 0x85 , pVBInfo->CR40[ 12 ][ XGINew_RAMType ] ) ;	/* CR85 */
+                XGINew_SetReg1( P3d4 , 0x86 , pVBInfo->CR40[ 13 ][ XGINew_RAMType ] ) ;	/* CR86 */
+                break ;
+            default:
+                XGINew_SetReg1( P3d4 , 0x82 , 0x88 ) ;
+                XGINew_SetReg1( P3d4 , 0x86 , 0x00 ) ;
+                XGINew_GetReg1( P3d4 , 0x86 ) ;				/* Insert read command for delay */
+                XGINew_SetReg1( P3d4 , 0x86 , 0x88 ) ;
+                XGINew_GetReg1( P3d4 , 0x86 ) ;
+                XGINew_SetReg1( P3d4 , 0x86 , pVBInfo->CR40[ 13 ][ XGINew_RAMType ] ) ;
+                XGINew_SetReg1( P3d4 , 0x82 , 0x77 ) ;
+                XGINew_SetReg1( P3d4 , 0x85 , 0x00 ) ;
+                XGINew_GetReg1( P3d4 , 0x85 ) ;				/* Insert read command for delay */
+                XGINew_SetReg1( P3d4 , 0x85 , 0x88 ) ;
+                XGINew_GetReg1( P3d4 , 0x85 ) ;				/* Insert read command for delay */
+                XGINew_SetReg1( P3d4 , 0x85 , pVBInfo->CR40[ 12 ][ XGINew_RAMType ] ) ;	/* CR85 */
+                XGINew_SetReg1( P3d4 , 0x82 , pVBInfo->CR40[ 11 ][ XGINew_RAMType ] ) ;	/* CR82 */
+                break ;
+        }
+
+        XGINew_SetReg1( P3d4 , 0x97 , 0x00 ) ;
+        XGINew_SetReg1( P3d4 , 0x98 , 0x01 ) ;
+        XGINew_SetReg1( P3d4 , 0x9A , 0x02 ) ;
+        XGINew_DDR1x_MRS_340( P3c4 , pVBInfo ) ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDR2x_DefaultRegister */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DDR2x_DefaultRegister( PXGI_HW_DEVICE_INFO HwDeviceExtension ,  ULONG Port ,PVB_DEVICE_INFO pVBInfo)
+{
+    ULONG P3d4 = Port ,
+           P3c4 = Port - 0x10 ;
+
+#ifndef LINUX_XF86
+    UCHAR  data ;
+#endif
+
+    XGINew_SetMemoryClock( HwDeviceExtension , pVBInfo ) ;
+
+    /* 20040906 Hsuan modify CR82, CR85, CR86 for XG42 */
+    switch( HwDeviceExtension->jChipType )
+    {
+       case XG41:
+       case XG42:
+            XGINew_SetReg1( P3d4 , 0x82 , pVBInfo->CR40[ 11 ][ XGINew_RAMType ] ) ;	/* CR82 */
+            XGINew_SetReg1( P3d4 , 0x85 , pVBInfo->CR40[ 12 ][ XGINew_RAMType ] ) ;	/* CR85 */
+            XGINew_SetReg1( P3d4 , 0x86 , pVBInfo->CR40[ 13 ][ XGINew_RAMType ] ) ;	/* CR86 */
+            break ;
+       default:
+         /* keep following setting sequence, each setting in the same reg insert idle */
+         XGINew_SetReg1( P3d4 , 0x82 , 0x88 ) ;
+    	 XGINew_SetReg1( P3d4 , 0x86 , 0x00 ) ;
+    	 XGINew_GetReg1( P3d4 , 0x86 ) ;				/* Insert read command for delay */
+    	 XGINew_SetReg1( P3d4 , 0x86 , 0x88 ) ;
+    	 XGINew_SetReg1( P3d4 , 0x82 , 0x77 ) ;
+    	 XGINew_SetReg1( P3d4 , 0x85 , 0x00 ) ;
+    	 XGINew_GetReg1( P3d4 , 0x85 ) ;				/* Insert read command for delay */
+    	 XGINew_SetReg1( P3d4 , 0x85 , 0x88 ) ;
+    	 XGINew_GetReg1( P3d4 , 0x85 ) ;				/* Insert read command for delay */
+    	 XGINew_SetReg1( P3d4 , 0x85 , pVBInfo->CR40[ 12 ][ XGINew_RAMType ] ) ;	/* CR85 */
+    	 XGINew_SetReg1( P3d4 , 0x82 , pVBInfo->CR40[ 11 ][ XGINew_RAMType ] ) ;	/* CR82 */
+    }
+    XGINew_SetReg1( P3d4 , 0x97 , 0x11 ) ;
+    if ( HwDeviceExtension->jChipType == XG42 )
+    {
+      XGINew_SetReg1( P3d4 , 0x98 , 0x01 ) ;
+    }
+    else
+    {
+      XGINew_SetReg1( P3d4 , 0x98 , 0x03 ) ;
+    }
+    XGINew_SetReg1( P3d4 , 0x9A , 0x02 ) ;
+
+    XGINew_DDR2x_MRS_340( P3c4 , pVBInfo ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDR2_DefaultRegister */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DDR2_DefaultRegister( PXGI_HW_DEVICE_INFO HwDeviceExtension, ULONG Port , PVB_DEVICE_INFO pVBInfo)
+{
+    ULONG P3d4 = Port ,
+           P3c4 = Port - 0x10 ;
+
+    /* keep following setting sequence, each setting in the same reg insert idle */
+    XGINew_SetReg1( P3d4 , 0x82 , 0x77 ) ;
+    XGINew_SetReg1( P3d4 , 0x86 , 0x00 ) ;
+    XGINew_GetReg1( P3d4 , 0x86 ) ;				/* Insert read command for delay */
+    XGINew_SetReg1( P3d4 , 0x86 , 0x88 ) ;
+    XGINew_GetReg1( P3d4 , 0x86 ) ;				/* Insert read command for delay */
+    XGINew_SetReg1( P3d4 , 0x86 , pVBInfo->CR40[ 13 ][ XGINew_RAMType ] ) ;	/* CR86 */
+    XGINew_SetReg1( P3d4 , 0x82 , 0x77 ) ;
+    XGINew_SetReg1( P3d4 , 0x85 , 0x00 ) ;
+    XGINew_GetReg1( P3d4 , 0x85 ) ;				/* Insert read command for delay */
+    XGINew_SetReg1( P3d4 , 0x85 , 0x88 ) ;
+    XGINew_GetReg1( P3d4 , 0x85 ) ;				/* Insert read command for delay */
+    XGINew_SetReg1( P3d4 , 0x85 , pVBInfo->CR40[ 12 ][ XGINew_RAMType ] ) ;	/* CR85 */
+    if ( HwDeviceExtension->jChipType == XG27 )
+      XGINew_SetReg1( P3d4 , 0x82 , pVBInfo->CR40[ 11 ][ XGINew_RAMType ] ) ;	/* CR82 */
+    else
+    XGINew_SetReg1( P3d4 , 0x82 , 0xA8 ) ;	/* CR82 */
+
+    XGINew_SetReg1( P3d4 , 0x98 , 0x01 ) ;
+    XGINew_SetReg1( P3d4 , 0x9A , 0x02 ) ;
+    if ( HwDeviceExtension->jChipType == XG27 )
+       XGINew_DDRII_Bootup_XG27( HwDeviceExtension ,  P3c4 , pVBInfo) ;
+    else
+    XGINew_DDR2_MRS_XG20( HwDeviceExtension , P3c4, pVBInfo ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetDRAMDefaultRegister340 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetDRAMDefaultRegister340( PXGI_HW_DEVICE_INFO HwDeviceExtension ,  ULONG Port , PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR temp , temp1 , temp2 , temp3 ,
+          i , j , k ;
+
+    ULONG P3d4 = Port ,
+           P3c4 = Port - 0x10 ;
+
+    XGINew_SetReg1( P3d4 , 0x6D , pVBInfo->CR40[ 8 ][ XGINew_RAMType ] ) ;
+    XGINew_SetReg1( P3d4 , 0x68 , pVBInfo->CR40[ 5 ][ XGINew_RAMType ] ) ;
+    XGINew_SetReg1( P3d4 , 0x69 , pVBInfo->CR40[ 6 ][ XGINew_RAMType ] ) ;
+    XGINew_SetReg1( P3d4 , 0x6A , pVBInfo->CR40[ 7 ][ XGINew_RAMType ] ) ;
+
+    temp2 = 0 ;
+    for( i = 0 ; i < 4 ; i++ )
+    {
+        temp = pVBInfo->CR6B[ XGINew_RAMType ][ i ] ;        		/* CR6B DQS fine tune delay */
+        for( j = 0 ; j < 4 ; j++ )
+        {
+            temp1 = ( ( temp >> ( 2 * j ) ) & 0x03 ) << 2 ;
+            temp2 |= temp1 ;
+            XGINew_SetReg1( P3d4 , 0x6B , temp2 ) ;
+            XGINew_GetReg1( P3d4 , 0x6B ) ;				/* Insert read command for delay */
+            temp2 &= 0xF0 ;
+            temp2 += 0x10 ;
+        }
+    }
+
+    temp2 = 0 ;
+    for( i = 0 ; i < 4 ; i++ )
+    {
+        temp = pVBInfo->CR6E[ XGINew_RAMType ][ i ] ;        		/* CR6E DQM fine tune delay */
+        for( j = 0 ; j < 4 ; j++ )
+        {
+            temp1 = ( ( temp >> ( 2 * j ) ) & 0x03 ) << 2 ;
+            temp2 |= temp1 ;
+            XGINew_SetReg1( P3d4 , 0x6E , temp2 ) ;
+            XGINew_GetReg1( P3d4 , 0x6E ) ;				/* Insert read command for delay */
+            temp2 &= 0xF0 ;
+            temp2 += 0x10 ;
+        }
+    }
+
+    temp3 = 0 ;
+    for( k = 0 ; k < 4 ; k++ )
+    {
+        XGINew_SetRegANDOR( P3d4 , 0x6E , 0xFC , temp3 ) ;		/* CR6E_D[1:0] select channel */
+        temp2 = 0 ;
+        for( i = 0 ; i < 8 ; i++ )
+        {
+            temp = pVBInfo->CR6F[ XGINew_RAMType ][ 8 * k + i ] ;   	/* CR6F DQ fine tune delay */
+            for( j = 0 ; j < 4 ; j++ )
+            {
+                temp1 = ( temp >> ( 2 * j ) ) & 0x03 ;
+                temp2 |= temp1 ;
+                XGINew_SetReg1( P3d4 , 0x6F , temp2 ) ;
+                XGINew_GetReg1( P3d4 , 0x6F ) ;				/* Insert read command for delay */
+                temp2 &= 0xF8 ;
+                temp2 += 0x08 ;
+            }
+        }
+        temp3 += 0x01 ;
+    }
+
+    XGINew_SetReg1( P3d4 , 0x80 , pVBInfo->CR40[ 9 ][ XGINew_RAMType ] ) ;	/* CR80 */
+    XGINew_SetReg1( P3d4 , 0x81 , pVBInfo->CR40[ 10 ][ XGINew_RAMType ] ) ;	/* CR81 */
+
+    temp2 = 0x80 ;
+    temp = pVBInfo->CR89[ XGINew_RAMType ][ 0 ] ;        		/* CR89 terminator type select */
+    for( j = 0 ; j < 4 ; j++ )
+    {
+        temp1 = ( temp >> ( 2 * j ) ) & 0x03 ;
+        temp2 |= temp1 ;
+        XGINew_SetReg1( P3d4 , 0x89 , temp2 ) ;
+        XGINew_GetReg1( P3d4 , 0x89 ) ;				/* Insert read command for delay */
+        temp2 &= 0xF0 ;
+        temp2 += 0x10 ;
+    }
+
+    temp = pVBInfo->CR89[ XGINew_RAMType ][ 1 ] ;
+    temp1 = temp & 0x03 ;
+    temp2 |= temp1 ;
+    XGINew_SetReg1( P3d4 , 0x89 , temp2 ) ;
+
+    temp = pVBInfo->CR40[ 3 ][ XGINew_RAMType ] ;
+    temp1 = temp & 0x0F ;
+    temp2 = ( temp >> 4 ) & 0x07 ;
+    temp3 = temp & 0x80 ;
+    XGINew_SetReg1( P3d4 , 0x45 , temp1 ) ;	/* CR45 */
+    XGINew_SetReg1( P3d4 , 0x99 , temp2 ) ;	/* CR99 */
+    XGINew_SetRegOR( P3d4 , 0x40 , temp3 ) ;	/* CR40_D[7] */
+    XGINew_SetReg1( P3d4 , 0x41 , pVBInfo->CR40[ 0 ][ XGINew_RAMType ] ) ;	/* CR41 */
+
+    if ( HwDeviceExtension->jChipType == XG27 )
+      XGINew_SetReg1( P3d4 , 0x8F , *pVBInfo->pCR8F ) ;	/* CR8F */
+      
+    for( j = 0 ; j <= 6 ; j++ )
+        XGINew_SetReg1( P3d4 , ( 0x90 + j ) , pVBInfo->CR40[ 14 + j ][ XGINew_RAMType ] ) ;	/* CR90 - CR96 */
+
+    for( j = 0 ; j <= 2 ; j++ )
+        XGINew_SetReg1( P3d4 , ( 0xC3 + j ) , pVBInfo->CR40[ 21 + j ][ XGINew_RAMType ] ) ;	/* CRC3 - CRC5 */
+
+    for( j = 0 ; j < 2 ; j++ )
+        XGINew_SetReg1( P3d4 , ( 0x8A + j ) , pVBInfo->CR40[ 1 + j ][ XGINew_RAMType ] ) ;	/* CR8A - CR8B */
+
+    if ( ( HwDeviceExtension->jChipType == XG41 ) || ( HwDeviceExtension->jChipType == XG42 ) )
+        XGINew_SetReg1( P3d4 , 0x8C , 0x87 ) ;
+
+    XGINew_SetReg1( P3d4 , 0x59 , pVBInfo->CR40[ 4 ][ XGINew_RAMType ] ) ;	/* CR59 */
+
+    XGINew_SetReg1( P3d4 , 0x83 , 0x09 ) ;	/* CR83 */
+    XGINew_SetReg1( P3d4 , 0x87 , 0x00 ) ;	/* CR87 */
+    XGINew_SetReg1( P3d4 , 0xCF , *pVBInfo->pCRCF ) ;	/* CRCF */
+    if ( XGINew_RAMType )
+    {
+      //XGINew_SetReg1( P3c4 , 0x17 , 0xC0 ) ;		/* SR17 DDRII */
+      XGINew_SetReg1( P3c4 , 0x17 , 0x80 ) ;		/* SR17 DDRII */
+      if ( HwDeviceExtension->jChipType == XG27 )
+        XGINew_SetReg1( P3c4 , 0x17 , 0x02 ) ;		/* SR17 DDRII */
+
+    }
+    else
+      XGINew_SetReg1( P3c4 , 0x17 , 0x00 ) ;		/* SR17 DDR */
+    XGINew_SetReg1( P3c4 , 0x1A , 0x87 ) ;		/* SR1A */
+
+    temp = XGINew_GetXG20DRAMType( HwDeviceExtension, pVBInfo) ;
+    if( temp == 0 )
+      XGINew_DDR1x_DefaultRegister( HwDeviceExtension, P3d4, pVBInfo ) ;
+    else
+    {
+      XGINew_SetReg1( P3d4 , 0xB0 , 0x80 ) ;		/* DDRII Dual frequency mode */
+      XGINew_DDR2_DefaultRegister( HwDeviceExtension, P3d4, pVBInfo ) ;
+    }
+    XGINew_SetReg1( P3c4 , 0x1B , pVBInfo->SR15[ 3 ][ XGINew_RAMType ] ) ;	/* SR1B */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDR_MRS */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DDR_MRS(PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT data ;
+
+    PUCHAR volatile pVideoMemory = ( PUCHAR )pVBInfo->ROMAddr ;
+
+    /* SR16 <- 1F,DF,2F,AF */
+    /* yriver modified SR16 <- 0F,DF,0F,AF */
+    /* enable DLL of DDR SD/SGRAM , SR16 D4=1 */
+    data = pVideoMemory[ 0xFB ] ;
+    /* data = XGINew_GetReg1( pVBInfo->P3c4 , 0x16 ) ; */
+
+    data &= 0x0F ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , data ) ;
+    data |= 0xC0 ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , data ) ;
+    data &= 0x0F ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , data ) ;
+    data |= 0x80 ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , data ) ;
+    data &= 0x0F ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , data ) ;
+    data |= 0xD0 ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , data ) ;
+    data &= 0x0F ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , data ) ;
+    data |= 0xA0 ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , data ) ;
+/*
+   else {
+     data &= 0x0F;
+     data |= 0x10;
+     XGINew_SetReg1(pVBInfo->P3c4,0x16,data);
+
+     if (!(pVBInfo->SR15[1][XGINew_RAMType] & 0x10))
+     {
+       data &= 0x0F;
+     }
+
+     data |= 0xC0;
+     XGINew_SetReg1(pVBInfo->P3c4,0x16,data);
+
+
+     data &= 0x0F;
+     data |= 0x20;
+     XGINew_SetReg1(pVBInfo->P3c4,0x16,data);
+     if (!(pVBInfo->SR15[1][XGINew_RAMType] & 0x10))
+     {
+       data &= 0x0F;
+     }
+
+     data |= 0x80;
+     XGINew_SetReg1(pVBInfo->P3c4,0x16,data);
+   }
+*/
+}
+
+
+/* check if read cache pointer is correct */
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_VerifyMclk */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_VerifyMclk( PXGI_HW_DEVICE_INFO  HwDeviceExtension , PVB_DEVICE_INFO pVBInfo)
+{
+    PUCHAR pVideoMemory = pVBInfo->FBAddr ;
+    UCHAR i , j ;
+    USHORT Temp , SR21 ;
+
+    pVideoMemory[ 0 ] = 0xaa ; 		/* alan */
+    pVideoMemory[ 16 ] = 0x55 ; 	/* note: PCI read cache is off */
+
+    if ( ( pVideoMemory[ 0 ] != 0xaa ) || ( pVideoMemory[ 16 ] != 0x55 ) )
+    {
+        for( i = 0 , j = 16 ; i < 2 ; i++ , j += 16 )
+        {
+            SR21 = XGINew_GetReg1( pVBInfo->P3c4 , 0x21 ) ;
+            Temp = SR21 & 0xFB ;	/* disable PCI post write buffer empty gating */
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x21 , Temp ) ;
+
+            Temp = XGINew_GetReg1( pVBInfo->P3c4 , 0x3C ) ;
+            Temp |= 0x01 ;		/* MCLK reset */
+
+
+            Temp = XGINew_GetReg1( pVBInfo->P3c4 , 0x3C ) ;
+            Temp &= 0xFE ;		/* MCLK normal operation */
+
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x21 , SR21 ) ;
+
+            pVideoMemory[ 16 + j ] = j ;
+            if ( pVideoMemory[ 16 + j ] == j )
+            {
+                pVideoMemory[ j ] = j ;
+                break ;
+            }
+        }
+    }
+}
+
+
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetDRAMSize_340 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetDRAMSize_340( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT  data ;
+
+    pVBInfo->ROMAddr = HwDeviceExtension->pjVirtualRomBase ;
+    pVBInfo->FBAddr = HwDeviceExtension->pjVideoMemoryAddress ;
+
+    XGISetModeNew( HwDeviceExtension , 0x2e ) ;
+
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x21 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x21 , ( USHORT )( data & 0xDF ) ) ;	/* disable read cache */
+    XGI_DisplayOff( HwDeviceExtension, pVBInfo );
+
+    /*data = XGINew_GetReg1( pVBInfo->P3c4 , 0x1 ) ;*/
+    /*data |= 0x20 ;*/
+    /*XGINew_SetReg1( pVBInfo->P3c4 , 0x01 , data ) ;*/			/* Turn OFF Display */
+    XGINew_DDRSizing340( HwDeviceExtension, pVBInfo ) ;
+    data=XGINew_GetReg1( pVBInfo->P3c4 , 0x21 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x21 , ( USHORT )( data | 0x20 ) ) ;	/* enable read cache */
+
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetDRAMSize_310( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo)
+{
+
+#ifndef LINUX_XF86
+    ULONG UMASize = 0 ;
+    UCHAR tempah ;
+#endif
+    USHORT data ;
+    pVBInfo->ROMAddr  = HwDeviceExtension->pjVirtualRomBase ,
+    pVBInfo->FBAddr = HwDeviceExtension->pjVideoMemoryAddress ;
+#ifdef XGI301
+    /* XGINew_SetReg1( pVBInfo->P3d4 , 0x30 , 0x40 ) ; */
+#endif
+
+#ifdef XGI302	/* alan,should change value */
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x30 , 0x4D ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x31 , 0xc0 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x34 , 0x3F ) ;
+#endif
+
+    XGISetModeNew( HwDeviceExtension , 0x2e ) ;
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x21 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x21 , ( USHORT )( data & 0xDF ) ) ;	/* disable read cache */
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x1 ) ;
+    data |= 0x20 ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x01 , data ) ;		/* Turn OFF Display */
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x16 ) ;
+
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , ( USHORT )( data | 0x0F ) ) ;		/* assume lowest speed DRAM */
+
+    XGINew_SetDRAMModeRegister( pVBInfo ) ;
+    XGINew_DisableRefresh( HwDeviceExtension, pVBInfo ) ;
+    XGINew_CheckBusWidth_310( pVBInfo) ;
+    XGINew_VerifyMclk( HwDeviceExtension, pVBInfo ) ;	/* alan 2000/7/3 */
+
+
+
+    if ( XGINew_Get310DRAMType( pVBInfo ) < 2 )
+    {
+        XGINew_SDRSizing( pVBInfo ) ;
+    }
+    else
+    {
+        XGINew_DDRSizing( pVBInfo) ;
+    }
+
+
+
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , pVBInfo->SR15[ 1 ][ XGINew_RAMType ] ) ;	/* restore SR16 */
+
+    XGINew_EnableRefresh(  HwDeviceExtension, pVBInfo ) ;
+    data=XGINew_GetReg1( pVBInfo->P3c4 ,0x21 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x21 , ( USHORT )( data | 0x20 ) ) ;	/* enable read cache */
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetDRAMModeRegister340 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+
+void XGINew_SetDRAMModeRegister340( PXGI_HW_DEVICE_INFO HwDeviceExtension )
+{
+    UCHAR data ;
+    VB_DEVICE_INFO VBINF;
+    PVB_DEVICE_INFO pVBInfo = &VBINF;
+    pVBInfo->ROMAddr = HwDeviceExtension->pjVirtualRomBase ;
+    pVBInfo->FBAddr = HwDeviceExtension->pjVideoMemoryAddress ;
+    pVBInfo->BaseAddr = HwDeviceExtension->pjIOAddress ;
+    pVBInfo->ISXPDOS = 0 ;
+
+    pVBInfo->P3c4 = pVBInfo->BaseAddr + 0x14 ;
+    pVBInfo->P3d4 = pVBInfo->BaseAddr + 0x24 ;
+    pVBInfo->P3c0 = pVBInfo->BaseAddr + 0x10 ;
+    pVBInfo->P3ce = pVBInfo->BaseAddr + 0x1e ;
+    pVBInfo->P3c2 = pVBInfo->BaseAddr + 0x12 ;
+    pVBInfo->P3ca = pVBInfo->BaseAddr + 0x1a ;
+    pVBInfo->P3c6 = pVBInfo->BaseAddr + 0x16 ;
+    pVBInfo->P3c7 = pVBInfo->BaseAddr + 0x17 ;
+    pVBInfo->P3c8 = pVBInfo->BaseAddr + 0x18 ;
+    pVBInfo->P3c9 = pVBInfo->BaseAddr + 0x19 ;
+    pVBInfo->P3da = pVBInfo->BaseAddr + 0x2A ;
+    pVBInfo->Part0Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_00 ;
+    pVBInfo->Part1Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_04 ;
+    pVBInfo->Part2Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_10 ;
+    pVBInfo->Part3Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_12 ;
+    pVBInfo->Part4Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 ;
+    pVBInfo->Part5Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 + 2 ;
+    if ( HwDeviceExtension->jChipType < XG20 )                  /* kuku 2004/06/25 */
+    XGI_GetVBType( pVBInfo ) ;         /* Run XGI_GetVBType before InitTo330Pointer */
+
+    InitTo330Pointer(HwDeviceExtension->jChipType,pVBInfo);
+
+    ReadVBIOSTablData( HwDeviceExtension->jChipType , pVBInfo) ;
+
+    if ( XGINew_GetXG20DRAMType( HwDeviceExtension, pVBInfo) == 0 )
+    {
+        data = ( XGINew_GetReg1( pVBInfo->P3c4 , 0x39 ) & 0x02 ) >> 1 ;
+        if ( data == 0x01 )
+            XGINew_DDR2x_MRS_340( pVBInfo->P3c4, pVBInfo ) ;
+        else
+            XGINew_DDR1x_MRS_340( pVBInfo->P3c4, pVBInfo ) ;
+    }
+    else
+        XGINew_DDR2_MRS_XG20( HwDeviceExtension, pVBInfo->P3c4, pVBInfo);
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1B , 0x03 ) ;
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetDRAMModeRegister */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetDRAMModeRegister( PVB_DEVICE_INFO pVBInfo)
+{
+    if ( XGINew_Get310DRAMType( pVBInfo ) < 2 )
+    {
+      XGINew_SDR_MRS(pVBInfo ) ;
+    }
+    else
+    {
+      /* SR16 <- 0F,CF,0F,8F */
+      XGINew_DDR_MRS( pVBInfo ) ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DisableRefresh */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DisableRefresh( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT  data ;
+
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x1B ) ;
+    data &= 0xF8 ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1B , data ) ;
+
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_EnableRefresh */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_EnableRefresh( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo)
+{
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1B , pVBInfo->SR15[ 3 ][ XGINew_RAMType ] ) ;	/* SR1B */
+
+
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DisableChannelInterleaving */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DisableChannelInterleaving( int index , USHORT XGINew_DDRDRAM_TYPE[][ 5 ] , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT data ;
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x15 ) ;
+    data &= 0x1F ;
+
+    switch( XGINew_DDRDRAM_TYPE[ index ][ 3 ] )
+    {
+        case 64:
+            data |= 0 ;
+            break ;
+        case 32:
+            data |= 0x20 ;
+            break ;
+        case 16:
+            data |= 0x40 ;
+            break ;
+        case 4:
+            data |= 0x60 ;
+            break ;
+        default:
+            break ;
+    }
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x15 , data ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetDRAMSizingType */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetDRAMSizingType( int index , USHORT DRAMTYPE_TABLE[][ 5 ] ,PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT data ;
+
+    data = DRAMTYPE_TABLE[ index ][ 4 ] ;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x13 , 0x80 , data ) ;
+    DelayUS( 15 ) ;
+   /* should delay 50 ns */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_CheckBusWidth_310 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_CheckBusWidth_310(  PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT data ;
+    PULONG volatile pVideoMemory ;
+
+    pVideoMemory = (PULONG) pVBInfo->FBAddr;
+
+    if ( XGINew_Get310DRAMType( pVBInfo ) < 2 )
+    {
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x00 ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x12 ) ;
+        /* should delay */
+        XGINew_SDR_MRS( pVBInfo ) ;
+
+        XGINew_ChannelAB = 0 ;
+        XGINew_DataBusWidth = 128 ;
+        pVideoMemory[ 0 ] = 0x01234567L ;
+        pVideoMemory[ 1 ] = 0x456789ABL ;
+        pVideoMemory[ 2 ] = 0x89ABCDEFL ;
+        pVideoMemory[ 3 ] = 0xCDEF0123L ;
+        pVideoMemory[ 4 ] = 0x55555555L ;
+        pVideoMemory[ 5 ] = 0x55555555L ;
+        pVideoMemory[ 6 ] = 0xFFFFFFFFL ;
+        pVideoMemory[ 7 ] = 0xFFFFFFFFL ;
+
+        if ( ( pVideoMemory[ 3 ] != 0xCDEF0123L ) || ( pVideoMemory[ 2 ] != 0x89ABCDEFL ) )
+        {
+            /* ChannelA64Bit */
+            XGINew_DataBusWidth = 64 ;
+            XGINew_ChannelAB = 0 ;
+            data=XGINew_GetReg1( pVBInfo->P3c4 , 0x14 ) ;
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , ( USHORT )( data & 0xFD ) ) ;
+        }
+
+        if ( ( pVideoMemory[ 1 ] != 0x456789ABL ) || ( pVideoMemory[ 0 ] != 0x01234567L ) )
+        {
+            /* ChannelB64Bit */
+            XGINew_DataBusWidth = 64 ;
+            XGINew_ChannelAB = 1 ;
+            data=XGINew_GetReg1( pVBInfo->P3c4 , 0x14 ) ;
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , ( USHORT )( ( data & 0xFD ) | 0x01 ) ) ;
+        }
+
+        return ;
+    }
+    else
+    {
+        /* DDR Dual channel */
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x00 ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x02 ) ;	/* Channel A, 64bit */
+        /* should delay */
+        XGINew_DDR_MRS( pVBInfo ) ;
+
+        XGINew_ChannelAB = 0 ;
+        XGINew_DataBusWidth = 64 ;
+        pVideoMemory[ 0 ] = 0x01234567L ;
+        pVideoMemory[ 1 ] = 0x456789ABL ;
+        pVideoMemory[ 2 ] = 0x89ABCDEFL ;
+        pVideoMemory[ 3 ] = 0xCDEF0123L ;
+        pVideoMemory[ 4 ] = 0x55555555L ;
+        pVideoMemory[ 5 ] = 0x55555555L ;
+        pVideoMemory[ 6 ] = 0xAAAAAAAAL ;
+        pVideoMemory[ 7 ] = 0xAAAAAAAAL ;
+
+        if ( pVideoMemory[ 1 ] == 0x456789ABL )
+        {
+            if ( pVideoMemory[ 0 ] == 0x01234567L )
+            {
+                /* Channel A 64bit */
+                return ;
+            }
+        }
+        else
+        {
+            if ( pVideoMemory[ 0 ] == 0x01234567L )
+            {
+                /* Channel A 32bit */
+                XGINew_DataBusWidth = 32 ;
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x00 ) ;
+                return ;
+            }
+        }
+
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x03 ) ;	/* Channel B, 64bit */
+        XGINew_DDR_MRS( pVBInfo);
+
+        XGINew_ChannelAB = 1 ;
+        XGINew_DataBusWidth = 64 ;
+        pVideoMemory[ 0 ] = 0x01234567L ;
+        pVideoMemory[ 1 ] = 0x456789ABL ;
+        pVideoMemory[ 2 ] = 0x89ABCDEFL ;
+        pVideoMemory[ 3 ] = 0xCDEF0123L ;
+        pVideoMemory[ 4 ] = 0x55555555L ;
+        pVideoMemory[ 5 ] = 0x55555555L ;
+        pVideoMemory[ 6 ] = 0xAAAAAAAAL ;
+        pVideoMemory[ 7 ] = 0xAAAAAAAAL ;
+
+        if ( pVideoMemory[ 1 ] == 0x456789ABL )
+        {
+            /* Channel B 64 */
+            if ( pVideoMemory[ 0 ] == 0x01234567L )
+            {
+                /* Channel B 64bit */
+                return ;
+            }
+            else
+            {
+                /* error */
+            }
+        }
+        else
+        {
+            if ( pVideoMemory[ 0 ] == 0x01234567L )
+            {
+                /* Channel B 32 */
+                XGINew_DataBusWidth = 32 ;
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x01 ) ;
+            }
+            else
+            {
+                /* error */
+            }
+        }
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetRank */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_SetRank( int index , UCHAR RankNo , UCHAR XGINew_ChannelAB , USHORT DRAMTYPE_TABLE[][ 5 ] , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT data ;
+    int RankSize ;
+
+    if ( ( RankNo == 2 ) && ( DRAMTYPE_TABLE[ index ][ 0 ] == 2 ) )
+        return 0 ;
+
+    RankSize = DRAMTYPE_TABLE[ index ][ 3 ] / 2 * XGINew_DataBusWidth / 32 ;
+
+    if ( ( RankNo * RankSize ) <= 128 )
+    {
+        data = 0 ;
+
+        while( ( RankSize >>= 1 ) > 0 )
+        {
+            data += 0x10 ;
+        }
+        data |= ( RankNo - 1 ) << 2 ;
+        data |= ( XGINew_DataBusWidth / 64 ) & 2 ;
+        data |= XGINew_ChannelAB ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , data ) ;
+        /* should delay */
+        XGINew_SDR_MRS( pVBInfo ) ;
+        return( 1 ) ;
+    }
+    else
+        return( 0 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetDDRChannel */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_SetDDRChannel( int index , UCHAR ChannelNo , UCHAR XGINew_ChannelAB , USHORT DRAMTYPE_TABLE[][ 5 ] , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT  data ;
+    int RankSize ;
+
+    RankSize = DRAMTYPE_TABLE[index][3]/2 * XGINew_DataBusWidth/32;
+    /* RankSize = DRAMTYPE_TABLE[ index ][ 3 ] ; */
+    if ( ChannelNo * RankSize <= 128 )
+    {
+        data = 0 ;
+        while( ( RankSize >>= 1 ) > 0 )
+        {
+            data += 0x10 ;
+        }
+
+        if ( ChannelNo == 2 )
+            data |= 0x0C ;
+
+        data |= ( XGINew_DataBusWidth / 32 ) & 2 ;
+        data |= XGINew_ChannelAB ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , data ) ;
+        /* should delay */
+        XGINew_DDR_MRS( pVBInfo ) ;
+        return( 1 ) ;
+    }
+    else
+        return( 0 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_CheckColumn */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_CheckColumn( int index , USHORT DRAMTYPE_TABLE[][ 5 ], PVB_DEVICE_INFO pVBInfo)
+{
+    int i ;
+    ULONG Increment , Position ;
+
+    /* Increment = 1 << ( DRAMTYPE_TABLE[ index ][ 2 ] + XGINew_DataBusWidth / 64 + 1 ) ; */
+    Increment = 1 << ( 10 + XGINew_DataBusWidth / 64 ) ;
+
+    for( i = 0 , Position = 0 ; i < 2 ; i++ )
+    {
+        *( ( PULONG )( pVBInfo->FBAddr + Position ) ) = Position ;
+        Position += Increment ;
+    }
+
+#ifdef WIN2000  /* chiawen for linux solution */
+    DelayUS( 100 ) ;
+#endif
+
+    for( i = 0 , Position = 0 ; i < 2 ; i++ )
+    {
+        /* if ( pVBInfo->FBAddr[ Position ] != Position ) */
+        if ( ( *( PULONG )( pVBInfo->FBAddr + Position ) ) != Position )
+            return( 0 ) ;
+        Position += Increment ;
+    }
+    return( 1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_CheckBanks */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_CheckBanks( int index , USHORT DRAMTYPE_TABLE[][ 5 ], PVB_DEVICE_INFO pVBInfo)
+{
+    int i ;
+    ULONG Increment , Position ;
+
+    Increment = 1 << ( DRAMTYPE_TABLE[ index ][ 2 ] + XGINew_DataBusWidth / 64 + 2 ) ;
+
+    for( i = 0 , Position = 0 ; i < 4 ; i++ )
+    {
+        /* pVBInfo->FBAddr[ Position ] = Position ; */
+        *( ( PULONG )( pVBInfo->FBAddr + Position ) ) = Position ;
+        Position += Increment ;
+    }
+
+    for( i = 0 , Position = 0 ; i < 4 ; i++ )
+    {
+        /* if (pVBInfo->FBAddr[ Position ] != Position ) */
+        if ( ( *( PULONG )( pVBInfo->FBAddr + Position ) ) != Position )
+            return( 0 ) ;
+        Position += Increment ;
+    }
+    return( 1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_CheckRank */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_CheckRank( int RankNo , int index , USHORT DRAMTYPE_TABLE[][ 5 ], PVB_DEVICE_INFO pVBInfo)
+{
+    int i ;
+    ULONG Increment , Position ;
+
+    Increment = 1 << ( DRAMTYPE_TABLE[ index ][ 2 ] + DRAMTYPE_TABLE[ index ][ 1 ] +
+                  DRAMTYPE_TABLE[ index ][ 0 ] + XGINew_DataBusWidth / 64 + RankNo ) ;
+
+    for( i = 0 , Position = 0 ; i < 2 ; i++ )
+    {
+        /* pVBInfo->FBAddr[ Position ] = Position ; */
+        /* *( ( PULONG )( pVBInfo->FBAddr ) ) = Position ; */
+        *( ( PULONG )( pVBInfo->FBAddr + Position ) ) = Position ;
+        Position += Increment ;
+    }
+
+    for( i = 0 , Position = 0 ; i < 2 ; i++ )
+    {
+        /* if ( pVBInfo->FBAddr[ Position ] != Position ) */
+        /* if ( ( *( PULONG )( pVBInfo->FBAddr ) ) != Position ) */
+        if ( ( *( PULONG )( pVBInfo->FBAddr + Position ) ) != Position )
+            return( 0 ) ;
+        Position += Increment ;
+    }
+    return( 1 );
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_CheckDDRRank */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_CheckDDRRank( int RankNo , int index , USHORT DRAMTYPE_TABLE[][ 5 ], PVB_DEVICE_INFO pVBInfo)
+{
+    ULONG Increment , Position ;
+    USHORT data ;
+
+    Increment = 1 << ( DRAMTYPE_TABLE[ index ][ 2 ] + DRAMTYPE_TABLE[ index ][ 1 ] +
+                       DRAMTYPE_TABLE[ index ][ 0 ] + XGINew_DataBusWidth / 64 + RankNo ) ;
+
+    Increment += Increment / 2 ;
+
+    Position = 0;
+    *( ( PULONG )( pVBInfo->FBAddr + Position + 0 ) ) = 0x01234567 ;
+    *( ( PULONG )( pVBInfo->FBAddr + Position + 1 ) ) = 0x456789AB ;
+    *( ( PULONG )( pVBInfo->FBAddr + Position + 2 ) ) = 0x55555555 ;
+    *( ( PULONG )( pVBInfo->FBAddr + Position + 3 ) ) = 0x55555555 ;
+    *( ( PULONG )( pVBInfo->FBAddr + Position + 4 ) ) = 0xAAAAAAAA ;
+    *( ( PULONG )( pVBInfo->FBAddr + Position + 5 ) ) = 0xAAAAAAAA ;
+
+    if ( ( *( PULONG )( pVBInfo->FBAddr + 1 ) ) == 0x456789AB )
+        return( 1 ) ;
+
+    if ( ( *( PULONG )( pVBInfo->FBAddr + 0 ) ) == 0x01234567 )
+        return( 0 ) ;
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x14 ) ;
+    data &= 0xF3 ;
+    data |= 0x0E ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , data ) ;
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x15 ) ;
+    data += 0x20 ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x15 , data ) ;
+
+    return( 1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_CheckRanks */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_CheckRanks( int RankNo , int index , USHORT DRAMTYPE_TABLE[][ 5 ], PVB_DEVICE_INFO pVBInfo)
+{
+    int r ;
+
+    for( r = RankNo ; r >= 1 ; r-- )
+    {
+        if ( !XGINew_CheckRank( r , index , DRAMTYPE_TABLE, pVBInfo ) )
+            return( 0 ) ;
+    }
+
+    if ( !XGINew_CheckBanks( index , DRAMTYPE_TABLE, pVBInfo ) )
+        return( 0 ) ;
+
+    if ( !XGINew_CheckColumn( index , DRAMTYPE_TABLE, pVBInfo ) )
+        return( 0 ) ;
+
+    return( 1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_CheckDDRRanks */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_CheckDDRRanks( int RankNo , int index , USHORT DRAMTYPE_TABLE[][ 5 ], PVB_DEVICE_INFO pVBInfo)
+{
+    int r ;
+
+    for( r = RankNo ; r >= 1 ; r-- )
+    {
+        if ( !XGINew_CheckDDRRank( r , index , DRAMTYPE_TABLE, pVBInfo ) )
+            return( 0 ) ;
+    }
+
+    if ( !XGINew_CheckBanks( index , DRAMTYPE_TABLE, pVBInfo ) )
+        return( 0 ) ;
+
+    if ( !XGINew_CheckColumn( index , DRAMTYPE_TABLE, pVBInfo ) )
+        return( 0 ) ;
+
+    return( 1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_SDRSizing(PVB_DEVICE_INFO pVBInfo)
+{
+    int    i ;
+    UCHAR  j ;
+
+    for( i = 0 ; i < 13 ; i++ )
+    {
+        XGINew_SetDRAMSizingType( i , XGINew_SDRDRAM_TYPE , pVBInfo) ;
+
+        for( j = 2 ; j > 0 ; j-- )
+        {
+            if ( !XGINew_SetRank( i , ( UCHAR )j , XGINew_ChannelAB , XGINew_SDRDRAM_TYPE , pVBInfo) )
+                continue ;
+            else
+            {
+                if ( XGINew_CheckRanks( j , i , XGINew_SDRDRAM_TYPE, pVBInfo) )
+                    return( 1 ) ;
+            }
+        }
+    }
+    return( 0 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetDRAMSizeReg */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT XGINew_SetDRAMSizeReg( int index , USHORT DRAMTYPE_TABLE[][ 5 ], PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT data = 0 , memsize = 0 ;
+    int RankSize ;
+    UCHAR ChannelNo ;
+
+    RankSize = DRAMTYPE_TABLE[ index ][ 3 ] * XGINew_DataBusWidth / 32 ;
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x13 ) ;
+    data &= 0x80 ;
+
+    if ( data == 0x80 )
+        RankSize *= 2 ;
+
+    data = 0 ;
+
+    if( XGINew_ChannelAB == 3 )
+        ChannelNo = 4 ;
+    else
+        ChannelNo = XGINew_ChannelAB ;
+
+    if ( ChannelNo * RankSize <= 256 )
+    {
+        while( ( RankSize >>= 1 ) > 0 )
+        {
+            data += 0x10 ;
+        }
+
+        memsize = data >> 4 ;
+
+        /* [2004/03/25] Vicent, Fix DRAM Sizing Error */
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , ( XGINew_GetReg1( pVBInfo->P3c4 , 0x14 ) & 0x0F ) | ( data & 0xF0 ) ) ;
+
+       /* data |= XGINew_ChannelAB << 2 ; */
+       /* data |= ( XGINew_DataBusWidth / 64 ) << 1 ; */
+       /* XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , data ) ; */
+
+        /* should delay */
+        /* XGINew_SetDRAMModeRegister340( pVBInfo ) ; */
+    }
+    return( memsize ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetDRAMSize20Reg */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT XGINew_SetDRAMSize20Reg( int index , USHORT DRAMTYPE_TABLE[][ 5 ], PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT data = 0 , memsize = 0 ;
+    int RankSize ;
+    UCHAR ChannelNo ;
+
+    RankSize = DRAMTYPE_TABLE[ index ][ 3 ] * XGINew_DataBusWidth / 8 ;
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x13 ) ;
+    data &= 0x80 ;
+
+    if ( data == 0x80 )
+        RankSize *= 2 ;
+
+    data = 0 ;
+
+    if( XGINew_ChannelAB == 3 )
+        ChannelNo = 4 ;
+    else
+        ChannelNo = XGINew_ChannelAB ;
+
+    if ( ChannelNo * RankSize <= 256 )
+    {
+        while( ( RankSize >>= 1 ) > 0 )
+        {
+            data += 0x10 ;
+        }
+
+        memsize = data >> 4 ;
+
+        /* [2004/03/25] Vicent, Fix DRAM Sizing Error */
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , ( XGINew_GetReg1( pVBInfo->P3c4 , 0x14 ) & 0x0F ) | ( data & 0xF0 ) ) ;
+	DelayUS( 15 ) ;
+
+       /* data |= XGINew_ChannelAB << 2 ; */
+       /* data |= ( XGINew_DataBusWidth / 64 ) << 1 ; */
+       /* XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , data ) ; */
+
+        /* should delay */
+        /* XGINew_SetDRAMModeRegister340( pVBInfo ) ; */
+    }
+    return( memsize ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_ReadWriteRest */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_ReadWriteRest( USHORT StopAddr , USHORT StartAddr, PVB_DEVICE_INFO pVBInfo)
+{
+//    int i ;
+//    ULONG Position = 0 ;
+//
+//   *( ( PULONG )( pVBInfo->FBAddr + Position ) ) = Position ;
+//
+//    for( i = StartAddr ; i <= StopAddr ; i++ )
+//    {
+//        Position = 1 << i ;
+//        *( ( PULONG )( pVBInfo->FBAddr + Position ) ) = Position ;
+//    }
+//
+//    DelayUS( 500 ) ;	/* [Vicent] 2004/04/16. Fix #1759 Memory Size error in Multi-Adapter. */
+//
+//    Position = 0 ;
+//
+//    if ( ( *( PULONG )( pVBInfo->FBAddr + Position ) ) != Position )
+//        return( 0 ) ;
+//
+//    for( i = StartAddr ; i <= StopAddr ; i++ )
+//    {
+//        Position = 1 << i ;
+//        if ( ( *( PULONG )( pVBInfo->FBAddr + Position ) ) != Position )
+//            return( 0 ) ;
+//    }
+//    return( 1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_CheckFrequence */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+UCHAR XGINew_CheckFrequence( PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR data ;
+
+    data = XGINew_GetReg1( pVBInfo->P3d4 , 0x97 ) ;
+
+    if ( ( data & 0x10 ) == 0 )
+    {
+        data = XGINew_GetReg1( pVBInfo->P3c4 , 0x39 ) ;
+        data = ( data & 0x02 ) >> 1 ;
+        return( data ) ;
+    }
+    else
+        return( data & 0x01 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_CheckChannel */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_CheckChannel( PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR data;
+
+    switch( HwDeviceExtension->jChipType )
+    {
+      case XG20:
+      case XG21:
+          data = XGINew_GetReg1( pVBInfo->P3d4 , 0x97 ) ;
+          data = data & 0x01;
+          XGINew_ChannelAB = 1 ;		/* XG20 "JUST" one channel */
+
+          if ( data == 0 )  /* Single_32_16 */
+          {
+
+	      if (( HwDeviceExtension->ulVideoMemorySize - 1 ) > 0x1000000)
+	      {
+
+                XGINew_DataBusWidth = 32 ;	/* 32 bits */
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xB1 ) ;  /* 22bit + 2 rank + 32bit */
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x52 ) ;
+		DelayUS( 15 ) ;
+
+                if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                    return ;
+
+		if (( HwDeviceExtension->ulVideoMemorySize - 1 ) > 0x800000)
+		{
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x31 ) ;  /* 22bit + 1 rank + 32bit */
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x42 ) ;
+		  DelayUS( 15 ) ;
+
+                  if ( XGINew_ReadWriteRest( 23 , 23 , pVBInfo ) == 1 )
+                      return ;
+                }
+	      }
+
+	      if (( HwDeviceExtension->ulVideoMemorySize - 1 ) > 0x800000)
+	      {
+	        XGINew_DataBusWidth = 16 ;	/* 16 bits */
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xB1 ) ;  /* 22bit + 2 rank + 16bit */
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x41 ) ;
+		DelayUS( 15 ) ;
+
+                if ( XGINew_ReadWriteRest( 23 , 22 , pVBInfo ) == 1 )
+                    return ;
+                else
+                    XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x31 ) ;
+                    DelayUS( 15 ) ;
+              }
+
+          }
+          else  /* Dual_16_8 */
+          {
+              if (( HwDeviceExtension->ulVideoMemorySize - 1 ) > 0x800000)
+              {
+
+                XGINew_DataBusWidth = 16 ;	/* 16 bits */
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xB1 ) ;  /* (0x31:12x8x2) 22bit + 2 rank */
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x41 ) ;  /* 0x41:16Mx16 bit*/
+                DelayUS( 15 ) ;
+
+                if ( XGINew_ReadWriteRest( 23 , 22 , pVBInfo ) == 1 )
+                    return ;
+
+		if (( HwDeviceExtension->ulVideoMemorySize - 1 ) > 0x400000)
+		{
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x31 ) ;  /* (0x31:12x8x2) 22bit + 1 rank */
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x31 ) ;  /* 0x31:8Mx16 bit*/
+                  DelayUS( 15 ) ;
+
+                  if ( XGINew_ReadWriteRest( 22 , 22 , pVBInfo ) == 1 )
+                      return ;
+                }
+	      }
+
+
+	      if (( HwDeviceExtension->ulVideoMemorySize - 1 ) > 0x400000)
+	      {
+	        XGINew_DataBusWidth = 8 ;	/* 8 bits */
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xB1 ) ;  /* (0x31:12x8x2) 22bit + 2 rank */
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x30 ) ;  /* 0x30:8Mx8 bit*/
+                DelayUS( 15 ) ;
+
+                if ( XGINew_ReadWriteRest( 22 , 21 , pVBInfo ) == 1 )
+                    return ;
+                else
+                    XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x31 ) ;  /* (0x31:12x8x2) 22bit + 1 rank */
+                    DelayUS( 15 ) ;
+              }
+          }
+          break ;
+
+      case XG27:
+          XGINew_DataBusWidth = 16 ;	/* 16 bits */
+          XGINew_ChannelAB = 1 ;		/* Single channel */
+          XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x51 ) ;  /* 32Mx16 bit*/
+          break ;
+      case XG41:
+          if ( XGINew_CheckFrequence(pVBInfo) == 1 )
+          {
+              XGINew_DataBusWidth = 32 ;	/* 32 bits */
+              XGINew_ChannelAB = 3 ;		/* Quad Channel */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xA1 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x4C ) ;
+
+              if ( XGINew_ReadWriteRest( 25 , 23 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_ChannelAB = 2 ;		/* Dual channels */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x48 ) ;
+
+              if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x49 ) ;
+
+              if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_ChannelAB = 3 ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x21 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x3C ) ;
+
+              if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x38 ) ;
+
+              if ( XGINew_ReadWriteRest( 8 , 4 , pVBInfo ) == 1 )
+                  return ;
+              else
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x39 ) ;
+          }
+          else
+          {					/* DDR */
+              XGINew_DataBusWidth = 64 ;	/* 64 bits */
+              XGINew_ChannelAB = 2 ;		/* Dual channels */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xA1 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x5A ) ;
+
+              if ( XGINew_ReadWriteRest( 25 , 24 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_ChannelAB = 1 ;		/* Single channels */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x52 ) ;
+
+              if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x53 ) ;
+
+              if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_ChannelAB = 2 ;		/* Dual channels */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x21 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x4A ) ;
+
+              if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_ChannelAB = 1 ;		/* Single channels */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x42 ) ;
+
+              if ( XGINew_ReadWriteRest( 8 , 4 , pVBInfo ) == 1 )
+                  return ;
+              else
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x43 ) ;
+          }
+
+          break ;
+
+      case XG42:
+/*
+      	  XG42 SR14 D[3] Reserve
+      	  	    D[2] = 1, Dual Channel
+      	  	         = 0, Single Channel
+
+      	  It's Different from Other XG40 Series.
+*/
+          if ( XGINew_CheckFrequence(pVBInfo) == 1 )	/* DDRII, DDR2x */
+          {
+              XGINew_DataBusWidth = 32 ;	/* 32 bits */
+              XGINew_ChannelAB = 2 ;		/* 2 Channel */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xA1 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x44 ) ;
+
+              if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x21 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x34 ) ;
+              if ( XGINew_ReadWriteRest( 23 , 22 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_ChannelAB = 1 ;		/* Single Channel */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xA1 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x40 ) ;
+
+              if ( XGINew_ReadWriteRest( 23 , 22 , pVBInfo ) == 1 )
+                  return ;
+              else
+              {
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x21 ) ;
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x30 ) ;
+              }
+          }
+          else
+          {					/* DDR */
+              XGINew_DataBusWidth = 64 ;	/* 64 bits */
+              XGINew_ChannelAB = 1 ;		/* 1 channels */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xA1 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x52 ) ;
+
+              if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                  return ;
+              else
+              {
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x21 ) ;
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x42 ) ;
+              }
+          }
+
+          break ;
+
+      default:	/* XG40 */
+
+          if ( XGINew_CheckFrequence(pVBInfo) == 1 )	/* DDRII */
+          {
+              XGINew_DataBusWidth = 32 ;	/* 32 bits */
+              XGINew_ChannelAB = 3 ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xA1 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x4C ) ;
+
+              if ( XGINew_ReadWriteRest( 25 , 23 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_ChannelAB = 2 ;		/* 2 channels */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x48 ) ;
+
+              if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x21 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x3C ) ;
+
+              if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                  XGINew_ChannelAB = 3 ;	/* 4 channels */
+              else
+              {
+                  XGINew_ChannelAB = 2 ;	/* 2 channels */
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x38 ) ;
+              }
+          }
+          else
+          {					/* DDR */
+              XGINew_DataBusWidth = 64 ;	/* 64 bits */
+              XGINew_ChannelAB = 2 ;		/* 2 channels */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xA1 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x5A ) ;
+
+              if ( XGINew_ReadWriteRest( 25 , 24 , pVBInfo ) == 1 )
+                  return ;
+              else
+              {
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x21 ) ;
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x4A ) ;
+              }
+          }
+      	  break ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDRSizing340 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_DDRSizing340( PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+    int i ;
+    USHORT memsize , addr ;
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x15 , 0x00 ) ;	/* noninterleaving */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1C , 0x00 ) ;	/* nontiling */
+    XGINew_CheckChannel( HwDeviceExtension, pVBInfo ) ;
+
+
+    if ( HwDeviceExtension->jChipType >= XG20 )
+    {
+      for( i = 0 ; i < 12 ; i++ )
+      {
+        XGINew_SetDRAMSizingType( i , XGINew_DDRDRAM_TYPE20, pVBInfo ) ;
+        memsize = XGINew_SetDRAMSize20Reg( i , XGINew_DDRDRAM_TYPE20, pVBInfo ) ;
+        if ( memsize == 0 )
+            continue ;
+
+        addr = memsize + ( XGINew_ChannelAB - 2 ) + 20 ;
+        if ( ( HwDeviceExtension->ulVideoMemorySize - 1 ) < ( ULONG )( 1 << addr ) )
+            continue ;
+
+        if ( XGINew_ReadWriteRest( addr , 5, pVBInfo ) == 1 )
+            return( 1 ) ;
+      }
+    }
+    else
+    {
+      for( i = 0 ; i < 4 ; i++ )
+      {
+    	XGINew_SetDRAMSizingType( i , XGINew_DDRDRAM_TYPE340, pVBInfo ) ;
+        memsize = XGINew_SetDRAMSizeReg( i , XGINew_DDRDRAM_TYPE340, pVBInfo ) ;
+
+        if ( memsize == 0 )
+            continue ;
+
+        addr = memsize + ( XGINew_ChannelAB - 2 ) + 20 ;
+        if ( ( HwDeviceExtension->ulVideoMemorySize - 1 ) < ( ULONG )( 1 << addr ) )
+            continue ;
+
+        if ( XGINew_ReadWriteRest( addr , 9, pVBInfo ) == 1 )
+            return( 1 ) ;
+      }
+    }
+    return( 0 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDRSizing */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_DDRSizing(PVB_DEVICE_INFO pVBInfo)
+{
+    int    i ;
+    UCHAR  j ;
+
+    for( i = 0 ; i < 4 ; i++ )
+    {
+        XGINew_SetDRAMSizingType( i , XGINew_DDRDRAM_TYPE, pVBInfo ) ;
+        XGINew_DisableChannelInterleaving( i , XGINew_DDRDRAM_TYPE , pVBInfo) ;
+        for( j = 2 ; j > 0 ; j-- )
+        {
+            XGINew_SetDDRChannel( i , j , XGINew_ChannelAB , XGINew_DDRDRAM_TYPE , pVBInfo ) ;
+            if ( !XGINew_SetRank( i , ( UCHAR )j , XGINew_ChannelAB , XGINew_DDRDRAM_TYPE, pVBInfo ) )
+                continue ;
+            else
+            {
+                if ( XGINew_CheckDDRRanks( j , i , XGINew_DDRDRAM_TYPE,  pVBInfo ) )
+                return( 1 ) ;
+            }
+        }
+    }
+    return( 0 ) ;
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetMemoryClock */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetMemoryClock( PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+#ifndef LINUX_XF86
+    UCHAR tempal ;
+#endif
+
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x28 , pVBInfo->MCLKData[ XGINew_RAMType ].SR28 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x29 , pVBInfo->MCLKData[ XGINew_RAMType ].SR29 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2A , pVBInfo->MCLKData[ XGINew_RAMType ].SR2A ) ;
+
+
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2E , pVBInfo->ECLKData[ XGINew_RAMType ].SR2E ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2F , pVBInfo->ECLKData[ XGINew_RAMType ].SR2F ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x30 , pVBInfo->ECLKData[ XGINew_RAMType ].SR30 ) ;
+
+    /* [Vicent] 2004/07/07, When XG42 ECLK = MCLK = 207MHz, Set SR32 D[1:0] = 10b */
+    /* [Hsuan] 2004/08/20, Modify SR32 value, when MCLK=207MHZ, ELCK=250MHz, Set SR32 D[1:0] = 10b */
+    if ( HwDeviceExtension->jChipType == XG42 )
+    {
+      if ( ( pVBInfo->MCLKData[ XGINew_RAMType ].SR28 == 0x1C ) && ( pVBInfo->MCLKData[ XGINew_RAMType ].SR29 == 0x01 )
+        && ( ( ( pVBInfo->ECLKData[ XGINew_RAMType ].SR2E == 0x1C ) && ( pVBInfo->ECLKData[ XGINew_RAMType ].SR2F == 0x01 ) )
+        || ( ( pVBInfo->ECLKData[ XGINew_RAMType ].SR2E == 0x22 ) && ( pVBInfo->ECLKData[ XGINew_RAMType ].SR2F == 0x01 ) ) ) )
+      {
+      	XGINew_SetReg1( pVBInfo->P3c4 , 0x32 , ( ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x32 ) & 0xFC ) | 0x02 ) ;
+      }
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : ChkLFB */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN ChkLFB( PVB_DEVICE_INFO pVBInfo )
+{
+    if ( LFBDRAMTrap & XGINew_GetReg1( pVBInfo->P3d4 , 0x78 ) )
+        return( TRUE ) ;
+    else
+        return( FALSE );
+}
+
+
+/* --------------------------------------------------------------------- */
+/* input : dx ,valid value : CR or second chip's CR */
+/*  */
+/* SetPowerConsume : */
+/* Description: reduce 40/43 power consumption in first chip or */
+/* in second chip, assume CR A1 D[6]="1" in this case */
+/* output : none */
+/* --------------------------------------------------------------------- */
+void SetPowerConsume ( PXGI_HW_DEVICE_INFO HwDeviceExtension , ULONG XGI_P3d4Port )
+{
+    ULONG   lTemp ;
+    UCHAR   bTemp;
+
+    HwDeviceExtension->pQueryVGAConfigSpace( HwDeviceExtension , 0x08 , 0 , &lTemp ) ; /* Get */
+    if ((lTemp&0xFF)==0)
+    {
+        /* set CR58 D[5]=0 D[3]=0 */
+        XGINew_SetRegAND( XGI_P3d4Port , 0x58 , 0xD7 ) ;
+        bTemp = (UCHAR) XGINew_GetReg1( XGI_P3d4Port , 0xCB ) ;
+    	if (bTemp&0x20)
+    	{
+            if (!(bTemp&0x10))
+            {
+            	XGINew_SetRegANDOR( XGI_P3d4Port , 0x58 , 0xD7 , 0x20 ) ; /* CR58 D[5]=1 D[3]=0 */
+            }
+            else
+            {
+            	XGINew_SetRegANDOR( XGI_P3d4Port , 0x58 , 0xD7 , 0x08 ) ; /* CR58 D[5]=0 D[3]=1 */
+            }
+
+    	}
+
+    }
+}
+
+
+
+#if defined(LINUX_XF86)||defined(LINUX_KERNEL)
+void XGINew_InitVBIOSData(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+
+	/* ULONG ROMAddr = (ULONG)HwDeviceExtension->pjVirtualRomBase; */
+    pVBInfo->ROMAddr = HwDeviceExtension->pjVirtualRomBase ;
+    pVBInfo->FBAddr = HwDeviceExtension->pjVideoMemoryAddress ;
+    pVBInfo->BaseAddr = HwDeviceExtension->pjIOAddress ;
+    pVBInfo->ISXPDOS = 0 ;
+
+    pVBInfo->P3c4 = pVBInfo->BaseAddr + 0x14 ;
+    pVBInfo->P3d4 = pVBInfo->BaseAddr + 0x24 ;
+    pVBInfo->P3c0 = pVBInfo->BaseAddr + 0x10 ;
+    pVBInfo->P3ce = pVBInfo->BaseAddr + 0x1e ;
+    pVBInfo->P3c2 = pVBInfo->BaseAddr + 0x12 ;
+    pVBInfo->P3ca = pVBInfo->BaseAddr + 0x1a ;
+    pVBInfo->P3c6 = pVBInfo->BaseAddr + 0x16 ;
+    pVBInfo->P3c7 = pVBInfo->BaseAddr + 0x17 ;
+    pVBInfo->P3c8 = pVBInfo->BaseAddr + 0x18 ;
+    pVBInfo->P3c9 = pVBInfo->BaseAddr + 0x19 ;
+    pVBInfo->P3da = pVBInfo->BaseAddr + 0x2A ;
+    pVBInfo->Part0Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_00 ;
+    pVBInfo->Part1Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_04 ;
+    pVBInfo->Part2Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_10 ;
+    pVBInfo->Part3Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_12 ;
+    pVBInfo->Part4Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 ;
+    pVBInfo->Part5Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 + 2 ;
+    if ( HwDeviceExtension->jChipType < XG20 )                  /* kuku 2004/06/25 */
+    XGI_GetVBType( pVBInfo ) ;         /* Run XGI_GetVBType before InitTo330Pointer */
+
+	switch(HwDeviceExtension->jChipType)
+	{
+	case XG40:
+	case XG41:
+	case XG42:
+	case XG20:
+	case XG21:
+	default:
+		InitTo330Pointer(HwDeviceExtension->jChipType,pVBInfo);
+		return ;
+	}
+
+}
+#endif /* For Linux */
+
+/* --------------------------------------------------------------------- */
+/* Function : ReadVBIOSTablData */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void ReadVBIOSTablData( UCHAR ChipType , PVB_DEVICE_INFO pVBInfo)
+{
+#ifndef LINUX_XF86
+    ULONG   ulOffset ;
+    UCHAR   temp , index , l ;
+#endif
+    PUCHAR  volatile pVideoMemory = ( PUCHAR )pVBInfo->ROMAddr ;
+    ULONG   i ;
+    UCHAR   j , k ;
+    ULONG   ii , jj ;
+#if 0
+    i = pVideoMemory[ 0x1CF ] | ( pVideoMemory[ 0x1D0 ] << 8 ) ;		/* UniROM */
+    if ( i != 0 )
+        UNIROM = 1 ;
+
+    ii = 0x90 ;
+    for( jj = 0x00 ; jj < 0x08 ; jj++ )
+    {
+        pVBInfo->MCLKData[ jj ].SR28 = pVideoMemory[ ii ] ;
+        pVBInfo->MCLKData[ jj ].SR29 = pVideoMemory[ ii + 1] ;
+        pVBInfo->MCLKData[ jj ].SR2A = pVideoMemory[ ii + 2] ;
+        pVBInfo->MCLKData[ jj ].CLOCK = pVideoMemory[ ii + 3 ] | ( pVideoMemory[ ii + 4 ] << 8 ) ;
+        ii += 0x05 ;
+    }
+
+    ii = 0xB8 ;
+    for( jj = 0x00 ; jj < 0x08 ; jj++ )
+    {
+        pVBInfo->ECLKData[ jj ].SR2E = pVideoMemory[ ii ] ;
+        pVBInfo->ECLKData[ jj ].SR2F=pVideoMemory[ ii + 1 ] ;
+        pVBInfo->ECLKData[ jj ].SR30= pVideoMemory[ ii + 2 ] ;
+        pVBInfo->ECLKData[ jj ].CLOCK= pVideoMemory[ ii + 3 ] | ( pVideoMemory[ ii + 4 ] << 8 ) ;
+        ii += 0x05 ;
+    }
+
+    /* Volari customize data area start */
+    /* if ( ChipType == XG40 ) */
+    if ( ChipType >= XG40 )
+    {
+        ii = 0xE0 ;
+        for( jj = 0x00 ; jj < 0x03 ; jj++ )
+        {
+            pVBInfo->SR15[ jj ][ 0 ] = pVideoMemory[ ii ] ;		/* SR13, SR14, and SR18 */
+            pVBInfo->SR15[ jj ][ 1 ] = pVideoMemory[ ii + 1 ] ;
+            pVBInfo->SR15[ jj ][ 2 ] = pVideoMemory[ ii + 2 ] ;
+            pVBInfo->SR15[ jj ][ 3 ] = pVideoMemory[ ii + 3 ] ;
+            pVBInfo->SR15[ jj ][ 4 ] = pVideoMemory[ ii + 4 ] ;
+            pVBInfo->SR15[ jj ][ 5 ] = pVideoMemory[ ii + 5 ] ;
+            pVBInfo->SR15[ jj ][ 6 ] = pVideoMemory[ ii + 6 ] ;
+            pVBInfo->SR15[ jj ][ 7 ] = pVideoMemory[ ii + 7 ] ;
+            ii += 0x08 ;
+        }
+        ii = 0x110 ;
+        jj = 0x03 ;
+        pVBInfo->SR15[ jj ][ 0 ] = pVideoMemory[ ii ] ;		/* SR1B */
+        pVBInfo->SR15[ jj ][ 1 ] = pVideoMemory[ ii + 1 ] ;
+        pVBInfo->SR15[ jj ][ 2 ] = pVideoMemory[ ii + 2 ] ;
+        pVBInfo->SR15[ jj ][ 3 ] = pVideoMemory[ ii + 3 ] ;
+        pVBInfo->SR15[ jj ][ 4 ] = pVideoMemory[ ii + 4 ] ;
+        pVBInfo->SR15[ jj ][ 5 ] = pVideoMemory[ ii + 5 ] ;
+        pVBInfo->SR15[ jj ][ 6 ] = pVideoMemory[ ii + 6 ] ;
+        pVBInfo->SR15[ jj ][ 7 ] = pVideoMemory[ ii + 7 ] ;
+
+        *pVBInfo->pSR07 = pVideoMemory[ 0x74 ] ;
+        *pVBInfo->pSR1F = pVideoMemory[ 0x75 ] ;
+        *pVBInfo->pSR21 = pVideoMemory[ 0x76 ] ;
+        *pVBInfo->pSR22 = pVideoMemory[ 0x77 ] ;
+        *pVBInfo->pSR23 = pVideoMemory[ 0x78 ] ;
+        *pVBInfo->pSR24 = pVideoMemory[ 0x79 ] ;
+        pVBInfo->SR25[ 0 ] = pVideoMemory[ 0x7A ] ;
+        *pVBInfo->pSR31 = pVideoMemory[ 0x7B ] ;
+        *pVBInfo->pSR32 = pVideoMemory[ 0x7C ] ;
+        *pVBInfo->pSR33 = pVideoMemory[ 0x7D ] ;
+        ii = 0xF8 ;
+
+        for( jj = 0 ; jj < 3 ; jj++ )
+        {
+            pVBInfo->CR40[ jj ][ 0 ] = pVideoMemory[ ii ] ;
+            pVBInfo->CR40[ jj ][ 1 ] = pVideoMemory[ ii + 1 ] ;
+            pVBInfo->CR40[ jj ][ 2 ] = pVideoMemory[ ii + 2 ] ;
+            pVBInfo->CR40[ jj ][ 3 ] = pVideoMemory[ ii + 3 ] ;
+            pVBInfo->CR40[ jj ][ 4 ] = pVideoMemory[ ii + 4 ] ;
+            pVBInfo->CR40[ jj ][ 5 ] = pVideoMemory[ ii + 5 ] ;
+            pVBInfo->CR40[ jj ][ 6 ] = pVideoMemory[ ii + 6 ] ;
+            pVBInfo->CR40[ jj ][ 7 ] = pVideoMemory[ ii + 7 ] ;
+            ii += 0x08 ;
+        }
+
+        ii = 0x118 ;
+        for( j = 3 ; j < 24 ; j++ )
+        {
+            pVBInfo->CR40[ j ][ 0 ] = pVideoMemory[ ii ] ;
+            pVBInfo->CR40[ j ][ 1 ] = pVideoMemory[ ii + 1 ] ;
+            pVBInfo->CR40[ j ][ 2 ] = pVideoMemory[ ii + 2 ] ;
+            pVBInfo->CR40[ j ][ 3 ] = pVideoMemory[ ii + 3 ] ;
+            pVBInfo->CR40[ j ][ 4 ] = pVideoMemory[ ii + 4 ] ;
+            pVBInfo->CR40[ j ][ 5 ] = pVideoMemory[ ii + 5 ] ;
+            pVBInfo->CR40[ j ][ 6 ] = pVideoMemory[ ii + 6 ] ;
+            pVBInfo->CR40[ j ][ 7 ] = pVideoMemory[ ii + 7 ] ;
+            ii += 0x08 ;
+        }
+
+        i = pVideoMemory[ 0x1C0 ] | ( pVideoMemory[ 0x1C1 ] << 8 ) ;
+
+        for( j = 0 ; j < 8 ; j++ )
+        {
+            for( k = 0 ; k < 4 ; k++ )
+                pVBInfo->CR6B[ j ][ k ] = pVideoMemory[ i + 4 * j + k ] ;
+        }
+
+        i = pVideoMemory[ 0x1C2 ] | ( pVideoMemory[ 0x1C3 ] << 8 ) ;
+
+        for( j = 0 ; j < 8 ; j++ )
+        {
+            for( k = 0 ; k < 4 ; k++ )
+                pVBInfo->CR6E[ j ][ k ] = pVideoMemory[ i + 4 * j + k ] ;
+        }
+
+        i = pVideoMemory[ 0x1C4 ] | ( pVideoMemory[ 0x1C5 ] << 8 ) ;
+        for( j = 0 ; j < 8 ; j++ )
+        {
+            for( k = 0 ; k < 32 ; k++ )
+                pVBInfo->CR6F[ j ][ k ] = pVideoMemory[ i + 32 * j + k ] ;
+        }
+
+        i = pVideoMemory[ 0x1C6 ] | ( pVideoMemory[ 0x1C7 ] << 8 ) ;
+
+        for( j = 0 ; j < 8 ; j++ )
+        {
+            for( k = 0 ; k < 2 ; k++ )
+                pVBInfo->CR89[ j ][ k ] = pVideoMemory[ i + 2 * j + k ] ;
+        }
+
+        i = pVideoMemory[ 0x1C8 ] | ( pVideoMemory[ 0x1C9 ] << 8 ) ;
+        for( j = 0 ; j < 12 ; j++ )
+            pVBInfo->AGPReg[ j ] = pVideoMemory[ i + j ] ;
+
+        i = pVideoMemory[ 0x1CF ] | ( pVideoMemory[ 0x1D0 ] << 8 ) ;
+        for( j = 0 ; j < 4 ; j++ )
+            pVBInfo->SR16[ j ] = pVideoMemory[ i + j ] ;
+
+        *pVBInfo->pCRCF = pVideoMemory[ 0x1CA ] ;
+        *pVBInfo->pXGINew_DRAMTypeDefinition = pVideoMemory[ 0x1CB ] ;
+        *pVBInfo->pXGINew_I2CDefinition = pVideoMemory[ 0x1D1 ] ;
+        if ( ChipType >= XG20 )
+           *pVBInfo->pXGINew_CR97 = pVideoMemory[ 0x1D2 ] ;
+    }
+    /* Volari customize data area end */
+#endif
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDR1x_MRS_XG20 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DDR1x_MRS_XG20( ULONG P3c4 , PVB_DEVICE_INFO pVBInfo)
+{
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x01 ) ;
+    XGINew_SetReg1( P3c4 , 0x19 , 0x40 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+    DelayUS( 60 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;
+    XGINew_SetReg1( P3c4 , 0x19 , 0x40 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+    DelayUS( 60 ) ;
+    XGINew_SetReg1( P3c4 , 0x18 , pVBInfo->SR15[ 2 ][ XGINew_RAMType ] ) ;	/* SR18 */
+    /* XGINew_SetReg1( P3c4 , 0x18 , 0x31 ) ; */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x01 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x03 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x83 ) ;
+    DelayUS( 1000 ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x03 ) ;
+    DelayUS( 500 ) ;
+    /* XGINew_SetReg1( P3c4 , 0x18 , 0x31 ) ; */
+    XGINew_SetReg1( P3c4 , 0x18 , pVBInfo->SR15[ 2 ][ XGINew_RAMType ] ) ;	/* SR18 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x00 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x03 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x83 ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x00 ) ;
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetDRAMModeRegister_XG20 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetDRAMModeRegister_XG20( PXGI_HW_DEVICE_INFO HwDeviceExtension )
+{
+#ifndef LINUX_XF86
+    UCHAR data ;
+#endif
+    VB_DEVICE_INFO VBINF;
+    PVB_DEVICE_INFO pVBInfo = &VBINF;
+    pVBInfo->ROMAddr = HwDeviceExtension->pjVirtualRomBase ;
+    pVBInfo->FBAddr = HwDeviceExtension->pjVideoMemoryAddress ;
+    pVBInfo->BaseAddr = HwDeviceExtension->pjIOAddress ;
+    pVBInfo->ISXPDOS = 0 ;
+
+    pVBInfo->P3c4 = pVBInfo->BaseAddr + 0x14 ;
+    pVBInfo->P3d4 = pVBInfo->BaseAddr + 0x24 ;
+    pVBInfo->P3c0 = pVBInfo->BaseAddr + 0x10 ;
+    pVBInfo->P3ce = pVBInfo->BaseAddr + 0x1e ;
+    pVBInfo->P3c2 = pVBInfo->BaseAddr + 0x12 ;
+    pVBInfo->P3ca = pVBInfo->BaseAddr + 0x1a ;
+    pVBInfo->P3c6 = pVBInfo->BaseAddr + 0x16 ;
+    pVBInfo->P3c7 = pVBInfo->BaseAddr + 0x17 ;
+    pVBInfo->P3c8 = pVBInfo->BaseAddr + 0x18 ;
+    pVBInfo->P3c9 = pVBInfo->BaseAddr + 0x19 ;
+    pVBInfo->P3da = pVBInfo->BaseAddr + 0x2A ;
+    pVBInfo->Part0Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_00 ;
+    pVBInfo->Part1Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_04 ;
+    pVBInfo->Part2Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_10 ;
+    pVBInfo->Part3Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_12 ;
+    pVBInfo->Part4Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 ;
+    pVBInfo->Part5Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 + 2 ;
+
+    InitTo330Pointer(HwDeviceExtension->jChipType,pVBInfo);
+
+    ReadVBIOSTablData( HwDeviceExtension->jChipType , pVBInfo) ;
+
+    if ( XGINew_GetXG20DRAMType( HwDeviceExtension, pVBInfo) == 0 )
+        XGINew_DDR1x_MRS_XG20( pVBInfo->P3c4, pVBInfo ) ;
+    else
+        XGINew_DDR2_MRS_XG20( HwDeviceExtension , pVBInfo->P3c4 , pVBInfo ) ;
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1B , 0x03 ) ;
+}
+
+void XGINew_SetDRAMModeRegister_XG27( PXGI_HW_DEVICE_INFO HwDeviceExtension )
+{
+#ifndef LINUX_XF86
+    UCHAR data ;
+#endif
+    VB_DEVICE_INFO VBINF;
+    PVB_DEVICE_INFO pVBInfo = &VBINF;
+    pVBInfo->ROMAddr = HwDeviceExtension->pjVirtualRomBase ;
+    pVBInfo->FBAddr = HwDeviceExtension->pjVideoMemoryAddress ;
+    pVBInfo->BaseAddr = HwDeviceExtension->pjIOAddress ;
+    pVBInfo->ISXPDOS = 0 ;
+
+    pVBInfo->P3c4 = pVBInfo->BaseAddr + 0x14 ;
+    pVBInfo->P3d4 = pVBInfo->BaseAddr + 0x24 ;
+    pVBInfo->P3c0 = pVBInfo->BaseAddr + 0x10 ;
+    pVBInfo->P3ce = pVBInfo->BaseAddr + 0x1e ;
+    pVBInfo->P3c2 = pVBInfo->BaseAddr + 0x12 ;
+    pVBInfo->P3ca = pVBInfo->BaseAddr + 0x1a ;
+    pVBInfo->P3c6 = pVBInfo->BaseAddr + 0x16 ;
+    pVBInfo->P3c7 = pVBInfo->BaseAddr + 0x17 ;
+    pVBInfo->P3c8 = pVBInfo->BaseAddr + 0x18 ;
+    pVBInfo->P3c9 = pVBInfo->BaseAddr + 0x19 ;
+    pVBInfo->P3da = pVBInfo->BaseAddr + 0x2A ;
+    pVBInfo->Part0Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_00 ;
+    pVBInfo->Part1Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_04 ;
+    pVBInfo->Part2Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_10 ;
+    pVBInfo->Part3Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_12 ;
+    pVBInfo->Part4Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 ;
+    pVBInfo->Part5Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 + 2 ;
+
+    InitTo330Pointer(HwDeviceExtension->jChipType,pVBInfo);
+
+    ReadVBIOSTablData( HwDeviceExtension->jChipType , pVBInfo) ;
+
+    if ( XGINew_GetXG20DRAMType( HwDeviceExtension, pVBInfo) == 0 )
+        XGINew_DDR1x_MRS_XG20( pVBInfo->P3c4, pVBInfo ) ;
+    else
+        //XGINew_DDR2_MRS_XG27( HwDeviceExtension , pVBInfo->P3c4 , pVBInfo ) ;
+        XGINew_DDRII_Bootup_XG27( HwDeviceExtension , pVBInfo->P3c4 , pVBInfo) ;
+
+    //XGINew_SetReg1( pVBInfo->P3c4 , 0x1B , 0x03 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1B , pVBInfo->SR15[ 3 ][ XGINew_RAMType ] ) ;	/* SR1B */
+
+}
+/*
+void XGINew_SetDRAMModeRegister_XG27( PXGI_HW_DEVICE_INFO HwDeviceExtension )
+{
+#ifndef LINUX_XF86
+    UCHAR data ;
+#endif
+    VB_DEVICE_INFO VBINF;
+    PVB_DEVICE_INFO pVBInfo = &VBINF;
+    pVBInfo->ROMAddr = HwDeviceExtension->pjVirtualRomBase ;
+    pVBInfo->FBAddr = HwDeviceExtension->pjVideoMemoryAddress ;
+    pVBInfo->BaseAddr = HwDeviceExtension->pjIOAddress ;
+    pVBInfo->ISXPDOS = 0 ;
+
+    pVBInfo->P3c4 = pVBInfo->BaseAddr + 0x14 ;
+    pVBInfo->P3d4 = pVBInfo->BaseAddr + 0x24 ;
+    pVBInfo->P3c0 = pVBInfo->BaseAddr + 0x10 ;
+    pVBInfo->P3ce = pVBInfo->BaseAddr + 0x1e ;
+    pVBInfo->P3c2 = pVBInfo->BaseAddr + 0x12 ;
+    pVBInfo->P3ca = pVBInfo->BaseAddr + 0x1a ;
+    pVBInfo->P3c6 = pVBInfo->BaseAddr + 0x16 ;
+    pVBInfo->P3c7 = pVBInfo->BaseAddr + 0x17 ;
+    pVBInfo->P3c8 = pVBInfo->BaseAddr + 0x18 ;
+    pVBInfo->P3c9 = pVBInfo->BaseAddr + 0x19 ;
+    pVBInfo->P3da = pVBInfo->BaseAddr + 0x2A ;
+    pVBInfo->Part0Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_00 ;
+    pVBInfo->Part1Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_04 ;
+    pVBInfo->Part2Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_10 ;
+    pVBInfo->Part3Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_12 ;
+    pVBInfo->Part4Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 ;
+    pVBInfo->Part5Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 + 2 ;
+
+    InitTo330Pointer(HwDeviceExtension->jChipType,pVBInfo);
+
+    ReadVBIOSTablData( HwDeviceExtension->jChipType , pVBInfo) ;
+
+    if ( XGINew_GetXG20DRAMType( HwDeviceExtension, pVBInfo) == 0 )
+        XGINew_DDR1x_MRS_XG20( pVBInfo->P3c4, pVBInfo ) ;
+    else
+        XGINew_DDR2_MRS_XG27( HwDeviceExtension , pVBInfo->P3c4 , pVBInfo ) ;
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1B , 0x03 ) ;
+}
+*/
+/* -------------------------------------------------------- */
+/* Function : XGINew_ChkSenseStatus */
+/* Input : */
+/* Output : */
+/* Description : */
+/* -------------------------------------------------------- */
+void XGINew_ChkSenseStatus ( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempbx=0 , temp , tempcx , CR3CData;
+
+    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x32 ) ;
+
+    if ( temp & Monitor1Sense )
+    	tempbx |= ActiveCRT1 ;
+    if ( temp & LCDSense )
+    	tempbx |= ActiveLCD ;
+    if ( temp & Monitor2Sense )
+    	tempbx |= ActiveCRT2 ;
+    if ( temp & TVSense )
+    {
+    	tempbx |= ActiveTV ;
+    	if ( temp & AVIDEOSense )
+    	    tempbx |= ( ActiveAVideo << 8 );
+    	if ( temp & SVIDEOSense )
+    	    tempbx |= ( ActiveSVideo << 8 );
+    	if ( temp & SCARTSense )
+    	    tempbx |= ( ActiveSCART << 8 );
+    	if ( temp & HiTVSense )
+    	    tempbx |= ( ActiveHiTV << 8 );
+    	if ( temp & YPbPrSense )
+    	    tempbx |= ( ActiveYPbPr << 8 );
+    }
+
+    tempcx = XGINew_GetReg1( pVBInfo->P3d4 , 0x3d ) ;
+    tempcx |= ( XGINew_GetReg1( pVBInfo->P3d4 , 0x3e ) << 8 ) ;
+
+    if ( tempbx & tempcx )
+    {
+    	CR3CData = XGINew_GetReg1( pVBInfo->P3d4 , 0x3c ) ;
+    	if ( !( CR3CData & DisplayDeviceFromCMOS ) )
+    	{
+    	    tempcx = 0x1FF0 ;
+    	    if ( *pVBInfo->pSoftSetting & ModeSoftSetting )
+    	    {
+    	    	tempbx = 0x1FF0 ;
+    	    }
+    	}
+    }
+    else
+    {
+    	tempcx = 0x1FF0 ;
+    	if ( *pVBInfo->pSoftSetting & ModeSoftSetting )
+    	{
+    	    tempbx = 0x1FF0 ;
+    	}
+    }
+
+    tempbx &= tempcx ;
+    XGINew_SetReg1( pVBInfo->P3d4, 0x3d , ( tempbx & 0x00FF ) ) ;
+    XGINew_SetReg1( pVBInfo->P3d4, 0x3e , ( ( tempbx & 0xFF00 ) >> 8 )) ;
+}
+/* -------------------------------------------------------- */
+/* Function : XGINew_SetModeScratch */
+/* Input : */
+/* Output : */
+/* Description : */
+/* -------------------------------------------------------- */
+void XGINew_SetModeScratch ( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT temp , tempcl = 0 , tempch = 0 , CR31Data , CR38Data;
+
+    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x3d ) ;
+    temp |= XGINew_GetReg1( pVBInfo->P3d4 , 0x3e ) << 8 ;
+    temp |= ( XGINew_GetReg1( pVBInfo->P3d4 , 0x31 ) & ( DriverMode >> 8) ) << 8 ;
+
+    if ( pVBInfo->IF_DEF_CRT2Monitor == 1)
+    {
+    	if ( temp & ActiveCRT2 )
+    	   tempcl = SetCRT2ToRAMDAC ;
+    }
+
+    if ( temp & ActiveLCD )
+    {
+    	tempcl |= SetCRT2ToLCD ;
+    	if  ( temp & DriverMode )
+    	{
+    	    if ( temp & ActiveTV )
+    	    {
+    	    	tempch = SetToLCDA | EnableDualEdge ;
+    	    	temp ^= SetCRT2ToLCD ;
+
+    	    	if ( ( temp >> 8 ) & ActiveAVideo )
+    	    	    tempcl |= SetCRT2ToAVIDEO ;
+    	    	if ( ( temp >> 8 ) & ActiveSVideo )
+    	    	    tempcl |= SetCRT2ToSVIDEO ;
+    	    	if ( ( temp >> 8 ) & ActiveSCART )
+    	    	    tempcl |= SetCRT2ToSCART ;
+
+    	    	if ( pVBInfo->IF_DEF_HiVision == 1 )
+    	    	{
+    	    	    if ( ( temp >> 8 ) & ActiveHiTV )
+    	    	    tempcl |= SetCRT2ToHiVisionTV ;
+    	    	}
+
+    	    	if ( pVBInfo->IF_DEF_YPbPr == 1 )
+    	    	{
+    	    	    if ( ( temp >> 8 ) & ActiveYPbPr )
+    	    	    tempch |= SetYPbPr ;
+    	    	}
+    	    }
+    	}
+    }
+    else
+    {
+    	if ( ( temp >> 8 ) & ActiveAVideo )
+    	   tempcl |= SetCRT2ToAVIDEO ;
+    	if ( ( temp >> 8 ) & ActiveSVideo )
+  	   tempcl |= SetCRT2ToSVIDEO ;
+    	if ( ( temp >> 8 ) & ActiveSCART )
+   	   tempcl |= SetCRT2ToSCART ;
+
+   	if ( pVBInfo->IF_DEF_HiVision == 1 )
+    	{
+    	   if ( ( temp >> 8 ) & ActiveHiTV )
+    	   tempcl |= SetCRT2ToHiVisionTV ;
+    	}
+
+    	if ( pVBInfo->IF_DEF_YPbPr == 1 )
+    	{
+    	   if ( ( temp >> 8 ) & ActiveYPbPr )
+    	   tempch |= SetYPbPr ;
+    	}
+    }
+
+
+    tempcl |= SetSimuScanMode ;
+    if ( (!( temp & ActiveCRT1 )) && ( ( temp & ActiveLCD ) || ( temp & ActiveTV ) || ( temp & ActiveCRT2 ) ) )
+       tempcl ^= ( SetSimuScanMode | SwitchToCRT2 ) ;
+    if ( ( temp & ActiveLCD ) && ( temp & ActiveTV ) )
+       tempcl ^= ( SetSimuScanMode | SwitchToCRT2 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4, 0x30 , tempcl ) ;
+
+    CR31Data = XGINew_GetReg1( pVBInfo->P3d4 , 0x31 ) ;
+    CR31Data &= ~( SetNotSimuMode >> 8 ) ;
+    if ( !( temp & ActiveCRT1 ) )
+        CR31Data |= ( SetNotSimuMode >> 8 ) ;
+    CR31Data &= ~( DisableCRT2Display >> 8 ) ;
+    if  (!( ( temp & ActiveLCD ) || ( temp & ActiveTV ) || ( temp & ActiveCRT2 ) ) )
+        CR31Data |= ( DisableCRT2Display >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4, 0x31 , CR31Data ) ;
+
+    CR38Data = XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) ;
+    CR38Data &= ~SetYPbPr ;
+    CR38Data |= tempch ;
+    XGINew_SetReg1( pVBInfo->P3d4, 0x38 , CR38Data ) ;
+
+}
+
+/* -------------------------------------------------------- */
+/* Function : XGINew_GetXG21Sense */
+/* Input : */
+/* Output : */
+/* Description : */
+/* -------------------------------------------------------- */
+void XGINew_GetXG21Sense(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR Temp;
+    PUCHAR  volatile pVideoMemory = ( PUCHAR )pVBInfo->ROMAddr ;
+
+    pVBInfo->IF_DEF_LVDS = 0 ;
+     
+#ifdef WIN2000   
+   pVBInfo->IF_DEF_CH7007 = 0 ;
+    if ( ( pVideoMemory[ 0x65 ] & 0x02 ) )			/* For XG21 CH7007 */
+    {
+        /* VideoDebugPrint((0, "ReadVBIOSTablData: pVideoMemory[ 0x65 ] =%x\n",pVideoMemory[ 0x65 ])); */
+        pVBInfo->IF_DEF_CH7007 = 1 ;                            /* [Billy] 07/05/03 */
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x38 , ~0xE0 , 0x60 ) ; /* CH7007 on chip */
+    }
+    else    
+#endif
+#if 0
+    if ( ( pVideoMemory[ 0x65 ] & 0x01 ) )			/* For XG21 LVDS */
+    {
+        pVBInfo->IF_DEF_LVDS = 1 ;
+        XGINew_SetRegOR( pVBInfo->P3d4 , 0x32 , LCDSense ) ;
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x38 , ~0xE0 , 0xC0 ) ; /* LVDS on chip */
+    }
+    else
+    {
+#endif
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x4A , ~0x03 , 0x03 ) ; /* Enable GPIOA/B read  */
+        Temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x48 ) & 0xC0;
+        if ( Temp == 0xC0 )
+        {								/* DVI & DVO GPIOA/B pull high */
+          XGINew_SenseLCD( HwDeviceExtension, pVBInfo ) ;
+          XGINew_SetRegOR( pVBInfo->P3d4 , 0x32 , LCDSense ) ;
+          XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x4A , ~0x20 , 0x20 ) ;   /* Enable read GPIOF */
+          Temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x48 ) & 0x04 ;
+          if ( !Temp )
+            XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x38 , ~0xE0 , 0x80 ) ; /* TMDS on chip */
+          else
+            XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x38 , ~0xE0 , 0xA0 ) ; /* Only DVO on chip */
+          XGINew_SetRegAND( pVBInfo->P3d4 , 0x4A , ~0x20 ) ;	    /* Disable read GPIOF */
+        }
+#if 0
+    }
+#endif
+}
+
+/* -------------------------------------------------------- */
+/* Function : XGINew_GetXG27Sense */
+/* Input : */
+/* Output : */
+/* Description : */
+/* -------------------------------------------------------- */
+void XGINew_GetXG27Sense(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR Temp,bCR4A;
+    PUCHAR  volatile pVideoMemory = ( PUCHAR )pVBInfo->ROMAddr ;
+
+     pVBInfo->IF_DEF_LVDS = 0 ;
+     bCR4A = XGINew_GetReg1( pVBInfo->P3d4 , 0x4A ) ;
+     XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x4A , ~0x07 , 0x07 ) ; /* Enable GPIOA/B/C read  */
+     Temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x48 ) & 0x07;
+     XGINew_SetReg1( pVBInfo->P3d4, 0x4A , bCR4A ) ;
+     
+     if ( Temp <= 0x02 )
+     {
+         pVBInfo->IF_DEF_LVDS = 1 ;
+         XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x38 , ~0xE0 , 0xC0 ) ; /* LVDS setting */
+         XGINew_SetReg1( pVBInfo->P3d4, 0x30 , 0x21 ) ;
+     }
+     else
+     {
+       XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x38 , ~0xE0 , 0xA0 ) ; /* TMDS/DVO setting */
+     }
+     XGINew_SetRegOR( pVBInfo->P3d4 , 0x32 , LCDSense ) ;
+
+}
+
+UCHAR GetXG21FPBits(PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR CR38,CR4A,temp;
+    
+    CR4A = XGINew_GetReg1( pVBInfo->P3d4 , 0x4A ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x4A , ~0x10 , 0x10 ) ; /* enable GPIOE read */
+    CR38 = XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) ;
+    temp =0;
+    if ( ( CR38 & 0xE0 ) > 0x80 )
+    {
+        temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x48 ) ;
+        temp &= 0x08;
+        temp >>= 3;
+    }
+    
+    XGINew_SetReg1( pVBInfo->P3d4, 0x4A , CR4A ) ;
+    
+    return temp;
+}
+
+UCHAR GetXG27FPBits(PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR CR38,CR4A,temp;
+    
+    CR4A = XGINew_GetReg1( pVBInfo->P3d4 , 0x4A ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x4A , ~0x03 , 0x03 ) ; /* enable GPIOA/B/C read */
+    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x48 ) ;
+    if ( temp <= 2 )
+    {
+    	temp &= 0x03;
+    }
+    else
+    {
+    	temp = ((temp&0x04)>>1) || ((~temp)&0x01);
+    }
+    XGINew_SetReg1( pVBInfo->P3d4, 0x4A , CR4A ) ;
+    
+    return temp;
+}
+
diff --git a/drivers/video/xgi/vb_init.h b/drivers/video/xgi/vb_init.h
new file mode 100644
index 0000000..296df00
--- /dev/null
+++ b/drivers/video/xgi/vb_init.h
@@ -0,0 +1,7 @@
+#ifndef  _VBINIT_
+#define  _VBINIT_
+extern   BOOLEAN    XGIInitNew( PXGI_HW_DEVICE_INFO HwDeviceExtension ) ;
+extern XGI21_LVDSCapStruct  XGI21_LCDCapList;
+
+#endif
+
diff --git a/drivers/video/xgi/vb_release.txt b/drivers/video/xgi/vb_release.txt
new file mode 100644
index 0000000..b5d6e34
--- /dev/null
+++ b/drivers/video/xgi/vb_release.txt
@@ -0,0 +1,44 @@
+[2004/08/18]
+1. Merge XG20 and XG4x C Code
+
+[2004/08/20]
+1. Code modify : Add CR97 in header and reference DDR/DDR2x according to this byte
+2. Dram Size setting from the data which read from VBIOS
+
+[2004/08/20] XG42 by Hsuan
+1. Add auto over driver in XG42.
+2. When MCLK=207MHz, ECLK=207 or 250MHz, SR32 D[1:0] set 10b.
+
+[2004/9/03] XG42 by Vicent
+1. New Feature: #41, XG42 solve 32-bit boot to Widnows hang issue
+ - Modify: vb_init.c
+	Modify XG42 SR1F, SR31, SR32, and SR33 for HW request.
+
+[2004/09/08] XG42 by Hsuan
+1. Feature Modify: Modify XGINew DDR2x default registers. (XG42 #473, #488)
+ - Modify: vb_init.c
+	Modify CR82, CR85, CR86, CR98 in XG42.
+
+[2004/09/08] XG4x by Vicent
+1. Feature Modify: Add ReadVBIOSTablData function in XGINew_SetDRAMModeRegister340. (XG42 #473, #488)
+ - Modify: vb_init.c
+	Add ReadVBIOSTablData function in XGINew_SetDRAMModeRegister340.
+
+[2004/09/15] XG20 by kuku
+1. Feature Modify: To set CR51, CR52 value for XG20
+ - Modify: vb_setmode.c
+ 	In XGI_SetCRT1ModeRegs() , set CR51=0x02 and CR52=0x33 when driver mode , CR52=0x73 when dos mode for XG20
+
+[2004/09/16] XG4X by Hsuan
+1. Bug Fixed: #524 Multi adapter dos full screen sometimes, CRT have green screen.
+ - Modify: vb_setmode.c
+        In XGI_SetCRT1ModeRegs(), it can't set SR3F D[7:6] = 00b.
+        The DPMS is handled by 2D.
+
+[2004/10/01] XG42 by kuku
+1. Bug Fixed: #530 [32-32] Enable "Overscan" and do Dos prompt switch, the screen shift
+ - Modify: xgiv.h, vb,c, tv301.c
+ 	In xgiv.h add globel parameter. When enable "Overscan" , parameter will be "1"
+ 	And lTVPosTempShift will be "0"
+2. Move down the screen and change mode to another mode, the display is not default(The screen move up).
+   The solution is the same as above.
\ No newline at end of file
diff --git a/drivers/video/xgi/vb_setmode.c b/drivers/video/xgi/vb_setmode.c
new file mode 100644
index 0000000..eb127c1
--- /dev/null
+++ b/drivers/video/xgi/vb_setmode.c
@@ -0,0 +1,10829 @@
+#include "osdef.h"
+
+#ifdef TC
+#include <stdio.h>
+#include <string.h>
+#include <conio.h>
+#include <dos.h>
+#endif
+
+
+#ifdef LINUX_XF86
+#include "xf86.h"
+#include "xf86PciInfo.h"
+#include "xgi.h"
+#include "xgi_regs.h"
+#endif
+
+#ifdef LINUX_KERNEL
+#include <asm/io.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include "XGIfb.h"
+/*#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#include <video/XGIfb.h>
+#else
+#include <linux/XGIfb.h>
+#endif*/
+#endif
+
+#ifdef WIN2000
+#include <dderror.h>
+#include <devioctl.h>
+#include <miniport.h>
+#include <ntddvdeo.h>
+#include <video.h>
+
+#include "xgiv.h"
+#include "dd_i2c.h"
+#include "tools.h"
+#endif
+
+#include "vb_def.h"
+#include "vgatypes.h"
+#include "vb_struct.h"
+#include "vb_util.h"
+#include "vb_table.h"
+
+
+
+#define  IndexMask 0xff
+#ifndef XGI_MASK_DUAL_CHIP
+#define XGI_MASK_DUAL_CHIP	  0x04  /* SR3A */
+#endif
+
+
+
+BOOLEAN  XGI_IsLCDDualLink(PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGI_SetCRT2Group301(USHORT ModeNo, PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGI_BacklightByDrv(PVB_DEVICE_INFO pVBInfo);
+
+BOOLEAN  XGI_IsLCDON(PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGI_DisableChISLCD(PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGI_EnableChISLCD(PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGI_AjustCRT2Rate(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,USHORT *i, PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGI_SearchModeID( USHORT ModeNo,USHORT  *ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGI_GetLCDInfo(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGISetModeNew( PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT ModeNo ) ;
+BOOLEAN  XGI_BridgeIsOn(PVB_DEVICE_INFO pVBInfo);
+UCHAR    XGI_GetModePtr( USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo);
+USHORT   XGI_GetOffset(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO pVBInfo);
+USHORT   XGI_GetRatePtrCRT2( PXGI_HW_DEVICE_INFO pXGIHWDE, USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo );
+USHORT   XGI_GetResInfo(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+USHORT   XGI_GetColorDepth(USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo);
+USHORT   XGI_GetVGAHT2(PVB_DEVICE_INFO pVBInfo);
+USHORT   XGI_GetVCLK2Ptr(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO pVBInfo);
+void     XGI_VBLongWait(PVB_DEVICE_INFO pVBInfo);
+void     XGI_SaveCRT2Info(USHORT ModeNo, PVB_DEVICE_INFO pVBInfo);
+void     XGI_GetCRT2Data(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_GetCRT2ResInfo(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_PreSetGroup1(USHORT ModeNo,USHORT ModeIdIndex, PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetGroup1(USHORT ModeNo,USHORT ModeIdIndex, PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetLockRegs(USHORT ModeNo,USHORT ModeIdIndex, PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetLCDRegs(USHORT ModeNo,USHORT ModeIdIndex, PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetGroup2(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetGroup3(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetGroup4(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetGroup5(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+void*    XGI_GetLcdPtr(USHORT BX,  USHORT ModeNo, USHORT ModeIdIndex, USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void*    XGI_GetTVPtr(USHORT BX, USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void 	 XGI_FirePWDEnable(PVB_DEVICE_INFO pVBInfo);
+void 	 XGI_EnableGatingCRT(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo);
+void 	 XGI_DisableGatingCRT(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo);
+void 	 XGI_SetPanelDelay(USHORT tempbl, PVB_DEVICE_INFO pVBInfo);
+void 	 XGI_SetPanelPower(USHORT tempah,USHORT tempbl, PVB_DEVICE_INFO pVBInfo);
+void 	 XGI_EnablePWD( PVB_DEVICE_INFO pVBInfo);
+void 	 XGI_DisablePWD( PVB_DEVICE_INFO pVBInfo);
+void     XGI_AutoThreshold( PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetTap4Regs( PVB_DEVICE_INFO pVBInfo);
+
+void     XGI_DisplayOn(PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO pVBInfo);
+void     XGI_DisplayOff( PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO pVBInfo );
+void     XGI_SetCRT1Group(PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetXG21CRTC(USHORT ModeNo, USHORT ModeIdIndex, USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetXG21LCD(PVB_DEVICE_INFO pVBInfo,USHORT RefreshRateTableIndex,USHORT ModeNo);
+void     XGI_SetXG27CRTC(USHORT ModeNo, USHORT ModeIdIndex, USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetXG27LCD(PVB_DEVICE_INFO pVBInfo,USHORT RefreshRateTableIndex,USHORT ModeNo);
+void	 XGI_UpdateXG21CRTC(USHORT ModeNo, PVB_DEVICE_INFO pVBInfo, USHORT RefreshRateTableIndex);
+void     XGI_WaitDisply(PVB_DEVICE_INFO pVBInfo);
+void     XGI_SenseCRT1(PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetSeqRegs(USHORT ModeNo,USHORT StandTableIndex,USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetMiscRegs(USHORT StandTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetCRTCRegs(PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT StandTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetATTRegs(USHORT ModeNo,USHORT StandTableIndex,USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo );
+void     XGI_SetGRCRegs(USHORT StandTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_ClearExt1Regs(PVB_DEVICE_INFO pVBInfo);
+
+void     XGI_SetSync(USHORT RefreshRateTableIndex,PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetCRT1CRTC(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PVB_DEVICE_INFO pVBInfo,PXGI_HW_DEVICE_INFO HwDeviceExtension);
+void     XGI_SetCRT1Timing_H(PVB_DEVICE_INFO pVBInfo,PXGI_HW_DEVICE_INFO HwDeviceExtension);
+void     XGI_SetCRT1Timing_V(USHORT ModeIdIndex,USHORT ModeNo,PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetCRT1DE(PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetCRT1VCLK(USHORT ModeNo,USHORT ModeIdIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetCRT1FIFO(USHORT ModeNo,PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetCRT1ModeRegs(PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetVCLKState(PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT ModeNo,USHORT RefreshRateTableIndex,PVB_DEVICE_INFO pVBInfo);
+
+void     XGI_LoadDAC(USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo);
+void     XGI_WriteDAC(USHORT dl, USHORT ah, USHORT al, USHORT dh, PVB_DEVICE_INFO pVBInfo);
+/*void     XGI_ClearBuffer(PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT ModeNo,PVB_DEVICE_INFO pVBInfo);*/
+void     XGI_SetLCDAGroup(USHORT ModeNo,USHORT ModeIdIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO  pVBInfo);
+void     XGI_GetLVDSResInfo( USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO  pVBInfo);
+void     XGI_GetLVDSData(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PVB_DEVICE_INFO  pVBInfo);
+void     XGI_ModCRT1Regs(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO  pVBInfo);
+void     XGI_SetLVDSRegs(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PVB_DEVICE_INFO  pVBInfo);
+void     XGI_UpdateModeInfo(PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO  pVBInfo);
+void     XGI_GetVGAType(PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO  pVBInfo);
+void     XGI_GetVBType(PVB_DEVICE_INFO  pVBInfo);
+void     XGI_GetVBInfo(USHORT ModeNo,USHORT ModeIdIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO  pVBInfo);
+void     XGI_GetTVInfo(USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO  pVBInfo);
+void     XGI_SetCRT2ECLK( USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PVB_DEVICE_INFO  pVBInfo);
+void     InitTo330Pointer(UCHAR,PVB_DEVICE_INFO pVBInfo);
+void     XGI_GetLCDSync(USHORT* HSyncWidth, USHORT* VSyncWidth, PVB_DEVICE_INFO pVBInfo);
+void 	 XGI_DisableBridge(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo);
+void  	 XGI_EnableBridge(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetCRT2VCLK(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_OEM310Setting(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetDelayComp(PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetLCDCap(PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetLCDCap_A(USHORT tempcx,PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetLCDCap_B(USHORT tempcx,PVB_DEVICE_INFO pVBInfo);
+void     SetSpectrum(PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetAntiFlicker(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetEdgeEnhance(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetPhaseIncr(PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetYFilter(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_GetTVPtrIndex2(USHORT* tempbx,UCHAR* tempcl,UCHAR* tempch, PVB_DEVICE_INFO pVBInfo);
+USHORT   XGI_GetTVPtrIndex(  PVB_DEVICE_INFO pVBInfo );
+void     XGI_SetCRT2ModeRegs(USHORT ModeNo,PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO pVBInfo );
+void     XGI_CloseCRTC(PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO pVBInfo);
+void     XGI_OpenCRTC(PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO pVBInfo);
+void     XGI_GetRAMDAC2DATA(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_UnLockCRT2(PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO pVBInfo);
+void     XGI_LockCRT2(PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO pVBInfo);
+void     XGINew_EnableCRT2(PVB_DEVICE_INFO pVBInfo);
+void     XGINew_LCD_Wait_Time(UCHAR DelayTime, PVB_DEVICE_INFO pVBInfo);
+void     XGI_LongWait(PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetCRT1Offset( USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex , PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO pVBInfo );
+void     XGI_GetLCDVCLKPtr(UCHAR* di_0,UCHAR *di_1, PVB_DEVICE_INFO pVBInfo);
+UCHAR    XGI_GetVCLKPtr(USHORT RefreshRateTableIndex,USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_GetVCLKLen(UCHAR tempal,UCHAR* di_0,UCHAR* di_1, PVB_DEVICE_INFO pVBInfo);
+USHORT   XGI_GetLCDCapPtr(PVB_DEVICE_INFO pVBInfo);
+USHORT   XGI_GetLCDCapPtr1(PVB_DEVICE_INFO pVBInfo);
+XGI301C_Tap4TimingStruct* XGI_GetTap4Ptr(USHORT tempcx, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetXG21FPBits(PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetXG27FPBits(PVB_DEVICE_INFO pVBInfo);
+UCHAR    XGI_XG21GetPSCValue(PVB_DEVICE_INFO pVBInfo);
+UCHAR    XGI_XG27GetPSCValue(PVB_DEVICE_INFO pVBInfo);
+void     XGI_XG21BLSignalVDD(USHORT tempbh,USHORT tempbl, PVB_DEVICE_INFO pVBInfo);
+void     XGI_XG27BLSignalVDD(USHORT tempbh,USHORT tempbl, PVB_DEVICE_INFO pVBInfo);
+void     XGI_XG21SetPanelDelay(USHORT tempbl, PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGI_XG21CheckLVDSMode(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo );
+void     XGI_SetXG21LVDSPara(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo );
+void     XGI_SetXG27LVDSPara(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo );
+UCHAR    XGI_SetDefaultVCLK( PVB_DEVICE_INFO pVBInfo );
+
+extern   void 	  ReadVBIOSTablData( UCHAR ChipType , PVB_DEVICE_INFO pVBInfo);
+#ifdef WIN2000
+/* [Billy] 2007/05/17 For CH7007 */
+extern  UCHAR CH7007TVReg_UNTSC[][8],CH7007TVReg_ONTSC[][8],CH7007TVReg_UPAL[][8],CH7007TVReg_OPAL[][8];
+extern  UCHAR CH7007TVCRT1UNTSC_H[][10],CH7007TVCRT1ONTSC_H[][10],CH7007TVCRT1UPAL_H[][10],CH7007TVCRT1OPAL_H[][10] ;
+extern  UCHAR CH7007TVCRT1UNTSC_V[][10],CH7007TVCRT1ONTSC_V[][10],CH7007TVCRT1UPAL_V[][10],CH7007TVCRT1OPAL_V[][10] ;
+extern  UCHAR XGI7007_CHTVVCLKUNTSC[],XGI7007_CHTVVCLKONTSC[],XGI7007_CHTVVCLKUPAL[],XGI7007_CHTVVCLKOPAL[];
+
+extern  BOOLEAN XGI_XG21CheckCH7007TVMode(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo ) ;
+extern  void SetCH7007Regs(PXGI_HW_DEVICE_INFO HwDeviceExtension, USHORT ModeNo, USHORT ModeIdIndex, USHORT RefreshRateTableIndex, PVB_DEVICE_INFO  pVBInfo ) ;
+extern  VP_STATUS TurnOnCH7007(PHW_DEVICE_EXTENSION pHWDE) ;
+extern  VP_STATUS TurnOffCH7007(PHW_DEVICE_EXTENSION pHWDE) ;
+extern  BOOLEAN IsCH7007TVMode(PVB_DEVICE_INFO pVBInfo) ;
+#endif
+
+/* USHORT XGINew_flag_clearbuffer; 0: no clear frame buffer 1:clear frame buffer */
+
+
+
+
+
+USHORT XGINew_MDA_DAC[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+               0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
+               0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
+               0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
+               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+               0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
+               0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
+               0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F};
+
+USHORT XGINew_CGA_DAC[]={0x00,0x10,0x04,0x14,0x01,0x11,0x09,0x15,
+               0x00,0x10,0x04,0x14,0x01,0x11,0x09,0x15,
+               0x2A,0x3A,0x2E,0x3E,0x2B,0x3B,0x2F,0x3F,
+               0x2A,0x3A,0x2E,0x3E,0x2B,0x3B,0x2F,0x3F,
+               0x00,0x10,0x04,0x14,0x01,0x11,0x09,0x15,
+               0x00,0x10,0x04,0x14,0x01,0x11,0x09,0x15,
+               0x2A,0x3A,0x2E,0x3E,0x2B,0x3B,0x2F,0x3F,
+               0x2A,0x3A,0x2E,0x3E,0x2B,0x3B,0x2F,0x3F};
+
+USHORT XGINew_EGA_DAC[]={0x00,0x10,0x04,0x14,0x01,0x11,0x05,0x15,
+               0x20,0x30,0x24,0x34,0x21,0x31,0x25,0x35,
+               0x08,0x18,0x0C,0x1C,0x09,0x19,0x0D,0x1D,
+               0x28,0x38,0x2C,0x3C,0x29,0x39,0x2D,0x3D,
+               0x02,0x12,0x06,0x16,0x03,0x13,0x07,0x17,
+               0x22,0x32,0x26,0x36,0x23,0x33,0x27,0x37,
+               0x0A,0x1A,0x0E,0x1E,0x0B,0x1B,0x0F,0x1F,
+               0x2A,0x3A,0x2E,0x3E,0x2B,0x3B,0x2F,0x3F};
+
+USHORT XGINew_VGA_DAC[]={0x00,0x10,0x04,0x14,0x01,0x11,0x09,0x15,
+               0x2A,0x3A,0x2E,0x3E,0x2B,0x3B,0x2F,0x3F,
+               0x00,0x05,0x08,0x0B,0x0E,0x11,0x14,0x18,
+               0x1C,0x20,0x24,0x28,0x2D,0x32,0x38,0x3F,
+
+               0x00,0x10,0x1F,0x2F,0x3F,0x1F,0x27,0x2F,
+               0x37,0x3F,0x2D,0x31,0x36,0x3A,0x3F,0x00,
+               0x07,0x0E,0x15,0x1C,0x0E,0x11,0x15,0x18,
+               0x1C,0x14,0x16,0x18,0x1A,0x1C,0x00,0x04,
+               0x08,0x0C,0x10,0x08,0x0A,0x0C,0x0E,0x10,
+               0x0B,0x0C,0x0D,0x0F,0x10};
+
+
+/* --------------------------------------------------------------------- */
+/* Function : InitTo330Pointer */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void InitTo330Pointer( UCHAR ChipType ,PVB_DEVICE_INFO pVBInfo)
+{
+    pVBInfo->SModeIDTable = (XGI_StStruct *) XGI330_SModeIDTable ;
+    pVBInfo->StandTable = (XGI_StandTableStruct *) XGI330_StandTable ;
+    pVBInfo->EModeIDTable = (XGI_ExtStruct *) XGI330_EModeIDTable ;
+    pVBInfo->RefIndex = (XGI_Ext2Struct *) XGI330_RefIndex ;
+    pVBInfo->XGINEWUB_CRT1Table = (XGI_CRT1TableStruct *) XGI_CRT1Table ;
+
+    /* add for new UNIVGABIOS */
+    /* XGINew_UBLCDDataTable = (XGI_LCDDataTablStruct *) XGI_LCDDataTable ; */
+    /* XGINew_UBTVDataTable = (XGI_TVDataTablStruct *) XGI_TVDataTable ; */
+
+
+    if ( ChipType >= XG40 )
+    {
+        pVBInfo->MCLKData = (XGI_MCLKDataStruct *) XGI340New_MCLKData ;
+        pVBInfo->ECLKData = (XGI_ECLKDataStruct *) XGI340_ECLKData ;
+    }
+    else
+    {
+        pVBInfo->MCLKData = (XGI_MCLKDataStruct *) XGI330New_MCLKData ;
+        pVBInfo->ECLKData = (XGI_ECLKDataStruct *) XGI330_ECLKData ;
+    }
+
+    pVBInfo->VCLKData = (XGI_VCLKDataStruct *) XGI_VCLKData ;
+    pVBInfo->VBVCLKData = (XGI_VBVCLKDataStruct *) XGI_VBVCLKData ;
+    pVBInfo->ScreenOffset = XGI330_ScreenOffset ;
+    pVBInfo->StResInfo = (XGI_StResInfoStruct *) XGI330_StResInfo ;
+    pVBInfo->ModeResInfo = (XGI_ModeResInfoStruct *) XGI330_ModeResInfo ;
+
+    pVBInfo->pOutputSelect = &XGI330_OutputSelect ;
+    pVBInfo->pSoftSetting = &XGI330_SoftSetting ;
+    pVBInfo->pSR07 = &XGI330_SR07 ;
+    pVBInfo->LCDResInfo = 0 ;
+    pVBInfo->LCDTypeInfo = 0 ;
+    pVBInfo->LCDInfo = 0 ;
+    pVBInfo->VBInfo = 0 ;
+    pVBInfo->TVInfo = 0;
+
+
+    pVBInfo->SR15 = XGI340_SR13 ;
+    pVBInfo->CR40 = XGI340_cr41 ;
+    pVBInfo->SR25 = XGI330_sr25 ;
+    pVBInfo->pSR31 = &XGI330_sr31 ;
+    pVBInfo->pSR32 = &XGI330_sr32 ;
+    pVBInfo->CR6B = XGI340_CR6B ;
+    pVBInfo->CR6E = XGI340_CR6E ;
+    pVBInfo->CR6F = XGI340_CR6F ;
+    pVBInfo->CR89 = XGI340_CR89 ;
+    pVBInfo->AGPReg = XGI340_AGPReg ;
+    pVBInfo->SR16 = XGI340_SR16 ;
+    pVBInfo->pCRCF = &XG40_CRCF ;
+    pVBInfo->pXGINew_DRAMTypeDefinition = &XG40_DRAMTypeDefinition ;
+
+
+    pVBInfo->CR49 = XGI330_CR49 ;
+    pVBInfo->pSR1F = &XGI330_SR1F ;
+    pVBInfo->pSR21 = &XGI330_SR21 ;
+    pVBInfo->pSR22 = &XGI330_SR22 ;
+    pVBInfo->pSR23 = &XGI330_SR23 ;
+    pVBInfo->pSR24 = &XGI330_SR24 ;
+    pVBInfo->pSR33 = &XGI330_SR33 ;
+
+
+
+    pVBInfo->pCRT2Data_1_2 = &XGI330_CRT2Data_1_2 ;
+    pVBInfo->pCRT2Data_4_D = &XGI330_CRT2Data_4_D ;
+    pVBInfo->pCRT2Data_4_E = &XGI330_CRT2Data_4_E ;
+    pVBInfo->pCRT2Data_4_10 = &XGI330_CRT2Data_4_10 ;
+    pVBInfo->pRGBSenseData = &XGI330_RGBSenseData ;
+    pVBInfo->pVideoSenseData = &XGI330_VideoSenseData ;
+    pVBInfo->pYCSenseData = &XGI330_YCSenseData ;
+    pVBInfo->pRGBSenseData2 = &XGI330_RGBSenseData2 ;
+    pVBInfo->pVideoSenseData2 = &XGI330_VideoSenseData2 ;
+    pVBInfo->pYCSenseData2 = &XGI330_YCSenseData2 ;
+
+    pVBInfo->NTSCTiming = XGI330_NTSCTiming ;
+    pVBInfo->PALTiming = XGI330_PALTiming ;
+    pVBInfo->HiTVExtTiming = XGI330_HiTVExtTiming ;
+    pVBInfo->HiTVSt1Timing = XGI330_HiTVSt1Timing ;
+    pVBInfo->HiTVSt2Timing = XGI330_HiTVSt2Timing ;
+    pVBInfo->HiTVTextTiming = XGI330_HiTVTextTiming ;
+    pVBInfo->YPbPr750pTiming = XGI330_YPbPr750pTiming ;
+    pVBInfo->YPbPr525pTiming = XGI330_YPbPr525pTiming ;
+    pVBInfo->YPbPr525iTiming = XGI330_YPbPr525iTiming ;
+    pVBInfo->HiTVGroup3Data = XGI330_HiTVGroup3Data ;
+    pVBInfo->HiTVGroup3Simu = XGI330_HiTVGroup3Simu ;
+    pVBInfo->HiTVGroup3Text = XGI330_HiTVGroup3Text ;
+    pVBInfo->Ren525pGroup3 = XGI330_Ren525pGroup3 ;
+    pVBInfo->Ren750pGroup3 = XGI330_Ren750pGroup3 ;
+
+
+    pVBInfo->TimingH = (XGI_TimingHStruct *) XGI_TimingH ;
+    pVBInfo->TimingV = (XGI_TimingVStruct *) XGI_TimingV ;
+    pVBInfo->UpdateCRT1 = (XGI_XG21CRT1Struct *) XGI_UpdateCRT1Table ;
+
+    pVBInfo->CHTVVCLKUNTSC = XGI330_CHTVVCLKUNTSC ;
+    pVBInfo->CHTVVCLKONTSC = XGI330_CHTVVCLKONTSC ;
+    pVBInfo->CHTVVCLKUPAL = XGI330_CHTVVCLKUPAL ;
+    pVBInfo->CHTVVCLKOPAL = XGI330_CHTVVCLKOPAL ;
+
+    /* 310 customization related */
+    if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+        pVBInfo->LCDCapList = XGI_LCDDLCapList ;
+    else
+        pVBInfo->LCDCapList = XGI_LCDCapList ;
+
+    if ( ( ChipType == XG21 ) || ( ChipType == XG27 ) )
+        pVBInfo->XG21_LVDSCapList = XGI21_LCDCapList ;
+
+    pVBInfo->XGI_TVDelayList = XGI301TVDelayList ;
+    pVBInfo->XGI_TVDelayList2 = XGI301TVDelayList2 ;
+
+
+    pVBInfo->pXGINew_I2CDefinition = &XG40_I2CDefinition ;
+
+    if ( ChipType >= XG20 )
+    	pVBInfo->pXGINew_CR97 = &XG20_CR97 ;
+   
+    if ( ChipType == XG27 )
+    {
+        pVBInfo->MCLKData = (XGI_MCLKDataStruct *) XGI27New_MCLKData ;
+        pVBInfo->CR40 = XGI27_cr41 ;
+    	pVBInfo->pXGINew_CR97 = &XG27_CR97 ;
+    	pVBInfo->pSR36 = &XG27_SR36 ;
+    	pVBInfo->pCR8F = &XG27_CR8F ;
+    	pVBInfo->pCRD0 = XG27_CRD0 ;
+    	pVBInfo->pCRDE = XG27_CRDE ;
+    	pVBInfo->pSR40 = &XG27_SR40 ;
+    	pVBInfo->pSR41 = &XG27_SR41 ;
+    	
+    }
+
+    if ( ChipType >= XG20 )
+    {
+    	pVBInfo->pDVOSetting = &XG21_DVOSetting ;
+    	pVBInfo->pCR2E = &XG21_CR2E ;
+    	pVBInfo->pCR2F = &XG21_CR2F ;
+    	pVBInfo->pCR46 = &XG21_CR46 ;
+    	pVBInfo->pCR47 = &XG21_CR47 ;
+    }
+
+}
+
+
+
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGISetModeNew */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGISetModeNew( PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT ModeNo )
+{
+#ifndef LINUX_XF86
+    ULONG  temp ;
+    USHORT KeepLockReg ;
+#endif
+    USHORT ModeIdIndex ;
+        /* PUCHAR pVBInfo->FBAddr = HwDeviceExtension->pjVideoMemoryAddress ; */
+    VB_DEVICE_INFO VBINF;
+    PVB_DEVICE_INFO pVBInfo = &VBINF;
+    pVBInfo->ROMAddr = HwDeviceExtension->pjVirtualRomBase ;
+    pVBInfo->BaseAddr = HwDeviceExtension->pjIOAddress ;
+    pVBInfo->IF_DEF_LVDS = 0 ;
+    pVBInfo->IF_DEF_CH7005 = 0 ;
+    pVBInfo->IF_DEF_LCDA = 1 ;
+    pVBInfo->IF_DEF_CH7017 = 0 ;
+    pVBInfo->IF_DEF_CH7007 = 0 ;                                /* [Billy] 2007/05/14 */
+    pVBInfo->IF_DEF_VideoCapture = 0 ;
+    pVBInfo->IF_DEF_ScaleLCD = 0 ;
+    pVBInfo->IF_DEF_OEMUtil = 0 ;
+    pVBInfo->IF_DEF_PWD = 0 ;
+
+
+    if ( HwDeviceExtension->jChipType >= XG20 )			/* kuku 2004/06/25 */
+    {
+    	pVBInfo->IF_DEF_YPbPr = 0 ;
+        pVBInfo->IF_DEF_HiVision = 0 ;
+        pVBInfo->IF_DEF_CRT2Monitor = 0 ;
+        pVBInfo->VBType = 0 ;  /*set VBType default 0*/
+    }
+    else if ( HwDeviceExtension->jChipType >= XG40 )
+    {
+        pVBInfo->IF_DEF_YPbPr = 1 ;
+        pVBInfo->IF_DEF_HiVision = 1 ;
+        pVBInfo->IF_DEF_CRT2Monitor = 1 ;
+    }
+    else
+    {
+        pVBInfo->IF_DEF_YPbPr = 1 ;
+        pVBInfo->IF_DEF_HiVision = 1 ;
+        pVBInfo->IF_DEF_CRT2Monitor = 0 ;
+    }
+
+    pVBInfo->P3c4 = pVBInfo->BaseAddr + 0x14 ;
+    pVBInfo->P3d4 = pVBInfo->BaseAddr + 0x24 ;
+    pVBInfo->P3c0 = pVBInfo->BaseAddr + 0x10 ;
+    pVBInfo->P3ce = pVBInfo->BaseAddr + 0x1e ;
+    pVBInfo->P3c2 = pVBInfo->BaseAddr + 0x12 ;
+    pVBInfo->P3cc = pVBInfo->BaseAddr + 0x1C ;
+    pVBInfo->P3ca = pVBInfo->BaseAddr + 0x1a ;
+    pVBInfo->P3c6 = pVBInfo->BaseAddr + 0x16 ;
+    pVBInfo->P3c7 = pVBInfo->BaseAddr + 0x17 ;
+    pVBInfo->P3c8 = pVBInfo->BaseAddr + 0x18 ;
+    pVBInfo->P3c9 = pVBInfo->BaseAddr + 0x19 ;
+    pVBInfo->P3da = pVBInfo->BaseAddr + 0x2A ;
+    pVBInfo->Part0Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_00 ;
+    pVBInfo->Part1Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_04 ;
+    pVBInfo->Part2Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_10 ;
+    pVBInfo->Part3Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_12 ;
+    pVBInfo->Part4Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 ;
+    pVBInfo->Part5Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 + 2 ;
+
+    if ( HwDeviceExtension->jChipType == XG27 )
+    {
+        if ( ( XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) & 0xE0 ) == 0xC0 )
+        {
+          if ( XGINew_GetReg1( pVBInfo->P3d4 , 0x30 ) & 0x20 )
+          {
+            pVBInfo->IF_DEF_LVDS = 1 ;
+          }
+        }
+    }
+
+    if ( HwDeviceExtension->jChipType < XG20 )			/* kuku 2004/06/25 */
+    XGI_GetVBType( pVBInfo ) ;
+
+    InitTo330Pointer( HwDeviceExtension->jChipType, pVBInfo ) ;
+#ifdef WIN2000
+    ReadVBIOSTablData( HwDeviceExtension->jChipType , pVBInfo) ;
+#endif   
+    if ( ModeNo & 0x80 )
+    {
+        ModeNo = ModeNo & 0x7F ;
+/* XGINew_flag_clearbuffer = 0 ; */
+    }
+/*    else
+    {
+        XGINew_flag_clearbuffer = 1 ;
+    }
+*/
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x05 , 0x86 ) ;
+
+    if ( HwDeviceExtension->jChipType < XG20 )			/* kuku 2004/06/25 1.Openkey */
+    XGI_UnLockCRT2( HwDeviceExtension , pVBInfo ) ;
+
+    XGI_SearchModeID( ModeNo , &ModeIdIndex, pVBInfo ) ;
+
+    XGI_GetVGAType(HwDeviceExtension,  pVBInfo) ;
+
+    if ( HwDeviceExtension->jChipType < XG20 )			/* kuku 2004/06/25 */
+    {
+        XGI_GetVBInfo(ModeNo , ModeIdIndex , HwDeviceExtension, pVBInfo ) ;
+        XGI_GetTVInfo(ModeNo , ModeIdIndex, pVBInfo ) ;
+        XGI_GetLCDInfo(ModeNo , ModeIdIndex, pVBInfo ) ;
+        XGI_DisableBridge( HwDeviceExtension,pVBInfo ) ;
+/*        XGI_OpenCRTC( HwDeviceExtension, pVBInfo ) ; */
+        
+        if ( pVBInfo->VBInfo & ( SetSimuScanMode | SetCRT2ToLCDA ) )
+        {
+            XGI_SetCRT1Group(HwDeviceExtension , ModeNo , ModeIdIndex, pVBInfo ) ;
+        
+            if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+            {
+                XGI_SetLCDAGroup(ModeNo , ModeIdIndex , HwDeviceExtension, pVBInfo ) ;
+            }
+        }
+        else
+        {
+            if ( !( pVBInfo->VBInfo & SwitchToCRT2) )
+            {
+                XGI_SetCRT1Group( HwDeviceExtension , ModeNo , ModeIdIndex, pVBInfo ) ;
+                if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+                {
+                    XGI_SetLCDAGroup( ModeNo , ModeIdIndex , HwDeviceExtension, pVBInfo ) ;
+                }
+            }
+        }
+        
+        if ( pVBInfo->VBInfo & ( SetSimuScanMode | SwitchToCRT2 ) )
+        {
+            switch( HwDeviceExtension->ujVBChipID )
+            {
+                case VB_CHIP_301:
+                    XGI_SetCRT2Group301( ModeNo , HwDeviceExtension, pVBInfo ) ;		/*add for CRT2 */
+                    break ;
+        
+                case VB_CHIP_302:
+                    XGI_SetCRT2Group301(ModeNo , HwDeviceExtension, pVBInfo ) ;		/*add for CRT2 */
+                    break ;
+        
+                default:
+                    break ;
+            }
+        }
+        
+        XGI_SetCRT2ModeRegs( ModeNo, HwDeviceExtension,pVBInfo ) ;
+        XGI_OEM310Setting( ModeNo, ModeIdIndex,pVBInfo ) ; /*0212*/
+        XGI_CloseCRTC( HwDeviceExtension, pVBInfo ) ;
+        XGI_EnableBridge( HwDeviceExtension ,pVBInfo) ;
+    }	/* !XG20 */
+    else
+    {
+#ifdef WIN2000    	
+        if ( pVBInfo->IF_DEF_CH7007 == 1 )
+        {
+
+            VideoDebugPrint((0, "XGISetModeNew: pVBIfo->IF_DEF_CH7007==1\n"));
+            pVBInfo->VBType = VB_CH7007 ;
+            XGI_GetVBInfo(ModeNo , ModeIdIndex , HwDeviceExtension, pVBInfo ) ;
+            XGI_GetTVInfo(ModeNo , ModeIdIndex, pVBInfo ) ;
+            XGI_GetLCDInfo(ModeNo , ModeIdIndex, pVBInfo ) ;
+            if( !(XGI_XG21CheckCH7007TVMode(ModeNo, ModeIdIndex, pVBInfo )) )
+            {
+              return FALSE;
+            }
+        }
+#endif  
+
+
+        if ( pVBInfo->IF_DEF_LVDS == 1 )
+        {
+            if ( !XGI_XG21CheckLVDSMode(ModeNo , ModeIdIndex, pVBInfo) )
+            {
+              return FALSE;
+            }
+        }
+
+        if ( ModeNo <= 0x13 )
+        {
+            pVBInfo->ModeType = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag & ModeInfoFlag;
+        }
+        else
+        {
+            pVBInfo->ModeType = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag & ModeInfoFlag;
+        }
+
+    	pVBInfo->SetFlag = 0 ;
+        if ( pVBInfo->IF_DEF_CH7007 != 1 )
+        {
+    	    pVBInfo->VBInfo = DisableCRT2Display ;
+        }
+
+
+    	XGI_DisplayOff(HwDeviceExtension, pVBInfo) ;
+
+    	XGI_SetCRT1Group(HwDeviceExtension , ModeNo , ModeIdIndex, pVBInfo ) ;
+
+    	XGI_DisplayOn( HwDeviceExtension, pVBInfo ) ;
+    	/*
+    	if( HwDeviceExtension->jChipType == XG21 )
+    	  XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x09 , ~0x80 , 0x80 ) ;
+    	*/
+    }
+
+
+/*
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+    }
+    pVBInfo->ModeType = modeflag&ModeInfoFlag ;
+    pVBInfo->SetFlag = 0x00 ;
+    pVBInfo->VBInfo = DisableCRT2Display ;
+    temp = XGINew_CheckMemorySize(  HwDeviceExtension , ModeNo , ModeIdIndex, pVBInfo ) ;
+
+    if ( temp == 0 )
+        return( 0 ) ;
+
+    XGI_DisplayOff( HwDeviceExtension, pVBInfo) ;
+    XGI_SetCRT1Group( HwDeviceExtension , ModeNo , ModeIdIndex, pVBInfo ) ;
+    XGI_DisplayOn( HwDeviceExtension, pVBInfo) ;
+*/
+
+    XGI_UpdateModeInfo( HwDeviceExtension, pVBInfo ) ;
+
+    if ( HwDeviceExtension->jChipType < XG20 )			/* kuku 2004/06/25 */
+{
+    XGI_LockCRT2( HwDeviceExtension, pVBInfo ) ;
+}
+
+    return( TRUE ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT1Group */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT1Group( PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT ModeNo , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT StandTableIndex ,
+           RefreshRateTableIndex ,
+           b3CC ,
+           temp ;
+
+    USHORT XGINew_P3cc =  pVBInfo->P3cc;
+#ifndef LINUX_XF86
+    USHORT XGINew_P3c2 =  pVBInfo->P3c2;
+#endif
+
+    /* XGINew_CRT1Mode = ModeNo ; // SaveModeID */
+    StandTableIndex = XGI_GetModePtr( ModeNo , ModeIdIndex, pVBInfo ) ;
+    /* XGI_SetBIOSData(ModeNo , ModeIdIndex ) ; */
+    /* XGI_ClearBankRegs( ModeNo , ModeIdIndex ) ; */
+    XGI_SetSeqRegs( ModeNo , StandTableIndex , ModeIdIndex, pVBInfo ) ;
+    XGI_SetMiscRegs( StandTableIndex,  pVBInfo ) ;
+    XGI_SetCRTCRegs( HwDeviceExtension , StandTableIndex,  pVBInfo) ;
+    XGI_SetATTRegs( ModeNo , StandTableIndex , ModeIdIndex, pVBInfo ) ;
+    XGI_SetGRCRegs(  StandTableIndex, pVBInfo ) ;
+    XGI_ClearExt1Regs(pVBInfo) ;
+
+/* if ( pVBInfo->IF_DEF_ExpLink ) */
+    if ( HwDeviceExtension->jChipType == XG27 )
+    {
+      if ( pVBInfo->IF_DEF_LVDS == 0 )
+      {
+        XGI_SetDefaultVCLK( pVBInfo ) ; 
+      }
+    }
+    
+    temp = ~ProgrammingCRT2 ;
+    pVBInfo->SetFlag &= temp ;
+    pVBInfo->SelectCRT2Rate = 0 ;
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        if ( pVBInfo->VBInfo & ( SetSimuScanMode | SetCRT2ToLCDA | SetInSlaveMode ) )
+        {
+            pVBInfo->SetFlag |= ProgrammingCRT2 ;
+         }
+    }
+
+    RefreshRateTableIndex = XGI_GetRatePtrCRT2( HwDeviceExtension, ModeNo , ModeIdIndex, pVBInfo ) ;
+    if ( RefreshRateTableIndex != 0xFFFF )
+    {
+        XGI_SetSync( RefreshRateTableIndex, pVBInfo ) ;
+        XGI_SetCRT1CRTC( ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo, HwDeviceExtension ) ;
+        XGI_SetCRT1DE( HwDeviceExtension , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+        XGI_SetCRT1Offset( ModeNo , ModeIdIndex , RefreshRateTableIndex , HwDeviceExtension, pVBInfo ) ;
+        XGI_SetCRT1VCLK( ModeNo , ModeIdIndex , HwDeviceExtension , RefreshRateTableIndex, pVBInfo ) ;
+    }
+
+    if ( ( HwDeviceExtension->jChipType >= XG20 )&&
+         ( HwDeviceExtension->jChipType < XG27 ) ) /* fix H/W DCLK/2 bug */
+    {
+    	if ( ( ModeNo == 0x00 ) | (ModeNo == 0x01) )
+    	{
+    	    XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , 0x4E) ;
+    	    XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , 0xE9) ;
+    	    b3CC =(UCHAR) XGINew_GetReg2(XGINew_P3cc) ;
+    	    XGINew_SetReg3(XGINew_P3cc ,  (b3CC |= 0x0C) ) ;
+    	}
+    	else if ( ( ModeNo == 0x04) | ( ModeNo == 0x05) | ( ModeNo == 0x0D) )
+    	{
+    	    XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , 0x1B) ;
+    	    XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , 0xE3) ;
+    	    b3CC = (UCHAR)XGINew_GetReg2(XGINew_P3cc) ;
+    	    XGINew_SetReg3(XGINew_P3cc ,  (b3CC |= 0x0C) ) ;
+    	}
+    }
+
+    if ( HwDeviceExtension->jChipType >= XG21 )
+    {
+      temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) ;
+      if ( temp & 0xA0 )
+      {
+        
+        /*XGINew_SetRegAND( pVBInfo->P3d4 , 0x4A , ~0x20 ) ;*/	/* Enable write GPIOF */
+        /*XGINew_SetRegAND( pVBInfo->P3d4 , 0x48 , ~0x20 ) ;*/ 	/* P. DWN */
+        /* XG21 CRT1 Timing */
+        if ( HwDeviceExtension->jChipType == XG27 )
+          XGI_SetXG27CRTC( ModeNo, ModeIdIndex, RefreshRateTableIndex, pVBInfo );
+        else
+        XGI_SetXG21CRTC( ModeNo, ModeIdIndex, RefreshRateTableIndex, pVBInfo );
+          
+        XGI_UpdateXG21CRTC( ModeNo , pVBInfo , RefreshRateTableIndex) ;
+        
+        if ( HwDeviceExtension->jChipType == XG27 )
+          XGI_SetXG27LCD( pVBInfo , RefreshRateTableIndex , ModeNo );
+        else
+          XGI_SetXG21LCD( pVBInfo , RefreshRateTableIndex , ModeNo );
+          
+        if ( pVBInfo->IF_DEF_LVDS == 1 )
+        {
+          if ( HwDeviceExtension->jChipType == XG27 )
+            XGI_SetXG27LVDSPara(ModeNo,ModeIdIndex, pVBInfo );
+          else
+            XGI_SetXG21LVDSPara(ModeNo,ModeIdIndex, pVBInfo );
+        }
+        /*XGINew_SetRegOR( pVBInfo->P3d4 , 0x48 , 0x20 ) ;*/	/* P. ON */
+      }
+    }
+
+    pVBInfo->SetFlag &= ( ~ProgrammingCRT2 ) ;
+    XGI_SetCRT1FIFO(  ModeNo , HwDeviceExtension,  pVBInfo ) ;
+    XGI_SetCRT1ModeRegs(  HwDeviceExtension , ModeNo , ModeIdIndex , RefreshRateTableIndex , pVBInfo) ;
+
+
+    /* XGI_LoadCharacter(); //dif ifdef TVFont */
+
+    XGI_LoadDAC( ModeNo , ModeIdIndex, pVBInfo ) ;
+    /* XGI_ClearBuffer( HwDeviceExtension , ModeNo, pVBInfo ) ; */
+#ifdef WIN2000    	
+   if ( pVBInfo->IF_DEF_CH7007 == 1 )  /* [Billy]  2007/05/14  */
+   {
+       VideoDebugPrint((0, "XGI_SetCRT1Group: VBInfo->IF_DEF_CH7007==1\n"));
+       SetCH7007Regs(HwDeviceExtension, ModeNo, ModeIdIndex, RefreshRateTableIndex, pVBInfo ) ; /* 07/05/28 */ 
+   }
+#endif   
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetModePtr */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+UCHAR XGI_GetModePtr( USHORT ModeNo , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR index ;
+
+    if ( ModeNo <= 0x13 )
+        index = pVBInfo->SModeIDTable[ ModeIdIndex ].St_StTableIndex ;
+    else
+    {
+        if ( pVBInfo->ModeType <= 0x02 )
+            index = 0x1B ;	/* 02 -> ModeEGA */
+        else
+            index = 0x0F ;
+    }
+    return( index ) ;		/* Get pVBInfo->StandTable index */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetBIOSData */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+/*UCHAR XGI_SetBIOSData( USHORT ModeNo , USHORT ModeIdIndex )
+{
+    return( 0 ) ;
+}
+*/
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_ClearBankRegs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+/*UCHAR XGI_ClearBankRegs( USHORT ModeNo , USHORT ModeIdIndex )
+{
+    return( 0 ) ;
+}
+*/
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetSeqRegs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetSeqRegs(  USHORT ModeNo , USHORT StandTableIndex , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR tempah ,
+          SRdata ;
+
+    USHORT i ,
+           modeflag ;
+
+    if ( ModeNo <= 0x13 )
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+    else
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x00 , 0x03 ) ;		/* Set SR0 */
+    tempah=pVBInfo->StandTable[ StandTableIndex ].SR[ 0 ] ;
+
+    i = SetCRT2ToLCDA ;
+    if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+    {
+        tempah |= 0x01 ;
+    }
+    else
+    {
+        if ( pVBInfo->VBInfo & ( SetCRT2ToTV | SetCRT2ToLCD ) )
+        {
+            if ( pVBInfo->VBInfo & SetInSlaveMode )
+                tempah |= 0x01 ;
+        }
+    }
+
+    tempah |= 0x20 ;		/* screen off */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x01 , tempah ) ;		/* Set SR1 */
+
+    for( i = 02 ; i <= 04 ; i++ )
+    {
+        SRdata = pVBInfo->StandTable[ StandTableIndex ].SR[ i - 1 ] ;	/* Get SR2,3,4 from file */
+        XGINew_SetReg1( pVBInfo->P3c4 , i , SRdata ) ;				/* Set SR2 3 4 */
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetMiscRegs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetMiscRegs( USHORT StandTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR Miscdata ;
+
+    Miscdata = pVBInfo->StandTable[ StandTableIndex ].MISC ;	/* Get Misc from file */
+/*
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+        {
+            Miscdata |= 0x0C ;
+        }
+    }
+*/
+
+    XGINew_SetReg3( pVBInfo->P3c2 , Miscdata ) ;		/* Set Misc(3c2) */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRTCRegs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRTCRegs( PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT StandTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR CRTCdata ;
+    USHORT i ;
+
+    CRTCdata = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x11 ) ;
+    CRTCdata &= 0x7f ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x11 , CRTCdata ) ;		/* Unlock CRTC */
+
+    for( i = 0 ; i <= 0x18 ; i++ )
+    {
+        CRTCdata = pVBInfo->StandTable[ StandTableIndex ].CRTC[ i ] ;	/* Get CRTC from file */
+        XGINew_SetReg1( pVBInfo->P3d4 , i , CRTCdata ) ;				/* Set CRTC( 3d4 ) */
+    }
+/*
+    if ( ( HwDeviceExtension->jChipType == XGI_630 )&& ( HwDeviceExtension->jChipRevision == 0x30 ) )
+    {
+        if ( pVBInfo->VBInfo & SetInSlaveMode )
+        {
+            if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToTV ) )
+            {
+                XGINew_SetReg1( pVBInfo->P3d4 , 0x18 , 0xFE ) ;
+            }
+        }
+    }
+*/
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetATTRegs( USHORT ModeNo , USHORT StandTableIndex , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR ARdata ;
+    USHORT i ,
+           modeflag ;
+
+    if ( ModeNo <= 0x13 )
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+    else
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+
+    for( i = 0 ; i <= 0x13 ; i++ )
+    {
+        ARdata = pVBInfo->StandTable[ StandTableIndex ].ATTR[ i ] ;
+        if ( modeflag & Charx8Dot )	/* ifndef Dot9 */
+        {
+            if ( i == 0x13 )
+            {
+                if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+                    ARdata = 0 ;
+                else
+                {
+                    if ( pVBInfo->VBInfo & ( SetCRT2ToTV | SetCRT2ToLCD ) )
+                    {
+                        if ( pVBInfo->VBInfo & SetInSlaveMode )
+                            ARdata = 0 ;
+                    }
+                }
+            }
+        }
+
+        XGINew_GetReg2( pVBInfo->P3da ) ;			/* reset 3da */
+        XGINew_SetReg3( pVBInfo->P3c0 , i ) ;		/* set index */
+        XGINew_SetReg3( pVBInfo->P3c0 , ARdata ) ;	/* set data */
+    }
+
+    XGINew_GetReg2( pVBInfo->P3da ) ;			/* reset 3da */
+    XGINew_SetReg3( pVBInfo->P3c0 , 0x14 ) ;		/* set index */
+    XGINew_SetReg3( pVBInfo->P3c0 , 0x00 ) ;		/* set data */
+    XGINew_GetReg2( pVBInfo->P3da ) ;			/* Enable Attribute */
+    XGINew_SetReg3( pVBInfo->P3c0 , 0x20 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetGRCRegs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetGRCRegs( USHORT StandTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR GRdata ;
+    USHORT i ;
+
+    for( i = 0 ; i <= 0x08 ; i++ )
+    {
+        GRdata = pVBInfo->StandTable[ StandTableIndex ].GRC[ i ] ;	/* Get GR from file */
+        XGINew_SetReg1( pVBInfo->P3ce , i , GRdata ) ;			/* Set GR(3ce) */
+    }
+
+    if ( pVBInfo->ModeType > ModeVGA )
+    {
+        GRdata = ( UCHAR )XGINew_GetReg1( pVBInfo->P3ce , 0x05 ) ;
+        GRdata &= 0xBF ;						/* 256 color disable */
+        XGINew_SetReg1( pVBInfo->P3ce , 0x05 , GRdata ) ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_ClearExt1Regs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_ClearExt1Regs(PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT i ;
+
+    for( i = 0x0A ; i <= 0x0E ; i++ )
+        XGINew_SetReg1( pVBInfo->P3c4 , i , 0x00 ) ;	/* Clear SR0A-SR0E */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetDefaultVCLK */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+UCHAR XGI_SetDefaultVCLK( PVB_DEVICE_INFO pVBInfo )
+{
+
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x31 , ~0x30 , 0x20 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , pVBInfo->VCLKData[ 0 ].SR2B ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , pVBInfo->VCLKData[ 0 ].SR2C ) ;
+
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x31 , ~0x30 , 0x10 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , pVBInfo->VCLKData[ 1 ].SR2B ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , pVBInfo->VCLKData[ 1 ].SR2C ) ;
+
+    XGINew_SetRegAND( pVBInfo->P3c4 , 0x31 , ~0x30 ) ;
+    return( 0 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetRatePtrCRT2 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT XGI_GetRatePtrCRT2( PXGI_HW_DEVICE_INFO pXGIHWDE, USHORT ModeNo , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    SHORT  LCDRefreshIndex[] = { 0x00 , 0x00 , 0x03 , 0x01 } ,
+           LCDARefreshIndex[] = { 0x00 , 0x00 , 0x03 , 0x01 , 0x01 , 0x01 , 0x01 } ;
+
+    USHORT RefreshRateTableIndex , i ,
+         modeflag , index , temp ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+    }
+
+    if ( pVBInfo->IF_DEF_CH7005 == 1 )
+    {
+        if ( pVBInfo->VBInfo & SetCRT2ToTV )
+        {
+            if ( modeflag & HalfDCLK )
+                return( 0 ) ;
+        }
+    }
+
+    if ( ModeNo < 0x14 )
+        return( 0xFFFF ) ;
+
+    index = XGINew_GetReg1( pVBInfo->P3d4 , 0x33 ) ;
+    index = index >> pVBInfo->SelectCRT2Rate ;
+    index &= 0x0F ;
+
+    if ( pVBInfo->LCDInfo & LCDNonExpanding )
+        index = 0 ;
+
+    if ( index > 0 )
+        index-- ;
+
+    if ( pVBInfo->SetFlag & ProgrammingCRT2 )
+    {
+        if ( pVBInfo->IF_DEF_CH7005 == 1 )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToTV )
+            {
+                index = 0 ;
+            }
+        }
+
+        if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+        {
+            if( pVBInfo->IF_DEF_LVDS == 0 )
+            {
+                if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+                    temp = LCDARefreshIndex[ pVBInfo->LCDResInfo & 0x0F ] ;     /* 301b */
+                else
+                    temp = LCDRefreshIndex[ pVBInfo->LCDResInfo & 0x0F ] ;
+
+                if ( index > temp )
+                {
+                    index = temp ;
+                }
+            }
+            else
+            {
+                index = 0 ;
+            }
+        }
+    }
+
+    RefreshRateTableIndex = pVBInfo->EModeIDTable[ ModeIdIndex ].REFindex ;
+    ModeNo = pVBInfo->RefIndex[ RefreshRateTableIndex ].ModeID ;
+    if ( pXGIHWDE->jChipType >= XG20 )  /* for XG20, XG21, XG27 */
+    {
+      /*
+      if ( pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_InfoFlag & XG2xNotSupport )
+      {
+        index++;
+      }
+      */
+      if ( ( pVBInfo->RefIndex[ RefreshRateTableIndex ].XRes == 800 ) && 
+           ( pVBInfo->RefIndex[ RefreshRateTableIndex ].YRes == 600 ) )
+      {
+        index++;
+      }
+/* Alan 10/19/2007; do the similiar adjustment like XGISearchCRT1Rate() */
+      if ( ( pVBInfo->RefIndex[ RefreshRateTableIndex ].XRes == 1024 ) && 
+           ( pVBInfo->RefIndex[ RefreshRateTableIndex ].YRes == 768 ) )
+      {
+        index++;
+      }
+      if ( ( pVBInfo->RefIndex[ RefreshRateTableIndex ].XRes == 1280 ) && 
+           ( pVBInfo->RefIndex[ RefreshRateTableIndex ].YRes == 1024 ) )
+      {
+        index++;
+      }
+    }
+
+    i = 0 ;    
+    do
+    {
+        if ( pVBInfo->RefIndex[ RefreshRateTableIndex + i ].ModeID != ModeNo )
+            break ;
+        temp = pVBInfo->RefIndex[ RefreshRateTableIndex + i ].Ext_InfoFlag ;
+        temp &= ModeInfoFlag ;
+        if ( temp < pVBInfo->ModeType )
+            break ;
+        i++ ;
+        index-- ;
+
+    } while( index != 0xFFFF ) ;
+    if ( !( pVBInfo->VBInfo & SetCRT2ToRAMDAC ) )
+    {
+        if ( pVBInfo->VBInfo & SetInSlaveMode )
+        {
+            temp = pVBInfo->RefIndex[ RefreshRateTableIndex + i - 1 ].Ext_InfoFlag ;
+            if ( temp & InterlaceMode )
+            {
+                i++ ;
+            }
+        }
+    }
+    i-- ;
+    if ( ( pVBInfo->SetFlag & ProgrammingCRT2 ) )
+    {
+        temp = XGI_AjustCRT2Rate( ModeNo , ModeIdIndex , RefreshRateTableIndex , &i, pVBInfo) ;
+    }
+    return( RefreshRateTableIndex + i ) ;                /*return(0x01|(temp1<<1));   */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_AjustCRT2Rate */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_AjustCRT2Rate( USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex , USHORT *i, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempax ,
+           tempbx ,
+           resinfo ,
+           modeflag ,
+           infoflag ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;	/* si+St_ModeFlag */
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+    }
+
+    resinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;
+    tempbx = pVBInfo->RefIndex[ RefreshRateTableIndex + ( *i ) ].ModeID ;
+    tempax = 0 ;
+
+    if ( pVBInfo->IF_DEF_LVDS == 0 )
+    {
+        if ( pVBInfo->VBInfo & SetCRT2ToRAMDAC )
+        {
+            tempax |= SupportRAMDAC2 ;
+
+            if ( pVBInfo->VBType & VB_XGI301C )
+                tempax |= SupportCRT2in301C ;
+        }
+
+        if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )	/* 301b */
+        {
+            tempax |= SupportLCD ;
+
+            if ( pVBInfo->LCDResInfo != Panel1280x1024 )
+            {
+                if ( pVBInfo->LCDResInfo != Panel1280x960 )
+                {
+                    if ( pVBInfo->LCDInfo & LCDNonExpanding )
+                    {
+                        if ( resinfo >= 9 )
+                        {
+                            tempax = 0 ;
+                            return( 0 ) ;
+                        }
+                    }
+                }
+            }
+        }
+
+        if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )	/* for HiTV */
+        {
+            if ( ( pVBInfo->VBType & VB_XGI301LV ) && ( pVBInfo->VBExtInfo == VB_YPbPr1080i ) )
+            {
+                tempax |= SupportYPbPr ;
+                if ( pVBInfo->VBInfo & SetInSlaveMode )
+                {
+                    if ( resinfo == 4 )
+                        return( 0 ) ;
+
+                    if ( resinfo == 3 )
+                        return( 0 ) ;
+
+                    if ( resinfo > 7 )
+                        return( 0 ) ;
+                }
+            }
+            else
+            {
+                tempax |= SupportHiVisionTV ;
+                if ( pVBInfo->VBInfo & SetInSlaveMode )
+                {
+                    if ( resinfo == 4 )
+                        return( 0 ) ;
+
+                    if ( resinfo == 3 )
+                    {
+                        if ( pVBInfo->SetFlag & TVSimuMode )
+                            return( 0 ) ;
+                    }
+
+                    if ( resinfo > 7 )
+                        return( 0 ) ;
+                }
+            }
+        }
+        else
+        {
+            if ( pVBInfo->VBInfo & ( SetCRT2ToAVIDEO | SetCRT2ToSVIDEO | SetCRT2ToSCART | SetCRT2ToYPbPr | SetCRT2ToHiVisionTV ) )
+            {
+                tempax |= SupportTV ;
+
+                if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+                {
+                    tempax |= SupportTV1024 ;
+                }
+
+                if ( !( pVBInfo->VBInfo & SetPALTV ) )
+                {
+                    if ( modeflag & NoSupportSimuTV )
+                    {
+                        if ( pVBInfo->VBInfo & SetInSlaveMode )
+                        {
+                            if ( !( pVBInfo->VBInfo & SetNotSimuMode ) )
+                            {
+                               return( 0 ) ;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+    else		/* for LVDS */
+    {
+        if ( pVBInfo->IF_DEF_CH7005 == 1 )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToTV )
+            {
+                tempax |= SupportCHTV ;
+            }
+        }
+
+        if ( pVBInfo->VBInfo & SetCRT2ToLCD )
+        {
+            tempax |= SupportLCD ;
+
+            if ( resinfo > 0x08 )
+                return( 0 ) ;		/* 1024x768 */
+
+            if ( pVBInfo->LCDResInfo < Panel1024x768 )
+            {
+                if ( resinfo > 0x07 )
+                    return( 0 ) ;	/* 800x600 */
+
+                if ( resinfo == 0x04 )
+                    return( 0 ) ;	/* 512x384 */
+            }
+        }
+    }
+
+    for( ; pVBInfo->RefIndex[ RefreshRateTableIndex + ( *i ) ].ModeID == tempbx ; ( *i )-- )
+    {
+        infoflag = pVBInfo->RefIndex[ RefreshRateTableIndex + ( *i ) ].Ext_InfoFlag ;
+        if ( infoflag & tempax )
+        {
+            return( 1 ) ;
+        }
+        if ( ( *i ) == 0 )
+            break ;
+    }
+
+    for( ( *i ) = 0 ; ; ( *i )++ )
+    {
+        infoflag = pVBInfo->RefIndex[ RefreshRateTableIndex + ( *i ) ].Ext_InfoFlag ;
+        if ( pVBInfo->RefIndex[ RefreshRateTableIndex + ( *i ) ].ModeID != tempbx )
+        {
+            return( 0 ) ;
+        }
+
+        if ( infoflag & tempax )
+        {
+            return( 1 ) ;
+        }
+    }
+    return( 1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetSync */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetSync(USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT sync ,
+           temp ;
+
+    sync = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_InfoFlag >> 8 ;	/* di+0x00 */
+    sync &= 0xC0 ;
+    temp = 0x2F ;
+    temp |= sync ;
+    XGINew_SetReg3( pVBInfo->P3c2 , temp ) ;				/* Set Misc(3c2) */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT1CRTC */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT1CRTC( USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex,PVB_DEVICE_INFO pVBInfo, PXGI_HW_DEVICE_INFO HwDeviceExtension )
+{
+    UCHAR  index ,
+           data ;
+
+#ifndef LINUX_XF86
+    USHORT temp ,
+           tempah ,
+           j ,
+           modeflag ,
+           ResInfo ,
+           DisplayType ;
+#endif
+    USHORT i ;
+
+    index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT1CRTC ;	/* Get index */
+    index = index&IndexMask ;
+
+    data =( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x11 ) ;
+    data &= 0x7F ;
+    XGINew_SetReg1(pVBInfo->P3d4,0x11,data);				/* Unlock CRTC */
+
+    for( i = 0 ; i < 8 ; i++ )
+        pVBInfo->TimingH[ 0 ].data[ i ] = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ i ] ;
+
+    for( i = 0 ; i < 7 ; i++ )
+        pVBInfo->TimingV[ 0 ].data[ i ] = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ i + 8 ] ;
+
+    XGI_SetCRT1Timing_H( pVBInfo, HwDeviceExtension ) ;
+
+
+
+    XGI_SetCRT1Timing_V( ModeIdIndex , ModeNo, pVBInfo ) ;
+
+
+    if( pVBInfo->ModeType > 0x03 )
+        XGINew_SetReg1( pVBInfo->P3d4 , 0x14 , 0x4F ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT1Timing_H */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT1Timing_H( PVB_DEVICE_INFO pVBInfo, PXGI_HW_DEVICE_INFO HwDeviceExtension )
+{
+    UCHAR data , data1, pushax;
+    USHORT i , j ;
+
+    /* XGINew_SetReg1( pVBInfo->P3d4 , 0x51 , 0 ) ; */
+    /* XGINew_SetReg1( pVBInfo->P3d4 , 0x56 , 0 ) ; */
+    /* XGINew_SetRegANDOR( pVBInfo->P3d4 ,0x11 , 0x7f , 0x00 ) ; */
+
+    data = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x11 ) ;		/* unlock cr0-7 */
+    data &= 0x7F ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x11 , data ) ;
+
+    data = pVBInfo->TimingH[ 0 ].data[ 0 ] ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0 , data ) ;
+
+    for( i = 0x01 ; i <= 0x04 ; i++ )
+    {
+        data = pVBInfo->TimingH[ 0 ].data[ i ] ;
+        XGINew_SetReg1( pVBInfo->P3d4 , ( USHORT )( i + 1 ) , data ) ;
+    }
+
+    for( i = 0x05 ; i <= 0x06 ; i++ )
+    {
+        data = pVBInfo->TimingH[ 0 ].data[ i ];
+        XGINew_SetReg1( pVBInfo->P3c4 ,( USHORT )( i + 6 ) , data ) ;
+    }
+
+    j = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x0e ) ;
+    j &= 0x1F ;
+    data = pVBInfo->TimingH[ 0 ].data[ 7 ] ;
+    data &= 0xE0 ;
+    data |= j ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x0e , data ) ;
+
+    if ( HwDeviceExtension->jChipType >= XG20 )
+    {
+    	data = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x04 ) ;
+    	data = data - 1 ;
+    	XGINew_SetReg1( pVBInfo->P3d4 , 0x04 , data ) ;
+    	data = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x05 ) ;
+    	data1 = data ;
+    	data1 &= 0xE0 ;
+    	data &= 0x1F ;
+    	if ( data == 0 )
+    	{
+    	    pushax = data ;
+    	    data = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x0c ) ;
+    	    data &= 0xFB ;
+    	    XGINew_SetReg1( pVBInfo->P3c4 , 0x0c , data ) ;
+    	    data = pushax ;
+    	}
+    	data = data - 1 ;
+    	data |= data1 ;
+    	XGINew_SetReg1( pVBInfo->P3d4 , 0x05 , data ) ;
+    	data = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x0e ) ;
+    	data = data >> 5 ;
+    	data = data + 3 ;
+    	if ( data > 7 )
+    	    data = data - 7 ;
+    	data = data << 5 ;
+    	XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0e , ~0xE0 , data ) ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT1Timing_V */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT1Timing_V( USHORT ModeIdIndex , USHORT ModeNo,PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR data ;
+    USHORT i , j ;
+
+    /* XGINew_SetReg1( pVBInfo->P3d4 , 0x51 , 0 ) ; */
+    /* XGINew_SetReg1( pVBInfo->P3d4 , 0x56 , 0 ) ; */
+    /* XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x11 , 0x7f , 0x00 ) ; */
+
+    for( i = 0x00 ; i <= 0x01 ; i++ )
+    {
+        data = pVBInfo->TimingV[ 0 ].data[ i ] ;
+        XGINew_SetReg1( pVBInfo->P3d4 , ( USHORT )( i + 6 ) , data ) ;
+    }
+
+    for( i = 0x02 ; i <= 0x03 ; i++ )
+    {
+        data = pVBInfo->TimingV[ 0 ].data[ i ] ;
+        XGINew_SetReg1( pVBInfo->P3d4 , ( USHORT )( i + 0x0e ) , data ) ;
+    }
+
+    for( i = 0x04 ; i <= 0x05 ; i++ )
+    {
+        data = pVBInfo->TimingV[ 0 ].data[ i ] ;
+        XGINew_SetReg1( pVBInfo->P3d4 , ( USHORT )( i + 0x11 ) , data ) ;
+    }
+
+    j = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x0a ) ;
+    j &= 0xC0 ;
+    data = pVBInfo->TimingV[ 0 ].data[ 6 ] ;
+    data &= 0x3F ;
+    data |= j ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x0a , data ) ;
+
+    data = pVBInfo->TimingV[ 0 ].data[ 6 ] ;
+    data &= 0x80 ;
+    data = data >> 2 ;
+
+    if ( ModeNo <= 0x13 )
+        i = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+    else
+        i = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+
+    i &= DoubleScanMode ;
+    if ( i )
+        data |= 0x80 ;
+
+    j = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x09 ) ;
+    j &= 0x5F ;
+    data |= j ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x09 , data ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetXG21CRTC */
+/* Input : Stand or enhance CRTC table */
+/* Output : Fill CRT Hsync/Vsync to SR2E/SR2F/SR30/SR33/SR34/SR3F */
+/* Description : Set LCD timing */
+/* --------------------------------------------------------------------- */
+void XGI_SetXG21CRTC(USHORT ModeNo, USHORT ModeIdIndex, USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo)
+{
+  UCHAR StandTableIndex, index, Tempax, Tempbx, Tempcx, Tempdx ;
+  USHORT Temp1, Temp2, Temp3 ;
+
+  if ( ModeNo <= 0x13 )
+  {
+    StandTableIndex = XGI_GetModePtr( ModeNo , ModeIdIndex, pVBInfo ) ;
+    Tempax = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 4 ] ;		/* CR04 HRS */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2E , Tempax ) ;    		/* SR2E [7:0]->HRS */
+    Tempbx = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 5 ] ;		/* Tempbx: CR05 HRE */
+    Tempbx &= 0x1F ;							/* Tempbx: HRE[4:0] */
+    Tempcx = Tempax ;
+    Tempcx &=  0xE0 ;							/* Tempcx: HRS[7:5] */
+    Tempdx = Tempcx | Tempbx ;						/* Tempdx(HRE): HRS[7:5]HRE[4:0] */
+    if ( Tempbx < ( Tempax & 0x1F ) )					/* IF HRE < HRS */
+      Tempdx |= 0x20 ;							/* Tempdx: HRE = HRE + 0x20 */
+    Tempdx <<= 2 ;							/* Tempdx << 2 */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2F , Tempdx ) ;    		/* SR2F [7:2]->HRE */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x30 , 0xE3 , 00 ) ;
+
+    Tempax = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 16 ] ;	/* Tempax: CR16 VRS */
+    Tempbx = Tempax ;							/* Tempbx=Tempax */
+    Tempax &= 0x01 ;							/* Tempax: VRS[0] */
+    XGINew_SetRegOR( pVBInfo->P3c4 , 0x33 , Tempax ) ;   		/* SR33[0]->VRS */
+    Tempax = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 7 ] ;		/* Tempax: CR7 VRS */
+    Tempdx = Tempbx >> 1 ;						/* Tempdx: VRS[7:1] */
+    Tempcx = Tempax & 0x04 ;						/* Tempcx: CR7[2] */
+    Tempcx <<= 5 ;							/* Tempcx[7]: VRS[8] */
+    Tempdx |= Tempcx ;							/* Tempdx: VRS[8:1] */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x34 , Tempdx ) ;    		/* SR34[7:0]: VRS[8:1] */
+
+    Temp1 = Tempcx << 1 ;						/* Temp1[8]: VRS[8] UCHAR -> USHORT */
+    Temp1 |= Tempbx ;							/* Temp1[8:0]: VRS[8:0] */
+    Tempax &= 0x80 ;							/* Tempax[7]: CR7[7] */
+    Temp2 = Tempax << 2 ;						/* Temp2[9]: VRS[9] */
+    Temp1 |= Temp2 ;							/* Temp1[9:0]: VRS[9:0] */
+
+    Tempax = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 17 ] ;	/* CR16 VRE */
+    Tempax &= 0x0F ;							/* Tempax[3:0]: VRE[3:0] */
+    Temp2 = Temp1 & 0x3F0 ;						/* Temp2[9:4]: VRS[9:4] */
+    Temp2 |= Tempax ;							/* Temp2[9:0]: VRE[9:0] */
+    Temp3 = Temp1 & 0x0F ;						/* Temp3[3:0]: VRS[3:0] */
+    if ( Tempax < Temp3 )						/* VRE[3:0]<VRS[3:0] */
+      Temp2 |= 0x10 ;							/* Temp2: VRE + 0x10 */
+    Temp2 &= 0xFF ;							/* Temp2[7:0]: VRE[7:0] */
+    Tempax = (UCHAR)Temp2 ;						/* Tempax[7:0]: VRE[7:0] */
+    Tempax <<= 2 ;							/* Tempax << 2: VRE[5:0] */
+    Temp1 &= 0x600 ;							/* Temp1[10:9]: VRS[10:9] */
+    Temp1 >>= 9 ;							/* [10:9]->[1:0] */
+    Tempbx = (UCHAR)Temp1 ;						/* Tempbx[1:0]: VRS[10:9] */
+    Tempax |= Tempbx ;							/* VRE[5:0]VRS[10:9] */
+    Tempax &= 0x7F ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x3F , Tempax ) ;   		/* SR3F D[7:2]->VRE D[1:0]->VRS */
+  }
+  else
+  {
+    index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT1CRTC ;
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 3 ] ;		/* Tempax: CR4 HRS */
+    Tempcx = Tempax ;							/* Tempcx: HRS */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2E , Tempax ) ;  		        /* SR2E[7:0]->HRS */
+
+    Tempdx = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 5 ] ;		/* SRB */
+    Tempdx &= 0xC0 ;							/* Tempdx[7:6]: SRB[7:6] */
+    Temp1 = Tempdx ;							/* Temp1[7:6]: HRS[9:8] */
+    Temp1 <<= 2 ;							/* Temp1[9:8]: HRS[9:8] */
+    Temp1 |= Tempax ;							/* Temp1[9:0]: HRS[9:0] */
+
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 4 ] ;		/* CR5 HRE */
+    Tempax &= 0x1F ;							/* Tempax[4:0]: HRE[4:0] */
+
+    Tempbx = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 6 ] ;		/* SRC */
+    Tempbx &= 0x04 ;							/* Tempbx[2]: HRE[5] */
+    Tempbx <<= 3 ;							/* Tempbx[5]: HRE[5] */
+    Tempax |= Tempbx ;							/* Tempax[5:0]: HRE[5:0] */
+
+    Temp2 = Temp1 & 0x3C0 ;						/* Temp2[9:6]: HRS[9:6] */
+    Temp2 |= Tempax ;							/* Temp2[9:0]: HRE[9:0] */
+
+    Tempcx &= 0x3F ;							/* Tempcx[5:0]: HRS[5:0] */
+    if( Tempax < Tempcx )						/* HRE < HRS */
+      Temp2 |= 0x40 ;                                                   /* Temp2 + 0x40 */
+
+    Temp2 &= 0xFF ;
+    Tempax = (UCHAR)Temp2 ;						/* Tempax: HRE[7:0] */
+    Tempax <<= 2 ;							/* Tempax[7:2]: HRE[5:0] */
+    Tempdx >>= 6 ;							/* Tempdx[7:6]->[1:0] HRS[9:8] */
+    Tempax |= Tempdx ;							/* HRE[5:0]HRS[9:8] */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2F , Tempax ) ;    		/* SR2F D[7:2]->HRE, D[1:0]->HRS */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x30 , 0xE3 , 00 ) ;
+
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 10 ] ;		/* CR10 VRS */
+    Tempbx = Tempax ;							/* Tempbx: VRS */
+    Tempax &= 0x01 ;							/* Tempax[0]: VRS[0] */
+    XGINew_SetRegOR( pVBInfo->P3c4 , 0x33 , Tempax ) ;   		/* SR33[0]->VRS[0] */
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 9 ] ;		/* CR7[2][7] VRE */
+    Tempcx = Tempbx >> 1 ;				   		/* Tempcx[6:0]: VRS[7:1] */
+    Tempdx = Tempax & 0x04 ;						/* Tempdx[2]: CR7[2] */
+    Tempdx <<= 5 ;							/* Tempdx[7]: VRS[8] */
+    Tempcx |= Tempdx ;							/* Tempcx[7:0]: VRS[8:1] */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x34 , Tempcx ) ;   		/* SR34[8:1]->VRS */
+
+    Temp1 = Tempdx ;							/* Temp1[7]: Tempdx[7] */
+    Temp1 <<= 1 ;							/* Temp1[8]: VRS[8] */
+    Temp1 |= Tempbx ;							/* Temp1[8:0]: VRS[8:0] */
+    Tempax &= 0x80 ;
+    Temp2 = Tempax << 2 ;						/* Temp2[9]: VRS[9] */
+    Temp1 |= Temp2 ;							/* Temp1[9:0]: VRS[9:0] */
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 14 ] ;		/* Tempax: SRA */
+    Tempax &= 0x08 ;							/* Tempax[3]: VRS[3] */
+    Temp2 = Tempax ;
+    Temp2 <<= 7 ;							/* Temp2[10]: VRS[10] */
+    Temp1 |= Temp2 ;							/* Temp1[10:0]: VRS[10:0] */
+
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 11 ] ;		/* Tempax: CR11 VRE */
+    Tempax &= 0x0F ;							/* Tempax[3:0]: VRE[3:0] */
+    Tempbx = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 14 ] ;		/* Tempbx: SRA */
+    Tempbx &= 0x20 ;							/* Tempbx[5]: VRE[5] */
+    Tempbx >>= 1 ;							/* Tempbx[4]: VRE[4] */
+    Tempax |= Tempbx ;							/* Tempax[4:0]: VRE[4:0] */
+    Temp2 = Temp1 & 0x7E0 ;						/* Temp2[10:5]: VRS[10:5] */
+    Temp2 |= Tempax ;							/* Temp2[10:5]: VRE[10:5] */
+
+    Temp3 = Temp1 & 0x1F ;						/* Temp3[4:0]: VRS[4:0] */
+    if ( Tempax < Temp3 )						/* VRE < VRS */
+      Temp2 |= 0x20 ;							/* VRE + 0x20 */
+
+    Temp2 &= 0xFF ;
+    Tempax = (UCHAR)Temp2 ;						/* Tempax: VRE[7:0] */
+    Tempax <<= 2 ;							/* Tempax[7:0]; VRE[5:0]00 */
+    Temp1 &= 0x600 ;							/* Temp1[10:9]: VRS[10:9] */
+    Temp1 >>= 9 ;  							/* Temp1[1:0]: VRS[10:9] */
+    Tempbx = (UCHAR)Temp1 ;
+    Tempax |= Tempbx ;							/* Tempax[7:0]: VRE[5:0]VRS[10:9] */
+    Tempax &= 0x7F ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x3F , Tempax ) ;   		/* SR3F D[7:2]->VRE D[1:0]->VRS */
+  }
+}
+
+void XGI_SetXG27CRTC(USHORT ModeNo, USHORT ModeIdIndex, USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo)
+{
+  USHORT StandTableIndex, index, Tempax, Tempbx, Tempcx, Tempdx ;
+  USHORT Temp1, Temp2, Temp3 ;
+
+  if ( ModeNo <= 0x13 )
+  {
+    StandTableIndex = XGI_GetModePtr( ModeNo , ModeIdIndex, pVBInfo ) ;
+    Tempax = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 4 ] ;		/* CR04 HRS */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2E , Tempax ) ;    		/* SR2E [7:0]->HRS */
+    Tempbx = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 5 ] ;		/* Tempbx: CR05 HRE */
+    Tempbx &= 0x1F ;							/* Tempbx: HRE[4:0] */
+    Tempcx = Tempax ;
+    Tempcx &=  0xE0 ;							/* Tempcx: HRS[7:5] */
+    Tempdx = Tempcx | Tempbx ;						/* Tempdx(HRE): HRS[7:5]HRE[4:0] */
+    if ( Tempbx < ( Tempax & 0x1F ) )					/* IF HRE < HRS */
+      Tempdx |= 0x20 ;							/* Tempdx: HRE = HRE + 0x20 */
+    Tempdx <<= 2 ;							/* Tempdx << 2 */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2F , Tempdx ) ;    		/* SR2F [7:2]->HRE */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x30 , 0xE3 , 00 ) ;
+
+    Tempax = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 16 ] ;	/* Tempax: CR10 VRS */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x34 , Tempax ) ;   		/* SR34[7:0]->VRS */
+    Tempcx = Tempax ;							/* Tempcx=Tempax=VRS[7:0] */
+    Tempax = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 7 ] ;		/* Tempax[7][2]: CR7[7][2] VRS[9][8] */
+    Tempbx = Tempax ;							/* Tempbx=CR07 */
+    Tempax &= 0x04 ;     						/* Tempax[2]: CR07[2] VRS[8] */
+    Tempax >>= 2;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x35 , ~0x01, Tempax ) ;        /* SR35 D[0]->VRS D[8] */
+    Tempcx |= (Tempax << 8) ;					        /* Tempcx[8] |= VRS[8] */
+    Tempcx |= (Tempbx & 0x80)<<2;					/* Tempcx[9] |= VRS[9] */
+
+
+    Tempax = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 17 ] ;	/* CR11 VRE */
+    Tempax &= 0x0F ;							/* Tempax: VRE[3:0] */
+    Tempbx = Tempcx ;							/* Tempbx=Tempcx=VRS[9:0] */
+    Tempbx &= 0x3F0 ;    						/* Tempbx[9:4]: VRS[9:4] */
+    Tempbx |= Tempax ;							/* Tempbx[9:0]: VRE[9:0] */
+    if ( Tempax <= (Tempcx & 0x0F) )					/* VRE[3:0]<=VRS[3:0] */
+      Tempbx |= 0x10 ;							/* Tempbx: VRE + 0x10 */
+    Tempax = (UCHAR)Tempbx & 0xFF;					/* Tempax[7:0]: VRE[7:0] */
+    Tempax <<= 2 ;							/* Tempax << 2: VRE[5:0] */
+    Tempcx = (Tempcx&0x600)>>8;                                         /* Tempcx VRS[10:9] */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x3F , ~0xFC, Tempax ) ;        /* SR3F D[7:2]->VRE D[5:0] */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x35 , ~0x06, Tempcx ) ;	/* SR35 D[2:1]->VRS[10:9] */
+  }
+  else
+  {
+    index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT1CRTC ;
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 3 ] ;		/* Tempax: CR4 HRS */
+    Tempbx = Tempax ;							/* Tempbx: HRS[7:0] */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2E , Tempax ) ;  		        /* SR2E[7:0]->HRS */
+
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 5 ] ;		/* SR0B */
+    Tempax &= 0xC0 ;							/* Tempax[7:6]: SR0B[7:6]: HRS[9:8]*/
+    Tempbx |= (Tempax << 2);					/* Tempbx: HRS[9:0] */
+
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 4 ] ;		/* CR5 HRE */
+    Tempax &= 0x1F ;							/* Tempax[4:0]: HRE[4:0] */
+    Tempcx = Tempax ;							/* Tempcx: HRE[4:0] */
+
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 6 ] ;		/* SRC */
+    Tempax &= 0x04 ;							/* Tempax[2]: HRE[5] */
+    Tempax <<= 3 ;							    /* Tempax[5]: HRE[5] */
+    Tempcx |= Tempax ;							/* Tempcx[5:0]: HRE[5:0] */
+
+    Tempbx = Tempbx & 0x3C0 ;					/* Tempbx[9:6]: HRS[9:6] */
+    Tempbx |= Tempcx ;							/* Tempbx: HRS[9:6]HRE[5:0] */
+    
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 3 ] ;		/* Tempax: CR4 HRS */
+    Tempax &= 0x3F ;							/* Tempax: HRS[5:0] */
+    if( Tempcx <= Tempax )						/* HRE[5:0] < HRS[5:0] */
+      Tempbx += 0x40 ;                          /* Tempbx= Tempbx + 0x40 : HRE[9:0]*/
+
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 5 ] ;		/* SR0B */
+    Tempax &= 0xC0 ;							/* Tempax[7:6]: SR0B[7:6]: HRS[9:8]*/
+    Tempax >>= 6;                               /* Tempax[1:0]: HRS[9:8]*/
+    Tempax |= ((Tempbx << 2) & 0xFF);           /* Tempax[7:2]: HRE[5:0] */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2F , Tempax ) ;    		/* SR2F [7:2][1:0]: HRE[5:0]HRS[9:8] */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x30 , 0xE3 , 00 ) ;
+
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 10 ] ;		/* CR10 VRS */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x34 , Tempax ) ;   		/* SR34[7:0]->VRS[7:0] */
+    
+    Tempcx = Tempax ;							/* Tempcx <= VRS[7:0] */
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 9 ] ;		/* CR7[7][2] VRS[9][8] */
+    Tempbx = Tempax ;							/* Tempbx <= CR07[7:0] */    
+    Tempax = Tempax & 0x04 ;					/* Tempax[2]: CR7[2]: VRS[8] */
+    Tempax >>= 2 ;							    /* Tempax[0]: VRS[8] */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x35 , ~0x01 , Tempax ) ;   	/* SR35[0]: VRS[8] */
+    Tempcx |= (Tempax<<8) ;						/* Tempcx <= VRS[8:0] */
+    Tempcx |= ((Tempbx&0x80)<<2) ;				/* Tempcx <= VRS[9:0] */
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 14 ] ;		/* Tempax: SR0A */
+    Tempax &= 0x08;                             /* SR0A[3] VRS[10] */
+    Tempcx |= (Tempax<<7) ;        				/* Tempcx <= VRS[10:0] */
+    
+
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 11 ] ;		/* Tempax: CR11 VRE */
+    Tempax &= 0x0F ;							/* Tempax[3:0]: VRE[3:0] */
+    Tempbx = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 14 ] ;		/* Tempbx: SR0A */
+    Tempbx &= 0x20 ;							/* Tempbx[5]: SR0A[5]: VRE[4] */
+    Tempbx >>= 1 ;							    /* Tempbx[4]: VRE[4] */
+    Tempax |= Tempbx ;							/* Tempax[4:0]: VRE[4:0] */
+    Tempbx = Tempcx ;							/* Tempbx: VRS[10:0] */
+    Tempbx &= 0x7E0 ;						    /* Tempbx[10:5]: VRS[10:5] */
+    Tempbx |= Tempax ;							/* Tempbx: VRS[10:5]VRE[4:0] */
+
+    if ( Tempbx <= Tempcx )						/* VRE <= VRS */
+      Tempbx |= 0x20 ;							/* VRE + 0x20 */
+
+    Tempax = (Tempbx<<2) & 0xFF ;					/* Tempax: Tempax[7:0]; VRE[5:0]00 */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x3F , ~0xFC , Tempax ) ;	/* SR3F[7:2]:VRE[5:0] */
+    Tempax = Tempcx >> 8;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x35 , ~0x07 , Tempax ) ;	/* SR35[2:0]:VRS[10:8] */
+  }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetXG21LCD */
+/* Input : */
+/* Output : FCLK duty cycle, FCLK delay compensation */
+/* Description : All values set zero */
+/* --------------------------------------------------------------------- */
+void XGI_SetXG21LCD(PVB_DEVICE_INFO pVBInfo,USHORT RefreshRateTableIndex,USHORT ModeNo)
+{
+  USHORT Data , Temp , b3CC ;
+  USHORT XGI_P3cc ;
+
+  if ( ModeNo > 0x13 )
+    Data = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_InfoFlag ;
+  XGI_P3cc = pVBInfo->P3cc ;
+
+  XGINew_SetReg1( pVBInfo->P3d4 , 0x2E , 0x00 ) ;
+  XGINew_SetReg1( pVBInfo->P3d4 , 0x2F , 0x00 ) ;
+  XGINew_SetReg1( pVBInfo->P3d4 , 0x46 , 0x00 ) ;
+  XGINew_SetReg1( pVBInfo->P3d4 , 0x47 , 0x00 ) ;
+  if ( ((*pVBInfo->pDVOSetting)&0xC0) == 0xC0 )
+  {
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x2E , *pVBInfo->pCR2E ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x2F , *pVBInfo->pCR2F ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x46 , *pVBInfo->pCR46 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x47 , *pVBInfo->pCR47 ) ;
+  }
+
+  Temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x37 ) ;
+  
+  if ( Temp & 0x01 )
+  {
+    XGINew_SetRegOR( pVBInfo->P3c4 , 0x06 , 0x40 ) ; /* 18 bits FP */
+    XGINew_SetRegOR( pVBInfo->P3c4 , 0x09 , 0x40 ) ;
+  }
+
+  XGINew_SetRegOR( pVBInfo->P3c4 , 0x1E , 0x01 ) ;   /* Negative blank polarity */
+
+  XGINew_SetRegAND( pVBInfo->P3c4 , 0x30 , ~0x20 ) ;
+  XGINew_SetRegAND( pVBInfo->P3c4 , 0x35 , ~0x80 ) ;
+
+  if ( ModeNo <= 0x13 )
+  {
+    b3CC = (UCHAR) XGINew_GetReg2( XGI_P3cc ) ;
+    if ( b3CC & 0x40 )
+      XGINew_SetRegOR( pVBInfo->P3c4 , 0x30 , 0x20 ) ; /* Hsync polarity */
+    if ( b3CC & 0x80 )
+      XGINew_SetRegOR( pVBInfo->P3c4 , 0x35 , 0x80 ) ; /* Vsync polarity */
+  }
+  else
+  {
+    if ( Data & 0x4000 )
+      XGINew_SetRegOR( pVBInfo->P3c4 , 0x30 , 0x20 ) ; /* Hsync polarity */
+    if ( Data & 0x8000 )
+      XGINew_SetRegOR( pVBInfo->P3c4 , 0x35 , 0x80 ) ; /* Vsync polarity */
+  }
+}
+
+void XGI_SetXG27LCD(PVB_DEVICE_INFO pVBInfo,USHORT RefreshRateTableIndex,USHORT ModeNo)
+{
+  USHORT Data , Temp , b3CC ;
+  USHORT XGI_P3cc ;
+
+  if ( ModeNo > 0x13 )
+    Data = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_InfoFlag ;
+  XGI_P3cc = pVBInfo->P3cc ;
+
+  XGINew_SetReg1( pVBInfo->P3d4 , 0x2E , 0x00 ) ;
+  XGINew_SetReg1( pVBInfo->P3d4 , 0x2F , 0x00 ) ;
+  XGINew_SetReg1( pVBInfo->P3d4 , 0x46 , 0x00 ) ;
+  XGINew_SetReg1( pVBInfo->P3d4 , 0x47 , 0x00 ) ;
+
+  Temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x37 ) ;
+  if ( ( Temp & 0x03 ) == 0 )  /* dual 12 */
+  {
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x46 , 0x13 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x47 , 0x13 ) ;
+  }
+
+  if ( ((*pVBInfo->pDVOSetting)&0xC0) == 0xC0 )
+  {
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x2E , *pVBInfo->pCR2E ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x2F , *pVBInfo->pCR2F ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x46 , *pVBInfo->pCR46 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x47 , *pVBInfo->pCR47 ) ;
+  }
+
+  XGI_SetXG27FPBits(pVBInfo);
+  
+  XGINew_SetRegOR( pVBInfo->P3c4 , 0x1E , 0x01 ) ;   /* Negative blank polarity */
+
+  XGINew_SetRegAND( pVBInfo->P3c4 , 0x30 , ~0x20 ) ; /* Hsync polarity */
+  XGINew_SetRegAND( pVBInfo->P3c4 , 0x35 , ~0x80 ) ; /* Vsync polarity */
+
+  if ( ModeNo <= 0x13 )
+  {
+    b3CC = (UCHAR) XGINew_GetReg2( XGI_P3cc ) ;
+    if ( b3CC & 0x40 )
+      XGINew_SetRegOR( pVBInfo->P3c4 , 0x30 , 0x20 ) ; /* Hsync polarity */
+    if ( b3CC & 0x80 )
+      XGINew_SetRegOR( pVBInfo->P3c4 , 0x35 , 0x80 ) ; /* Vsync polarity */
+  }
+  else
+  {
+    if ( Data & 0x4000 )
+      XGINew_SetRegOR( pVBInfo->P3c4 , 0x30 , 0x20 ) ; /* Hsync polarity */
+    if ( Data & 0x8000 )
+      XGINew_SetRegOR( pVBInfo->P3c4 , 0x35 , 0x80 ) ; /* Vsync polarity */
+  }
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_UpdateXG21CRTC */
+/* Input : */
+/* Output : CRT1 CRTC */
+/* Description : Modify CRT1 Hsync/Vsync to fix LCD mode timing */
+/* --------------------------------------------------------------------- */
+void XGI_UpdateXG21CRTC( USHORT ModeNo , PVB_DEVICE_INFO pVBInfo , USHORT RefreshRateTableIndex )
+{
+  int i , index = -1;
+
+  XGINew_SetRegAND( pVBInfo->P3d4 , 0x11 , 0x7F ) ;		/* Unlock CR0~7 */
+  if ( ModeNo <= 0x13 )
+  {
+    for( i = 0 ; i < 12 ; i++ )
+    {
+      if ( ModeNo == pVBInfo->UpdateCRT1[ i ].ModeID )
+        index = i ;
+    }
+  }
+  else
+  {
+    if ( ModeNo == 0x2E && ( pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT1CRTC ==  RES640x480x60 ) )
+      index = 12 ;
+    else if ( ModeNo == 0x2E && ( pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT1CRTC == RES640x480x72 ) )
+      index = 13 ;
+    else if ( ModeNo == 0x2F )
+      index = 14 ;
+    else if ( ModeNo == 0x50 )
+      index = 15 ;
+    else if ( ModeNo == 0x59 )
+      index = 16 ;
+  }
+
+  if( index != -1 )
+  {
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x02 , pVBInfo->UpdateCRT1[ index ].CR02 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x03 , pVBInfo->UpdateCRT1[ index ].CR03 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x15 , pVBInfo->UpdateCRT1[ index ].CR15 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x16 , pVBInfo->UpdateCRT1[ index ].CR16 ) ;
+  }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT1DE */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT1DE( PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT ModeNo,USHORT ModeIdIndex , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT resindex ,
+           tempax ,
+           tempbx ,
+           tempcx ,
+           temp ,
+           modeflag ;
+
+    UCHAR data ;
+
+    resindex = XGI_GetResInfo( ModeNo , ModeIdIndex, pVBInfo ) ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+        tempax = pVBInfo->StResInfo[ resindex ].HTotal ;
+        tempbx = pVBInfo->StResInfo[ resindex ].VTotal ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+        tempax = pVBInfo->ModeResInfo[ resindex ].HTotal ;
+        tempbx = pVBInfo->ModeResInfo[ resindex ].VTotal ;
+    }
+
+    if ( modeflag & HalfDCLK )
+        tempax = tempax >> 1 ;
+
+    if ( ModeNo > 0x13 )
+    {
+        if ( modeflag & HalfDCLK )
+            tempax = tempax << 1 ;
+
+        temp = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_InfoFlag ;
+
+        if ( temp & InterlaceMode )
+            tempbx = tempbx >> 1 ;
+
+        if ( modeflag & DoubleScanMode )
+            tempbx = tempbx << 1 ;
+    }
+
+    tempcx = 8 ;
+
+    /* if ( !( modeflag & Charx8Dot ) ) */
+    /* tempcx = 9 ; */
+
+    tempax /= tempcx ;
+    tempax -= 1 ;
+    tempbx -= 1 ;
+    tempcx = tempax ;
+    temp = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x11 ) ;
+    data = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x11 ) ;
+    data &= 0x7F ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x11 , data ) ;		/* Unlock CRTC */
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x01 , ( USHORT )( tempcx & 0xff ) ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x0b , ~0x0c , ( USHORT )( ( tempcx & 0x0ff00 ) >> 10 ) ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x12 , ( USHORT )( tempbx & 0xff ) ) ;
+    tempax = 0 ;
+    tempbx = tempbx >> 8 ;
+
+    if ( tempbx & 0x01 )
+        tempax |= 0x02 ;
+
+    if ( tempbx & 0x02 )
+        tempax |= 0x40 ;
+
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x42 , tempax ) ;
+    data =( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x07 ) ;
+    data &= 0xFF ;
+    tempax = 0 ;
+
+    if ( tempbx & 0x04 )
+        tempax |= 0x02 ;
+
+    XGINew_SetRegANDOR( pVBInfo->P3d4 ,0x0a , ~0x02 , tempax ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x11 , temp ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetResInfo */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT 	XGI_GetResInfo(USHORT ModeNo , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT resindex ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        resindex = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ResInfo ; 	/* si+St_ResInfo */
+    }
+    else
+    {
+        resindex = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;	/* si+Ext_ResInfo */
+    }
+    return( resindex ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT1Offset */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT1Offset(  USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex , PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT temp ,
+           ah ,
+           al ,
+           temp2 ,
+           i ,
+           DisplayUnit ;
+
+    /* GetOffset */
+    temp = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeInfo ;
+    temp = temp >> 8 ;
+    temp = pVBInfo->ScreenOffset[ temp ] ;
+
+    temp2 = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_InfoFlag ;
+    temp2 &= InterlaceMode ;
+
+    if ( temp2 )
+        temp = temp << 1;
+
+    temp2 = pVBInfo->ModeType - ModeEGA ;
+
+    switch( temp2 )
+    {
+        case 0:
+            temp2 = 1 ;
+            break ;
+        case 1:
+            temp2 = 2 ;
+            break ;
+        case 2:
+            temp2 = 4 ;
+            break ;
+        case 3:
+            temp2 = 4 ;
+            break ;
+        case 4:
+            temp2 = 6 ;
+            break;
+        case 5:
+            temp2 = 8 ;
+            break ;
+        default:
+            break ;
+    }
+
+    if ( ( ModeNo >= 0x26 ) && ( ModeNo <= 0x28 ) )
+        temp = temp * temp2 + temp2 / 2 ;
+    else
+        temp *= temp2 ;
+
+    /* SetOffset */
+    DisplayUnit = temp ;
+    temp2 = temp ;
+    temp = temp >> 8 ;		/* ah */
+    temp &= 0x0F ;
+    i = XGINew_GetReg1( pVBInfo->P3c4 , 0x0E ) ;
+    i &= 0xF0 ;
+    i |= temp ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x0E , i ) ;
+
+    temp =( UCHAR )temp2 ;
+    temp &= 0xFF ;		/* al */
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x13 , temp ) ;
+
+    /* SetDisplayUnit */
+    temp2 = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_InfoFlag ;
+    temp2 &= InterlaceMode ;
+    if ( temp2 )
+        DisplayUnit >>= 1 ;
+
+    DisplayUnit = DisplayUnit << 5 ;
+    ah = ( DisplayUnit & 0xff00 ) >> 8 ;
+    al = DisplayUnit & 0x00ff ;
+    if ( al == 0 )
+        ah += 1 ;
+    else
+        ah += 2 ;
+
+    if ( HwDeviceExtension->jChipType >= XG20 )
+        if ( ( ModeNo == 0x4A ) | (ModeNo == 0x49 ) )
+            ah -= 1 ;
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x10 , ah ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT1VCLK */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT1VCLK( USHORT ModeNo , USHORT ModeIdIndex ,
+                        PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR index , data ;
+    USHORT vclkindex ;
+
+    if ( pVBInfo->IF_DEF_LVDS == 1 )
+    {
+        index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRTVCLK ;
+        data = XGINew_GetReg1( pVBInfo->P3c4 , 0x31 ) & 0xCF ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x31 , data ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , pVBInfo->VCLKData[ index ].SR2B ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , pVBInfo->VCLKData[ index ].SR2C ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2D , 0x01 ) ;
+    }
+    else if ( ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) ) && ( pVBInfo->VBInfo & SetCRT2ToLCDA ) )
+    {
+        vclkindex = XGI_GetVCLK2Ptr( ModeNo , ModeIdIndex , RefreshRateTableIndex , HwDeviceExtension, pVBInfo ) ;
+        data = XGINew_GetReg1( pVBInfo->P3c4 , 0x31 ) & 0xCF ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x31 , data ) ;
+        data = pVBInfo->VBVCLKData[ vclkindex ].Part4_A ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , data ) ;
+        data = pVBInfo->VBVCLKData[ vclkindex ].Part4_B ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , data ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2D , 0x01 ) ;
+    }
+    else
+    {
+        index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRTVCLK ;
+        data = XGINew_GetReg1( pVBInfo->P3c4 , 0x31 ) & 0xCF ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x31 , data ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , pVBInfo->VCLKData[ index ].SR2B ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , pVBInfo->VCLKData[ index ].SR2C ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2D , 0x01 ) ;
+    }
+
+    if ( HwDeviceExtension->jChipType >= XG20 )
+    {
+    	if ( pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag & HalfDCLK )
+    	{
+    	data = XGINew_GetReg1( pVBInfo->P3c4 , 0x2B ) ;
+    	XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , data ) ;
+    	data = XGINew_GetReg1( pVBInfo->P3c4 , 0x2C ) ;
+    	index = data ;
+    	index &= 0xE0 ;
+    	data &= 0x1F ;
+    	data = data << 1 ;
+    	data += 1 ;
+    	data |= index ;
+    	XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , data ) ;
+    	}
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT1FIFO */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT1FIFO( USHORT ModeNo , PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT data ;
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x3D ) ;
+    data &= 0xfe ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x3D , data ) ;	/* diable auto-threshold */
+
+    if ( ModeNo > 0x13 )
+    {
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x08 , 0x34 ) ;
+        data = XGINew_GetReg1( pVBInfo->P3c4 , 0x09 ) ;
+        data &= 0xC0 ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x09 , data | 0x30) ;
+        data = XGINew_GetReg1( pVBInfo->P3c4 , 0x3D ) ;
+        data |= 0x01 ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x3D , data ) ;
+    }
+    else
+    {
+        if (HwDeviceExtension->jChipType == XG27)
+        {
+          XGINew_SetReg1( pVBInfo->P3c4 , 0x08 , 0x0E ) ;
+          data = XGINew_GetReg1( pVBInfo->P3c4 , 0x09 ) ;
+          data &= 0xC0 ;
+          XGINew_SetReg1( pVBInfo->P3c4 , 0x09 , data | 0x20 ) ;
+        }
+        else
+        {
+          XGINew_SetReg1( pVBInfo->P3c4 , 0x08 , 0xAE ) ;
+          data = XGINew_GetReg1( pVBInfo->P3c4 , 0x09 ) ;
+          data &= 0xF0 ;
+          XGINew_SetReg1( pVBInfo->P3c4 , 0x09 , data ) ;
+        }
+    }
+
+    if (HwDeviceExtension->jChipType == XG21)
+    {
+        XGI_SetXG21FPBits(pVBInfo);                 /* Fix SR9[7:6] can't read back */
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT1ModeRegs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT1ModeRegs( PXGI_HW_DEVICE_INFO HwDeviceExtension ,
+                            USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex,PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT data ,
+           data2 ,
+           data3 ,
+           infoflag = 0 ,
+           modeflag ,
+           resindex ,
+           xres ;
+
+    if ( ModeNo > 0x13 )
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+        infoflag = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_InfoFlag ;
+    }
+    else
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;    /* si+St_ModeFlag */
+
+    if ( XGINew_GetReg1( pVBInfo->P3d4 , 0x31 ) & 0x01 )
+      XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x1F , 0x3F , 0x00 ) ;
+
+    if ( ModeNo > 0x13 )
+        data = infoflag ;
+    else
+        data = 0 ;
+
+    data2 = 0 ;
+
+    if ( ModeNo > 0x13 )
+    {
+        if ( pVBInfo->ModeType > 0x02 )
+        {
+            data2 |= 0x02 ;
+            data3 = pVBInfo->ModeType - ModeVGA ;
+            data3 = data3 << 2 ;
+            data2 |= data3 ;
+        }
+    }
+
+    data &= InterlaceMode ;
+
+    if ( data )
+        data2 |= 0x20 ;
+
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x06 , ~0x3F , data2 ) ;
+    /* XGINew_SetReg1(pVBInfo->P3c4,0x06,data2); */
+    resindex = XGI_GetResInfo( ModeNo , ModeIdIndex, pVBInfo ) ;
+    if ( ModeNo <= 0x13 )
+        xres = pVBInfo->StResInfo[ resindex ].HTotal ;
+    else
+        xres = pVBInfo->ModeResInfo[ resindex ].HTotal ;                         /* xres->ax */
+
+    data = 0x0000 ;
+    if ( infoflag & InterlaceMode )
+    {
+        if ( xres == 1024 )
+            data = 0x0035 ;
+        else if ( xres == 1280 )
+            data = 0x0048 ;
+    }
+
+    data2 = data & 0x00FF ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x19 , 0xFF , data2 ) ;
+    data2 = ( data & 0xFF00 ) >> 8 ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x19 , 0xFC , data2 ) ;
+
+    if( modeflag & HalfDCLK )
+        XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x01 , 0xF7 , 0x08 ) ;
+
+    data2 = 0 ;
+
+    if ( modeflag & LineCompareOff )
+        data2 |= 0x08 ;
+
+    if ( ModeNo > 0x13 )
+    {
+        if ( pVBInfo->ModeType == ModeEGA )
+            data2 |= 0x40 ;
+    }
+
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0F , ~0x48 , data2 ) ;
+    data = 0x60 ;
+    if ( pVBInfo->ModeType != ModeText )
+    {
+        data = data ^ 0x60 ;
+        if ( pVBInfo->ModeType != ModeEGA )
+        {
+            data = data ^ 0xA0 ;
+        }
+    }
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x21 , 0x1F , data ) ;
+
+    XGI_SetVCLKState( HwDeviceExtension , ModeNo , RefreshRateTableIndex, pVBInfo) ;
+
+    /* if(modeflag&HalfDCLK)//030305 fix lowresolution bug */
+    /* if(XGINew_IF_DEF_NEW_LOWRES) */
+    /* XGI_VesaLowResolution(ModeNo,ModeIdIndex);//030305 fix lowresolution bug */
+
+    data=XGINew_GetReg1( pVBInfo->P3d4 , 0x31 ) ;
+
+    if (HwDeviceExtension->jChipType == XG27 )
+    {
+    	if ( data & 0x40 )
+    	    data = 0x2c ;
+    	else
+    	    data = 0x6c ;
+    	XGINew_SetReg1( pVBInfo->P3d4 , 0x52 , data ) ;
+    	XGINew_SetRegOR( pVBInfo->P3d4 , 0x51 , 0x10 ) ;
+    }
+    else
+    if (HwDeviceExtension->jChipType >= XG20 )
+    {
+    	if ( data & 0x40 )
+    	    data = 0x33 ;
+    	else
+    	    data = 0x73 ;
+    	XGINew_SetReg1( pVBInfo->P3d4 , 0x52 , data ) ;
+    	XGINew_SetReg1( pVBInfo->P3d4 , 0x51 , 0x02 ) ;
+    }
+    else
+    {
+    if ( data & 0x40 )
+        data = 0x2c ;
+    else
+        data = 0x6c ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x52 , data ) ;
+    }
+
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetVCLKState */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetVCLKState(  PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT ModeNo , USHORT RefreshRateTableIndex,PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT data ,
+           data2 = 0 ;
+    SHORT  VCLK ;
+
+    UCHAR  index ;
+
+    if ( ModeNo <= 0x13 )
+        VCLK = 0 ;
+    else
+    {
+        index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRTVCLK ;
+        index &= IndexMask ;
+        VCLK = pVBInfo->VCLKData[ index ].CLOCK ;
+    }
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x32 ) ;
+    data &= 0xf3 ;
+    if ( VCLK >= 200 )
+        data |= 0x0c ;	/* VCLK > 200 */
+
+    if ( HwDeviceExtension->jChipType >= XG20 )
+        data &= ~0x04 ; /* 2 pixel mode */
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x32 , data ) ;
+
+    if ( HwDeviceExtension->jChipType < XG20 )
+    {
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x1F ) ;
+    data &= 0xE7 ;
+    if ( VCLK < 200 )
+        data |= 0x10 ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1F , data ) ;
+    }
+
+/*  Jong for Adavantech LCD ripple issue
+    if ( ( VCLK >= 0 ) && ( VCLK < 135 ) )
+        data2 = 0x03 ;
+    else if ( ( VCLK >= 135 ) && ( VCLK < 160 ) )
+        data2 = 0x02 ;
+    else if ( ( VCLK >= 160 ) && ( VCLK < 260 ) )
+        data2 = 0x01 ;
+    else if ( VCLK > 260 )
+          data2 = 0x00 ;
+*/
+    data2 = 0x00 ;
+
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x07 , 0xFC , data2 ) ;
+    if (HwDeviceExtension->jChipType >= XG27 )
+    {
+      XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x40 , 0xFC , data2&0x03 ) ;
+    }
+    
+
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_VesaLowResolution */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+/*void XGI_VesaLowResolution( USHORT ModeNo , USHORT ModeIdIndex ,PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT modeflag;
+
+    if ( ModeNo > 0x13 )
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+    else
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+
+    if ( ModeNo > 0x13 )
+    {
+        if ( modeflag & DoubleScanMode )
+        {
+            if ( modeflag & HalfDCLK )
+            {
+                if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+                {
+                    if ( !( pVBInfo->VBInfo & SetCRT2ToRAMDAC ) )
+                    {
+                        if ( pVBInfo->VBInfo & SetInSlaveMode )
+                        {
+                            XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x01 , 0xf7 , 0x00 ) ;
+                            XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0f , 0x7f , 0x00 ) ;
+                            return ;
+                        }
+                    }
+                }
+                XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0f , 0xff , 0x80 ) ;
+                XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x01 , 0xf7 , 0x00 ) ;
+                return ;
+            }
+        }
+    }
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0f , 0x7f , 0x00 ) ;
+}
+*/
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_LoadDAC */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_LoadDAC( USHORT ModeNo , USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT data , data2 , time ,
+           i  , j , k , m , n , o ,
+           si , di , bx , dl , al , ah , dh ,
+           *table = NULL ;
+
+    if ( ModeNo <= 0x13 )
+        data = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+    else
+        data = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+
+    data &= DACInfoFlag ;
+    time = 64 ;
+
+    if ( data == 0x00 )
+        table = XGINew_MDA_DAC ;
+    else if ( data == 0x08 )
+        table = XGINew_CGA_DAC ;
+    else if ( data == 0x10 )
+        table = XGINew_EGA_DAC ;
+    else if ( data == 0x18 )
+    {
+        time = 256 ;
+        table = XGINew_VGA_DAC ;
+    }
+
+    if ( time == 256 )
+        j = 16 ;
+    else
+        j = time ;
+
+    XGINew_SetReg3( pVBInfo->P3c6 , 0xFF ) ;
+    XGINew_SetReg3( pVBInfo->P3c8 , 0x00 ) ;
+
+    for( i = 0 ; i < j ; i++ )
+    {
+        data = table[ i ] ;
+
+        for( k = 0 ; k < 3 ; k++ )
+        {
+            data2 = 0 ;
+
+            if ( data & 0x01 )
+                data2 = 0x2A ;
+
+            if ( data & 0x02 )
+                data2 += 0x15 ;
+
+            XGINew_SetReg3( pVBInfo->P3c9 , data2 ) ;
+            data = data >> 2 ;
+        }
+    }
+
+    if ( time == 256 )
+    {
+        for( i = 16 ; i < 32 ; i++ )
+        {
+            data = table[ i ] ;
+
+            for( k = 0 ; k < 3 ; k++ )
+                XGINew_SetReg3( pVBInfo->P3c9 , data ) ;
+        }
+
+        si = 32 ;
+
+        for( m = 0 ; m < 9 ; m++ )
+        {
+            di = si ;
+            bx = si + 0x04 ;
+            dl = 0 ;
+
+            for( n = 0 ; n < 3 ; n++ )
+            {
+                for( o = 0 ; o < 5 ; o++ )
+                {
+                    dh = table[ si ] ;
+                    ah = table[ di ] ;
+                    al = table[ bx ] ;
+                    si++ ;
+                    XGI_WriteDAC( dl , ah , al , dh, pVBInfo ) ;
+                }
+
+                si -= 2 ;
+
+                for( o = 0 ; o < 3 ; o++ )
+                {
+                    dh = table[ bx ] ;
+                    ah = table[ di ] ;
+                    al = table[ si ] ;
+                    si-- ;
+                    XGI_WriteDAC( dl , ah , al , dh, pVBInfo ) ;
+                }
+
+                dl++ ;
+            }
+
+            si += 5 ;
+        }
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_WriteDAC */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_WriteDAC( USHORT dl , USHORT ah , USHORT al , USHORT dh,PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT temp , bh , bl ;
+
+    bh = ah ;
+    bl = al ;
+
+    if ( dl != 0 )
+    {
+        temp = bh ;
+        bh = dh ;
+        dh = temp ;
+        if ( dl == 1 )
+        {
+            temp = bl ;
+            bl = dh ;
+            dh = temp ;
+        }
+        else
+        {
+            temp = bl ;
+            bl = bh ;
+            bh = temp ;
+        }
+    }
+    XGINew_SetReg3( pVBInfo->P3c9 , ( USHORT )dh ) ;
+    XGINew_SetReg3( pVBInfo->P3c9 , ( USHORT )bh ) ;
+    XGINew_SetReg3( pVBInfo->P3c9 , ( USHORT )bl ) ;
+}
+
+#if 0
+/* --------------------------------------------------------------------- */
+/* Function : XGI_ClearBuffer */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_ClearBuffer( PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT ModeNo, PVB_DEVICE_INFO  pVBInfo)
+{
+    PVOID VideoMemoryAddress = ( PVOID )HwDeviceExtension->pjVideoMemoryAddress ;
+    ULONG AdapterMemorySize  = ( ULONG )HwDeviceExtension->ulVideoMemorySize ;
+    PUSHORT pBuffer ;
+#ifndef LINUX_XF86
+    int i ;
+#endif
+
+    if ( pVBInfo->ModeType >= ModeEGA )
+    {
+        if ( ModeNo > 0x13 )
+        {
+            AdapterMemorySize = 0x40000 ;	/* clear 256k */
+            /* GetDRAMSize( HwDeviceExtension ) ; */
+            XGI_SetMemory( VideoMemoryAddress , AdapterMemorySize , 0 ) ;
+        }
+        else
+        {
+/*
+            pBuffer = VideoMemoryAddress ;
+            for( i = 0 ; i < 0x4000 ; i++ )
+                pBuffer[ i ] = 0x0000 ;
+*/
+        }
+    }
+    else
+    {
+        pBuffer = VideoMemoryAddress ;
+        if ( pVBInfo->ModeType < ModeCGA )
+        {
+/*
+            for ( i = 0 ; i < 0x4000 ; i++ )
+                pBuffer[ i ] = 0x0720 ;
+*/
+        }
+        else
+            XGI_SetMemory( VideoMemoryAddress , 0x8000 , 0 ) ;
+    }
+}
+
+#endif
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetLCDAGroup */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetLCDAGroup( USHORT ModeNo , USHORT ModeIdIndex , PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO  pVBInfo )
+{
+    USHORT RefreshRateTableIndex ;
+    /* USHORT temp ; */
+
+    /* pVBInfo->SelectCRT2Rate = 0 ; */
+
+    pVBInfo->SetFlag |= ProgrammingCRT2 ;
+    RefreshRateTableIndex = XGI_GetRatePtrCRT2( HwDeviceExtension, ModeNo , ModeIdIndex, pVBInfo ) ;
+    XGI_GetLVDSResInfo(  ModeNo , ModeIdIndex,  pVBInfo ) ;
+    XGI_GetLVDSData( ModeNo , ModeIdIndex , RefreshRateTableIndex,  pVBInfo);
+    XGI_ModCRT1Regs( ModeNo , ModeIdIndex , RefreshRateTableIndex , HwDeviceExtension, pVBInfo ) ;
+    XGI_SetLVDSRegs( ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+    XGI_SetCRT2ECLK( ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetLVDSResInfo */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetLVDSResInfo( USHORT ModeNo , USHORT ModeIdIndex,PVB_DEVICE_INFO  pVBInfo )
+{
+    USHORT resindex , xres , yres , modeflag ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ResInfo ;	/* si+St_ResInfo */
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;	/* si+Ext_ResInfo */
+    }
+
+
+    /* if ( ModeNo > 0x13 ) */
+    /* modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ; */
+    /* else */
+    /* modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ; */
+
+    if ( ModeNo <= 0x13 )
+    {
+        resindex = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ResInfo ;	/* si+St_ResInfo */
+    }
+    else
+    {
+        resindex = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;	/* si+Ext_ResInfo */
+    }
+
+    /* resindex = XGI_GetResInfo( ModeNo , ModeIdIndex, pVBInfo ) ; */
+
+    if ( ModeNo <= 0x13 )
+    {
+        xres = pVBInfo->StResInfo[ resindex ].HTotal ;
+        yres = pVBInfo->StResInfo[ resindex ].VTotal ;
+    }
+    else
+    {
+        xres = pVBInfo->ModeResInfo[ resindex ].HTotal ;
+        yres = pVBInfo->ModeResInfo[ resindex ].VTotal ;
+    }
+    if ( ModeNo > 0x13 )
+    {
+        if ( modeflag & HalfDCLK )
+            xres = xres << 1 ;
+
+        if ( modeflag & DoubleScanMode )
+            yres = yres << 1 ;
+    }
+    /* if ( modeflag & Charx8Dot ) */
+    /* { */
+
+    if ( xres == 720 )
+        xres = 640 ;
+
+    /* } */
+    pVBInfo->VGAHDE = xres ;
+    pVBInfo->HDE = xres ;
+    pVBInfo->VGAVDE = yres ;
+    pVBInfo->VDE = yres ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetLVDSData */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetLVDSData(  USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO  pVBInfo )
+{
+    USHORT tempbx ;
+    XGI330_LVDSDataStruct *LCDPtr = NULL ;
+    XGI330_CHTVDataStruct  *TVPtr = NULL ;
+
+    tempbx = 2 ;
+
+    if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+    {
+        LCDPtr = ( XGI330_LVDSDataStruct * )XGI_GetLcdPtr( tempbx, ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo) ;
+        pVBInfo->VGAHT = LCDPtr->VGAHT ;
+        pVBInfo->VGAVT = LCDPtr->VGAVT ;
+        pVBInfo->HT = LCDPtr->LCDHT ;
+        pVBInfo->VT = LCDPtr->LCDVT ;
+    }
+    if ( pVBInfo->IF_DEF_CH7017 == 1 )
+    {
+        if ( pVBInfo->VBInfo & SetCRT2ToTV )
+        {
+            TVPtr = ( XGI330_CHTVDataStruct * )XGI_GetTVPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+            pVBInfo->VGAHT = TVPtr->VGAHT ;
+            pVBInfo->VGAVT = TVPtr->VGAVT ;
+            pVBInfo->HT = TVPtr->LCDHT ;
+            pVBInfo->VT = TVPtr->LCDVT ;
+        }
+    }
+
+    if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+    {
+        if ( !( pVBInfo->LCDInfo & ( SetLCDtoNonExpanding | EnableScalingLCD ) ) )
+        {
+            if ( ( pVBInfo->LCDResInfo == Panel1024x768 ) || ( pVBInfo->LCDResInfo == Panel1024x768x75 ) )
+            {
+                pVBInfo->HDE = 1024 ;
+                pVBInfo->VDE = 768 ;
+            }
+            else if ( ( pVBInfo->LCDResInfo == Panel1280x1024 ) || ( pVBInfo->LCDResInfo == Panel1280x1024x75 ) )
+            {
+                pVBInfo->HDE = 1280 ;
+                pVBInfo->VDE = 1024 ;
+            }
+            else if ( pVBInfo->LCDResInfo == Panel1400x1050 )
+            {
+                pVBInfo->HDE = 1400 ;
+                pVBInfo->VDE = 1050 ;
+            }
+            else
+            {
+                pVBInfo->HDE = 1600 ;
+                pVBInfo->VDE = 1200 ;
+            }
+        }
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_ModCRT1Regs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_ModCRT1Regs( USHORT ModeNo , USHORT ModeIdIndex ,
+                        USHORT RefreshRateTableIndex , PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO  pVBInfo )
+{
+    UCHAR index ;
+    USHORT tempbx , i ;
+    XGI_LVDSCRT1HDataStruct  *LCDPtr = NULL ;
+    XGI_LVDSCRT1VDataStruct  *LCDPtr1 =NULL ;
+    /* XGI330_CHTVDataStruct *TVPtr = NULL ; */
+    XGI_CH7007TV_TimingHStruct *CH7007TV_TimingHPtr;
+    XGI_CH7007TV_TimingVStruct *CH7007TV_TimingVPtr;
+
+    if( ModeNo <= 0x13 )
+        index = pVBInfo->SModeIDTable[ ModeIdIndex ].St_CRT2CRTC ;
+    else
+        index = pVBInfo->RefIndex[RefreshRateTableIndex].Ext_CRT2CRTC;
+
+    index= index & IndexMask ;
+
+    if ( ( pVBInfo->IF_DEF_ScaleLCD == 0 ) || ( ( pVBInfo->IF_DEF_ScaleLCD == 1 ) && ( !( pVBInfo->LCDInfo & EnableScalingLCD ) ) ) )
+    {
+        tempbx = 0 ;
+
+        if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+        {
+            LCDPtr = ( XGI_LVDSCRT1HDataStruct * )XGI_GetLcdPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+
+            for( i = 0 ; i < 8 ; i++ )
+                pVBInfo->TimingH[ 0 ].data[ i ] = LCDPtr[ 0 ].Reg[ i ] ;
+        }
+
+        if ( pVBInfo->IF_DEF_CH7007 == 1 )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToTV )
+            { 
+                CH7007TV_TimingHPtr = ( XGI_CH7007TV_TimingHStruct *)XGI_GetTVPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+
+                for( i = 0 ; i < 8 ; i++ )
+                    pVBInfo->TimingH[ 0 ].data[ i ] = CH7007TV_TimingHPtr[ 0 ].data[ i ] ;
+            }
+        } 
+
+        /* if ( pVBInfo->IF_DEF_CH7017 == 1 )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToTV )
+                TVPtr = ( XGI330_CHTVDataStruct *)XGI_GetTVPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+        } */
+
+        XGI_SetCRT1Timing_H(pVBInfo,HwDeviceExtension) ;
+
+        if ( pVBInfo->IF_DEF_CH7007 == 1 )
+        {
+    	    XGINew_SetReg1( pVBInfo->P3c4 , 0x2E , CH7007TV_TimingHPtr[ 0 ].data[ 8 ] ) ;
+    	    XGINew_SetReg1( pVBInfo->P3c4 , 0x2F , CH7007TV_TimingHPtr[ 0 ].data[ 9 ] ) ;
+        }
+
+        tempbx = 1 ;
+
+        if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+        {
+            LCDPtr1 = ( XGI_LVDSCRT1VDataStruct * )XGI_GetLcdPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+            for( i = 0 ; i < 7 ; i++ )
+                pVBInfo->TimingV[ 0 ].data[ i ] = LCDPtr1[ 0 ].Reg[ i ] ;
+        }
+
+        if ( pVBInfo->IF_DEF_CH7007 == 1 )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToTV )
+            { 
+                CH7007TV_TimingVPtr = ( XGI_CH7007TV_TimingVStruct *)XGI_GetTVPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+
+                for( i = 0 ; i < 7 ; i++ )
+                    pVBInfo->TimingV[ 0 ].data[ i ] = CH7007TV_TimingVPtr[ 0 ].data[ i ] ;
+            }
+        } 
+        /* if ( pVBInfo->IF_DEF_CH7017 == 1 )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToTV )
+                TVPtr = ( XGI330_CHTVDataStruct *)XGI_GetTVPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+        } */
+
+        XGI_SetCRT1Timing_V( ModeIdIndex , ModeNo , pVBInfo) ;
+
+        if ( pVBInfo->IF_DEF_CH7007 == 1 )
+        {
+    	    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x33 , ~0x01 , CH7007TV_TimingVPtr[ 0 ].data[ 7 ]&0x01 ) ;
+    	    XGINew_SetReg1( pVBInfo->P3c4 , 0x34 , CH7007TV_TimingVPtr[ 0 ].data[8 ] ) ;
+    	    XGINew_SetReg1( pVBInfo->P3c4 , 0x3F , CH7007TV_TimingVPtr[ 0 ].data[9 ] ) ;
+
+        }
+    }
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetLVDSRegs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetLVDSRegs( USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO  pVBInfo )
+{
+    USHORT tempbx , tempax , tempcx , tempdx , push1 , push2 , modeflag ;
+    unsigned long temp , temp1 , temp2 , temp3 , push3 ;
+    XGI330_LCDDataDesStruct  *LCDPtr = NULL ;
+    XGI330_LCDDataDesStruct2  *LCDPtr1 = NULL ;
+
+    if ( ModeNo > 0x13 )
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+    else
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+
+    if ( !( pVBInfo->SetFlag & Win9xDOSMode ) )
+    {
+        if ( ( pVBInfo->IF_DEF_CH7017 == 0 ) || ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) ) )
+        {
+            if ( pVBInfo->IF_DEF_OEMUtil == 1 )
+            {
+    	        tempbx = 8 ;
+    	        LCDPtr = ( XGI330_LCDDataDesStruct * )XGI_GetLcdPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+            }
+
+            if ( ( pVBInfo->IF_DEF_OEMUtil == 0 ) || ( LCDPtr == 0 ) )
+            {
+                tempbx = 3 ;
+                if ( pVBInfo->LCDInfo & EnableScalingLCD )
+                    LCDPtr1 = ( XGI330_LCDDataDesStruct2 * )XGI_GetLcdPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+                else
+                    LCDPtr = ( XGI330_LCDDataDesStruct * )XGI_GetLcdPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+            }
+
+            XGI_GetLCDSync( &tempax , &tempbx ,pVBInfo) ;
+            push1 = tempbx ;
+            push2 = tempax ;
+
+            /* GetLCDResInfo */
+            if ( ( pVBInfo->LCDResInfo == Panel1024x768 ) || ( pVBInfo->LCDResInfo == Panel1024x768x75 ) )
+            {
+                tempax = 1024 ;
+                tempbx = 768 ;
+            }
+            else if ( ( pVBInfo->LCDResInfo == Panel1280x1024 ) || ( pVBInfo->LCDResInfo == Panel1280x1024x75 ) )
+            {
+                tempax = 1280 ;
+                tempbx = 1024 ;
+            }
+            else if ( pVBInfo->LCDResInfo == Panel1400x1050 )
+            {
+                tempax = 1400 ;
+                tempbx = 1050 ;
+            }
+            else
+            {
+                tempax = 1600 ;
+                tempbx = 1200 ;
+            }
+
+            if ( pVBInfo->LCDInfo & SetLCDtoNonExpanding )
+            {
+                pVBInfo->HDE=tempax;
+                pVBInfo->VDE=tempbx;
+                pVBInfo->VGAHDE=tempax;
+                pVBInfo->VGAVDE=tempbx;
+            }
+
+            if ( ( pVBInfo->IF_DEF_ScaleLCD == 1 ) && ( pVBInfo->LCDInfo & EnableScalingLCD ) )
+            {
+                tempax=pVBInfo->HDE;
+                tempbx=pVBInfo->VDE;
+            }
+
+            tempax = pVBInfo->HT ;
+
+            if ( pVBInfo->LCDInfo & EnableScalingLCD )
+                tempbx = LCDPtr1->LCDHDES ;
+            else
+                tempbx = LCDPtr->LCDHDES ;
+
+            tempcx = pVBInfo->HDE ;
+            tempbx = tempbx & 0x0fff ;
+            tempcx += tempbx ;
+
+            if ( tempcx >= tempax )
+                tempcx -= tempax ;
+
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x1A , tempbx & 0x07 ) ;
+
+            tempcx = tempcx >> 3 ;
+            tempbx = tempbx >> 3 ;
+
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x16 , ( USHORT )( tempbx & 0xff ) ) ;
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x17 , ( USHORT )( tempcx & 0xff ) ) ;
+
+            tempax = pVBInfo->HT ;
+
+            if ( pVBInfo->LCDInfo & EnableScalingLCD )
+                tempbx = LCDPtr1->LCDHRS ;
+            else
+                tempbx = LCDPtr->LCDHRS ;
+
+            tempcx = push2 ;
+
+            if ( pVBInfo->LCDInfo & EnableScalingLCD )
+                tempcx = LCDPtr1->LCDHSync ;
+
+            tempcx += tempbx ;
+
+            if ( tempcx >= tempax )
+                tempcx -= tempax ;
+
+            tempax = tempbx & 0x07 ;
+            tempax = tempax >> 5 ;
+            tempcx = tempcx >> 3 ;
+            tempbx = tempbx >> 3 ;
+
+            tempcx &= 0x1f ;
+            tempax |= tempcx ;
+
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x15 , tempax ) ;
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x14 , ( USHORT )( tempbx & 0xff ) ) ;
+
+            tempax = pVBInfo->VT ;
+            if ( pVBInfo->LCDInfo & EnableScalingLCD )
+                tempbx = LCDPtr1->LCDVDES ;
+            else
+                tempbx = LCDPtr->LCDVDES ;
+            tempcx = pVBInfo->VDE ;
+
+            tempbx = tempbx & 0x0fff ;
+            tempcx += tempbx ;
+            if ( tempcx >= tempax )
+                tempcx -= tempax ;
+
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x1b , ( USHORT )( tempbx & 0xff ) ) ;
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x1c , ( USHORT )( tempcx & 0xff ) ) ;
+
+            tempbx = ( tempbx >> 8 ) & 0x07 ;
+            tempcx = ( tempcx >> 8 ) & 0x07 ;
+
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x1d , ( USHORT )( ( tempcx << 3 ) | tempbx ) ) ;
+
+            tempax = pVBInfo->VT ;
+            if ( pVBInfo->LCDInfo & EnableScalingLCD )
+                tempbx = LCDPtr1->LCDVRS ;
+            else
+                tempbx = LCDPtr->LCDVRS ;
+
+            /* tempbx = tempbx >> 4 ; */
+              tempcx = push1 ;
+
+            if ( pVBInfo->LCDInfo & EnableScalingLCD )
+                tempcx = LCDPtr1->LCDVSync ;
+
+            tempcx += tempbx ;
+            if ( tempcx >= tempax )
+                tempcx -= tempax ;
+
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x18 , ( USHORT )( tempbx & 0xff ) ) ;
+            XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x19 , ~0x0f , ( USHORT )( tempcx & 0x0f ) ) ;
+
+            tempax = ( ( tempbx >> 8 ) & 0x07 ) << 3 ;
+
+            tempbx = pVBInfo->VGAVDE ;
+            if ( tempbx != pVBInfo->VDE )
+                tempax |= 0x40 ;
+
+            if ( pVBInfo->LCDInfo & EnableLVDSDDA )
+                tempax |= 0x40 ;
+
+            XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x1a , 0x07 , tempax ) ;
+
+            tempcx = pVBInfo->VGAVT ;
+            tempbx = pVBInfo->VDE ;
+            tempax = pVBInfo->VGAVDE ;
+            tempcx -= tempax ;
+
+            temp = tempax ;            /* 0430 ylshieh */
+            temp1 = ( temp << 18 ) / tempbx ;
+
+            tempdx = ( USHORT )( ( temp << 18 ) % tempbx ) ;
+
+            if ( tempdx != 0 )
+            temp1 += 1 ;
+
+            temp2 = temp1 ;
+            push3 = temp2 ;
+
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x37 , ( USHORT )( temp2 & 0xff ) ) ;
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x36 , ( USHORT )( ( temp2 >> 8 ) & 0xff ) ) ;
+
+            tempbx = ( USHORT )( temp2 >> 16 ) ;
+            tempax = tempbx & 0x03 ;
+
+            tempbx = pVBInfo->VGAVDE ;
+            if ( tempbx == pVBInfo->VDE )
+                tempax |= 0x04 ;
+
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x35 , tempax ) ;
+
+            if ( pVBInfo->VBType & VB_XGI301C )
+            {
+                temp2 = push3 ;
+      	        XGINew_SetReg1( pVBInfo->Part4Port , 0x3c , ( USHORT )( temp2 & 0xff ) ) ;
+      	        XGINew_SetReg1( pVBInfo->Part4Port , 0x3b , ( USHORT )( ( temp2 >> 8 ) & 0xff ) ) ;
+      	        tempbx = ( USHORT )( temp2 >> 16 ) ;
+      	        XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x3a , ~0xc0 , ( USHORT )( ( tempbx & 0xff ) << 6 ) ) ;
+
+                tempcx = pVBInfo->VGAVDE ;
+                if ( tempcx == pVBInfo->VDE )
+                    XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x30 , ~0x0c , 0x00 ) ;
+                else
+                    XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x30 , ~0x0c , 0x08 ) ;
+            }
+
+            tempcx = pVBInfo->VGAHDE ;
+            tempbx = pVBInfo->HDE ;
+
+            temp1 = tempcx << 16 ;
+
+            tempax = ( USHORT )( temp1 / tempbx ) ;
+
+            if ( ( tempbx & 0xffff ) == ( tempcx & 0xffff ) )
+                tempax = 65535 ;
+
+            temp3 = tempax ;
+            temp1 = pVBInfo->VGAHDE << 16 ;
+
+            temp1 /= temp3 ;
+            temp3 = temp3 << 16 ;
+            temp1 -= 1 ;
+
+            temp3 = ( temp3 & 0xffff0000 ) + ( temp1 & 0xffff ) ;
+
+            tempax = ( USHORT )( temp3 & 0xff ) ;
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x1f , tempax ) ;
+
+            temp1 = pVBInfo->VGAVDE << 18 ;
+            temp1 = temp1 / push3 ;
+            tempbx = ( USHORT )( temp1 & 0xffff ) ;
+
+            if ( pVBInfo->LCDResInfo == Panel1024x768 )
+                tempbx -= 1 ;
+
+            tempax = ( ( tempbx >> 8 ) & 0xff ) << 3 ;
+            tempax |= ( USHORT )( ( temp3 >> 8 ) & 0x07 ) ;
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x20 , ( USHORT )( tempax & 0xff ) ) ;
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x21 , ( USHORT )( tempbx & 0xff ) ) ;
+
+            temp3 = temp3 >> 16 ;
+
+            if ( modeflag & HalfDCLK )
+                temp3 = temp3 >> 1 ;
+
+            XGINew_SetReg1(pVBInfo->Part1Port , 0x22 , ( USHORT )( ( temp3 >> 8 ) & 0xff ) ) ;
+            XGINew_SetReg1(pVBInfo->Part1Port , 0x23 , ( USHORT )( temp3 & 0xff ) ) ;
+        }
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT2ECLK */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT2ECLK( USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO  pVBInfo )
+{
+    UCHAR di_0 , di_1 , tempal ;
+    int i ;
+
+    tempal = XGI_GetVCLKPtr( RefreshRateTableIndex , ModeNo , ModeIdIndex, pVBInfo ) ;
+    XGI_GetVCLKLen( tempal , &di_0 , &di_1, pVBInfo ) ;
+    XGI_GetLCDVCLKPtr( &di_0 , &di_1, pVBInfo ) ;
+
+    for( i = 0 ; i < 4 ; i++ )
+    {
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x31 , ~0x30 , ( USHORT )( 0x10 * i ) ) ;
+        if ( pVBInfo->IF_DEF_CH7007 == 1 )
+        {
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x2b , di_0 ) ;
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x2c , di_1 ) ;
+        }
+        else if ( ( !( pVBInfo->VBInfo & SetCRT2ToLCDA ) ) && ( !( pVBInfo->VBInfo & SetInSlaveMode ) ) )
+        {
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x2e , di_0 ) ;
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x2f , di_1 ) ;
+        }
+        else
+        {
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x2b , di_0 ) ;
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x2c , di_1 ) ;
+        }
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_UpdateModeInfo */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_UpdateModeInfo( PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO  pVBInfo )
+{
+    USHORT tempcl ,
+           tempch ,
+           temp ,
+           tempbl ,
+           tempax ;
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        tempcl = 0 ;
+        tempch = 0 ;
+        temp = XGINew_GetReg1( pVBInfo->P3c4 , 0x01 ) ;
+
+        if ( !( temp & 0x20 ) )
+        {
+            temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x17 ) ;
+            if ( temp & 0x80 )
+            {
+                if ( ( HwDeviceExtension->jChipType >= XG20 ) || ( HwDeviceExtension->jChipType >= XG40 ) )
+                    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x53 ) ;
+                else
+                    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x63 ) ;
+
+                if ( !( temp & 0x40 ) )
+                    tempcl |= ActiveCRT1 ;
+            }
+        }
+
+        temp = XGINew_GetReg1( pVBInfo->Part1Port , 0x2e ) ;
+        temp &= 0x0f ;
+
+        if ( !( temp == 0x08 ) )
+        {
+            tempax = XGINew_GetReg1( pVBInfo->Part1Port , 0x13 ) ;	/* Check ChannelA by Part1_13 [2003/10/03] */
+            if ( tempax & 0x04 )
+               	tempcl = tempcl | ActiveLCD ;
+
+            temp &= 0x05 ;
+
+            if ( !( tempcl & ActiveLCD ) )
+            	if ( temp == 0x01 )
+                    tempcl |= ActiveCRT2 ;
+
+            if ( temp == 0x04 )
+                tempcl |= ActiveLCD ;
+
+            if ( temp == 0x05 )
+            {
+                temp = XGINew_GetReg1( pVBInfo->Part2Port , 0x00 ) ;
+
+                if( !( temp & 0x08 ) )
+                    tempch |= ActiveAVideo ;
+
+                if ( !( temp & 0x04 ) )
+                    tempch |= ActiveSVideo ;
+
+                if ( temp & 0x02 )
+                    tempch |= ActiveSCART ;
+
+                if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+                {
+                    if ( temp & 0x01 )
+                        tempch |= ActiveHiTV ;
+                }
+
+                if ( pVBInfo->VBInfo & SetCRT2ToYPbPr )
+                {
+                    temp = XGINew_GetReg1( pVBInfo->Part2Port , 0x4d ) ;
+
+                    if ( temp & 0x10 )
+                        tempch |= ActiveYPbPr ;
+                }
+
+                if ( tempch != 0 )
+                    tempcl |= ActiveTV ;
+            }
+        }
+
+        temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x3d ) ;
+        if ( tempcl & ActiveLCD )
+        {
+            if ( ( pVBInfo->SetFlag & ReserveTVOption ) )
+            {
+                if ( temp & ActiveTV )
+                    tempcl |= ActiveTV ;
+            }
+        }
+        temp = tempcl ;
+        tempbl = ~ModeSwitchStatus ;
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x3d , tempbl , temp ) ;
+
+        if ( !( pVBInfo->SetFlag & ReserveTVOption ) )
+            XGINew_SetReg1( pVBInfo->P3d4 , 0x3e , tempch ) ;
+    }
+    else
+    {
+        return ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetVGAType */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetVGAType( PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO  pVBInfo)
+{
+#ifndef LINUX_XF86
+    USHORT tempbx ,
+           tempah ;
+#endif
+    /*
+    if ( HwDeviceExtension->jChipType >= XG20 )
+    {
+        pVBInfo->Set_VGAType = XG20;
+    }
+    else if ( HwDeviceExtension->jChipType >= XG40 )
+    {
+        pVBInfo->Set_VGAType = VGA_XGI340 ;
+    }
+    */
+    pVBInfo->Set_VGAType = HwDeviceExtension->jChipType;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetVBType */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetVBType(PVB_DEVICE_INFO  pVBInfo)
+{
+    USHORT flag , tempbx , tempah ;
+
+    if ( pVBInfo->IF_DEF_CH7007 == 1 )
+    {
+        pVBInfo->VBType = VB_CH7007 ;
+        return;
+    }
+    if ( pVBInfo->IF_DEF_LVDS == 0 )
+    {
+        tempbx = VB_XGI302B ;
+        flag = XGINew_GetReg1( pVBInfo->Part4Port , 0x00 ) ;
+        if ( flag != 0x02 )
+        {
+            tempbx = VB_XGI301 ;
+            flag = XGINew_GetReg1( pVBInfo->Part4Port , 0x01 ) ;
+            if ( flag >= 0xB0 )
+            {
+                tempbx = VB_XGI301B ;
+                if ( flag >= 0xC0 )
+                {
+                    tempbx = VB_XGI301C ;
+                    if ( flag >= 0xD0 )
+                    {
+                        tempbx = VB_XGI301LV ;
+                        if ( flag >= 0xE0 )
+                        {
+                            tempbx = VB_XGI302LV ;
+                            tempah = XGINew_GetReg1( pVBInfo->Part4Port , 0x39 ) ;
+                            if ( tempah != 0xFF )
+                                tempbx = VB_XGI301C ;
+                        }
+                    }
+                }
+
+                if ( tempbx & ( VB_XGI301B | VB_XGI302B ) )
+                {
+                    flag = XGINew_GetReg1( pVBInfo->Part4Port , 0x23 ) ;
+
+                    if ( !( flag & 0x02 ) )
+                        tempbx = tempbx | VB_NoLCD ;
+                }
+            }
+        }
+        pVBInfo->VBType = tempbx ;
+    }
+/*
+    else if ( pVBInfo->IF_DEF_CH7017 == 1 )
+        pVBInfo->VBType = VB_CH7017 ;
+    else  //LVDS
+        pVBInfo->VBType = VB_LVDS_NS ;
+*/
+
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetVBInfo */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetVBInfo( USHORT ModeNo , USHORT ModeIdIndex , PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO  pVBInfo )
+{
+    USHORT tempax ,
+           push ,
+           tempbx ,
+           temp ,
+           modeflag ;
+
+#ifndef LINUX_XF86
+    UCHAR OutputSelect = *pVBInfo->pOutputSelect ;
+#endif
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+    }
+
+    pVBInfo->SetFlag = 0 ;
+    pVBInfo->ModeType = modeflag & ModeInfoFlag ;
+    tempbx = 0 ;
+
+    if ( pVBInfo->VBType & 0xFFFF )
+    {
+        temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x30 ) ;           /* Check Display Device */
+        tempbx = tempbx | temp ;
+        temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x31 ) ;
+        push = temp ;
+        push = push << 8 ;
+        tempax = temp << 8 ;
+        tempbx = tempbx | tempax ;
+        temp = ( SetCRT2ToDualEdge | SetCRT2ToYPbPr | SetCRT2ToLCDA | SetInSlaveMode | DisableCRT2Display ) ;
+        temp = 0xFFFF ^ temp ;
+        tempbx &= temp ;
+
+        temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) ;
+
+        if ( pVBInfo->IF_DEF_LCDA == 1 )
+        {
+
+            if ( ( pVBInfo->Set_VGAType >= XG20 ) || ( pVBInfo->Set_VGAType >= XG40 ))
+            {
+                if ( pVBInfo->IF_DEF_LVDS == 0 )
+                {
+                    /* if ( ( pVBInfo->VBType & VB_XGI302B ) || ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) || ( pVBInfo->VBType & VB_XGI301C ) ) */
+                    if ( pVBInfo->VBType & ( VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+                    {
+                        if ( temp & EnableDualEdge )
+                        {
+                            tempbx |= SetCRT2ToDualEdge ;
+
+                            if ( temp & SetToLCDA )
+                                tempbx |= SetCRT2ToLCDA ;
+                        }
+                    }
+                }
+                else if ( pVBInfo->IF_DEF_CH7017 == 1 )
+                {
+                    if ( pVBInfo->VBType & VB_CH7017 )
+                    {
+                        if ( temp & EnableDualEdge )
+                        {
+                            tempbx |= SetCRT2ToDualEdge ;
+
+                            if ( temp & SetToLCDA )
+                                tempbx |= SetCRT2ToLCDA ;
+                        }
+                    }
+                }
+            }
+        }
+
+        if ( pVBInfo->IF_DEF_YPbPr == 1 )
+        {
+            if ( ( ( pVBInfo->IF_DEF_LVDS == 0 ) && ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) || ( pVBInfo->VBType & VB_XGI301C ) ) )
+            || ( ( pVBInfo->IF_DEF_CH7017 == 1 ) && ( pVBInfo->VBType&VB_CH7017 ) ) || ( (pVBInfo->IF_DEF_CH7007 == 1) && (pVBInfo->VBType&VB_CH7007) ) )    /* [Billy] 07/05/04 */
+            {
+                if ( temp & SetYPbPr )	/* temp = CR38 */
+                {
+                    if ( pVBInfo->IF_DEF_HiVision == 1 )
+                    {
+                        temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x35 ) ;  /* shampoo add for new scratch */
+                        temp &= YPbPrMode ;
+                        tempbx |= SetCRT2ToHiVisionTV ;
+
+                        if ( temp != YPbPrMode1080i ) {
+                            tempbx &= ( ~SetCRT2ToHiVisionTV ) ;
+                            tempbx |= SetCRT2ToYPbPr ; }
+                    }
+
+                    /* tempbx |= SetCRT2ToYPbPr ; */
+                }
+            }
+        }
+
+        tempax = push ;  /* restore CR31 */
+
+        if ( pVBInfo->IF_DEF_LVDS == 0 )
+        {
+            if ( pVBInfo->IF_DEF_YPbPr == 1 )
+            {
+                if ( pVBInfo->IF_DEF_HiVision == 1 )
+                    temp = 0x09FC ;
+                else
+                    temp = 0x097C ;
+            }
+            else
+            {
+                if ( pVBInfo->IF_DEF_HiVision == 1 )
+                    temp = 0x01FC ;
+                else
+                    temp = 0x017C ;
+            }
+        }
+        else	/* 3nd party chip */
+        {
+            if ( pVBInfo->IF_DEF_CH7017 == 1 )
+                temp = ( SetCRT2ToTV | SetCRT2ToLCD | SetCRT2ToLCDA ) ;
+            else if ( pVBInfo->IF_DEF_CH7007 == 1 )  /* [Billy] 07/05/03 */
+            {
+                temp = SetCRT2ToTV ;
+            }
+            else
+                temp = SetCRT2ToLCD ;
+        }
+
+        if ( !( tempbx & temp ) )
+        {
+            tempax |= DisableCRT2Display ;
+            tempbx = 0 ;
+        }
+
+        if ( pVBInfo->IF_DEF_LCDA == 1 )	/* Select Display Device */
+        {
+            if ( !( pVBInfo->VBType & VB_NoLCD ) )
+            {
+                if ( tempbx & SetCRT2ToLCDA )
+                {
+                    if ( tempbx & SetSimuScanMode )
+                        tempbx &= ( ~( SetCRT2ToLCD | SetCRT2ToRAMDAC | SwitchToCRT2 ) ) ;
+                    else
+                        tempbx &= ( ~( SetCRT2ToLCD | SetCRT2ToRAMDAC | SetCRT2ToTV | SwitchToCRT2 ) ) ;
+                }
+            }
+        }
+
+        /* shampoo add */
+        if ( !( tempbx & ( SwitchToCRT2 | SetSimuScanMode ) ) )	/* for driver abnormal */
+        {
+            if ( pVBInfo->IF_DEF_CRT2Monitor == 1 )
+            {
+                if ( tempbx & SetCRT2ToRAMDAC )
+                {
+                    tempbx &= ( 0xFF00 | SetCRT2ToRAMDAC | SwitchToCRT2 | SetSimuScanMode ) ;
+                    tempbx &= ( 0x00FF | ( ~SetCRT2ToYPbPr ) ) ;
+                }
+            }
+            else
+                tempbx &= ( ~( SetCRT2ToRAMDAC | SetCRT2ToLCD | SetCRT2ToTV ) ) ;
+        }
+
+        if ( !( pVBInfo->VBType & VB_NoLCD ) )
+        {
+            if ( tempbx & SetCRT2ToLCD )
+            {
+                tempbx &= ( 0xFF00 | SetCRT2ToLCD | SwitchToCRT2 | SetSimuScanMode ) ;
+                tempbx &= ( 0x00FF | ( ~SetCRT2ToYPbPr ) ) ;
+            }
+        }
+
+        if ( tempbx & SetCRT2ToSCART )
+        {
+            tempbx &= ( 0xFF00 | SetCRT2ToSCART | SwitchToCRT2 | SetSimuScanMode ) ;
+            tempbx &= ( 0x00FF | ( ~SetCRT2ToYPbPr ) ) ;
+        }
+
+        if ( pVBInfo->IF_DEF_YPbPr == 1 )
+        {
+            if ( tempbx & SetCRT2ToYPbPr )
+                tempbx &= ( 0xFF00 | SwitchToCRT2 | SetSimuScanMode ) ;
+        }
+
+        if ( pVBInfo->IF_DEF_HiVision == 1 )
+        {
+            if ( tempbx & SetCRT2ToHiVisionTV )
+                tempbx &= ( 0xFF00 | SetCRT2ToHiVisionTV | SwitchToCRT2 | SetSimuScanMode ) ;
+        }
+
+        if ( tempax & DisableCRT2Display )	/* Set Display Device Info */
+        {
+            if ( !( tempbx & ( SwitchToCRT2 | SetSimuScanMode ) ) )
+                tempbx = DisableCRT2Display ;
+        }
+
+        if ( !( tempbx & DisableCRT2Display ) )
+        {
+            if ( ( !( tempbx & DriverMode ) ) || ( !( modeflag & CRT2Mode ) ) )
+            {
+                if ( pVBInfo->IF_DEF_LCDA == 1 )
+      	        {
+                    if ( !( tempbx & SetCRT2ToLCDA ) )
+                        tempbx |= ( SetInSlaveMode | SetSimuScanMode ) ;
+                }
+
+                if ( pVBInfo->IF_DEF_VideoCapture == 1 )
+                {
+                    if ( ( ( HwDeviceExtension->jChipType == XG40 ) && ( pVBInfo->Set_VGAType == XG40 ) )
+                    || ( ( HwDeviceExtension->jChipType == XG41 ) && ( pVBInfo->Set_VGAType == XG41 ) )
+                    || ( ( HwDeviceExtension->jChipType == XG42 ) && ( pVBInfo->Set_VGAType == XG42 ) )
+                    || ( ( HwDeviceExtension->jChipType == XG45 ) && ( pVBInfo->Set_VGAType == XG45 ) ) )
+                    {
+                        if ( ModeNo <= 13 )
+                        {
+                            if ( !( tempbx & SetCRT2ToRAMDAC ) )	/*CRT2 not need to support*/
+                            {
+                                tempbx &= ( 0x00FF | ( ~SetInSlaveMode ) ) ;
+                                pVBInfo->SetFlag |= EnableVCMode ;
+                            }
+                        }
+                    }
+                }
+            }
+
+            /*LCD+TV can't support in slave mode (Force LCDA+TV->LCDB)*/
+            if ( ( tempbx & SetInSlaveMode ) && ( tempbx & SetCRT2ToLCDA ) )
+            {
+                tempbx ^= ( SetCRT2ToLCD | SetCRT2ToLCDA | SetCRT2ToDualEdge ) ;
+                pVBInfo->SetFlag |= ReserveTVOption ;
+            }
+        }
+    }
+
+    pVBInfo->VBInfo = tempbx ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetTVInfo */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetTVInfo( USHORT ModeNo , USHORT ModeIdIndex ,PVB_DEVICE_INFO  pVBInfo )
+{
+    USHORT temp ,
+           tempbx = 0 ,
+           resinfo = 0 ,
+           modeflag ,
+           index1 ;
+#ifndef LINUX_XF86
+    USHORT temp2 ,
+           OutputSelect = *pVBInfo->pOutputSelect ;
+#endif
+
+    tempbx = 0 ;
+    resinfo = 0 ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToTV )
+    {
+        if ( ModeNo <= 0x13 )
+        {
+            modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;	/* si+St_ModeFlag */
+            resinfo = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ResInfo ;	/* si+St_ResInfo */
+        }
+        else
+        {
+            modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+            resinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ; /* si+Ext_ResInfo */
+        }
+
+        if ( pVBInfo->VBInfo & SetCRT2ToTV )
+        {
+            temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x35 ) ;
+            tempbx = temp;
+            if ( tempbx & SetPALTV )
+            {
+                tempbx &= ( SetCHTVOverScan | SetPALMTV | SetPALNTV | SetPALTV ) ;
+                if ( tempbx & SetPALMTV )
+                    tempbx &= ~SetPALTV ; /* set to NTSC if PAL-M */
+            }
+            else
+                tempbx &= ( SetCHTVOverScan | SetNTSCJ | SetPALTV ) ;
+/*
+            if ( pVBInfo->IF_DEF_LVDS == 0 )
+            {
+                index1 = XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) ; //PAL-M/PAL-N Info
+                temp2 = ( index1 & 0xC0 ) >> 5 ; 	        //00:PAL, 01:PAL-M, 10:PAL-N
+                tempbx |= temp2 ;
+                if ( temp2 & 0x02 )          //PAL-M
+                    tempbx &= ( ~SetPALTV ) ;
+            }
+*/
+        }
+
+        if ( pVBInfo->IF_DEF_CH7017 == 1 )
+        {
+            tempbx = XGINew_GetReg1( pVBInfo->P3d4 , 0x35 ) ;
+
+            if ( tempbx & TVOverScan )
+                tempbx |= SetCHTVOverScan ;
+        }
+
+        if ( pVBInfo->IF_DEF_CH7007 == 1 ) /* [Billy] 07/05/04 */
+        {
+            tempbx = XGINew_GetReg1( pVBInfo->P3d4 , 0x35 ) ;
+
+            if ( tempbx & TVOverScan )
+            {
+                tempbx |= SetCHTVOverScan ;
+            }
+        }
+
+
+        if ( pVBInfo->IF_DEF_LVDS == 0 )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToSCART )
+                tempbx |= SetPALTV ;
+        }
+
+        if ( pVBInfo->IF_DEF_YPbPr == 1 )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToYPbPr )
+            {
+                index1 = XGINew_GetReg1( pVBInfo->P3d4 , 0x35 ) ;
+                index1 &= YPbPrMode ;
+
+                if ( index1 == YPbPrMode525i )
+                    tempbx |= SetYPbPrMode525i ;
+
+                if ( index1 == YPbPrMode525p )
+                    tempbx = tempbx | SetYPbPrMode525p;
+                if ( index1 == YPbPrMode750p)
+                    tempbx = tempbx | SetYPbPrMode750p;
+            }
+        }
+
+        if ( pVBInfo->IF_DEF_HiVision == 1 )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+            {
+                tempbx = tempbx | SetYPbPrMode1080i | SetPALTV ;
+            }
+        }
+
+        if ( pVBInfo->IF_DEF_LVDS == 0 )
+        {      /* shampoo */
+            if ( ( pVBInfo->VBInfo & SetInSlaveMode ) && ( !( pVBInfo->VBInfo & SetNotSimuMode ) ) )
+                tempbx |= TVSimuMode ;
+
+            if ( !( tempbx & SetPALTV ) && ( modeflag > 13 ) && ( resinfo == 8 ) ) /* NTSC 1024x768, */
+                tempbx |= NTSC1024x768 ;
+
+            tempbx |= RPLLDIV2XO ;
+
+            if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+            {
+                if ( pVBInfo->VBInfo & SetInSlaveMode )
+                    tempbx &=( ~RPLLDIV2XO ) ;
+            }
+            else
+            {
+                if ( tempbx & ( SetYPbPrMode525p | SetYPbPrMode750p ) )
+                    tempbx &= ( ~RPLLDIV2XO ) ;
+                else if ( !( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) ) )
+                {
+                    if ( tempbx & TVSimuMode )
+                        tempbx &= ( ~RPLLDIV2XO ) ;
+                }
+            }
+        }
+    }
+    pVBInfo->TVInfo = tempbx ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetLCDInfo */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_GetLCDInfo( USHORT ModeNo , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT temp ,
+           tempax ,
+           tempbx ,
+           modeflag ,
+           resinfo = 0 ,
+           LCDIdIndex ;
+
+    pVBInfo->LCDResInfo = 0 ;
+    pVBInfo->LCDTypeInfo = 0 ;
+    pVBInfo->LCDInfo = 0 ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;  /* si+St_ModeFlag // */
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+        resinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ; /* si+Ext_ResInfo// */
+    }
+
+    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x36 ) ; /* Get LCD Res.Info */
+    tempbx = temp & 0x0F ;
+
+    if ( tempbx == 0 )
+        tempbx = Panel1024x768 ; /* default */
+
+    /* LCD75 [2003/8/22] Vicent */
+    if ( ( tempbx == Panel1024x768 ) || ( tempbx == Panel1280x1024 ) )
+    {
+        if ( pVBInfo->VBInfo & DriverMode )
+        {
+            tempax = XGINew_GetReg1( pVBInfo->P3d4 , 0x33 ) ;
+            if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+                tempax &= 0x0F ;
+            else
+                tempax = tempax >> 4 ;
+
+            if ( ( resinfo == 6 ) || ( resinfo == 9 ) )
+            {
+                if ( tempax >= 3 )
+      	            tempbx |= PanelRef75Hz ;
+            }
+            else if ( ( resinfo == 7 ) || ( resinfo == 8 ) )
+            {
+      	        if ( tempax >= 4 )
+      	            tempbx |= PanelRef75Hz ;
+            }
+        }
+    }
+
+    pVBInfo->LCDResInfo = tempbx ;
+
+    /* End of LCD75 */
+
+    if( pVBInfo->IF_DEF_OEMUtil == 1 )
+    {
+        pVBInfo->LCDTypeInfo = ( temp & 0xf0 ) >> 4 ;
+    }
+
+    if ( !( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) ) )
+    {
+        return 0;
+    }
+
+    tempbx = 0 ;
+
+    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x37 ) ;
+
+    temp &= ( ScalingLCD | LCDNonExpanding | LCDSyncBit | SetPWDEnable ) ;
+
+    if ( ( pVBInfo->IF_DEF_ScaleLCD == 1 ) && ( temp & LCDNonExpanding ) )
+        temp &= ~EnableScalingLCD ;
+
+    tempbx |= temp ;
+
+    LCDIdIndex = XGI_GetLCDCapPtr1(pVBInfo) ;
+
+    tempax = pVBInfo->LCDCapList[ LCDIdIndex ].LCD_Capability ;
+
+    if ( pVBInfo->IF_DEF_LVDS == 0 )	/* shampoo */
+    {
+        if ( ( ( pVBInfo->VBType & VB_XGI302LV ) || ( pVBInfo->VBType & VB_XGI301C ) ) && ( tempax & LCDDualLink ) )
+        {
+            tempbx |= SetLCDDualLink ;
+        }
+    }
+
+    if ( pVBInfo->IF_DEF_CH7017 == 1 )
+    {
+        if ( tempax & LCDDualLink )
+        {
+            tempbx |= SetLCDDualLink ;
+        }
+    }
+
+    if ( pVBInfo->IF_DEF_LVDS == 0 )
+    {
+        if ( ( pVBInfo->LCDResInfo == Panel1400x1050 ) && ( pVBInfo->VBInfo & SetCRT2ToLCD ) && ( ModeNo > 0x13 ) && ( resinfo == 9 ) && ( !( tempbx & EnableScalingLCD ) ) )
+            tempbx |= SetLCDtoNonExpanding ;	/* set to center in 1280x1024 LCDB for Panel1400x1050 */
+    }
+
+/*
+    if ( tempax & LCDBToA )
+    {
+        tempbx |= SetLCDBToA ;
+    }
+*/
+
+    if ( pVBInfo->IF_DEF_ExpLink == 1 )
+    {
+        if ( modeflag & HalfDCLK )
+        {
+            /* if ( !( pVBInfo->LCDInfo&LCDNonExpanding ) ) */
+            if ( !( tempbx & SetLCDtoNonExpanding ) )
+            {
+                tempbx |= EnableLVDSDDA ;
+            }
+            else
+            {
+                if ( ModeNo > 0x13 )
+                {
+                    if ( pVBInfo->LCDResInfo == Panel1024x768 )
+                    {
+                        if ( resinfo == 4 )
+                        {                                /* 512x384  */
+                            tempbx |= EnableLVDSDDA ;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    if ( pVBInfo->VBInfo & SetInSlaveMode )
+    {
+        if ( pVBInfo->VBInfo & SetNotSimuMode )
+        {
+            tempbx |= LCDVESATiming ;
+        }
+    }
+    else
+    {
+        tempbx |= LCDVESATiming ;
+    }
+
+    pVBInfo->LCDInfo = tempbx ;
+
+    if ( pVBInfo->IF_DEF_PWD == 1 )
+    {
+        if ( pVBInfo->LCDInfo & SetPWDEnable )
+        {
+            if ( ( pVBInfo->VBType & VB_XGI302LV ) || ( pVBInfo->VBType & VB_XGI301C ) )
+            {
+                if ( !( tempax & PWDEnable ) )
+                {
+                    pVBInfo->LCDInfo &= ~SetPWDEnable ;
+                }
+            }
+        }
+    }
+
+    if ( pVBInfo->IF_DEF_LVDS == 0 )
+    {
+        if ( tempax & ( LockLCDBToA | StLCDBToA ) )
+        {
+            if ( pVBInfo->VBInfo & SetInSlaveMode )
+            {
+                if ( !( tempax & LockLCDBToA ) )
+                {
+                    if ( ModeNo <= 0x13 )
+                    {
+                        pVBInfo->VBInfo &= ~( SetSimuScanMode | SetInSlaveMode | SetCRT2ToLCD ) ;
+                        pVBInfo->VBInfo |= SetCRT2ToLCDA | SetCRT2ToDualEdge ;
+                    }
+                }
+            }
+        }
+    }
+
+/*
+    if ( pVBInfo->IF_DEF_LVDS == 0 )
+    {
+        if ( tempax & ( LockLCDBToA | StLCDBToA ) )
+        {
+            if ( pVBInfo->VBInfo & SetInSlaveMode )
+            {
+                if ( !( ( !( tempax & LockLCDBToA ) ) && ( ModeNo > 0x13 ) ) )
+                {
+                    pVBInfo->VBInfo&=~(SetSimuScanMode|SetInSlaveMode|SetCRT2ToLCD);
+                    pVBInfo->VBInfo|=SetCRT2ToLCDA|SetCRT2ToDualEdge;
+                }
+            }
+        }
+    }
+*/
+
+    return( 1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SearchModeID */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_SearchModeID( USHORT ModeNo , USHORT *ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+#ifndef LINUX_XF86
+    PUCHAR VGA_INFO = "\0x11" ;
+#endif
+
+#ifdef TC
+
+    if ( ModeNo <= 5 )
+        ModeNo |= 1 ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        /* for (*ModeIdIndex=0;*ModeIdIndex<sizeof(pVBInfo->SModeIDTable)/sizeof(XGI_StStruct);(*ModeIdIndex)++) */
+        for( *ModeIdIndex = 0 ; ; ( *ModeIdIndex )++ )
+        {
+            if ( pVBInfo->SModeIDTable[ *ModeIdIndex ].St_ModeID == ModeNo )
+                break ;
+            if ( pVBInfo->SModeIDTable[ *ModeIdIndex ].St_ModeID == 0xFF )
+                return( FALSE ) ;
+        }
+
+        VGA_INFO = ( PUCHAR )MK_FP( 0 , 0x489 ) ;
+
+        if ( ModeNo == 0x07 )
+        {
+            if ( ( *VGA_INFO & 0x10 ) != 0 )
+                ( *ModeIdIndex )++ ; /* 400 lines */
+            /* else 350 lines */
+        }
+
+        if ( ModeNo <= 3 )
+        {
+            if ( ( *VGA_INFO & 0x80 ) == 0 )
+            {
+                ( *ModeIdIndex )++ ;
+                if ( ( *VGA_INFO & 0x10 ) != 0 )
+                    ( *ModeIdIndex )++ ; /* 400 lines */
+                /* else 350 lines */
+            }
+            /* else 200 lines */
+        }
+    }
+    else
+    {
+        /* for (*ModeIdIndex=0;*ModeIdIndex<sizeof(pVBInfo->EModeIDTable)/sizeof(XGI_ExtStruct);(*ModeIdIndex)++) */
+        for( *ModeIdIndex = 0 ; ; ( *ModeIdIndex )++ )
+        {
+            if ( pVBInfo->EModeIDTable[ *ModeIdIndex ].Ext_ModeID == ModeNo )
+                break ;
+            if ( pVBInfo->EModeIDTable[ *ModeIdIndex ].Ext_ModeID == 0xFF )
+                return( FALSE ) ;
+        }
+    }
+
+
+#endif
+
+#ifdef WIN2000
+
+    if ( ModeNo <= 5 )
+        ModeNo |= 1 ;
+    if ( ModeNo <= 0x13 )
+    {
+        /* for (*ModeIdIndex=0;*ModeIdIndex<sizeof(pVBInfo->SModeIDTable)/sizeof(XGI_StStruct);(*ModeIdIndex)++) */
+        for( *ModeIdIndex = 0 ; ; ( *ModeIdIndex )++ )
+        {
+            if ( pVBInfo->SModeIDTable[ *ModeIdIndex ].St_ModeID == ModeNo )
+                break ;
+            if ( pVBInfo->SModeIDTable[ *ModeIdIndex ].St_ModeID == 0xFF )
+                return( FALSE ) ;
+        }
+
+        if ( ModeNo == 0x07 )
+            ( *ModeIdIndex )++ ; /* 400 lines */
+
+        if ( ModeNo <=3 )
+            ( *ModeIdIndex ) += 2 ; /* 400 lines */
+        /* else 350 lines */
+    }
+    else
+    {
+        /* for (*ModeIdIndex=0;*ModeIdIndex<sizeof(pVBInfo->EModeIDTable)/sizeof(XGI_ExtStruct);(*ModeIdIndex)++) */
+        for( *ModeIdIndex = 0 ; ; ( *ModeIdIndex )++ )
+        {
+            if ( pVBInfo->EModeIDTable[ *ModeIdIndex ].Ext_ModeID == ModeNo )
+                break ;
+            if ( pVBInfo->EModeIDTable[ *ModeIdIndex ].Ext_ModeID == 0xFF )
+                return( FALSE ) ;
+        }
+    }
+
+#endif
+
+#ifdef LINUX /* chiawen for linux solution */
+
+    if ( ModeNo <= 5 )
+        ModeNo |= 1 ;
+    if ( ModeNo <= 0x13 )
+    {
+        /* for (*ModeIdIndex=0;*ModeIdIndex<sizeof(pVBInfo->SModeIDTable)/sizeof(XGI_StStruct);(*ModeIdIndex)++) */
+        for( *ModeIdIndex = 0 ; ; ( *ModeIdIndex )++ )
+        {
+            if ( pVBInfo->SModeIDTable[ *ModeIdIndex ].St_ModeID == ModeNo )
+                break ;
+            if ( pVBInfo->SModeIDTable[ *ModeIdIndex ].St_ModeID == 0xFF )
+                return( FALSE ) ;
+        }
+
+        if ( ModeNo == 0x07 )
+            ( *ModeIdIndex )++ ; /* 400 lines */
+
+        if ( ModeNo <= 3 )
+            ( *ModeIdIndex ) += 2 ; /* 400 lines */
+        /* else 350 lines */
+    }
+    else
+    {
+        /* for (*ModeIdIndex=0;*ModeIdIndex<sizeof(pVBInfo->EModeIDTable)/sizeof(XGI_ExtStruct);(*ModeIdIndex)++) */
+        for( *ModeIdIndex = 0 ; ; ( *ModeIdIndex )++ )
+        {
+            if ( pVBInfo->EModeIDTable[ *ModeIdIndex ].Ext_ModeID == ModeNo )
+                break ;
+            if ( pVBInfo->EModeIDTable[ *ModeIdIndex ].Ext_ModeID == 0xFF )
+                return( FALSE ) ;
+        }
+    }
+
+#endif
+
+    return( TRUE ) ;
+}
+
+
+
+
+/* win2000 MM adapter not support standard mode! */
+
+/* --------------------------------------------------------------------- */
+/* Function : */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGINew_CheckMemorySize(PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT memorysize ,
+           modeflag ,
+           temp ,
+           temp1 ,
+           tmp ;
+
+/*  if ( ( HwDeviceExtension->jChipType == XGI_650 ) ||
+         ( HwDeviceExtension->jChipType == XGI_650M ) )
+    {
+        return( TRUE ) ;
+    } */
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+    }
+    else  {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+    }
+
+    /* ModeType = modeflag&ModeInfoFlag ; // Get mode type */
+
+    memorysize = modeflag & MemoryInfoFlag ;
+    memorysize = memorysize > MemorySizeShift ;
+    memorysize++ ;					/* Get memory size */
+
+    temp = XGINew_GetReg1( pVBInfo->P3c4 , 0x14 ) ;	/* Get DRAM Size */
+    tmp = temp ;
+
+    if ( HwDeviceExtension->jChipType == XG40 )
+    {
+        temp = 1 << ( ( temp & 0x0F0 ) >> 4 ) ;		/* memory size per channel SR14[7:4] */
+        if ( ( tmp & 0x0c ) == 0x0C )			/* Qual channels */
+        {
+            temp <<= 2 ;
+        }
+        else if ( ( tmp & 0x0c ) == 0x08 )		/* Dual channels */
+        {
+            temp <<= 1 ;
+        }
+    }
+    else if ( HwDeviceExtension->jChipType == XG42 )
+    {
+    	temp = 1 << ( ( temp & 0x0F0 ) >> 4 ) ;		/* memory size per channel SR14[7:4] */
+        if ( ( tmp & 0x04 ) == 0x04 )			/* Dual channels */
+        {
+            temp <<= 1 ;
+        }
+    }
+    else if ( HwDeviceExtension->jChipType == XG45 )
+    {
+    	temp = 1 << ( ( temp & 0x0F0 ) >> 4 ) ;		/* memory size per channel SR14[7:4] */
+    	if ( ( tmp & 0x0c ) == 0x0C )			/* Qual channels */
+        {
+            temp <<= 2 ;
+        }
+        else if ( ( tmp & 0x0c ) == 0x08 )		/* triple channels */
+        {
+            temp1 = temp ;
+            temp <<= 1 ;
+            temp += temp1 ;
+        }
+        else if ( ( tmp & 0x0c ) == 0x04 )		/* Dual channels */
+        {
+            temp <<= 1 ;
+        }
+    }
+    if ( temp < memorysize )
+        return( FALSE ) ;
+    else
+        return( TRUE ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_IsLowResolution */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+/*void XGINew_IsLowResolution( USHORT ModeNo , USHORT ModeIdIndex, BOOLEAN XGINew_CheckMemorySize(PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT data ;
+    USHORT ModeFlag ;
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x0F ) ;
+    data &= 0x7F ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x0F , data ) ;
+
+    if ( ModeNo > 0x13 )
+    {
+        ModeFlag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+        if ( ( ModeFlag & HalfDCLK ) && ( ModeFlag & DoubleScanMode ) )
+        {
+            data = XGINew_GetReg1( pVBInfo->P3c4 , 0x0F ) ;
+            data |= 0x80 ;
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x0F , data ) ;
+            data = XGINew_GetReg1( pVBInfo->P3c4 , 0x01 ) ;
+            data &= 0xF7 ;
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x01 , data ) ;
+        }
+    }
+}
+
+*/
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_DisplayOn */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_DisplayOn( PXGI_HW_DEVICE_INFO pXGIHWDE , PVB_DEVICE_INFO pVBInfo )
+{
+
+    XGINew_SetRegANDOR(pVBInfo->P3c4,0x01,0xDF,0x00);
+    if ( pXGIHWDE->jChipType == XG21 ) 
+    {
+       if ( pVBInfo->IF_DEF_LVDS == 1 )
+       {
+         if (!(XGI_XG21GetPSCValue( pVBInfo )&0x1))
+         {
+            XGI_XG21BLSignalVDD( 0x01 , 0x01, pVBInfo ) ; /* LVDS VDD on */
+            XGI_XG21SetPanelDelay( 2,pVBInfo ) ;
+         }
+         if (!(XGI_XG21GetPSCValue( pVBInfo )&0x20))
+         {
+            XGI_XG21BLSignalVDD( 0x20 , 0x20, pVBInfo ) ; /* LVDS signal on */
+         }
+         XGI_XG21SetPanelDelay( 3,pVBInfo ) ;
+         XGI_XG21BLSignalVDD( 0x02 , 0x02, pVBInfo ) ; /* LVDS backlight on */
+       }
+       else
+       {
+            XGI_XG21BLSignalVDD( 0x20 , 0x20, pVBInfo ) ; /* DVO/DVI signal on */
+       }
+
+    }
+
+    if (pVBInfo->IF_DEF_CH7007 == 1) /* [Billy] 07/05/23 For CH7007 */
+    {
+#ifdef WIN2000   
+       if ( IsCH7007TVMode( pVBInfo ) ) 
+       {
+           TurnOnCH7007(pXGIHWDE->pDevice) ; /* 07/05/28 */ 
+       }
+#endif
+       
+    }
+
+
+    if ( pXGIHWDE->jChipType == XG27 ) 
+    {
+       if ( pVBInfo->IF_DEF_LVDS == 1 )
+       {
+         if (!(XGI_XG27GetPSCValue( pVBInfo )&0x1))
+         {
+            XGI_XG27BLSignalVDD( 0x01 , 0x01, pVBInfo ) ; /* LVDS VDD on */
+            XGI_XG21SetPanelDelay( 2,pVBInfo ) ;
+         }
+         if (!(XGI_XG27GetPSCValue( pVBInfo )&0x20))
+         {
+            XGI_XG27BLSignalVDD( 0x20 , 0x20, pVBInfo ) ; /* LVDS signal on */
+         }
+         XGI_XG21SetPanelDelay( 3,pVBInfo ) ;
+         XGI_XG27BLSignalVDD( 0x02 , 0x02, pVBInfo ) ; /* LVDS backlight on */
+       }
+       else
+       {
+            XGI_XG27BLSignalVDD( 0x20 , 0x20, pVBInfo ) ; /* DVO/DVI signal on */
+       }
+
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_DisplayOff */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_DisplayOff( PXGI_HW_DEVICE_INFO pXGIHWDE , PVB_DEVICE_INFO pVBInfo )
+{
+
+    if ( pXGIHWDE->jChipType == XG21 ) 
+    {
+       if ( pVBInfo->IF_DEF_LVDS == 1 ) 
+       {
+         XGI_XG21BLSignalVDD( 0x02 , 0x00, pVBInfo ) ; /* LVDS backlight off */
+         XGI_XG21SetPanelDelay( 3,pVBInfo ) ;
+       }
+       else
+       {
+            XGI_XG21BLSignalVDD( 0x20 , 0x00, pVBInfo ) ; /* DVO/DVI signal off */
+       }
+    }
+   
+    if (pVBInfo->IF_DEF_CH7007 == 1) /*[Billy] 07/05/23 For CH7007 */
+    {
+       /* if( IsCH7007TVMode( pVBInfo ) == 0 ) */
+       {
+#ifdef WIN2000
+         TurnOffCH7007(pXGIHWDE->pDevice) ;  /* 07/05/28 */
+#endif
+       }
+    }
+
+
+    if ( pXGIHWDE->jChipType == XG27 ) 
+    {
+       if ((XGI_XG27GetPSCValue( pVBInfo )&0x2))
+       {
+         XGI_XG27BLSignalVDD( 0x02 , 0x00, pVBInfo ) ; /* LVDS backlight off */
+         XGI_XG21SetPanelDelay( 3,pVBInfo ) ;
+       }
+
+       if ( pVBInfo->IF_DEF_LVDS == 0 ) 
+       {
+            XGI_XG27BLSignalVDD( 0x20 , 0x00, pVBInfo ) ; /* DVO/DVI signal off */
+       }
+    }
+    
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x01 , 0xDF , 0x20 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_WaitDisply */
+/* Input : */
+/* Output : */
+/* Description : chiawen for sensecrt1 */
+/* --------------------------------------------------------------------- */
+void XGI_WaitDisply( PVB_DEVICE_INFO pVBInfo )
+{
+    while( ( XGINew_GetReg2( pVBInfo->P3da ) & 0x01 ) )
+        break ;
+
+    while( !( XGINew_GetReg2( pVBInfo->P3da ) & 0x01 ) )
+        break ;
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SenseCRT1 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+
+void XGI_SenseCRT1( PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR CRTCData[ 17 ] = { 0x5F , 0x4F , 0x50 , 0x82 , 0x55 , 0x81 ,
+                             0x0B , 0x3E , 0xE9 , 0x0B , 0xDF , 0xE7 ,
+                             0x04 , 0x00 , 0x00 , 0x05 , 0x00 } ;
+
+    UCHAR SR01 = 0 , SR1F = 0 , SR07 = 0 , SR06 = 0 ;
+
+    UCHAR CR17 , CR63 , SR31 ;
+    USHORT temp ;
+    UCHAR DAC_TEST_PARMS[ 3 ] = { 0x0F , 0x0F , 0x0F } ;
+
+    int i ;
+#ifndef LINUX_XF86
+    int j ;
+#endif
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x05 , 0x86 ) ;
+
+    /* [2004/05/06] Vicent to fix XG42 single LCD sense to CRT+LCD */
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x57 , 0x4A ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x53 , ( UCHAR )( XGINew_GetReg1( pVBInfo->P3d4 , 0x53 ) | 0x02 ) ) ;
+
+    SR31 = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x31 ) ;
+    CR63 = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x63 ) ;
+    SR01 = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x01 ) ;
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x01 , ( UCHAR )( SR01 & 0xDF ) ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x63 , ( UCHAR )( CR63 & 0xBF ) ) ;
+
+    CR17 = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x17 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x17 , ( UCHAR )( CR17 | 0x80 ) ) ;
+
+    SR1F = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x1F ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1F , ( UCHAR )( SR1F | 0x04 ) ) ;
+
+    SR07 = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x07 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x07 , ( UCHAR )( SR07 & 0xFB ) ) ;
+    SR06 = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x06 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x06 , ( UCHAR )( SR06 & 0xC3 ) ) ;
+
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x11 , 0x00 ) ;
+
+    for( i = 0 ; i < 8 ; i++ )
+        XGINew_SetReg1( pVBInfo->P3d4 , ( USHORT )i , CRTCData[ i ] ) ;
+
+    for( i = 8 ; i < 11 ; i++ )
+        XGINew_SetReg1( pVBInfo->P3d4 , ( USHORT )( i + 8 ) , CRTCData[ i ] ) ;
+
+    for( i = 11 ; i < 13 ; i++ )
+        XGINew_SetReg1( pVBInfo->P3d4 , ( USHORT )( i + 4 ) , CRTCData[ i ] ) ;
+
+    for( i = 13 ; i < 16 ; i++ )
+        XGINew_SetReg1( pVBInfo->P3c4 , ( USHORT )( i - 3 ) , CRTCData[ i ] ) ;
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x0E , ( UCHAR )( CRTCData[ 16 ] & 0xE0 ) ) ;
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x31 , 0x00 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , 0x1B ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , 0xE1 ) ;
+
+    XGINew_SetReg3( pVBInfo->P3c8 , 0x00 ) ;
+
+    for( i = 0 ; i < 256 ; i++ )
+    {
+        XGINew_SetReg3( ( pVBInfo->P3c8 + 1 ) , ( UCHAR )DAC_TEST_PARMS[ 0 ] ) ;
+        XGINew_SetReg3( ( pVBInfo->P3c8 + 1 ) , ( UCHAR )DAC_TEST_PARMS[ 1 ] ) ;
+        XGINew_SetReg3( ( pVBInfo->P3c8 + 1 ) , ( UCHAR )DAC_TEST_PARMS[ 2 ] ) ;
+    }
+
+    XGI_VBLongWait( pVBInfo ) ;
+    XGI_VBLongWait( pVBInfo ) ;
+    XGI_VBLongWait( pVBInfo ) ;
+
+    XGINew_LCD_Wait_Time( 0x01 , pVBInfo ) ;
+
+    XGI_WaitDisply( pVBInfo ) ;
+    temp = XGINew_GetReg2( pVBInfo->P3c2 ) ;
+    
+    if( temp & 0x10 )
+    {
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x32 , 0xDF , 0x20 ) ;
+    }
+    else
+    {
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x32 , 0xDF , 0x00 ) ;
+    }
+
+    /* alan, avoid display something, set BLACK DAC if not restore DAC */
+    XGINew_SetReg3( pVBInfo->P3c8 , 0x00 ) ;
+
+    for( i = 0 ; i < 256 ; i++ )
+    {
+      XGINew_SetReg3( ( pVBInfo->P3c8 + 1 ) , 0 ) ;
+      XGINew_SetReg3( ( pVBInfo->P3c8 + 1 ) , 0 ) ;
+      XGINew_SetReg3( ( pVBInfo->P3c8 + 1 ) , 0 ) ;
+    }
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x01 , SR01 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x63 , CR63 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x31 , SR31 ) ;
+
+    /* [2004/05/11] Vicent */
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x53 , ( UCHAR )( XGINew_GetReg1( pVBInfo->P3d4 , 0x53 ) & 0xFD ) ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1F , ( UCHAR ) SR1F ) ;
+}
+
+
+
+
+
+#ifdef TC
+/* --------------------------------------------------------------------- */
+/* Function : INT1AReturnCode */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int INT1AReturnCode( union REGS regs )
+{
+    if ( regs.x.cflag )
+    {
+        /* printf( "Error to find pci device!\n" ) ; */
+        return( 1 ) ;
+    }
+
+    switch(regs.h.ah)
+    {
+        case 0: return 0;
+            break ;
+        case 0x81:
+            printf( "Function not support\n" ) ;
+            break ;
+        case 0x83:
+            printf( "bad vendor id\n" ) ;
+            break ;
+        case 0x86:
+            printf( "device not found\n" ) ;
+            break ;
+        case 0x87:
+            printf( "bad register number\n" ) ;
+            break ;
+        case 0x88:
+            printf( "set failed\n" ) ;
+            break ;
+        case 0x89:
+            printf( "buffer too small" ) ;
+            break ;
+        default:
+            break ;
+    }
+    return( 1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : FindPCIIOBase */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+unsigned FindPCIIOBase( unsigned index , unsigned deviceid )
+{
+    union REGS regs ;
+
+    regs.h.ah = 0xb1 ;	/* PCI_FUNCTION_ID */
+    regs.h.al = 0x02 ;	/* FIND_PCI_DEVICE */
+    regs.x.cx = deviceid ;
+    regs.x.dx = 0x1039 ;
+    regs.x.si = index ;	/* find n-th device */
+
+    int86( 0x1A , &regs , &regs ) ;
+
+    if ( INT1AReturnCode( regs ) != 0 )
+        return( 0 ) ;
+
+    /* regs.h.bh bus number */
+    /* regs.h.bl device number */
+    regs.h.ah = 0xb1 ;  /* PCI_FUNCTION_ID */
+    regs.h.al = 0x09 ;  /* READ_CONFIG_WORD */
+    regs.x.cx = deviceid ;
+    regs.x.dx = 0x1039 ;
+    regs.x.di = 0x18 ;  /* register number */
+    int86( 0x1A , &regs , &regs ) ;
+
+    if ( INT1AReturnCode( regs ) != 0 )
+        return( 0 ) ;
+
+    return( regs.x.cx ) ;
+}
+
+#endif
+
+
+
+#ifdef TC
+/* --------------------------------------------------------------------- */
+/* Function : main */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void main(int argc, char *argv[])
+{
+    XGI_HW_DEVICE_INFO HwDeviceExtension ;
+    USHORT temp ;
+    USHORT ModeNo ;
+
+    /* HwDeviceExtension.pjVirtualRomBase =(PUCHAR) MK_FP(0xC000,0); */
+    /* HwDeviceExtension.pjVideoMemoryAddress = (PUCHAR)MK_FP(0xA000,0); */
+
+
+    HwDeviceExtension.pjIOAddress = ( FindPCIIOBase( 0 ,0x6300 ) & 0xFF80 ) + 0x30 ;
+    HwDeviceExtension.jChipType = XGI_340 ;
+
+
+
+    /* HwDeviceExtension.pjIOAddress = ( FindPCIIOBase( 0 , 0x5315 ) & 0xFF80 ) + 0x30 ; */
+
+    HwDeviceExtension.pjIOAddress = ( FindPCIIOBase( 0 , 0x330 ) & 0xFF80 ) + 0x30 ;
+    HwDeviceExtension.jChipType = XGI_340 ;
+
+
+    HwDeviceExtension.ujVBChipID = VB_CHIP_301 ;
+    StrCpy(HwDeviceExtension.szVBIOSVer , "0.84" ) ;
+    HwDeviceExtension.bSkipDramSizing = FALSE ;
+    HwDeviceExtension.ulVideoMemorySize = 0 ;
+
+    if ( argc == 2 )
+    {
+        ModeNo = atoi( argv[ 1 ] ) ;
+    }
+    else
+    {
+        ModeNo = 0x2e ;
+        /* ModeNo = 0x37 ; 1024x768x 4bpp */
+        /* ModeNo = 0x38 ; 1024x768x 8bpp */
+        /* ModeNo = 0x4A ; 1024x768x 16bpp */
+        /* ModeNo = 0x47 ; 800x600x 16bpp */
+    }
+
+    /* XGIInitNew( &HwDeviceExtension ) ; */
+    XGISetModeNew( &HwDeviceExtension , ModeNo ) ;
+}
+#endif
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_WaitDisplay */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_WaitDisplay( PVB_DEVICE_INFO pVBInfo )
+{
+    while( !( XGINew_GetReg2( pVBInfo->P3da ) & 0x01 ) ) ;
+
+    while( XGINew_GetReg2( pVBInfo->P3da ) & 0x01 ) ;
+}
+
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT2Group301 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_SetCRT2Group301( USHORT ModeNo , PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempbx ,
+           ModeIdIndex ,
+           RefreshRateTableIndex ;
+
+    tempbx=pVBInfo->VBInfo ;
+    pVBInfo->SetFlag |= ProgrammingCRT2 ;
+    XGI_SearchModeID( ModeNo , &ModeIdIndex,  pVBInfo ) ;
+    pVBInfo->SelectCRT2Rate = 4 ;
+    RefreshRateTableIndex = XGI_GetRatePtrCRT2( HwDeviceExtension, ModeNo , ModeIdIndex, pVBInfo ) ;
+    XGI_SaveCRT2Info( ModeNo, pVBInfo ) ;
+    XGI_GetCRT2ResInfo( ModeNo , ModeIdIndex, pVBInfo) ;
+    XGI_GetCRT2Data( ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+    XGI_PreSetGroup1( ModeNo , ModeIdIndex , HwDeviceExtension , RefreshRateTableIndex, pVBInfo ) ;
+    XGI_SetGroup1( ModeNo , ModeIdIndex , HwDeviceExtension , RefreshRateTableIndex, pVBInfo ) ;
+    XGI_SetLockRegs( ModeNo , ModeIdIndex , HwDeviceExtension , RefreshRateTableIndex, pVBInfo ) ;
+    XGI_SetGroup2(  ModeNo , ModeIdIndex , RefreshRateTableIndex , HwDeviceExtension, pVBInfo ) ;
+    XGI_SetLCDRegs(ModeNo , ModeIdIndex , HwDeviceExtension , RefreshRateTableIndex, pVBInfo ) ;
+    XGI_SetTap4Regs(pVBInfo) ;
+    XGI_SetGroup3(ModeNo, ModeIdIndex, pVBInfo);
+    XGI_SetGroup4( ModeNo , ModeIdIndex , RefreshRateTableIndex , HwDeviceExtension, pVBInfo ) ;
+    XGI_SetCRT2VCLK( ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+    XGI_SetGroup5( ModeNo , ModeIdIndex, pVBInfo) ;
+    XGI_AutoThreshold( pVBInfo) ;
+    return 1 ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_AutoThreshold */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_AutoThreshold(  PVB_DEVICE_INFO pVBInfo )
+{
+    if ( !( pVBInfo->SetFlag & Win9xDOSMode ) )
+      XGINew_SetRegOR( pVBInfo->Part1Port , 0x01 , 0x40 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SaveCRT2Info */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SaveCRT2Info( USHORT ModeNo , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT temp1 ,
+           temp2 ;
+
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x34 , ModeNo ) ;  /* reserve CR34 for CRT1 Mode No */
+    temp1 = ( pVBInfo->VBInfo&SetInSlaveMode ) >> 8 ;
+    temp2 = ~( SetInSlaveMode >> 8 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x31 , temp2 , temp1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetCRT2ResInfo */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetCRT2ResInfo( USHORT ModeNo , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT xres ,
+           yres ,
+           modeflag ,
+           resindex ;
+
+    resindex = XGI_GetResInfo( ModeNo , ModeIdIndex, pVBInfo) ;
+    if ( ModeNo <= 0x13 )
+    {
+        xres = pVBInfo->StResInfo[ resindex ].HTotal ;
+        yres = pVBInfo->StResInfo[ resindex ].VTotal ;
+     /* modeflag = pVBInfo->SModeIDTable[ModeIdIndex].St_ModeFlag; si+St_ResInfo */
+    }
+    else
+    {
+        xres = pVBInfo->ModeResInfo[ resindex ].HTotal ;			/* xres->ax */
+        yres = pVBInfo->ModeResInfo[ resindex ].VTotal ;			/* yres->bx */
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex].Ext_ModeFlag ;		/* si+St_ModeFlag */
+
+/*        if ( pVBInfo->IF_DEF_FSTN )
+        {
+            xres *= 2 ;
+            yres *= 2 ;
+        }
+        else
+        {
+*/
+            if ( modeflag & HalfDCLK )
+                xres *= 2;
+
+            if ( modeflag & DoubleScanMode )
+                yres *= 2 ;
+/* } */
+    }
+
+    if ( pVBInfo->VBInfo & SetCRT2ToLCD )
+    {
+        if ( pVBInfo->IF_DEF_LVDS == 0 )
+        {
+            if ( pVBInfo->LCDResInfo == Panel1600x1200 )
+            {
+                if ( !( pVBInfo->LCDInfo & LCDVESATiming ) )
+                {
+                    if ( yres == 1024 )
+                        yres = 1056 ;
+	        }
+            }
+
+            if ( pVBInfo->LCDResInfo == Panel1280x1024 )
+            {
+	        if ( yres == 400 )
+	            yres = 405 ;
+	        else if ( yres == 350 )
+	            yres = 360 ;
+
+	        if ( pVBInfo->LCDInfo & LCDVESATiming )
+	        {
+	            if ( yres == 360 )
+	                yres = 375 ;
+	        }
+            }
+
+            if ( pVBInfo->LCDResInfo == Panel1024x768 )
+            {
+	        if ( !( pVBInfo->LCDInfo & LCDVESATiming ) )
+	        {
+	            if ( !( pVBInfo->LCDInfo & LCDNonExpanding ) )
+	            {
+	                if ( yres == 350 )
+	                    yres = 357 ;
+	                else if ( yres == 400 )
+	                    yres = 420 ;
+	                else if ( yres == 480 )
+	                    yres = 525 ;
+	            }
+                }
+            }
+        }
+
+        if ( xres == 720 )
+            xres = 640 ;
+    }
+
+    pVBInfo->VGAHDE = xres ;
+    pVBInfo->HDE = xres ;
+    pVBInfo->VGAVDE = yres ;
+    pVBInfo->VDE = yres ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_IsLCDDualLink */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_IsLCDDualLink( PVB_DEVICE_INFO pVBInfo )
+{
+#ifndef LINUX_XF86
+    USHORT flag ;
+#endif
+
+    if ( ( ( ( pVBInfo->VBInfo & SetCRT2ToLCD ) | SetCRT2ToLCDA ) ) && ( pVBInfo->LCDInfo & SetLCDDualLink ) ) /* shampoo0129 */
+        return ( 1 ) ;
+
+    return( 0 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetCRT2Data */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetCRT2Data(  USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempax = 0,
+           tempbx ,
+           modeflag ,
+           resinfo ;
+#ifndef LINUX_XF86
+    USHORT CRT2Index ,
+           ResIndex ;
+#endif
+
+    XGI_LCDDataStruct *LCDPtr = NULL ;
+    XGI_TVDataStruct  *TVPtr = NULL ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;      /* si+St_ResInfo */
+        resinfo = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ResInfo ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;     /* si+Ext_ResInfo */
+        resinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;
+    }
+
+    pVBInfo->NewFlickerMode = 0 ;
+    pVBInfo->RVBHRS = 50 ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToRAMDAC )
+    {
+        XGI_GetRAMDAC2DATA( ModeNo , ModeIdIndex , RefreshRateTableIndex,pVBInfo ) ;
+        return ;
+    }
+
+    tempbx = 4 ;
+
+    if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+    {
+        LCDPtr = (XGI_LCDDataStruct* )XGI_GetLcdPtr( tempbx, ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+
+        pVBInfo->RVBHCMAX = LCDPtr->RVBHCMAX ;
+        pVBInfo->RVBHCFACT = LCDPtr->RVBHCFACT ;
+        pVBInfo->VGAHT = LCDPtr->VGAHT ;
+        pVBInfo->VGAVT = LCDPtr->VGAVT ;
+        pVBInfo->HT = LCDPtr->LCDHT ;
+        pVBInfo->VT = LCDPtr->LCDVT ;
+
+        if ( pVBInfo->LCDResInfo == Panel1024x768 )
+        {
+            tempax = 1024 ;
+            tempbx = 768 ;
+
+            if ( !( pVBInfo->LCDInfo & LCDVESATiming ) )
+            {
+                if ( pVBInfo->VGAVDE == 357 )
+                    tempbx = 527 ;
+	        else if ( pVBInfo->VGAVDE == 420 )
+	            tempbx = 620 ;
+	        else if ( pVBInfo->VGAVDE == 525 )
+	            tempbx = 775 ;
+	        else if ( pVBInfo->VGAVDE == 600 )
+	            tempbx = 775 ;
+                /* else if(pVBInfo->VGAVDE==350) tempbx=560; */
+                /* else if(pVBInfo->VGAVDE==400) tempbx=640; */
+	        else
+	          tempbx = 768 ;
+            }
+            else
+                tempbx = 768 ;
+        }
+        else if ( pVBInfo->LCDResInfo == Panel1024x768x75 )
+        {
+            tempax = 1024 ;
+            tempbx = 768 ;
+        }
+        else if ( pVBInfo->LCDResInfo == Panel1280x1024 )
+        {
+            tempax = 1280 ;
+            if ( pVBInfo->VGAVDE == 360 )
+                tempbx = 768 ;
+            else if ( pVBInfo->VGAVDE == 375 )
+                tempbx = 800 ;
+            else if ( pVBInfo->VGAVDE == 405 )
+                tempbx = 864 ;
+            else
+                tempbx = 1024 ;
+        }
+        else if ( pVBInfo->LCDResInfo == Panel1280x1024x75 )
+        {
+            tempax = 1280 ;
+            tempbx = 1024 ;
+        }
+        else if ( pVBInfo->LCDResInfo == Panel1280x960 )
+        {
+            tempax = 1280 ;
+            if ( pVBInfo->VGAVDE == 350 )
+                tempbx = 700 ;
+            else if ( pVBInfo->VGAVDE == 400 )
+                tempbx = 800 ;
+            else if ( pVBInfo->VGAVDE == 1024 )
+                tempbx = 960 ;
+            else
+                tempbx = 960 ;
+        }
+        else if ( pVBInfo->LCDResInfo == Panel1400x1050 )
+        {
+            tempax = 1400 ;
+            tempbx = 1050 ;
+
+            if ( pVBInfo->VGAVDE == 1024 )
+            {
+                tempax = 1280 ;
+                tempbx = 1024 ;
+            }
+        }
+        else if ( pVBInfo->LCDResInfo == Panel1600x1200 )
+        {
+            tempax = 1600 ;
+            tempbx = 1200 ;  /* alan 10/14/2003 */
+            if ( !( pVBInfo->LCDInfo & LCDVESATiming ) )
+            {
+              if ( pVBInfo->VGAVDE == 350 )
+                tempbx = 875 ;
+              else if ( pVBInfo->VGAVDE == 400 )
+                tempbx = 1000 ;
+            }
+        }
+
+        if ( pVBInfo->LCDInfo & LCDNonExpanding )
+        {
+            tempax = pVBInfo->VGAHDE ;
+            tempbx = pVBInfo->VGAVDE ;
+        }
+
+        pVBInfo->HDE = tempax ;
+        pVBInfo->VDE = tempbx ;
+        return ;
+    }
+
+    if ( pVBInfo->VBInfo & ( SetCRT2ToTV ) )
+    {
+        tempbx = 4 ;
+        TVPtr = ( XGI_TVDataStruct * )XGI_GetTVPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+
+        pVBInfo->RVBHCMAX = TVPtr->RVBHCMAX ;
+        pVBInfo->RVBHCFACT = TVPtr->RVBHCFACT ;
+        pVBInfo->VGAHT = TVPtr->VGAHT ;
+        pVBInfo->VGAVT = TVPtr->VGAVT ;
+        pVBInfo->HDE = TVPtr->TVHDE ;
+        pVBInfo->VDE = TVPtr->TVVDE ;
+        pVBInfo->RVBHRS = TVPtr->RVBHRS ;
+        pVBInfo->NewFlickerMode = TVPtr->FlickerMode ;
+
+        if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+        {
+            if ( resinfo == 0x08 )
+                pVBInfo->NewFlickerMode = 0x40 ;
+            else if ( resinfo == 0x09 )
+                pVBInfo->NewFlickerMode = 0x40 ;
+            else if ( resinfo == 0x12 )
+                pVBInfo->NewFlickerMode = 0x40 ;
+
+            if ( pVBInfo->VGAVDE == 350 )
+                pVBInfo->TVInfo |= TVSimuMode ;
+
+            tempax = ExtHiTVHT ;
+            tempbx = ExtHiTVVT ;
+
+            if ( pVBInfo->VBInfo & SetInSlaveMode )
+            {
+	        if ( pVBInfo->TVInfo & TVSimuMode )
+	        {
+	            tempax = StHiTVHT ;
+	            tempbx = StHiTVVT ;
+
+	            if ( !( modeflag & Charx8Dot ) )
+	            {
+	                tempax = StHiTextTVHT ;
+	                tempbx = StHiTextTVVT ;
+	            }
+	        }
+            }
+        }
+        else if ( pVBInfo->VBInfo & SetCRT2ToYPbPr )
+        {
+            if ( pVBInfo->TVInfo & SetYPbPrMode750p )
+            {
+                tempax = YPbPrTV750pHT ;	/* Ext750pTVHT */
+                tempbx = YPbPrTV750pVT ;	/* Ext750pTVVT */
+            }
+
+            if ( pVBInfo->TVInfo & SetYPbPrMode525p )
+            {
+                tempax = YPbPrTV525pHT ;	/* Ext525pTVHT */
+                tempbx = YPbPrTV525pVT ;	/* Ext525pTVVT */
+            }
+            else if ( pVBInfo->TVInfo & SetYPbPrMode525i )
+            {
+                tempax = YPbPrTV525iHT ;	/* Ext525iTVHT */
+                tempbx = YPbPrTV525iVT ;	/* Ext525iTVVT */
+                if ( pVBInfo->TVInfo & NTSC1024x768 )
+                    tempax = NTSC1024x768HT ;
+            }
+        }
+        else
+        {
+            tempax = PALHT ;
+            tempbx = PALVT ;
+            if ( !( pVBInfo->TVInfo & SetPALTV ) )
+            {
+                tempax = NTSCHT ;
+	        tempbx = NTSCVT ;
+	        if ( pVBInfo->TVInfo & NTSC1024x768 )
+	            tempax = NTSC1024x768HT ;
+            }
+        }
+
+        pVBInfo->HT = tempax ;
+        pVBInfo->VT = tempbx ;
+        return ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT2VCLK */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT2VCLK( USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR di_0 ,
+          di_1 ,
+          tempal ;
+
+    tempal = XGI_GetVCLKPtr( RefreshRateTableIndex , ModeNo , ModeIdIndex, pVBInfo ) ;
+    XGI_GetVCLKLen( tempal, &di_0 , &di_1, pVBInfo ) ;
+    XGI_GetLCDVCLKPtr( &di_0 , &di_1, pVBInfo ) ;
+
+    if ( pVBInfo->VBType & VB_XGI301 ) /* shampoo 0129 */
+    {				/* 301 */
+        XGINew_SetReg1(pVBInfo->Part4Port , 0x0A , 0x10 ) ;
+        XGINew_SetReg1(pVBInfo->Part4Port , 0x0B , di_1 ) ;
+        XGINew_SetReg1(pVBInfo->Part4Port , 0x0A , di_0 ) ;
+    }
+    else
+    {				/* 301b/302b/301lv/302lv */
+        XGINew_SetReg1( pVBInfo->Part4Port , 0x0A , di_0 ) ;
+        XGINew_SetReg1( pVBInfo->Part4Port , 0x0B , di_1 ) ;
+    }
+
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x00 , 0x12 ) ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToRAMDAC )
+        XGINew_SetRegOR( pVBInfo->Part4Port , 0x12 , 0x28 ) ;
+    else
+        XGINew_SetRegOR( pVBInfo->Part4Port , 0x12 , 0x08 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GETLCDVCLKPtr */
+/* Input : */
+/* Output : al -> VCLK Index */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetLCDVCLKPtr( UCHAR* di_0 , UCHAR *di_1, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT index ;
+
+    if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+    {
+        if ( pVBInfo->IF_DEF_ScaleLCD == 1 )
+        {
+            if ( pVBInfo->LCDInfo & EnableScalingLCD )
+                return ;
+        }
+
+        /* index = XGI_GetLCDCapPtr(pVBInfo) ; */
+        index = XGI_GetLCDCapPtr1( pVBInfo) ;
+
+        if ( pVBInfo->VBInfo & SetCRT2ToLCD )
+        {	/* LCDB */
+            *di_0 = pVBInfo->LCDCapList[ index ].LCUCHAR_VCLKData1 ;
+            *di_1 = pVBInfo->LCDCapList[ index ].LCUCHAR_VCLKData2 ;
+        }
+        else
+        {	/* LCDA */
+            *di_0 = pVBInfo->LCDCapList[ index ].LCDA_VCLKData1 ;
+            *di_1 = pVBInfo->LCDCapList[ index ].LCDA_VCLKData2 ;
+        }
+    }
+    return ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetVCLKPtr */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+UCHAR XGI_GetVCLKPtr(USHORT RefreshRateTableIndex,USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo)
+{
+
+    USHORT index ,
+           modeflag ;
+#ifndef LINUX_XF86
+    USHORT tempbx ;
+#endif
+
+    UCHAR tempal ;
+    UCHAR *CHTVVCLKPtr = NULL ;
+
+    if ( ModeNo <= 0x13 )
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;      /* si+St_ResInfo */
+    else
+        modeflag = pVBInfo->EModeIDTable[ModeIdIndex].Ext_ModeFlag;    /* si+Ext_ResInfo */
+
+
+    if ( ( pVBInfo->SetFlag & ProgrammingCRT2 ) && ( !( pVBInfo->LCDInfo & EnableScalingLCD ) ) )
+    {   /* {LCDA/LCDB} */
+        index = XGI_GetLCDCapPtr(pVBInfo) ;
+        tempal = pVBInfo->LCDCapList[ index ].LCD_VCLK ;
+
+        if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+            return tempal ;
+
+	/* {TV} */
+        if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV| VB_XGI302LV| VB_XGI301C ) )
+        {
+            if(pVBInfo->VBInfo&SetCRT2ToHiVisionTV)
+           {
+                tempal = HiTVVCLKDIV2;
+                if(!(pVBInfo->TVInfo & RPLLDIV2XO))
+                    tempal = HiTVVCLK;
+	        if(pVBInfo->TVInfo & TVSimuMode)
+                {
+                    tempal = HiTVSimuVCLK;
+                    if(!(modeflag & Charx8Dot))
+              	        tempal = HiTVTextVCLK;
+
+                 }
+                 return tempal;
+             }
+
+            if ( pVBInfo->TVInfo & SetYPbPrMode750p )
+            {
+                tempal = YPbPr750pVCLK ;
+                return tempal ;
+            }
+
+            if ( pVBInfo->TVInfo & SetYPbPrMode525p )
+            {
+                tempal = YPbPr525pVCLK ;
+                return tempal ;
+            }
+
+            tempal = NTSC1024VCLK ;
+
+            if ( !( pVBInfo->TVInfo & NTSC1024x768 ) )
+            {
+                tempal = TVVCLKDIV2 ;
+                if ( !( pVBInfo->TVInfo & RPLLDIV2XO ) )
+                    tempal = TVVCLK ;
+            }
+
+            if ( pVBInfo->VBInfo & SetCRT2ToTV )
+                return tempal ;
+        }
+        /*else
+        if((pVBInfo->IF_DEF_CH7017==1)&&(pVBInfo->VBType&VB_CH7017))
+        {
+            if(ModeNo<=0x13)
+                *tempal = pVBInfo->SModeIDTable[ModeIdIndex].St_CRT2CRTC;
+            else
+                *tempal = pVBInfo->RefIndex[RefreshRateTableIndex].Ext_CRT2CRTC;
+            *tempal = *tempal & 0x1F;
+
+            tempbx = 0;
+            if(pVBInfo->TVInfo & SetPALTV)
+                tempbx = tempbx + 2;
+            if(pVBInfo->TVInfo & SetCHTVOverScan)
+                tempbx++;
+            tempbx = tempbx << 1;
+        }  */
+    }	/* {End of VB} */
+
+    if((pVBInfo->IF_DEF_CH7007==1)&&(pVBInfo->VBType&VB_CH7007)) /* [Billy] 07/05/08 CH7007 */
+    {
+       /* VideoDebugPrint((0, "XGI_GetVCLKPtr: pVBInfo->IF_DEF_CH7007==1\n")); */
+       if ( (pVBInfo->VBInfo & SetCRT2ToTV) )
+       {    
+           if( ModeNo <= 0x13 )
+           { 
+              tempal = pVBInfo->SModeIDTable[ ModeIdIndex ].St_CRT2CRTC ;
+           }
+           else
+           {
+              tempal = pVBInfo->RefIndex[RefreshRateTableIndex].Ext_CRT2CRTC;
+           }
+
+           tempal = tempal & 0x0F;
+           tempbx = 0;
+
+           if(pVBInfo->TVInfo & SetPALTV)
+           {
+              tempbx = tempbx + 2; 
+           }
+           if(pVBInfo->TVInfo & SetCHTVOverScan)
+           {
+              tempbx++; 
+           }
+           /** tempbx = tempbx << 1; CH7007 ? **/
+
+/*[Billy]07/05/29 CH7007*/
+           if ( pVBInfo->IF_DEF_CH7007 == 1 )
+           {
+             switch( tempbx )
+             {
+               case 0:
+                   CHTVVCLKPtr = XGI7007_CHTVVCLKUNTSC ;
+                   break ;
+               case 1:
+                   CHTVVCLKPtr = XGI7007_CHTVVCLKONTSC ;
+                   break ;
+               case 2:
+                   CHTVVCLKPtr = XGI7007_CHTVVCLKUPAL ;
+                   break ;
+               case 3:
+                   CHTVVCLKPtr = XGI7007_CHTVVCLKOPAL ;
+                   break ;
+               default:
+                   break ;
+          
+             }
+           }
+           /*else
+           { 
+            switch( tempbx )
+            {
+               case 0:
+                   CHTVVCLKPtr = pVBInfo->CHTVVCLKUNTSC ;
+                   break ;
+               case 1:
+                   CHTVVCLKPtr = pVBInfo->CHTVVCLKONTSC ;
+                   break ;
+               case 2:
+                   CHTVVCLKPtr = pVBInfo->CHTVVCLKUPAL ;
+                   break ;
+               case 3:
+                   CHTVVCLKPtr = pVBInfo->CHTVVCLKOPAL ;
+                   break ;
+               default:
+                   break ;
+            } 
+           }*/
+
+           tempal = CHTVVCLKPtr[ tempal ] ;
+           return tempal ;
+       }
+       
+    }
+
+    tempal = ( UCHAR )XGINew_GetReg2( ( pVBInfo->P3ca + 0x02 ) ) ;
+    tempal = tempal >> 2 ;
+    tempal &= 0x03 ;
+
+    if ( ( pVBInfo->LCDInfo & EnableScalingLCD ) && ( modeflag & Charx8Dot ) )  /* for Dot8 Scaling LCD */
+        tempal = tempal ^ tempal ;                   /* ; set to VCLK25MHz always */
+
+    if ( ModeNo <= 0x13 )
+        return tempal ;
+
+    tempal = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRTVCLK ;
+    return tempal ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetVCLKLen */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetVCLKLen(UCHAR tempal,UCHAR* di_0,UCHAR* di_1, PVB_DEVICE_INFO pVBInfo)
+{
+    if ( pVBInfo->IF_DEF_CH7007 == 1 ) /* [Billy] 2007/05/16 */
+    {
+       /* VideoDebugPrint((0, "XGI_GetVCLKLen: pVBInfo->IF_DEF_CH7007==1\n")); */
+        *di_0 = ( UCHAR )XGI_CH7007VCLKData[ tempal ].SR2B ;
+        *di_1 = ( UCHAR )XGI_CH7007VCLKData[ tempal ].SR2C ;
+    }
+    else if ( pVBInfo->VBType & ( VB_XGI301 | VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        if ( ( !( pVBInfo->VBInfo & SetCRT2ToLCDA ) ) && ( pVBInfo->SetFlag & ProgrammingCRT2 ) )
+        {
+            *di_0 = ( UCHAR )XGI_VBVCLKData[ tempal ].SR2B ;
+            *di_1 = XGI_VBVCLKData[ tempal ].SR2C ;
+        }
+    }
+    else
+    {
+        *di_0 = XGI_VCLKData[ tempal ].SR2B ;
+        *di_1 = XGI_VCLKData[ tempal ].SR2C ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT2Offset */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT2Offset( USHORT ModeNo ,
+				   USHORT ModeIdIndex , USHORT RefreshRateTableIndex , PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT offset ;
+    UCHAR temp ;
+
+    if ( pVBInfo->VBInfo & SetInSlaveMode )
+    {
+        return ;
+    }
+
+    offset = XGI_GetOffset(  ModeNo , ModeIdIndex , RefreshRateTableIndex , HwDeviceExtension, pVBInfo ) ;
+    temp = ( UCHAR )( offset & 0xFF ) ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x07 , temp ) ;
+    temp =( UCHAR)( ( offset & 0xFF00 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x09 , temp ) ;
+    temp =( UCHAR )( ( ( offset >> 3 ) & 0xFF ) + 1 ) ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x03 , temp ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetOffset */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT XGI_GetOffset(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT temp ,
+           colordepth ,
+           modeinfo ,
+           index ,
+           infoflag ,
+           ColorDepth[] = { 0x01 , 0x02 , 0x04 } ;
+
+    modeinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeInfo ;
+    if ( ModeNo <= 0x14 )
+        infoflag = 0 ;
+    else
+        infoflag = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_InfoFlag ;
+
+
+    index = ( modeinfo >> 8 ) & 0xFF ;
+
+    temp = pVBInfo->ScreenOffset[ index ] ;
+
+    if ( infoflag & InterlaceMode )
+    {
+        temp = temp << 1 ;
+    }
+
+    colordepth = XGI_GetColorDepth( ModeNo , ModeIdIndex, pVBInfo ) ;
+
+    if ( ( ModeNo >= 0x7C ) && ( ModeNo <= 0x7E ) )
+    {
+        temp = ModeNo - 0x7C ;
+	colordepth = ColorDepth[ temp ] ;
+	temp = 0x6B ;
+	if ( infoflag & InterlaceMode )
+	{
+            temp = temp << 1 ;
+	}
+	return( temp * colordepth ) ;
+    }
+    else
+        return( temp * colordepth ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT2FIFO */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT2FIFO( PVB_DEVICE_INFO pVBInfo)
+{
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x01 , 0x3B ) ;			/* threshold high ,disable auto threshold */
+    XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x02 , ~( 0x3F ) , 0x04 ) ;	/* threshold low default 04h */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_PreSetGroup1 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_PreSetGroup1(USHORT ModeNo , USHORT ModeIdIndex ,PXGI_HW_DEVICE_INFO HwDeviceExtension,
+                       USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempcx = 0 ,
+           CRT1Index = 0 ,
+           resinfo = 0 ;
+#ifndef LINUX_XF86
+    USHORT temp = 0 ,
+           tempax = 0 ,
+           tempbx = 0 ,
+           pushbx = 0 ,
+           modeflag ;
+#endif
+
+    if ( ModeNo > 0x13 )
+    {
+        CRT1Index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT1CRTC ;
+        CRT1Index &= IndexMask ;
+        resinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;
+    }
+
+    XGI_SetCRT2Offset( ModeNo , ModeIdIndex , RefreshRateTableIndex , HwDeviceExtension, pVBInfo ) ;
+    XGI_SetCRT2FIFO(pVBInfo) ;
+    /* XGI_SetCRT2Sync(ModeNo,RefreshRateTableIndex); */
+
+    for( tempcx = 4 ; tempcx < 7 ; tempcx++ )
+    {
+        XGINew_SetReg1( pVBInfo->Part1Port , tempcx , 0x0 ) ;
+    }
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x50 , 0x00 ) ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x02 , 0x44 ) ;	/* temp 0206 */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetGroup1 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetGroup1( USHORT ModeNo , USHORT ModeIdIndex ,
+                            PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT temp = 0 ,
+           tempax = 0 ,
+           tempbx = 0 ,
+           tempcx = 0 ,
+           pushbx = 0 ,
+           CRT1Index = 0 ,
+           modeflag ,
+           resinfo = 0 ;
+
+    if ( ModeNo > 0x13 )
+    {
+        CRT1Index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT1CRTC ;
+        CRT1Index &= IndexMask ;
+        resinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;
+    }
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+    }
+
+    /* bainy change table name */
+    if ( modeflag & HalfDCLK )
+    {
+        temp = ( pVBInfo->VGAHT / 2 - 1 ) & 0x0FF ;			/* BTVGA2HT 0x08,0x09 */
+        XGINew_SetReg1( pVBInfo->Part1Port , 0x08 , temp ) ;
+        temp = ( ( ( pVBInfo->VGAHT / 2 - 1 ) & 0xFF00 ) >> 8 ) << 4 ;
+        XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x09 , ~0x0F0 , temp ) ;
+        temp = ( pVBInfo->VGAHDE / 2 + 16 ) & 0x0FF ;			/* BTVGA2HDEE 0x0A,0x0C */
+        XGINew_SetReg1( pVBInfo->Part1Port , 0x0A , temp ) ;
+        tempcx = ( ( pVBInfo->VGAHT - pVBInfo->VGAHDE ) / 2 ) >> 2 ;
+        pushbx = pVBInfo->VGAHDE / 2 + 16 ;
+        tempcx = tempcx >> 1 ;
+        tempbx = pushbx + tempcx ;					/* bx BTVGA@HRS 0x0B,0x0C */
+        tempcx += tempbx ;
+
+  	if ( pVBInfo->VBInfo & SetCRT2ToRAMDAC )
+  	{
+            tempbx = pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 4 ] ;
+            tempbx |= ( ( pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 14 ] & 0xC0 ) << 2 ) ;
+            tempbx = ( tempbx - 3 ) << 3 ;				/* (VGAHRS-3)*8 */
+            tempcx = pVBInfo->XGINEWUB_CRT1Table[CRT1Index].CR[ 5 ] ;
+            tempcx &= 0x1F ;
+            temp = pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 15 ] ;
+            temp = ( temp & 0x04 ) << ( 5 - 2 ) ;			/* VGAHRE D[5] */
+            tempcx = ( ( tempcx | temp ) - 3 ) << 3 ;			/* (VGAHRE-3)*8 */
+        }
+
+        tempbx += 4 ;
+        tempcx += 4 ;
+
+        if ( tempcx > ( pVBInfo->VGAHT / 2 ) )
+            tempcx = pVBInfo->VGAHT / 2 ;
+
+        temp = tempbx & 0x00FF ;
+
+        XGINew_SetReg1( pVBInfo->Part1Port , 0x0B , temp ) ;
+    }
+    else
+    {
+        temp = ( pVBInfo->VGAHT - 1 ) & 0x0FF ;				/* BTVGA2HT 0x08,0x09 */
+        XGINew_SetReg1( pVBInfo->Part1Port , 0x08 , temp ) ;
+        temp = ( ( ( pVBInfo->VGAHT - 1 ) & 0xFF00 ) >> 8 ) << 4 ;
+        XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x09 , ~0x0F0 , temp ) ;
+        temp = ( pVBInfo->VGAHDE + 16 ) & 0x0FF ;				/* BTVGA2HDEE 0x0A,0x0C */
+        XGINew_SetReg1( pVBInfo->Part1Port , 0x0A , temp ) ;
+        tempcx = ( pVBInfo->VGAHT - pVBInfo->VGAHDE ) >> 2 ;		/* cx */
+        pushbx = pVBInfo->VGAHDE + 16 ;
+        tempcx = tempcx >> 1 ;
+        tempbx = pushbx + tempcx ;					/* bx BTVGA@HRS 0x0B,0x0C */
+        tempcx += tempbx ;
+
+        if ( pVBInfo->VBInfo & SetCRT2ToRAMDAC )
+        {
+            tempbx = pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 3 ] ;
+            tempbx |= ( ( pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 5 ] & 0xC0 ) << 2 ) ;
+            tempbx = ( tempbx - 3 ) << 3 ;				/* (VGAHRS-3)*8 */
+            tempcx = pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 4 ] ;
+            tempcx &= 0x1F ;
+            temp = pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 6 ] ;
+            temp = ( temp & 0x04 ) << ( 5 - 2 ) ;			/* VGAHRE D[5] */
+            tempcx = ( ( tempcx | temp ) - 3 ) << 3 ;			/* (VGAHRE-3)*8 */
+            tempbx += 16 ;
+            tempcx += 16 ;
+        }
+
+        if ( tempcx > pVBInfo->VGAHT )
+            tempcx = pVBInfo->VGAHT ;
+
+        temp = tempbx & 0x00FF ;
+        XGINew_SetReg1( pVBInfo->Part1Port , 0x0B , temp ) ;
+    }
+
+    tempax = ( tempax & 0x00FF ) | ( tempbx & 0xFF00 ) ;
+    tempbx = pushbx ;
+    tempbx = ( tempbx & 0x00FF ) | ( ( tempbx & 0xFF00 ) << 4 ) ;
+    tempax |= ( tempbx & 0xFF00 ) ;
+    temp = ( tempax & 0xFF00 ) >> 8 ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x0C , temp ) ;
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x0D , temp ) ;
+    tempcx = ( pVBInfo->VGAVT - 1 ) ;
+    temp = tempcx & 0x00FF ;
+
+    if ( pVBInfo->IF_DEF_CH7005 == 1 )
+    {
+        if ( pVBInfo->VBInfo & 0x0C )
+        {
+            temp-- ;
+	}
+    }
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x0E , temp ) ;
+    tempbx = pVBInfo->VGAVDE - 1 ;
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x0F , temp ) ;
+    temp = ( ( tempbx & 0xFF00 ) << 3 ) >> 8 ;
+    temp |= ( ( tempcx & 0xFF00 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x12 , temp ) ;
+
+    tempax = pVBInfo->VGAVDE ;
+    tempbx = pVBInfo->VGAVDE ;
+    tempcx = pVBInfo->VGAVT ;
+    tempbx = ( pVBInfo->VGAVT + pVBInfo->VGAVDE ) >> 1 ;				/* BTVGA2VRS 0x10,0x11 */
+    tempcx = ( ( pVBInfo->VGAVT - pVBInfo->VGAVDE ) >> 4 ) + tempbx + 1 ;		/* BTVGA2VRE 0x11 */
+
+    if ( pVBInfo->VBInfo & SetCRT2ToRAMDAC )
+    {
+        tempbx = pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 10 ] ;
+        temp = pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 9 ] ;
+
+        if ( temp & 0x04 )
+            tempbx |= 0x0100 ;
+
+        if ( temp & 0x080 )
+            tempbx |= 0x0200 ;
+
+        temp = pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 14 ] ;
+
+        if ( temp & 0x08 )
+            tempbx |= 0x0400 ;
+
+        temp = pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 11 ] ;
+        tempcx = ( tempcx & 0xFF00 ) | ( temp & 0x00FF ) ;
+    }
+
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x10 , temp ) ;
+    temp = ( ( tempbx & 0xFF00 ) >> 8 ) << 4 ;
+    temp = ( ( tempcx & 0x000F ) | ( temp ) ) ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x11 , temp ) ;
+    tempax = 0 ;
+
+    if ( modeflag & DoubleScanMode )
+        tempax |= 0x80 ;
+
+    if ( modeflag & HalfDCLK )
+        tempax |= 0x40 ;
+
+    XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x2C , ~0x0C0 , tempax ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetLockRegs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void  XGI_SetLockRegs( USHORT ModeNo , USHORT ModeIdIndex ,
+                                PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT push1 ,
+           push2 ,
+           tempax ,
+           tempbx = 0 ,
+           tempcx ,
+           temp ,
+           resinfo ,
+           modeflag ,
+           CRT1Index ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;	/* si+St_ResInfo */
+        resinfo = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ResInfo ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;	/* si+Ext_ResInfo */
+        resinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;
+        CRT1Index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT1CRTC ;
+        CRT1Index &= IndexMask;
+    }
+
+    if ( !( pVBInfo->VBInfo & SetInSlaveMode ) )
+    {
+        return ;
+    }
+
+    temp = 0xFF ;							/* set MAX HT */
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x03 , temp ) ;
+    /* if ( modeflag & Charx8Dot ) tempcx = 0x08 ; */
+    /* else */
+    tempcx=0x08;
+
+    if ( pVBInfo->VBType & ( VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        modeflag |= Charx8Dot ;
+
+    tempax = pVBInfo->VGAHDE ;						/* 0x04 Horizontal Display End */
+
+    if ( modeflag & HalfDCLK )
+        tempax = tempax >> 1 ;
+
+    tempax = ( tempax / tempcx ) - 1 ;
+    tempbx |= ( ( tempax & 0x00FF ) << 8 ) ;
+    temp = tempax & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x04 , temp ) ;
+
+    temp = ( tempbx & 0xFF00 ) >> 8 ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToTV )
+    {
+        if ( !( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) ) )
+            temp += 2 ;
+
+        if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+        {
+            if ( pVBInfo->VBType & VB_XGI301LV )
+            {
+                if ( pVBInfo->VBExtInfo == VB_YPbPr1080i )
+                {
+                    if ( resinfo == 7 )
+                        temp -= 2 ;
+                }
+            }
+            else
+                if ( resinfo == 7 )
+                    temp -= 2 ;
+        }
+    }
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x05 , temp ) ;			/* 0x05 Horizontal Display Start */
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x06 , 0x03 ) ;			/* 0x06 Horizontal Blank end */
+
+    if ( !( pVBInfo->VBInfo & DisableCRT2Display ) )
+    {                            					/* 030226 bainy */
+        if ( pVBInfo->VBInfo & SetCRT2ToTV )
+            tempax = pVBInfo->VGAHT ;
+        else
+            tempax = XGI_GetVGAHT2( pVBInfo) ;
+    }
+
+    if ( tempax >= pVBInfo->VGAHT )
+    {
+        tempax = pVBInfo->VGAHT ;
+    }
+
+    if ( modeflag & HalfDCLK )
+    {
+        tempax = tempax >> 1 ;
+    }
+
+    tempax = ( tempax / tempcx ) - 5 ;
+    tempcx = tempax ;				/* 20030401 0x07 horizontal Retrace Start */
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+    {
+        temp = ( tempbx & 0x00FF ) - 1 ;
+        if ( !( modeflag & HalfDCLK ) )
+        {
+            temp -= 6 ;
+            if ( pVBInfo->TVInfo & TVSimuMode )
+            {
+                temp -= 4 ;
+                if ( ModeNo > 0x13 )
+                    temp -= 10 ;
+            }
+        }
+    }
+    else
+    {
+        /* tempcx = tempbx & 0x00FF ; */
+        tempbx = ( tempbx & 0xFF00 ) >> 8 ;
+        tempcx = ( tempcx + tempbx ) >> 1 ;
+        temp = ( tempcx & 0x00FF ) + 2 ;
+
+        if ( pVBInfo->VBInfo & SetCRT2ToTV )
+        {
+            temp -= 1 ;
+            if ( !( modeflag & HalfDCLK ) )
+            {
+                if ( ( modeflag & Charx8Dot ) )
+                {
+                    temp += 4 ;
+                    if ( pVBInfo->VGAHDE >= 800 )
+                    {
+                        temp -= 6 ;
+                    }
+                }
+            }
+        }
+        else
+        {
+            if ( !( modeflag & HalfDCLK ) )
+            {
+                temp -= 4 ;
+                if ( pVBInfo->LCDResInfo != Panel1280x960 )
+                {
+                    if( pVBInfo->VGAHDE >= 800 )
+                    {
+                        temp -= 7 ;
+                        if ( pVBInfo->ModeType == ModeEGA )
+                        {
+                            if ( pVBInfo->VGAVDE == 1024 )
+                            {
+                                temp += 15 ;
+                                if ( pVBInfo->LCDResInfo != Panel1280x1024 )
+                                {
+                                    temp += 7 ;
+                                }
+                            }
+                        }
+
+                        if ( pVBInfo->VGAHDE >= 1280 )
+                        {
+                            if ( pVBInfo->LCDResInfo != Panel1280x960 )
+                            {
+                                if ( pVBInfo->LCDInfo & LCDNonExpanding )
+                                {
+                                    temp += 28 ;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x07 , temp ) ;		/* 0x07 Horizontal Retrace Start */
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x08 , 0 ) ;		/* 0x08 Horizontal Retrace End */
+
+    if ( pVBInfo->VBInfo & SetCRT2ToTV )
+    {
+        if ( pVBInfo->TVInfo & TVSimuMode )
+        {
+            if ( ( ModeNo == 0x06 ) || ( ModeNo == 0x10 ) || ( ModeNo == 0x11 ) || ( ModeNo == 0x13 ) || ( ModeNo == 0x0F ) )
+            {
+                XGINew_SetReg1( pVBInfo->Part1Port , 0x07 , 0x5b ) ;
+                XGINew_SetReg1( pVBInfo->Part1Port , 0x08 , 0x03 ) ;
+            }
+
+            if ( ( ModeNo == 0x00 ) || ( ModeNo == 0x01 ) )
+            {
+                if ( pVBInfo->TVInfo & SetNTSCTV )
+                {
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x07 , 0x2A ) ;
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x08 , 0x61 ) ;
+                }
+                else
+                {
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x07 , 0x2A ) ;
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x08 , 0x41 ) ;
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x0C , 0xF0 ) ;
+                }
+            }
+
+            if ( ( ModeNo == 0x02 ) || ( ModeNo == 0x03 ) || ( ModeNo == 0x07 ) )
+            {
+                if ( pVBInfo->TVInfo & SetNTSCTV )
+                {
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x07 , 0x54 ) ;
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x08 , 0x00 ) ;
+                }
+                else
+                {
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x07 , 0x55 ) ;
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x08 , 0x00 ) ;
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x0C , 0xF0 ) ;
+                }
+            }
+
+            if ( ( ModeNo == 0x04 ) || ( ModeNo == 0x05 ) || ( ModeNo == 0x0D ) || ( ModeNo == 0x50 ) )
+            {
+                if ( pVBInfo->TVInfo & SetNTSCTV )
+                {
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x07 , 0x30 ) ;
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x08 , 0x03 ) ;
+                }
+                else
+                {
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x07 , 0x2f ) ;
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x08 , 0x02 ) ;
+                }
+            }
+        }
+    }
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x18 , 0x03 ) ;				/* 0x18 SR0B */
+    XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x19 , 0xF0 , 0x00 ) ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x09 , 0xFF ) ;				/* 0x09 Set Max VT */
+
+    tempbx = pVBInfo->VGAVT ;
+    push1 = tempbx ;
+    tempcx = 0x121 ;
+    tempbx = pVBInfo->VGAVDE ;							/* 0x0E Virtical Display End */
+
+    if ( tempbx == 357 )
+        tempbx = 350 ;
+    if ( tempbx == 360 )
+        tempbx =350 ;
+    if ( tempbx == 375 )
+        tempbx = 350 ;
+    if ( tempbx == 405 )
+        tempbx = 400 ;
+    if ( tempbx == 525 )
+        tempbx = 480 ;
+
+    push2 = tempbx ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToLCD )
+    {
+        if ( pVBInfo->LCDResInfo == Panel1024x768 )
+        {
+            if ( !( pVBInfo->LCDInfo & LCDVESATiming ) )
+            {
+                if ( tempbx == 350 )
+                    tempbx += 5 ;
+		if ( tempbx == 480 )
+		    tempbx += 5 ;
+            }
+        }
+    }
+    tempbx-- ;
+    temp = tempbx & 0x00FF ;
+    tempbx-- ;
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x10 ,temp ) ;				/* 0x10 vertical Blank Start */
+    tempbx = push2 ;
+    tempbx-- ;
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x0E , temp ) ;
+
+    if ( tempbx & 0x0100 )
+    {
+        tempcx |= 0x0002 ;
+    }
+
+    tempax = 0x000B ;
+
+    if ( modeflag & DoubleScanMode )
+    {
+        tempax |= 0x08000 ;
+    }
+
+    if ( tempbx & 0x0200 )
+    {
+        tempcx |= 0x0040 ;
+    }
+
+    temp = ( tempax & 0xFF00 ) >> 8 ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x0B , temp ) ;
+
+    if ( tempbx & 0x0400 )
+    {
+        tempcx |= 0x0600 ;
+    }
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x11 , 0x00 ) ;				/* 0x11 Vertival Blank End */
+
+    tempax = push1 ;
+    tempax -= tempbx ;								/* 0x0C Vertical Retrace Start */
+    tempax = tempax >> 2 ;
+    push1 = tempax ;								/* push ax */
+
+    if ( resinfo != 0x09 )
+    {
+        tempax = tempax << 1 ;
+        tempbx += tempax ;
+    }
+
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+    {
+        if ( pVBInfo->VBType & VB_XGI301LV )
+        {
+            if ( pVBInfo->TVInfo & SetYPbPrMode1080i )
+                tempbx -= 10 ;
+            else
+            {
+                if ( pVBInfo->TVInfo & TVSimuMode )
+                {
+                    if ( pVBInfo->TVInfo & SetPALTV )
+                    {
+                        if ( pVBInfo->VBType & VB_XGI301LV )
+                        {
+                            if ( !( pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p | SetYPbPrMode1080i ) ) )
+                                tempbx += 40 ;
+                        }
+                        else
+                            tempbx += 40 ;
+                    }
+                }
+            }
+        }
+        else
+            tempbx -= 10 ;
+    }
+    else
+    {
+        if ( pVBInfo->TVInfo & TVSimuMode )
+        {
+            if ( pVBInfo->TVInfo & SetPALTV )
+            {
+                if ( pVBInfo->VBType & VB_XGI301LV )
+                {
+                    if ( !( pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p | SetYPbPrMode1080i ) ) )
+                        tempbx += 40 ;
+                }
+                else
+                    tempbx += 40 ;
+            }
+        }
+    }
+    tempax = push1 ;
+    tempax = tempax >> 2 ;
+    tempax++ ;
+    tempax += tempbx ;
+    push1 = tempax ;						/* push ax */
+
+    if ( ( pVBInfo->TVInfo & SetPALTV ) )
+    {
+        if ( tempbx <= 513 )
+        {
+            if ( tempax >= 513 )
+            {
+                tempbx = 513 ;
+            }
+        }
+    }
+
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x0C , temp ) ;
+    tempbx-- ;
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x10 , temp ) ;
+
+    if ( tempbx & 0x0100 )
+    {
+        tempcx |= 0x0008 ;
+    }
+
+    if ( tempbx & 0x0200 )
+    {
+        XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x0B , 0x0FF , 0x20 ) ;
+    }
+
+    tempbx++ ;
+
+    if ( tempbx & 0x0100 )
+    {
+        tempcx |= 0x0004 ;
+    }
+
+    if ( tempbx & 0x0200 )
+    {
+        tempcx |= 0x0080 ;
+    }
+
+    if ( tempbx & 0x0400 )
+    {
+        tempcx |= 0x0C00 ;
+    }
+
+    tempbx = push1 ;						/* pop ax */
+    temp = tempbx & 0x00FF ;
+    temp &= 0x0F ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x0D , temp ) ;		/* 0x0D vertical Retrace End */
+
+    if ( tempbx & 0x0010 )
+    {
+        tempcx |= 0x2000 ;
+    }
+
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x0A , temp ) ;		/* 0x0A CR07 */
+    temp = ( tempcx & 0x0FF00 ) >> 8 ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x17 , temp ) ;		/* 0x17 SR0A */
+    tempax = modeflag ;
+    temp = ( tempax & 0xFF00 ) >> 8 ;
+
+    temp = ( temp >> 1 ) & 0x09 ;
+
+    if ( pVBInfo->VBType & ( VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        temp |= 0x01 ;
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x16 , temp ) ;			/* 0x16 SR01 */
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x0F , 0 ) ;			/* 0x0F CR14 */
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x12 , 0 ) ;			/* 0x12 CR17 */
+
+    if ( pVBInfo->LCDInfo & LCDRGB18Bit )
+        temp = 0x80 ;
+    else
+        temp = 0x00 ;
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x1A , temp ) ;			/* 0x1A SR0E */
+
+    return ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetGroup2 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetGroup2( USHORT ModeNo, USHORT ModeIdIndex, USHORT RefreshRateTableIndex,
+                    PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT i ,
+           j ,
+           tempax ,
+           tempbx ,
+           tempcx ,
+           temp ,
+           push1 ,
+           push2 ,
+           modeflag ,
+           resinfo ,
+           crt2crtc ;
+#ifndef LINUX_XF86
+   USHORT  temp1 ,
+           temp3 ,
+           resindex ,
+           xres ;
+#endif
+/*           XGINew_RY1COE = 0 ,
+           XGINew_RY2COE = 0 ,
+           XGINew_RY3COE = 0 ,
+           XGINew_RY4COE = 0 ,
+           XGINew_RY5COE = 0 ,
+           XGINew_RY6COE = 0 ,
+           XGINew_RY7COE = 0 ;
+*/
+#ifndef LINUX_XF86
+    UCHAR *PhasePoint ;
+#endif
+    UCHAR *TimingPoint ;
+
+    ULONG longtemp ,
+          tempeax ,
+          tempebx ,
+          temp2 ,
+          tempecx ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;		/* si+St_ResInfo */
+        resinfo = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ResInfo ;
+        crt2crtc = pVBInfo->SModeIDTable[ ModeIdIndex ].St_CRT2CRTC ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;		/* si+Ext_ResInfo */
+        resinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;
+        crt2crtc = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT2CRTC ;
+    }
+
+    tempax = 0 ;
+
+    if ( !( pVBInfo->VBInfo & SetCRT2ToAVIDEO ) )
+        tempax |= 0x0800 ;
+
+    if ( !( pVBInfo->VBInfo & SetCRT2ToSVIDEO ) )
+        tempax |= 0x0400 ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToSCART )
+        tempax |= 0x0200 ;
+
+    if ( !( pVBInfo->TVInfo & SetPALTV ) )
+        tempax |= 0x1000 ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+        tempax |= 0x0100 ;
+
+    if ( pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p ) )
+        tempax &= 0xfe00 ;
+
+    tempax = ( tempax & 0xff00 ) >> 8 ;
+
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x0 , tempax ) ;
+    TimingPoint = pVBInfo->NTSCTiming ;
+
+    if ( pVBInfo->TVInfo & SetPALTV )
+    {
+        TimingPoint = pVBInfo->PALTiming ;
+    }
+
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+    {
+        TimingPoint = pVBInfo->HiTVExtTiming ;
+
+        if ( pVBInfo->VBInfo & SetInSlaveMode )
+            TimingPoint = pVBInfo->HiTVSt2Timing ;
+
+        if ( pVBInfo->SetFlag & TVSimuMode )
+            TimingPoint = pVBInfo->HiTVSt1Timing ;
+
+        if ( !(modeflag & Charx8Dot) )
+            TimingPoint = pVBInfo->HiTVTextTiming ;
+    }
+
+    if ( pVBInfo->VBInfo & SetCRT2ToYPbPr )
+    {
+        if ( pVBInfo->TVInfo & SetYPbPrMode525i )
+            TimingPoint = pVBInfo->YPbPr525iTiming ;
+
+        if ( pVBInfo->TVInfo & SetYPbPrMode525p )
+    	    TimingPoint = pVBInfo->YPbPr525pTiming ;
+
+        if ( pVBInfo->TVInfo & SetYPbPrMode750p )
+    	    TimingPoint = pVBInfo->YPbPr750pTiming ;
+    }
+
+    for( i = 0x01 , j = 0 ; i <= 0x2D ; i++ , j++ )
+    {
+        XGINew_SetReg1( pVBInfo->Part2Port , i , TimingPoint[ j ] ) ;
+    }
+
+    for( i = 0x39 ; i <= 0x45 ; i++ , j++ )
+    {
+        XGINew_SetReg1( pVBInfo->Part2Port , i , TimingPoint[ j ] ) ;	/* di->temp2[j] */
+    }
+
+    if ( pVBInfo->VBInfo & SetCRT2ToTV )
+    {
+        XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x3A , 0x1F , 0x00 ) ;
+    }
+
+    temp = pVBInfo->NewFlickerMode ;
+    temp &= 0x80 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x0A , 0xFF , temp ) ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+        tempax = 950 ;
+
+    if ( pVBInfo->TVInfo & SetPALTV )
+        tempax = 520 ;
+    else
+        tempax = 440 ;
+
+    if ( pVBInfo->VDE <= tempax )
+    {
+        tempax -= pVBInfo->VDE ;
+        tempax = tempax >> 2 ;
+        tempax = ( tempax & 0x00FF ) | ( ( tempax & 0x00FF ) << 8 ) ;
+        push1 = tempax ;
+        temp = ( tempax & 0xFF00 ) >> 8 ;
+        temp += ( USHORT )TimingPoint[ 0 ] ;
+
+        if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        {
+            if ( pVBInfo->VBInfo & ( SetCRT2ToAVIDEO | SetCRT2ToSVIDEO | SetCRT2ToSCART | SetCRT2ToYPbPr ) )
+            {
+                tempcx=pVBInfo->VGAHDE;
+                if ( tempcx >= 1024 )
+                {
+                    temp = 0x17 ;		/* NTSC */
+                    if ( pVBInfo->TVInfo & SetPALTV )
+                        temp = 0x19 ;		/* PAL */
+                }
+            }
+        }
+
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x01 , temp ) ;
+        tempax = push1 ;
+        temp = ( tempax & 0xFF00 ) >> 8 ;
+        temp += TimingPoint[ 1 ] ;
+
+        if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        {
+            if ( ( pVBInfo->VBInfo & ( SetCRT2ToAVIDEO | SetCRT2ToSVIDEO | SetCRT2ToSCART | SetCRT2ToYPbPr ) ) )
+            {
+                tempcx = pVBInfo->VGAHDE ;
+                if ( tempcx >= 1024 )
+                {
+                    temp = 0x1D ;		/* NTSC */
+                    if ( pVBInfo->TVInfo & SetPALTV )
+                        temp = 0x52 ;		/* PAL */
+                }
+            }
+        }
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x02 , temp ) ;
+    }
+
+    /* 301b */
+    tempcx = pVBInfo->HT ;
+
+    if ( XGI_IsLCDDualLink( pVBInfo ) )
+        tempcx = tempcx >> 1 ;
+
+    tempcx -= 2 ;
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x1B , temp ) ;
+
+    temp = ( tempcx & 0xFF00 ) >> 8 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x1D , ~0x0F , temp ) ;
+
+    tempcx = pVBInfo->HT >> 1 ;
+    push1 = tempcx ;				/* push cx */
+    tempcx += 7 ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+    {
+        tempcx -= 4 ;
+    }
+
+    temp = tempcx & 0x00FF ;
+    temp = temp << 4 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x22 , 0x0F , temp ) ;
+
+    tempbx = TimingPoint[ j ] | ( ( TimingPoint[ j + 1 ] ) << 8 ) ;
+    tempbx += tempcx ;
+    push2 = tempbx ;
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x24 , temp ) ;
+    temp = ( tempbx & 0xFF00 ) >> 8 ;
+    temp = temp << 4 ;
+    XGINew_SetRegANDOR(pVBInfo->Part2Port,0x25,0x0F,temp);
+
+    tempbx=push2;
+    tempbx=tempbx+8;
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+    {
+        tempbx=tempbx-4;
+        tempcx=tempbx;
+    }
+
+    temp = ( tempbx & 0x00FF ) << 4 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x29 , 0x0F , temp ) ;
+
+    j += 2 ;
+    tempcx += ( TimingPoint[ j ] | ( ( TimingPoint[ j + 1 ] ) << 8 ) ) ;
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x27 , temp ) ;
+    temp = ( ( tempcx & 0xFF00 ) >> 8 ) << 4 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x28 , 0x0F , temp ) ;
+
+    tempcx += 8 ;
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+    {
+        tempcx -= 4 ;
+    }
+
+    temp = tempcx & 0xFF ;
+    temp = temp << 4 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x2A , 0x0F , temp ) ;
+
+    tempcx = push1 ;					/* pop cx */
+    j += 2 ;
+    temp = TimingPoint[ j ] | ( ( TimingPoint[ j + 1 ] ) << 8 ) ;
+    tempcx -= temp ;
+    temp = tempcx & 0x00FF ;
+    temp = temp << 4 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x2D , 0x0F ,temp ) ;
+
+    tempcx -= 11 ;
+
+    if ( !( pVBInfo->VBInfo & SetCRT2ToTV ) )
+    {
+        tempax = XGI_GetVGAHT2( pVBInfo) ;
+        tempcx = tempax - 1 ;
+    }
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x2E , temp ) ;
+
+    tempbx = pVBInfo->VDE ;
+
+    if ( pVBInfo->VGAVDE == 360 )
+        tempbx = 746 ;
+    if ( pVBInfo->VGAVDE == 375 )
+        tempbx = 746 ;
+    if ( pVBInfo->VGAVDE == 405 )
+        tempbx = 853 ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToTV )
+    {
+        if ( pVBInfo->VBType & ( VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        {
+            if ( !( pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p ) ) )
+                tempbx = tempbx >> 1 ;
+        }
+        else
+            tempbx = tempbx >> 1 ;
+    }
+
+    tempbx -= 2 ;
+    temp = tempbx & 0x00FF ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+    {
+        if ( pVBInfo->VBType & VB_XGI301LV )
+        {
+            if ( pVBInfo->TVInfo & SetYPbPrMode1080i )
+            {
+                if ( pVBInfo->VBInfo & SetInSlaveMode )
+                {
+                    if ( ModeNo == 0x2f )
+                        temp += 1 ;
+                }
+            }
+        }
+        else
+        {
+            if ( pVBInfo->VBInfo & SetInSlaveMode )
+            {
+                if ( ModeNo == 0x2f )
+                    temp += 1 ;
+            }
+        }
+    }
+
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x2F , temp ) ;
+
+    temp = ( tempcx & 0xFF00 ) >> 8 ;
+    temp |= ( ( tempbx & 0xFF00 ) >> 8 ) << 6 ;
+
+    if ( !( pVBInfo->VBInfo & SetCRT2ToHiVisionTV ) )
+    {
+        if ( pVBInfo->VBType & VB_XGI301LV )
+        {
+            if ( pVBInfo->TVInfo & SetYPbPrMode1080i )
+            {
+                temp |= 0x10 ;
+
+                if ( !( pVBInfo->VBInfo & SetCRT2ToSVIDEO ) )
+                    temp |= 0x20 ;
+            }
+        }
+        else
+        {
+            temp |= 0x10 ;
+            if ( !( pVBInfo->VBInfo & SetCRT2ToSVIDEO ) )
+                temp |= 0x20 ;
+        }
+    }
+
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x30 , temp ) ;
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )	/* TV gatingno */
+    {
+        tempbx = pVBInfo->VDE ;
+        tempcx = tempbx - 2 ;
+
+        if ( pVBInfo->VBInfo & SetCRT2ToTV )
+        {
+            if ( !( pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p ) ) )
+                tempbx = tempbx >> 1 ;
+        }
+
+        if ( pVBInfo->VBType & ( VB_XGI302LV | VB_XGI301C ) )
+        {
+            temp=0;
+            if( tempcx & 0x0400 )
+                temp |= 0x20 ;
+
+            if ( tempbx & 0x0400 )
+                temp |= 0x40 ;
+
+            XGINew_SetReg1( pVBInfo->Part4Port , 0x10 , temp ) ;
+        }
+
+        temp = ( ( ( tempbx - 3 ) & 0x0300 ) >> 8 ) << 5 ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x46 , temp ) ;
+        temp = ( tempbx - 3 ) & 0x00FF ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x47 , temp ) ;
+    }
+
+    tempbx = tempbx & 0x00FF ;
+
+    if ( !( modeflag & HalfDCLK ) )
+    {
+        tempcx = pVBInfo->VGAHDE ;
+        if ( tempcx >= pVBInfo->HDE )
+        {
+            tempbx |= 0x2000 ;
+            tempax &= 0x00FF ;
+        }
+    }
+
+    tempcx = 0x0101 ;
+
+    if( pVBInfo->VBInfo & SetCRT2ToTV ) { /*301b*/
+        if(pVBInfo->VGAHDE>=1024)
+        {
+	    tempcx=0x1920;
+            if(pVBInfo->VGAHDE>=1280)
+            {
+	        tempcx=0x1420;
+	        tempbx=tempbx&0xDFFF;
+            }
+        }
+    }
+
+    if ( !( tempbx & 0x2000 ) )
+    {
+        if ( modeflag & HalfDCLK )
+        {
+            tempcx = ( tempcx & 0xFF00 ) | ( ( tempcx & 0x00FF ) << 1 ) ;
+	}
+
+        push1 = tempbx ;
+        tempeax = pVBInfo->VGAHDE ;
+        tempebx = ( tempcx & 0xFF00 ) >> 8 ;
+        longtemp = tempeax * tempebx ;
+        tempecx = tempcx & 0x00FF ;
+        longtemp = longtemp / tempecx ;
+
+	/* 301b */
+        tempecx = 8 * 1024 ;
+
+        if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        {
+            tempecx = tempecx * 8 ;
+        }
+
+        longtemp = longtemp * tempecx ;
+        tempecx = pVBInfo->HDE ;
+        temp2 = longtemp % tempecx ;
+        tempeax = longtemp / tempecx ;
+        if ( temp2 != 0 )
+        {
+            tempeax += 1 ;
+        }
+
+        tempax = ( USHORT )tempeax ;
+
+	/* 301b */
+        if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        {
+            tempcx = ( ( tempax & 0xFF00 ) >> 5 ) >> 8 ;
+        }
+        /* end 301b */
+
+        tempbx = push1 ;
+        tempbx =( USHORT )( ( ( tempeax & 0x0000FF00 ) & 0x1F00 ) | ( tempbx & 0x00FF ) ) ;
+        tempax =( USHORT )( ( ( tempeax & 0x000000FF ) << 8 ) | ( tempax & 0x00FF ) ) ;
+        temp = ( tempax & 0xFF00 ) >> 8 ;
+    }
+    else
+    {
+        temp = ( tempax & 0x00FF ) >> 8 ;
+    }
+
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x44 , temp ) ;
+    temp = ( tempbx & 0xFF00 ) >> 8 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x45 , ~0x03F , temp ) ;
+    temp = tempcx & 0x00FF ;
+
+    if ( tempbx & 0x2000 )
+        temp = 0 ;
+
+    if ( !( pVBInfo->VBInfo & SetCRT2ToLCD ) )
+        temp |= 0x18 ;
+
+    XGINew_SetRegANDOR(pVBInfo->Part2Port,0x46,~0x1F,temp);
+    if ( pVBInfo->TVInfo & SetPALTV )
+    {
+        tempbx = 0x0382 ;
+        tempcx = 0x007e ;
+    }
+    else
+    {
+        tempbx = 0x0369 ;
+        tempcx = 0x0061 ;
+    }
+
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x4b , temp ) ;
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x4c , temp ) ;
+
+    temp = ( ( tempcx & 0xFF00 ) >> 8 ) & 0x03 ;
+    temp = temp << 2 ;
+    temp |= ( ( tempbx & 0xFF00 ) >> 8 ) & 0x03 ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToYPbPr )
+    {
+        temp |= 0x10 ;
+
+        if ( pVBInfo->TVInfo & SetYPbPrMode525p )
+            temp |= 0x20 ;
+
+        if ( pVBInfo->TVInfo & SetYPbPrMode750p )
+            temp |= 0x60 ;
+    }
+
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x4d , temp ) ;
+    temp=XGINew_GetReg1( pVBInfo->Part2Port , 0x43 ) ;		/* 301b change */
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x43 , ( USHORT )( temp - 3 ) ) ;
+
+    if ( !( pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p ) ) )
+    {
+        if ( pVBInfo->TVInfo & NTSC1024x768 )
+        {
+            TimingPoint = XGI_NTSC1024AdjTime ;
+            for( i = 0x1c , j = 0 ; i <= 0x30 ; i++ , j++ )
+            {
+                XGINew_SetReg1( pVBInfo->Part2Port , i , TimingPoint[ j ] ) ;
+            }
+            XGINew_SetReg1( pVBInfo->Part2Port , 0x43 , 0x72 ) ;
+        }
+    }
+
+    /* [ycchen] 01/14/03 Modify for 301C PALM Support */
+    if ( pVBInfo->VBType & VB_XGI301C )
+    {
+        if ( pVBInfo->TVInfo & SetPALMTV )
+	    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x4E , ~0x08 , 0x08 ) ;	/* PALM Mode */
+    }
+
+    if ( pVBInfo->TVInfo & SetPALMTV )
+    {
+        tempax = ( UCHAR )XGINew_GetReg1( pVBInfo->Part2Port , 0x01 ) ;
+        tempax-- ;
+        XGINew_SetRegAND( pVBInfo->Part2Port , 0x01 , tempax ) ;
+
+        /* if ( !( pVBInfo->VBType & VB_XGI301C ) ) */
+        XGINew_SetRegAND( pVBInfo->Part2Port , 0x00 , 0xEF ) ;
+    }
+
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+    {
+        if ( !( pVBInfo->VBInfo & SetInSlaveMode ) )
+        {
+            XGINew_SetReg1( pVBInfo->Part2Port , 0x0B , 0x00 ) ;
+        }
+    }
+
+    if ( pVBInfo->VBInfo & SetCRT2ToTV )
+    {
+        return ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetLCDRegs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void  XGI_SetLCDRegs(USHORT ModeNo,USHORT ModeIdIndex, PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT push1 ,
+           push2 ,
+           pushbx ,
+           tempax ,
+           tempbx ,
+           tempcx ,
+           temp ,
+           tempah ,
+           tempbh ,
+           tempch ,
+           resinfo ,
+           modeflag ,
+           CRT1Index ;
+
+    XGI_LCDDesStruct *LCDBDesPtr = NULL ;
+
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;	/* si+St_ResInfo */
+        resinfo = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ResInfo ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;	/* si+Ext_ResInfo */
+        resinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;
+        CRT1Index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT1CRTC ;
+        CRT1Index &= IndexMask ;
+    }
+
+    if ( !( pVBInfo->VBInfo & SetCRT2ToLCD ) )
+    {
+        return ;
+    }
+
+    tempbx = pVBInfo->HDE ;			/* RHACTE=HDE-1 */
+
+    if ( XGI_IsLCDDualLink( pVBInfo ) )
+        tempbx = tempbx >> 1 ;
+
+    tempbx -= 1 ;
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x2C , temp ) ;
+    temp = ( tempbx & 0xFF00 ) >> 8 ;
+    temp = temp << 4 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x2B , 0x0F , temp ) ;
+    temp = 0x01 ;
+
+    if ( pVBInfo->LCDResInfo == Panel1280x1024 )
+    {
+        if ( pVBInfo->ModeType == ModeEGA )
+        {
+            if ( pVBInfo->VGAHDE >= 1024 )
+            {
+                temp = 0x02 ;
+                if ( pVBInfo->LCDInfo & LCDVESATiming )
+                    temp = 0x01 ;
+            }
+        }
+    }
+
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x0B , temp ) ;
+    tempbx = pVBInfo->VDE ;			/* RTVACTEO=(VDE-1)&0xFF */
+    push1 = tempbx ;
+    tempbx-- ;
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x03 , temp ) ;
+    temp = ( ( tempbx & 0xFF00 ) >> 8 ) & 0x07 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x0C , ~0x07 , temp ) ;
+
+    tempcx = pVBInfo->VT - 1 ;
+    push2 = tempcx + 1 ;
+    temp = tempcx & 0x00FF ;			/* RVTVT=VT-1 */
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x19 , temp ) ;
+    temp = ( tempcx & 0xFF00 ) >> 8 ;
+    temp = temp << 5 ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x1A , temp ) ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x09 , 0xF0 , 0x00 ) ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x0A , 0xF0 , 0x00 ) ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x17 , 0xFB , 0x00 ) ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x18 , 0xDF , 0x00 ) ;
+
+    /* Customized LCDB Des no add */
+    tempbx = 5 ;
+    LCDBDesPtr = ( XGI_LCDDesStruct * )XGI_GetLcdPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+    tempah = pVBInfo->LCDResInfo ;
+    tempah &= PanelResInfo ;
+
+    if ( ( tempah == Panel1024x768 ) || ( tempah == Panel1024x768x75 ) )
+    {
+        tempbx = 1024 ;
+        tempcx = 768 ;
+    }
+    else if ( ( tempah == Panel1280x1024 ) || ( tempah == Panel1280x1024x75 ) )
+    {
+        tempbx = 1280 ;
+        tempcx = 1024 ;
+    }
+    else if ( tempah == Panel1400x1050 )
+    {
+        tempbx = 1400 ;
+        tempcx = 1050 ;
+    }
+    else
+    {
+        tempbx = 1600 ;
+        tempcx = 1200 ;
+    }
+
+    if ( pVBInfo->LCDInfo & EnableScalingLCD )
+    {
+        tempbx = pVBInfo->HDE ;
+        tempcx = pVBInfo->VDE ;
+    }
+
+    pushbx = tempbx ;
+    tempax = pVBInfo->VT ;
+    pVBInfo->LCDHDES = LCDBDesPtr->LCDHDES ;
+    pVBInfo->LCDHRS = LCDBDesPtr->LCDHRS ;
+    pVBInfo->LCDVDES = LCDBDesPtr->LCDVDES ;
+    pVBInfo->LCDVRS = LCDBDesPtr->LCDVRS ;
+    tempbx = pVBInfo->LCDVDES ;
+    tempcx += tempbx ;
+
+    if ( tempcx >= tempax )
+        tempcx -= tempax ;	/* lcdvdes */
+
+    temp = tempbx & 0x00FF ;	/* RVEQ1EQ=lcdvdes */
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x05 , temp ) ;
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x06 , temp ) ;
+    tempch = ( ( tempcx & 0xFF00 ) >> 8 ) & 0x07 ;
+    tempbh = ( ( tempbx & 0xFF00 ) >> 8 ) & 0x07 ;
+    tempah = tempch ;
+    tempah = tempah << 3 ;
+    tempah |= tempbh ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x02 , tempah ) ;
+
+    /* getlcdsync() */
+    XGI_GetLCDSync( &tempax , &tempbx,pVBInfo ) ;
+    tempcx = tempbx ;
+    tempax = pVBInfo->VT ;
+    tempbx = pVBInfo->LCDVRS ;
+
+    /* if ( SetLCD_Info & EnableScalingLCD ) */
+    tempcx += tempbx ;
+    if ( tempcx >= tempax )
+        tempcx -= tempax ;
+
+    temp = tempbx & 0x00FF ;	/* RTVACTEE=lcdvrs */
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x04 , temp ) ;
+    temp = ( tempbx & 0xFF00 ) >> 8 ;
+    temp = temp << 4 ;
+    temp |= ( tempcx & 0x000F ) ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x01 , temp ) ;
+    tempcx = pushbx ;
+    tempax = pVBInfo->HT ;
+    tempbx = pVBInfo->LCDHDES ;
+    tempbx &= 0x0FFF ;
+
+    if ( XGI_IsLCDDualLink(  pVBInfo ) )
+    {
+        tempax = tempax >> 1 ;
+        tempbx = tempbx >> 1 ;
+        tempcx = tempcx >> 1 ;
+    }
+
+    if ( pVBInfo->VBType & VB_XGI302LV )
+        tempbx += 1 ;
+
+    if ( pVBInfo->VBType & VB_XGI301C )  /* tap4 */
+        tempbx += 1 ;
+
+    tempcx += tempbx ;
+
+    if ( tempcx >= tempax )
+        tempcx -= tempax ;
+
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x1F , temp ) ;	/* RHBLKE=lcdhdes */
+    temp = ( ( tempbx & 0xFF00 ) >> 8 ) << 4 ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x20 , temp ) ;
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x23 , temp ) ;	/* RHEQPLE=lcdhdee */
+    temp = ( tempcx & 0xFF00 ) >> 8 ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x25 , temp ) ;
+
+    /* getlcdsync() */
+    XGI_GetLCDSync( &tempax , &tempbx ,pVBInfo) ;
+    tempcx = tempax ;
+    tempax = pVBInfo->HT ;
+    tempbx = pVBInfo->LCDHRS ;
+    /* if ( SetLCD_Info & EnableScalingLCD) */
+    if ( XGI_IsLCDDualLink( pVBInfo) )
+    {
+        tempax = tempax >> 1 ;
+        tempbx = tempbx >> 1 ;
+        tempcx = tempcx >> 1 ;
+    }
+
+    if ( pVBInfo->VBType & VB_XGI302LV )
+        tempbx += 1 ;
+
+    tempcx += tempbx ;
+
+    if ( tempcx >= tempax )
+        tempcx -= tempax ;
+
+    temp = tempbx & 0x00FF ;	/* RHBURSTS=lcdhrs */
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x1C , temp ) ;
+
+    temp = ( tempbx & 0xFF00 ) >> 8 ;
+    temp = temp << 4 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x1D , ~0x0F0 , temp ) ;
+    temp = tempcx & 0x00FF ;	/* RHSYEXP2S=lcdhre */
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x21 , temp ) ;
+
+    if ( !( pVBInfo->LCDInfo & LCDVESATiming ) )
+    {
+        if ( pVBInfo->VGAVDE == 525 )
+        {
+            if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+            {
+                temp = 0xC6 ;
+            }
+            else
+                temp = 0xC4 ;
+
+            XGINew_SetReg1( pVBInfo->Part2Port , 0x2f , temp ) ;
+            XGINew_SetReg1( pVBInfo->Part2Port , 0x30 , 0xB3 ) ;
+        }
+
+        if ( pVBInfo->VGAVDE == 420 )
+        {
+            if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+            {
+                temp = 0x4F ;
+            }
+            else
+                temp = 0x4E ;
+            XGINew_SetReg1( pVBInfo->Part2Port , 0x2f , temp ) ;
+        }
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetTap4Ptr */
+/* Input : */
+/* Output : di -> Tap4 Reg. Setting Pointer */
+/* Description : */
+/* --------------------------------------------------------------------- */
+XGI301C_Tap4TimingStruct* XGI_GetTap4Ptr(USHORT tempcx, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempax ,
+           tempbx ,
+           i ;
+
+    XGI301C_Tap4TimingStruct *Tap4TimingPtr ;
+
+    if ( tempcx == 0 )
+    {
+        tempax = pVBInfo->VGAHDE ;
+        tempbx = pVBInfo->HDE ;
+    }
+    else
+    {
+        tempax = pVBInfo->VGAVDE ;
+        tempbx = pVBInfo->VDE ;
+    }
+
+    if ( tempax < tempbx )
+        return &EnlargeTap4Timing[ 0 ] ;
+    else if( tempax == tempbx )
+        return &NoScaleTap4Timing[ 0 ] ; 	/* 1:1 */
+    else
+        Tap4TimingPtr = NTSCTap4Timing ; 	/* NTSC */
+
+    if ( pVBInfo->TVInfo & SetPALTV )
+        Tap4TimingPtr = PALTap4Timing ;
+
+
+    if ( pVBInfo->VBInfo & SetCRT2ToYPbPr )
+    {
+        if ( pVBInfo->TVInfo & SetYPbPrMode525i )
+            Tap4TimingPtr = YPbPr525iTap4Timing ;
+        if ( pVBInfo->TVInfo & SetYPbPrMode525p )
+            Tap4TimingPtr = YPbPr525pTap4Timing ;
+        if ( pVBInfo->TVInfo & SetYPbPrMode750p )
+            Tap4TimingPtr = YPbPr750pTap4Timing ;
+    }
+
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+        Tap4TimingPtr = HiTVTap4Timing ;
+
+    i = 0 ;
+    while( Tap4TimingPtr[ i ].DE != 0xFFFF )
+    {
+        if ( Tap4TimingPtr[ i ].DE == tempax )
+            break ;
+        i++ ;
+    }
+    return &Tap4TimingPtr[ i ] ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetTap4Regs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetTap4Regs( PVB_DEVICE_INFO pVBInfo)
+{
+
+#ifndef LINUX_XF86
+    USHORT tempcx ;
+#endif
+    USHORT i ,
+           j ;
+
+    XGI301C_Tap4TimingStruct *Tap4TimingPtr ;
+
+    if ( !( pVBInfo->VBType & VB_XGI301C ) )
+        return ;
+
+#ifndef Tap4
+    XGINew_SetRegAND( pVBInfo->Part2Port , 0x4E , 0xEB ) ;	/* Disable Tap4 */
+#else            /* Tap4 Setting */
+
+    Tap4TimingPtr = XGI_GetTap4Ptr( 0 , pVBInfo) ;  /* Set Horizontal Scaling */
+    for( i = 0x80 , j = 0 ; i <= 0xBF ; i++ , j++ )
+        XGINew_SetReg1( pVBInfo->Part2Port , i , Tap4TimingPtr->Reg[ j ] ) ;
+
+    if ( ( pVBInfo->VBInfo & SetCRT2ToTV ) && ( !( pVBInfo->VBInfo & SetCRT2ToHiVisionTV ) ) )
+    {
+        Tap4TimingPtr = XGI_GetTap4Ptr( 1 , pVBInfo);	/* Set Vertical Scaling */
+        for( i = 0xC0 , j = 0 ; i < 0xFF ; i++ , j++ )
+            XGINew_SetReg1( pVBInfo->Part2Port , i , Tap4TimingPtr->Reg[ j ] ) ;
+    }
+
+    if ( ( pVBInfo->VBInfo & SetCRT2ToTV ) && ( !( pVBInfo->VBInfo & SetCRT2ToHiVisionTV ) ) )
+        XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x4E , ~0x14 , 0x04 ) ;	/* Enable V.Scaling */
+    else
+        XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x4E , ~0x14 , 0x10 ) ;	/* Enable H.Scaling */
+#endif
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetGroup3 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetGroup3(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT i;
+    UCHAR *tempdi;
+    USHORT  modeflag;
+
+    if(ModeNo<=0x13)
+    {
+        modeflag = pVBInfo->SModeIDTable[ModeIdIndex].St_ModeFlag;      /* si+St_ResInfo */
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ModeIdIndex].Ext_ModeFlag;     /* si+Ext_ResInfo */
+    }
+
+
+    XGINew_SetReg1(pVBInfo->Part3Port,0x00,0x00);
+    if(pVBInfo->TVInfo&SetPALTV)
+    {
+        XGINew_SetReg1(pVBInfo->Part3Port,0x13,0xFA);
+        XGINew_SetReg1(pVBInfo->Part3Port,0x14,0xC8);
+    }
+    else
+    {
+        XGINew_SetReg1(pVBInfo->Part3Port,0x13,0xF5);
+        XGINew_SetReg1(pVBInfo->Part3Port,0x14,0xB7);
+    }
+
+    if(!(pVBInfo->VBInfo&SetCRT2ToTV))
+    {
+        return;
+    }
+
+    if(pVBInfo->TVInfo&SetPALMTV)
+    {
+        XGINew_SetReg1(pVBInfo->Part3Port,0x13,0xFA);
+        XGINew_SetReg1(pVBInfo->Part3Port,0x14,0xC8);
+        XGINew_SetReg1(pVBInfo->Part3Port,0x3D,0xA8);
+    }
+
+    if((pVBInfo->VBInfo&SetCRT2ToHiVisionTV)|| (pVBInfo->VBInfo&SetCRT2ToYPbPr))
+    {
+        if(pVBInfo->TVInfo & SetYPbPrMode525i)
+        {
+            return;
+        }
+        tempdi=pVBInfo->HiTVGroup3Data;
+        if(pVBInfo->SetFlag&TVSimuMode)
+        {
+            tempdi=pVBInfo->HiTVGroup3Simu;
+            if(!(modeflag&Charx8Dot))
+            {
+                tempdi=pVBInfo->HiTVGroup3Text;
+            }
+        }
+
+        if(pVBInfo->TVInfo & SetYPbPrMode525p)
+        {
+            tempdi=pVBInfo->Ren525pGroup3;
+        }
+        if(pVBInfo->TVInfo & SetYPbPrMode750p)
+        {
+             tempdi=pVBInfo->Ren750pGroup3;
+        }
+
+        for(i=0;i<=0x3E;i++)
+        {
+            XGINew_SetReg1(pVBInfo->Part3Port,i,tempdi[i]);
+        }
+        if(pVBInfo->VBType&VB_XGI301C)  /* Marcovision */
+        {
+            if(pVBInfo->TVInfo & SetYPbPrMode525p)
+            {
+                XGINew_SetReg1(pVBInfo->Part3Port,0x28,0x3f);
+            }
+        }
+    }
+    return;
+}  /* {end of XGI_SetGroup3} */
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetGroup4 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetGroup4(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempax ,
+           tempcx ,
+           tempbx ,
+           modeflag ,
+           temp ,
+           temp2 ;
+#ifndef LINUX_XF86
+    USHORT push1 ;
+#endif
+
+    ULONG tempebx ,
+          tempeax ,
+          templong ;
+
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;	/* si+St_ResInfo */
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;	/* si+Ext_ResInfo */
+    }
+
+    temp = pVBInfo->RVBHCFACT ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x13 , temp ) ;
+
+    tempbx = pVBInfo->RVBHCMAX ;
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x14 , temp ) ;
+    temp2 = ( ( tempbx & 0xFF00 ) >> 8 ) << 7 ;
+    tempcx = pVBInfo->VGAHT - 1 ;
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x16 , temp ) ;
+
+    temp =( ( tempcx & 0xFF00 ) >> 8 ) << 3 ;
+    temp2 |= temp ;
+
+    tempcx = pVBInfo->VGAVT - 1 ;
+    if ( !( pVBInfo->VBInfo & SetCRT2ToTV ) )
+    {
+        tempcx -= 5 ;
+    }
+
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x17 , temp ) ;
+    temp = temp2 | ( ( tempcx & 0xFF00 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x15 , temp ) ;
+    XGINew_SetRegOR( pVBInfo->Part4Port , 0x0D , 0x08 ) ;
+    tempcx = pVBInfo->VBInfo ;
+    tempbx = pVBInfo->VGAHDE ;
+
+    if ( modeflag & HalfDCLK )
+    {
+        tempbx = tempbx >> 1 ;
+    }
+
+    if ( XGI_IsLCDDualLink( pVBInfo ) )
+        tempbx = tempbx >> 1 ;
+
+    if(tempcx&SetCRT2ToHiVisionTV)
+    {
+        temp=0;
+        if(tempbx<=1024)
+            temp=0xA0;
+       if(tempbx == 1280)
+          temp = 0xC0;
+    }
+    else if(tempcx&SetCRT2ToTV)
+    {
+         temp=0xA0;
+         if(tempbx <= 800)
+             temp=0x80;
+    }
+    else
+    {
+	 temp=0x80;
+	 if(pVBInfo->VBInfo&SetCRT2ToLCD)
+	 {
+	     temp=0;
+	     if(tempbx>800)
+	         temp=0x60;
+	 }
+    }
+
+    if ( pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p ) )
+    {
+        temp = 0x00 ;
+        if ( pVBInfo->VGAHDE == 1280 )
+            temp = 0x40 ;
+        if ( pVBInfo->VGAHDE == 1024 )
+	    temp = 0x20 ;
+    }
+    XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x0E , ~0xEF , temp ) ;
+
+    tempebx = pVBInfo->VDE ;
+
+    if ( tempcx & SetCRT2ToHiVisionTV )
+    {
+        if ( !( temp & 0xE000 ) )
+            tempbx = tempbx >> 1 ;
+    }
+
+    tempcx = pVBInfo->RVBHRS ;
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x18 , temp );
+
+    tempeax = pVBInfo->VGAVDE ;
+    tempcx |= 0x04000 ;
+
+
+    if ( tempeax <= tempebx )
+    {
+        tempcx=(tempcx&(~0x4000));
+        tempeax = pVBInfo->VGAVDE ;
+    }
+    else
+    {
+        tempeax -= tempebx ;
+    }
+
+
+    templong = ( tempeax * 256 * 1024 ) % tempebx ;
+    tempeax = ( tempeax * 256 * 1024 ) / tempebx ;
+    tempebx = tempeax ;
+
+    if ( templong != 0 )
+    {
+        tempebx++ ;
+    }
+
+
+    temp = ( USHORT )( tempebx & 0x000000FF ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x1B , temp ) ;
+
+    temp = ( USHORT )( ( tempebx & 0x0000FF00 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x1A , temp ) ;
+    tempbx = ( USHORT )( tempebx >> 16 ) ;
+    temp = tempbx & 0x00FF ;
+    temp = temp << 4 ;
+    temp |= ( ( tempcx & 0xFF00 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x19 , temp ) ;
+
+    /* 301b */
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        temp = 0x0028 ;
+        XGINew_SetReg1( pVBInfo->Part4Port , 0x1C , temp ) ;
+        tempax = pVBInfo->VGAHDE ;
+        if ( modeflag & HalfDCLK )
+        {
+            tempax = tempax >> 1 ;
+        }
+
+        if ( XGI_IsLCDDualLink( pVBInfo ) )
+            tempax = tempax >> 1 ;
+
+        /* if((pVBInfo->VBInfo&(SetCRT2ToLCD))||((pVBInfo->TVInfo&SetYPbPrMode525p)||(pVBInfo->TVInfo&SetYPbPrMode750p))) { */
+        if ( pVBInfo->VBInfo & SetCRT2ToLCD )
+        {
+            if ( tempax > 800 )
+                tempax -= 800 ;
+        }
+        else
+        {
+            if ( pVBInfo->VGAHDE > 800 )
+            {
+                if ( pVBInfo->VGAHDE == 1024 )
+                    tempax = ( tempax * 25 / 32 ) - 1 ;
+                else
+                    tempax = ( tempax * 20 / 32 ) - 1 ;
+            }
+        }
+        tempax -= 1 ;
+
+/*
+        if ( pVBInfo->VBInfo & ( SetCRT2ToTV | SetCRT2ToHiVisionTV ) )
+        {
+            if ( pVBInfo->VBType & VB_XGI301LV )
+            {
+                if ( !( pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p | SetYPbPrMode1080i ) ) )
+                {
+                    if ( pVBInfo->VGAHDE > 800 )
+                    {
+                        if ( pVBInfo->VGAHDE == 1024 )
+                            tempax = ( tempax * 25 / 32 ) - 1 ;
+                        else
+                            tempax = ( tempax * 20 / 32 ) - 1 ;
+                    }
+                }
+            }
+            else
+            {
+                if ( pVBInfo->VGAHDE > 800 )
+                {
+                    if ( pVBInfo->VGAHDE == 1024 )
+                        tempax = ( tempax * 25 / 32 ) - 1 ;
+                    else
+                        tempax = ( tempax * 20 / 32 ) - 1 ;
+                }
+            }
+        }
+*/
+
+        temp = ( tempax & 0xFF00 ) >> 8 ;
+        temp = ( ( temp & 0x0003 ) << 4 ) ;
+        XGINew_SetReg1( pVBInfo->Part4Port , 0x1E , temp ) ;
+        temp = ( tempax & 0x00FF ) ;
+        XGINew_SetReg1( pVBInfo->Part4Port , 0x1D , temp ) ;
+
+        if ( pVBInfo->VBInfo & ( SetCRT2ToTV | SetCRT2ToHiVisionTV ) )
+        {
+            if ( pVBInfo->VGAHDE > 800 )
+            {
+                XGINew_SetRegOR( pVBInfo->Part4Port , 0x1E , 0x08 ) ;
+            }
+        }
+        temp = 0x0036 ;
+
+        if ( pVBInfo->VBInfo & SetCRT2ToTV )
+        {
+            if ( !( pVBInfo->TVInfo & ( NTSC1024x768 | SetYPbPrMode525p | SetYPbPrMode750p | SetYPbPrMode1080i ) ) )
+            {
+                temp |= 0x0001 ;
+                if ( ( pVBInfo->VBInfo & SetInSlaveMode ) && ( !( pVBInfo->TVInfo & TVSimuMode ) ) )
+                    temp &= ( ~0x0001 ) ;
+            }
+        }
+
+        XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x1F , 0x00C0 , temp ) ;
+        tempbx = pVBInfo->HT ;
+        if ( XGI_IsLCDDualLink( pVBInfo ) )
+            tempbx = tempbx >> 1 ;
+        tempbx = ( tempbx >> 1 ) - 2 ;
+        temp = ( ( tempbx & 0x0700 ) >> 8 ) << 3 ;
+        XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x21 , 0x00C0 , temp ) ;
+        temp = tempbx & 0x00FF ;
+        XGINew_SetReg1( pVBInfo->Part4Port , 0x22 , temp ) ;
+    }
+    /* end 301b */
+
+    if ( pVBInfo->ISXPDOS == 0 )
+        XGI_SetCRT2VCLK( ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetGroup5 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetGroup5( USHORT ModeNo , USHORT ModeIdIndex , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT Pindex ,
+           Pdata ;
+
+    Pindex = pVBInfo->Part5Port ;
+    Pdata = pVBInfo->Part5Port + 1 ;
+    if ( pVBInfo->ModeType == ModeVGA )
+    {
+        if ( !( pVBInfo->VBInfo & ( SetInSlaveMode | LoadDACFlag | CRT2DisplayFlag ) ) )
+        {
+            XGINew_EnableCRT2(pVBInfo) ;
+            /* LoadDAC2(pVBInfo->Part5Port,ModeNo,ModeIdIndex); */
+        }
+    }
+    return ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetLcdPtr */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void* XGI_GetLcdPtr( USHORT BX , USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT i ,
+           tempdx ,
+           tempcx ,
+           tempbx ,
+           tempal ,
+           modeflag ,
+           table ;
+
+    XGI330_LCDDataTablStruct *tempdi = 0 ;
+
+
+    tempbx = BX;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+        tempal = pVBInfo->SModeIDTable[ ModeIdIndex ].St_CRT2CRTC ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+        tempal = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT2CRTC ;
+    }
+
+    tempal = tempal & 0x0f ;
+
+    if ( tempbx <= 1 )		/* ExpLink */
+    {
+        if ( ModeNo <= 0x13 )
+        {
+            tempal = pVBInfo->SModeIDTable[ ModeIdIndex ].St_CRT2CRTC ; /* find no Ext_CRT2CRTC2 */
+        }
+        else
+        {
+            tempal= pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT2CRTC ;
+        }
+
+        if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+        {
+            if ( ModeNo <= 0x13 )
+                tempal = pVBInfo->SModeIDTable[ ModeIdIndex ].St_CRT2CRTC2 ;
+            else
+                tempal= pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT2CRTC2 ;
+        }
+
+        if ( tempbx & 0x01 )
+            tempal = ( tempal >> 4 ) ;
+
+        tempal = ( tempal & 0x0f ) ;
+    }
+
+    tempcx = LCDLenList[ tempbx ] ;	/* mov cl,byte ptr cs:LCDLenList[bx] */
+
+    if ( pVBInfo->LCDInfo & EnableScalingLCD )	/* ScaleLCD */
+    {
+        if ( ( tempbx == 5 ) || ( tempbx ) == 7 )
+            tempcx = LCDDesDataLen2 ;
+        else if ( ( tempbx == 3 ) || ( tempbx == 8 ) )
+            tempcx = LVDSDesDataLen2 ;
+    }
+    /* mov di, word ptr cs:LCDDataList[bx] */
+    /* tempdi=pVideoMemory[LCDDataList+tempbx*2]|(pVideoMemory[LCDDataList+tempbx*2+1]<<8); */
+
+    switch( tempbx )
+    {
+        case 0:
+            tempdi = XGI_EPLLCDCRT1Ptr_H ;
+            break ;
+        case 1:
+            tempdi = XGI_EPLLCDCRT1Ptr_V ;
+             break ;
+        case 2:
+            tempdi = XGI_EPLLCDDataPtr ;
+            break ;
+        case 3:
+            tempdi = XGI_EPLLCDDesDataPtr ;
+            break ;
+        case 4:
+            tempdi = XGI_LCDDataTable ;
+            break ;
+        case 5:
+            tempdi = XGI_LCDDesDataTable ;
+            break ;
+        case 6:
+            tempdi = XGI_EPLCHLCDRegPtr ;
+            break ;
+        case 7:
+        case 8:
+        case 9:
+            tempdi = 0 ;
+            break ;
+        default:
+        break ;
+    }
+
+    if ( tempdi == 0x00 )  /* OEMUtil */
+        return 0 ;
+
+    table = tempbx ;
+    i = 0 ;
+
+    while( tempdi[ i ].PANELID != 0xff )
+    {
+        tempdx = pVBInfo->LCDResInfo ;
+        if ( tempbx & 0x0080 )     /* OEMUtil */
+        {
+            tempbx &= ( ~0x0080 ) ;
+            tempdx = pVBInfo->LCDTypeInfo ;
+        }
+
+        if ( pVBInfo->LCDInfo & EnableScalingLCD )
+        tempdx &= ( ~PanelResInfo ) ;
+
+        if ( tempdi[ i ].PANELID == tempdx )
+        {
+            tempbx = tempdi[ i ].MASK ;
+            tempdx = pVBInfo->LCDInfo ;
+
+            if ( ModeNo <= 0x13 )         /* alan 09/10/2003 */
+                tempdx |= SetLCDStdMode ;
+
+            if ( modeflag & HalfDCLK )
+                tempdx |= SetLCDLowResolution ;
+
+            tempbx &= tempdx;
+            if ( tempbx == tempdi[ i ].CAP )
+                break ;
+        }
+        i++ ;
+    }
+
+    if ( table == 0 )
+    {
+        switch( tempdi[ i ].DATAPTR )
+        {
+            case 0:
+                return &XGI_LVDSCRT11024x768_1_H[ tempal ] ;
+                break ;
+            case 1:
+                return &XGI_LVDSCRT11024x768_2_H[ tempal ] ;
+                break ;
+            case 2:
+                return &XGI_LVDSCRT11280x1024_1_H[ tempal ] ;
+                break ;
+            case 3:
+                return &XGI_LVDSCRT11280x1024_2_H[ tempal ] ;
+                break ;
+            case 4:
+                return &XGI_LVDSCRT11400x1050_1_H[ tempal ] ;
+                break ;
+            case 5:
+                return &XGI_LVDSCRT11400x1050_2_H[ tempal ] ;
+                break ;
+            case 6:
+                return &XGI_LVDSCRT11600x1200_1_H[ tempal ] ;
+                break ;
+            case 7:
+                return &XGI_LVDSCRT11024x768_1_Hx75[ tempal ] ;
+                break ;
+            case 8:
+                return &XGI_LVDSCRT11024x768_2_Hx75[ tempal ] ;
+                break ;
+            case 9:
+                return &XGI_LVDSCRT11280x1024_1_Hx75[ tempal ] ;
+                break ;
+            case 10:
+                return &XGI_LVDSCRT11280x1024_2_Hx75[ tempal ] ;
+                break ;
+            default:
+                break ;
+        }
+    }
+    else if ( table == 1 )
+    {
+        switch( tempdi[ i ].DATAPTR )
+        {
+            case 0:
+                return &XGI_LVDSCRT11024x768_1_V[ tempal ] ;
+                break ;
+            case 1:
+                return &XGI_LVDSCRT11024x768_2_V[ tempal ] ;
+                break ;
+            case 2:
+                return &XGI_LVDSCRT11280x1024_1_V[ tempal ] ;
+                break ;
+            case 3:
+                return &XGI_LVDSCRT11280x1024_2_V[ tempal ] ;
+                break ;
+            case 4:
+                return &XGI_LVDSCRT11400x1050_1_V[ tempal ] ;
+                break ;
+            case 5:
+                return &XGI_LVDSCRT11400x1050_2_V[ tempal ] ;
+                break ;
+            case 6:
+                return &XGI_LVDSCRT11600x1200_1_V[ tempal ] ;
+                break ;
+            case 7:
+                return &XGI_LVDSCRT11024x768_1_Vx75[ tempal ] ;
+                break ;
+            case 8:
+                return &XGI_LVDSCRT11024x768_2_Vx75[ tempal ] ;
+                break ;
+            case 9:
+                return &XGI_LVDSCRT11280x1024_1_Vx75[ tempal ] ;
+                break ;
+            case 10:
+                return &XGI_LVDSCRT11280x1024_2_Vx75[ tempal ] ;
+                break ;
+            default:
+                break ;
+        }
+    }
+    else if ( table == 2 )
+    {
+        switch( tempdi[ i ].DATAPTR )
+        {
+            case 0:
+                return &XGI_LVDS1024x768Data_1[ tempal ] ;
+                break ;
+            case 1:
+                return &XGI_LVDS1024x768Data_2[ tempal ] ;
+                break ;
+            case 2:
+                return &XGI_LVDS1280x1024Data_1[ tempal ] ;
+                break ;
+            case 3:
+                return &XGI_LVDS1280x1024Data_2[ tempal ] ;
+                break ;
+            case 4:
+                return &XGI_LVDS1400x1050Data_1[ tempal ] ;
+                break ;
+            case 5:
+                return &XGI_LVDS1400x1050Data_2[ tempal ] ;
+                break ;
+            case 6:
+                return &XGI_LVDS1600x1200Data_1[ tempal ] ;
+                break ;
+            case 7:
+                return &XGI_LVDSNoScalingData[ tempal ] ;
+                break ;
+            case 8:
+                return &XGI_LVDS1024x768Data_1x75[ tempal ] ;
+                break ;
+            case 9:
+                return &XGI_LVDS1024x768Data_2x75[ tempal ] ;
+                break ;
+            case 10:
+                return &XGI_LVDS1280x1024Data_1x75[ tempal ] ;
+                break ;
+            case 11:
+                return &XGI_LVDS1280x1024Data_2x75[ tempal ] ;
+                break ;
+            case 12:
+                return &XGI_LVDSNoScalingDatax75[ tempal ] ;
+                break ;
+            default:
+                break ;
+        }
+    }
+    else if ( table == 3 )
+    {
+        switch( tempdi[ i ].DATAPTR )
+        {
+            case 0:
+                return &XGI_LVDS1024x768Des_1[ tempal ] ;
+                break ;
+            case 1:
+                return &XGI_LVDS1024x768Des_3[ tempal ] ;
+                break ;
+            case 2:
+                return &XGI_LVDS1024x768Des_2[ tempal ] ;
+                break ;
+            case 3:
+                return &XGI_LVDS1280x1024Des_1[ tempal ] ;
+                break ;
+            case 4:
+                return &XGI_LVDS1280x1024Des_2[ tempal ] ;
+                break ;
+            case 5:
+                return &XGI_LVDS1400x1050Des_1[ tempal ] ;
+                break ;
+            case 6:
+                return &XGI_LVDS1400x1050Des_2[ tempal ] ;
+                break ;
+            case 7:
+                return &XGI_LVDS1600x1200Des_1[ tempal ] ;
+                break ;
+            case 8:
+                return &XGI_LVDSNoScalingDesData[ tempal ] ;
+                break ;
+            case 9:
+                return &XGI_LVDS1024x768Des_1x75[ tempal ] ;
+                break ;
+            case 10:
+                return &XGI_LVDS1024x768Des_3x75[ tempal ] ;
+                break ;
+            case 11:
+                return &XGI_LVDS1024x768Des_2x75[ tempal ] ;
+                break;
+            case 12:
+                return &XGI_LVDS1280x1024Des_1x75[ tempal ] ;
+                break ;
+            case 13:
+                return &XGI_LVDS1280x1024Des_2x75[ tempal ] ;
+                break ;
+            case 14:
+                return &XGI_LVDSNoScalingDesDatax75[ tempal ] ;
+                break ;
+            default:
+                break ;
+        }
+    }
+    else if ( table == 4 )
+    {
+        switch( tempdi[ i ].DATAPTR )
+        {
+            case 0:
+                return &XGI_ExtLCD1024x768Data[ tempal ] ;
+                break ;
+            case 1:
+                return &XGI_StLCD1024x768Data[ tempal ] ;
+                break ;
+            case 2:
+                return &XGI_CetLCD1024x768Data[ tempal ] ;
+                break ;
+            case 3:
+                return &XGI_ExtLCD1280x1024Data[ tempal ] ;
+                break ;
+            case 4:
+                return &XGI_StLCD1280x1024Data[ tempal ] ;
+                break ;
+            case 5:
+                return &XGI_CetLCD1280x1024Data[ tempal ] ;
+                break ;
+            case 6:
+                return &XGI_ExtLCD1400x1050Data[ tempal ] ;
+                break ;
+            case 7:
+                return &XGI_StLCD1400x1050Data[ tempal ] ;
+                break ;
+            case 8:
+                return &XGI_CetLCD1400x1050Data[ tempal ] ;
+                break ;
+            case 9:
+                return &XGI_ExtLCD1600x1200Data[ tempal ] ;
+                break  ;
+            case 10:
+                return &XGI_StLCD1600x1200Data[ tempal ] ;
+                break ;
+            case 11:
+                return &XGI_NoScalingData[ tempal ] ;
+                break ;
+            case 12:
+                return &XGI_ExtLCD1024x768x75Data[ tempal ] ;
+                break ;
+            case 13:
+                return &XGI_ExtLCD1024x768x75Data[ tempal ] ;
+                break ;
+            case 14:
+                return &XGI_CetLCD1024x768x75Data[ tempal ] ;
+                break ;
+            case 15:
+                 return &XGI_ExtLCD1280x1024x75Data[ tempal ] ;
+                break ;
+            case 16:
+                return &XGI_StLCD1280x1024x75Data[ tempal ] ;
+                break;
+            case 17:
+                return &XGI_CetLCD1280x1024x75Data[ tempal ] ;
+                break;
+            case 18:
+                return &XGI_NoScalingDatax75[ tempal ] ;
+                break ;
+            default:
+                break ;
+        }
+    }
+    else if ( table == 5 )
+    {
+        switch( tempdi[ i ].DATAPTR )
+        {
+            case 0:
+                return &XGI_ExtLCDDes1024x768Data[ tempal ] ;
+                break ;
+            case 1:
+                return &XGI_StLCDDes1024x768Data[ tempal ] ;
+                break ;
+            case 2:
+                return &XGI_CetLCDDes1024x768Data[ tempal ] ;
+                break ;
+            case 3:
+                if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+                    return &XGI_ExtLCDDLDes1280x1024Data[ tempal ] ;
+                else
+                    return &XGI_ExtLCDDes1280x1024Data[ tempal ] ;
+                break ;
+            case 4:
+                if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+                    return &XGI_StLCDDLDes1280x1024Data[ tempal ] ;
+                else
+                    return &XGI_StLCDDes1280x1024Data[ tempal ] ;
+                break ;
+            case 5:
+                if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+                    return &XGI_CetLCDDLDes1280x1024Data[ tempal ] ;
+                else
+                    return &XGI_CetLCDDes1280x1024Data[ tempal ] ;
+                break ;
+            case 6:
+                if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+                    return &XGI_ExtLCDDLDes1400x1050Data[ tempal ] ;
+                else
+                    return &XGI_ExtLCDDes1400x1050Data[ tempal ] ;
+                break ;
+            case 7:
+                if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+                    return &XGI_StLCDDLDes1400x1050Data[ tempal ] ;
+                else
+                    return &XGI_StLCDDes1400x1050Data[ tempal ] ;
+                break ;
+            case 8:
+                return &XGI_CetLCDDes1400x1050Data[ tempal ] ;
+                break ;
+            case 9:
+                return &XGI_CetLCDDes1400x1050Data2[ tempal ] ;
+                break ;
+            case 10:
+                if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+                    return &XGI_ExtLCDDLDes1600x1200Data[ tempal ] ;
+                else
+                    return &XGI_ExtLCDDes1600x1200Data[ tempal ] ;
+                break ;
+            case 11:
+                if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+                    return &XGI_StLCDDLDes1600x1200Data[ tempal ] ;
+                else
+                    return &XGI_StLCDDes1600x1200Data[ tempal ] ;
+                break ;
+            case 12:
+                return &XGI_NoScalingDesData[ tempal ] ;
+                break;
+            case 13:
+                return &XGI_ExtLCDDes1024x768x75Data[ tempal ] ;
+                break ;
+            case 14:
+                return &XGI_StLCDDes1024x768x75Data[ tempal ] ;
+                break ;
+            case 15:
+                return &XGI_CetLCDDes1024x768x75Data[ tempal ] ;
+                break ;
+            case 16:
+                if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+                    return &XGI_ExtLCDDLDes1280x1024x75Data[ tempal ] ;
+                else
+                    return &XGI_ExtLCDDes1280x1024x75Data[ tempal ] ;
+                break ;
+            case 17:
+                if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+                    return &XGI_StLCDDLDes1280x1024x75Data[ tempal ] ;
+                else
+                    return &XGI_StLCDDes1280x1024x75Data[ tempal ] ;
+                break ;
+            case 18:
+                if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+                    return &XGI_CetLCDDLDes1280x1024x75Data[ tempal ] ;
+                else
+                    return &XGI_CetLCDDes1280x1024x75Data[ tempal ] ;
+                break ;
+            case 19:
+                return &XGI_NoScalingDesDatax75[ tempal ] ;
+                break ;
+            default:
+                break ;
+        }
+    }
+    else if ( table == 6 )
+    {
+        switch( tempdi[ i ].DATAPTR )
+        {
+            case 0:
+                return &XGI_CH7017LV1024x768[ tempal ] ;
+                break ;
+            case 1:
+                return &XGI_CH7017LV1400x1050[ tempal ] ;
+                break ;
+            default:
+                break ;
+        }
+    }
+    return 0 ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetTVPtr */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void* XGI_GetTVPtr (USHORT BX,USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT i , tempdx , tempbx , tempal , modeflag , table ;
+    XGI330_TVDataTablStruct *tempdi = 0 ;
+
+    tempbx = BX ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+        tempal = pVBInfo->SModeIDTable[ ModeIdIndex ].St_CRT2CRTC ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+        tempal = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT2CRTC ;
+    }
+
+    tempal = tempal & 0x3f ;
+    table = tempbx ;
+
+    switch( tempbx )
+    {
+        case 0:
+            tempdi = 0 ;	/*EPLCHTVCRT1Ptr_H;*/
+            if ( pVBInfo->IF_DEF_CH7007 == 1 )
+            {
+                tempdi = XGI_EPLCHTVCRT1Ptr;
+            }
+            break ;
+        case 1:
+            tempdi = 0 ;	/*EPLCHTVCRT1Ptr_V;*/
+            if ( pVBInfo->IF_DEF_CH7007 == 1 )
+            {
+                tempdi = XGI_EPLCHTVCRT1Ptr;
+            }
+            break ;
+        case 2:
+            tempdi = XGI_EPLCHTVDataPtr ;
+            break ;
+        case 3:
+            tempdi = 0 ;
+            break ;
+        case 4:
+            tempdi = XGI_TVDataTable ;
+            break ;
+        case 5:
+            tempdi = 0 ;
+            break ;
+        case 6:
+            tempdi = XGI_EPLCHTVRegPtr ;
+            break ;
+        default:
+            break ;
+    }
+
+    if ( tempdi == 0x00 )  /* OEMUtil */
+        return( 0 ) ;
+
+    tempdx = pVBInfo->TVInfo ;
+
+    if ( pVBInfo->VBInfo & SetInSlaveMode )
+        tempdx = tempdx | SetTVLockMode ;
+
+    if ( modeflag & HalfDCLK )
+        tempdx = tempdx | SetTVLowResolution ;
+
+    i = 0 ;
+
+    while( tempdi[ i ].MASK != 0xffff )
+    {
+        if ( ( tempdx & tempdi[ i ].MASK ) == tempdi[ i ].CAP )
+            break ;
+        i++ ;
+    }
+
+    if ( table == 0x00 ) /* 07/05/22 */
+    {
+#ifdef WIN2000    	
+        if ( pVBInfo->IF_DEF_CH7007 == 1 )
+        {
+          switch( tempdi[ i ].DATAPTR )
+          {
+            case 0:
+                return &CH7007TVCRT1UNTSC_H[ tempal ] ;
+                break ;
+            case 1:
+                return &CH7007TVCRT1ONTSC_H[ tempal ] ;
+                break ;
+            case 2:
+                return &CH7007TVCRT1UPAL_H[ tempal ] ;
+                break ;
+            case 3:
+                return &CH7007TVCRT1OPAL_H[ tempal ] ;
+                break ;
+            default:
+                break ;
+          }
+        }
+#endif        
+    } 
+    else if ( table == 0x01 )
+    {
+#ifdef WIN2000
+        if ( pVBInfo->IF_DEF_CH7007 == 1 )
+        {
+          switch( tempdi[ i ].DATAPTR )
+          {
+            case 0:
+                return &CH7007TVCRT1UNTSC_V[ tempal ] ;
+                break ;
+            case 1:
+                return &CH7007TVCRT1ONTSC_V[ tempal ] ;
+                break ;
+            case 2:
+                return &CH7007TVCRT1UPAL_V[ tempal ] ;
+                break ;
+            case 3:
+                return &CH7007TVCRT1OPAL_V[ tempal ] ;
+                break ;
+            default:
+                break ;
+          }
+        }
+#endif        
+    } 
+    else if ( table == 0x04 )
+    {
+        switch( tempdi[ i ].DATAPTR )
+        {
+            case 0:
+                return &XGI_ExtPALData[ tempal ] ;
+		break ;
+            case 1:
+                return &XGI_ExtNTSCData[ tempal ] ;
+ 		break ;
+      	    case 2:
+      	   	return &XGI_StPALData[ tempal ] ;
+ 		break ;
+            case 3:
+           	return &XGI_StNTSCData[ tempal ] ;
+ 		break ;
+      	    case 4:
+      	   	return &XGI_ExtHiTVData[ tempal ] ;
+ 		break ;
+      	    case 5:
+      	   	return &XGI_St2HiTVData[ tempal ] ;
+ 		break ;
+      	    case 6:
+      	   	return &XGI_ExtYPbPr525iData[ tempal ] ;
+ 		break ;
+      	    case 7:
+      	   	return &XGI_ExtYPbPr525pData[ tempal ] ;
+ 		break ;
+      	    case 8:
+      	   	return &XGI_ExtYPbPr750pData[ tempal ] ;
+ 		break ;
+      	    case 9:
+      	   	return &XGI_StYPbPr525iData[ tempal ] ;
+ 		break ;
+      	    case 10:
+      	   	return &XGI_StYPbPr525pData[ tempal ] ;
+ 		break ;
+      	    case 11:
+      	   	return &XGI_StYPbPr750pData[ tempal ] ;
+             	break;
+            case 12: 	/* avoid system hang */
+      	   	return &XGI_ExtNTSCData[ tempal ] ;
+             	break ;
+            case 13:
+      	   	return &XGI_St1HiTVData[ tempal ] ;
+             	break ;
+            default:
+                break ;
+        }
+    }
+    else if( table == 0x02 )
+    {
+        switch( tempdi[ i ].DATAPTR )
+        {
+            case 0:
+                return &XGI_CHTVUNTSCData[ tempal ] ;
+                break ;
+            case 1:
+      	        return &XGI_CHTVONTSCData[ tempal ] ;
+                break ;
+            case 2:
+                return &XGI_CHTVUPALData[ tempal ] ;
+                break ;
+            case 3:
+                return &XGI_CHTVOPALData[ tempal ] ;
+                break ;
+            default:
+                break ;
+        }
+    }
+    else if( table == 0x06 )
+    {
+#ifdef WIN2000
+        if ( pVBInfo->IF_DEF_CH7007 == 1 )
+        {
+          /* VideoDebugPrint((0, "XGI_GetTVPtr: pVBInfo->IF_DEF_CH7007==1\n")); */
+          switch( tempdi[ i ].DATAPTR )
+          {
+            case 0:
+                return &CH7007TVReg_UNTSC[ tempal ] ;
+                break ;
+            case 1:
+                return &CH7007TVReg_ONTSC[ tempal ] ;
+                break ;
+            case 2:
+                return &CH7007TVReg_UPAL[ tempal ] ;
+                break ;
+            case 3:
+                return &CH7007TVReg_OPAL[ tempal ] ;
+                break ;
+            default:
+                break ;
+          }
+        }
+        else
+        {
+            switch( tempdi[ i ].DATAPTR )
+            {
+              case 0:
+                return &XGI_CHTVRegUNTSC[ tempal ] ;
+                break ;
+              case 1:
+                return &XGI_CHTVRegONTSC[ tempal ] ;
+                break ;
+              case 2:
+                return &XGI_CHTVRegUPAL[ tempal ] ;
+                break ;
+              case 3:
+                return &XGI_CHTVRegOPAL[ tempal ] ;
+                break ;
+              default:
+                break ;
+            }
+        }
+#endif        
+    }
+    return( 0 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_BacklightByDrv */
+/* Input : */
+/* Output : TRUE -> Skip backlight control */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_BacklightByDrv( PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR tempah ;
+
+    tempah = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x3A ) ;
+    if ( tempah & BacklightControlBit )
+        return TRUE ;
+    else
+        return FALSE ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_FirePWDDisable */
+/* Input : */
+/* Output : */
+/* Description : Turn off VDD & Backlight : Fire disable procedure */
+/* --------------------------------------------------------------------- */
+/*
+void XGI_FirePWDDisable( PVB_DEVICE_INFO pVBInfo )
+{
+    XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x26 , 0x00 , 0xFC ) ;
+}
+*/
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_FirePWDEnable */
+/* Input : */
+/* Output : */
+/* Description : Turn on VDD & Backlight : Fire enable procedure */
+/* --------------------------------------------------------------------- */
+void XGI_FirePWDEnable(PVB_DEVICE_INFO pVBInfo )
+{
+    XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x26 , 0x03 , 0xFC ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_EnableGatingCRT */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_EnableGatingCRT(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x63 , 0xBF , 0x40 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_DisableGatingCRT */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_DisableGatingCRT(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x63 , 0xBF , 0x00 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetPanelDelay */
+/* Input : */
+/* Output : */
+/* Description : */
+/* I/P : bl : 1 ; T1 : the duration between CPL on and signal on */
+/* : bl : 2 ; T2 : the duration signal on and Vdd on */
+/* : bl : 3 ; T3 : the duration between CPL off and signal off */
+/* : bl : 4 ; T4 : the duration signal off and Vdd off */
+/* --------------------------------------------------------------------- */
+void XGI_SetPanelDelay(USHORT tempbl, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT index ;
+#ifndef LINUX_XF86
+    USHORT temp ;
+#endif
+
+    index = XGI_GetLCDCapPtr(pVBInfo) ;
+
+    if ( tempbl == 1 )
+        XGINew_LCD_Wait_Time( pVBInfo->LCDCapList[ index ].PSC_S1, pVBInfo ) ;
+
+    if ( tempbl == 2 )
+        XGINew_LCD_Wait_Time( pVBInfo->LCDCapList[ index ].PSC_S2, pVBInfo ) ;
+
+    if ( tempbl == 3 )
+        XGINew_LCD_Wait_Time( pVBInfo->LCDCapList[ index ].PSC_S3, pVBInfo ) ;
+
+    if ( tempbl == 4 )
+        XGINew_LCD_Wait_Time( pVBInfo->LCDCapList[ index ].PSC_S4, pVBInfo ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetPanelPower */
+/* Input : */
+/* Output : */
+/* Description : */
+/* I/O : ah = 0011b = 03h ; Backlight on, Power on */
+/* = 0111b = 07h ; Backlight on, Power off */
+/* = 1011b = 0Bh ; Backlight off, Power on */
+/* = 1111b = 0Fh ; Backlight off, Power off */
+/* --------------------------------------------------------------------- */
+void XGI_SetPanelPower(USHORT tempah,USHORT tempbl, PVB_DEVICE_INFO pVBInfo)
+{
+    if ( pVBInfo->VBType & ( VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x26 , tempbl , tempah ) ;
+    else
+        XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x11 , tempbl , tempah ) ;
+}
+
+UCHAR XG21GPIODataTransfer(UCHAR ujDate)
+{
+    UCHAR  ujRet = 0;
+    UCHAR  i = 0;
+
+    for (i=0; i<8; i++)
+	{
+    	ujRet = ujRet << 1;
+	/* ujRet |= GETBITS(ujDate >> i, 0:0); */
+        ujRet |= (ujDate >> i) & 1;
+    }
+
+	return ujRet;
+}
+
+/*----------------------------------------------------------------------------*/
+/* output                                                                     */
+/*      bl[5] : LVDS signal                                                   */
+/*      bl[1] : LVDS backlight                                                */
+/*      bl[0] : LVDS VDD                                                      */
+/*----------------------------------------------------------------------------*/
+UCHAR XGI_XG21GetPSCValue(PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR CR4A,temp;
+    
+    CR4A = XGINew_GetReg1( pVBInfo->P3d4 , 0x4A ) ;
+    XGINew_SetRegAND( pVBInfo->P3d4 , 0x4A , ~0x23 ) ; /* enable GPIO write */
+
+    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x48 ) ;
+    
+    temp = XG21GPIODataTransfer(temp);
+    temp &= 0x23;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x4A , CR4A ) ; 
+    return temp;
+}
+
+/*----------------------------------------------------------------------------*/
+/* output                                                                     */
+/*      bl[5] : LVDS signal                                                   */
+/*      bl[1] : LVDS backlight                                                */
+/*      bl[0] : LVDS VDD                                                      */
+/*----------------------------------------------------------------------------*/
+UCHAR XGI_XG27GetPSCValue(PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR CR4A,CRB4,temp;
+    
+    CR4A = XGINew_GetReg1( pVBInfo->P3d4 , 0x4A ) ;
+    XGINew_SetRegAND( pVBInfo->P3d4 , 0x4A , ~0x0C ) ; /* enable GPIO write */
+
+    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x48 ) ;
+    
+    temp &= 0x0C;
+    temp >>= 2;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x4A , CR4A ) ; 
+    CRB4 = XGINew_GetReg1( pVBInfo->P3d4 , 0xB4 ) ;
+    temp |= ((CRB4&0x04)<<3);
+    return temp;
+}
+/*----------------------------------------------------------------------------*/
+/* input                                                                      */
+/*      bl[5] : 1;LVDS signal on                                              */
+/*      bl[1] : 1;LVDS backlight on                                           */
+/*      bl[0] : 1:LVDS VDD on                                                 */
+/*      bh: 100000b : clear bit 5, to set bit5                                */
+/*          000010b : clear bit 1, to set bit1                                */
+/*          000001b : clear bit 0, to set bit0                                */
+/*----------------------------------------------------------------------------*/
+void XGI_XG21BLSignalVDD(USHORT tempbh,USHORT tempbl, PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR CR4A,temp;
+    
+    CR4A = XGINew_GetReg1( pVBInfo->P3d4 , 0x4A ) ;
+    tempbh &= 0x23;
+    tempbl &= 0x23;
+    XGINew_SetRegAND( pVBInfo->P3d4 , 0x4A , ~tempbh ) ; /* enable GPIO write */
+
+    if (tempbh&0x20)
+    {
+      temp = (tempbl>>4)&0x02;
+      
+      XGINew_SetRegANDOR( pVBInfo->P3d4 , 0xB4 , ~0x02 , temp) ; /* CR B4[1] */
+    
+    }
+    
+    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x48 ) ;
+    
+    temp = XG21GPIODataTransfer(temp);
+    temp &= ~tempbh;
+    temp |= tempbl;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x48 , temp ) ; 
+}
+
+void XGI_XG27BLSignalVDD(USHORT tempbh,USHORT tempbl, PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR CR4A,temp;
+    USHORT tempbh0,tempbl0;
+
+    tempbh0 = tempbh;
+    tempbl0 = tempbl;
+    tempbh0 &= 0x20;
+    tempbl0 &= 0x20;
+    tempbh0 >>= 3;
+    tempbl0 >>= 3;
+
+    if (tempbh&0x20)
+    {
+      temp = (tempbl>>4)&0x02;
+      
+      XGINew_SetRegANDOR( pVBInfo->P3d4 , 0xB4 , ~0x02 , temp) ; /* CR B4[1] */
+    
+    }
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0xB4 , ~tempbh0 , tempbl0 ) ;
+
+    CR4A = XGINew_GetReg1( pVBInfo->P3d4 , 0x4A ) ;
+    tempbh &= 0x03;
+    tempbl &= 0x03;
+    tempbh <<= 2;
+    tempbl <<= 2;                                       /* GPIOC,GPIOD */
+    XGINew_SetRegAND( pVBInfo->P3d4 , 0x4A , ~tempbh ) ; /* enable GPIO write */
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x48 , ~tempbh , tempbl ) ;
+}
+
+/* --------------------------------------------------------------------- */
+USHORT XGI_GetLVDSOEMTableIndex(PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT index ;
+
+    index = XGINew_GetReg1( pVBInfo->P3d4 , 0x36 ) ;
+    if (index<sizeof(XGI21_LCDCapList)/sizeof(XGI21_LVDSCapStruct))
+    {
+      return index;
+    }
+    return 0;
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_XG21SetPanelDelay */
+/* Input : */
+/* Output : */
+/* Description : */
+/* I/P : bl : 1 ; T1 : the duration between CPL on and signal on */
+/* : bl : 2 ; T2 : the duration signal on and Vdd on */
+/* : bl : 3 ; T3 : the duration between CPL off and signal off */
+/* : bl : 4 ; T4 : the duration signal off and Vdd off */
+/* --------------------------------------------------------------------- */
+void XGI_XG21SetPanelDelay(USHORT tempbl, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT index ;
+
+    index = XGI_GetLVDSOEMTableIndex( pVBInfo );
+    if ( tempbl == 1 )
+        XGINew_LCD_Wait_Time( pVBInfo->XG21_LVDSCapList[ index ].PSC_S1, pVBInfo ) ;
+
+    if ( tempbl == 2 )
+        XGINew_LCD_Wait_Time( pVBInfo->XG21_LVDSCapList[ index ].PSC_S2, pVBInfo ) ;
+
+    if ( tempbl == 3 )
+        XGINew_LCD_Wait_Time( pVBInfo->XG21_LVDSCapList[ index ].PSC_S3, pVBInfo ) ;
+
+    if ( tempbl == 4 )
+        XGINew_LCD_Wait_Time( pVBInfo->XG21_LVDSCapList[ index ].PSC_S4, pVBInfo ) ;
+}
+
+BOOLEAN XGI_XG21CheckLVDSMode(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT xres ,
+           yres ,
+           colordepth ,
+           modeflag ,
+           resindex ,
+           lvdstableindex;
+
+    resindex = XGI_GetResInfo( ModeNo , ModeIdIndex, pVBInfo ) ;
+    if ( ModeNo <= 0x13 )
+    {
+        xres = pVBInfo->StResInfo[ resindex ].HTotal ;
+        yres = pVBInfo->StResInfo[ resindex ].VTotal ;
+        modeflag = pVBInfo->SModeIDTable[ModeIdIndex].St_ModeFlag;    /* si+St_ResInfo */
+    }
+    else
+    {
+        xres = pVBInfo->ModeResInfo[ resindex ].HTotal ;			  /* xres->ax */
+        yres = pVBInfo->ModeResInfo[ resindex ].VTotal ;			  /* yres->bx */
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex].Ext_ModeFlag ; /* si+St_ModeFlag */
+    }
+
+    if ( !( modeflag & Charx8Dot ) )
+    {
+        xres /= 9;
+        xres *= 8;
+    }
+
+    if ( ModeNo > 0x13 )
+    {
+        if ( ( ModeNo>0x13 ) && ( modeflag & HalfDCLK ) )
+        {
+          xres *=  2 ;
+        }
+        if ( ( ModeNo>0x13 ) && ( modeflag & DoubleScanMode ) )
+        {
+          yres *=  2 ;
+        }
+    }
+    
+    lvdstableindex = XGI_GetLVDSOEMTableIndex( pVBInfo );
+    if ( xres > (pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHDE) )
+      return FALSE;
+
+    if ( yres > (pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVDE) )
+      return FALSE;
+
+    if ( ModeNo > 0x13 )
+    {
+      if ( ( xres != (pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHDE) ) || 
+           ( yres != (pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVDE)) )
+      {
+          colordepth = XGI_GetColorDepth( ModeNo , ModeIdIndex, pVBInfo ) ;
+          if ( colordepth > 2 )
+          {
+            return FALSE;
+          }
+      }
+    }
+    return TRUE;
+}
+
+void XGI_SetXG21FPBits(PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR temp;
+
+    temp = XGINew_GetReg1( pVBInfo->P3d4  , 0x37 ) ;  /* D[0] 1: 18bit */
+    temp = ( temp & 1 ) << 6;                         
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x06 , ~0x40 , temp ) ;      /* SR06[6] 18bit Dither */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x09 , ~0xc0 , temp | 0x80 ) ;  /* SR09[7] enable FP output, SR09[6] 1: sigle 18bits, 0: dual 12bits */
+    
+}
+
+void XGI_SetXG27FPBits(PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR temp;
+
+    temp = XGINew_GetReg1( pVBInfo->P3d4  , 0x37 ) ;  /* D[1:0] 01: 18bit, 00: dual 12, 10: single 24 */
+    temp = ( temp & 3 ) << 6;                         
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x06 , ~0xc0 , temp & 0x80 ) ;  /* SR06[7]0: dual 12/1: single 24 [6] 18bit Dither <= 0 h/w recommend */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x09 , ~0xc0 , temp | 0x80 ) ;  /* SR09[7] enable FP output, SR09[6] 1: sigle 18bits, 0: 24bits */
+    
+}
+
+void XGI_SetXG21LVDSPara(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR temp,Miscdata;
+    USHORT xres ,
+           yres ,
+           colordepth ,
+           modeflag ,
+           resindex ,
+           lvdstableindex ;
+    USHORT LVDSHT,LVDSHBS,LVDSHRS,LVDSHRE,LVDSHBE;
+    USHORT LVDSVT,LVDSVBS,LVDSVRS,LVDSVRE,LVDSVBE;
+    USHORT value;
+
+    lvdstableindex = XGI_GetLVDSOEMTableIndex( pVBInfo );
+
+    temp = (UCHAR) ( ( pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDS_Capability & (LCDPolarity << 8 ) ) >> 8 );
+    temp &= LCDPolarity;
+    Miscdata =(UCHAR) XGINew_GetReg2(pVBInfo->P3cc) ;
+
+    XGINew_SetReg3( pVBInfo->P3c2 , (Miscdata & 0x3F) | temp ) ;
+    
+    temp = (UCHAR) ( pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDS_Capability & LCDPolarity ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x35 , ~0x80 , temp&0x80 ) ;      /* SR35[7] FP VSync polarity */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x30 , ~0x20 , (temp&0x40)>>1 ) ;   /* SR30[5] FP HSync polarity */
+    
+    XGI_SetXG21FPBits(pVBInfo);
+    resindex = XGI_GetResInfo( ModeNo , ModeIdIndex, pVBInfo ) ;
+    if ( ModeNo <= 0x13 )
+    {
+        xres = pVBInfo->StResInfo[ resindex ].HTotal ;
+        yres = pVBInfo->StResInfo[ resindex ].VTotal ;
+        modeflag = pVBInfo->SModeIDTable[ModeIdIndex].St_ModeFlag;    /* si+St_ResInfo */
+    }
+    else
+    {
+        xres = pVBInfo->ModeResInfo[ resindex ].HTotal ;			  /* xres->ax */
+        yres = pVBInfo->ModeResInfo[ resindex ].VTotal ;			  /* yres->bx */
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex].Ext_ModeFlag ; /* si+St_ModeFlag */
+    }
+
+    if (!( modeflag & Charx8Dot ))
+      xres = xres * 8 / 9;
+      
+    LVDSHT = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHT;
+    
+    LVDSHBS = xres + ( pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHDE - xres ) / 2 ;    
+    if ( ( ModeNo<=0x13 ) && ( modeflag & HalfDCLK ) )
+    {
+      LVDSHBS -=  xres/4 ;
+    }
+    if (LVDSHBS > LVDSHT) LVDSHBS -= LVDSHT ;
+    
+    LVDSHRS = LVDSHBS + pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHFP ;
+    if (LVDSHRS > LVDSHT) LVDSHRS -= LVDSHT ;
+    
+    LVDSHRE = LVDSHRS + pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHSYNC ;
+    if (LVDSHRE > LVDSHT) LVDSHRE -= LVDSHT ;
+    
+    LVDSHBE = LVDSHBS + LVDSHT - pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHDE ;
+
+    LVDSVT = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVT;
+    
+    LVDSVBS = yres + ( pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVDE - yres ) / 2 ;    
+    if ( ( ModeNo>0x13 ) && ( modeflag & DoubleScanMode ) )
+    {
+      LVDSVBS +=  yres/2 ;
+    }
+    if (LVDSVBS > LVDSVT) LVDSVBS -= LVDSVT ;
+    
+    LVDSVRS = LVDSVBS + pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVFP ;
+    if (LVDSVRS > LVDSVT) LVDSVRS -= LVDSVT ;
+    
+    LVDSVRE = LVDSVRS + pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVSYNC ;
+    if (LVDSVRE > LVDSVT) LVDSVRE -= LVDSVT ;
+    
+    LVDSVBE = LVDSVBS + LVDSVT - pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVDE ;
+    
+    temp = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x11 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x11 , temp & 0x7f ) ;		/* Unlock CRTC */
+    
+    if (!( modeflag & Charx8Dot ))
+    {
+        XGINew_SetRegOR( pVBInfo->P3c4 , 0x1 , 0x1 ) ;
+    }
+    
+    /* HT SR0B[1:0] CR00 */
+    value = ( LVDSHT >> 3 ) - 5;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0B , ~0x03 , ( value & 0x300 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x0 , (value & 0xFF) ) ;
+    
+    /* HBS SR0B[5:4] CR02 */
+    value = ( LVDSHBS >> 3 ) - 1;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0B , ~0x30 , ( value & 0x300 ) >> 4 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x2 , (value & 0xFF) ) ;
+
+    /* HBE SR0C[1:0] CR05[7] CR03[4:0] */
+    value = ( LVDSHBE >> 3 ) - 1;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0C , ~0x03 , ( value & 0xC0 ) >> 6 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x05 , ~0x80 , ( value & 0x20 ) << 2 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x03 , ~0x1F , value & 0x1F ) ;
+    
+    /* HRS SR0B[7:6] CR04 */
+    value = ( LVDSHRS >> 3 ) + 2;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0B , ~0xC0 , ( value & 0x300 ) >> 2 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x4 , (value & 0xFF) ) ;
+    
+    /* Panel HRS SR2F[1:0] SR2E[7:0]  */
+    value--;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x2F , ~0x03 , ( value & 0x300 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2E , (value & 0xFF) ) ;
+    
+    /* HRE SR0C[2] CR05[4:0] */
+    value = ( LVDSHRE >> 3 ) + 2;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0C , ~0x04 , ( value & 0x20 ) >> 3 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x05 , ~0x1F , value & 0x1F ) ;
+
+    /* Panel HRE SR2F[7:2]  */
+    value--;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x2F , ~0xFC , value << 2 ) ;
+
+    /* VT SR0A[0] CR07[5][0] CR06 */
+    value = LVDSVT - 2 ;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0A , ~0x01 , ( value & 0x400 ) >> 10 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x20 , ( value & 0x200 ) >> 4 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x01 , ( value & 0x100 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x06 , (value & 0xFF) ) ;
+
+    /* VBS SR0A[2] CR09[5] CR07[3] CR15 */
+    value = LVDSVBS - 1 ;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0A , ~0x04 , ( value & 0x400 ) >> 8 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x09 , ~0x20 , ( value & 0x200 ) >> 4 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x08 , ( value & 0x100 ) >> 5 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x15 , (value & 0xFF) ) ;
+
+    /* VBE SR0A[4] CR16 */
+    value = LVDSVBE - 1;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0A , ~0x10 , ( value & 0x100 ) >> 4 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x16 , (value & 0xFF) ) ;
+
+    /* VRS SR0A[3] CR7[7][2] CR10 */
+    value = LVDSVRS - 1 ;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0A , ~0x08 , ( value & 0x400 ) >> 7 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x80 , ( value & 0x200 ) >> 2 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x04 , ( value & 0x100 ) >> 6 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x10 , (value & 0xFF) ) ;
+
+    /* Panel VRS SR3F[1:0] SR34[7:0] SR33[0] */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x3F , ~0x03 , ( value & 0x600 ) >> 9 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x34 , (value >> 1) & 0xFF ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x33 , ~0x01 , value & 0x01 ) ;
+
+    /* VRE SR0A[5] CR11[3:0] */
+    value = LVDSVRE - 1;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0A , ~0x20 , ( value & 0x10 ) << 1 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x11 , ~0x0F , value & 0x0F ) ;
+
+    /* Panel VRE SR3F[7:2] */ /* SR3F[7] has to be 0, h/w bug */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x3F , ~0xFC , ( value << 2 ) & 0x7C ) ;
+    
+    for ( temp=0, value = 0; temp < 3; temp++)
+    {
+        
+        XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x31 , ~0x30 , value ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , pVBInfo->XG21_LVDSCapList[lvdstableindex].VCLKData1) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , pVBInfo->XG21_LVDSCapList[lvdstableindex].VCLKData2) ;
+        value += 0x10;
+    }
+
+    if (!( modeflag & Charx8Dot ))
+    {
+        XGINew_GetReg2( pVBInfo->P3da ) ;           /* reset 3da */
+        XGINew_SetReg3( pVBInfo->P3c0 , 0x13 ) ;    /* set index */
+        XGINew_SetReg3( pVBInfo->P3c0 , 0x00 ) ;    /* set data, panning = 0, shift left 1 dot*/
+
+        XGINew_GetReg2( pVBInfo->P3da ) ;           /* Enable Attribute */
+        XGINew_SetReg3( pVBInfo->P3c0 , 0x20 ) ;
+
+        XGINew_GetReg2( pVBInfo->P3da ) ;           /* reset 3da */
+    }
+    
+
+}
+
+/* no shadow case */
+void XGI_SetXG27LVDSPara(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR temp,Miscdata;
+    USHORT xres ,
+           yres ,
+           colordepth ,
+           modeflag ,
+           resindex ,
+           lvdstableindex ;
+    USHORT LVDSHT,LVDSHBS,LVDSHRS,LVDSHRE,LVDSHBE;
+    USHORT LVDSVT,LVDSVBS,LVDSVRS,LVDSVRE,LVDSVBE;
+    USHORT value;
+
+    lvdstableindex = XGI_GetLVDSOEMTableIndex( pVBInfo );
+    temp = (UCHAR) ( ( pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDS_Capability & (LCDPolarity << 8 ) ) >> 8 );
+    temp &= LCDPolarity;
+    Miscdata =(UCHAR) XGINew_GetReg2(pVBInfo->P3cc) ;
+
+    XGINew_SetReg3( pVBInfo->P3c2 , (Miscdata & 0x3F) | temp ) ;
+    
+    temp = (UCHAR) ( pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDS_Capability & LCDPolarity ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x35 , ~0x80 , temp&0x80 ) ;      /* SR35[7] FP VSync polarity */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x30 , ~0x20 , (temp&0x40)>>1 ) ;   /* SR30[5] FP HSync polarity */
+    
+    XGI_SetXG27FPBits(pVBInfo);
+    resindex = XGI_GetResInfo( ModeNo , ModeIdIndex, pVBInfo ) ;
+    if ( ModeNo <= 0x13 )
+    {
+        xres = pVBInfo->StResInfo[ resindex ].HTotal ;
+        yres = pVBInfo->StResInfo[ resindex ].VTotal ;
+        modeflag = pVBInfo->SModeIDTable[ModeIdIndex].St_ModeFlag;    /* si+St_ResInfo */
+    }
+    else
+    {
+        xres = pVBInfo->ModeResInfo[ resindex ].HTotal ;			  /* xres->ax */
+        yres = pVBInfo->ModeResInfo[ resindex ].VTotal ;			  /* yres->bx */
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex].Ext_ModeFlag ; /* si+St_ModeFlag */
+    }
+
+    if (!( modeflag & Charx8Dot ))
+      xres = xres * 8 / 9;
+      
+    LVDSHT = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHT;
+    
+    LVDSHBS = xres + ( pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHDE - xres ) / 2 ;    
+    if ( ( ModeNo<=0x13 ) && ( modeflag & HalfDCLK ) )
+    {
+      LVDSHBS -=  xres/4 ;
+    }
+    if (LVDSHBS > LVDSHT) LVDSHBS -= LVDSHT ;
+    
+    LVDSHRS = LVDSHBS + pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHFP ;
+    if (LVDSHRS > LVDSHT) LVDSHRS -= LVDSHT ;
+    
+    LVDSHRE = LVDSHRS + pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHSYNC ;
+    if (LVDSHRE > LVDSHT) LVDSHRE -= LVDSHT ;
+    
+    LVDSHBE = LVDSHBS + LVDSHT - pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHDE ;
+
+    LVDSVT = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVT;
+    
+    LVDSVBS = yres + ( pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVDE - yres ) / 2 ;    
+    if ( ( ModeNo>0x13 ) && ( modeflag & DoubleScanMode ) )
+    {
+      LVDSVBS +=  yres/2 ;
+    }
+    if (LVDSVBS > LVDSVT) LVDSVBS -= LVDSVT ;
+    
+    LVDSVRS = LVDSVBS + pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVFP ;
+    if (LVDSVRS > LVDSVT) LVDSVRS -= LVDSVT ;
+    
+    LVDSVRE = LVDSVRS + pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVSYNC ;
+    if (LVDSVRE > LVDSVT) LVDSVRE -= LVDSVT ;
+    
+    LVDSVBE = LVDSVBS + LVDSVT - pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVDE ;
+    
+    temp = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x11 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x11 , temp & 0x7f ) ;		/* Unlock CRTC */
+    
+    if (!( modeflag & Charx8Dot ))
+    {
+        XGINew_SetRegOR( pVBInfo->P3c4 , 0x1 , 0x1 ) ;
+    }
+    
+    /* HT SR0B[1:0] CR00 */
+    value = ( LVDSHT >> 3 ) - 5;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0B , ~0x03 , ( value & 0x300 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x0 , (value & 0xFF) ) ;
+    
+    /* HBS SR0B[5:4] CR02 */
+    value = ( LVDSHBS >> 3 ) - 1;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0B , ~0x30 , ( value & 0x300 ) >> 4 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x2 , (value & 0xFF) ) ;
+
+    /* HBE SR0C[1:0] CR05[7] CR03[4:0] */
+    value = ( LVDSHBE >> 3 ) - 1;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0C , ~0x03 , ( value & 0xC0 ) >> 6 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x05 , ~0x80 , ( value & 0x20 ) << 2 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x03 , ~0x1F , value & 0x1F ) ;
+    
+    /* HRS SR0B[7:6] CR04 */
+    value = ( LVDSHRS >> 3 ) + 2;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0B , ~0xC0 , ( value & 0x300 ) >> 2 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x4 , (value & 0xFF) ) ;
+    
+    /* Panel HRS SR2F[1:0] SR2E[7:0]  */
+    value--;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x2F , ~0x03 , ( value & 0x300 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2E , (value & 0xFF) ) ;
+    
+    /* HRE SR0C[2] CR05[4:0] */
+    value = ( LVDSHRE >> 3 ) + 2;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0C , ~0x04 , ( value & 0x20 ) >> 3 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x05 , ~0x1F , value & 0x1F ) ;
+
+    /* Panel HRE SR2F[7:2]  */
+    value--;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x2F , ~0xFC , value << 2 ) ;
+
+    /* VT SR0A[0] CR07[5][0] CR06 */
+    value = LVDSVT - 2 ;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0A , ~0x01 , ( value & 0x400 ) >> 10 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x20 , ( value & 0x200 ) >> 4 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x01 , ( value & 0x100 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x06 , (value & 0xFF) ) ;
+
+    /* VBS SR0A[2] CR09[5] CR07[3] CR15 */
+    value = LVDSVBS - 1 ;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0A , ~0x04 , ( value & 0x400 ) >> 8 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x09 , ~0x20 , ( value & 0x200 ) >> 4 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x08 , ( value & 0x100 ) >> 5 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x15 , (value & 0xFF) ) ;
+
+    /* VBE SR0A[4] CR16 */
+    value = LVDSVBE - 1;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0A , ~0x10 , ( value & 0x100 ) >> 4 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x16 , (value & 0xFF) ) ;
+
+    /* VRS SR0A[3] CR7[7][2] CR10 */
+    value = LVDSVRS - 1 ;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0A , ~0x08 , ( value & 0x400 ) >> 7 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x80 , ( value & 0x200 ) >> 2 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x04 , ( value & 0x100 ) >> 6 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x10 , (value & 0xFF) ) ;
+
+    /* Panel VRS SR35[2:0] SR34[7:0] */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x35 , ~0x07 , ( value & 0x700 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x34 , value & 0xFF ) ;
+
+    /* VRE SR0A[5] CR11[3:0] */
+    value = LVDSVRE - 1;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0A , ~0x20 , ( value & 0x10 ) << 1 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x11 , ~0x0F , value & 0x0F ) ;
+
+    /* Panel VRE SR3F[7:2] */ 
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x3F , ~0xFC , ( value << 2 ) & 0xFC ) ;
+    
+    for ( temp=0, value = 0; temp < 3; temp++)
+    {
+        
+        XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x31 , ~0x30 , value ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , pVBInfo->XG21_LVDSCapList[lvdstableindex].VCLKData1) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , pVBInfo->XG21_LVDSCapList[lvdstableindex].VCLKData2) ;
+        value += 0x10;
+    }
+
+    if (!( modeflag & Charx8Dot ))
+    {
+        XGINew_GetReg2( pVBInfo->P3da ) ;           /* reset 3da */
+        XGINew_SetReg3( pVBInfo->P3c0 , 0x13 ) ;    /* set index */
+        XGINew_SetReg3( pVBInfo->P3c0 , 0x00 ) ;    /* set data, panning = 0, shift left 1 dot*/
+
+        XGINew_GetReg2( pVBInfo->P3da ) ;           /* Enable Attribute */
+        XGINew_SetReg3( pVBInfo->P3c0 , 0x20 ) ;
+
+        XGINew_GetReg2( pVBInfo->P3da ) ;           /* reset 3da */
+    }
+    
+
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_IsLCDON */
+/* Input : */
+/* Output : FALSE : Skip PSC Control */
+/* TRUE: Disable PSC */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_IsLCDON(PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempax ;
+
+    tempax = pVBInfo->VBInfo ;
+    if ( tempax & SetCRT2ToDualEdge )
+        return FALSE ;
+    else if ( tempax & ( DisableCRT2Display | SwitchToCRT2 | SetSimuScanMode ) )
+        return TRUE ;
+
+    return FALSE ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_EnablePWD */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_EnablePWD(  PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT index ,
+           temp ;
+
+    index = XGI_GetLCDCapPtr(pVBInfo) ;
+    temp = pVBInfo->LCDCapList[ index ].PWD_2B ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x2B , temp ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x2C , pVBInfo->LCDCapList[ index ].PWD_2C ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x2D , pVBInfo->LCDCapList[ index ].PWD_2D ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x2E , pVBInfo->LCDCapList[ index ].PWD_2E ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x2F , pVBInfo->LCDCapList[ index ].PWD_2F ) ;
+    XGINew_SetRegOR( pVBInfo->Part4Port , 0x27 , 0x80 ) ; 	/* enable PWD */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_DisablePWD */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_DisablePWD( PVB_DEVICE_INFO pVBInfo )
+{
+    XGINew_SetRegAND( pVBInfo->Part4Port , 0x27 , 0x7F ) ;	/* disable PWD */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_DisableChISLCD */
+/* Input : */
+/* Output : FALSE -> Not LCD Mode */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_DisableChISLCD(PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempbx ,
+           tempah ;
+
+    tempbx = pVBInfo->SetFlag & ( DisableChA | DisableChB ) ;
+    tempah = ~( ( USHORT )XGINew_GetReg1( pVBInfo->Part1Port  , 0x2E ) ) ;
+
+    if ( tempbx & ( EnableChA | DisableChA ) )
+    {
+        if ( !( tempah & 0x08 ) )		/* Chk LCDA Mode */
+            return FALSE ;
+    }
+
+    if ( !( tempbx & ( EnableChB | DisableChB ) ) )
+        return FALSE ;
+
+    if ( tempah & 0x01 )       /* Chk LCDB Mode */
+        return TRUE ;
+
+    return FALSE ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_EnableChISLCD */
+/* Input : */
+/* Output : 0 -> Not LCD mode */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_EnableChISLCD(PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempbx ,
+           tempah ;
+
+
+    tempbx = pVBInfo->SetFlag & ( EnableChA | EnableChB ) ;
+    tempah = ~( ( USHORT )XGINew_GetReg1( pVBInfo->Part1Port , 0x2E ) ) ;
+
+    if ( tempbx & ( EnableChA | DisableChA ) )
+    {
+        if ( !( tempah & 0x08 ) )		/* Chk LCDA Mode */
+            return FALSE ;
+    }
+
+    if ( !( tempbx & ( EnableChB | DisableChB ) ) )
+        return FALSE ;
+
+    if ( tempah & 0x01 )       /* Chk LCDB Mode */
+        return TRUE ;
+
+    return FALSE ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetLCDCapPtr */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT XGI_GetLCDCapPtr(  PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR tempal ,
+          tempah ,
+          tempbl ,
+          i ;
+
+    tempah = XGINew_GetReg1( pVBInfo->P3d4 , 0x36 ) ;
+    tempal = tempah & 0x0F ;
+    tempah = tempah & 0xF0 ;
+    i = 0 ;
+    tempbl =  pVBInfo->LCDCapList[ i ].LCD_ID ;
+
+    while( tempbl != 0xFF )
+    {
+        if ( tempbl & 0x80 )   /* OEMUtil */
+        {
+            tempal = tempah ;
+            tempbl = tempbl & ~( 0x80 ) ;
+        }
+
+        if ( tempal == tempbl )
+            break ;
+
+        i++ ;
+
+        tempbl = pVBInfo->LCDCapList[ i ].LCD_ID ;
+    }
+
+    return i ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetLCDCapPtr1 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT XGI_GetLCDCapPtr1( PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempah ,
+           tempal ,
+           tempbl ,
+           i ;
+
+    tempal = pVBInfo->LCDResInfo ;
+    tempah = pVBInfo->LCDTypeInfo ;
+
+    i = 0 ;
+    tempbl =  pVBInfo->LCDCapList[ i ].LCD_ID;
+
+    while( tempbl != 0xFF )
+    {
+        if ( ( tempbl & 0x80 ) && ( tempbl != 0x80 ) )
+        {
+            tempal = tempah ;
+            tempbl &= ~0x80 ;
+        }
+
+        if ( tempal == tempbl )
+            break ;
+
+        i++ ;
+        tempbl = pVBInfo->LCDCapList[ i ].LCD_ID ;
+    }
+
+    if ( tempbl == 0xFF )
+    {
+        pVBInfo->LCDResInfo = Panel1024x768 ;
+        pVBInfo->LCDTypeInfo = 0 ;
+        i = 0 ;
+    }
+
+    return i ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetLCDSync */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetLCDSync( USHORT* HSyncWidth , USHORT* VSyncWidth, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT Index ;
+
+    Index = XGI_GetLCDCapPtr(pVBInfo) ;
+    *HSyncWidth = pVBInfo->LCDCapList[ Index ].LCD_HSyncWidth ;
+    *VSyncWidth = pVBInfo->LCDCapList[ Index ].LCD_VSyncWidth ;
+
+    return ;
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_EnableBridge */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_EnableBridge( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo)
+{
+#ifndef LINUX_XF86
+    USHORT tempax ;
+#endif
+    USHORT tempbl ,
+           tempah ;
+
+    if ( pVBInfo->SetFlag == Win9xDOSMode )
+    {
+        if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        {
+            XGI_DisplayOn( HwDeviceExtension, pVBInfo) ;
+            return ;
+        }
+        else  /* LVDS or CH7017 */
+            return ;
+    }
+
+
+    if ( HwDeviceExtension->jChipType < XG40 )
+    {
+        if ( !XGI_DisableChISLCD(pVBInfo) )
+        {
+            if ( ( XGI_EnableChISLCD(pVBInfo) ) || ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) ) )
+            {
+                if ( pVBInfo->LCDInfo & SetPWDEnable )
+                {
+                    XGI_EnablePWD( pVBInfo);
+                }
+                else
+                {
+                    pVBInfo->LCDInfo &= ( ~SetPWDEnable ) ;
+                    if ( pVBInfo->VBType & ( VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+                    {
+                        tempbl = 0xFD ;
+                        tempah = 0x02 ;
+                    }
+                    else
+                    {
+                        tempbl = 0xFB ;
+                        tempah = 0x00 ;
+                    }
+
+                    XGI_SetPanelPower( tempah , tempbl, pVBInfo ) ;
+                    XGI_SetPanelDelay( 1,pVBInfo ) ;
+                }
+            }
+        }
+    }	/* Not 340 */
+
+
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        if ( !( pVBInfo->SetFlag & DisableChA ) )
+        {
+            if ( pVBInfo->SetFlag & EnableChA )
+            {
+                XGINew_SetReg1( pVBInfo->Part1Port , 0x1E , 0x20 ) ;  /* Power on */
+            }
+            else
+            {
+                if ( pVBInfo->VBInfo & SetCRT2ToDualEdge ) /* SetCRT2ToLCDA ) */
+                {
+                    XGINew_SetReg1(pVBInfo->Part1Port,0x1E,0x20);  /* Power on */
+                }
+            }
+        }
+
+        if ( !( pVBInfo->SetFlag & DisableChB ) )
+        {
+            if ( ( pVBInfo->SetFlag & EnableChB ) || ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToTV | SetCRT2ToRAMDAC ) ) )
+            {
+                tempah = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x32 ) ;
+                tempah &= 0xDF;
+                if ( pVBInfo->VBInfo & SetInSlaveMode )
+                {
+                    if ( !( pVBInfo->VBInfo & SetCRT2ToRAMDAC ) )
+                        tempah |= 0x20 ;
+                }
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x32 , tempah ) ;
+                XGINew_SetRegOR( pVBInfo->P3c4 , 0x1E , 0x20 ) ;
+
+
+                tempah = ( UCHAR )XGINew_GetReg1( pVBInfo->Part1Port , 0x2E ) ;
+
+                if ( !( tempah & 0x80 ) )
+                    XGINew_SetRegOR( pVBInfo->Part1Port , 0x2E , 0x80 ) ;   	/* BVBDOENABLE = 1 */
+
+                XGINew_SetRegAND( pVBInfo->Part1Port , 0x00 , 0x7F ) ;     	/* BScreenOFF = 0 */
+            }
+        }
+
+        if ( ( pVBInfo->SetFlag & ( EnableChA | EnableChB ) ) || ( !( pVBInfo->VBInfo & DisableCRT2Display ) ) )
+        {
+            XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x00 , ~0xE0 , 0x20 ) ;   /* shampoo 0129 */
+            if ( pVBInfo->VBType & ( VB_XGI302LV | VB_XGI301C ) )
+            {
+                if ( !XGI_DisableChISLCD(pVBInfo) )
+                {
+                    if ( XGI_EnableChISLCD( pVBInfo) || ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) ) )
+                        XGINew_SetRegAND( pVBInfo->Part4Port ,0x2A , 0x7F ) ;  	/* LVDS PLL power on */
+                }
+                XGINew_SetRegAND( pVBInfo->Part4Port , 0x30 , 0x7F ) ;		/* LVDS Driver power on */
+            }
+        }
+
+        tempah = 0x00 ;
+
+        if ( !( pVBInfo->VBInfo & DisableCRT2Display ) )
+        {
+            tempah = 0xc0 ;
+
+            if ( !( pVBInfo->VBInfo & SetSimuScanMode ) )
+            {
+                if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+                {
+                    if ( pVBInfo->VBInfo & SetCRT2ToDualEdge )
+                    {
+                        tempah = tempah & 0x40;
+                        if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+                            tempah = tempah ^ 0xC0 ;
+
+                        if ( pVBInfo->SetFlag & DisableChB )
+                            tempah &= 0xBF ;
+
+                        if ( pVBInfo->SetFlag & DisableChA )
+                            tempah &= 0x7F ;
+
+                        if ( pVBInfo->SetFlag & EnableChB )
+                            tempah |= 0x40 ;
+
+                        if ( pVBInfo->SetFlag & EnableChA )
+                            tempah |= 0x80 ;
+                    }
+                }
+            }
+        }
+
+        XGINew_SetRegOR( pVBInfo->Part4Port , 0x1F , tempah ) ;          /* EnablePart4_1F */
+
+        if ( pVBInfo->SetFlag & Win9xDOSMode )
+        {
+            XGI_DisplayOn( HwDeviceExtension, pVBInfo) ;
+            return ;
+        }
+
+        if ( !( pVBInfo->SetFlag & DisableChA ) )
+        {
+            XGI_VBLongWait( pVBInfo) ;
+            if ( !( pVBInfo->SetFlag & GatingCRT ) )
+            {
+                XGI_DisableGatingCRT( HwDeviceExtension, pVBInfo ) ;
+                XGI_DisplayOn( HwDeviceExtension, pVBInfo) ;
+                XGI_VBLongWait( pVBInfo) ;
+            }
+        }
+    }	/* 301 */
+    else 	/* LVDS */
+    {
+        if ( pVBInfo->VBInfo & ( SetCRT2ToTV | SetCRT2ToLCD | SetCRT2ToLCDA ) )
+            XGINew_SetRegOR( pVBInfo->Part1Port , 0x1E , 0x20 ) ;      	/* enable CRT2 */
+
+
+
+        tempah = ( UCHAR )XGINew_GetReg1( pVBInfo->Part1Port , 0x2E ) ;
+        if ( !( tempah & 0x80 ) )
+            XGINew_SetRegOR( pVBInfo->Part1Port , 0x2E , 0x80 ) ;	/* BVBDOENABLE = 1 */
+
+        XGINew_SetRegAND(pVBInfo->Part1Port,0x00,0x7F);
+        XGI_DisplayOn( HwDeviceExtension, pVBInfo);
+    } /* End of VB */
+
+
+    if ( HwDeviceExtension->jChipType < XG40 )
+    {
+        if ( !XGI_EnableChISLCD(pVBInfo) )
+        {
+            if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+            {
+                if ( XGI_BacklightByDrv(pVBInfo) )
+                    return ;
+            }
+            else
+                return ;
+        }
+
+        if ( pVBInfo->LCDInfo & SetPWDEnable )
+        {
+            XGI_FirePWDEnable(pVBInfo) ;
+            return ;
+        }
+
+        XGI_SetPanelDelay( 2,pVBInfo ) ;
+
+        if ( pVBInfo->VBType & ( VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        {
+            tempah = 0x01 ;
+            tempbl = 0xFE ;		/* turn on backlght */
+        }
+        else
+        {
+            tempbl = 0xF7 ;
+            tempah = 0x00 ;
+        }
+        XGI_SetPanelPower( tempah , tempbl , pVBInfo) ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_DisableBridge */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_DisableBridge(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempax ,
+           tempbx ,
+           tempah = 0 ,
+           tempbl = 0 ;
+
+    if ( pVBInfo->SetFlag == Win9xDOSMode )
+        return ;
+
+
+    if ( HwDeviceExtension->jChipType < XG40 )
+    {
+        if ( ( !( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) ) ) || ( XGI_DisableChISLCD(pVBInfo) ) )
+        {
+            if ( !XGI_IsLCDON(pVBInfo) )
+            {
+                if ( pVBInfo->LCDInfo & SetPWDEnable )
+                    XGI_EnablePWD( pVBInfo) ;
+                else
+                {
+                    pVBInfo->LCDInfo &= ~SetPWDEnable ;
+                    XGI_DisablePWD(pVBInfo) ;
+                    if ( pVBInfo->VBType & ( VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+                    {
+                        tempbx = 0xFE ;  /* not 01h */
+                        tempax = 0 ;
+                    }
+                    else
+                    {
+                        tempbx = 0xF7 ;  /* not 08h */
+                        tempax = 0x08 ;
+                    }
+                    XGI_SetPanelPower( tempax , tempbx , pVBInfo) ;
+                    XGI_SetPanelDelay( 3,pVBInfo ) ;
+                }
+            }	/* end if(!XGI_IsLCDON(pVBInfo)) */
+        }
+    }
+
+/*  if ( CH7017 )
+    {
+        if ( !( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2toLCDA ) ) || ( XGI_DisableChISLCD(pVBInfo) ) )
+        {
+            if ( !XGI_IsLCDON(pVBInfo) )
+            {
+                if ( DISCHARGE )
+                {
+                    tempbx = XGINew_GetCH7005( 0x61 ) ;
+                    if ( tempbx < 0x01 )   //first time we power up
+                        XGINew_SetCH7005( 0x0066 ) ;	//and disable power sequence
+                    else
+                        XGINew_SetCH7005( 0x5f66 ) ; //leave VDD on - disable power
+                }
+            }
+        }
+    }        */
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B| VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        tempah = 0x3F ;
+        if ( !( pVBInfo->VBInfo & ( DisableCRT2Display | SetSimuScanMode ) ) )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+            {
+                if ( pVBInfo->VBInfo & SetCRT2ToDualEdge )
+                {
+                    tempah = 0x7F;			/* Disable Channel A */
+                    if ( !( pVBInfo->VBInfo & SetCRT2ToLCDA ) )
+                        tempah = 0xBF ;		/* Disable Channel B */
+
+                    if ( pVBInfo->SetFlag & DisableChB )
+                        tempah &= 0xBF ;		/* force to disable Cahnnel */
+
+                    if ( pVBInfo->SetFlag & DisableChA )
+                        tempah &= 0x7F ;		/* Force to disable Channel B */
+                }
+            }
+        }
+
+        XGINew_SetRegAND( pVBInfo->Part4Port , 0x1F , tempah ) ;   /* disable part4_1f */
+
+        if ( pVBInfo->VBType & ( VB_XGI302LV | VB_XGI301C ) )
+        {
+            if ( ( ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) ) ) || ( XGI_DisableChISLCD(pVBInfo) ) || ( XGI_IsLCDON(pVBInfo) ) )
+                XGINew_SetRegOR( pVBInfo->Part4Port , 0x30 , 0x80 ) ;  /* LVDS Driver power down */
+        }
+
+        if ( ( pVBInfo->SetFlag & DisableChA ) || ( pVBInfo->VBInfo & ( DisableCRT2Display | SetCRT2ToLCDA | SetSimuScanMode ) ) )
+        {
+            if ( pVBInfo->SetFlag & GatingCRT )
+                XGI_EnableGatingCRT( HwDeviceExtension, pVBInfo ) ;
+            XGI_DisplayOff( HwDeviceExtension, pVBInfo) ;
+        }
+
+        if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+        {
+            if ( ( pVBInfo->SetFlag & DisableChA ) || ( pVBInfo->VBInfo & SetCRT2ToLCDA ) )
+                XGINew_SetRegAND( pVBInfo->Part1Port , 0x1e , 0xdf ) ; 	/* Power down */
+        }
+
+        XGINew_SetRegAND( pVBInfo->P3c4 , 0x32 , 0xdf ) ; 		/* disable TV as primary VGA swap */
+
+        if ( ( pVBInfo->VBInfo & ( SetSimuScanMode | SetCRT2ToDualEdge  ) ) )
+            XGINew_SetRegAND(pVBInfo->Part2Port,0x00,0xdf);
+
+        if ( ( pVBInfo->SetFlag & DisableChB ) || ( pVBInfo->VBInfo & ( DisableCRT2Display | SetSimuScanMode ) )
+        || ( ( !( pVBInfo->VBInfo & SetCRT2ToLCDA ) ) && ( pVBInfo->VBInfo & ( SetCRT2ToRAMDAC | SetCRT2ToLCD | SetCRT2ToTV ) ) ) )
+            XGINew_SetRegOR( pVBInfo->Part1Port , 0x00 , 0x80 ) ; 	/* BScreenOff=1 */
+
+        if ( ( pVBInfo->SetFlag & DisableChB ) || ( pVBInfo->VBInfo & ( DisableCRT2Display | SetSimuScanMode ) )
+        || ( !( pVBInfo->VBInfo & SetCRT2ToLCDA ) ) || ( pVBInfo->VBInfo & ( SetCRT2ToRAMDAC | SetCRT2ToLCD | SetCRT2ToTV ) ) )
+        {
+            tempah= XGINew_GetReg1( pVBInfo->Part1Port , 0x00 ) ;   	/* save Part1 index 0 */
+            XGINew_SetRegOR( pVBInfo->Part1Port , 0x00 , 0x10 ) ; 	/* BTDAC = 1, avoid VB reset */
+            XGINew_SetRegAND( pVBInfo->Part1Port , 0x1E , 0xDF ) ;	/* disable CRT2 */
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x00 , tempah ) ;	/* restore Part1 index 0 */
+        }
+    }
+    else /* {301} */
+    {
+        if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToTV ) )
+        {
+            XGINew_SetRegOR( pVBInfo->Part1Port , 0x00 , 0x80 ) ; 	/* BScreenOff=1 */
+            XGINew_SetRegAND( pVBInfo->Part1Port , 0x1E , 0xDF ) ;	/* Disable CRT2 */
+            XGINew_SetRegAND( pVBInfo->P3c4 , 0x32 , 0xDF ) ;	/* Disable TV asPrimary VGA swap */
+        }
+
+        if ( pVBInfo->VBInfo & ( DisableCRT2Display | SetCRT2ToLCDA | SetSimuScanMode ) )
+            XGI_DisplayOff( HwDeviceExtension, pVBInfo) ;
+    }
+
+
+
+
+    if ( HwDeviceExtension->jChipType < XG40 )
+    {
+        if ( !( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) ) || ( XGI_DisableChISLCD(pVBInfo) ) || ( XGI_IsLCDON(pVBInfo) ) )
+        {
+            if ( pVBInfo->LCDInfo & SetPWDEnable )
+            {
+                if ( pVBInfo->LCDInfo & SetPWDEnable )
+                    XGI_BacklightByDrv(pVBInfo) ;
+                else
+                {
+                    XGI_SetPanelDelay( 4 ,pVBInfo) ;
+                    if ( pVBInfo->VBType & VB_XGI301LV )
+                    {
+                        tempbl = 0xFD ;
+                        tempah = 0x00 ;
+                    }
+                    else
+                    {
+                        tempbl = 0xFB ;
+                        tempah = 0x04 ;
+                    }
+                }
+            }
+            XGI_SetPanelPower( tempah , tempbl , pVBInfo) ;
+        }
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetTVPtrIndex */
+/* Input : */
+/* Output : */
+/* Description : bx 0 : ExtNTSC */
+/* 1 : StNTSC */
+/* 2 : ExtPAL */
+/* 3 : StPAL */
+/* 4 : ExtHiTV */
+/* 5 : StHiTV */
+/* 6 : Ext525i */
+/* 7 : St525i */
+/* 8 : Ext525p */
+/* 9 : St525p */
+/* A : Ext750p */
+/* B : St750p */
+/* --------------------------------------------------------------------- */
+USHORT XGI_GetTVPtrIndex(  PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempbx = 0 ;
+
+    if ( pVBInfo->TVInfo & SetPALTV )
+        tempbx = 2 ;
+    if ( pVBInfo->TVInfo & SetYPbPrMode1080i )
+        tempbx = 4 ;
+    if ( pVBInfo->TVInfo & SetYPbPrMode525i )
+        tempbx = 6 ;
+    if ( pVBInfo->TVInfo & SetYPbPrMode525p )
+        tempbx = 8 ;
+    if ( pVBInfo->TVInfo & SetYPbPrMode750p )
+        tempbx = 10 ;
+    if ( pVBInfo->TVInfo & TVSimuMode )
+        tempbx++ ;
+
+    return tempbx ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_OEM310Setting */
+/* Input : */
+/* Output : */
+/* Description : Customized Param. for 301 */
+/* --------------------------------------------------------------------- */
+void XGI_OEM310Setting( USHORT ModeNo , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo)
+{
+    if ( pVBInfo->SetFlag & Win9xDOSMode )
+        return ;
+
+    /* GetPart1IO(); */
+    XGI_SetDelayComp(pVBInfo) ;
+
+    if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+        XGI_SetLCDCap(pVBInfo) ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToTV )
+    {
+        /* GetPart2IO() */
+        XGI_SetPhaseIncr(pVBInfo) ;
+        XGI_SetYFilter( ModeNo , ModeIdIndex,pVBInfo ) ;
+        XGI_SetAntiFlicker( ModeNo , ModeIdIndex,pVBInfo ) ;
+
+        if ( pVBInfo->VBType&VB_XGI301)
+            XGI_SetEdgeEnhance( ModeNo , ModeIdIndex ,pVBInfo) ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetDelayComp */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetDelayComp( PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT index ;
+
+    UCHAR  tempah ,
+           tempbl ,
+           tempbh ;
+#ifndef LINUX_XF86
+    UCHAR  temp ;
+#endif
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA | SetCRT2ToTV | SetCRT2ToRAMDAC ) )
+        {
+            tempbl = 0;
+            tempbh = 0;
+
+            index = XGI_GetTVPtrIndex(pVBInfo ) ;           /* Get TV Delay */
+            tempbl = pVBInfo->XGI_TVDelayList[ index ] ;
+
+            if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+                tempbl = pVBInfo->XGI_TVDelayList2[ index ] ;
+
+            if ( pVBInfo->VBInfo & SetCRT2ToDualEdge )
+                tempbl = tempbl >> 4 ;
+/*
+            if ( pVBInfo->VBInfo & SetCRT2ToRAMDAC )
+                tempbl = CRT2Delay1 ;			// Get CRT2 Delay
+
+            if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+                tempbl = CRT2Delay2 ;
+*/
+            if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+            {
+                index = XGI_GetLCDCapPtr(pVBInfo) ; 		/* Get LCD Delay */
+                tempbh=pVBInfo->LCDCapList[ index ].LCD_DelayCompensation ;
+
+                if ( !( pVBInfo->VBInfo & SetCRT2ToLCDA ) )
+                     tempbl = tempbh ;
+            }
+
+            tempbl  &= 0x0F ;
+            tempbh  &= 0xF0 ;
+            tempah = XGINew_GetReg1( pVBInfo->Part1Port , 0x2D ) ;
+
+            if ( pVBInfo->VBInfo & ( SetCRT2ToRAMDAC | SetCRT2ToLCD | SetCRT2ToTV ) )  /* Channel B */
+            {
+                tempah &= 0xF0 ;
+                tempah |= tempbl ;
+            }
+
+            if ( pVBInfo->VBInfo & SetCRT2ToLCDA )		/* Channel A */
+            {
+                tempah &= 0x0F ;
+                tempah |= tempbh ;
+            }
+            XGINew_SetReg1(pVBInfo->Part1Port,0x2D,tempah);
+        }
+    }
+    else if ( pVBInfo->IF_DEF_LVDS == 1 )
+    {
+        tempbl = 0;
+        tempbh = 0;
+        if ( pVBInfo->VBInfo & SetCRT2ToLCD )
+        {
+            tempah = pVBInfo->LCDCapList[ XGI_GetLCDCapPtr(pVBInfo) ].LCD_DelayCompensation ;		/* / Get LCD Delay */
+            tempah &= 0x0f ;
+            tempah = tempah << 4 ;
+            XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x2D , 0x0f , tempah ) ;
+        }
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetLCDCap */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetLCDCap( PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempcx ;
+
+    tempcx = pVBInfo->LCDCapList[ XGI_GetLCDCapPtr(pVBInfo) ].LCD_Capability ;
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        if ( pVBInfo->VBType & ( VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        {        				/* 301LV/302LV only */
+            /* Set 301LV Capability */
+            XGINew_SetReg1( pVBInfo->Part4Port , 0x24 , ( UCHAR )( tempcx & 0x1F ) ) ;
+	}
+        /* VB Driving */
+        XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x0D , ~( ( EnableVBCLKDRVLOW | EnablePLLSPLOW ) >> 8 ) , ( USHORT )( ( tempcx & ( EnableVBCLKDRVLOW | EnablePLLSPLOW ) ) >> 8 ) ) ;
+    }
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        if ( pVBInfo->VBInfo & SetCRT2ToLCD )
+            XGI_SetLCDCap_B( tempcx,pVBInfo ) ;
+        else if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+            XGI_SetLCDCap_A( tempcx,pVBInfo ) ;
+
+        if ( pVBInfo->VBType & ( VB_XGI302LV | VB_XGI301C ) )
+        {
+            if ( tempcx & EnableSpectrum )
+                SetSpectrum( pVBInfo) ;
+        }
+    }
+    else      /* LVDS,CH7017 */
+        XGI_SetLCDCap_A( tempcx, pVBInfo ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetLCDCap_A */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetLCDCap_A(USHORT tempcx,PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT temp ;
+
+    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x37 ) ;
+
+    if ( temp & LCDRGB18Bit )
+    {
+        XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x19 , 0x0F , ( USHORT )( 0x20 | ( tempcx & 0x00C0 ) ) ) ; /* Enable Dither */
+        XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x1A , 0x7F , 0x80 ) ;
+    }
+    else
+    {
+        XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x19 , 0x0F , ( USHORT )( 0x30 | ( tempcx & 0x00C0 ) ) ) ;
+        XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x1A , 0x7F , 0x00 ) ;
+    }
+
+/*
+    if ( tempcx & EnableLCD24bpp )	// 24bits
+    {
+        XGINew_SetRegANDOR(pVBInfo->Part1Port,0x19, 0x0F,(USHORT)(0x30|(tempcx&0x00C0)) );
+        XGINew_SetRegANDOR(pVBInfo->Part1Port,0x1A,0x7F,0x00);
+    }
+    else
+    {
+        XGINew_SetRegANDOR(pVBInfo->Part1Port,0x19, 0x0F,(USHORT)(0x20|(tempcx&0x00C0)) );//Enable Dither
+        XGINew_SetRegANDOR(pVBInfo->Part1Port,0x1A,0x7F,0x80);
+    }
+*/
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetLCDCap_B */
+/* Input : cx -> LCD Capability */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetLCDCap_B(USHORT tempcx,PVB_DEVICE_INFO pVBInfo)
+{
+    if ( tempcx & EnableLCD24bpp )	/* 24bits */
+        XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x1A , 0xE0 , ( USHORT )( ( ( tempcx & 0x00ff ) >> 6 ) | 0x0c ) ) ;
+    else
+        XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x1A , 0xE0 , ( USHORT )( ( ( tempcx & 0x00ff ) >> 6 ) | 0x18 ) ) ; /* Enable Dither */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : SetSpectrum */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void SetSpectrum( PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT index ;
+
+    index = XGI_GetLCDCapPtr(pVBInfo) ;
+
+    XGINew_SetRegAND( pVBInfo->Part4Port , 0x30 , 0x8F ) ;   /* disable down spectrum D[4] */
+    XGI_LongWait(pVBInfo) ;
+    XGINew_SetRegOR( pVBInfo->Part4Port , 0x30 , 0x20 ) ;	 /* reset spectrum */
+    XGI_LongWait(pVBInfo) ;
+
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x31 , pVBInfo->LCDCapList[ index ].Spectrum_31 ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x32 , pVBInfo->LCDCapList[ index ].Spectrum_32 ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x33 , pVBInfo->LCDCapList[ index ].Spectrum_33 ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x34 , pVBInfo->LCDCapList[ index ].Spectrum_34 ) ;
+    XGI_LongWait(pVBInfo) ;
+    XGINew_SetRegOR( pVBInfo->Part4Port , 0x30 , 0x40 ) ; /* enable spectrum */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetAntiFlicker */
+/* Input : */
+/* Output : */
+/* Description : Set TV Customized Param. */
+/* --------------------------------------------------------------------- */
+void XGI_SetAntiFlicker( USHORT ModeNo , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempbx ,
+           index ;
+
+    UCHAR tempah ;
+
+    if (pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p ) )
+        return ;
+
+    tempbx = XGI_GetTVPtrIndex(pVBInfo ) ;
+    tempbx &= 0xFE ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        index = pVBInfo->SModeIDTable[ ModeIdIndex ].VB_StTVFlickerIndex ;
+    }
+    else
+    {
+        index = pVBInfo->EModeIDTable[ ModeIdIndex ].VB_ExtTVFlickerIndex ;
+    }
+
+    tempbx += index ;
+    tempah = TVAntiFlickList[ tempbx ] ;
+    tempah = tempah << 4 ;
+
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x0A , 0x8F , tempah ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetEdgeEnhance */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetEdgeEnhance( USHORT ModeNo , USHORT ModeIdIndex , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempbx ,
+           index ;
+
+    UCHAR tempah ;
+
+
+    tempbx = XGI_GetTVPtrIndex(pVBInfo ) ;
+    tempbx &= 0xFE ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        index = pVBInfo->SModeIDTable[ ModeIdIndex ].VB_StTVEdgeIndex ;
+    }
+    else
+    {
+        index = pVBInfo->EModeIDTable[ ModeIdIndex ].VB_ExtTVEdgeIndex ;
+    }
+
+    tempbx += index ;
+    tempah = TVEdgeList[ tempbx ] ;
+    tempah = tempah << 5 ;
+
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x3A , 0x1F , tempah ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetPhaseIncr */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetPhaseIncr( PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempbx ;
+
+    UCHAR tempcl ,
+          tempch ;
+
+    ULONG tempData ;
+
+    XGI_GetTVPtrIndex2( &tempbx , &tempcl , &tempch, pVBInfo ) ; /* bx, cl, ch */
+    tempData = TVPhaseList[ tempbx ] ;
+
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x31 , ( USHORT )( tempData & 0x000000FF ) ) ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x32 , ( USHORT )( ( tempData & 0x0000FF00 ) >> 8 ) ) ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x33 , ( USHORT )( ( tempData & 0x00FF0000 ) >> 16 ) ) ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x34 , ( USHORT )( ( tempData & 0xFF000000 ) >> 24 ) ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetYFilter */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetYFilter( USHORT ModeNo , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempbx ,
+           index ;
+
+    UCHAR tempcl ,
+          tempch ,
+          tempal ,
+          *filterPtr ;
+
+    XGI_GetTVPtrIndex2( &tempbx , &tempcl , &tempch, pVBInfo ) ; /* bx, cl, ch */
+
+    switch( tempbx )
+    {
+        case 0x00:
+        case 0x04:
+            filterPtr = NTSCYFilter1 ;
+            break ;
+
+        case 0x01:
+            filterPtr = PALYFilter1 ;
+            break ;
+
+        case 0x02:
+        case 0x05:
+        case 0x0D:
+            filterPtr = PALMYFilter1 ;
+            break ;
+
+        case 0x03:
+            filterPtr = PALNYFilter1 ;
+            break ;
+
+        case 0x08:
+        case 0x0C:
+            filterPtr = NTSCYFilter2 ;
+            break ;
+
+        case 0x0A:
+            filterPtr = PALMYFilter2 ;
+            break ;
+
+        case 0x0B:
+            filterPtr = PALNYFilter2 ;
+            break ;
+
+        case 0x09:
+            filterPtr = PALYFilter2 ;
+            break ;
+
+        default:
+            return ;
+    }
+
+    if ( ModeNo <= 0x13 )
+        tempal = pVBInfo->SModeIDTable[ ModeIdIndex ].VB_StTVYFilterIndex ;
+    else
+        tempal = pVBInfo->EModeIDTable[ ModeIdIndex ].VB_ExtTVYFilterIndex ;
+
+    if ( tempcl == 0 )
+        index = tempal * 4;
+    else
+        index = tempal * 7;
+
+    if ( ( tempcl == 0 ) && ( tempch == 1 ) )
+    {
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x35 , 0 ) ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x36 , 0 ) ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x37 , 0 ) ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x38 , filterPtr[ index++ ] ) ;
+    }
+    else
+    {
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x35 , filterPtr[ index++ ] ) ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x36 , filterPtr[ index++ ] ) ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x37 , filterPtr[ index++ ] ) ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x38 , filterPtr[ index++ ] ) ;
+    }
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x48 , filterPtr[ index++ ] ) ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x49 , filterPtr[ index++ ] ) ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x4A , filterPtr[ index++ ] ) ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetTVPtrIndex2 */
+/* Input : */
+/* Output : bx 0 : NTSC */
+/* 1 : PAL */
+/* 2 : PALM */
+/* 3 : PALN */
+/* 4 : NTSC1024x768 */
+/* 5 : PAL-M 1024x768 */
+/* 6-7: reserved */
+/* cl 0 : YFilter1 */
+/* 1 : YFilter2 */
+/* ch 0 : 301A */
+/* 1 : 301B/302B/301LV/302LV */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetTVPtrIndex2(USHORT* tempbx,UCHAR* tempcl,UCHAR* tempch, PVB_DEVICE_INFO pVBInfo)
+{
+    *tempbx = 0 ;
+    *tempcl = 0 ;
+    *tempch = 0 ;
+
+    if ( pVBInfo->TVInfo & SetPALTV )
+        *tempbx = 1 ;
+
+    if ( pVBInfo->TVInfo & SetPALMTV )
+        *tempbx = 2 ;
+
+    if ( pVBInfo->TVInfo & SetPALNTV )
+        *tempbx = 3 ;
+
+    if ( pVBInfo->TVInfo & NTSC1024x768 )
+    {
+        *tempbx = 4 ;
+        if ( pVBInfo->TVInfo & SetPALMTV )
+            *tempbx = 5 ;
+    }
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        if ( ( !( pVBInfo->VBInfo & SetInSlaveMode ) ) || ( pVBInfo->TVInfo & TVSimuMode ) )
+        {
+            *tempbx += 8 ;
+            *tempcl += 1 ;
+        }
+    }
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        *tempch++ ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT2ModeRegs */
+/* Input : */
+/* Output : */
+/* Description : Origin code for crt2group */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT2ModeRegs(USHORT ModeNo,PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+#ifndef LINUX_XF86
+    USHORT i ,
+           j ;
+#endif
+    USHORT tempbl ;
+    SHORT  tempcl ;
+
+    UCHAR  tempah ;
+
+    /* XGINew_SetReg1( pVBInfo->Part1Port , 0x03 , 0x00 ) ; // fix write part1 index 0 BTDRAM bit Bug */
+    tempah=0;
+    if ( !( pVBInfo->VBInfo & DisableCRT2Display ) )
+    {
+        tempah=XGINew_GetReg1( pVBInfo->Part1Port , 0x00 ) ;
+        tempah &= ~0x10 ;	/* BTRAMDAC */
+        tempah |=  0x40 ;	/* BTRAM */
+
+        if ( pVBInfo->VBInfo & ( SetCRT2ToRAMDAC | SetCRT2ToTV | SetCRT2ToLCD ) )
+        {
+            tempah=0x40;	/* BTDRAM */
+            if ( ModeNo > 0x13 )
+            {
+                tempcl = pVBInfo->ModeType ;
+                tempcl -= ModeVGA ;
+                if ( tempcl >= 0 )
+                {
+                    tempah = ( 0x008 >> tempcl ) ;	/* BT Color */
+                    if ( tempah == 0 )
+                        tempah = 1 ;
+                    tempah |= 0x040 ;
+                }
+            }
+            if ( pVBInfo->VBInfo & SetInSlaveMode )
+                tempah ^= 0x50 ;	/* BTDAC */
+        }
+    }
+
+/*	0210 shampoo
+    if ( pVBInfo->VBInfo & DisableCRT2Display )
+    {
+        tempah = 0 ;
+    }
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x00 , tempah ) ;
+    if ( pVBInfo->VBInfo & ( SetCRT2ToRAMDAC | SetCRT2ToTV | SetCRT2ToLCD ) )
+    {
+        tempcl = pVBInfo->ModeType ;
+        if ( ModeNo > 0x13 )
+        {
+            tempcl -= ModeVGA ;
+            if ( ( tempcl > 0 ) || ( tempcl == 0 ) )
+            {
+                tempah=(0x008>>tempcl) ;
+                if ( tempah == 0 )
+                    tempah = 1 ;
+                tempah |= 0x040;
+            }
+        }
+        else
+        {
+            tempah = 0x040 ;
+        }
+
+        if ( pVBInfo->VBInfo & SetInSlaveMode )
+        {
+            tempah = ( tempah ^ 0x050 ) ;
+        }
+    }
+*/
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x00 , tempah ) ;
+    tempah = 0x08 ;
+    tempbl = 0xf0 ;
+
+    if ( pVBInfo->VBInfo & DisableCRT2Display )
+        XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x2e , tempbl , tempah ) ;
+    else
+    {
+        tempah = 0x00 ;
+        tempbl = 0xff ;
+
+        if ( pVBInfo->VBInfo & ( SetCRT2ToRAMDAC | SetCRT2ToTV | SetCRT2ToLCD | SetCRT2ToLCDA ) )
+        {
+            if ( ( pVBInfo->VBInfo & SetCRT2ToLCDA ) && ( !( pVBInfo->VBInfo & SetSimuScanMode ) ) )
+            {
+                tempbl &= 0xf7 ;
+                tempah |= 0x01 ;
+                XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x2e , tempbl , tempah ) ;
+            }
+            else
+            {
+                if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+                {
+                    tempbl &= 0xf7 ;
+                    tempah |= 0x01 ;
+                }
+
+                if ( pVBInfo->VBInfo & ( SetCRT2ToRAMDAC | SetCRT2ToTV | SetCRT2ToLCD ) )
+                {
+                    tempbl &= 0xf8 ;
+                    tempah = 0x01 ;
+
+                    if ( !( pVBInfo->VBInfo & SetInSlaveMode ) )
+                        tempah |= 0x02 ;
+
+                    if ( !( pVBInfo->VBInfo & SetCRT2ToRAMDAC ) )
+                    {
+                        tempah = tempah ^ 0x05 ;
+                        if ( !( pVBInfo->VBInfo & SetCRT2ToLCD ) )
+                            tempah = tempah ^ 0x01 ;
+                    }
+
+                    if ( !( pVBInfo->VBInfo & SetCRT2ToDualEdge ) )
+                        tempah |= 0x08 ;
+                    XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x2e , tempbl , tempah ) ;
+                }
+                else
+                    XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x2e , tempbl , tempah ) ;
+            }
+        }
+        else
+            XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x2e , tempbl , tempah ) ;
+    }
+
+    if ( pVBInfo->VBInfo & ( SetCRT2ToRAMDAC | SetCRT2ToTV | SetCRT2ToLCD | SetCRT2ToLCDA ) )
+    {
+        tempah &= ( ~0x08 ) ;
+        if ( ( pVBInfo->ModeType == ModeVGA ) && ( !( pVBInfo->VBInfo & SetInSlaveMode ) ) )
+        {
+            tempah |= 0x010 ;
+        }
+        tempah |= 0x080 ;
+
+        if ( pVBInfo->VBInfo & SetCRT2ToTV )
+        {
+            /* if ( !( pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p ) ) ) */
+            /* { */
+            tempah |= 0x020 ;
+            if ( ModeNo > 0x13 )
+            {
+                if ( pVBInfo->VBInfo & DriverMode )
+                    tempah = tempah ^ 0x20 ;
+            }
+        /* } */
+        }
+
+        XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x0D , ~0x0BF , tempah ) ;
+        tempah = 0 ;
+
+        if ( pVBInfo->LCDInfo & SetLCDDualLink )
+            tempah |= 0x40 ;
+
+        if ( pVBInfo->VBInfo & SetCRT2ToTV )
+        {
+            /* if ( ( !( pVBInfo->VBInfo & SetCRT2ToHiVisionTV ) ) && ( !( pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p ) ) ) ) */
+            /* { */
+                if ( pVBInfo->TVInfo & RPLLDIV2XO )
+                    tempah |= 0x40 ;
+            /* } */
+        }
+
+        if ( ( pVBInfo->LCDResInfo == Panel1280x1024 ) || ( pVBInfo->LCDResInfo == Panel1280x1024x75 ) )
+            tempah |= 0x80 ;
+
+        if ( pVBInfo->LCDResInfo == Panel1280x960 )
+            tempah |= 0x80 ;
+
+        XGINew_SetReg1( pVBInfo->Part4Port , 0x0C , tempah ) ;
+    }
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        tempah = 0 ;
+        tempbl = 0xfb ;
+
+        if ( pVBInfo->VBInfo & SetCRT2ToDualEdge )
+        {
+            tempbl=0xff;
+            if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+                tempah |= 0x04 ; /* shampoo 0129 */
+        }
+
+        XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x13 , tempbl , tempah ) ;
+        tempah = 0x00 ;
+        tempbl = 0xcf ;
+        if ( !( pVBInfo->VBInfo & DisableCRT2Display ) )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToDualEdge )
+                tempah |= 0x30 ;
+        }
+
+        XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x2c , tempbl , tempah ) ;
+        tempah = 0 ;
+        tempbl = 0x3f ;
+
+        if ( !( pVBInfo->VBInfo & DisableCRT2Display ) )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToDualEdge )
+                tempah |= 0xc0 ;
+        }
+        XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x21 , tempbl , tempah ) ;
+    }
+
+    tempah = 0 ;
+    tempbl = 0x7f ;
+    if ( !( pVBInfo->VBInfo & SetCRT2ToLCDA ) )
+    {
+        tempbl = 0xff ;
+        if ( !( pVBInfo->VBInfo & SetCRT2ToDualEdge ) )
+            tempah |= 0x80 ;
+    }
+
+    XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x23 , tempbl , tempah ) ;
+
+    if ( pVBInfo->VBType & ( VB_XGI302LV | VB_XGI301C ) )
+    {
+        if ( pVBInfo->LCDInfo & SetLCDDualLink )
+        {
+            XGINew_SetRegOR( pVBInfo->Part4Port , 0x27 , 0x20 ) ;
+            XGINew_SetRegOR( pVBInfo->Part4Port , 0x34 , 0x10 ) ;
+        }
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_CloseCRTC */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_CloseCRTC( PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempbx ;
+#ifndef LINUX_XF86
+    USHORT temp ;
+#endif
+
+    tempbx = 0 ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+        tempbx = 0x08A0 ;
+
+
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_OpenCRTC */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_OpenCRTC( PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempbx ;
+#ifndef LINUX_XF86
+    USHORT temp ;
+#endif
+
+    tempbx = 0 ;
+
+
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetRAMDAC2DATA */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetRAMDAC2DATA(USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempax ,
+           tempbx ,
+           temp1 ,
+           temp2 ,
+           modeflag = 0 ,
+           tempcx ,
+           StandTableIndex ,
+           CRT1Index ;
+#ifndef LINUX_XF86
+    USHORT temp ,
+           ResInfo ,
+           DisplayType ;
+#endif
+
+    pVBInfo->RVBHCMAX = 1 ;
+    pVBInfo->RVBHCFACT = 1 ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+        StandTableIndex = XGI_GetModePtr( ModeNo , ModeIdIndex, pVBInfo ) ;
+        tempax = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 0 ] ;
+        tempbx = pVBInfo->StandTable[StandTableIndex ].CRTC[ 6 ] ;
+        temp1 = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 7 ] ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+        CRT1Index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT1CRTC ;
+        CRT1Index &= IndexMask ;
+        temp1 = ( USHORT )pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 0 ] ;
+        temp2 = ( USHORT )pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 5 ] ;
+	tempax = ( temp1 & 0xFF ) | ( ( temp2 & 0x03 ) << 8 ) ;
+        tempbx = ( USHORT )pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 8 ] ;
+        tempcx = ( USHORT )pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 14 ] << 8 ;
+	tempcx &= 0x0100 ;
+	tempcx = tempcx << 2 ;
+	tempbx |= tempcx;
+        temp1 = ( USHORT )pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 9 ] ;
+    }
+
+    if ( temp1 & 0x01 )
+        tempbx |= 0x0100 ;
+
+    if ( temp1 & 0x20 )
+        tempbx |= 0x0200 ;
+    tempax += 5 ;
+
+    if ( modeflag & Charx8Dot )
+        tempax *= 8 ;
+    else
+        tempax *= 9 ;
+
+    pVBInfo->VGAHT = tempax ;
+    pVBInfo->HT = tempax ;
+    tempbx++ ;
+    pVBInfo->VGAVT = tempbx ;
+    pVBInfo->VT = tempbx ;
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetColorDepth */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT XGI_GetColorDepth(USHORT ModeNo , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT ColorDepth[ 6 ] = { 1 , 2 , 4 , 4 , 6 , 8 } ;
+    SHORT  index ;
+    USHORT modeflag ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+    }
+
+    index=(modeflag&ModeInfoFlag)-ModeEGA;
+
+    if ( index < 0 )
+        index = 0 ;
+
+    return( ColorDepth[ index ] ) ;
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_UnLockCRT2 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_UnLockCRT2( PXGI_HW_DEVICE_INFO HwDeviceExtension,  PVB_DEVICE_INFO pVBInfo )
+{
+
+    XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x2f , 0xFF , 0x01 ) ;
+
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_LockCRT2 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_LockCRT2( PXGI_HW_DEVICE_INFO HwDeviceExtension,  PVB_DEVICE_INFO pVBInfo )
+{
+
+    XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x2F , 0xFE , 0x00 ) ;
+
+
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_EnableCRT2 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_EnableCRT2( PVB_DEVICE_INFO pVBInfo)
+{
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x1E , 0xFF , 0x20 ) ;
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_LCD_Wait_Time(UCHAR DelayTime, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT i ,
+           j ;
+
+    ULONG temp ,
+          flag ;
+
+    flag = 0 ;
+//printk("XGINew_LCD_Wait_Time");
+return;
+    for( i = 0 ; i < DelayTime ; i++ )
+    {
+        for( j = 0 ; j < 66 ; j++ )
+        {
+
+            temp =  XGINew_GetReg3( 0x61 ) ;
+
+            temp &= 0x10000000;
+            temp &= 0x10;
+            if ( temp == flag )
+                continue ;
+
+            flag = temp ;
+        }
+    }
+}
+
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_BridgeIsOn */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_BridgeIsOn( PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT flag ;
+
+    if ( pVBInfo->IF_DEF_LVDS == 1 )
+    {
+        return( 1 ) ;
+    }
+    else
+    {
+        flag = XGINew_GetReg1( pVBInfo->Part4Port , 0x00 ) ;
+        if ( ( flag == 1 ) || ( flag == 2 ) )
+            return( 1 ) ;	/* 301b */
+        else
+            return( 0 ) ;
+    }
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_LongWait */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_LongWait(PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT i ;
+
+    i = XGINew_GetReg1( pVBInfo->P3c4 , 0x1F ) ;
+
+    if ( !( i & 0xC0 ) )
+    {
+        for( i = 0 ; i < 0xFFFF ; i++ )
+        {
+            if ( !( XGINew_GetReg2( pVBInfo->P3da ) & 0x08 ) )
+                break ;
+        }
+
+        for( i = 0 ; i < 0xFFFF ; i++ )
+        {
+            if ( ( XGINew_GetReg2( pVBInfo->P3da ) & 0x08 ) )
+                break ;
+	}
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_VBLongWait */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_VBLongWait( PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempal ,
+           temp ,
+           i ,
+           j ;
+return ;
+    if ( !( pVBInfo->VBInfo & SetCRT2ToTV ) )
+    {
+        temp = 0 ;
+        for( i = 0 ; i < 3 ; i++ )
+        {
+            for( j = 0 ; j < 100 ; j++ )
+            { 
+                tempal = XGINew_GetReg2( pVBInfo->P3da ) ;
+                if ( temp & 0x01 )
+                {			/* VBWaitMode2 */
+                    if ( ( tempal & 0x08 ) )
+                    {
+                        continue ;
+                    }
+
+                    if ( !( tempal & 0x08 ) )
+                    {
+                        break ;
+                    }
+                }
+                else
+                {			/* VBWaitMode1 */
+                    if ( !( tempal & 0x08 ) )
+                    {
+                        continue ;
+                    }
+
+                    if ( ( tempal & 0x08 ) )
+                    {
+                        break ;
+                    }
+                }
+            }
+            temp = temp ^ 0x01 ;
+        }
+    }
+    else
+    {
+        XGI_LongWait(pVBInfo) ;
+    }
+    return ;
+}
+
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetVGAHT2 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT XGI_GetVGAHT2( PVB_DEVICE_INFO pVBInfo )
+{
+    ULONG tempax ,
+          tempbx ;
+
+    tempbx = ( ( pVBInfo->VGAVT - pVBInfo->VGAVDE ) * pVBInfo->RVBHCMAX ) & 0xFFFF ;
+    tempax = ( pVBInfo->VT - pVBInfo->VDE ) * pVBInfo->RVBHCFACT ;
+    tempax = ( tempax * pVBInfo->HT ) /tempbx ;
+
+    return( ( USHORT )tempax ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetVCLK2Ptr */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT XGI_GetVCLK2Ptr( USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex , PXGI_HW_DEVICE_INFO HwDeviceExtension ,PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempbx ;
+
+    USHORT LCDXlat1VCLK[ 4 ] = { VCLK65 + 2 , VCLK65 + 2 , VCLK65 + 2 , VCLK65 + 2 } ;
+    USHORT LCDXlat2VCLK[ 4 ] = { VCLK108_2 + 5 , VCLK108_2 + 5 , VCLK108_2 + 5 , VCLK108_2 + 5 } ;
+    USHORT LVDSXlat1VCLK[ 4 ] = { VCLK40 , VCLK40 , VCLK40 , VCLK40 } ;
+    USHORT LVDSXlat2VCLK[ 4 ] = { VCLK65 + 2 , VCLK65 + 2 , VCLK65 + 2 , VCLK65 + 2 } ;
+    USHORT LVDSXlat3VCLK[ 4 ] = { VCLK65 + 2 , VCLK65 + 2 , VCLK65 + 2 , VCLK65 + 2 } ;
+
+    USHORT CRT2Index , VCLKIndex ;
+    USHORT modeflag , resinfo ;
+    UCHAR *CHTVVCLKPtr = NULL ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;      /* si+St_ResInfo */
+        resinfo = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ResInfo ;
+        CRT2Index = pVBInfo->SModeIDTable[ ModeIdIndex ].St_CRT2CRTC ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;     /* si+Ext_ResInfo */
+        resinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;
+        CRT2Index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT2CRTC ;
+    }
+
+    if ( pVBInfo->IF_DEF_LVDS == 0 )
+    {
+        CRT2Index = CRT2Index >> 6 ;        /*  for LCD */
+        if ( ( ( pVBInfo->VBInfo & SetCRT2ToLCD ) | SetCRT2ToLCDA ) )	 /*301b*/
+        {
+            if ( pVBInfo->LCDResInfo != Panel1024x768 )
+            {
+                VCLKIndex = LCDXlat2VCLK[ CRT2Index ] ;
+            }
+            else
+            {
+                 VCLKIndex = LCDXlat1VCLK[ CRT2Index ] ;
+            }
+        }
+        else	/* for TV */
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToTV )
+            {
+                if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+                {
+                    if ( pVBInfo->SetFlag & RPLLDIV2XO )
+                    {
+                        VCLKIndex = HiTVVCLKDIV2 ;
+
+
+                            VCLKIndex += 25 ;
+
+                    }
+                    else
+                    {
+                        VCLKIndex = HiTVVCLK ;
+
+
+                            VCLKIndex += 25 ;
+
+                    }
+
+                    if ( pVBInfo->SetFlag & TVSimuMode )
+                    {
+                        if( modeflag & Charx8Dot )
+                        {
+                            VCLKIndex = HiTVSimuVCLK ;
+
+
+                                VCLKIndex += 25 ;
+
+                        }
+                        else
+                        {
+                            VCLKIndex = HiTVTextVCLK ;
+
+
+                                VCLKIndex += 25 ;
+
+                        }
+                    }
+
+                    if ( pVBInfo->VBType & VB_XGI301LV )	/* 301lv */
+                    {
+                        if ( !( pVBInfo->VBExtInfo == VB_YPbPr1080i ) )
+                        {
+                            VCLKIndex = YPbPr750pVCLK ;
+                            if ( !( pVBInfo->VBExtInfo == VB_YPbPr750p ) )
+                            {
+                                VCLKIndex = YPbPr525pVCLK ;
+                                if ( !( pVBInfo->VBExtInfo == VB_YPbPr525p ) )
+                                {
+                                    VCLKIndex = YPbPr525iVCLK_2 ;
+                                    if ( !( pVBInfo->SetFlag & RPLLDIV2XO ) )
+                                        VCLKIndex = YPbPr525iVCLK ;
+                                }
+                            }
+                        }
+                    }
+                }
+                else
+                {
+                    if ( pVBInfo->VBInfo & SetCRT2ToTV )
+                    {
+                        if ( pVBInfo->SetFlag & RPLLDIV2XO )
+			{
+                            VCLKIndex = TVVCLKDIV2 ;
+
+
+                            VCLKIndex += 25 ;
+
+                        }
+                        else
+                        {
+                            VCLKIndex = TVVCLK ;
+
+
+                            VCLKIndex += 25 ;
+
+                        }
+                    }
+                }
+            }
+            else
+            {	/* for CRT2 */
+                VCLKIndex = ( UCHAR )XGINew_GetReg2( ( pVBInfo->P3ca + 0x02 ) ) ;	/* Port 3cch */
+		VCLKIndex = ( ( VCLKIndex >> 2 ) & 0x03 ) ;
+                if ( ModeNo > 0x13 )
+                {
+                    VCLKIndex = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRTVCLK ;	/* di+Ext_CRTVCLK */
+                    VCLKIndex &= IndexMask ;
+                }
+            }
+        }
+    }
+    else
+    {		/* LVDS */
+        if ( ModeNo <= 0x13 )
+            VCLKIndex = CRT2Index ;
+	else
+	    VCLKIndex = CRT2Index ;
+
+        if ( pVBInfo->IF_DEF_CH7005 == 1 )
+        {
+            if ( !( pVBInfo->VBInfo & SetCRT2ToLCD ) )
+            {
+                VCLKIndex &= 0x1f ;
+		tempbx = 0 ;
+
+                if ( pVBInfo->VBInfo & SetPALTV )
+                    tempbx += 2 ;
+
+                if ( pVBInfo->VBInfo & SetCHTVOverScan )
+                    tempbx += 1 ;
+
+                switch( tempbx )
+                {
+                    case 0:
+                        CHTVVCLKPtr = pVBInfo->CHTVVCLKUNTSC ;
+                        break ;
+                    case 1:
+                        CHTVVCLKPtr = pVBInfo->CHTVVCLKONTSC ;
+                        break;
+                    case 2:
+                        CHTVVCLKPtr = pVBInfo->CHTVVCLKUPAL ;
+                        break ;
+                    case 3:
+                        CHTVVCLKPtr = pVBInfo->CHTVVCLKOPAL ;
+                        break ;
+                    default:
+                        break ;
+                }
+
+                VCLKIndex = CHTVVCLKPtr[ VCLKIndex ] ;
+            }
+        }
+        else
+        {
+            VCLKIndex = VCLKIndex >> 6 ;
+            if ( ( pVBInfo->LCDResInfo == Panel800x600 ) || ( pVBInfo->LCDResInfo == Panel320x480 ) )
+                VCLKIndex = LVDSXlat1VCLK[ VCLKIndex ] ;
+            else if ( ( pVBInfo->LCDResInfo == Panel1024x768 ) || ( pVBInfo->LCDResInfo == Panel1024x768x75 ) )
+                VCLKIndex = LVDSXlat2VCLK[ VCLKIndex ] ;
+            else
+                VCLKIndex = LVDSXlat3VCLK[ VCLKIndex ] ;
+        }
+    }
+    /* VCLKIndex = VCLKIndex&IndexMask ; */
+
+
+
+    return( VCLKIndex ) ;
+}
+
diff --git a/drivers/video/xgi/vb_setmode.h b/drivers/video/xgi/vb_setmode.h
new file mode 100644
index 0000000..09753d7
--- /dev/null
+++ b/drivers/video/xgi/vb_setmode.h
@@ -0,0 +1,40 @@
+#ifndef  _VBSETMODE_
+#define  _VBSETMODE_
+
+extern   void     InitTo330Pointer(UCHAR,PVB_DEVICE_INFO);
+extern   void     XGI_UnLockCRT2(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO );
+extern   void     XGI_LockCRT2(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO );
+extern   void     XGI_LongWait( PVB_DEVICE_INFO );
+extern   void     XGI_SetCRT2ModeRegs(USHORT ModeNo,PXGI_HW_DEVICE_INFO,  PVB_DEVICE_INFO  );
+extern   void     XGI_DisableBridge(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO );
+extern   void  	  XGI_EnableBridge(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO );
+extern   void     XGI_DisplayOff( PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO );
+extern   void     XGI_DisplayOn( PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO );
+extern   void     XGI_GetVBType(PVB_DEVICE_INFO);
+extern   void     XGI_SenseCRT1(PVB_DEVICE_INFO );
+extern   void     XGI_GetVGAType(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO );
+extern   void     XGI_GetVBInfo(USHORT ModeNo,USHORT ModeIdIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO );
+extern   void     XGI_GetTVInfo(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO );
+extern   void     XGI_SetCRT1Offset(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO );
+extern   void     XGI_SetLCDAGroup(USHORT ModeNo,USHORT ModeIdIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO );
+extern   void     XGI_WaitDisply( PVB_DEVICE_INFO );
+extern   USHORT   XGI_GetResInfo(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+
+extern   BOOLEAN  XGISetModeNew( PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT ModeNo ) ;
+
+extern   BOOLEAN  XGI_SearchModeID( USHORT ModeNo,USHORT  *ModeIdIndex, PVB_DEVICE_INFO );
+extern   BOOLEAN  XGI_GetLCDInfo(USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO );
+extern   BOOLEAN  XGI_BridgeIsOn( PVB_DEVICE_INFO );
+extern   BOOLEAN  XGI_SetCRT2Group301(USHORT ModeNo, PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO);
+extern   USHORT   XGI_GetRatePtrCRT2( PXGI_HW_DEVICE_INFO pXGIHWDE, USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO );
+
+extern   void     XGI_SetXG21FPBits(PVB_DEVICE_INFO pVBInfo);
+extern   void     XGI_SetXG27FPBits(PVB_DEVICE_INFO pVBInfo);
+extern   void     XGI_XG21BLSignalVDD(USHORT tempbh,USHORT tempbl, PVB_DEVICE_INFO pVBInfo);
+extern   void     XGI_XG27BLSignalVDD(USHORT tempbh,USHORT tempbl, PVB_DEVICE_INFO pVBInfo);
+extern   void     XGI_XG21SetPanelDelay(USHORT tempbl, PVB_DEVICE_INFO pVBInfo);
+extern   BOOLEAN  XGI_XG21CheckLVDSMode(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo );
+extern   void     XGI_SetXG21LVDSPara(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo );
+extern   USHORT XGI_GetLVDSOEMTableIndex(PVB_DEVICE_INFO pVBInfo);
+
+#endif
diff --git a/drivers/video/xgi/vb_struct.h b/drivers/video/xgi/vb_struct.h
new file mode 100644
index 0000000..d29efd2
--- /dev/null
+++ b/drivers/video/xgi/vb_struct.h
@@ -0,0 +1,518 @@
+#ifndef _VB_STRUCT_
+#define _VB_STRUCT_
+
+#ifdef _INITNEW_
+#define EXTERN
+#else
+#define EXTERN extern
+#endif
+
+
+
+
+typedef struct _XGI_PanelDelayTblStruct
+{
+ UCHAR timer[2];
+} XGI_PanelDelayTblStruct;
+
+typedef struct _XGI_LCDDataStruct
+{
+ USHORT RVBHCMAX;
+ USHORT RVBHCFACT;
+ USHORT VGAHT;
+ USHORT VGAVT;
+ USHORT LCDHT;
+ USHORT LCDVT;
+} XGI_LCDDataStruct;
+
+
+typedef struct _XGI_LVDSCRT1HDataStruct
+{
+ UCHAR Reg[8];
+} XGI_LVDSCRT1HDataStruct;
+typedef struct _XGI_LVDSCRT1VDataStruct
+{
+ UCHAR Reg[7];
+} XGI_LVDSCRT1VDataStruct;
+
+
+typedef struct _XGI_TVDataStruct
+{
+ USHORT RVBHCMAX;
+ USHORT RVBHCFACT;
+ USHORT VGAHT;
+ USHORT VGAVT;
+ USHORT TVHDE;
+ USHORT TVVDE;
+ USHORT RVBHRS;
+ UCHAR FlickerMode;
+ USHORT HALFRVBHRS;
+ UCHAR RY1COE;
+ UCHAR RY2COE;
+ UCHAR RY3COE;
+ UCHAR RY4COE;
+} XGI_TVDataStruct;
+
+typedef struct _XGI_LVDSDataStruct
+{
+ USHORT VGAHT;
+ USHORT VGAVT;
+ USHORT LCDHT;
+ USHORT LCDVT;
+} XGI_LVDSDataStruct;
+
+typedef struct _XGI_LVDSDesStruct
+{
+ USHORT LCDHDES;
+ USHORT LCDVDES;
+} XGI_LVDSDesStruct;
+
+typedef struct _XGI_LVDSCRT1DataStruct
+{
+ UCHAR CR[15];
+} XGI_LVDSCRT1DataStruct;
+
+/*add for LCDA*/
+
+
+typedef struct _XGI_StStruct
+{
+ UCHAR St_ModeID;
+ USHORT St_ModeFlag;
+ UCHAR St_StTableIndex;
+ UCHAR St_CRT2CRTC;
+ UCHAR St_CRT2CRTC2;
+ UCHAR St_ResInfo;
+ UCHAR VB_StTVFlickerIndex;
+ UCHAR VB_StTVEdgeIndex;
+ UCHAR VB_StTVYFilterIndex;
+} XGI_StStruct;
+
+typedef struct _XGI_StandTableStruct
+{
+ UCHAR CRT_COLS;
+ UCHAR ROWS;
+ UCHAR CHAR_HEIGHT;
+ USHORT CRT_LEN;
+ UCHAR SR[4];
+ UCHAR MISC;
+ UCHAR CRTC[0x19];
+ UCHAR ATTR[0x14];
+ UCHAR GRC[9];
+} XGI_StandTableStruct;
+
+typedef struct _XGI_ExtStruct
+{
+ UCHAR Ext_ModeID;
+ USHORT Ext_ModeFlag;
+ USHORT Ext_ModeInfo;
+ USHORT Ext_Point;
+ USHORT Ext_VESAID;
+ UCHAR Ext_VESAMEMSize;
+ UCHAR Ext_RESINFO;
+ UCHAR VB_ExtTVFlickerIndex;
+ UCHAR VB_ExtTVEdgeIndex;
+ UCHAR VB_ExtTVYFilterIndex;
+ UCHAR REFindex;
+} XGI_ExtStruct;
+
+typedef struct _XGI_Ext2Struct
+{
+ USHORT Ext_InfoFlag;
+ UCHAR Ext_CRT1CRTC;
+ UCHAR Ext_CRTVCLK;
+ UCHAR Ext_CRT2CRTC;
+ UCHAR Ext_CRT2CRTC2;
+ UCHAR  ModeID;
+ USHORT XRes;
+ USHORT YRes;
+ /* USHORT ROM_OFFSET; */
+} XGI_Ext2Struct;
+
+
+typedef struct _XGI_MCLKDataStruct
+{
+ UCHAR SR28,SR29,SR2A;
+ USHORT CLOCK;
+} XGI_MCLKDataStruct;
+
+typedef struct _XGI_ECLKDataStruct
+{
+ UCHAR SR2E,SR2F,SR30;
+ USHORT CLOCK;
+} XGI_ECLKDataStruct;
+
+typedef struct _XGI_VCLKDataStruct
+{
+ UCHAR SR2B,SR2C;
+ USHORT CLOCK;
+} XGI_VCLKDataStruct;
+
+typedef struct _XGI_VBVCLKDataStruct
+{
+ UCHAR Part4_A,Part4_B;
+ USHORT CLOCK;
+} XGI_VBVCLKDataStruct;
+
+typedef struct _XGI_StResInfoStruct
+{
+ USHORT HTotal;
+ USHORT VTotal;
+} XGI_StResInfoStruct;
+
+typedef struct _XGI_ModeResInfoStruct
+{
+ USHORT HTotal;
+ USHORT VTotal;
+ UCHAR  XChar;
+ UCHAR  YChar;
+} XGI_ModeResInfoStruct;
+
+typedef struct _XGI_LCDNBDesStruct
+{
+  UCHAR NB[12];
+} XGI_LCDNBDesStruct;
+ /*add for new UNIVGABIOS*/
+typedef struct _XGI_LCDDesStruct
+{
+ USHORT LCDHDES;
+ USHORT LCDHRS;
+ USHORT LCDVDES;
+ USHORT LCDVRS;
+} XGI_LCDDesStruct;
+
+typedef struct _XGI_LCDDataTablStruct
+{
+ UCHAR  PANELID;
+ USHORT MASK;
+ USHORT CAP;
+ USHORT DATAPTR;
+} XGI_LCDDataTablStruct;
+
+typedef struct _XGI_TVTablDataStruct
+{
+ USHORT MASK;
+ USHORT CAP;
+ USHORT DATAPTR;
+} XGI_TVDataTablStruct;
+
+typedef struct _XGI330_LCDDesDataStruct
+{
+ USHORT LCDHDES;
+ USHORT LCDHRS;
+ USHORT LCDVDES;
+ USHORT LCDVRS;
+} XGI330_LCDDataDesStruct;
+
+
+typedef struct _XGI330_LVDSDataStruct
+{
+ USHORT VGAHT;
+ USHORT VGAVT;
+ USHORT LCDHT;
+ USHORT LCDVT;
+} XGI330_LVDSDataStruct;
+
+typedef struct _XGI330_LCDDesDataStruct2
+{
+ USHORT LCDHDES;
+ USHORT LCDHRS;
+ USHORT LCDVDES;
+ USHORT LCDVRS;
+ USHORT LCDHSync;
+ USHORT LCDVSync;
+} XGI330_LCDDataDesStruct2;
+
+typedef struct _XGI330_LCDDataStruct
+{
+ USHORT RVBHCMAX;
+ USHORT RVBHCFACT;
+ USHORT VGAHT;
+ USHORT VGAVT;
+ USHORT LCDHT;
+ USHORT LCDVT;
+} XGI330_LCDDataStruct;
+
+
+typedef struct _XGI330_TVDataStruct
+{
+ USHORT RVBHCMAX;
+ USHORT RVBHCFACT;
+ USHORT VGAHT;
+ USHORT VGAVT;
+ USHORT TVHDE;
+ USHORT TVVDE;
+ USHORT RVBHRS;
+ UCHAR FlickerMode;
+ USHORT HALFRVBHRS;
+} XGI330_TVDataStruct;
+
+typedef struct _XGI330_LCDDataTablStruct
+{
+ UCHAR  PANELID;
+ USHORT MASK;
+ USHORT CAP;
+ USHORT DATAPTR;
+} XGI330_LCDDataTablStruct;
+
+typedef struct _XGI330_TVDataTablStruct
+{
+ USHORT MASK;
+ USHORT CAP;
+ USHORT DATAPTR;
+} XGI330_TVDataTablStruct;
+
+
+typedef struct _XGI330_CHTVDataStruct
+{
+ USHORT VGAHT;
+ USHORT VGAVT;
+ USHORT LCDHT;
+ USHORT LCDVT;
+} XGI330_CHTVDataStruct;
+
+typedef struct _XGI_TimingHStruct
+{
+  UCHAR data[8];
+} XGI_TimingHStruct;
+
+typedef struct _XGI_TimingVStruct
+{
+  UCHAR data[7];
+} XGI_TimingVStruct;
+
+typedef struct _XGI_CH7007TV_TimingHStruct
+{
+  UCHAR data[10];
+} XGI_CH7007TV_TimingHStruct;
+
+typedef struct _XGI_CH7007TV_TimingVStruct
+{
+  UCHAR data[10];
+} XGI_CH7007TV_TimingVStruct;
+
+typedef struct _XGI_XG21CRT1Struct
+{
+ UCHAR ModeID,CR02,CR03,CR15,CR16;
+} XGI_XG21CRT1Struct;
+
+typedef struct _XGI330_CHTVRegDataStruct
+{
+ UCHAR Reg[16];
+} XGI330_CHTVRegDataStruct;
+
+typedef struct _XGI330_LCDCapStruct
+{
+ 		UCHAR      LCD_ID;
+                USHORT     LCD_Capability;
+                UCHAR      LCD_SetFlag;
+                UCHAR      LCD_DelayCompensation;
+                UCHAR      LCD_HSyncWidth;
+                UCHAR      LCD_VSyncWidth;
+                UCHAR      LCD_VCLK;
+                UCHAR      LCDA_VCLKData1;
+                UCHAR      LCDA_VCLKData2;
+                UCHAR      LCUCHAR_VCLKData1;
+                UCHAR      LCUCHAR_VCLKData2;
+                UCHAR      PSC_S1;
+                UCHAR      PSC_S2;
+                UCHAR      PSC_S3;
+                UCHAR      PSC_S4;
+                UCHAR      PSC_S5;
+                UCHAR      PWD_2B;
+                UCHAR      PWD_2C;
+                UCHAR      PWD_2D;
+                UCHAR      PWD_2E;
+                UCHAR      PWD_2F;
+                UCHAR      Spectrum_31;
+                UCHAR      Spectrum_32;
+                UCHAR      Spectrum_33;
+                UCHAR      Spectrum_34;
+} XGI330_LCDCapStruct;
+
+typedef struct _XGI21_LVDSCapStruct
+{
+                USHORT     LVDS_Capability;
+                USHORT     LVDSHT;
+                USHORT     LVDSVT;
+                USHORT     LVDSHDE;
+                USHORT     LVDSVDE;
+                USHORT     LVDSHFP;
+                USHORT     LVDSVFP;
+                USHORT     LVDSHSYNC;
+                USHORT     LVDSVSYNC;
+                UCHAR      VCLKData1;
+                UCHAR      VCLKData2;
+                UCHAR      PSC_S1;
+                UCHAR      PSC_S2;
+                UCHAR      PSC_S3;
+                UCHAR      PSC_S4;
+                UCHAR      PSC_S5;
+} XGI21_LVDSCapStruct;
+
+typedef struct _XGI_CRT1TableStruct
+{
+  UCHAR CR[15];
+} XGI_CRT1TableStruct;
+
+
+typedef struct _XGI330_VCLKDataStruct
+{
+    UCHAR SR2B,SR2C;
+    USHORT CLOCK;
+} XGI330_VCLKDataStruct;
+
+typedef struct _XGI301C_Tap4TimingStruct
+{
+    USHORT DE;
+    UCHAR  Reg[64];   /* C0-FF */
+} XGI301C_Tap4TimingStruct;
+
+typedef struct _XGI_New_StandTableStruct
+{
+	UCHAR  CRT_COLS;
+	UCHAR  ROWS;
+	UCHAR  CHAR_HEIGHT;
+	USHORT CRT_LEN;
+	UCHAR  SR[4];
+	UCHAR  MISC;
+	UCHAR  CRTC[0x19];
+	UCHAR  ATTR[0x14];
+	UCHAR  GRC[9];
+} XGI_New_StandTableStruct;
+
+typedef UCHAR DRAM8Type[8];
+typedef UCHAR DRAM4Type[4];
+typedef UCHAR DRAM32Type[32];
+typedef UCHAR DRAM2Type[2];
+
+typedef struct _VB_DEVICE_INFO  VB_DEVICE_INFO,*PVB_DEVICE_INFO;
+
+struct _VB_DEVICE_INFO
+{
+    BOOLEAN  ISXPDOS;
+    ULONG   P3c4,P3d4,P3c0,P3ce,P3c2,P3cc;
+    ULONG   P3ca,P3c6,P3c7,P3c8,P3c9,P3da;
+    ULONG   Part0Port,Part1Port,Part2Port;
+    ULONG   Part3Port,Part4Port,Part5Port;
+    USHORT   RVBHCFACT,RVBHCMAX,RVBHRS;
+    USHORT   VGAVT,VGAHT,VGAVDE,VGAHDE;
+    USHORT   VT,HT,VDE,HDE;
+    USHORT   LCDHRS,LCDVRS,LCDHDES,LCDVDES;
+
+    USHORT   ModeType;
+    USHORT   IF_DEF_LVDS,IF_DEF_TRUMPION,IF_DEF_DSTN;/* ,IF_DEF_FSTN; add for dstn */
+    USHORT   IF_DEF_CRT2Monitor,IF_DEF_VideoCapture;
+    USHORT   IF_DEF_LCDA,IF_DEF_CH7017,IF_DEF_YPbPr,IF_DEF_ScaleLCD,IF_DEF_OEMUtil,IF_DEF_PWD;
+    USHORT   IF_DEF_ExpLink;
+    USHORT   IF_DEF_CH7005,IF_DEF_HiVision;
+    USHORT   IF_DEF_CH7007; /* Billy 2007/05/03 */
+    USHORT   LCDResInfo,LCDTypeInfo, VBType;/*301b*/
+    USHORT   VBInfo,TVInfo,LCDInfo, Set_VGAType;
+    USHORT   VBExtInfo;/*301lv*/
+    USHORT   SetFlag;
+    USHORT   NewFlickerMode;
+    USHORT   SelectCRT2Rate;
+
+    PUCHAR ROMAddr;
+    PUCHAR FBAddr;
+    ULONG BaseAddr;
+    ULONG RelIO;
+
+    DRAM4Type  *CR6B;
+    DRAM4Type  *CR6E;
+    DRAM32Type *CR6F;
+    DRAM2Type  *CR89;
+
+    DRAM8Type  *SR15; /* pointer : point to array */
+    DRAM8Type  *CR40;
+    UCHAR  *pSoftSetting;
+    UCHAR  *pOutputSelect;
+
+    USHORT *pRGBSenseData;
+    USHORT *pRGBSenseData2; /*301b*/
+    USHORT *pVideoSenseData;
+    USHORT *pVideoSenseData2;
+    USHORT *pYCSenseData;
+    USHORT *pYCSenseData2;
+
+    UCHAR  *pSR07;
+    UCHAR  *CR49;
+    UCHAR  *pSR1F;
+    UCHAR  *AGPReg;
+    UCHAR  *SR16;
+    UCHAR  *pSR21;
+    UCHAR  *pSR22;
+    UCHAR  *pSR23;
+    UCHAR  *pSR24;
+    UCHAR  *SR25;
+    UCHAR  *pSR31;
+    UCHAR  *pSR32;
+    UCHAR  *pSR33;
+    UCHAR  *pSR36;      /* alan 12/07/2006 */
+    UCHAR  *pCRCF;
+    UCHAR  *pCRD0;      /* alan 12/07/2006 */
+    UCHAR  *pCRDE;      /* alan 12/07/2006 */
+    UCHAR  *pCR8F;      /* alan 12/07/2006 */
+    UCHAR  *pSR40;      /* alan 12/07/2006 */
+    UCHAR  *pSR41;      /* alan 12/07/2006 */
+    UCHAR  *pDVOSetting;
+    UCHAR  *pCR2E;
+    UCHAR  *pCR2F;
+    UCHAR  *pCR46;
+    UCHAR  *pCR47;
+    UCHAR  *pCRT2Data_1_2;
+    UCHAR  *pCRT2Data_4_D;
+    UCHAR  *pCRT2Data_4_E;
+    UCHAR  *pCRT2Data_4_10;
+    XGI_MCLKDataStruct  *MCLKData;
+    XGI_ECLKDataStruct  *ECLKData;
+
+    UCHAR   *XGI_TVDelayList;
+    UCHAR   *XGI_TVDelayList2;
+    UCHAR   *CHTVVCLKUNTSC;
+    UCHAR   *CHTVVCLKONTSC;
+    UCHAR   *CHTVVCLKUPAL;
+    UCHAR   *CHTVVCLKOPAL;
+    UCHAR   *NTSCTiming;
+    UCHAR   *PALTiming;
+    UCHAR   *HiTVExtTiming;
+    UCHAR   *HiTVSt1Timing;
+    UCHAR   *HiTVSt2Timing;
+    UCHAR   *HiTVTextTiming;
+    UCHAR   *YPbPr750pTiming;
+    UCHAR   *YPbPr525pTiming;
+    UCHAR   *YPbPr525iTiming;
+    UCHAR   *HiTVGroup3Data;
+    UCHAR   *HiTVGroup3Simu;
+    UCHAR   *HiTVGroup3Text;
+    UCHAR   *Ren525pGroup3;
+    UCHAR   *Ren750pGroup3;
+    UCHAR   *ScreenOffset;
+    UCHAR   *pXGINew_DRAMTypeDefinition;
+    UCHAR   *pXGINew_I2CDefinition ;
+    UCHAR   *pXGINew_CR97 ;
+
+    XGI330_LCDCapStruct  *LCDCapList;
+    XGI21_LVDSCapStruct  *XG21_LVDSCapList;
+
+    XGI_TimingHStruct  *TimingH;
+    XGI_TimingVStruct  *TimingV;
+
+    XGI_StStruct          *SModeIDTable;
+    XGI_StandTableStruct  *StandTable;
+    XGI_ExtStruct         *EModeIDTable;
+    XGI_Ext2Struct        *RefIndex;
+    /* XGINew_CRT1TableStruct *CRT1Table; */
+    XGI_CRT1TableStruct    *XGINEWUB_CRT1Table;
+    XGI_VCLKDataStruct    *VCLKData;
+    XGI_VBVCLKDataStruct  *VBVCLKData;
+    XGI_StResInfoStruct   *StResInfo;
+    XGI_ModeResInfoStruct *ModeResInfo;
+    XGI_XG21CRT1Struct	  *UpdateCRT1;
+};  /* _VB_DEVICE_INFO */
+
+
+
+#define _VB_STRUCT_
+#endif /* _VB_STRUCT_ */
diff --git a/drivers/video/xgi/vb_table.h b/drivers/video/xgi/vb_table.h
new file mode 100644
index 0000000..973888c
--- /dev/null
+++ b/drivers/video/xgi/vb_table.h
@@ -0,0 +1,4406 @@
+#define  Tap4
+
+
+XGI_MCLKDataStruct XGI330New_MCLKData[]=
+{
+ { 0x5c,0x23,0x01,166},
+ { 0x5c,0x23,0x01,166},
+ { 0x7C,0x08,0x80,200},
+ { 0x79,0x06,0x80,250},
+ { 0x29,0x01,0x81,300},
+ { 0x29,0x01,0x81,300},
+ { 0x29,0x01,0x81,300},
+ { 0x29,0x01,0x81,300}
+};
+//yilin modify for xgi20
+XGI_MCLKDataStruct XGI340New_MCLKData[]=
+{
+ { 0x16,0x01,0x01,166},
+ { 0x19,0x02,0x01,124},
+ { 0x7C,0x08,0x01,200},
+ { 0x79,0x06,0x01,250},
+ { 0x29,0x01,0x81,301},
+ { 0x5c,0x23,0x01,166},
+ { 0x5c,0x23,0x01,166},
+ { 0x5c,0x23,0x01,166}
+};
+
+XGI_MCLKDataStruct XGI27New_MCLKData[]=
+{
+ { 0x5c,0x23,0x01,166},
+ { 0x19,0x02,0x01,124},
+ { 0x7C,0x08,0x80,200},
+ { 0x79,0x06,0x80,250},
+ { 0x29,0x01,0x81,300},
+ { 0x5c,0x23,0x01,166},
+ { 0x5c,0x23,0x01,166},
+ { 0x5c,0x23,0x01,166}
+};
+
+XGI_ECLKDataStruct XGI330_ECLKData[]=
+{
+ { 0x7c,0x08,0x01,200},
+ { 0x7c,0x08,0x01,200},
+ { 0x7C,0x08,0x80,200},
+ { 0x79,0x06,0x80,250},
+ { 0x29,0x01,0x81,300},
+ { 0x29,0x01,0x81,300},
+ { 0x29,0x01,0x81,300},
+ { 0x29,0x01,0x81,300}
+};
+//yilin modify for xgi20
+XGI_ECLKDataStruct XGI340_ECLKData[]=
+{
+ { 0x5c,0x23,0x01,166},
+ { 0x55,0x84,0x01,123},
+ { 0x7C,0x08,0x01,200},
+ { 0x79,0x06,0x01,250},
+ { 0x29,0x01,0x81,301},
+ { 0x5c,0x23,0x01,166},
+ { 0x5c,0x23,0x01,166},
+ { 0x5c,0x23,0x01,166}
+};
+
+
+
+UCHAR XGI340_SR13[4][8]={
+{0x35,0x45,0xb1,0x00,0x00,0x00,0x00,0x00},/* SR13 */
+{0x41,0x51,0x5c,0x00,0x00,0x00,0x00,0x00},/* SR14 */
+{0x31,0x42,0x42,0x00,0x00,0x00,0x00,0x00},/* SR18 */
+{0x03,0x03,0x03,0x00,0x00,0x00,0x00,0x00}/* SR1B */
+};
+
+UCHAR XGI340_cr41[24][8]=
+{{0x20,0x50,0x60,0x00,0x00,0x00,0x00,0x00},/* 0 CR41 */
+{0xc4,0x40,0x84,0x00,0x00,0x00,0x00,0x00},/* 1 CR8A */
+{0xc4,0x40,0x84,0x00,0x00,0x00,0x00,0x00},/* 2 CR8B */
+{0xb5,0xa4,0xa4,0x00,0x00,0x00,0x00,0x00},
+{0xf0,0xf0,0xf0,0x00,0x00,0x00,0x00,0x00},
+{0x90,0x90,0x24,0x00,0x00,0x00,0x00,0x00},/* 5 CR68 */
+{0x77,0x77,0x44,0x00,0x00,0x00,0x00,0x00},/* 6 CR69 */
+{0x77,0x77,0x44,0x00,0x00,0x00,0x00,0x00},/* 7 CR6A */
+{0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00},/* 8 CR6D */
+{0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x00},/* 9 CR80 */
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/* 10 CR81 */
+{0x88,0xa8,0x48,0x00,0x00,0x00,0x00,0x00},/* 11 CR82 */
+{0x44,0x44,0x77,0x00,0x00,0x00,0x00,0x00},/* 12 CR85 */
+{0x48,0x48,0x88,0x00,0x00,0x00,0x00,0x00},/* 13 CR86 */
+{0x54,0x54,0x44,0x00,0x00,0x00,0x00,0x00},/* 14 CR90 */
+{0x54,0x54,0x44,0x00,0x00,0x00,0x00,0x00},/* 15 CR91 */
+{0x0a,0x0a,0x07,0x00,0x00,0x00,0x00,0x00},/* 16 CR92 */
+{0x44,0x44,0x44,0x00,0x00,0x00,0x00,0x00},/* 17 CR93 */
+{0x10,0x10,0x0A,0x00,0x00,0x00,0x00,0x00},/* 18 CR94 */
+{0x11,0x11,0x0a,0x00,0x00,0x00,0x00,0x00},/* 19 CR95 */
+{0x05,0x05,0x05,0x00,0x00,0x00,0x00,0x00},/* 20 CR96 */
+{0xf0,0xf0,0xf0,0x00,0x00,0x00,0x00,0x00},/* 21 CRC3 */
+{0x05,0x00,0x02,0x00,0x00,0x00,0x00,0x00},/* 22 CRC4 */
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}/* 23 CRC5 */
+};
+
+
+UCHAR XGI27_cr41[24][8]=
+{
+{0x20,0x40,0x60,0x00,0x00,0x00,0x00,0x00},/* 0 CR41 */
+{0xC4,0x40,0x84,0x00,0x00,0x00,0x00,0x00},/* 1 CR8A */
+{0xC4,0x40,0x84,0x00,0x00,0x00,0x00,0x00},/* 2 CR8B */
+{0xB5,0x13,0xa4,0x00,0x00,0x00,0x00,0x00},/* 3 CR40[7],CR99[2:0],CR45[3:0]*/
+{0xf0,0xf5,0xf0,0x00,0x00,0x00,0x00,0x00},/* 4 CR59 */
+{0x90,0x90,0x24,0x00,0x00,0x00,0x00,0x00},/* 5 CR68 */
+{0x77,0x67,0x44,0x00,0x00,0x00,0x00,0x00},/* 6 CR69 */
+{0x77,0x77,0x44,0x00,0x00,0x00,0x00,0x00},/* 7 CR6A */
+{0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00},/* 8 CR6D */
+{0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x00},/* 9 CR80 */
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/* 10 CR81 */
+{0x88,0xcc,0x48,0x00,0x00,0x00,0x00,0x00},/* 11 CR82 */
+{0x44,0x88,0x77,0x00,0x00,0x00,0x00,0x00},/* 12 CR85 */
+{0x48,0x88,0x88,0x00,0x00,0x00,0x00,0x00},/* 13 CR86 */
+{0x54,0x32,0x44,0x00,0x00,0x00,0x00,0x00},/* 14 CR90 */
+{0x54,0x33,0x44,0x00,0x00,0x00,0x00,0x00},/* 15 CR91 */
+{0x0a,0x07,0x07,0x00,0x00,0x00,0x00,0x00},/* 16 CR92 */
+{0x44,0x63,0x44,0x00,0x00,0x00,0x00,0x00},/* 17 CR93 */
+{0x10,0x14,0x0A,0x00,0x00,0x00,0x00,0x00},/* 18 CR94 */
+{0x11,0x0B,0x0C,0x00,0x00,0x00,0x00,0x00},/* 19 CR95 */
+{0x05,0x22,0x05,0x00,0x00,0x00,0x00,0x00},/* 20 CR96 */
+{0xf0,0xf0,0x00,0x00,0x00,0x00,0x00,0x00},/* 21 CRC3 */
+{0x05,0x00,0x02,0x00,0x00,0x00,0x00,0x00},/* 22 CRC4 */
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}/* 23 CRC5 */
+};
+
+
+#if 0
+UCHAR XGI27_cr41[24][8]=
+{
+{0x20,0x60,0x60,0x00,0x00,0x00,0x00,0x00},/* 0 CR41 */
+{0x04,0x44,0x84,0x00,0x00,0x00,0x00,0x00},/* 1 CR8A */
+{0x04,0x40,0x84,0x00,0x00,0x00,0x00,0x00},/* 2 CR8B */
+{0xb5,0x03,0xa4,0x00,0x00,0x00,0x00,0x00},/* 3 CR40[7],CR99[2:0],CR45[3:0]*/
+{0xf0,0xf5,0xf0,0x00,0x00,0x00,0x00,0x00},/* 4 CR59 */
+{0xa4,0x1C,0x24,0x00,0x00,0x00,0x00,0x00},/* 5 CR68 */
+{0x77,0x77,0x44,0x00,0x00,0x00,0x00,0x00},/* 6 CR69 */
+{0x77,0x77,0x44,0x00,0x00,0x00,0x00,0x00},/* 7 CR6A */
+{0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00},/* 8 CR6D */
+{0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x00},/* 9 CR80 */
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/* 10 CR81 */
+{0x48,0xa8,0x48,0x00,0x00,0x00,0x00,0x00},/* 11 CR82 */
+{0x77,0x88,0x77,0x00,0x00,0x00,0x00,0x00},/* 12 CR85 */
+{0x88,0x88,0x88,0x00,0x00,0x00,0x00,0x00},/* 13 CR86 */
+{0x44,0x32,0x44,0x00,0x00,0x00,0x00,0x00},/* 14 CR90 */
+{0x44,0x33,0x44,0x00,0x00,0x00,0x00,0x00},/* 15 CR91 */
+{0x07,0x07,0x07,0x00,0x00,0x00,0x00,0x00},/* 16 CR92 */
+{0x44,0x63,0x44,0x00,0x00,0x00,0x00,0x00},/* 17 CR93 */
+{0x0A,0x14,0x0A,0x00,0x00,0x00,0x00,0x00},/* 18 CR94 */
+{0x0C,0x0B,0x0C,0x00,0x00,0x00,0x00,0x00},/* 19 CR95 */
+{0x05,0x22,0x05,0x00,0x00,0x00,0x00,0x00},/* 20 CR96 */
+{0xf0,0xf0,0xf0,0x00,0x00,0x00,0x00,0x00},/* 21 CRC3 */
+{0x03,0x00,0x02,0x00,0x00,0x00,0x00,0x00},/* 22 CRC4 */
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}/* 23 CRC5 */
+};
+#endif
+UCHAR XGI340_CR6B[8][4]={
+{0xaa,0xaa,0xaa,0xaa},
+{0xaa,0xaa,0xaa,0xaa},
+{0xaa,0xaa,0xaa,0xaa},
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00}
+};
+
+UCHAR XGI340_CR6E[8][4]={
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00}
+};
+
+UCHAR XGI340_CR6F[8][32]={
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
+};
+
+UCHAR XGI340_CR89[8][2]={
+{0x00,0x00},
+{0x00,0x00},
+{0x00,0x00},
+{0x00,0x00},
+{0x00,0x00},
+{0x00,0x00},
+{0x00,0x00},
+{0x00,0x00}
+};
+			 /* CR47,CR48,CR49,CR4A,CR4B,CR4C,CR70,CR71,CR74,CR75,CR76,CR77 */
+UCHAR XGI340_AGPReg[12]={0x28,0x23,0x00,0x20,0x00,0x20,0x00,0x05,0xd0,0x10,0x10,0x00};
+
+UCHAR XGI340_SR16[4]={0x03,0x83,0x03,0x83};
+
+UCHAR XGI330_SR15_1[8][8]={
+{0x0,0x0,0x00,0x00,0x20,0x20,0x00,0x00},
+{0x5,0x15,0x15,0x15,0x15,0x15,0x00,0x00},
+{0xba,0xba,0xba,0xba,0xBA,0xBA,0x00,0x00},
+{0x55,0x57,0x57,0xAB,0xAB,0xAB,0x00,0x00},
+{0x60,0x34,0x34,0x34,0x34,0x34,0x00,0x00},
+{0x0,0x80,0x80,0x80,0x83,0x83,0x00,0x00},
+{0x50,0x50,0x50,0x3C,0x3C,0x3C,0x00,0x00},
+{0x0,0xa5,0xfb,0xf6,0xF6,0xF6,0x00,0x00}
+};
+
+UCHAR XGI330_cr40_1[15][8]={
+{0x66,0x40,0x40,0x28,0x24,0x24,0x00,0x00},
+{0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x0F,0x0F,0x00,0x00},
+{0x00,0xf0,0xf0,0xf0,0xF0,0xF0,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x10,0x10,0x10,0x10,0x20,0x20,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x88,0x88,0x88,0xAA,0xAC,0xAC,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x77,0x77,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0xA2,0x00,0x00,0xA2,0xA2,0x00,0x00},
+};
+
+UCHAR XGI330_sr25[]={0x00,0x0};
+UCHAR XGI330_sr31=0xc0;
+UCHAR XGI330_sr32=0x11;
+UCHAR XGI330_SR33=0x00;
+UCHAR XG40_CRCF=0x13;
+UCHAR XG40_DRAMTypeDefinition=0xFF ;
+
+XGI_StStruct XGI330_SModeIDTable[]=
+{
+ {0x01,0x9208,0x01,0x00,0x10,0x00,0x00,0x01,0x00},
+ {0x01,0x1210,0x14,0x01,0x00,0x01,0x00,0x01,0x00},
+ {0x01,0x1010,0x17,0x02,0x11,0x00,0x00,0x01,0x01},
+ {0x03,0x8208,0x03,0x00,0x14,0x00,0x00,0x01,0x02},
+ {0x03,0x0210,0x16,0x01,0x04,0x01,0x00,0x01,0x02},
+ {0x03,0x0010,0x18,0x02,0x15,0x00,0x00,0x01,0x03},
+ {0x05,0x9209,0x05,0x00,0x10,0x00,0x00,0x00,0x04},
+ {0x06,0x8209,0x06,0x00,0x14,0x00,0x00,0x00,0x05},
+ {0x07,0x0000,0x07,0x03,0x05,0x03,0x00,0x01,0x03},
+ {0x07,0x0000,0x19,0x02,0x15,0x02,0x00,0x01,0x03},
+ {0x0d,0x920a,0x0d,0x00,0x10,0x00,0x00,0x00,0x04},
+ {0x0e,0x820a,0x0e,0x00,0x14,0x00,0x00,0x00,0x05},
+ {0x0f,0x0202,0x11,0x01,0x04,0x01,0x00,0x00,0x05},
+ {0x10,0x0212,0x12,0x01,0x04,0x01,0x00,0x00,0x05},
+ {0x11,0x0212,0x1a,0x04,0x24,0x04,0x00,0x00,0x05},
+ {0x12,0x0212,0x1b,0x04,0x24,0x04,0x00,0x00,0x05},
+ {0x13,0x021b,0x1c,0x00,0x14,0x00,0x00,0x00,0x04},
+ {0x12,0x0010,0x18,0x02,0x24,0x02,0x00,0x00,0x05},/* St_CRT2CRTC2 not sure */
+ {0x12,0x0210,0x18,0x01,0x24,0x01,0x00,0x00,0x05},/* St_CRT2CRTC2 not sure */
+ {0xff,0x0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
+};
+
+
+XGI_ExtStruct  XGI330_EModeIDTable[]=
+{
+ {0x6a,0x2212,0x0407,0x3a81,0x0102,0x08,0x07,0x00,0x00,0x07,0x0e},
+ {0x2e,0x0a1b,0x0306,0x3a57,0x0101,0x08,0x06,0x00,0x00,0x05,0x06},
+ {0x2f,0x0a1b,0x0305,0x3a50,0x0100,0x08,0x05,0x00,0x00,0x05,0x05},
+ {0x30,0x2a1b,0x0407,0x3a81,0x0103,0x08,0x07,0x00,0x00,0x07,0x0e},
+ {0x31,0x0a1b,0x030d,0x3b85,0x0000,0x08,0x0d,0x00,0x00,0x06,0x3d},
+ {0x32,0x0a1b,0x0a0e,0x3b8c,0x0000,0x08,0x0e,0x00,0x00,0x06,0x3e},
+ {0x33,0x0a1d,0x0a0d,0x3b85,0x0000,0x08,0x0d,0x00,0x00,0x06,0x3d},
+ {0x34,0x2a1d,0x0a0e,0x3b8c,0x0000,0x08,0x0e,0x00,0x00,0x06,0x3e},
+ {0x35,0x0a1f,0x0a0d,0x3b85,0x0000,0x08,0x0d,0x00,0x00,0x06,0x3d},
+ {0x36,0x2a1f,0x0a0e,0x3b8c,0x0000,0x08,0x0e,0x00,0x00,0x06,0x3e},
+ {0x37,0x0212,0x0508,0x3aab,0x0104,0x08,0x08,0x00,0x00,0x00,0x16},
+ {0x38,0x0a1b,0x0508,0x3aab,0x0105,0x08,0x08,0x00,0x00,0x00,0x16},
+ {0x3a,0x0e3b,0x0609,0x3adc,0x0107,0x08,0x09,0x00,0x00,0x00,0x1e},
+ {0x3c,0x0e3b,0x070a,0x3af2,0x0130,0x08,0x0a,0x00,0x00,0x00,0x22},	/* mode 1600x1200 add CRT2MODE [2003/10/07] */
+ {0x3d,0x0e7d,0x070a,0x3af2,0x0131,0x08,0x0a,0x00,0x00,0x00,0x22},	/* mode 1600x1200 add CRT2MODE */
+ {0x40,0x9a1c,0x0000,0x3a34,0x010d,0x08,0x00,0x00,0x00,0x04,0x00},
+ {0x41,0x9a1d,0x0000,0x3a34,0x010e,0x08,0x00,0x00,0x00,0x04,0x00},	/* ModeIdIndex = 0x10 */
+ {0x43,0x0a1c,0x0306,0x3a57,0x0110,0x08,0x06,0x00,0x00,0x05,0x06},
+ {0x44,0x0a1d,0x0306,0x3a57,0x0111,0x08,0x06,0x00,0x00,0x05,0x06},
+ {0x46,0x2a1c,0x0407,0x3a81,0x0113,0x08,0x07,0x00,0x00,0x07,0x0e},
+ {0x47,0x2a1d,0x0407,0x3a81,0x0114,0x08,0x07,0x00,0x00,0x07,0x0e},
+ {0x49,0x0a3c,0x0508,0x3aab,0x0116,0x08,0x08,0x00,0x00,0x00,0x16},
+ {0x4a,0x0a3d,0x0508,0x3aab,0x0117,0x08,0x08,0x00,0x00,0x00,0x16},
+ {0x4c,0x0e7c,0x0609,0x3adc,0x0119,0x08,0x09,0x00,0x00,0x00,0x1e},
+ {0x4d,0x0e7d,0x0609,0x3adc,0x011a,0x08,0x09,0x00,0x00,0x00,0x1e},
+ {0x50,0x9a1b,0x0001,0x3a3b,0x0132,0x08,0x01,0x00,0x00,0x04,0x02},
+ {0x51,0xba1b,0x0103,0x3a42,0x0133,0x08,0x03,0x00,0x00,0x07,0x03},
+ {0x52,0x9a1b,0x0204,0x3a49,0x0134,0x08,0x04,0x00,0x00,0x00,0x04},
+ {0x56,0x9a1d,0x0001,0x3a3b,0x0135,0x08,0x01,0x00,0x00,0x04,0x02},
+ {0x57,0xba1d,0x0103,0x3a42,0x0136,0x08,0x03,0x00,0x00,0x07,0x03},
+ {0x58,0x9a1d,0x0204,0x3a49,0x0137,0x08,0x04,0x00,0x00,0x00,0x04},
+ {0x59,0x9a1b,0x0000,0x3a34,0x0138,0x08,0x00,0x00,0x00,0x04,0x00},
+ {0x5A,0x021b,0x0014,0x3b83,0x0138,0x08,0x01,0x00,0x00,0x04,0x3f},	/* ModeIdIndex = 0x20 */
+ {0x5B,0x0a1d,0x0014,0x3b83,0x0135,0x08,0x01,0x00,0x00,0x04,0x3f},
+ {0x5d,0x0a1d,0x0305,0x3a50,0x0139,0x08,0x05,0x00,0x00,0x07,0x05},
+ {0x62,0x0a3f,0x0306,0x3a57,0x013a,0x08,0x06,0x00,0x00,0x05,0x06},
+ {0x63,0x2a3f,0x0407,0x3a81,0x013b,0x08,0x07,0x00,0x00,0x07,0x0e},
+ {0x64,0x0a7f,0x0508,0x3aab,0x013c,0x08,0x08,0x00,0x00,0x00,0x16},
+ {0x65,0x0eff,0x0609,0x3adc,0x013d,0x08,0x09,0x00,0x00,0x00,0x1e},
+ {0x66,0x0eff,0x070a,0x3af2,0x013e,0x08,0x0a,0x00,0x00,0x00,0x22},	/* mode 1600x1200 add CRT2MODE */
+ {0x68,0x067b,0x080b,0x3b17,0x013f,0x08,0x0b,0x00,0x00,0x00,0x29},
+ {0x69,0x06fd,0x080b,0x3b17,0x0140,0x08,0x0b,0x00,0x00,0x00,0x29},
+ {0x6b,0x07ff,0x080b,0x3b17,0x0141,0x10,0x0b,0x00,0x00,0x00,0x29},
+ {0x6c,0x067b,0x090c,0x3b37,0x0000,0x08,0x0c,0x00,0x00,0x00,0x2f},
+ {0x6d,0x06fd,0x090c,0x3b37,0x0000,0x10,0x0c,0x00,0x00,0x00,0x2f},
+ {0x6e,0x07ff,0x090c,0x3b37,0x0000,0x10,0x0c,0x00,0x00,0x00,0x2f},
+ {0x70,0x2a1b,0x0410,0x3b52,0x0000,0x08,0x10,0x00,0x00,0x07,0x34},
+ {0x71,0x0a1b,0x0511,0x3b63,0x0000,0x08,0x11,0x00,0x00,0x00,0x37},
+ {0x74,0x0a1d,0x0511,0x3b63,0x0000,0x08,0x11,0x00,0x00,0x00,0x37},	/* ModeIdIndex = 0x30 */
+ {0x75,0x0a3d,0x0612,0x3b74,0x0000,0x08,0x12,0x00,0x00,0x00,0x3a},
+ {0x76,0x2a1f,0x0410,0x3b52,0x0000,0x08,0x10,0x00,0x00,0x07,0x34},
+ {0x77,0x0a1f,0x0511,0x3b63,0x0000,0x08,0x11,0x00,0x00,0x00,0x37},
+ {0x78,0x0a3f,0x0612,0x3b74,0x0000,0x08,0x12,0x00,0x00,0x00,0x3a},
+ {0x79,0x0a3b,0x0612,0x3b74,0x0000,0x08,0x12,0x00,0x00,0x00,0x3a},
+ {0x7a,0x2a1d,0x0410,0x3b52,0x0000,0x08,0x10,0x00,0x00,0x07,0x34},
+ {0x7b,0x0e3b,0x060f,0x3ad0,0x0000,0x08,0x0f,0x00,0x00,0x00,0x1d},
+ {0x7c,0x0e7d,0x060f,0x3ad0,0x0000,0x08,0x0f,0x00,0x00,0x00,0x1d},
+ {0x7d,0x0eff,0x060f,0x3ad0,0x0000,0x08,0x0f,0x00,0x00,0x00,0x1d},
+ {0x20,0x0e3b,0x0D16,0x49e0,0x0000,0x08,0x16,0x00,0x00,0x00,0x43},
+ {0x21,0x0e7d,0x0D16,0x49e0,0x0000,0x08,0x16,0x00,0x00,0x00,0x43},
+ {0x22,0x0eff,0x0D16,0x49e0,0x0000,0x08,0x16,0x00,0x00,0x00,0x43},
+ {0x23,0x0e3b,0x0614,0x49d5,0x0000,0x08,0x14,0x00,0x00,0x00,0x41},
+ {0x24,0x0e7d,0x0614,0x49d5,0x0000,0x08,0x14,0x00,0x00,0x00,0x41},
+ {0x25,0x0eff,0x0614,0x49d5,0x0000,0x08,0x14,0x00,0x00,0x00,0x41},
+ {0x26,0x063b,0x0c15,0x49dc,0x0000,0x08,0x15,0x00,0x00,0x00,0x42},	/* ModeIdIndex = 0x40 */
+ {0x27,0x067d,0x0c15,0x49dc,0x0000,0x08,0x15,0x00,0x00,0x00,0x42},
+ {0x28,0x06ff,0x0c15,0x49dc,0x0000,0x08,0x15,0x00,0x00,0x00,0x42},
+ {0xff,0x0000,0x0000,0x0000,0x0000,0x00,0x00,0x00,0x00,0x00,0x00}
+};
+
+XGI_StandTableStruct XGI330_StandTable[]=
+{
+/* MD_0_200 */
+ {
+  0x28,0x18,0x08,0x0800,
+  {0x09,0x03,0x00,0x02},
+  0x63,
+  {0x2d,0x27,0x28,0x90,0x2b,0xa0,0xbf,0x1f,
+   0x00,0xc7,0x06,0x07,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x14,0x1f,0x96,0xb9,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
+   0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
+   0x08,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,
+   0xff}
+ },
+/* MD_1_200 */
+ {
+  0x28,0x18,0x08,0x0800,
+  {0x09,0x03,0x00,0x02},
+  0x63,
+  {0x2d,0x27,0x28,0x90,0x2b,0xa0,0xbf,0x1f,
+   0x00,0xc7,0x06,0x07,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x14,0x1f,0x96,0xb9,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
+   0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
+   0x08,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,
+   0xff}
+ },
+/* MD_2_200 */
+ {
+  0x50,0x18,0x08,0x1000,
+  {0x01,0x03,0x00,0x02},
+  0x63,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0xc7,0x06,0x07,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x28,0x1f,0x96,0xb9,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
+   0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
+   0x08,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,
+   0xff}
+ },
+/* MD_3_200 */
+ {
+  0x50,0x18,0x08,0x1000,
+  {0x01,0x03,0x00,0x02},
+  0x63,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0xc7,0x06,0x07,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x28,0x1f,0x96,0xb9,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
+   0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
+   0x08,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,
+   0xff}
+ },
+/* MD_4 */
+ {
+  0x28,0x18,0x08,0x4000,
+  {0x09,0x03,0x00,0x02},
+  0x63,
+  {0x2d,0x27,0x28,0x90,0x2c,0x80,0xbf,0x1f,
+   0x00,0xc1,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x14,0x00,0x96,0xb9,0xa2,
+   0xff},
+  {0x00,0x13,0x15,0x17,0x02,0x04,0x06,0x07,
+   0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
+   0x01,0x00,0x03,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x30,0x0f,0x00,
+   0xff}
+ },
+/* MD_5 */
+ {
+  0x28,0x18,0x08,0x4000,
+  {0x09,0x03,0x00,0x02},
+  0x63,
+  {0x2d,0x27,0x28,0x90,0x2c,0x80,0xbf,0x1f,
+   0x00,0xc1,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x14,0x00,0x96,0xb9,0xa2,
+   0xff},
+  {0x00,0x13,0x15,0x17,0x02,0x04,0x06,0x07,
+   0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
+   0x01,0x00,0x03,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x30,0x0f,0x00,
+   0xff}
+ },
+/* MD_6 */
+ {
+  0x50,0x18,0x08,0x4000,
+  {0x01,0x01,0x00,0x06},
+  0x63,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0xc1,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x28,0x00,0x96,0xb9,0xc2,
+   0xff},
+  {0x00,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
+   0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
+   0x01,0x00,0x01,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x00,0x0d,0x00,
+   0xff}
+ },
+/* MD_7 */
+ {
+  0x50,0x18,0x0e,0x1000,
+  {0x00,0x03,0x00,0x03},
+  0xa6,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0x4d,0x0b,0x0c,0x00,0x00,0x00,0x00,
+   0x83,0x85,0x5d,0x28,0x0d,0x63,0xba,0xa3,
+   0xff},
+  {0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
+   0x10,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+   0x0e,0x00,0x0f,0x08},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0a,0x00,
+   0xff}
+ },
+/* MDA_DAC */
+ {
+  0x00,0x00,0x00,0x0000,
+  {0x00,0x00,0x00,0x15},
+  0x15,
+  {0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
+   0x15,0x15,0x15,0x15,0x15,0x15,0x3f,0x3f,
+   0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x00,0x00,
+   0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x15,0x15,0x15,
+   0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
+   0x15,0x15,0x15,0x15},
+  {0x15,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
+   0x3f}
+ },
+/* CGA_DAC */
+ {
+  0x00,0x10,0x04,0x0114,
+  {0x11,0x09,0x15,0x00},
+  0x10,
+  {0x04,0x14,0x01,0x11,0x09,0x15,0x2a,0x3a,
+   0x2e,0x3e,0x2b,0x3b,0x2f,0x3f,0x2a,0x3a,
+   0x2e,0x3e,0x2b,0x3b,0x2f,0x3f,0x00,0x10,
+   0x04},
+  {0x14,0x01,0x11,0x09,0x15,0x00,0x10,0x04,
+   0x14,0x01,0x11,0x09,0x15,0x2a,0x3a,0x2e,
+   0x3e,0x2b,0x3b,0x2f},
+  {0x3f,0x2a,0x3a,0x2e,0x3e,0x2b,0x3b,0x2f,
+   0x3f}
+ },
+/* EGA_DAC */
+ {
+  0x00,0x10,0x04,0x0114,
+  {0x11,0x05,0x15,0x20},
+  0x30,
+  {0x24,0x34,0x21,0x31,0x25,0x35,0x08,0x18,
+   0x0c,0x1c,0x09,0x19,0x0d,0x1d,0x28,0x38,
+   0x2c,0x3c,0x29,0x39,0x2d,0x3d,0x02,0x12,
+   0x06},
+  {0x16,0x03,0x13,0x07,0x17,0x22,0x32,0x26,
+   0x36,0x23,0x33,0x27,0x37,0x0a,0x1a,0x0e,
+   0x1e,0x0b,0x1b,0x0f},
+  {0x1f,0x2a,0x3a,0x2e,0x3e,0x2b,0x3b,0x2f,
+   0x3f}
+ },
+/* VGA_DAC */
+ {
+  0x00,0x10,0x04,0x0114,
+  {0x11,0x09,0x15,0x2a},
+  0x3a,
+  {0x2e,0x3e,0x2b,0x3b,0x2f,0x3f,0x00,0x05,
+   0x08,0x0b,0x0e,0x11,0x14,0x18,0x1c,0x20,
+   0x24,0x28,0x2d,0x32,0x38,0x3f,0x00,0x10,
+   0x1f},
+  {0x2f,0x3f,0x1f,0x27,0x2f,0x37,0x3f,0x2d,
+   0x31,0x36,0x3a,0x3f,0x00,0x07,0x0e,0x15,
+   0x1c,0x0e,0x11,0x15},
+  {0x18,0x1c,0x14,0x16,0x18,0x1a,0x1c,0x00,
+   0x04}
+ },
+ {
+  0x08,0x0c,0x10,0x0a08,
+  {0x0c,0x0e,0x10,0x0b},
+  0x0c,
+  {0x0d,0x0f,0x10,0x10,0x01,0x08,0x00,0x00,
+   0x00,0x00,0x01,0x00,0x02,0x02,0x01,0x00,
+   0x04,0x04,0x01,0x00,0x05,0x02,0x05,0x00,
+   0x06},
+  {0x01,0x06,0x05,0x06,0x00,0x08,0x01,0x08,
+   0x00,0x07,0x02,0x07,0x06,0x07,0x00,0x00,
+   0x00,0x00,0x00,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x00}
+ },
+/* MD_D */
+ {
+  0x28,0x18,0x08,0x2000,
+  {0x09,0x0f,0x00,0x06},
+  0x63,
+  {0x2d,0x27,0x28,0x90,0x2c,0x80,0xbf,0x1f,
+   0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x14,0x00,0x96,0xb9,0xe3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
+   0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
+   0x01,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0f,
+   0xff}
+ },
+/* MD_E */
+ {
+  0x50,0x18,0x08,0x4000,
+  {0x01,0x0f,0x00,0x06},
+  0x63,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x28,0x00,0x96,0xb9,0xe3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
+   0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
+   0x01,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0f,
+   0xff}
+ },
+/* ExtVGATable */
+ {
+  0x00,0x00,0x00,0x0000,
+  {0x01,0x0f,0x00,0x0e},
+  0x23,
+  {0x5f,0x4f,0x50,0x82,0x54,0x80,0x0b,0x3e,
+   0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,
+   0xea,0x8c,0xdf,0x28,0x40,0xe7,0x04,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
+   0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
+   0x01,0x00,0x00,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0f,
+   0xff}
+ },
+/* ROM_SAVEPTR */
+ {
+  0x9f,0x3b,0x00,0x00c0,
+  {0x00,0x00,0x00,0x00},
+  0x00,
+  {0x00,0x00,0x00,0x00,0x00,0x00,0xbb,0x3f,
+   0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x00,0x00,0x1a,0x00,0xac,0x3e,0x00,0xc0,
+   0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x00,0x00,0x00,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x00}
+ },
+/* MD_F */
+ {
+  0x50,0x18,0x0e,0x8000,
+  {0x01,0x0f,0x00,0x06},
+  0xa2,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x82,0x84,0x5d,0x28,0x0f,0x63,0xba,0xe3,
+   0xff},
+  {0x00,0x08,0x00,0x00,0x18,0x18,0x00,0x00,
+   0x00,0x08,0x00,0x00,0x00,0x18,0x00,0x00,
+   0x0b,0x00,0x05,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x05,
+   0xff}
+ },
+/* MD_10 */
+ {
+  0x50,0x18,0x0e,0x8000,
+  {0x01,0x0f,0x00,0x06},
+  0xa3,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x82,0x84,0x5d,0x28,0x0f,0x63,0xba,0xe3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,
+   0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
+   0x01,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0f,
+   0xff}
+ },
+/* MD_0_350 */
+ {
+  0x28,0x18,0x0e,0x0800,
+  {0x09,0x03,0x00,0x02},
+  0xa3,
+  {0x2d,0x27,0x28,0x90,0x2b,0xb1,0xbf,0x1f,
+   0x00,0x4d,0x0b,0x0c,0x00,0x00,0x00,0x00,
+   0x83,0x85,0x5d,0x14,0x1f,0x63,0xba,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,
+   0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
+   0x08,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,
+   0xff}
+ },
+/* MD_1_350 */
+ {
+  0x28,0x18,0x0e,0x0800,
+  {0x09,0x03,0x00,0x02},
+  0xa3,
+  {0x2d,0x27,0x28,0x90,0x2b,0xa0,0xbf,0x1f,
+   0x00,0x4d,0x0b,0x0c,0x00,0x00,0x00,0x00,
+   0x83,0x85,0x5d,0x14,0x1f,0x63,0xba,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,
+   0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
+   0x08,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,
+   0xff}
+ },
+/* MD_2_350 */
+ {
+  0x50,0x18,0x0e,0x1000,
+  {0x01,0x03,0x00,0x02},
+  0xa3,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0x4d,0x0b,0x0c,0x00,0x00,0x00,0x00,
+   0x83,0x85,0x5d,0x28,0x1f,0x63,0xba,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,
+   0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
+   0x08,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,
+   0xff}
+ },
+/* MD_3_350 */
+ {
+  0x50,0x18,0x0e,0x1000,
+  {0x01,0x03,0x00,0x02},
+  0xa3,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0x4d,0x0b,0x0c,0x00,0x00,0x00,0x00,
+   0x83,0x85,0x5d,0x28,0x1f,0x63,0xba,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,
+   0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
+   0x08,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,
+   0xff}
+ },
+/* MD_0_1_400 */
+ {
+  0x28,0x18,0x10,0x0800,
+  {0x08,0x03,0x00,0x02},
+  0x67,
+  {0x2d,0x27,0x28,0x90,0x2b,0xb1,0xbf,0x1f,
+   0x00,0x4f,0x0d,0x0e,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x14,0x1f,0x96,0xb9,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,
+   0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
+   0x0c,0x00,0x0f,0x08},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,
+   0xff}
+ },
+/* MD_2_3_400 */
+ {
+  0x50,0x18,0x10,0x1000,
+  {0x00,0x03,0x00,0x02},
+  0x67,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0x4f,0x0d,0x0e,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x28,0x1f,0x96,0xb9,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,
+   0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
+   0x0c,0x00,0x0f,0x08},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,
+   0xff}
+ },
+/* MD_7_400 */
+ {
+  0x50,0x18,0x10,0x1000,
+  {0x00,0x03,0x00,0x02},
+  0x66,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0x4f,0x0d,0x0e,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x28,0x0f,0x96,0xb9,0xa3,
+   0xff},
+  {0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
+   0x10,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+   0x0e,0x00,0x0f,0x08},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0a,0x00,
+   0xff}
+ },
+/* MD_11 */
+ {
+  0x50,0x1d,0x10,0xa000,
+  {0x01,0x0f,0x00,0x06},
+  0xe3,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0x0b,0x3e,
+   0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,
+   0xe9,0x8b,0xdf,0x28,0x00,0xe7,0x04,0xc3,
+   0xff},
+  {0x00,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
+   0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
+   0x01,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x01,
+   0xff}
+ },
+/* ExtEGATable */
+ {
+  0x50,0x1d,0x10,0xa000,
+  {0x01,0x0f,0x00,0x06},
+  0xe3,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0x0b,0x3e,
+   0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,
+   0xe9,0x8b,0xdf,0x28,0x00,0xe7,0x04,0xe3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,
+   0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
+   0x01,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0f,
+   0xff}
+ },
+/* MD_13 */
+ {
+  0x28,0x18,0x08,0x2000,
+  {0x01,0x0f,0x00,0x0e},
+  0x63,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0x41,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x28,0x40,0x96,0xb9,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
+   0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
+   0x41,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0f,
+   0xff}
+ }
+};
+
+XGI_TimingHStruct XGI_TimingH[]=
+{{{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}}};
+
+XGI_TimingVStruct XGI_TimingV[]=
+{{{0x00,0x00,0x00,0x00,0x00,0x00,0x00}}};
+
+XGI_XG21CRT1Struct XGI_UpdateCRT1Table[]=
+{
+ {0x01,0x27,0x91,0x8f,0xc0},	/* 00 */
+ {0x03,0x4f,0x83,0x8f,0xc0},	/* 01 */
+ {0x05,0x27,0x91,0x8f,0xc0},	/* 02 */
+ {0x06,0x4f,0x83,0x8f,0xc0},	/* 03 */
+ {0x07,0x4f,0x83,0x8f,0xc0},	/* 04 */
+ {0x0d,0x27,0x91,0x8f,0xc0},	/* 05 */
+ {0x0e,0x4f,0x83,0x8f,0xc0},	/* 06 */
+ {0x0f,0x4f,0x83,0x5d,0xc0},	/* 07 */
+ {0x10,0x4f,0x83,0x5d,0xc0},	/* 08 */
+ {0x11,0x4f,0x83,0xdf,0x0c},	/* 09 */
+ {0x12,0x4f,0x83,0xdf,0x0c},	/* 10 */
+ {0x13,0x4f,0x83,0x8f,0xc0},	/* 11 */
+ {0x2e,0x4f,0x83,0xdf,0x0c},	/* 12 */
+ {0x2e,0x4f,0x87,0xdf,0xc0},	/* 13 */
+ {0x2f,0x4f,0x83,0x8f,0xc0},	/* 14 */
+ {0x50,0x27,0x91,0xdf,0x0c},	/* 15 */
+ {0x59,0x27,0x91,0x8f,0xc0}	/* 16 */
+};
+
+XGI_CRT1TableStruct XGI_CRT1Table[]=
+{
+ {{0x2d,0x28,0x90,0x2c,0x90,0x00,0x04,0x00,
+    0xbf,0x1f,0x9c,0x8e,0x96,0xb9,0x30}}, /* 0x0 */
+ {{0x2d,0x28,0x90,0x2c,0x90,0x00,0x04,0x00,
+    0x0b,0x3e,0xe9,0x8b,0xe7,0x04,0x00}}, /* 0x1 */
+ {{0x3D,0x31,0x81,0x37,0x1F,0x00,0x05,0x00,
+    0x72,0xF0,0x58,0x8C,0x57,0x73,0xA0}}, /* 0x2 */
+ {{0x4F,0x3F,0x93,0x45,0x0D,0x00,0x01,0x00,
+    0x24,0xF5,0x02,0x88,0xFF,0x25,0x90}}, /* 0x3 */
+ {{0x5F,0x50,0x82,0x55,0x81,0x00,0x05,0x00,
+    0xBF,0x1F,0x9C,0x8E,0x96,0xB9,0x30}}, /* 0x4 */
+ {{0x5F,0x50,0x82,0x55,0x81,0x00,0x05,0x00,
+    0x0B,0x3E,0xE9,0x8B,0xE7,0x04,0x00}}, /* 0x5 */
+ {{0x63,0x50,0x86,0x56,0x9B,0x00,0x01,0x00,
+    0x06,0x3E,0xE8,0x8B,0xE7,0xFF,0x10}}, /* 0x6 */
+ {{0x64,0x4F,0x88,0x55,0x9D,0x00,0x01,0x00,
+    0xF2,0x1F,0xE0,0x83,0xDF,0xF3,0x10}}, /* 0x7 */
+ {{0x63,0x4F,0x87,0x5A,0x81,0x00,0x05,0x00,
+    0xFB,0x1F,0xE0,0x83,0xDF,0xFC,0x10}}, /* 0x8 */
+ {{0x65,0x4F,0x89,0x58,0x80,0x00,0x05,0x60,
+    0xFB,0x1F,0xE0,0x83,0xDF,0xFC,0x80}}, /* 0x9 */
+ {{0x65,0x4F,0x89,0x58,0x80,0x00,0x05,0x60,
+    0x01,0x3E,0xE0,0x83,0xDF,0x02,0x80}}, /* 0xa */
+ {{0x67,0x4F,0x8B,0x58,0x81,0x00,0x05,0x60,
+    0x0D,0x3E,0xE0,0x83,0xDF,0x0E,0x90}}, /* 0xb */
+ {{0x65,0x4F,0x89,0x57,0x9F,0x00,0x01,0x00,
+   0xFB,0x1F,0xE6,0x8A,0xDF,0xFC,0x10}}, /* 0xc */
+ {{0x7B,0x63,0x9F,0x6A,0x93,0x00,0x05,0x00,    /* ; 0D (800x600,56Hz) */
+    0x6F,0xF0,0x58,0x8A,0x57,0x70,0xA0}},         /* ; (VCLK 36.0MHz) */
+ {{0x7F,0x63,0x83,0x6C,0x1C,0x00,0x06,0x00,    /* ; 0E (800x600,60Hz) */
+    0x72,0xF0,0x58,0x8C,0x57,0x73,0xA0}},         /* ; (VCLK 40.0MHz) */
+ {{0x7D,0x63,0x81,0x6E,0x1D,0x00,0x06,0x00,    /* ; 0F (800x600,72Hz) */
+    0x98,0xF0,0x7C,0x82,0x57,0x99,0x80}},         /* ; (VCLK 50.0MHz) */
+ {{0x7F,0x63,0x83,0x69,0x13,0x00,0x06,0x00,    /* ; 10 (800x600,75Hz) */
+    0x6F,0xF0,0x58,0x8B,0x57,0x70,0xA0}},         /* ; (VCLK 49.5MHz) */
+ {{0x7E,0x63,0x82,0x6B,0x13,0x00,0x06,0x00,    /* ; 11 (800x600,85Hz) */
+    0x75,0xF0,0x58,0x8B,0x57,0x76,0xA0}},         /* ; (VCLK 56.25MHz) */
+ {{0x81,0x63,0x85,0x6D,0x18,0x00,0x06,0x60,    /* ; 12 (800x600,100Hz) */
+    0x7A,0xF0,0x58,0x8B,0x57,0x7B,0xA0}},         /* ; (VCLK 75.8MHz) */
+ {{0x83,0x63,0x87,0x6E,0x19,0x00,0x06,0x60,    /* ; 13 (800x600,120Hz) */
+    0x81,0xF0,0x58,0x8B,0x57,0x82,0xA0}},         /* ; (VCLK 79.411MHz) */
+ {{0x85,0x63,0x89,0x6F,0x1A,0x00,0x06,0x60,    /* ; 14 (800x600,160Hz) */
+   0x91,0xF0,0x58,0x8B,0x57,0x92,0xA0}},         /* ; (VCLK 105.822MHz) */
+ {{0x99,0x7F,0x9D,0x84,0x1A,0x00,0x02,0x00,
+    0x96,0x1F,0x7F,0x83,0x7F,0x97,0x10}}, /* 0x15 */
+ {{0xA3,0x7F,0x87,0x86,0x97,0x00,0x02,0x00,
+    0x24,0xF5,0x02,0x88,0xFF,0x25,0x90}}, /* 0x16 */
+ {{0xA1,0x7F,0x85,0x86,0x97,0x00,0x02,0x00,
+    0x24,0xF5,0x02,0x88,0xFF,0x25,0x90}}, /* 0x17 */
+ {{0x9F,0x7F,0x83,0x85,0x91,0x00,0x02,0x00,
+    0x1E,0xF5,0x00,0x83,0xFF,0x1F,0x90}}, /* 0x18 */
+ {{0xA7,0x7F,0x8B,0x89,0x95,0x00,0x02,0x00,
+    0x26,0xF5,0x00,0x83,0xFF,0x27,0x90}}, /* 0x19 */
+ {{0xA9,0x7F,0x8D,0x8C,0x9A,0x00,0x02,0x62,
+    0x2C,0xF5,0x00,0x83,0xFF,0x2D,0x14}}, /* 0x1a */
+ {{0xAB,0x7F,0x8F,0x8D,0x9B,0x00,0x02,0x62,
+    0x35,0xF5,0x00,0x83,0xFF,0x36,0x14}}, /* 0x1b */
+ {{0xCF,0x9F,0x93,0xB2,0x01,0x00,0x03,0x00,
+    0x14,0xBA,0x00,0x83,0xFF,0x15,0x00}}, /* 0x1c */
+ {{0xCE,0x9F,0x92,0xA9,0x17,0x00,0x07,0x00,
+    0x28,0x5A,0x00,0x83,0xFF,0x29,0x89}}, /* 0x1d */
+ {{0xCE,0x9F,0x92,0xA5,0x17,0x00,0x07,0x00,
+    0x28,0x5A,0x00,0x83,0xFF,0x29,0x89}}, /* 0x1e */
+ {{0xD3,0x9F,0x97,0xAB,0x1F,0x00,0x07,0x00,
+    0x2E,0x5A,0x00,0x83,0xFF,0x2F,0x89}}, /* 0x1f */
+ {{0x09,0xC7,0x8D,0xD3,0x0B,0x01,0x04,0x00,
+    0xE0,0x10,0xB0,0x83,0xAF,0xE1,0x2F}}, /* 0x20 */
+ {{0x09,0xC7,0x8D,0xD3,0x0B,0x01,0x04,0x00,
+    0xE0,0x10,0xB0,0x83,0xAF,0xE1,0x2F}}, /* 0x21 */
+ {{0x09,0xC7,0x8D,0xD3,0x0B,0x01,0x04,0x00,
+    0xE0,0x10,0xB0,0x83,0xAF,0xE1,0x2F}}, /* 0x22 */
+ {{0x09,0xC7,0x8D,0xD3,0x0B,0x01,0x04,0x00,
+    0xE0,0x10,0xB0,0x83,0xAF,0xE1,0x2F}}, /* 0x23 */
+ {{0x09,0xC7,0x8D,0xD3,0x0B,0x01,0x04,0x00,
+    0xE0,0x10,0xB0,0x83,0xAF,0xE1,0x2F}}, /* 0x24 */
+ {{0x09,0xC7,0x8D,0xD3,0x0B,0x01,0x04,0x00,
+    0xE0,0x10,0xB0,0x83,0xAF,0xE1,0x2F}}, /* 0x25 */
+ {{0x09,0xC7,0x8D,0xD3,0x0B,0x01,0x04,0x00,
+    0xE0,0x10,0xB0,0x83,0xAF,0xE1,0x2F}}, /* 0x26 */
+ {{0x40,0xEF,0x84,0x03,0x1D,0x41,0x01,0x00,
+    0xDA,0x1F,0xA0,0x83,0x9F,0xDB,0x1F}}, /* 0x27 */
+ {{0x43,0xEF,0x87,0x06,0x00,0x41,0x05,0x62,
+    0xD4,0x1F,0xA0,0x83,0x9F,0xD5,0x9F}}, /* 0x28 */
+ {{0x45,0xEF,0x89,0x07,0x01,0x41,0x05,0x62,
+    0xD9,0x1F,0xA0,0x83,0x9F,0xDA,0x9F}}, /* 0x29 */
+ {{0x40,0xEF,0x84,0x03,0x1D,0x41,0x01,0x00,
+    0xDA,0x1F,0xA0,0x83,0x9F,0xDB,0x1F}}, /* 0x2a */
+ {{0x40,0xEF,0x84,0x03,0x1D,0x41,0x01,0x00,
+    0xDA,0x1F,0xA0,0x83,0x9F,0xDB,0x1F}}, /* 0x2b */
+ {{0x40,0xEF,0x84,0x03,0x1D,0x41,0x01,0x00,
+    0xDA,0x1F,0xA0,0x83,0x9F,0xDB,0x1F}}, /* 0x2c */
+ {{0x59,0xFF,0x9D,0x17,0x13,0x41,0x05,0x44,
+    0x33,0xBA,0x00,0x83,0xFF,0x34,0x0F}}, /* 0x2d */
+ {{0x5B,0xFF,0x9F,0x18,0x14,0x41,0x05,0x44,
+    0x38,0xBA,0x00,0x83,0xFF,0x39,0x0F}}, /* 0x2e */
+ {{0x5B,0xFF,0x9F,0x18,0x14,0x41,0x05,0x44,
+    0x3D,0xBA,0x00,0x83,0xFF,0x3E,0x0F}}, /* 0x2f */
+ {{0x5D,0xFF,0x81,0x19,0x95,0x41,0x05,0x44,
+    0x41,0xBA,0x00,0x84,0xFF,0x42,0x0F}}, /* 0x30 */
+ {{0x55,0xFF,0x99,0x0D,0x0C,0x41,0x05,0x00,
+    0x3E,0xBA,0x00,0x84,0xFF,0x3F,0x0F}}, /* 0x31 */
+ {{0x7F,0x63,0x83,0x6C,0x1C,0x00,0x06,0x00,
+    0x72,0xBA,0x27,0x8B,0xDF,0x73,0x80}}, /* 0x32 */
+ {{0x7F,0x63,0x83,0x69,0x13,0x00,0x06,0x00,
+    0x6F,0xBA,0x26,0x89,0xDF,0x6F,0x80}}, /* 0x33 */
+ {{0x7F,0x63,0x82,0x6B,0x13,0x00,0x06,0x00,
+    0x75,0xBA,0x29,0x8C,0xDF,0x75,0x80}}, /* 0x34 */
+ {{0xA3,0x7F,0x87,0x86,0x97,0x00,0x02,0x00,
+    0x24,0xF1,0xAF,0x85,0x3F,0x25,0xB0}}, /* 0x35 */
+ {{0x9F,0x7F,0x83,0x85,0x91,0x00,0x02,0x00,
+    0x1E,0xF1,0xAD,0x81,0x3F,0x1F,0xB0}}, /* 0x36 */
+ {{0xA7,0x7F,0x88,0x89,0x15,0x00,0x02,0x00,
+    0x26,0xF1,0xB1,0x85,0x3F,0x27,0xB0}}, /* 0x37 */
+ {{0xCE,0x9F,0x92,0xA9,0x17,0x00,0x07,0x00,
+    0x28,0xC4,0x7A,0x8E,0xCF,0x29,0xA1}}, /* 0x38 */
+ {{0xCE,0x9F,0x92,0xA5,0x17,0x00,0x07,0x00,
+    0x28,0xD4,0x7A,0x8E,0xCF,0x29,0xA1}}, /* 0x39 */
+ {{0xD3,0x9F,0x97,0xAB,0x1F,0x00,0x07,0x00,
+    0x2E,0xD4,0x7D,0x81,0xCF,0x2F,0xA1}}, /* 0x3a */
+ {{0xDC,0x9F,0x00,0xAB,0x19,0x00,0x07,0x00,
+    0xE6,0xEF,0xC0,0xC3,0xBF,0xE7,0x90}}, /* 0x3b */
+ {{0x6B,0x59,0x8F,0x5E,0x8C,0x00,0x05,0x00,
+    0x0B,0x3E,0xE9,0x8B,0xE7,0x04,0x00}}, /* 0x3c */
+ {{0x7B,0x63,0x9F,0x6A,0x93,0x00,0x05,0x00,
+    0x6F,0xF0,0x58,0x8A,0x57,0x70,0xA0}}, /* 0x3d */
+ {{0x86,0x6A,0x8a,0x74,0x06,0x00,0x02,0x00,
+    0x8c,0x15,0x4f,0x83,0xef,0x8d,0x30}}, /* 0x3e */
+ {{0x81,0x6A,0x85,0x70,0x00,0x00,0x02,0x00,
+    0x0f,0x3e,0xeb,0x8e,0xdf,0x10,0x00}}, /* 0x3f */
+ {{0xCE,0x9F,0x92,0xA9,0x17,0x00,0x07,0x00,
+    0x20,0xF5,0x03,0x88,0xFF,0x21,0x90}}, /* 0x40 */
+ {{0xE6,0xAE,0x8A,0xBD,0x90,0x00,0x03,0x00,
+    0x3D,0x10,0x1A,0x8D,0x19,0x3E,0x2F}}, /* 0x41 */
+ {{0xB9,0x8F,0x9D,0x9B,0x8A,0x00,0x06,0x00,
+    0x7D,0xFF,0x60,0x83,0x5F,0x7E,0x90}}, /* 0x42 */
+ {{0xC3,0x8F,0x87,0x9B,0x0B,0x00,0x07,0x00,
+    0x82,0xFF,0x60,0x83,0x5F,0x83,0x90}},  /* 0x43 */
+ {{0xAD,0x7F,0x91,0x8E,0x9C,0x00,0x02,0x82,
+    0x49,0xF5,0x00,0x83,0xFF,0x4A,0x90}},  /* 0x44 */
+ {{0xCD,0x9F,0x91,0xA7,0x19,0x00,0x07,0x60,
+    0xE6,0xFF,0xC0,0x83,0xBF,0xE7,0x90}},  /* 0x45 */
+ {{0xD3,0x9F,0x97,0xAB,0x1F,0x00,0x07,0x60,
+    0xF1,0xFF,0xC0,0x83,0xBF,0xF2,0x90}},  /* 0x46 */
+ {{0xD7,0x9F,0x9B,0xAC,0x1E,0x00,0x07,0x00,
+    0x03,0xDE,0xC0,0x84,0xBF,0x04,0x90}}  /* 0x47 */
+};
+
+XGI330_CHTVRegDataStruct XGI_CHTVRegUNTSC[] = {
+                /* Index:000h,001h,002h,004h,003h,005h,006h,007h,008h,015h,01Fh,00Ch,00Dh,00Eh,00Fh,010h */
+                {{      0x4A,0x77,0xBB,0x94,0x84,0x48,0xFE,0x50,0x04,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* 00 (640x200,640x400) */
+                {{      0x4A,0x77,0xBB,0x94,0x84,0x48,0xFE,0x50,0x04,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* 01 (640x350) */
+                {{      0x4A,0x77,0xBB,0x94,0x84,0x48,0xFE,0x50,0x04,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* 02 (720x400) */
+                {{      0x4A,0x77,0xBB,0x94,0x84,0x48,0xFE,0x50,0x04,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* 03 (720x350) */
+                {{      0x6A,0x77,0xBB,0x6E,0x84,0x2E,0x02,0x5A,0x04,0x00,0x80,0x20,0x7E,0x80,0x97,0x00  }},/* 04 (640x480) ;;5/6/02 */
+                {{      0xCF,0x77,0xB7,0xC8,0x84,0x3B,0x02,0x5A,0x04,0x00,0x80,0x19,0x88,0xAE,0xA3,0x00  }},/* 05 (800x600) ;;1/12/02 */
+                {{      0xEE,0x77,0xBB,0x66,0x87,0x32,0x01,0x5A,0x04,0x00,0x80,0x1B,0xD4,0x2F,0x6F,0x00  }}/* 06 (1024x768) ;;5/6/02 */
+          };
+
+XGI330_CHTVRegDataStruct XGI_CHTVRegONTSC[]= {
+                /* Index:000h,001h,002h,004h,003h,005h,006h,007h,008h,015h,01Fh,00Ch,00Dh,00Eh,00Fh,010h */
+                {{      0x49,0x77,0xBB,0x7B,0x84,0x34,0x00,0x50,0x04,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* 00 (640x200,640x400) */
+                {{      0x49,0x77,0xBB,0x7B,0x84,0x34,0x00,0x50,0x04,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* 01 (640x350) */
+                {{      0x49,0x77,0xBB,0x7B,0x84,0x34,0x00,0x50,0x04,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* 02 (720x400) */
+                {{      0x49,0x77,0xBB,0x7B,0x84,0x34,0x00,0x50,0x04,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* 03 (720x350) */
+                {{      0x69,0x77,0xBB,0x6E,0x84,0x1E,0x00,0x5A,0x04,0x00,0x80,0x25,0x1A,0x80,0x26,0x00  }},/* 04 (640x480) ;;5/6/02 */
+                {{      0xCE,0x77,0xB7,0xB6,0x83,0x2C,0x02,0x5A,0x04,0x00,0x80,0x1C,0x00,0x82,0x97,0x00  }},/* 05 (800x600) ;;5/6/02 */
+                {{      0xED,0x77,0xBB,0x66,0x8C,0x21,0x02,0x5A,0x04,0x00,0x80,0x1F,0xA0,0x7E,0x73,0x00  }}/* 06 (1024x768) ;;5/6/02 */
+          };
+
+XGI330_CHTVRegDataStruct XGI_CHTVRegUPAL[]=  {
+                /* Index:000h,001h,002h,004h,003h,005h,006h,007h,008h,015h,01Fh,00Ch,00Dh,00Eh,00Fh,010h */
+                {{      0x41,0x7F,0xB7,0x34,0xAD,0x50,0x34,0x83,0x05,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* ; 00 (640x200,640x400) */
+                {{      0x41,0x7F,0xB7,0x80,0x85,0x50,0x00,0x83,0x05,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* ; 01 (640x350) */
+                {{      0x41,0x7F,0xB7,0x34,0xAD,0x50,0x34,0x83,0x05,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* ; 02 (720x400) */
+                {{      0x41,0x7F,0xB7,0x12,0x85,0x50,0x00,0x83,0x05,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* ; 03 (720x350) */
+                {{      0x61,0x7F,0xB7,0x99,0x84,0x35,0x04,0x5A,0x05,0x00,0x80,0x26,0x2A,0x55,0x5D,0x00  }},/* ; 04 (640x480) */
+                {{      0xC3,0x7F,0xB7,0x7A,0x84,0x40,0x02,0x5A,0x05,0x00,0x80,0x1F,0x84,0x3D,0x28,0x00  }},/* ; 05 (800x600) ;;1/12/02 */
+                {{      0xE5,0x7F,0xB7,0x1D,0xA7,0x3E,0x04,0x5A,0x05,0x00,0x80,0x20,0x3E,0xE4,0x22,0x00  }}/* ; 06 (1024x768) ;;1/12/02 */
+	  };
+
+XGI330_CHTVRegDataStruct XGI_CHTVRegOPAL[]={
+                /* Index:000,0x01,0x02,0x04,0x03,0x05,0x06,0x07,0x08,0x15,0x1F,0x0C,0x0D,0x0E,0x0F,0x10h */
+                {{      0x41,0x7F,0xB7,0x36,0xAD,0x50,0x34,0x83,0x05,0x00,0x80,0x00,0x00,0x00,0x00,0x01 }},/* 00 (640x200,640x400) */
+                {{      0x41,0x7F,0xB7,0x86,0x85,0x50,0x00,0x83,0x05,0x00,0x80,0x00,0x00,0x00,0x00,0x01 }},/* 01 (640x350) */
+                {{      0x41,0x7F,0xB7,0x36,0xAD,0x50,0x34,0x83,0x05,0x00,0x80,0x00,0x00,0x00,0x00,0x01 }},/* 02 (720x400) */
+                {{      0x41,0x7F,0xB7,0x86,0x85,0x50,0x00,0x83,0x05,0x00,0x80,0x00,0x00,0x00,0x00,0x01 }},/* 03 (720x350) */
+                {{      0x61,0x7F,0xB7,0x99,0x84,0x35,0x04,0x5A,0x05,0x00,0x80,0x26,0x2A,0x55,0x5D,0x00 }},/* 04 (640x480) */
+                {{      0xC1,0x7F,0xB7,0x4D,0x8C,0x1E,0x31,0x5A,0x05,0x00,0x80,0x26,0x78,0x19,0x34,0x00 }},/* 05 (800x600) ;;1/12/02 */
+                {{      0xE4,0x7F,0xB7,0x1E,0xAF,0x29,0x37,0x5A,0x05,0x00,0x80,0x25,0x8C,0xB2,0x2A,0x00 }}/* 06 (1024x768) ;;1/12/02 */
+	     };
+
+UCHAR XGI_CH7017LV1024x768[]={0x60,0x02,0x00,0x07,0x40,0xED,0xA3,
+                   			0xC8,0xC7,0xAC,0xE0,0x02};
+UCHAR XGI_CH7017LV1400x1050[]={0x60,0x03,0x11,0x00,0x40,0xE3,0xAD,
+                   			0xDB,0xF6,0xAC,0xE0,0x02};
+
+
+/*add for new UNIVGABIOS*/
+XGI330_LCDDataStruct  XGI_StLCD1024x768Data[]=
+{
+ {   62,  25, 800, 546,1344, 806},
+ {   32,  15, 930, 546,1344, 806},
+ {   62,  25, 800, 546,1344, 806}, /* chiawen for dot9 -> dot8 */
+ {  104,  45, 945, 496,1344, 806},
+ {   62,  25, 800, 546,1344, 806},
+ {   31,  18,1008, 624,1344, 806},
+ {    1,   1,1344, 806,1344, 806}
+};
+
+XGI330_LCDDataStruct  XGI_ExtLCD1024x768Data[]=
+{
+ {   42,  25,1536, 419,1344, 806}, /* { 12, 5, 896, 512,1344, 806}, // alan 09/12/2003 */
+ {   48,  25,1536, 369,1344, 806}, /* { 12, 5, 896, 510,1344, 806}, // alan 09/12/2003 */
+ {   42,  25,1536, 419,1344, 806}, /* { 32, 15,1008, 505,1344, 806}, // alan 09/12/2003 */
+ {   48,  25,1536, 369,1344, 806}, /* { 32, 15,1008, 514,1344, 806}, // alan 09/12/2003 */
+ {   12,   5, 896, 500,1344, 806},
+ {   42,  25,1024, 625,1344, 806},
+ {    1,   1,1344, 806,1344, 806},
+ {   12,   5, 896, 500,1344, 806},
+ {   42,  25,1024, 625,1344, 806},
+ {    1,   1,1344, 806,1344, 806},
+ {   12,   5, 896, 500,1344, 806},
+ {   42,  25,1024, 625,1344, 806},
+ {    1,   1,1344, 806,1344, 806}
+};
+
+/*XGI330_LCDDataStruct  XGI_St2LCD1024x768Data[]=
+{
+ {   62,  25, 800, 546,1344, 806},
+ {   32,  15, 930, 546,1344, 806},
+ {   62,  25, 800, 546,1344, 806},
+ {  104,  45, 945, 496,1344, 806},
+ {   62,  25, 800, 546,1344, 806},
+ {   31,  18,1008, 624,1344, 806},
+ {    1,   1,1344, 806,1344, 806}
+};*/
+
+XGI330_LCDDataStruct  XGI_CetLCD1024x768Data[]=
+{
+	{         1,1,1344,806,1344,806           }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {         1,1,1344,806,1344,806           }, /* 01 (320x350,640x350) */
+        {         1,1,1344,806,1344,806           }, /* 02 (360x400,720x400) */
+        {         1,1,1344,806,1344,806           }, /* 03 (720x350) */
+        {         1,1,1344,806,1344,806           }, /* 04 (640x480x60Hz) */
+        {         1,1,1344,806,1344,806           }, /* 05 (800x600x60Hz) */
+        {         1,1,1344,806,1344,806           }  /* 06 (1024x768x60Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_StLCD1280x1024Data[]=
+{
+ {   22,   5, 800, 510,1650,1088},
+ {   22,   5, 800, 510,1650,1088},
+ {  176,  45, 900, 510,1650,1088},
+ {  176,  45, 900, 510,1650,1088},
+ {   22,   5, 800, 510,1650,1088},
+ {   13,   5,1024, 675,1560,1152},
+ {   16,   9,1266, 804,1688,1072},
+ {    1,   1,1688,1066,1688,1066}
+};
+
+XGI330_LCDDataStruct  XGI_ExtLCD1280x1024Data[]=
+{
+ {  211,  60,1024, 501,1688,1066},
+ {  211,  60,1024, 508,1688,1066},
+ {  211,  60,1024, 501,1688,1066},
+ {  211,  60,1024, 508,1688,1066},
+ {  211,  60,1024, 500,1688,1066},
+ {  211,  75,1024, 625,1688,1066},
+ {  211, 120,1280, 798,1688,1066},
+ {    1,   1,1688,1066,1688,1066}
+};
+
+XGI330_LCDDataStruct  XGI_St2LCD1280x1024Data[]=
+{
+ {   22,   5, 800, 510,1650,1088},
+ {   22,   5, 800, 510,1650,1088},
+ {  176,  45, 900, 510,1650,1088},
+ {  176,  45, 900, 510,1650,1088},
+ {   22,   5, 800, 510,1650,1088},
+ {   13,   5,1024, 675,1560,1152},
+ {   16,   9,1266, 804,1688,1072},
+ {    1,   1,1688,1066,1688,1066}
+};
+
+XGI330_LCDDataStruct  XGI_CetLCD1280x1024Data[]=
+{
+	{         1,1,1688,1066,1688,1066         }, /* 00 (320x200,320x400,640x200,640x400) */
+        {         1,1,1688,1066,1688,1066         }, /* 01 (320x350,640x350) */
+        {         1,1,1688,1066,1688,1066         }, /* 02 (360x400,720x400) */
+        {         1,1,1688,1066,1688,1066         }, /* 03 (720x350) */
+        {         1,1,1688,1066,1688,1066         }, /* 04 (640x480x60Hz) */
+        {         1,1,1688,1066,1688,1066         }, /* 05 (800x600x60Hz) */
+        {         1,1,1688,1066,1688,1066         }, /* 06 (1024x768x60Hz) */
+        {         1,1,1688,1066,1688,1066         }, /* 07 (1280x1024x60Hz) */
+        {         1,1,1688,1066,1688,1066         } /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_StLCD1400x1050Data[]=
+{
+	{         211,100,2100,408,1688,1066      }, /* 00 (320x200,320x400,640x200,640x400) */
+        {         211,64,1536,358,1688,1066       }, /* 01 (320x350,640x350) */
+        {         211,100,2100,408,1688,1066      }, /* 02 (360x400,720x400) */
+        {         211,64,1536,358,1688,1066       }, /* 03 (720x350) */
+        {         211,48,840,488,1688,1066        }, /* 04 (640x480x60Hz) */
+        {         211,72,1008,609,1688,1066       }, /* 05 (800x600x60Hz) */
+        {         211,128,1400,776,1688,1066      }, /* 06 (1024x768x60Hz) */
+        {         1,1,1688,1066,1688,1066         }, /* 07 (1280x1024x60Hz w/o Scaling) */
+        {         1,1,1688,1066,1688,1066         }  /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_ExtLCD1400x1050Data[]=
+{
+	{         211,100,2100,408,1688,1066      }, /* 00 (320x200,320x400,640x200,640x400) */
+        {         211,64,1536,358,1688,1066       }, /* 01 (320x350,640x350) */
+        {         211,100,2100,408,1688,1066      }, /* 02 (360x400,720x400) */
+        {         211,64,1536,358,1688,1066       }, /* 03 (720x350) */
+        {         211,48,840,488,1688,1066        }, /* 04 (640x480x60Hz) */
+        {         211,72,1008,609,1688,1066       }, /* 05 (800x600x60Hz) */
+        {         211,128,1400,776,1688,1066      }, /* 06 (1024x768x60Hz) */
+        {         1,1,1688,1066,1688,1066         }, /* 07 (1280x1024x60Hz w/o Scaling) */
+        {         1,1,1688,1066,1688,1066         }  /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_ExtLCD1600x1200Data[]=
+{
+        {         4,1,1620,420,2160,1250          }, /* { 3,1,2160,425,2160,1250 }, // 00 (320x200,320x400,640x200,640x400) // alan 10/14/2003 */
+        {         27,7,1920,375,2160,1250         }, /* 01 (320x350,640x350) */
+        {         4,1,1620,420,2160,1250          }, /* { 3,1,2160,425,2160,1250 }, // 02 (360x400,720x400) // alan 10/14/2003 */
+        {         27,7,1920,375,2160,1250         }, /* 03 (720x350) */
+        {         27,4,800,500,2160,1250          }, /* 04 (640x480x60Hz) */
+        {         4,1,1080,625,2160,1250          }, /* 05 (800x600x60Hz) */
+        {         5,2,1350,800,2160,1250          }, /* 06 (1024x768x60Hz) */
+        {         27,16,1500,1064,2160,1250       }, /* 07 (1280x1024x60Hz) */
+        {         9,7,1920,1106,2160,1250         }, /* 08 (1400x1050x60Hz) */
+        {         1,1,2160,1250,2160,1250         }  /* 09 (1600x1200x60Hz) ;302lv */
+};
+
+XGI330_LCDDataStruct  XGI_StLCD1600x1200Data[]=
+{
+        {         27,4,800,500,2160,1250          },/* 00 (320x200,320x400,640x200,640x400) */
+        {         27,4,800,500,2160,1250          },/* 01 (320x350,640x350) */
+        {         27,4,800,500,2160,1250          },/* 02 (360x400,720x400) */
+        {         27,4,800,500,2160,1250          },/* 03 (720x350) */
+        {         27,4,800,500,2160,1250          },/* 04 (320x240,640x480) */
+        {         4,1,1080,625,2160,1250          },/* 05 (400x300,800x600) */
+        {         5,2,1350,800,2160,1250          },/* 06 (512x384,1024x768) */
+        {         135,88,1600,1100,2160,1250      },/* 07 (1280x1024) */
+        {         1,1,1800,1500,2160,1250         },/* 08 (1400x1050) */
+        {         1,1,2160,1250,2160,1250         } /* 09 (1600x1200) */
+};
+
+XGI330_LCDDataStruct  XGI_CetLCD1400x1050Data[]=
+{
+	{         1,1,1688,1066,1688,1066         }, /* 00 (320x200,320x400,640x200,640x400) */
+        {         1,1,1688,1066,1688,1066         }, /* 01 (320x350,640x350) */
+        {         1,1,1688,1066,1688,1066         }, /* 02 (360x400,720x400) */
+        {         1,1,1688,1066,1688,1066         }, /* 03 (720x350) */
+        {         1,1,1688,1066,1688,1066         }, /* 04 (640x480x60Hz) */
+        {         1,1,1688,1066,1688,1066         }, /* 05 (800x600x60Hz) */
+        {         1,1,1688,1066,1688,1066         }, /* 06 (1024x768x60Hz) */
+        {         1,1,1688,1066,1688,1066         }, /* 07 (1280x1024x60Hz) */
+        {         1,1,1688,1066,1688,1066         }  /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_NoScalingData[]=
+{
+ {    1,   1, 800, 449, 800, 449},
+ {    1,   1, 800, 449, 800, 449},
+ {    1,   1, 900, 449, 900, 449},
+ {    1,   1, 900, 449, 900, 449},
+ {    1,   1, 800, 525, 800, 525},
+ {    1,   1,1056, 628,1056, 628},
+ {    1,   1,1344, 806,1344, 806},
+ {    1,   1,1688,1066,1688,1066}
+};
+
+XGI330_LCDDataStruct  XGI_ExtLCD1024x768x75Data[]=
+{
+        {42,25,1536,419,1344,806 }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {48,25,1536,369,1344,806 }, /* ; 01 (320x350,640x350) */
+        {42,25,1536,419,1344,806 }, /* ; 02 (360x400,720x400) */
+        {48,25,1536,369,1344,806 }, /* ; 03 (720x350) */
+        {8,5,1312,500,1312,800   }, /* ; 04 (640x480x75Hz) */
+        {41,25,1024,625,1312,800 }, /* ; 05 (800x600x75Hz) */
+        {1,1,1312,800,1312,800   }  /* ; 06 (1024x768x75Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_StLCD1024x768x75Data[]=
+{
+        {42,25,1536,419,1344,806 }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {48,25,1536,369,1344,806 }, /* ; 01 (320x350,640x350) */
+        {42,25,1536,419,1344,806 }, /* ; 02 (360x400,720x400) */
+        {48,25,1536,369,1344,806 }, /* ; 03 (720x350) */
+        {8,5,1312,500,1312,800   }, /* ; 04 (640x480x75Hz) */
+        {41,25,1024,625,1312,800 }, /* ; 05 (800x600x75Hz) */
+        {1,1,1312,800,1312,800   }  /* ; 06 (1024x768x75Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_CetLCD1024x768x75Data[]=
+{
+        {1,1,1312,800,1312,800}, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {1,1,1312,800,1312,800}, /* ; 01 (320x350,640x350) */
+        {1,1,1312,800,1312,800}, /* ; 02 (360x400,720x400) */
+        {1,1,1312,800,1312,800}, /* ; 03 (720x350) */
+        {1,1,1312,800,1312,800}, /* ; 04 (640x480x75Hz) */
+        {1,1,1312,800,1312,800}, /* ; 05 (800x600x75Hz) */
+        {1,1,1312,800,1312,800} /* ; 06 (1024x768x75Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_ExtLCD1280x1024x75Data[]=
+{
+        {211,60,1024,501,1688,1066   }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {211,60,1024,508,1688,1066   }, /* ; 01 (320x350,640x350) */
+        {211,60,1024,501,1688,1066   }, /* ; 02 (360x400,720x400) */
+        {211,60,1024,508,1688,1066   }, /* ; 03 (720x350) */
+        {211,45,768,498,1688,1066    }, /* ; 04 (640x480x75Hz) */
+        {211,75,1024,625,1688,1066   }, /* ; 05 (800x600x75Hz) */
+        {211,120,1280,798,1688,1066  }, /* ; 06 (1024x768x75Hz) */
+        {1,1,1688,1066,1688,1066     }  /* ; 07 (1280x1024x75Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_StLCD1280x1024x75Data[]=
+{
+        {211,60,1024,501,1688,1066 }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {211,60,1024,508,1688,1066 }, /* ; 01 (320x350,640x350) */
+        {211,60,1024,501,1688,1066 }, /* ; 02 (360x400,720x400) */
+        {211,60,1024,508,1688,1066 }, /* ; 03 (720x350) */
+        {211,45,768,498,1688,1066  }, /* ; 04 (640x480x75Hz) */
+        {211,75,1024,625,1688,1066 }, /* ; 05 (800x600x75Hz) */
+        {211,120,1280,798,1688,1066}, /* ; 06 (1024x768x75Hz) */
+        {1,1,1688,1066,1688,1066   }  /* ; 07 (1280x1024x75Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_CetLCD1280x1024x75Data[]=
+{
+        {1,1,1688,1066,1688,1066}, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {1,1,1688,1066,1688,1066}, /* ; 01 (320x350,640x350) */
+        {1,1,1688,1066,1688,1066}, /* ; 02 (360x400,720x400) */
+        {1,1,1688,1066,1688,1066}, /* ; 03 (720x350) */
+        {1,1,1688,1066,1688,1066}, /* ; 04 (640x480x75Hz) */
+        {1,1,1688,1066,1688,1066}, /* ; 05 (800x600x75Hz) */
+        {1,1,1688,1066,1688,1066}, /* ; 06 (1024x768x75Hz) */
+        {1,1,1688,1066,1688,1066}  /* ; 07 (1280x1024x75Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_NoScalingDatax75[]=
+{
+        {1,1,800,449,800,449    }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {1,1,800,449,800,449    }, /* ; 01 (320x350,640x350) */
+        {1,1,900,449,900,449    }, /* ; 02 (360x400,720x400) */
+        {1,1,900,449,900,449    }, /* ; 03 (720x350) */
+        {1,1,840,500,840,500    }, /* ; 04 (640x480x75Hz) */
+        {1,1,1056,625,1056,625  }, /* ; 05 (800x600x75Hz) */
+        {1,1,1312,800,1312,800  }, /* ; 06 (1024x768x75Hz) */
+        {1,1,1688,1066,1688,1066}, /* ; 07 (1280x1024x75Hz) */
+        {1,1,1688,1066,1688,1066}, /* ; 08 (1400x1050x75Hz) ;;[ycchen] 12/19/02 */
+        {1,1,2160,1250,2160,1250}, /* ; 09 (1600x1200x75Hz) */
+        {1,1,1688,806,1688,806  }  /* ; 0A (1280x768x75Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_ExtLCDDes1024x768Data[]=
+{
+   {  9,1057,0, 771  }, /* ; 00 (320x200,320x400,640x200,640x400) */
+   {  9,1057,0, 771  }, /* ; 01 (320x350,640x350) */
+   {  9,1057,0, 771  }, /* ; 02 (360x400,720x400) */
+   {  9,1057,0, 771  }, /* ; 03 (720x350) */
+   {  9,1057,0, 771  }, /* ; 04 (640x480x60Hz) */
+   {  9,1057,0, 771  }, /* ; 05 (800x600x60Hz) */
+   {  9,1057,805, 770  }  /* ; 06 (1024x768x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_StLCDDes1024x768Data[]=
+{
+        { 9,1057,737,703   }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        { 9,1057,686,651   }, /* ; 01 (320x350,640x350) */
+        { 9,1057,737,703   }, /* ; 02 (360x400,720x400) */
+        { 9,1057,686,651   }, /* ; 03 (720x350) */
+        { 9,1057,776,741   }, /* ; 04 (640x480x60Hz) */
+        { 9,1057, 0 ,771   }, /* ; 05 (800x600x60Hz) */
+        { 9,1057,805,770   }  /* ; 06 (1024x768x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_CetLCDDes1024x768Data[]=
+{
+       	{      1152,856,622,587   }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {      1152,856,597,562   }, /* ; 01 (320x350,640x350) */
+        {      1152,856,622,587   }, /* ; 02 (360x400,720x400) */
+        {      1152,856,597,562   }, /* ; 03 (720x350) */
+        {      1152,856,662,627   }, /* ; 04 (640x480x60Hz) */
+        {      1232,936,722,687   }, /* ; 05 (800x600x60Hz) */
+        {      0,1048,805,770   }  /* ; 06 (1024x768x60Hz) */
+};
+
+XGI330_LCDDataDesStruct XGI_ExtLCDDLDes1280x1024Data[]=
+{
+        {      18,1346,981,940     },/* 00 (320x200,320x400,640x200,640x400) */
+        {      18,1346,926,865     },/* 01 (320x350,640x350) */
+        {      18,1346,981,940     },/* 02 (360x400,720x400) */
+        {      18,1346,926,865     },/* 03 (720x350) */
+        {      18,1346,0,1025     },/* 04 (640x480x60Hz) */
+        {      18,1346,0,1025     },/* 05 (800x600x60Hz) */
+        {      18,1346,1065,1024     },/* 06 (1024x768x60Hz) */
+        {      18,1346,1065,1024     }/* 07 (1280x1024x60Hz) */
+};
+
+XGI330_LCDDataDesStruct XGI_StLCDDLDes1280x1024Data[]=
+{
+        {      18,1346,970,907     },/* 00 (320x200,320x400,640x200,640x400) */
+        {      18,1346,917,854     },/* 01 (320x350,640x350) */
+        {      18,1346,970,907     },/* 02 (360x400,720x400) */
+        {      18,1346,917,854     },/* 03 (720x350) */
+        {      18,1346,0,1025     },/* 04 (640x480x60Hz) */
+        {      18,1346,0,1025     },/* 05 (800x600x60Hz) */
+        {      18,1346,1065,1024     },/* 06 (1024x768x60Hz) */
+        {      18,1346,1065,1024     }/* 07 (1280x1024x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_CetLCDDLDes1280x1024Data[]=
+{
+        {      1368,1008,752,711    }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      1368,1008,729,688    }, /* 01 (320x350,640x350) */
+        {      1368,1008,752,711    }, /* 02 (360x400,720x400) */
+    	{      1368,1008,729,688    }, /* 03 (720x350) */
+        {      1368,1008,794,753    }, /* 04 (640x480x60Hz) */
+        {      1448,1068,854,813    }, /* 05 (800x600x60Hz) */
+        {      1560,1200,938,897    }, /* 06 (1024x768x60Hz) */
+        {      18,1346,1065,1024    }  /* 07 (1280x1024x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_ExtLCDDes1280x1024Data[]=
+{
+        {      9,1337,981,940    }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {      9,1337,926,884    }, /* ; 01 (320x350,640x350) alan, 2003/09/30 */
+        {      9,1337,981,940    }, /* ; 02 (360x400,720x400) */
+        {      9,1337,926,884    }, /* ; 03 (720x350) alan, 2003/09/30 */
+        {      9,1337,0,1025    }, /* ; 04 (640x480x60Hz) */
+        {      9,1337,0,1025    }, /* ; 05 (800x600x60Hz) */
+        {      9,1337,1065,1024    }, /* ; 06 (1024x768x60Hz) */
+        {      9,1337,1065,1024    }  /* ; 07 (1280x1024x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_StLCDDes1280x1024Data[]=
+{
+        {      9,1337,970,907    }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {      9,1337,917,854    }, /* ; 01 (320x350,640x350) */
+        {      9,1337,970,907    }, /* ; 02 (360x400,720x400) */
+        {      9,1337,917,854    }, /* ; 03 (720x350) */
+        {      9,1337,0,1025    }, /* ; 04 (640x480x60Hz) */
+        {      9,1337,0,1025    }, /* ; 05 (800x600x60Hz) */
+        {      9,1337,1065,1024    }, /* ; 06 (1024x768x60Hz) */
+        {      9,1337,1065,1024    }  /* ; 07 (1280x1024x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_CetLCDDes1280x1024Data[]=
+{
+        {      1368,1008,752,711    }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      1368,1008,729,688    }, /* 01 (320x350,640x350) */
+        {      1368,1008,752,711    }, /* 02 (360x400,720x400) */
+    	{      1368,1008,729,688    }, /* 03 (720x350) */
+        {      1368,1008,794,753    }, /* 04 (640x480x60Hz) */
+        {      1448,1068,854,813    }, /* 05 (800x600x60Hz) */
+        {      1560,1200,938,897    }, /* 06 (1024x768x60Hz) */
+        {      9,1337,1065,1024    }  /* 07 (1280x1024x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_StLCDDLDes1400x1050Data[]=
+{
+        {      18,1464,0,1051    }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      18,1464,0,1051    }, /* 01 (320x350,640x350) */
+        {      18,1464,0,1051    }, /* 02 (360x400,720x400) */
+        {      18,1464,0,1051    }, /* 03 (720x350) */
+        {      18,1464,0,1051    }, /* 04 (640x480x60Hz) */
+        {      18,1464,0,1051    }, /* 05 (800x600x60Hz) */
+        {      18,1464,0,1051    }, /* 06 (1024x768x60Hz) */
+        {      1646,1406,1053,1038    }, /* 07 (1280x1024x60Hz) */
+        {      18,1464,0,1051    }  /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_ExtLCDDLDes1400x1050Data[]=
+{
+        {      18,1464,0,1051    }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      18,1464,0,1051    }, /* 01 (320x350,640x350) */
+        {      18,1464,0,1051    }, /* 02 (360x400,720x400) */
+        {      18,1464,0,1051    }, /* 03 (720x350) */
+        {      18,1464,0,1051    }, /* 04 (640x480x60Hz) */
+        {      18,1464,0,1051    }, /* 05 (800x600x60Hz) */
+        {      18,1464,0,1051    }, /* 06 (1024x768x60Hz) */
+        {      1646,1406,1053,1038    }, /* 07 (1280x1024x60Hz) */
+        {      18,1464,0,1051    }  /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_StLCDDes1400x1050Data[]=
+{
+        {      9,1455,0,1051     },/* 00 (320x200,320x400,640x200,640x400) */
+        {      9,1455,0,1051     },/* 01 (320x350,640x350) */
+        {      9,1455,0,1051     },/* 02 (360x400,720x400) */
+        {      9,1455,0,1051     },/* 03 (720x350) */
+        {      9,1455,0,1051     },/* 04 (640x480x60Hz) */
+        {      9,1455,0,1051     },/* 05 (800x600x60Hz) */
+        {      9,1455,0,1051     },/* 06 (1024x768x60Hz) */
+        {      1637,1397,1053,1038     },/* 07 (1280x1024x60Hz) */
+        {      9,1455,0,1051     } /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_ExtLCDDes1400x1050Data[]=
+{
+        {      9,1455,0,1051     },/* 00 (320x200,320x400,640x200,640x400) */
+        {      9,1455,0,1051     },/* 01 (320x350,640x350) */
+        {      9,1455,0,1051     },/* 02 (360x400,720x400) */
+        {      9,1455,0,1051     },/* 03 (720x350) */
+        {      9,1455,0,1051     },/* 04 (640x480x60Hz) */
+        {      9,1455,0,1051     },/* 05 (800x600x60Hz) */
+        {      9,1455,0,1051     },/* 06 (1024x768x60Hz) */
+        {      1637,1397,1053,1038     },/* 07 (1280x1024x60Hz) */
+        {      9,1455,0,1051     } /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_CetLCDDes1400x1050Data[]=
+{
+        {      1308,1068,781,766    }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      1308,1068,781,766    }, /* 01 (320x350,640x350) */
+        {      1308,1068,781,766    }, /* 02 (360x400,720x400) */
+        {      1308,1068,781,766    }, /* 03 (720x350) */
+        {      1308,1068,781,766    }, /* 04 (640x480x60Hz) */
+        {      1388,1148,841,826    }, /* 05 (800x600x60Hz) */
+        {      1490,1250,925,910    }, /* 06 (1024x768x60Hz) */
+        {      1646,1406,1053,1038    }, /* 07 (1280x1024x60Hz) */
+        {      18,1464,0,1051    } /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_CetLCDDes1400x1050Data2[]=
+{
+        {      0,1448,0,1051    }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      0,1448,0,1051    }, /* 01 (320x350,640x350) */
+        {      0,1448,0,1051    }, /* 02 (360x400,720x400) */
+        {      0,1448,0,1051    }, /* 03 (720x350) */
+        {      0,1448,0,1051    }  /* 04 (640x480x60Hz) */
+};
+
+
+
+XGI330_LCDDataDesStruct  XGI_ExtLCDDLDes1600x1200Data[]=
+{
+	{      18,1682,0,1201    }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      18,1682,0,1201    }, /* 01 (320x350,640x350) */
+        {      18,1682,0,1201    }, /* 02 (360x400,720x400) */
+        {      18,1682,0,1201    }, /* 03 (720x350) */
+        {      18,1682,0,1201    }, /* 04 (640x480x60Hz) */
+        {      18,1682,0,1201    }, /* 05 (800x600x60Hz) */
+        {      18,1682,0,1201    }, /* 06 (1024x768x60Hz) */
+        {      18,1682,0,1201    }, /* 07 (1280x1024x60Hz) */
+        {      18,1682,0,1201    }, /* 08 (1400x1050x60Hz) */
+        {      18,1682,0,1201    }  /* 09 (1600x1200x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_StLCDDLDes1600x1200Data[]=
+{
+        {      18,1682,1150,1101    }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      18,1682,1083,1034    }, /* 01 (320x350,640x350) */
+        {      18,1682,1150,1101    }, /* 02 (360x400,720x400) */
+        {      18,1682,1083,1034    }, /* 03 (720x350) */
+        {      18,1682,0,1201    }, /* 04 (640x480x60Hz) */
+        {      18,1682,0,1201    }, /* 05 (800x600x60Hz) */
+        {      18,1682,0,1201    }, /* 06 (1024x768x60Hz) */
+        {      18,1682,1232,1183    }, /* 07 (1280x1024x60Hz) */
+        {      18,1682,0,1201    }, /* 08 (1400x1050x60Hz) */
+        {      18,1682,0,1201    } /* 09 (1600x1200x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_ExtLCDDes1600x1200Data[]=
+{
+        {      9,1673,0,1201     },/* 00 (320x200,320x400,640x200,640x400) */
+        {      9,1673,0,1201     },/* 01 (320x350,640x350) */
+        {      9,1673,0,1201     },/* 02 (360x400,720x400) */
+        {      9,1673,0,1201     },/* 03 (720x350) */
+        {      9,1673,0,1201     },/* 04 (640x480x60Hz) */
+        {      9,1673,0,1201     },/* 05 (800x600x60Hz) */
+        {      9,1673,0,1201     },/* 06 (1024x768x60Hz) */
+        {      9,1673,0,1201     },/* 07 (1280x1024x60Hz) */
+        {      9,1673,0,1201     },/* 08 (1400x1050x60Hz) */
+        {      9,1673,0,1201     } /* 09 (1600x1200x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_StLCDDes1600x1200Data[]=
+{
+	{      9,1673,1150,1101     },/* 00 (320x200,320x400,640x200,640x400) */
+        {      9,1673,1083,1034     },/* 01 (320x350,640x350) */
+        {      9,1673,1150,1101     },/* 02 (360x400,720x400) */
+        {      9,1673,1083,1034     },/* 03 (720x350) */
+        {      9,1673,0,1201     },/* 04 (640x480x60Hz) */
+        {      9,1673,0,1201     },/* 05 (800x600x60Hz) */
+        {      9,1673,0,1201     },/* 06 (1024x768x60Hz) */
+        {      9,1673,1232,1183     },/* 07 (1280x1024x60Hz) */
+        {      9,1673,0,1201     },/* 08 (1400x1050x60Hz) */
+        {      9,1673,0,1201     } /* 09 (1600x1200x60Hz) */
+};
+
+XGI330_LCDDataDesStruct2  XGI_NoScalingDesData[]=
+{
+        {     9,657,448,405,96,2  }, /* 00 (320x200,320x400,640x200,640x400) */
+        {     9,657,448,355,96,2  }, /* 01 (320x350,640x350) */
+        {     9,657,448,405,96,2  }, /* 02 (360x400,720x400) */
+        {     9,657,448,355,96,2  }, /* 03 (720x350) */
+        {     9,657,1,483,96,2  }, /* 04 (640x480x60Hz) */
+        {     9,849,627,600,128,4  }, /* 05 (800x600x60Hz) */
+        {     9,1057,805,770,0136,6  }, /* 06 (1024x768x60Hz) */
+        {     9,1337,0,1025,112,3  }, /* 07 (1280x1024x60Hz) */
+        {     9,1457,0,1051,112,3  }, /* 08 (1400x1050x60Hz) }, //;[ycchen] 12/19/02 */
+        {     9,1673,0,1201,192,3  }, /* 09 (1600x1200x60Hz) */
+        {     9,1337,0,771,112,6  }  /* 0A (1280x768x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_ExtLCDDes1024x768x75Data[]=		/* ;;1024x768x75Hz */
+{
+        {9,1049,0,769},    /* ; 00 (320x200,320x400,640x200,640x400) */
+        {9,1049,0,769},    /* ; 01 (320x350,640x350) */
+        {9,1049,0,769},    /* ; 02 (360x400,720x400) */
+        {9,1049,0,769},    /* ; 03 (720x350) */
+        {9,1049,0,769},    /* ; 04 (640x480x75Hz) */
+        {9,1049,0,769},    /* ; 05 (800x600x75Hz) */
+        {9,1049,0,769}     /* ; 06 (1024x768x75Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_StLCDDes1024x768x75Data[]=
+{
+        {9,1049,0,769},    /* ; 00 (320x200,320x400,640x200,640x400) */
+        {9,1049,0,769},    /* ; 01 (320x350,640x350) */
+        {9,1049,0,769},    /* ; 02 (360x400,720x400) */
+        {9,1049,0,769},    /* ; 03 (720x350) */
+        {9,1049,0,769},    /* ; 04 (640x480x75Hz) */
+        {9,1049,0,769},    /* ; 05 (800x600x75Hz) */
+        {9,1049,0,769}     /* ; 06 (1024x768x75Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_CetLCDDes1024x768x75Data[]=	/* ;;1024x768x75Hz */
+{
+        {1152,856,622,587},     /* ; 00 (320x200,320x400,640x200,640x400) */
+        {1152,856,597,562},     /* ; 01 (320x350,640x350) */
+        {1192,896,622,587},     /* ; 02 (360x400,720x400) */
+        {1192,896,597,562},     /* ; 03 (720x350) */
+        {1129,857,656,625},     /* ; 04 (640x480x75Hz) */
+        {1209,937,716,685},     /* ; 05 (800x600x75Hz) */
+        {9,1049,0,769} 	   	/* ; 06 (1024x768x75Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_ExtLCDDLDes1280x1024x75Data[]=         /* ;;1280x1024x75Hz */
+{
+        {18,1314,0,1025     },/* ; 00 (320x200,320x400,640x200,640x400) */
+        {18,1314,0,1025     },/* ; 01 (320x350,640x350) */
+        {18,1314,0,1025     },/* ; 02 (360x400,720x400) */
+        {18,1314,0,1025     },/* ; 03 (720x350) */
+        {18,1314,0,1025     },/* ; 04 (640x480x60Hz) */
+        {18,1314,0,1025     },/* ; 05 (800x600x60Hz) */
+        {18,1314,0,1025     },/* ; 06 (1024x768x60Hz) */
+        {18,1314,0,1025     }/* ; 07 (1280x1024x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_StLCDDLDes1280x1024x75Data[]=
+{
+        {18,1314,0,1025     },/* ; 00 (320x200,320x400,640x200,640x400) */
+        {18,1314,0,1025     },/* ; 01 (320x350,640x350) */
+        {18,1314,0,1025     },/* ; 02 (360x400,720x400) */
+        {18,1314,0,1025     },/* ; 03 (720x350) */
+        {18,1314,0,1025     },/* ; 04 (640x480x60Hz) */
+        {18,1314,0,1025     },/* ; 05 (800x600x60Hz) */
+        {18,1314,0,1025     },/* ; 06 (1024x768x60Hz) */
+        {18,1314,0,1025     }/* ; 07 (1280x1024x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_CetLCDDLDes1280x1024x75Data[]=	/* 1280x1024x75Hz */
+{
+        {1368,1008,752,711},    /* ; 00 (320x200,320x400,640x200,640x400) */
+        {1368,1008,729,688},    /* ; 01 (320x350,640x350) */
+        {1408,1048,752,711},    /* ; 02 (360x400,720x400) */
+        {1408,1048,729,688},    /* ; 03 (720x350) */
+        {1377,985,794,753},    /* ; 04 (640x480x75Hz) */
+        {1457,1065,854,813},    /* ; 05 (800x600x75Hz) */
+        {1569,1177,938,897},    /* ; 06 (1024x768x75Hz) */
+        {18,1314,0,1025}     	  /* ; 07 (1280x1024x75Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_ExtLCDDes1280x1024x75Data[]=         /* ;;1280x1024x75Hz */
+{
+	{9,1305,0,1025},/* ; 00 (320x200,320x400,640x200,640x400) */
+        {9,1305,0,1025},/* ; 01 (320x350,640x350) */
+        {9,1305,0,1025},/* ; 02 (360x400,720x400) */
+        {9,1305,0,1025},/* ; 03 (720x350) */
+        {9,1305,0,1025},/* ; 04 (640x480x60Hz) */
+        {9,1305,0,1025},/* ; 05 (800x600x60Hz) */
+        {9,1305,0,1025},/* ; 06 (1024x768x60Hz) */
+        {9,1305,0,1025} /* ; 07 (1280x1024x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_StLCDDes1280x1024x75Data[]=
+{
+	{9,1305,0,1025},/* ; 00 (320x200,320x400,640x200,640x400) */
+        {9,1305,0,1025},/* ; 01 (320x350,640x350) */
+        {9,1305,0,1025},/* ; 02 (360x400,720x400) */
+        {9,1305,0,1025},/* ; 03 (720x350) */
+        {9,1305,0,1025},/* ; 04 (640x480x60Hz) */
+        {9,1305,0,1025},/* ; 05 (800x600x60Hz) */
+        {9,1305,0,1025},/* ; 06 (1024x768x60Hz) */
+        {9,1305,0,1025} /* ; 07 (1280x1024x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_CetLCDDes1280x1024x75Data[]=	/* 1280x1024x75Hz */
+{
+        {1368,1008,752,711},    /* ; 00 (320x200,320x400,640x200,640x400) */
+        {1368,1008,729,688},    /* ; 01 (320x350,640x350) */
+        {1408,1048,752,711},    /* ; 02 (360x400,720x400) */
+        {1408,1048,729,688},    /* ; 03 (720x350) */
+        {1377,985,794,753},    /* ; 04 (640x480x75Hz) */
+        {1457,1065,854,813},    /* ; 05 (800x600x75Hz) */
+        {1569,1177,938,897},    /* ; 06 (1024x768x75Hz) */
+        {9,1305,0,1025}     	  /* ; 07 (1280x1024x75Hz) */
+};
+
+XGI330_LCDDataDesStruct2 XGI_NoScalingDesDatax75[]= /* Scaling LCD 75Hz */
+{
+	{9,657,448,405,96,2},   /* ; 00 (320x200,320x400,640x200,640x400) */
+        {9,657,448,355,96,2},   /* ; 01 (320x350,640x350) */
+        {9,738,448,405,108,2},   /* ; 02 (360x400,720x400) */
+        {9,738,448,355,108,2},   /* ; 03 (720x350) */
+        {9,665,0,481,64,3},   /* ; 04 (640x480x75Hz) */
+        {9,825,0,601,80,3},   /* ; 05 (800x600x75Hz) */
+        {9,1049,0,769,96,3},   /* ; 06 (1024x768x75Hz) */
+        {9,1305,0,1025,144,3},   /* ; 07 (1280x1024x75Hz) */
+        {9,1457,0,1051,112,3},   /* ; 08 (1400x1050x60Hz) ;;[ycchen] 12/19/02 */
+        {9,1673,0,1201,192,3},   /* ; 09 (1600x1200x75Hz) */
+        {9,1337,0,771,112,6}    /* ; 0A (1280x768x60Hz) */
+};
+
+XGI330_TVDataStruct  XGI_StPALData[]=
+{
+ {    1,   1, 864, 525,1270, 400, 100,   0, 760},
+ {    1,   1, 864, 525,1270, 350, 100,   0, 760},
+ {    1,   1, 864, 525,1270, 400,   0,   0, 720},
+ {    1,   1, 864, 525,1270, 350,   0,   0, 720},
+ {    1,   1, 864, 525,1270, 480,  50,   0, 760},
+ {    1,   1, 864, 525,1270, 600,  50,   0,   0}
+};
+
+XGI330_TVDataStruct  XGI_ExtPALData[]=
+{
+ {    2,   1,1080, 463,1270, 500,  50,   0,  50},
+ {   15,   7,1152, 413,1270, 500,  50,   0,  50},
+ {    2,   1,1080, 463,1270, 500,  50,   0,  50},
+ {   15,   7,1152, 413,1270, 500,  50,   0,  50},
+ {    2,   1, 900, 543,1270, 500,   0,   0,  50},
+ {    4,   3,1080, 663,1270, 500, 438,   0, 438},
+ {    1,   1,1125, 831,1270, 500, 686,   0, 686},     /*301b*/
+ {    3,   2,1080, 619,1270, 540, 438,   0, 438}
+};
+
+XGI330_TVDataStruct  XGI_StNTSCData[]=
+{
+ {    1,   1, 858, 525,1270, 400,  50,   0, 760},
+ {    1,   1, 858, 525,1270, 350,  50,   0, 640},
+ {    1,   1, 858, 525,1270, 400,   0,   0, 720},
+ {    1,   1, 858, 525,1270, 350,   0,   0, 720},
+ {    1,   1, 858, 525,1270, 480,   0,   0, 760}
+};
+
+XGI330_TVDataStruct  XGI_ExtNTSCData[]=
+{
+ {    9,  5, 1001, 453,1270, 420, 171,   0, 171},
+ {   12,  5,  858, 403,1270, 420, 171,   0, 171},
+ {    9,  5, 1001, 453,1270, 420, 171,   0, 171},
+ {   12,  5,  858, 403,1270, 420, 171,   0, 171},
+ {  143,  80, 836, 523,1270, 420, 224,   0,   0},
+ {  143, 120,1008, 643,1270, 420,   0,   1,   0},
+ {   1,    1,1120, 821,1516, 420,   0,   1,   0}, /*301b*/
+ {    2,   1, 858, 503,1584, 480,   0,   1,   0},
+ {    3,   2,1001, 533,1270, 420,   0,   0,   0}
+};
+
+XGI330_TVDataStruct  XGI_St1HiTVData[]=
+{
+    	{        1,1,892,563,690,800,0,0,0               }, /* 00 (320x200,320x400,640x200,640x400) */
+        {        1,1,892,563,690,700,0,0,0               }, /* 01 (320x350,640x350) */
+        {        1,1,1000,563,785,800,0,0,0              }, /* 02 (360x400,720x400) */
+        {        1,1,1000,563,785,700,0,0,0              }, /* 03 (720x350) */
+        {        1,1,892,563,690,960,0,0,0               }, /* 04 (320x240,640x480) */
+        {        8,5,1050,683,1648,960,0x150,1,0         }  /* 05 (400x300,800x600) */
+};
+
+XGI330_TVDataStruct  XGI_St2HiTVData[]=
+{
+        {        3,1,840,483,1648,960,0x032,0,0          }, /* 00 (320x200,320x400,640x200,640x400) */
+        {        1,1,892,563,690,700,0,0,0               }, /* 01 (320x350,640x350) */
+        {        3,1,840,483,1648,960,0x032,0,0          }, /* 02 (360x400,720x400) */
+        {        1,1,1000,563,785,700,0,0,0              }, /* 03 (720x350) */
+        {        5,2,840,563,1648,960,0x08D,1,0          }, /* 04 (320x240,640x480) */
+        {        8,5,1050,683,1648,960,0x17C,1,0         }  /* 05 (400x300,800x600) */
+
+};
+
+XGI330_TVDataStruct  XGI_ExtHiTVData[]=
+{
+        {        6,1,840,563,1632,960,0,0,0              }, /* 00 (320x200,320x400,640x200,640x400) */
+        {        3,1,960,563,1632,960,0,0,0              }, /* 01 (320x350,640x350) */
+        {        3,1,840,483,1632,960,0,0,0              }, /* 02 (360x400,720x400) */
+        {        3,1,960,563,1632,960,0,0,0              }, /* 03 (720x350) */
+        {        5,1,840,563,1648,960,0x166,1,0          }, /* 04 (320x240,640x480) */
+        {        16,5,1050,683,1648,960,0x143,1,0        }, /* 05 (400x300,800x600) */
+        {        25,12,1260,851,1648,960,0x032,0,0       }, /* 06 (512x384,1024x768) */
+        {        5,4,1575,1124,1648,960,0x128,0,0        }, /* 07 (1280x1024) */
+        {        4,1,1050,563,1548,960,0x143,1,0         }, /* 08 (800x480) */
+        {        5,2,1400,659,1648,960,0x032,0,0         }, /* 09 (1024x576) */
+        {        8,5,1750,803,1648,960,0x128,0,0         }  /* 0A (1280x720) */
+
+};
+
+XGI330_TVDataStruct  XGI_ExtYPbPr525iData[]=
+{
+ {    9,  5, 1001, 453,1270, 420, 171,   0, 171},
+ {   12,  5,  858, 403,1270, 420, 171,   0, 171},
+ {    9,  5, 1001, 453,1270, 420, 171,   0, 171},
+ {   12,  5,  858, 403,1270, 420, 171,   0, 171},
+ {  143,  80, 836, 523,1250, 420, 224,   0,   0},
+ {  143, 120,1008, 643,1250, 420,   0,   1,   0},
+ {   1,    1,1120, 821,1516, 420,   0,   1,   0}, /*301b*/
+ {    2,   1, 858, 503,1584, 480,   0,   1,   0},
+ {    3,   2,1001, 533,1250, 420,   0,   0,   0}
+};
+
+XGI330_TVDataStruct  XGI_StYPbPr525iData[]=
+{
+ {    1,   1, 858, 525,1270, 400,  50,   0, 760},
+ {    1,   1, 858, 525,1270, 350,  50,   0, 640},
+ {    1,   1, 858, 525,1270, 400,   0,   0, 720},
+ {    1,   1, 858, 525,1270, 350,   0,   0, 720},
+ {    1,   1, 858, 525,1270, 480,   0,   0, 760},
+};
+
+XGI330_TVDataStruct  XGI_ExtYPbPr525pData[]=
+{
+ {    9,  5, 1001, 453,1270, 420, 171,   0, 171},
+ {   12,  5,  858, 403,1270, 420, 171,   0, 171},
+ {    9,  5, 1001, 453,1270, 420, 171,   0, 171},
+ {   12,  5,  858, 403,1270, 420, 171,   0, 171},
+ {  143,  80, 836, 523,1270, 420, 224,   0,   0},
+ {  143, 120,1008, 643,1270, 420,   0,   1,   0},
+ {   1,    1,1120, 821,1516, 420,   0,   1,   0}, /*301b*/
+ {    2,   1, 858, 503,1584, 480,   0,   1,   0},
+ {    3,   2,1001, 533,1270, 420,   0,   0,   0}
+ };
+
+XGI330_TVDataStruct  XGI_StYPbPr525pData[]=
+{
+ {    1,   1,1716, 525,1270, 400,  50,   0, 760},
+ {    1,   1,1716, 525,1270, 350,  50,   0, 640},
+ {    1,   1,1716, 525,1270, 400,   0,   0, 720},
+ {    1,   1,1716, 525,1270, 350,   0,   0, 720},
+ {    1,   1,1716, 525,1270, 480,   0,   0, 760},
+};
+
+XGI330_TVDataStruct  XGI_ExtYPbPr750pData[]=
+{
+ {    3,   1, 935, 470,1130, 680,  50,   0,   0},       /* 00 (320x200,320x400,640x200,640x400) */
+ {   24,   7, 935, 420,1130, 680,  50,   0,   0},       /* 01 (320x350,640x350) */
+ {    3,   1, 935, 470,1130, 680,  50,   0,   0},       /* 02 (360x400,720x400) */
+ {   24,   7, 935, 420,1130, 680,  50,   0,   0},       /* 03 (720x350) */
+ {    2,   1,1100, 590,1130, 640,  50,   0,   0},       /* 04 (320x240,640x480) */
+ {    3,   2,1210, 690,1130, 660,  50,   0,   0},       /* 05 (400x300,800x600) */
+ {    1,   1,1375, 878,1130, 640, 638,   0,   0},       /* 06 (1024x768) */
+ {    2,   1, 858, 503,1130, 480,   0,   1,   0},        /* 07 (720x480) */
+ {    5,   4,1815, 570,1130, 660,  50,   0,   0},
+ {    5,   3,1100, 686,1130, 640,  50,   1,   0},
+ {   10,   9,1320, 830,1130, 640,  50,   0,   0}
+};
+
+XGI330_TVDataStruct  XGI_StYPbPr750pData[]=
+{
+ {    1,   1,1650, 750,1280, 400,  50,   0, 760},
+ {    1,   1,1650, 750,1280, 350,  50,   0, 640},
+ {    1,   1,1650, 750,1280, 400,   0,   0, 720},
+ {    1,   1,1650, 750,1280, 350,   0,   0, 720},
+ {    1,   1,1650, 750,1280, 480,   0,   0, 760},
+};
+
+UCHAR XGI330_NTSCTiming[] = {
+  0x17,0x1d,0x03,0x09,0x05,0x06,0x0c,0x0c,
+  0x94,0x49,0x01,0x0a,0x06,0x0d,0x04,0x0a,
+  0x06,0x14,0x0d,0x04,0x0a,0x00,0x85,0x1b,
+  0x0c,0x50,0x00,0x97,0x00,0xda,0x4a,0x17,
+  0x7d,0x05,0x4b,0x00,0x00,0xe2,0x00,0x02,
+  0x03,0x0a,0x65,0x9d,0x08,0x92,0x8f,0x40,
+  0x60,0x80,0x14,0x90,0x8c,0x60,0x14,0x50,
+  0x00,0x40,0x44,0x00,0xdb,0x02,0x3b,0x00};
+
+UCHAR XGI330_PALTiming[] = {
+  0x21,0x5A,0x35,0x6e,0x04,0x38,0x3d,0x70,
+  0x94,0x49,0x01,0x12,0x06,0x3e,0x35,0x6d,
+  0x06,0x14,0x3e,0x35,0x6d,0x00,0x45,0x2b,
+  0x70,0x50,0x00,0x9b,0x00,0xd9,0x5d,0x17,
+  0x7d,0x05,0x45,0x00,0x00,0xe8,0x00,0x02,
+  0x0d,0x00,0x68,0xb0,0x0b,0x92,0x8f,0x40,
+  0x60,0x80,0x14,0x90,0x8c,0x60,0x14,0x63,
+  0x00,0x40,0x3e,0x00,0xe1,0x02,0x28,0x00};
+
+UCHAR XGI330_HiTVExtTiming[] =
+{
+      0x2D,0x60,0x2C,0x5F,0x08,0x31,0x3A,0x64,
+      0x28,0x02,0x01,0x3D,0x06,0x3E,0x35,0x6D,
+      0x06,0x14,0x3E,0x35,0x6D,0x00,0xC5,0x3F,
+      0x64,0x90,0x33,0x8C,0x18,0x36,0x3E,0x13,
+      0x2A,0xDE,0x2A,0x44,0x40,0x2A,0x44,0x40,
+      0x8E,0x8E,0x82,0x07,0x0B,
+      0x92,0x0F,0x40,0x60,0x80,0x14,0x90,0x8C,
+      0x60,0x14,0x3D,0x63,0x4F,
+      0x27,0x00,0xfc,0xff,0x6a,0x00
+
+};
+
+UCHAR XGI330_HiTVSt1Timing[] =
+{
+      0x32,0x65,0x2C,0x5F,0x08,0x31,0x3A,0x65,
+      0x28,0x02,0x01,0x3D,0x06,0x3E,0x35,0x6D,
+      0x06,0x14,0x3E,0x35,0x6D,0x00,0xC5,0x3F,
+      0x65,0x90,0x7B,0xA8,0x03,0xF0,0x87,0x03,
+      0x11,0x15,0x11,0xCF,0x10,0x11,0xCF,0x10,
+      0x35,0x35,0x3B,0x69,0x1D,
+      0x92,0x0F,0x40,0x60,0x80,0x14,0x90,0x8C,
+      0x60,0x04,0x86,0xAF,0x5D,
+      0x0E,0x00,0xfc,0xff,0x2d,0x00
+};
+
+UCHAR XGI330_HiTVSt2Timing[] =
+{
+      0x32,0x65,0x2C,0x5F,0x08,0x31,0x3A,0x64,
+      0x28,0x02,0x01,0x3D,0x06,0x3E,0x35,0x6D,
+      0x06,0x14,0x3E,0x35,0x6D,0x00,0xC5,0x3F,
+      0x64,0x90,0x33,0x8C,0x18,0x36,0x3E,0x13,
+      0x2A,0xDE,0x2A,0x44,0x40,0x2A,0x44,0x40,
+      0x8E,0x8E,0x82,0x07,0x0B,
+      0x92,0x0F,0x40,0x60,0x80,0x14,0x90,0x8C,
+      0x60,0x14,0x3D,0x63,0x4F,
+      0x27,0x00,0xFC,0xff,0x6a,0x00
+};
+
+UCHAR XGI330_HiTVTextTiming[] =
+{
+      0x32,0x65,0x2C,0x5F,0x08,0x31,0x3A,0x65,
+      0x28,0x02,0x01,0x3D,0x06,0x3E,0x35,0x6D,
+      0x06,0x14,0x3E,0x35,0x6D,0x00,0xC5,0x3F,
+      0x65,0x90,0xE7,0xBC,0x03,0x0C,0x97,0x03,
+      0x14,0x78,0x14,0x08,0x20,0x14,0x08,0x20,
+      0xC8,0xC8,0x3B,0xD2,0x26,
+      0x92,0x0F,0x40,0x60,0x80,0x14,0x90,0x8C,
+      0x60,0x04,0x96,0x72,0x5C,
+      0x11,0x00,0xFC,0xFF,0x32,0x00
+};
+
+UCHAR XGI330_YPbPr750pTiming[] =
+{
+      0x30,0x1d,0xe8,0x09,0x09,0xed,0x0c,0x0c,
+      0x98,0x0a,0x01,0x0c,0x06,0x0d,0x04,0x0a,
+      0x06,0x14,0x0d,0x04,0x0a,0x00,0x85,0x3f,
+      0xed,0x50,0x70,0x9f,0x16,0x59,0x60,0x13,
+      0x27,0x0b,0x27,0xfc,0x30,0x27,0x1c,0xb0,
+      0x4b,0x4b,0x6f,0x2f,0x63,
+      0x92,0x0F,0x40,0x60,0x80,0x14,0x90,0x8C,
+      0x60,0x14,0x73,0x00,0x40,
+      0x11,0x00,0xfc,0xff,0x32,0x00
+};
+
+UCHAR XGI330_YPbPr525pTiming[] =
+{
+      0x3E,0x11,0x06,0x09,0x0b,0x0c,0x0c,0x0c,
+      0x98,0x0a,0x01,0x0d,0x06,0x0d,0x04,0x0a,
+      0x06,0x14,0x0d,0x04,0x0a,0x00,0x85,0x3f,
+      0x0c,0x50,0xb2,0x9f,0x16,0x59,0x4f,0x13,
+      0xad,0x11,0xad,0x1d,0x40,0x8a,0x3d,0xb8,
+      0x51,0x5e,0x60,0x49,0x7d,
+      0x92,0x0F,0x40,0x60,0x80,0x14,0x90,0x8C,
+      0x60,0x14,0x4B,0x43,0x41,
+      0x11,0x00,0xFC,0xFF,0x32,0x00
+};
+
+UCHAR XGI330_YPbPr525iTiming[] =
+{
+      0x1B,0x21,0x03,0x09,0x05,0x06,0x0C,0x0C,
+      0x94,0x49,0x01,0x0A,0x06,0x0D,0x04,0x0A,
+      0x06,0x14,0x0D,0x04,0x0A,0x00,0x85,0x1B,
+      0x0C,0x50,0x00,0x97,0x00,0xDA,0x4A,0x17,
+      0x7D,0x05,0x4B,0x00,0x00,0xE2,0x00,0x02,
+      0x03,0x0A,0x65,0x9D,0x08,
+      0x92,0x8F,0x40,0x60,0x80,0x14,0x90,0x8C,
+      0x60,0x14,0x4B,0x00,0x40,
+      0x44,0x00,0xDB,0x02,0x3B,0x00
+
+};
+
+UCHAR XGI330_HiTVGroup3Data[] =
+{
+      0x00,0x1A,0x22,0x63,0x62,0x22,0x08,0x5F,
+      0x05,0x21,0xB2,0xB2,0x55,0x77,0x2A,0xA6,
+      0x25,0x2F,0x47,0xFA,0xC8,0xFF,0x8E,0x20,
+      0x8C,0x6E,0x60,0x2E,0x58,0x48,0x72,0x44,
+      0x56,0x36,0x4F,0x6E,0x3F,0x80,0x00,0x80,
+      0x4F,0x7F,0x03,0xA8,0x7D,0x20,0x1A,0xA9,
+      0x14,0x05,0x03,0x7E,0x64,0x31,0x14,0x75,
+      0x18,0x05,0x18,0x05,0x4C,0xA8,0x01
+};
+
+UCHAR XGI330_HiTVGroup3Simu[] =
+{
+      0x00,0x1A,0x22,0x63,0x62,0x22,0x08,0x95,
+      0xDB,0x20,0xB8,0xB8,0x55,0x47,0x2A,0xA6,
+      0x25,0x2F,0x47,0xFA,0xC8,0xFF,0x8E,0x20,
+      0x8C,0x6E,0x60,0x15,0x26,0xD3,0xE4,0x11,
+      0x56,0x36,0x4F,0x6E,0x3F,0x80,0x00,0x80,
+      0x67,0x36,0x01,0x47,0x0E,0x10,0xBE,0xB4,
+      0x01,0x05,0x03,0x7E,0x65,0x31,0x14,0x75,
+      0x18,0x05,0x18,0x05,0x4C,0xA8,0x01
+};
+
+UCHAR XGI330_HiTVGroup3Text[] =
+{
+      0x00,0x1A,0x22,0x63,0x62,0x22,0x08,0xA7,
+      0xF5,0x20,0xCE,0xCE,0x55,0x47,0x2A,0xA6,
+      0x25,0x2F,0x47,0xFA,0xC8,0xFF,0x8E,0x20,
+      0x8C,0x6E,0x60,0x18,0x2C,0x0C,0x20,0x22,
+      0x56,0x36,0x4F,0x6E,0x3F,0x80,0x00,0x80,
+      0x93,0x3C,0x01,0x50,0x2F,0x10,0xF4,0xCA,
+      0x01,0x05,0x03,0x7E,0x65,0x31,0x14,0x75,
+      0x18,0x05,0x18,0x05,0x4C,0xA8,0x01
+};
+
+UCHAR XGI330_Ren525pGroup3[] =
+{
+  0x00,0x14,0x15,0x25,0x55,0x15,0x0b,0x13,
+  0xB1,0x41,0x62,0x62,0xFF,0xF4,0x45,0xa6,
+  0x25,0x2F,0x67,0xF6,0xbf,0xFF,0x8E,0x20,
+  0xAC,0xDA,0x60,0xFe,0x6A,0x9A,0x06,0x10,
+  0xd1,0x04,0x18,0x0a,0xFF,0x80,0x00,0x80,
+  0x3c,0x77,0x00,0xEF,0xE0,0x10,0xB0,0xE0,
+  0x10,0x4F,0x0F,0x0F,0x05,0x0F,0x08,0x6E,
+  0x1a,0x1F,0x25,0x2a,0x4C,0xAA,0x01
+};
+
+UCHAR XGI330_Ren750pGroup3[] =
+{
+  0x00,0x14,0x15,0x25,0x55,0x15,0x0b,0x7a,
+  0x54,0x41,0xE7,0xE7,0xFF,0xF4,0x45,0xa6,
+  0x25,0x2F,0x67,0xF6,0xbf,0xFF,0x8E,0x20,
+  0xAC,0x6A,0x60,0x2b,0x52,0xCD,0x61,0x10,
+  0x51,0x04,0x18,0x0a,0x1F,0x80,0x00,0x80,
+  0xFF,0xA4,0x04,0x2B,0x94,0x21,0x72,0x94,
+  0x26,0x05,0x01,0x0F,0xed,0x0F,0x0A,0x64,
+  0x18,0x1D,0x23,0x28,0x4C,0xAA,0x01
+};
+
+XGI_PanelDelayTblStruct XGI330_PanelDelayTbl[]=
+{
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}}
+};
+
+XGI330_LVDSDataStruct  XGI330_LVDS320x480Data_1[]=
+{
+ {848, 433,400,525},
+ {848, 389,400,525},
+ {848, 433,400,525},
+ {848, 389,400,525},
+ {848, 518,400, 525},
+ {1056, 628,400,525},
+ {400, 525,400,525},
+ {800, 449,1000, 644},
+ {800, 525,1000, 635}
+};
+
+XGI330_LVDSDataStruct  XGI330_LVDS800x600Data_1[]=
+{
+ {848, 433,1060, 629},
+ {848, 389,1060, 629},
+ {848, 433,1060, 629},
+ {848, 389,1060, 629},
+ {848, 518,1060, 629},
+ {1056, 628,1056, 628},
+ {1056, 628,1056, 628},
+ {800, 449,1000, 644},
+ {800, 525,1000, 635}
+};
+
+XGI330_LVDSDataStruct  XGI330_LVDS800x600Data_2[]=
+{
+ {1056, 628,1056, 628},
+ {1056, 628,1056, 628},
+ {1056, 628,1056, 628},
+ {1056, 628,1056, 628},
+ {1056, 628,1056, 628},
+ {1056, 628,1056, 628},
+ {1056, 628,1056, 628},
+ {800, 449,1000, 644},
+ {800, 525,1000, 635}
+};
+
+XGI330_LVDSDataStruct  XGI_LVDS1024x768Data_1[]=
+{
+ { 960 , 438 , 1344 , 806 } ,	/* 00 (320x200,320x400,640x200,640x400) */
+ { 960 , 388 , 1344 , 806 } ,	/* 01 (320x350,640x350) */
+ { 1040, 438 , 1344 , 806 } ,	/* 02 (360x400,720x400) */
+ { 1040, 388 , 1344 , 806 } ,	/* 03 (720x350) */
+ { 960 , 518 , 1344 , 806 } ,	/* 04 (320x240,640x480) */
+ {1120 , 638 , 1344 , 806 } ,	/* 05 (400x300,800x600) */
+ {1344 , 806 , 1344 , 806 }	/* 06 (512x384,1024x768) */
+};
+
+
+XGI330_LVDSDataStruct  XGI_LVDS1024x768Data_2[]=
+{
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {800, 449,1280, 801},
+ {800, 525,1280, 813}
+};
+
+XGI330_LVDSDataStruct  XGI_LVDS1280x1024Data_1[]=
+{
+ {1048, 442,1688, 1066},
+ {1048, 392,1688, 1066},
+ {1048, 442,1688, 1066},
+ {1048, 392,1688, 1066},
+ {1048, 522,1688, 1066},
+ {1208, 642,1688, 1066},
+ {1432, 810,1688, 1066},
+ {1688, 1066,1688, 1066}
+};
+
+XGI330_LVDSDataStruct  XGI_LVDS1280x1024Data_2[]=
+{
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {800, 449,1280, 801},
+ {800, 525,1280, 813}
+};
+/*
+XGI330_LVDSDataStruct  XGI_LVDS1280x768Data_1[]=
+{
+ {768,438,1408,806},
+ {768,388,1408,806},
+ {768,438,1408,806},
+ {768,388,1408,806},
+ {768,518,1408,806},
+ {928,638,1408,806},
+ {1408,806,1408,806},
+ {1408,806,1408,806},
+ {1408,806,1408,806}
+};
+
+XGI330_LVDSDataStruct  XGI_LVDS1280x768Data_2[]=
+{
+ {1408, 806,1408, 806},
+ {1408, 806,1408, 806},
+ {1408, 806,1408, 806},
+ {1408, 806,1408, 806},
+ {1408, 806,1408, 806},
+ {1408, 806,1408, 806},
+ {1408, 806,1408, 806},
+ {1408, 806,1408, 806},
+ {1408, 806,1408, 806}
+};
+
+XGI330_LVDSDataStruct  XGI_LVDS1280x768NData_1[]=
+{
+ {704, 438,1344, 806},
+ {704, 388,1344, 806},
+ {704, 438,1344, 806},
+ {704, 388,1344, 806},
+ {704, 518,1344, 806},
+ {864, 638,1344, 806},
+ {1088, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806}
+};
+
+XGI330_LVDSDataStruct  XGI_LVDS1280x768NData_2[]=
+{
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806}
+};
+
+XGI330_LVDSDataStruct  XGI_LVDS1280x768SData_1[]=
+{
+ {1048,438,1688,806},
+ {1048,388,1688,806},
+ {1148,438,1688,806},
+ {1148,388,1688,806},
+ {1048,518,1688,806},
+ {1208,638,1688,806},
+ {1432,806,1688,806},
+ {1688,806,1688,806},
+ {1688,806,1688,806}
+};
+
+XGI330_LVDSDataStruct  XGI_LVDS1280x768SData_2[]=
+{
+ {1688,806,1688,806},
+ {1688,806,1688,806},
+ {1688,806,1688,806},
+ {1688,806,1688,806},
+ {1688,806,1688,806},
+ {1688,806,1688,806},
+ {1688,806,1688,806},
+ {1688,806,1688,806},
+ {1688,806,1688,806}
+};
+*/
+XGI330_LVDSDataStruct  XGI_LVDS1400x1050Data_1[]=
+{
+ {928,416,1688,1066},
+ {928,366,1688,1066},
+ {928,416,1688,1066},
+ {928,366,1688,1066},
+ {928,496,1688,1066},
+ {1088,616,1688,1066},
+ {1312,784,1688,1066},
+ {1568,1040,1688,1066},
+ {1688,1066,1688,1066}
+};
+
+XGI330_LVDSDataStruct  XGI_LVDS1400x1050Data_2[]=
+{
+ {1688,1066,1688,1066},
+ {1688,1066,1688,1066},
+ {1688,1066,1688,1066},
+ {1688,1066,1688,1066},
+ {1688,1066,1688,1066},
+ {1688,1066,1688,1066},
+ {1688,1066,1688,1066},
+ {1688,1066,1688,1066},
+ {1688,1066,1688,1066}
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1600x1200Data_1[]=
+{      /* ;;[ycchen] 12/05/02 LCDHTxLCDVT=2048x1320 */
+        {        1088,520,2048,1320      },/* 00 (320x200,320x400,640x200,640x400) */
+        {        1088,470,2048,1320      },/* 01 (320x350,640x350) */
+        {        1088,520,2048,1320      },/* 02 (360x400,720x400) */
+        {        1088,470,2048,1320      },/* 03 (720x350) */
+        {        1088,600,2048,1320      },/* 04 (320x240,640x480) */
+        {        1248,720,2048,1320      },/* 05 (400x300,800x600) */
+        {        1472,888,2048,1320      },/* 06 (512x384,1024x768) */
+        {        1728,1144,2048,1320     },/* 07 (640x512,1280x1024) */
+        {        1848,1170,2048,1320     },/* 08 (1400x1050) */
+        {        2048,1320,2048,1320     } /* 09 (1600x1200) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDSNoScalingData[]=
+{
+        {        800,449,800,449             }, /* 00 (320x200,320x400,640x200,640x400) */
+        {        800,449,800,449             }, /* 01 (320x350,640x350) */
+        {        800,449,800,449             }, /* 02 (360x400,720x400) */
+        {        800,449,800,449             }, /* 03 (720x350) */
+        {        800,525,800,525             }, /* 04 (640x480x60Hz) */
+        {        1056,628,1056,628           }, /* 05 (800x600x60Hz) */
+        {        1344,806,1344,806           }, /* 06 (1024x768x60Hz) */
+        {        1688,1066,1688,1066         }, /* 07 (1280x1024x60Hz) */
+        {        1688,1066,1688,1066         }, /* 08 (1400x1050x60Hz) ;;[ycchen] 12/19/02 */
+        {        2160,1250,2160,1250         }, /* 09 (1600x1200x60Hz) */
+        {        1688,806,1688,806           }  /* 0A (1280x768x60Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1024x768Data_1x75[]=
+{
+	{960,438,1312,800  }, /* 00 (320x200,320x400,640x200,640x400) */
+        {960,388,1312,800  }, /* 01 (320x350,640x350) */
+        {1040,438,1312,800 }, /* 02 (360x400,720x400) */
+        {1040,388,1312,800 }, /* 03 (720x350) */
+        {928,512,1312,800  }, /* 04 (320x240,640x480) */
+        {1088,632,1312,800 }, /* 05 (400x300,800x600) */
+        {1312,800,1312,800 }, /* 06 (512x384,1024x768) */
+};
+
+
+XGI330_LVDSDataStruct XGI_LVDS1024x768Data_2x75[]=
+{
+        {1312,800,1312,800}, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {1312,800,1312,800}, /* ; 01 (320x350,640x350) */
+        {1312,800,1312,800}, /* ; 02 (360x400,720x400) */
+        {1312,800,1312,800}, /* ; 03 (720x350) */
+        {1312,800,1312,800}, /* ; 04 (320x240,640x480) */
+        {1312,800,1312,800}, /* ; 05 (400x300,800x600) */
+        {1312,800,1312,800}, /* ; 06 (512x384,1024x768) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1280x1024Data_1x75[]=
+{
+        {1048,442,1688,1066  }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {1048,392,1688,1066  }, /* ; 01 (320x350,640x350) */
+        {1128,442,1688,1066  }, /* ; 02 (360x400,720x400) */
+        {1128,392,1688,1066  }, /* ; 03 (720x350) */
+        {1048,522,1688,1066  }, /* ; 04 (320x240,640x480) */
+        {1208,642,1688,1066  }, /* ; 05 (400x300,800x600) */
+        {1432,810,1688,1066  }, /* ; 06 (512x384,1024x768) */
+        {1688,1066,1688,1066 }, /* ; 06; 07 (640x512,1280x1024) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1280x1024Data_2x75[]=
+{
+        {1688,1066,1688,1066 }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {1688,1066,1688,1066 }, /* ; 01 (320x350,640x350) */
+        {1688,1066,1688,1066 }, /* ; 02 (360x400,720x400) */
+        {1688,1066,1688,1066 }, /* ; 03 (720x350) */
+        {1688,1066,1688,1066 }, /* ; 04 (320x240,640x480) */
+        {1688,1066,1688,1066 }, /* ; 05 (400x300,800x600) */
+        {1688,1066,1688,1066 }, /* ; 06 (512x384,1024x768) */
+        {1688,1066,1688,1066 }, /* ; 06; 07 (640x512,1280x1024) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDSNoScalingDatax75[]=
+{
+        {800,449,800,449     }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {800,449,800,449     }, /* ; 01 (320x350,640x350) */
+        {900,449,900,449     }, /* ; 02 (360x400,720x400) */
+        {900,449,900,449     }, /* ; 03 (720x350) */
+        {800,500,800,500     }, /* ; 04 (640x480x75Hz) */
+        {1056,625,1056,625   }, /* ; 05 (800x600x75Hz) */
+        {1312,800,1312,800   }, /* ; 06 (1024x768x75Hz) */
+        {1688,1066,1688,1066 }, /* ; 07 (1280x1024x75Hz) */
+        {1688,1066,1688,1066 }, /* ; 08 (1400x1050x75Hz) ;;[ycchen] 12/19/02 */
+        {2160,1250,2160,1250 }, /* ; 09 (1600x1200x75Hz) */
+        {1688,806,1688,806   }, /* ; 0A (1280x768x75Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1024x768Des_1[]=
+{
+	{      0,1048,   0, 771     }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      0,1048,   0, 771     }, /* 01 (320x350,640x350) */
+        {      0,1048,   0, 771     }, /* 02 (360x400,720x400) */
+        {      0,1048,   0, 771     }, /* 03 (720x350) */
+        {      0,1048,   0, 771     }, /* 04 (640x480x60Hz) */
+        {      0,1048,   0, 771     }, /* 05 (800x600x60Hz) */
+        {      0,1048, 805, 770     }  /* 06 (1024x768x60Hz) */
+} ;
+
+XGI330_LVDSDataStruct XGI_LVDS1024x768Des_2[]=
+{
+    	{      1142, 856, 622, 587     }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      1142, 856, 597, 562     }, /* 01 (320x350,640x350) */
+        {      1142, 856, 622, 587     }, /* 02 (360x400,720x400) */
+        {      1142, 856, 597, 562     }, /* 03 (720x350) */
+        {      1142,1048, 722, 687     }, /* 04 (640x480x60Hz) */
+        {      1232, 936, 722, 687     }, /* 05 (800x600x60Hz) */
+        {         0,1048, 805, 771     }  /* 06 (1024x768x60Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1024x768Des_3[]=
+{
+    	{       320,  24, 622, 587     }, /* 00 (320x200,320x400,640x200,640x400) */
+        {       320,  24, 597, 562     }, /* 01 (320x350,640x350) */
+        {       320,  24, 622, 587     }, /* 02 (360x400,720x400) */
+        {       320,  24, 597, 562     }, /* 03 (720x350) */
+        {       320,  24, 722, 687     }  /* 04 (640x480x60Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1280x1024Des_1[]=
+{
+    	{      0,1328,    0, 1025     }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      0,1328,    0, 1025     }, /* 01 (320x350,640x350) */
+        {      0,1328,    0, 1025     }, /* 02 (360x400,720x400) */
+        {      0,1328,    0, 1025     }, /* 03 (720x350) */
+        {      0,1328,    0, 1025     }, /* 04 (640x480x60Hz) */
+        {      0,1328,    0, 1025     }, /* 05 (800x600x60Hz) */
+        {      0,1328,    0, 1025     }, /* 06 (1024x768x60Hz) */
+        {      0,1328, 1065, 1024     }  /* 07 (1280x1024x60Hz) */
+};
+
+ /* The Display setting for DE Mode Panel */
+XGI330_LVDSDataStruct XGI_LVDS1280x1024Des_2[]=
+{
+    	{      1368,1008,752,711     }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      1368,1008,729,688     }, /* 01 (320x350,640x350) */
+        {      1408,1048,752,711     }, /* 02 (360x400,720x400) */
+        {      1408,1048,729,688     }, /* 03 (720x350) */
+        {      1368,1008,794,753     }, /* 04 (640x480x60Hz) */
+        {      1448,1068,854,813     }, /* 05 (800x600x60Hz) */
+        {      1560,1200,938,897     }, /* 06 (1024x768x60Hz) */
+        {      0000,1328,0,1025     }  /* 07 (1280x1024x60Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1400x1050Des_1[]=
+{
+    	{      0,1448,0,1051     }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      0,1448,0,1051     }, /* 01 (320x350,640x350) */
+        {      0,1448,0,1051     }, /* 02 (360x400,720x400) */
+        {      0,1448,0,1051     }, /* 03 (720x350) */
+        {      0,1448,0,1051     }, /* 04 (640x480x60Hz) */
+        {      0,1448,0,1051     }, /* 05 (800x600x60Hz) */
+        {      0,1448,0,1051     }, /* 06 (1024x768x60Hz) */
+        {      0,1448,0,1051     }, /* 07 (1280x1024x60Hz) */
+        {      0,1448,0,1051     }  /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1400x1050Des_2[]=
+{
+    	{      1308,1068, 781, 766     }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      1308,1068, 781, 766     }, /* 01 (320x350,640x350) */
+        {      1308,1068, 781, 766     }, /* 02 (360x400,720x400) */
+        {      1308,1068, 781, 766     }, /* 03 (720x350) */
+        {      1308,1068, 781, 766     }, /* 04 (640x480x60Hz) */
+        {      1388,1148, 841, 826     }, /* 05 (800x600x60Hz) */
+        {      1490,1250, 925, 910     }, /* 06 (1024x768x60Hz) */
+        {      1608,1368,1053,1038     }, /* 07 (1280x1024x60Hz) */
+        {      0,1448,0,1051     }  /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1600x1200Des_1[]=
+{
+    	{      0,1664,0,1201     }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      0,1664,0,1201     }, /* 01 (320x350,640x350) */
+        {      0,1664,0,1201     }, /* 02 (360x400,720x400) */
+        {      0,1664,0,1201     }, /* 03 (720x350) */
+        {      0,1664,0,1201     }, /* 04 (640x480x60Hz) */
+        {      0,1664,0,1201     }, /* 05 (800x600x60Hz) */
+        {      0,1664,0,1201     }, /* 06 (1024x768x60Hz) */
+        {      0,1664,0,1201     }, /* 07 (1280x1024x60Hz) */
+        {      0,1664,0,1201     }, /* 08 (1400x1050x60Hz) */
+        {      0,1664,0,1201     }  /* 09 (1600x1200x60Hz) */
+};
+
+
+
+XGI330_LCDDataDesStruct2  XGI_LVDSNoScalingDesData[]=
+{
+    	{     0, 648, 448, 405,  96,   2   }, /* 00 (320x200,320x400,640x200,640x400) */
+        {     0, 648, 448, 355,  96,   2   }, /* 01 (320x350,640x350) */
+        {     0, 648, 448, 405,  96,   2   }, /* 02 (360x400,720x400) */
+        {     0, 648, 448, 355,  96,   2   }, /* 03 (720x350) */
+        {     0, 648,  1, 483,  96,   2   }, /* 04 (640x480x60Hz) */
+        {     0, 840, 627, 600, 128,   4   }, /* 05 (800x600x60Hz) */
+        {     0,1048, 805, 770, 136,   6   }, /* 06 (1024x768x60Hz) */
+        {     0,1328,0,1025, 112,   3   }, /* 07 (1280x1024x60Hz) */
+        {     0,1438,0,1051, 112,   3   }, /* 08 (1400x1050x60Hz) ;;[ycchen] 12/19/02 */
+        {     0,1664,0,1201, 192,   3   }, /* 09 (1600x1200x60Hz) */
+        {     0,1328,0,0771, 112,   6   }  /* 0A (1280x768x60Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1024x768Des_1x75[]=			/* ; 1024x768 Full-screen */
+{
+        {0,1040,0,769}, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {0,1040,0,769}, /* ; 01 (320x350,640x350) */
+        {0,1040,0,769}, /* ; 02 (360x400,720x400) */
+        {0,1040,0,769}, /* ; 03 (720x350) */
+        {0,1040,0,769}, /* ; 04 (640x480x75Hz) */
+        {0,1040,0,769}, /* ; 05 (800x600x75Hz) */
+        {0,1040,0,769} /* ; 06 (1024x768x75Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1024x768Des_2x75[]= /* ; 1024x768 center-screen (Enh. Mode) */
+{
+        {1142, 856,622,587 }, /* 00 (320x200,320x400,640x200,640x400) */
+        {1142, 856,597,562 }, /* 01 (320x350,640x350) */
+        {1142, 856,622,587 }, /* 02 (360x400,720x400) */
+        {1142, 856,597,562 }, /* 03 (720x350) */
+        {1142,1048,722,687 }, /* 04 (640x480x60Hz) */
+        {1232, 936,722,687 }, /* 05 (800x600x60Hz) */
+        {   0,1048,805,771 }  /* 06 (1024x768x60Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1024x768Des_3x75[]= /* ; 1024x768 center-screen (St.Mode) */
+{
+        {320,24,622,587  }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {320,24,597,562  }, /* ; 01 (320x350,640x350) */
+        {320,24,622,587  }, /* ; 02 (360x400,720x400) */
+        {320,24,597,562  }, /* ; 03 (720x350) */
+        {320,24,722,687  } /* ; 04 (640x480x60Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1280x1024Des_1x75[]=
+{
+        {0,1296,0,1025}, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {0,1296,0,1025}, /* ; 01 (320x350,640x350) */
+        {0,1296,0,1025}, /* ; 02 (360x400,720x400) */
+        {0,1296,0,1025}, /* ; 03 (720x350) */
+        {0,1296,0,1025}, /* ; 04 (640x480x75Hz) */
+        {0,1296,0,1025}, /* ; 05 (800x600x75Hz) */
+        {0,1296,0,1025}, /* ; 06 (1024x768x75Hz) */
+        {0,1296,0,1025} /* ; 07 (1280x1024x75Hz) */
+};
+
+/* The Display setting for DE Mode Panel */
+XGI330_LVDSDataStruct XGI_LVDS1280x1024Des_2x75[]=   /* [ycchen] 02/18/03 Set DE as default */
+{
+        {1368,976,752,711 }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {1368,976,729,688 }, /* ; 01 (320x350,640x350) */
+        {1408,976,752,711 }, /* ; 02 (360x400,720x400) */
+        {1408,976,729,688 }, /* ; 03 (720x350) */
+        {1368,976,794,753 }, /* ; 04 (640x480x75Hz) */
+        {1448,1036,854,813}, /* ; 05 (800x600x75Hz) */
+        {1560,1168,938,897}, /* ; 06 (1024x768x75Hz) */
+        {0,1296,0,1025    } /* ; 07 (1280x1024x75Hz) */
+};
+
+XGI330_LCDDataDesStruct2 XGI_LVDSNoScalingDesDatax75[]=  /* Scaling LCD 75Hz */
+{
+       { 0,648,448,405,96,2  }, /* ; 00 (320x200,320x400,640x200,640x400) */
+       { 0,648,448,355,96,2  }, /* ; 01 (320x350,640x350) */
+       { 0,729,448,405,108,2 }, /* ; 02 (360x400,720x400) */
+       { 0,729,448,355,108,2 }, /* ; 03 (720x350) */
+       { 0,656,0,481,64,3    }, /* ; 04 (640x480x75Hz) */
+       { 0,816,0,601,80,3    }, /* ; 05 (800x600x75Hz) */
+       { 0,1040,0,769,96,3   }, /* ; 06 (1024x768x75Hz) */
+       { 0,1296,0,1025,144,3 }, /* ; 07 (1280x1024x75Hz) */
+       { 0,1448,0,1051,112,3 }, /* ; 08 (1400x1050x75Hz) ;;[ycchen] 12/19/02 */
+       { 0,1664,0,1201,192,3 }, /* ; 09 (1600x1200x75Hz) */
+       { 0,1328,0,771,112,6  }  /* ; 0A (1280x768x75Hz) */
+};
+
+XGI330_LVDSDataStruct  XGI330_LVDS640x480Data_1[]=
+{
+ {800, 449, 800, 449},
+ {800, 449, 800, 449},
+ {800, 449, 800, 449},
+ {800, 449, 800, 449},
+ {800, 525, 800, 525},
+ {1056, 628,1056, 628},
+ {1056, 628,1056, 628},
+ {1056, 628,1056, 628},
+ {1056, 628,1056, 628}
+};
+
+XGI330_CHTVDataStruct  XGI_CHTVUNTSCData[]=
+{
+ {840, 600, 840, 600},
+ {840, 600, 840, 600},
+ {840, 600, 840, 600},
+ {840, 600, 840, 600},
+ {784, 600, 784, 600},
+ {1064, 750,1064, 750}
+};
+
+XGI330_CHTVDataStruct  XGI_CHTVONTSCData[]=
+{
+ {840, 525, 840, 525},
+ {840, 525, 840, 525},
+ {840, 525, 840, 525},
+ {840, 525, 840, 525},
+ {784, 525, 784, 525},
+ {1040, 700,1040, 700}
+};
+
+XGI330_CHTVDataStruct  XGI_CHTVUPALData[]=
+{
+ {1008, 625,1008, 625},
+ {1008, 625,1008, 625},
+ {1008, 625,1008, 625},
+ {1008, 625,1008, 625},
+ {840, 750, 840, 750},
+ {936, 836, 936, 836}
+};
+
+XGI330_CHTVDataStruct  XGI_CHTVOPALData[]=
+{
+ {1008, 625,1008, 625},
+ {1008, 625,1008, 625},
+ {1008, 625,1008, 625},
+ {1008, 625,1008, 625},
+ {840, 625, 840, 625},
+ {960, 750, 960, 750}
+};
+
+XGI_LVDSCRT1HDataStruct  XGI_LVDSCRT11024x768_1_H[]=
+{
+	        /* CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+                {{      0x4B,0x27,0x8F,0x32,0x1B,0x00,0x45,0x00 }}, /* 00 (320x) */
+                {{      0x4B,0x27,0x8F,0x2B,0x03,0x00,0x44,0x00 }}, /* 01 (360x) */
+                {{      0x55,0x31,0x99,0x46,0x1D,0x00,0x55,0x00 }}, /* 02 (400x) */
+                {{      0x63,0x3F,0x87,0x4A,0x93,0x00,0x01,0x00 }}, /* 03 (512x) */
+                {{      0x73,0x4F,0x97,0x55,0x86,0x00,0x05,0x00 }}, /* 04 (640x) */
+                {{      0x73,0x4F,0x97,0x55,0x86,0x00,0x05,0x00 }}, /* 05 (720x) */
+                {{      0x87,0x63,0x8B,0x69,0x1A,0x00,0x26,0x00 }}, /* 06 (800x) */
+                {{      0xA3,0x7F,0x87,0x86,0x97,0x00,0x02,0x00 }} /* 07 (1024x) */
+};
+
+XGI_LVDSCRT1HDataStruct  XGI_LVDSCRT11280x1024_1_H[]=
+{
+		/* CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+                {{      0x56,0x27,0x9A,0x30,0x1E,0x00,0x05,0x00 }}, /* 00 (320x) */
+                {{      0x56,0x27,0x9A,0x30,0x1E,0x00,0x05,0x00 }}, /* 01 (360x) */
+                {{      0x60,0x31,0x84,0x3A,0x88,0x00,0x01,0x00 }}, /* 02 (400x) */
+                {{      0x6E,0x3F,0x92,0x48,0x96,0x00,0x01,0x00 }}, /* 03 (512x) */
+                {{      0x7E,0x4F,0x82,0x58,0x06,0x00,0x06,0x00 }}, /* 04 (640x) */
+                {{      0x7E,0x4F,0x82,0x58,0x06,0x00,0x06,0x00 }}, /* 05 (720x) */
+                {{      0x92,0x63,0x96,0x6C,0x1A,0x00,0x06,0x00 }}, /* 06 (800x) */
+                {{      0xAE,0x7F,0x92,0x88,0x96,0x00,0x02,0x00 }}, /* 07 (1024x) */
+                {{      0xCE,0x9F,0x92,0xA8,0x16,0x00,0x07,0x00 }} /* 08 (1280x) */
+};
+
+XGI_LVDSCRT1HDataStruct  XGI_LVDSCRT11024x768_2_H[]=
+{
+		/* CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+                {{      0x63,0x27,0x87,0x3B,0x8C,0x00,0x01,0x00 }}, /* 00 (320x) */
+                {{      0x63,0x27,0x87,0x3B,0x8C,0x00,0x01,0x00 }}, /* 01 (360x) */
+                {{      0x63,0x31,0x87,0x3D,0x8E,0x00,0x01,0x00 }}, /* 02 (400x) */
+                {{      0x63,0x3F,0x87,0x45,0x96,0x00,0x01,0x00 }}, /* 03 (512x) */
+                {{      0xA3,0x4F,0x87,0x6E,0x9F,0x00,0x06,0x00 }}, /* 04 (640x) */
+                {{      0xA3,0x4F,0x87,0x6E,0x9F,0x00,0x06,0x00 }}, /* 05 (720x) */
+                {{      0xA3,0x63,0x87,0x78,0x89,0x00,0x02,0x00 }}, /* 06 (800x) */
+                {{      0xA3,0x7F,0x87,0x86,0x97,0x00,0x02,0x00 }} /* 07 (1024x) */
+};
+
+XGI_LVDSCRT1HDataStruct  XGI_LVDSCRT11280x1024_2_H[]=
+{
+                /* CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+                {{      0x7E,0x3B,0x9A,0x44,0x12,0x00,0x01,0x00 }}, /* 00 (320x) */
+                {{      0x7E,0x3B,0x9A,0x44,0x12,0x00,0x01,0x00 }}, /* 01 (360x) */
+                {{      0x7E,0x40,0x84,0x49,0x91,0x00,0x01,0x00 }}, /* 02 (400x) */
+                {{      0x7E,0x47,0x93,0x50,0x9E,0x00,0x01,0x00 }}, /* 03 (512x) */
+                {{      0xCE,0x77,0x8A,0x80,0x8E,0x00,0x02,0x00 }}, /* 04 (640x) */
+                {{      0xCE,0x77,0x8A,0x80,0x8E,0x00,0x02,0x00 }}, /* 05 (720x) */
+                {{      0xCE,0x81,0x94,0x8A,0x98,0x00,0x02,0x00 }}, /* 06 (800x) */
+                {{      0xCE,0x8F,0x82,0x98,0x06,0x00,0x07,0x00 }}, /* 07 (1024x) */
+                {{      0xCE,0x9F,0x92,0xA8,0x16,0x00,0x07,0x00 }} /* 08 (1280x) */
+};
+
+XGI_LVDSCRT1HDataStruct XGI_LVDSCRT11400x1050_1_H[]=
+{               /* CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+                {{      0x47,0x27,0x8B,0x2C,0x1A,0x00,0x05,0x00 }}, /* 00 (320x) */
+                {{      0x47,0x27,0x8B,0x30,0x1E,0x00,0x05,0x00 }}, /* 01 (360x) */
+                {{      0x51,0x31,0x95,0x36,0x04,0x00,0x01,0x00 }}, /* 02 (400x) */
+                {{      0x5F,0x3F,0x83,0x44,0x92,0x00,0x01,0x00 }}, /* 03 (512x) */
+                {{      0x6F,0x4F,0x93,0x54,0x82,0x00,0x05,0x00 }}, /* 04 (640x) */
+                {{      0x6F,0x4F,0x93,0x54,0x82,0x00,0x05,0x00 }}, /* 05 (720x) */
+                {{      0x83,0x63,0x87,0x68,0x16,0x00,0x06,0x00 }}, /* 06 (800x) */
+                {{      0x9F,0x7F,0x83,0x84,0x92,0x00,0x02,0x00 }}, /* 07 (1024x) */
+                {{      0xBF,0x9F,0x83,0xA4,0x12,0x00,0x07,0x00 }}, /* 08 (1280x) */
+                {{      0xCE,0xAE,0x92,0xB3,0x01,0x00,0x03,0x00 }} /* 09 (1400x) */
+};
+
+XGI_LVDSCRT1HDataStruct XGI_LVDSCRT11400x1050_2_H[]=
+{               /* CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+                {{      0x76,0x3F,0x83,0x45,0x8C,0x00,0x41,0x00 }}, /* 00 (320x) */
+                {{      0x76,0x3F,0x83,0x45,0x8C,0x00,0x41,0x00 }}, /* 01 (360x) */
+                {{      0x76,0x31,0x9A,0x48,0x9F,0x00,0x41,0x00 }}, /* 02 (400x) */
+                {{      0x76,0x3F,0x9A,0x4F,0x96,0x00,0x41,0x00 }}, /* 03 (512x) */
+                {{      0xCE,0x7E,0x82,0x87,0x9E,0x00,0x02,0x00 }}, /* 04 (640x) */
+                {{      0xCE,0x7E,0x82,0x87,0x9E,0x00,0x02,0x00 }}, /* 05 (720x) */
+                {{      0xCE,0x63,0x92,0x96,0x04,0x00,0x07,0x00 }}, /* 06 (800x) */
+                {{      0xCE,0x7F,0x92,0xA4,0x12,0x00,0x07,0x00 }}, /* 07 (1024x) */
+                {{      0xCE,0x9F,0x92,0xB4,0x02,0x00,0x03,0x00 }}, /* 08 (1280x) */
+                {{      0xCE,0xAE,0x92,0xBC,0x0A,0x00,0x03,0x00 }} /* 09 (1400x) */
+};
+
+XGI_LVDSCRT1HDataStruct XGI_LVDSCRT11600x1200_1_H[]=
+/* ;302lv channelA [ycchen] 12/05/02 LCDHT=2048 */
+{   /* ; CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+                {{      0x5B,0x27,0x9F,0x32,0x0A,0x00,0x01,0x00 }},/* 00 (320x) */
+                {{      0x5B,0x27,0x9F,0x32,0x0A,0x00,0x01,0x00 }},/* 01 (360x) */
+                {{      0x65,0x31,0x89,0x3C,0x94,0x00,0x01,0x00 }},/* 02 (400x) */
+                {{      0x73,0x3F,0x97,0x4A,0x82,0x00,0x05,0x00 }},/* 03 (512x) */
+                {{      0x83,0x4F,0x87,0x51,0x09,0x00,0x06,0x00 }},/* 04 (640x) */
+		{{      0x83,0x4F,0x87,0x51,0x09,0x00,0x06,0x00 }},/* 05 (720x) */
+		{{      0x97,0x63,0x9B,0x65,0x1D,0x00,0x06,0xF0 }},/* 06 (800x) */
+		{{      0xB3,0x7F,0x97,0x81,0x99,0x00,0x02,0x00 }},/* 07 (1024x) */
+		{{      0xD3,0x9F,0x97,0xA1,0x19,0x00,0x07,0x00 }},/* 08 (1280x) */
+		{{      0xE2,0xAE,0x86,0xB9,0x91,0x00,0x03,0x00 }},/* 09 (1400x) */
+		{{      0xFB,0xC7,0x9F,0xC9,0x81,0x00,0x07,0x00 }} /* 0A (1600x) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11024x768_1_V[]=
+{               /* CR06,CR07,CR10,CR11,CR15,CR16,SR0A+CR09(5->7) */
+                {{      0x97,0x1F,0x60,0x87,0x5D,0x83,0x10      }}, /* 00 (x350) */
+                {{      0xB4,0x1F,0x92,0x89,0x8F,0xB5,0x30      }}, /* 01 (x400) */
+                {{      0x04,0x3E,0xE2,0x89,0xDF,0x05,0x00      }}, /* 02 (x480) */
+                {{      0x7C,0xF0,0x5A,0x8F,0x57,0x7D,0xA0      }}, /* 03 (x600) */
+                {{      0x24,0xF5,0x02,0x88,0xFF,0x25,0x90      }} /* 04 (x768) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11024x768_2_V[]=
+{               /* CR06,CR07,CR10,CR11,CR15,CR16,SR0A */
+                {{      0x24,0xBB,0x31,0x87,0x5D,0x25,0x30      }}, /* 00 (x350) */
+                {{      0x24,0xBB,0x4A,0x80,0x8F,0x25,0x30      }}, /* 01 (x400) */
+                {{      0x24,0xBB,0x72,0x88,0xDF,0x25,0x30      }}, /* 02 (x480) */
+                {{      0x24,0xF1,0xAE,0x84,0x57,0x25,0xB0      }}, /* 03 (x600) */
+                {{      0x24,0xF5,0x02,0x88,0xFF,0x25,0x90      }} /* 04 (x768) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11280x1024_1_V[]=
+{               /* CR06,CR07,CR10,CR11,CR15,CR16,SR0A */
+                {{       0x86,0x1F,0x5E,0x82,0x5D,0x87,0x00     }}, /* 00 (x350) */
+                {{       0xB8,0x1F,0x90,0x84,0x8F,0xB9,0x30     }}, /* 01 (x400) */
+                {{       0x08,0x3E,0xE0,0x84,0xDF,0x09,0x00     }}, /* 02 (x480) */
+                {{       0x80,0xF0,0x58,0x8C,0x57,0x81,0xA0     }}, /* 03 (x600) */
+                {{       0x28,0xF5,0x00,0x84,0xFF,0x29,0x90     }}, /* 04 (x768) */
+                {{       0x28,0x5A,0x13,0x87,0xFF,0x29,0xA9     }} /* 05 (x1024) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11280x1024_2_V[]=
+{               /* CR06,CR07,CR10,CR11,CR15,CR16,SR0A */
+                {{      0x28,0xD2,0xAF,0x83,0xAE,0xD8,0xA1      }}, /* 00 (x350) */
+                {{      0x28,0xD2,0xC8,0x8C,0xC7,0xF2,0x81      }}, /* 01 (x400) */
+                {{      0x28,0xD2,0xF0,0x84,0xEF,0x1A,0xB1      }}, /* 02 (x480) */
+                {{      0x28,0xDE,0x2C,0x8F,0x2B,0x56,0x91      }}, /* 03 (x600) */
+                {{      0x28,0xDE,0x80,0x83,0x7F,0xAA,0x91      }}, /* 04 (x768) */
+                {{      0x28,0x5A,0x13,0x87,0xFF,0x29,0xA9      }} /* 05 (x1024) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11400x1050_1_V[]=
+{               /* CR06,CR07,CR10,CR11,CR15,CR16,SR0A */
+                {{      0x6C,0x1F,0x60,0x84,0x5D,0x6D,0x10      }}, /* 00 (x350) */
+                {{      0x9E,0x1F,0x93,0x86,0x8F,0x9F,0x30      }}, /* 01 (x400) */
+                {{      0xEE,0x1F,0xE2,0x86,0xDF,0xEF,0x10      }}, /* 02 (x480) */
+                {{      0x66,0xF0,0x5A,0x8e,0x57,0x67,0xA0      }}, /* 03 (x600) */
+                {{      0x0E,0xF5,0x02,0x86,0xFF,0x0F,0x90      }}, /* 04 (x768) */
+                {{      0x0E,0x5A,0x02,0x86,0xFF,0x0F,0x89      }}, /* 05 (x1024) */
+                {{      0x28,0x10,0x1A,0x80,0x19,0x29,0x0F      }} /* 06 (x1050) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11400x1050_2_V[]=
+{              /* CR06,CR07,CR10,CR11,CR15,CR16,SR0A */
+                {{      0x28,0x92,0xB6,0x83,0xB5,0xCF,0x81      }}, /* 00 (x350) */
+                {{      0x28,0x92,0xD5,0x82,0xD4,0xEE,0x81      }}, /* 01 (x400) */
+                {{      0x28,0x92,0xFD,0x8A,0xFC,0x16,0xB1      }}, /* 02 (x480) */
+                {{      0x28,0xD4,0x39,0x86,0x57,0x29,0x81      }}, /* 03 (x600) */
+                {{      0x28,0xD4,0x8D,0x9A,0xFF,0x29,0xA1      }}, /* 04 (x768) */
+                {{      0x28,0x5A,0x0D,0x9A,0xFF,0x29,0xA9      }}, /* 05 (x1024) */
+                {{      0x28,0x10,0x1A,0x87,0x19,0x29,0x8F      }} /* 06 (x1050) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11600x1200_1_V[]=
+{
+               /* CR06,CR07,CR10,CR11,CR15,CR16,SR0A+CR09(5->7) */
+                {{      0xd4,0x1F,0x81,0x84,0x5D,0xd5,0x10      }}, /* 00 (x350) */
+                {{      0x06,0x3e,0xb3,0x86,0x8F,0x07,0x20      }}, /* 01 (x400) */
+                {{      0x56,0xba,0x03,0x86,0xDF,0x57,0x00      }}, /* 02 (x480) */
+                {{      0xce,0xF0,0x7b,0x8e,0x57,0xcf,0xa0      }}, /* 03 (x600) */
+                {{      0x76,0xF5,0x23,0x86,0xFF,0x77,0x90      }}, /* 04 (x768) */
+                {{      0x76,0x5A,0x23,0x86,0xFF,0x77,0x89      }}, /* 05 (x1024) */
+                {{      0x90,0x10,0x1A,0x8E,0x19,0x91,0x2F      }}, /* 06 (x1050) */
+                {{      0x26,0x11,0xd3,0x86,0xaF,0x27,0x3f      }} /* 07 (x1200) */
+};
+
+XGI_LVDSCRT1HDataStruct XGI_LVDSCRT11024x768_1_Hx75[]=
+{ 	/* CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+    {{      0x4B,0x27,0x8F,0x32,0x1B,0x00,0x45,0x00 }},/* ; 00 (320x) */
+    {{      0x4B,0x27,0x8F,0x2B,0x03,0x00,0x44,0x00 }},/* ; 01 (360x) */
+    {{      0x55,0x31,0x99,0x46,0x1D,0x00,0x55,0x00 }},/* ; 02 (400x) */
+    {{      0x63,0x3F,0x87,0x4A,0x93,0x00,0x01,0x00 }},/* ; 03 (512x) */
+    {{      0x6F,0x4F,0x93,0x54,0x80,0x00,0x05,0x00 }},/* ; 04 (640x) */
+    {{      0x6F,0x4F,0x93,0x54,0x80,0x00,0x05,0x00 }},/* ; 05 (720x) */
+    {{      0x83,0x63,0x87,0x68,0x14,0x00,0x26,0x00 }},/* ; 06 (800x) */
+    {{      0x9F,0x7F,0x83,0x85,0x91,0x00,0x02,0x00 }} /* ; 07 (1024x) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11024x768_1_Vx75[]=
+{	/* CR06,CR07,CR10,CR11,CR15,CR16,SR0A+CR09(5->7) */
+    {{      0x97,0x1F,0x60,0x87,0x5D,0x83,0x10      }},/* ; 00 (x350) */
+    {{      0xB4,0x1F,0x92,0x89,0x8F,0xB5,0x30      }},/* ; 01 (x400) */
+    {{      0xFE,0x1F,0xE0,0x84,0xDF,0xFF,0x10      }},/* ; 02 (x480) */
+    {{      0x76,0xF0,0x58,0x8C,0x57,0x77,0xA0      }},/* ; 03 (x600) */
+    {{      0x1E,0xF5,0x00,0x83,0xFF,0x1F,0x90      }} /* ; 04 (x768) */
+};
+
+XGI_LVDSCRT1HDataStruct XGI_LVDSCRT11024x768_2_Hx75[]=
+{       /* CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+    {{      0x63,0x27,0x87,0x3B,0x8C,0x00,0x01,0x00 }},/* ; 00 (320x) */
+    {{      0x63,0x27,0x87,0x3B,0x8C,0x00,0x01,0x00 }},/* ; 01 (360x) */
+    {{      0x63,0x31,0x87,0x3D,0x8E,0x00,0x01,0x00 }},/* ; 02 (400x) */
+    {{      0x63,0x3F,0x87,0x45,0x96,0x00,0x01,0x00 }},/* ; 03 (512x) */
+    {{      0xA3,0x4F,0x87,0x6E,0x9F,0x00,0x06,0x00 }},/* ; 04 (640x) */
+    {{      0xA3,0x4F,0x87,0x6E,0x9F,0x00,0x06,0x00 }},/* ; 05 (720x) */
+    {{      0xA3,0x63,0x87,0x78,0x89,0x00,0x02,0x00 }},/* ; 06 (800x) */
+    {{      0xA3,0x7F,0x87,0x86,0x97,0x00,0x02,0x00 }} /* ; 07 (1024x) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11024x768_2_Vx75[]=
+{       /* CR06,CR07,CR10,CR11,CR15,CR16,SR0A */
+    {{      0x24,0xBB,0x31,0x87,0x5D,0x25,0x30      }},/* ; 00 (x350) */
+    {{      0x24,0xBB,0x4A,0x80,0x8F,0x25,0x30      }},/* ; 01 (x400) */
+    {{      0x24,0xBB,0x72,0x88,0xDF,0x25,0x30      }},/* ; 02 (x480) */
+    {{      0x24,0xF1,0xAE,0x84,0x57,0x25,0xB0      }},/* ; 03 (x600) */
+    {{      0x24,0xF5,0x02,0x88,0xFF,0x25,0x90      }} /* ; 04 (x768) */
+};
+
+XGI_LVDSCRT1HDataStruct XGI_LVDSCRT11280x1024_1_Hx75[]=
+{      /* CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+    {{      0x56,0x27,0x9A,0x30,0x1E,0x00,0x05,0x00 }},/* ; 00 (320x) */
+    {{      0x56,0x27,0x9A,0x30,0x1E,0x00,0x05,0x00 }},/* ; 01 (360x) */
+    {{      0x60,0x31,0x84,0x3A,0x88,0x00,0x01,0x00 }},/* ; 02 (400x) */
+    {{      0x6E,0x3F,0x92,0x48,0x96,0x00,0x01,0x00 }},/* ; 03 (512x) */
+    {{      0x7E,0x4F,0x82,0x54,0x06,0x00,0x06,0x00 }},/* ; 04 (640x) */
+    {{      0x7E,0x4F,0x82,0x54,0x06,0x00,0x06,0x00 }},/* ; 05 (720x) */
+    {{      0x92,0x63,0x96,0x68,0x1A,0x00,0x06,0x00 }},/* ; 06 (800x) */
+    {{      0xAE,0x7F,0x92,0x84,0x96,0x00,0x02,0x00 }},/* ; 07 (1024x) */
+    {{      0xCE,0x9F,0x92,0xA5,0x17,0x00,0x07,0x00 }} /* ; 08 (1280x) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11280x1024_1_Vx75[]=
+{	/* CR06,CR07,CR10,CR11,CR15,CR16,SR0A */
+    {{      0x86,0xD1,0xBC,0x80,0xBB,0xE5,0x00      }},/* ; 00 (x350) */
+    {{      0xB8,0x1F,0x90,0x84,0x8F,0xB9,0x30      }},/* ; 01 (x400) */
+    {{      0x08,0x3E,0xE0,0x84,0xDF,0x09,0x00      }},/* ; 02 (x480) */
+    {{      0x80,0xF0,0x58,0x8C,0x57,0x81,0xA0      }},/* ; 03 (x600) */
+    {{      0x28,0xF5,0x00,0x84,0xFF,0x29,0x90      }},/* ; 04 (x768) */
+    {{      0x28,0x5A,0x13,0x87,0xFF,0x29,0xA9      }} /* ; 05 (x1024) */
+};
+
+XGI_LVDSCRT1HDataStruct XGI_LVDSCRT11280x1024_2_Hx75[]=
+{
+	/* CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+    {{      0x7E,0x3B,0x9A,0x44,0x12,0x00,0x01,0x00 }},/* ; 00 (320x) */
+    {{      0x7E,0x3B,0x9A,0x44,0x12,0x00,0x01,0x00 }},/* ; 01 (360x) */
+    {{      0x7E,0x40,0x84,0x49,0x91,0x00,0x01,0x00 }},/* ; 02 (400x) */
+    {{      0x7E,0x47,0x93,0x50,0x9E,0x00,0x01,0x00 }},/* ; 03 (512x) */
+    {{      0xCE,0x77,0x8A,0x80,0x8E,0x00,0x02,0x00 }},/* ; 04 (640x) */
+    {{      0xCE,0x77,0x8A,0x80,0x8E,0x00,0x02,0x00 }},/* ; 05 (720x) */
+    {{      0xCE,0x81,0x94,0x8A,0x98,0x00,0x02,0x00 }},/* ; 06 (800x) */
+    {{      0xCE,0x8F,0x82,0x98,0x06,0x00,0x07,0x00 }},/* ; 07 (1024x) */
+    {{      0xCE,0x9F,0x92,0xA8,0x16,0x00,0x07,0x00 }} /* ; 08 (1280x) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11280x1024_2_Vx75[]=
+{
+        /* CR06,CR07,CR10,CR11,CR15,CR16,SR0A */
+     {{     0x28,0xD2,0xAF,0x83,0xAE,0xD8,0xA1     }},/* ; 00 (x350) */
+     {{     0x28,0xD2,0xC8,0x8C,0xC7,0xF2,0x81     }},/* ; 01 (x400) */
+     {{     0x28,0xD2,0xF0,0x84,0xEF,0x1A,0xB1     }},/* ; 02 (x480) */
+     {{     0x28,0xDE,0x2C,0x8F,0x2B,0x56,0x91     }},/* ; 03 (x600) */
+     {{     0x28,0xDE,0x80,0x83,0x7F,0xAA,0x91     }},/* ; 04 (x768) */
+     {{     0x28,0x5A,0x13,0x87,0xFF,0x29,0xA9     }} /* ; 05 (x1024) */
+};
+
+XGI_LVDSCRT1DataStruct  XGI_CHTVCRT1UNTSC[]=
+{
+ {{0x64,0x4f,0x88,0x56,0x9f,0x56,0x3e,
+    0xe8,0x84,0x8f,0x57,0x20,0x00,0x01,0x00 }},
+ {{0x64,0x4f,0x88,0x56,0x9f,0x56,0x3e,
+    0xd0,0x82,0x5d,0x57,0x00,0x00,0x01,0x00 }},
+ {{0x64,0x4f,0x88,0x56,0x9f,0x56,0x3e,
+    0xe8,0x84,0x8f,0x57,0x20,0x00,0x01,0x00 }},
+ {{0x64,0x4f,0x88,0x56,0x9f,0x56,0x3e,
+    0xd0,0x82,0x5d,0x57,0x00,0x00,0x01,0x00 }},
+ {{0x5d,0x4f,0x81,0x53,0x9c,0x56,0xba,
+    0x18,0x84,0xdf,0x57,0x00,0x00,0x01,0x00 }},
+ {{0x80,0x63,0x84,0x6c,0x17,0xec,0xf0,
+   0x90,0x8c,0x57,0xed,0x20,0x00,0x06,0x01 }}
+};
+
+XGI_LVDSCRT1DataStruct  XGI_CHTVCRT1ONTSC[]=
+{
+ {{0x64,0x4f,0x88,0x5a,0x9f,0x0b,0x3e,
+    0xc0,0x84,0x8f,0x0c,0x20,0x00,0x01,0x00 }},
+ {{0x64,0x4f,0x88,0x5a,0x9f,0x0b,0x3e,
+    0xb0,0x8d,0x5d,0x0c,0x00,0x00,0x01,0x00 }},
+ {{0x64,0x4f,0x88,0x5a,0x9f,0x0b,0x3e,
+    0xc0,0x84,0x8f,0x0c,0x20,0x00,0x01,0x00 }},
+ {{0x64,0x4f,0x88,0x5a,0x9f,0x0b,0x3e,
+    0xb0,0x8d,0x5d,0x0c,0x00,0x00,0x01,0x00 }},
+ {{0x5d,0x4f,0x81,0x56,0x9c,0x0b,0x3e,
+    0xe8,0x84,0xdf,0x0c,0x00,0x00,0x01,0x00 }},
+ {{0x7d,0x63,0x81,0x6a,0x16,0xba,0xf0,
+   0x7f,0x86,0x57,0xbb,0x00,0x00,0x06,0x01 }}
+};
+
+XGI_LVDSCRT1DataStruct  XGI_CHTVCRT1UPAL[]=
+{
+ {{0x79,0x4f,0x9d,0x5a,0x90,0x6f,0x3e,
+    0xf8,0x83,0x8f,0x70,0x20,0x00,0x05,0x00 }},
+ {{0x79,0x4f,0x9d,0x5a,0x90,0x6f,0x3e,
+    0xde,0x81,0x5d,0x70,0x00,0x00,0x05,0x00 }},
+ {{0x79,0x4f,0x9d,0x5a,0x90,0x6f,0x3e,
+    0xf8,0x83,0x8f,0x70,0x20,0x00,0x05,0x00 }},
+ {{0x79,0x4f,0x9d,0x5a,0x90,0x6f,0x3e,
+    0xde,0x81,0x5d,0x70,0x00,0x00,0x05,0x00 }},
+ {{0x64,0x4f,0x88,0x55,0x80,0xec,0xba,
+    0x50,0x84,0xdf,0xed,0x00,0x00,0x05,0x00 }},
+ {{0x70,0x63,0x94,0x68,0x8d,0x42,0xf1,
+   0xc8,0x8c,0x57,0xe9,0x20,0x00,0x05,0x01 }}
+};
+
+XGI_LVDSCRT1DataStruct  XGI_CHTVCRT1OPAL[]=
+{
+ {{0x79,0x4f,0x9d,0x5a,0x90,0x6f,0x3e,
+    0xf0,0x83,0x8f,0x70,0x20,0x00,0x05,0x00 }},
+ {{0x79,0x4f,0x9d,0x5a,0x90,0x6f,0x3e,
+    0xde,0x81,0x5d,0x70,0x00,0x00,0x05,0x00 }},
+ {{0x79,0x4f,0x9d,0x5a,0x90,0x6f,0x3e,
+    0xf0,0x83,0x8f,0x70,0x20,0x00,0x05,0x00 }},
+ {{0x79,0x4f,0x9d,0x5a,0x90,0x6f,0x3e,
+    0xde,0x81,0x5d,0x70,0x00,0x00,0x05,0x00 }},
+ {{0x64,0x4f,0x88,0x55,0x80,0x6f,0xba,
+    0x20,0x83,0xdf,0x70,0x00,0x00,0x05,0x00 }},
+ {{0x73,0x63,0x97,0x69,0x8e,0xec,0xf0,
+   0x90,0x8c,0x57,0xed,0x20,0x00,0x05,0x01 }}
+};
+
+/*add for new UNIVGABIOS*/
+XGI330_LCDDataTablStruct XGI_LCDDataTable[]=
+{
+  {Panel1024x768,0x0019,0x0001,0},  /* XGI_ExtLCD1024x768Data */
+  {Panel1024x768,0x0019,0x0000,1},  /* XGI_StLCD1024x768Data */
+  {Panel1024x768,0x0018,0x0010,2},  /* XGI_CetLCD1024x768Data */
+  {Panel1280x1024,0x0019,0x0001,3},  /* XGI_ExtLCD1280x1024Data */
+  {Panel1280x1024,0x0019,0x0000,4},  /* XGI_StLCD1280x1024Data */
+  {Panel1280x1024,0x0018,0x0010,5},  /* XGI_CetLCD1280x1024Data */
+  {Panel1400x1050,0x0019,0x0001,6},  /* XGI_ExtLCD1400x1050Data */
+  {Panel1400x1050,0x0019,0x0000,7},  /* XGI_StLCD1400x1050Data */
+  {Panel1400x1050,0x0018,0x0010,8},  /* XGI_CetLCD1400x1050Data */
+  {Panel1600x1200,0x0019,0x0001,9},   /* XGI_ExtLCD1600x1200Data */
+  {Panel1600x1200,0x0019,0x0000,10},  /* XGI_StLCD1600x1200Data */
+  {PanelRef60Hz,0x0008,0x0008,11},  	/* XGI_NoScalingData */
+  {Panel1024x768x75,0x0019,0x0001,12}, 	/* XGI_ExtLCD1024x768x75Data */
+  {Panel1024x768x75,0x0019,0x0000,13}, 	/* XGI_StLCD1024x768x75Data */
+  {Panel1024x768x75,0x0018,0x0010,14}, 	/* XGI_CetLCD1024x768x75Data */
+  {Panel1280x1024x75,0x0019,0x0001,15}, /* XGI_ExtLCD1280x1024x75Data */
+  {Panel1280x1024x75,0x0019,0x0000,16}, /* XGI_StLCD1280x1024x75Data */
+  {Panel1280x1024x75,0x0018,0x0010,17}, /* XGI_CetLCD1280x1024x75Data */
+  {PanelRef75Hz,0x0008,0x0008,18},	/* XGI_NoScalingDatax75 */
+  {0xFF,0x0000,0x0000,0}   		/* End of table */
+};
+
+XGI330_LCDDataTablStruct XGI_LCDDesDataTable[]=
+{
+  {Panel1024x768,0x0019,0x0001,0}, /* XGI_ExtLCDDes1024x768Data */
+  {Panel1024x768,0x0019,0x0000,1}, /* XGI_StLCDDes1024x768Data */
+  {Panel1024x768,0x0018,0x0010,2}, /* XGI_CetLCDDes1024x768Data */
+  {Panel1280x1024,0x0019,0x0001,3}, /* XGI_ExtLCDDes1280x1024Data */
+  {Panel1280x1024,0x0019,0x0000,4}, /* XGI_StLCDDes1280x1024Data */
+  {Panel1280x1024,0x0018,0x0010,5}, /* XGI_CetLCDDes1280x1024Data */
+  {Panel1400x1050,0x0019,0x0001,6}, /* XGI_ExtLCDDes1400x1050Data */
+  {Panel1400x1050,0x0019,0x0000,7}, /* XGI_StLCDDes1400x1050Data */
+  {Panel1400x1050,0x0418,0x0010,8}, /* XGI_CetLCDDes1400x1050Data */
+  {Panel1400x1050,0x0418,0x0410,9}, /* XGI_CetLCDDes1400x1050Data2 */
+  {Panel1600x1200,0x0019,0x0001,10}, /* XGI_ExtLCDDes1600x1200Data */
+  {Panel1600x1200,0x0019,0x0000,11}, /* XGI_StLCDDes1600x1200Data */
+  {PanelRef60Hz,0x0008,0x0008,12}, 	/* XGI_NoScalingDesData */
+  {Panel1024x768x75,0x0019,0x0001,13}, 	/* XGI_ExtLCDDes1024x768x75Data */
+  {Panel1024x768x75,0x0019,0x0000,14},	/* XGI_StLCDDes1024x768x75Data */
+  {Panel1024x768x75,0x0018,0x0010,15},  /* XGI_CetLCDDes1024x768x75Data */
+  {Panel1280x1024x75,0x0019,0x0001,16},	/* XGI_ExtLCDDes1280x1024x75Data */
+  {Panel1280x1024x75,0x0019,0x0000,17}, /* XGI_StLCDDes1280x1024x75Data */
+  {Panel1280x1024x75,0x0018,0x0010,18},	/* XGI_CetLCDDes1280x1024x75Data */
+  {PanelRef75Hz,0x0008,0x0008,19},	/* XGI_NoScalingDesDatax75 */
+  {0xFF,0x0000,0x0000,0}
+};
+
+XGI330_LCDDataTablStruct XGI_EPLLCDCRT1Ptr_H[]=
+{
+  {Panel1024x768,0x0018,0x0000,0}, /* XGI_LVDSCRT11024x768_1_H */
+  {Panel1024x768,0x0018,0x0010,1}, /* XGI_LVDSCRT11024x768_2_H */
+  {Panel1280x1024,0x0018,0x0000,2}, /* XGI_LVDSCRT11280x1024_1_H */
+  {Panel1280x1024,0x0018,0x0010,3}, /* XGI_LVDSCRT11280x1024_2_H */
+  {Panel1400x1050,0x0018,0x0000,4}, /* XGI_LVDSCRT11400x1050_1_H */
+  {Panel1400x1050,0x0018,0x0010,5}, /* XGI_LVDSCRT11400x1050_2_H */
+  {Panel1600x1200,0x0018,0x0000,6},  /* XGI_LVDSCRT11600x1200_1_H */
+  {Panel1024x768x75,0x0018,0x0000,7},	/* XGI_LVDSCRT11024x768_1_Hx75 */
+  {Panel1024x768x75,0x0018,0x0010,8},	/* XGI_LVDSCRT11024x768_2_Hx75 */
+  {Panel1280x1024x75,0x0018,0x0000,9},	/* XGI_LVDSCRT11280x1024_1_Hx75 */
+  {Panel1280x1024x75,0x0018,0x0010,10},	/* XGI_LVDSCRT11280x1024_2_Hx75 */
+  {0xFF,0x0000,0x0000,0}
+};
+
+XGI330_LCDDataTablStruct XGI_EPLLCDCRT1Ptr_V[]=
+{
+  {Panel1024x768,0x0018,0x0000,0}, /* XGI_LVDSCRT11024x768_1_V */
+  {Panel1024x768,0x0018,0x0010,1}, /* XGI_LVDSCRT11024x768_2_V */
+  {Panel1280x1024,0x0018,0x0000,2}, /* XGI_LVDSCRT11280x1024_1_V */
+  {Panel1280x1024,0x0018,0x0010,3}, /* XGI_LVDSCRT11280x1024_2_V */
+  {Panel1400x1050,0x0018,0x0000,4}, /* XGI_LVDSCRT11400x1050_1_V */
+  {Panel1400x1050,0x0018,0x0010,5}, /* XGI_LVDSCRT11400x1050_2_V */
+  {Panel1600x1200,0x0018,0x0000,6}, /* XGI_LVDSCRT11600x1200_1_V */
+  {Panel1024x768x75,0x0018,0x0000,7},	/* XGI_LVDSCRT11024x768_1_Vx75 */
+  {Panel1024x768x75,0x0018,0x0010,8},	/* XGI_LVDSCRT11024x768_2_Vx75 */
+  {Panel1280x1024x75,0x0018,0x0000,9},	/* XGI_LVDSCRT11280x1024_1_Vx75 */
+  {Panel1280x1024x75,0x0018,0x0010,10},	/* XGI_LVDSCRT11280x1024_2_Vx75 */
+  {0xFF,0x0000,0x0000,0}
+};
+
+XGI330_LCDDataTablStruct XGI_EPLLCDDataPtr[]=
+{
+  {Panel1024x768,0x0018,0x0000,0}, /* XGI_LVDS1024x768Data_1 */
+  {Panel1024x768,0x0018,0x0010,1}, /* XGI_LVDS1024x768Data_2 */
+  {Panel1280x1024,0x0018,0x0000,2}, /* XGI_LVDS1280x1024Data_1 */
+  {Panel1280x1024,0x0018,0x0010,3}, /* XGI_LVDS1280x1024Data_2 */
+  {Panel1400x1050,0x0018,0x0000,4}, /* XGI_LVDS1400x1050Data_1 */
+  {Panel1400x1050,0x0018,0x0010,5}, /* XGI_LVDS1400x1050Data_2 */
+  {Panel1600x1200,0x0018,0x0000,6}, /* XGI_LVDS1600x1200Data_1 */
+  {PanelRef60Hz,0x0008,0x0008,7}, /* XGI_LVDSNoScalingData */
+  {Panel1024x768x75,0x0018,0x0000,8},	/* XGI_LVDS1024x768Data_1x75 */
+  {Panel1024x768x75,0x0018,0x0010,9},	/* XGI_LVDS1024x768Data_2x75 */
+  {Panel1280x1024x75,0x0018,0x0000,10},	/* XGI_LVDS1280x1024Data_1x75 */
+  {Panel1280x1024x75,0x0018,0x0010,11}, /* XGI_LVDS1280x1024Data_2x75 */
+  {PanelRef75Hz,0x0008,0x0008,12},	/* XGI_LVDSNoScalingDatax75 */
+  {0xFF,0x0000,0x0000,0}
+};
+
+XGI330_LCDDataTablStruct XGI_EPLLCDDesDataPtr[]=
+{
+  {Panel1024x768,0x0018,0x0000,0}, /* XGI_LVDS1024x768Des_1 */
+  {Panel1024x768,0x0618,0x0410,1}, /* XGI_LVDS1024x768Des_3 */
+  {Panel1024x768,0x0018,0x0010,2}, /* XGI_LVDS1024x768Des_2 */
+  {Panel1280x1024,0x0018,0x0000,3}, /* XGI_LVDS1280x1024Des_1 */
+  {Panel1280x1024,0x0018,0x0010,4}, /* XGI_LVDS1280x1024Des_2 */
+  {Panel1400x1050,0x0018,0x0000,5}, /* XGI_LVDS1400x1050Des_1 */
+  {Panel1400x1050,0x0018,0x0010,6}, /* XGI_LVDS1400x1050Des_2 */
+  {Panel1600x1200,0x0018,0x0000,7}, /* XGI_LVDS1600x1200Des_1 */
+  {PanelRef60Hz,0x0008,0x0008,8}, 	/* XGI_LVDSNoScalingDesData */
+  {Panel1024x768x75,0x0018,0x0000,9},	/* XGI_LVDS1024x768Des_1x75 */
+  {Panel1024x768x75,0x0618,0x0410,10},	/* XGI_LVDS1024x768Des_3x75 */
+  {Panel1024x768x75,0x0018,0x0010,11},	/* XGI_LVDS1024x768Des_2x75 */
+  {Panel1280x1024x75,0x0018,0x0000,12},	/* XGI_LVDS1280x1024Des_1x75 */
+  {Panel1280x1024x75,0x0018,0x0010,13},	/* XGI_LVDS1280x1024Des_2x75 */
+  {PanelRef75Hz,0x0008,0x0008,14},	/* XGI_LVDSNoScalingDesDatax75 */
+  {0xFF,0x0000,0x0000,0}
+};
+
+XGI330_LCDDataTablStruct XGI_EPLCHLCDRegPtr[]=
+{
+  {Panel1024x768,0x0000,0x0000,0}, /* XGI_CH7017LV1024x768 */
+  {Panel1400x1050,0x0000,0x0000,1}, /* XGI_CH7017LV1400x1050 */
+  {0xFF,0x0000,0x0000,0}
+};
+
+XGI330_TVDataTablStruct XGI_TVDataTable[]=
+{
+ {0x09E1,0x0001,0},	/* XGI_ExtPALData */
+ {0x09E1,0x0000,1},	/* XGI_ExtNTSCData */
+ {0x09E1,0x0801,2},	/* XGI_StPALData */
+ {0x09E1,0x0800,3},	/* XGI_StNTSCData */
+ {0x49E0,0x0100,4},	/* XGI_ExtHiTVData */
+ {0x49E0,0x4100,5},	/* XGI_St2HiTVData */
+ {0x49E0,0x4900,13},	/* XGI_St1HiTVData */
+ {0x09E0,0x0020,6},	/* XGI_ExtYPbPr525iData */
+ {0x09E0,0x0040,7},	/* XGI_ExtYPbPr525pData */
+ {0x09E0,0x0080,8},	/* XGI_ExtYPbPr750pData */
+ {0x09E0,0x0820,9},	/* XGI_StYPbPr525iData */
+ {0x09E0,0x0840,10},	/* XGI_StYPbPr525pData */
+ {0x09E0,0x0880,11}, 	/* XGI_StYPbPr750pData */
+ {0xffff,0x0000,12}  	/* END */
+};
+
+USHORT TVLenList[]=
+{
+   LVDSCRT1Len_H,
+   LVDSCRT1Len_V,
+   LVDSDataLen,
+   0,
+   TVDataLen,
+   0,
+   0,
+   CHTVRegLen
+} ;
+
+/* Chrontel 7017 TV CRT1 Timing List */
+XGI330_TVDataTablStruct XGI_EPLCHTVCRT1Ptr[]=
+{
+  {0x0011,0x0000,0}, /* XGI_CHTVCRT1UNTSC */
+  {0x0011,0x0010,1}, /* XGI_CHTVCRT1ONTSC */
+  {0x0011,0x0001,2}, /* XGI_CHTVCRT1UPAL */
+  {0x0011,0x0011,3}, /* XGI_CHTVCRT1OPAL */
+  {0xFFFF,0x0000,4}
+};
+
+/* ;;Chrontel 7017 TV Timing List */
+XGI330_TVDataTablStruct XGI_EPLCHTVDataPtr[]=
+{
+  {0x0011,0x0000,0}, /* XGI_CHTVUNTSCData */
+  {0x0011,0x0010,1}, /* XGI_CHTVONTSCData */
+  {0x0011,0x0001,2}, /* XGI_CHTVUPALData */
+  {0x0011,0x0011,3}, /* XGI_CHTVOPALData */
+  {0xFFFF,0x0000,4}
+};
+
+/* ;;Chrontel 7017 TV Reg. List */
+XGI330_TVDataTablStruct XGI_EPLCHTVRegPtr[]=
+{
+  {0x0011,0x0000,0}, /* XGI_CHTVRegUNTSC */
+  {0x0011,0x0010,1}, /* XGI_CHTVRegONTSC */
+  {0x0011,0x0001,2}, /* XGI_CHTVRegUPAL */
+  {0x0011,0x0011,3}, /* XGI_CHTVRegOPAL */
+  {0xFFFF,0x0000,4}
+};
+
+USHORT LCDLenList[]=
+{
+   LVDSCRT1Len_H,
+   LVDSCRT1Len_V,
+   LVDSDataLen,
+   LCDDesDataLen,
+   LCDDataLen,
+   LCDDesDataLen,
+   0,
+   LCDDesDataLen,
+   LCDDesDataLen,
+   0
+} ;
+
+XGI330_LCDCapStruct  XGI660_LCDDLCapList[]=  /* 660, Dual link */
+{
+/* LCDCap1024x768 */
+		{Panel1024x768, DefaultLCDCap, 0, 0x014, 0x88, 0x06, VCLK65,
+		 0x6C, 0xC3, 0x35, 0x62, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10},
+/* LCDCap1280x1024 */
+                {Panel1280x1024, LCDDualLink+DefaultLCDCap, StLCDBToA, 0x053, 0x70, 0x03, VCLK108_2,
+		 0x70, 0x44, 0xF8, 0x2F, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1400x1050 */
+                {Panel1400x1050, LCDDualLink+DefaultLCDCap, StLCDBToA, 0x053, 0x70, 0x03, VCLK108_2,
+		 0x70, 0x44, 0xF8, 0x2F, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1600x1200 */
+                {Panel1600x1200, LCDDualLink+DefaultLCDCap, LCDToFull, 0x053, 0xC0, 0x03, VCLK162,
+		 0x43, 0x22, 0x70, 0x24, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1024x768x75 */
+		{Panel1024x768x75, DefaultLCDCap, 0, 0x014, 0x60, 0, VCLK78_75,
+		 0x2B, 0x61, 0x2B, 0x61, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10},
+/* LCDCap1280x1024x75 */
+                {Panel1280x1024x75, LCDDualLink+DefaultLCDCap, StLCDBToA, 0x053, 0x90, 0x03, VCLK135_5,
+		 0x54, 0x42, 0x4A, 0x61, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCapDefault */
+                {0xFF, DefaultLCDCap, 0, 0x053, 0x88, 0x06, VCLK65,
+		0x6C, 0xC3, 0x35, 0x62, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10}
+};
+
+XGI330_LCDCapStruct  XGI_LCDDLCapList[]=  /* Dual link only */
+{
+/* LCDCap1024x768 */
+		{Panel1024x768, DefaultLCDCap, 0, 0x012, 0x88, 0x06, VCLK65,
+		0x6C, 0xC3, 0x35, 0x62, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10},
+/* LCDCap1280x1024 */
+		{Panel1280x1024, LCDDualLink+DefaultLCDCap, StLCDBToA, 0x012, 0x70, 0x03, VCLK108_2,
+		0x70, 0x44, 0xF8, 0x2F, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1400x1050 */
+		{Panel1400x1050, LCDDualLink+DefaultLCDCap, StLCDBToA, 0x012, 0x70, 0x03, VCLK108_2,
+		 0x70, 0x44, 0xF8, 0x2F, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1600x1200 */
+		{Panel1600x1200, LCDDualLink+DefaultLCDCap, LCDToFull, 0x012, 0xC0, 0x03, VCLK162,
+		 0x43, 0x22, 0x70, 0x24, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1024x768x75 */
+		{Panel1024x768x75, DefaultLCDCap, 0, 0x012, 0x60, 0, VCLK78_75,
+		 0x2B, 0x61, 0x2B, 0x61, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10},
+/* LCDCap1280x1024x75 */
+		{Panel1280x1024x75, LCDDualLink+DefaultLCDCap, StLCDBToA, 0x012, 0x90, 0x03, VCLK135_5,
+		 0x54, 0x42, 0x4A, 0x61, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCapDefault */
+		{0xFF, DefaultLCDCap, 0, 0x012, 0x88, 0x06, VCLK65,
+		0x6C, 0xC3, 0x35, 0x62, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10}
+};
+
+XGI330_LCDCapStruct  XGI660_LCDCapList[]=
+{
+/* LCDCap1024x768 */
+                {Panel1024x768, DefaultLCDCap, 0, 0x014, 0x88, 0x06, VCLK65,
+		0x6C, 0xC3, 0x35, 0x62, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10},
+/* LCDCap1280x1024 */
+                {Panel1280x1024, DefaultLCDCap, StLCDBToA, 0x053, 0x70, 0x03, VCLK108_2,
+		0x70, 0x44, 0xF8, 0x2F, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1400x1050 */
+                {Panel1400x1050, DefaultLCDCap, StLCDBToA, 0x053, 0x70, 0x03, VCLK108_2,
+		 0x70, 0x44, 0xF8, 0x2F, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1600x1200 */
+                {Panel1600x1200, DefaultLCDCap, LCDToFull, 0x053, 0xC0, 0x03, VCLK162,
+		 0x5A, 0x23, 0x5A, 0x23, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1024x768x75 */
+		{Panel1024x768x75, DefaultLCDCap, 0, 0x014, 0x60, 0, VCLK78_75,
+		 0x2B, 0x61, 0x2B, 0x61, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10},
+/* LCDCap1280x1024x75 */
+                {Panel1280x1024x75,+DefaultLCDCap, StLCDBToA, 0x053, 0x90, 0x03, VCLK135_5,
+		 0x54, 0x42, 0x4A, 0x61, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCapDefault */
+                {0xFF, DefaultLCDCap, 0, 0x053, 0x88, 0x06, VCLK65,
+		0x6C, 0xC3, 0x35, 0x62, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10}
+};
+
+XGI330_LCDCapStruct  XGI_LCDCapList[]=
+{
+/* LCDCap1024x768 */
+		{Panel1024x768, DefaultLCDCap, 0, 0x012, 0x88, 0x06, VCLK65,
+		0x6C, 0xC3, 0x35, 0x62, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10},
+/* LCDCap1280x1024 */
+		{Panel1280x1024, DefaultLCDCap, StLCDBToA, 0x012, 0x70, 0x03, VCLK108_2,
+		0x70, 0x44, 0xF8, 0x2F, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1400x1050 */
+		{Panel1400x1050, DefaultLCDCap, StLCDBToA, 0x012, 0x70, 0x03, VCLK108_2,
+		 0x70, 0x44, 0xF8, 0x2F, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1600x1200 */
+		{Panel1600x1200, DefaultLCDCap, LCDToFull, 0x012, 0xC0, 0x03, VCLK162,
+		 0x5A, 0x23, 0x5A, 0x23, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1024x768x75 */
+		{Panel1024x768x75, DefaultLCDCap, 0, 0x012, 0x60, 0, VCLK78_75,
+		 0x2B, 0x61, 0x2B, 0x61, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10},
+/* LCDCap1280x1024x75 */
+		{Panel1280x1024x75, DefaultLCDCap, StLCDBToA, 0x012, 0x90, 0x03, VCLK135_5,
+		 0x54, 0x42, 0x4A, 0x61, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCapDefault */
+		{0xFF, DefaultLCDCap, 0, 0x012, 0x88, 0x06, VCLK65,
+		0x6C, 0xC3, 0x35, 0x62, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10}
+};
+
+XGI21_LVDSCapStruct XGI21_LCDCapList[]=
+{
+    {DisableLCD24bpp + LCDPolarity,
+     2160,1250,1600,1200,  64,  1,  192,   3,
+     0x70,0x24,0x20,0x04,0x0A,0x02,0xC8
+    },
+    {DisableLCD24bpp + LCDPolarity,
+     1688,1066,1280,1024,  48,  1,  112,   3,
+     0x70,0x44,0x20,0x04,0x0A,0x02,0xC8
+    },
+    {DisableLCD24bpp + LCDPolarity + (LCDPolarity << 8),
+     1344, 806,1024, 768,  24,  3,  136,   6,
+     0x6C,0x65,0x20,0x04,0x0A,0x02,0xC8
+    },
+    {DisableLCD24bpp + LCDPolarity,
+     1056, 628, 800, 600,  40,   1, 128,   4,
+     0x42,0xE2,0x20,0x14,0x0A,0x02,0x00
+    },
+    {DisableLCD24bpp + LCDPolarity,
+      928, 525, 800, 480,  40,  13,  48,   3,
+     0x52,0xC5,0x20,0x14,0x0A,0x02,0x00
+    },
+    {DisableLCD24bpp + LCDPolarity + (LCDPolarity << 8),
+      800, 525, 640, 480,  16,  10,  96,   2,
+     0x1B,0xE1,0x20,0x04,0x0A,0x02,0xC8
+    }
+    
+};
+
+XGI_Ext2Struct XGI330_RefIndex[]=
+{
+{Support32Bpp + SupportAllCRT2 + SyncPN,			RES320x200,	 VCLK25_175, 0x00,0x10,0x59, 320, 200},/* 00 */
+{Support32Bpp + SupportAllCRT2 + SyncPN,			RES320x200,	 VCLK25_175, 0x00,0x10,0x00, 320, 400},/* 01 */
+{Support32Bpp + SupportAllCRT2 + SyncNN,			RES320x240,	 VCLK25_175, 0x04,0x20,0x50, 320, 240},/* 02 */
+{Support32Bpp + SupportAllCRT2 + SyncPP,			RES400x300,	 VCLK40,     0x05,0x32,0x51, 400, 300},/* 03 */
+{Support32Bpp + NoSupportTV + SyncNN + SupportTV1024,		RES512x384,	 VCLK65,     0x06,0x43,0x52, 512, 384},/* 04 */
+{Support32Bpp + SupportAllCRT2 + SyncPN,			RES640x400,	 VCLK25_175, 0x00,0x14,0x2f, 640, 400},/* 05 */
+{Support32Bpp + SupportAllCRT2 + SyncNN,			RES640x480x60,	 VCLK25_175, 0x04,0x24,0x2e, 640, 480},/* 06 640x480x60Hz (LCD 640x480x60z) */
+{Support32Bpp + NoSupportHiVisionTV + SyncNN,			RES640x480x72,	 VCLK31_5,   0x04,0x24,0x2e, 640, 480},/* 07 640x480x72Hz (LCD 640x480x70Hz) */
+{Support32Bpp + NoSupportHiVisionTV + SyncNN,			RES640x480x75,	 VCLK31_5,   0x47,0x24,0x2e, 640, 480},/* 08 640x480x75Hz (LCD 640x480x75Hz) */
+{Support32Bpp + SupportRAMDAC2 + SyncNN,			RES640x480x85,	 VCLK36,     0x8A,0x24,0x2e, 640, 480},/* 09 640x480x85Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPN,			RES640x480x100,	 VCLK43_163, 0x00,0x24,0x2e, 640, 480},/* 0a 640x480x100Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPN,			RES640x480x120,	 VCLK52_406, 0x00,0x24,0x2e, 640, 480},/* 0b 640x480x120Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPN,			RES640x480x160,	 VCLK72_852, 0x00,0x24,0x2e, 640, 480},/* 0c 640x480x160Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncNN,			RES640x480x200,	 VCLK86_6,   0x00,0x24,0x2e, 640, 480},/* 0d 640x480x200Hz */
+{Support32Bpp + NoSupportLCD + SyncPP,				RES800x600x56,	 VCLK36,     0x05,0x36,0x6a, 800, 600},/* 0e 800x600x56Hz */
+{Support32Bpp + NoSupportTV + SyncPP,				RES800x600x60,	 VCLK40,     0x05,0x36,0x6a, 800, 600},/* 0f 800x600x60Hz (LCD 800x600x60Hz) */
+{Support32Bpp + NoSupportHiVisionTV + SyncPP,			RES800x600x72,	 VCLK50,     0x48,0x36,0x6a, 800, 600},/* 10 800x600x72Hz (LCD 800x600x70Hz) */
+{Support32Bpp + NoSupportHiVisionTV + SyncPP,			RES800x600x75,	 VCLK49_5,   0x8B,0x36,0x6a, 800, 600},/* 11 800x600x75Hz (LCD 800x600x75Hz) */
+{Support32Bpp + SupportRAMDAC2 + SyncPP,			RES800x600x85,	 VCLK56_25,  0x00,0x36,0x6a, 800, 600},/* 12 800x600x85Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPN,			RES800x600x100,	 VCLK68_179, 0x00,0x36,0x6a, 800, 600},/* 13 800x600x100Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPN,			RES800x600x120,	 VCLK83_95,  0x00,0x36,0x6a, 800, 600},/* 14 800x600x120Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPN,			RES800x600x160,	 VCLK116_406,0x00,0x36,0x6a, 800, 600},/* 15 800x600x160Hz */
+{Support32Bpp + InterlaceMode + SyncPP,				RES1024x768x43,	 VCLK44_9,   0x00,0x47,0x37,1024, 768},/* 16 1024x768x43Hz */
+{Support32Bpp + NoSupportTV + SyncNN + SupportTV1024,		RES1024x768x60,	 VCLK65,     0x06,0x47,0x37,1024, 768},/* 17 1024x768x60Hz (LCD 1024x768x60Hz) */
+{Support32Bpp + NoSupportHiVisionTV + SyncNN,			RES1024x768x70,	 VCLK75,     0x49,0x47,0x37,1024, 768},/* 18 1024x768x70Hz (LCD 1024x768x70Hz) */
+{Support32Bpp + NoSupportHiVisionTV + SyncPP,			RES1024x768x75,	 VCLK78_75,  0x00,0x47,0x37,1024, 768},/* 19 1024x768x75Hz (LCD 1024x768x75Hz) */
+{Support32Bpp + SupportRAMDAC2 + SyncPP,			RES1024x768x85,	 VCLK94_5,   0x8C,0x47,0x37,1024, 768},/* 1a 1024x768x85Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPN,			RES1024x768x100, VCLK113_309,0x00,0x47,0x37,1024, 768},/* 1b 1024x768x100Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPN,			RES1024x768x120, VCLK139_054,0x00,0x47,0x37,1024, 768},/* 1c 1024x768x120Hz */
+{Support32Bpp + SupportLCD + SyncPP,				RES1280x960x60,	 VCLK108_2,  0x08,0x58,0x7b,1280, 960},/* 1d 1280x960x60Hz */
+{Support32Bpp + InterlaceMode + SyncPP,				RES1280x1024x43, VCLK78_75,  0x00,0x58,0x3a,1280,1024},/* 1e 1280x1024x43Hz */
+{Support32Bpp + NoSupportTV + SyncPP,				RES1280x1024x60, VCLK108_2,  0x07,0x58,0x3a,1280,1024},/* 1f 1280x1024x60Hz (LCD 1280x1024x60Hz) */
+{Support32Bpp + NoSupportTV + SyncPP,				RES1280x1024x75, VCLK135_5,  0x00,0x58,0x3a,1280,1024},/* 20 1280x1024x75Hz (LCD 1280x1024x75Hz) */
+{Support32Bpp + SyncPP,						RES1280x1024x85, VCLK157_5,  0x00,0x58,0x3a,1280,1024},/* 21 1280x1024x85Hz */
+{Support32Bpp + SupportLCD + SyncPP + SupportCRT2in301C,	RES1600x1200x60, VCLK162,    0x09,0x7A,0x3c,1600,1200},/* 22 1600x1200x60Hz */
+{Support32Bpp + SyncPP + SupportCRT2in301C,			RES1600x1200x65, VCLK175,    0x00,0x69,0x3c,1600,1200},/* 23 1600x1200x65Hz */
+{Support32Bpp + SyncPP + SupportCRT2in301C,			RES1600x1200x70, VCLK189,    0x00,0x69,0x3c,1600,1200},/* 24 1600x1200x70Hz */
+{Support32Bpp + SyncPP + SupportCRT2in301C,			RES1600x1200x75, VCLK202_5,  0x00,0x69,0x3c,1600,1200},/* 25 1600x1200x75Hz */
+{Support32Bpp + SyncPP,						RES1600x1200x85, VCLK229_5,  0x00,0x69,0x3c,1600,1200},/* 26 1600x1200x85Hz */
+{Support32Bpp + SyncPP,						RES1600x1200x100,VCLK269_655,0x00,0x69,0x3c,1600,1200},/* 27 1600x1200x100Hz */
+{Support32Bpp + SyncPP,						RES1600x1200x120,VCLK323_586,0x00,0x69,0x3c,1600,1200},/* 28 1600x1200x120Hz */
+{Support32Bpp + SupportLCD + SyncNP,				RES1920x1440x60, VCLK234,    0x00,0x00,0x68,1920,1440},/* 29 1920x1440x60Hz */
+{Support32Bpp + SyncPN,						RES1920x1440x65, VCLK254_817,0x00,0x00,0x68,1920,1440},/* 2a 1920x1440x65Hz */
+{Support32Bpp + SyncPN,						RES1920x1440x70, VCLK277_015,0x00,0x00,0x68,1920,1440},/* 2b 1920x1440x70Hz */
+{Support32Bpp + SyncPN,						RES1920x1440x75, VCLK291_132,0x00,0x00,0x68,1920,1440},/* 2c 1920x1440x75Hz */
+{Support32Bpp + SyncPN,						RES1920x1440x85, VCLK330_615,0x00,0x00,0x68,1920,1440},/* 2d 1920x1440x85Hz */
+{Support16Bpp + SyncPN,						RES1920x1440x100,VCLK388_631,0x00,0x00,0x68,1920,1440},/* 2e 1920x1440x100Hz */
+{Support32Bpp + SupportLCD + SyncPN,				RES2048x1536x60, VCLK266_952,0x00,0x00,0x6c,2048,1536},/* 2f 2048x1536x60Hz */
+{Support32Bpp + SyncPN,						RES2048x1536x65, VCLK291_766,0x00,0x00,0x6c,2048,1536},/* 30 2048x1536x65Hz */
+{Support32Bpp + SyncPN,						RES2048x1536x70, VCLK315_195,0x00,0x00,0x6c,2048,1536},/* 31 2048x1536x70Hz */
+{Support32Bpp + SyncPN,						RES2048x1536x75, VCLK340_477,0x00,0x00,0x6c,2048,1536},/* 32 2048x1536x75Hz */
+{Support16Bpp + SyncPN,						RES2048x1536x85, VCLK375_847,0x00,0x00,0x6c,2048,1536},/* 33 2048x1536x85Hz */
+{Support32Bpp + SupportHiVisionTV + SupportRAMDAC2 + SyncPP + SupportYPbPr,	RES800x480x60,	 VCLK39_77,  0x08,0x00,0x70, 800, 480},/* 34 800x480x60Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPP,			RES800x480x75,	 VCLK49_5,   0x08,0x00,0x70, 800, 480},/* 35 800x480x75Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPP,			RES800x480x85,	 VCLK56_25,  0x08,0x00,0x70, 800, 480},/* 36 800x480x85Hz */
+{Support32Bpp + SupportHiVisionTV + SupportRAMDAC2 + SyncPP + SupportYPbPr,	RES1024x576x60,	 VCLK65,     0x09,0x00,0x71,1024, 576},/* 37 1024x576x60Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPP,			RES1024x576x75,	 VCLK78_75,  0x09,0x00,0x71,1024, 576},/* 38 1024x576x75Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPP,			RES1024x576x85,	 VCLK94_5,   0x09,0x00,0x71,1024, 576},/* 39 1024x576x85Hz */
+{Support32Bpp + SupportHiVisionTV + SupportRAMDAC2 + SyncPP + SupportYPbPr,	RES1280x720x60,	 VCLK108_2,  0x0A,0x00,0x75,1280, 720},/* 3a 1280x720x60Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPP,			RES1280x720x75,	 VCLK135_5,  0x0A,0x00,0x75,1280, 720},/* 3b 1280x720x75Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPP,			RES1280x720x85,	 VCLK157_5,  0x0A,0x00,0x75,1280, 720},/* 3c 1280x720x85Hz */
+{Support32Bpp + SupportTV + SyncNN,				RES720x480x60,	 VCLK28_322, 0x06,0x00,0x31, 720, 480},/* 3d 720x480x60Hz */
+{Support32Bpp + SupportTV + SyncPP,				RES720x576x56,	 VCLK36,     0x06,0x00,0x32, 720, 576},/* 3e 720x576x56Hz */
+{Support32Bpp + InterlaceMode + NoSupportLCD + SyncPP,		RES856x480x79I,	 VCLK35_2,   0x00,0x00,0x00, 856, 480},/* 3f 856x480x79I */
+{Support32Bpp + NoSupportLCD + SyncNN,				RES856x480x60,	 VCLK35_2,   0x00,0x00,0x00, 856, 480},/* 40 856x480x60Hz */
+{Support32Bpp + NoSupportHiVisionTV + SyncPP,			RES1280x768x60,	 VCLK79_411, 0x08,0x48,0x23,1280, 768},/* 41 1280x768x60Hz */
+{Support32Bpp + NoSupportHiVisionTV + SyncPP,			RES1400x1050x60, VCLK122_61, 0x08,0x69,0x26,1400,1050},/* 42 1400x1050x60Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPP,			RES1152x864x60,	 VCLK80_350, 0x37,0x00,0x20,1152, 864},/* 43 1152x864x60Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPP,			RES1152x864x75,	 VCLK107_385,0x37,0x00,0x20,1152, 864},/* 44 1152x864x75Hz */
+{Support32Bpp + SupportLCD + SupportRAMDAC2 + SyncPP,		RES1280x960x75,	 VCLK125_999,0x3A,0x88,0x7b,1280, 960},/* 45 1280x960x75Hz */
+{Support32Bpp + SupportLCD + SupportRAMDAC2 + SyncPP,		RES1280x960x85,	 VCLK148_5,  0x0A,0x88,0x7b,1280, 960},/* 46 1280x960x85Hz */
+{Support32Bpp + SupportLCD + SupportRAMDAC2 + SyncPP,		RES1280x960x120, VCLK217_325,0x3A,0x88,0x7b,1280, 960},/* 47 1280x960x120Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPN,			RES1024x768x160, VCLK139_054,0x30,0x47,0x37,1024, 768},/* 48 1024x768x160Hz */
+};
+
+
+
+XGI330_VCLKDataStruct XGI330_VCLKData[]=
+{
+ { 0x1b,0xe1, 25}, /* 0x0 */
+ { 0x4e,0xe4, 28}, /* 0x1 */
+ { 0x57,0xe4, 31}, /* 0x2 */
+ { 0xc3,0xc8, 36}, /* 0x3 */
+ { 0x42,0xe2, 40}, /* 0x4 */
+ { 0xfe,0xcd, 43}, /* 0x5 */
+ { 0x5d,0xc4, 44}, /* 0x6 */
+ { 0x52,0xe2, 49}, /* 0x7 */
+ { 0x53,0xe2, 50}, /* 0x8 */
+ { 0x74,0x67, 52}, /* 0x9 */
+ { 0x6d,0x66, 56}, /* 0xa */
+ { 0x6c,0xc3, 65}, /* 0xb */
+ { 0x46,0x44, 67}, /* 0xc */
+ { 0xb1,0x46, 68}, /* 0xd */
+ { 0xd3,0x4a, 72}, /* 0xe */
+ { 0x29,0x61, 75}, /* 0xf */
+ { 0x6e,0x46, 76}, /* 0x10 */
+ { 0x2b,0x61, 78}, /* 0x11 */
+ { 0x31,0x42, 79}, /* 0x12 */
+ { 0xab,0x44, 83}, /* 0x13 */
+ { 0x46,0x25, 84}, /* 0x14 */
+ { 0x78,0x29, 86}, /* 0x15 */
+ { 0x62,0x44, 94}, /* 0x16 */
+ { 0x2b,0x41,104}, /* 0x17 */
+ { 0x3a,0x23,105}, /* 0x18 */
+ { 0x70,0x44,108}, /* 0x19 */
+ { 0x3c,0x23,109}, /* 0x1a */
+ { 0x5e,0x43,113}, /* 0x1b */
+ { 0xbc,0x44,116}, /* 0x1c */
+ { 0xe0,0x46,132}, /* 0x1d */
+ { 0x54,0x42,135}, /* 0x1e */
+ { 0xea,0x2a,139}, /* 0x1f */
+ { 0x41,0x22,157}, /* 0x20 */
+ { 0x70,0x24,162}, /* 0x21 */
+ { 0x30,0x21,175}, /* 0x22 */
+ { 0x4e,0x22,189}, /* 0x23 */
+ { 0xde,0x26,194}, /* 0x24 */
+ { 0x62,0x06,202}, /* 0x25 */
+ { 0x3f,0x03,229}, /* 0x26 */
+ { 0xb8,0x06,234}, /* 0x27 */
+ { 0x34,0x02,253}, /* 0x28 */
+ { 0x58,0x04,255}, /* 0x29 */
+ { 0x24,0x01,265}, /* 0x2a */
+ { 0x9b,0x02,267}, /* 0x2b */
+ { 0x70,0x05,270}, /* 0x2c */
+ { 0x25,0x01,272}, /* 0x2d */
+ { 0x9c,0x02,277}, /* 0x2e */
+ { 0x27,0x01,286}, /* 0x2f */
+ { 0x3c,0x02,291}, /* 0x30 */
+ { 0xef,0x0a,292}, /* 0x31 */
+ { 0xf6,0x0a,310}, /* 0x32 */
+ { 0x95,0x01,315}, /* 0x33 */
+ { 0xf0,0x09,324}, /* 0x34 */
+ { 0xfe,0x0a,331}, /* 0x35 */
+ { 0xf3,0x09,332}, /* 0x36 */
+ { 0xea,0x08,340}, /* 0x37 */
+ { 0xe8,0x07,376}, /* 0x38 */
+ { 0xde,0x06,389}, /* 0x39 */
+ { 0x52,0x2a, 54}, /* 0x3a */
+ { 0x52,0x6a, 27}, /* 0x3b */
+ { 0x62,0x24, 70}, /* 0x3c */
+ { 0x62,0x64, 70}, /* 0x3d */
+ { 0xa8,0x4c, 30}, /* 0x3e */
+ { 0x20,0x26, 33}, /* 0x3f */
+ { 0x31,0xc2, 39}, /* 0x40 */
+ { 0x60,0x36, 30}, /* 0x41 */
+ { 0x40,0x4A, 28}, /* 0x42 */
+ { 0x9F,0x46, 44}, /* 0x43 */
+ { 0x97,0x2C, 26}, /* 0x44 */
+ { 0x44,0xE4, 25}, /* 0x45 */
+ { 0x7E,0x32, 47}, /* 0x46 */
+ { 0x08,0x24, 31}, /* 0x47 */
+ { 0x97,0x2c, 26}, /* 0x48 */
+ { 0xCE,0x3c, 39}, /* 0x49 */
+ { 0x52,0x4A, 36}, /* 0x4a */
+ { 0x2C,0x61, 95}, /* 0x4b */
+ { 0x78,0x27,108}, /* 0x4c */
+ { 0x66,0x43,123},  /* 0x4d */
+ { 0x2c,0x61, 80},  /* 0x4e */
+ { 0x3b,0x61,108}  /* 0x4f */
+};
+
+XGI_VBVCLKDataStruct XGI330_VBVCLKData[]=
+{
+ { 0x1b,0xe1, 25}, /* 0x0 */
+ { 0x4e,0xe4, 28}, /* 0x1 */
+ { 0x57,0xe4, 31}, /* 0x2 */
+ { 0xc3,0xc8, 36}, /* 0x3 */
+ { 0x42,0x47, 40}, /* 0x4 */
+ { 0xfe,0xcd, 43}, /* 0x5 */
+ { 0x5d,0xc4, 44}, /* 0x6 */
+ { 0x52,0x47, 49}, /* 0x7 */
+ { 0x53,0x47, 50}, /* 0x8 */
+ { 0x74,0x67, 52}, /* 0x9 */
+ { 0x6d,0x66, 56}, /* 0xa */
+ { 0x5a,0x64, 65}, /* 0xb */
+ { 0x46,0x44, 67}, /* 0xc */
+ { 0xb1,0x46, 68}, /* 0xd */
+ { 0xd3,0x4a, 72}, /* 0xe */
+ { 0x29,0x61, 75}, /* 0xf */
+ { 0x6d,0x46, 75}, /* 0x10 */
+ { 0x41,0x43, 78}, /* 0x11 */
+ { 0x31,0x42, 79}, /* 0x12 */
+ { 0xab,0x44, 83}, /* 0x13 */
+ { 0x46,0x25, 84}, /* 0x14 */
+ { 0x78,0x29, 86}, /* 0x15 */
+ { 0x62,0x44, 94}, /* 0x16 */
+ { 0x2b,0x22,104}, /* 0x17 */
+ { 0x49,0x24,105}, /* 0x18 */
+ { 0xf8,0x2f,108}, /* 0x19 */
+ { 0x3c,0x23,109}, /* 0x1a */
+ { 0x5e,0x43,113}, /* 0x1b */
+ { 0xbc,0x44,116}, /* 0x1c */
+ { 0xe0,0x46,132}, /* 0x1d */
+ { 0xd4,0x28,135}, /* 0x1e */
+ { 0xea,0x2a,139}, /* 0x1f */
+ { 0x41,0x22,157}, /* 0x20 */
+ { 0x70,0x24,162}, /* 0x21 */
+ { 0x30,0x21,175}, /* 0x22 */
+ { 0x4e,0x22,189}, /* 0x23 */
+ { 0xde,0x26,194}, /* 0x24 */
+ { 0x70,0x07,202}, /* 0x25 */
+ { 0x3f,0x03,229}, /* 0x26 */
+ { 0xb8,0x06,234}, /* 0x27 */
+ { 0x34,0x02,253}, /* 0x28 */
+ { 0x58,0x04,255}, /* 0x29 */
+ { 0x24,0x01,265}, /* 0x2a */
+ { 0x9b,0x02,267}, /* 0x2b */
+ { 0x70,0x05,270}, /* 0x2c */
+ { 0x25,0x01,272}, /* 0x2d */
+ { 0x9c,0x02,277}, /* 0x2e */
+ { 0x27,0x01,286}, /* 0x2f */
+ { 0x3c,0x02,291}, /* 0x30 */
+ { 0xef,0x0a,292}, /* 0x31 */
+ { 0xf6,0x0a,310}, /* 0x32 */
+ { 0x95,0x01,315}, /* 0x33 */
+ { 0xf0,0x09,324}, /* 0x34 */
+ { 0xfe,0x0a,331}, /* 0x35 */
+ { 0xf3,0x09,332}, /* 0x36 */
+ { 0xea,0x08,340}, /* 0x37 */
+ { 0xe8,0x07,376}, /* 0x38 */
+ { 0xde,0x06,389}, /* 0x39 */
+ { 0x52,0x2a, 54}, /* 0x3a */
+ { 0x52,0x6a, 27}, /* 0x3b */
+ { 0x62,0x24, 70}, /* 0x3c */
+ { 0x62,0x64, 70}, /* 0x3d */
+ { 0xa8,0x4c, 30}, /* 0x3e */
+ { 0x20,0x26, 33}, /* 0x3f */
+ { 0x31,0xc2, 39}, /* 0x40 */
+ { 0x2e,0x48, 25}, /* 0x41 */
+ { 0x24,0x46, 25}, /* 0x42 */
+ { 0x26,0x64, 28}, /* 0x43 */
+ { 0x37,0x64, 40}, /* 0x44 */
+ { 0xa1,0x42,108}, /* 0x45 */
+ { 0x37,0x61,100}, /* 0x46 */
+ { 0x78,0x27,108}, /* 0x47 */
+ { 0x5e,0x64,68},  /* 0x48 chiawen for fuj1280x768*/
+ { 0x70,0x44,108}, /* 0x49 chiawen for 1400x1050*/
+};
+
+UCHAR XGI330_ScreenOffset[]={ 0x14,0x19,0x20,0x28,0x32,0x40,0x50,0x64,0x78,0x80,0x2d,0x35,0x57,0x48 };
+
+XGI_StResInfoStruct XGI330_StResInfo[]=
+{
+ { 640,400},
+ { 640,350},
+ { 720,400},
+ { 720,350},
+ { 640,480}
+};
+
+XGI_ModeResInfoStruct XGI330_ModeResInfo[]=
+{
+ {  320, 200, 8, 8},
+ {  320, 240, 8, 8},
+ {  320, 400, 8, 8},
+ {  400, 300, 8, 8},
+ {  512, 384, 8, 8},
+ {  640, 400, 8,16},
+ {  640, 480, 8,16},
+ {  800, 600, 8,16},
+ { 1024, 768, 8,16},
+ { 1280,1024, 8,16},
+ { 1600,1200, 8,16},
+ { 1920,1440, 8,16},
+ { 2048,1536, 8,16},
+ {  720, 480, 8,16},
+ {  720, 576, 8,16},
+ { 1280, 960, 8,16},
+ {  800, 480, 8,16},
+ { 1024, 576, 8,16},
+ { 1280, 720, 8,16},
+ {  856, 480, 8,16},
+ { 1280, 768, 8,16},
+ { 1400,1050, 8,16},
+ { 1152, 864, 8,16}
+};
+
+UCHAR XGI330_OutputSelect =0x40;
+UCHAR XGI330_SoftSetting = 0x30;
+UCHAR XGI330_SR07=0x18;
+UCHAR XGI330New_SR15[8][8]={
+{0x0,0x4,0x60,0x60},
+{0xf,0xf,0xf,0xf},
+{0xba,0xba,0xba,0xba},
+{0xa9,0xa9,0xac,0xac},
+{0xa0,0xa0,0xa0,0xa8},
+{0x0,0x0,0x2,0x2},
+{0x30,0x30,0x40,0x40},
+{0x0,0xa5,0xfb,0xf6}
+};
+
+UCHAR XGI330New_CR40[5][8]={
+{0x77,0x77,0x44,0x44},
+{0x77,0x77,0x44,0x44},
+{0x0,0x0,0x0,0x0},
+{0x5b,0x5b,0xab,0xab},
+{0x0,0x0,0xf0,0xf8}
+};
+
+UCHAR XGI330_CR49[]={0xaa,0x88};
+UCHAR XGI330_SR1F=0x0;
+UCHAR XGI330_SR21=0xa3;
+UCHAR XGI330_650_SR21=0xa7;
+UCHAR XGI330_SR22=0xfb;
+UCHAR XGI330_SR23=0xf6;
+UCHAR XGI330_SR24=0xd;
+
+UCHAR XGI660_SR21=0xa3;/* 2003.0312 */
+UCHAR XGI660_SR22=0xf3;/* 2003.0312 */
+
+UCHAR XGI330_LVDS_SR32=0x00;   /* ynlai for 650 LVDS */
+UCHAR XGI330_LVDS_SR33=0x00;	/* chiawen for 650 LVDS */
+UCHAR XGI330_650_SR31=0x40;
+UCHAR XGI330_650_SR33=0x04;
+UCHAR XGI330_CRT2Data_1_2 = 0x0;
+UCHAR XGI330_CRT2Data_4_D = 0x0;
+UCHAR XGI330_CRT2Data_4_E = 0x0;
+UCHAR XGI330_CRT2Data_4_10 = 0x80;
+USHORT XGI330_RGBSenseData = 0xd1;
+USHORT XGI330_VideoSenseData = 0xb9;
+USHORT XGI330_YCSenseData = 0xb3;
+USHORT XGI330_RGBSenseData2 = 0x0190;     /*301b*/
+USHORT XGI330_VideoSenseData2 = 0x0110;
+USHORT XGI330_YCSenseData2 = 0x016B;
+UCHAR XGI330_NTSCPhase[] = {0x21,0xed,0x8a,0x8};
+UCHAR XGI330_PALPhase[] = {0x2a,0x5,0xd3,0x0};
+UCHAR XGI330_NTSCPhase2[] = {0x21,0xF0,0x7B,0xD6};/*301b*/
+UCHAR XGI330_PALPhase2[] = {0x2a,0x09,0x86,0xe9};
+UCHAR XGI330_PALMPhase[] = {0x21,0xE4,0x2E,0x9B};   /*palmn*/
+UCHAR XGI330_PALNPhase[] = {0x21,0xF4,0x3E,0xBA};
+UCHAR XG40_I2CDefinition = 0x00 ;
+UCHAR XG20_CR97 = 0x10 ;
+
+UCHAR XG21_DVOSetting = 0x00 ;
+UCHAR XG21_CR2E = 0x00 ;
+UCHAR XG21_CR2F = 0x00 ;
+UCHAR XG21_CR46 = 0x00 ;
+UCHAR XG21_CR47 = 0x00 ;
+
+UCHAR XG27_CR97 = 0xC1 ;
+UCHAR XG27_SR36 = 0x30 ;
+UCHAR XG27_CR8F = 0x0C ;
+UCHAR XG27_CRD0[] = {0,0,0,0,0,0,0,0x82,0x00,0x66,0x01,0x00} ;
+UCHAR XG27_CRDE[] = {0,0} ;
+UCHAR XG27_SR40 = 0x04 ;
+UCHAR XG27_SR41 = 0x00 ;
+
+UCHAR XGI330_CHTVVCLKUNTSC[]={0x00 };
+
+UCHAR XGI330_CHTVVCLKONTSC[]={0x00 };
+
+UCHAR XGI330_CHTVVCLKUPAL[]={0x00 };
+
+UCHAR XGI330_CHTVVCLKOPAL[]={0x00 };
+
+UCHAR XGI7007_CHTVVCLKUNTSC[]={CH7007TVVCLK30_2,
+                               CH7007TVVCLK30_2,
+                               CH7007TVVCLK30_2,
+                               CH7007TVVCLK30_2,
+                               CH7007TVVCLK28_1,
+                               CH7007TVVCLK47_8
+                              };
+
+UCHAR XGI7007_CHTVVCLKONTSC[]={CH7007TVVCLK26_4,
+                               CH7007TVVCLK26_4,
+                               CH7007TVVCLK26_4,
+                               CH7007TVVCLK26_4,
+                               CH7007TVVCLK24_6,
+                               CH7007TVVCLK43_6
+                              };
+
+UCHAR XGI7007_CHTVVCLKUPAL[]={CH7007TVVCLK31_5,
+                              CH7007TVVCLK31_5,
+                              CH7007TVVCLK31_5,
+                              CH7007TVVCLK31_5,
+                              CH7007TVVCLK26_2,
+                              CH7007TVVCLK39
+                             };
+
+UCHAR XGI7007_CHTVVCLKOPAL[]={CH7007TVVCLK31_5,
+                              CH7007TVVCLK31_5,
+                              CH7007TVVCLK31_5,
+                              CH7007TVVCLK31_5,
+                              CH7007TVVCLK26_2,
+                              CH7007TVVCLK36
+                             };
+
+XGI330_VCLKDataStruct XGI_CH7007VCLKData[]=
+{
+ { 0x60,0x36,30},  /* 0 30.2 MHZ */
+ { 0x40,0x4A,28},  /* 1 28.19 MHZ */
+ { 0x9F,0x46,44},  /* 2 43.6 MHZ */
+ { 0x97,0x2C,26},  /* 3 26.4 MHZ */
+ { 0x44,0xE4,25},  /* 4 24.6 MHZ */
+ { 0x7E,0x32,47},  /* 5 47.832 MHZ */
+ { 0x8A,0x24,31},  /* 6 31.5 MHZ */
+ { 0x97,0x2C,26},  /* 7 26.2 MHZ */
+ { 0xCE,0x3C,39},  /* 8 39 MHZ   */
+ { 0x52,0x4A,36},  /* 9 36 MHZ   */
+ { 0xFF,0x00,0 }   /* End mark      */
+};
+
+XGI330_VCLKDataStruct XGI_VCLKData[]=
+{
+               	/* SR2B,SR2C,SR2D */
+ 		{      0x1B,0xE1,25               },/* 00 (25.175MHz) */
+
+		{      0x4E,0xE4,28               },/* 01 (28.322MHz) */
+
+                {      0x57,0xE4,31               },/* 02 (31.500MHz) */
+
+                {      0xC3,0xC8,36               },/* 03 (36.000MHz) */
+
+                {      0x42,0xE2,40               },/* 04 (40.000MHz) */
+
+                {      0xFE,0xCD,43               },/* 05 (43.163MHz) */
+
+                {      0x5D,0xC4,44               },/* 06 (44.900MHz) */
+
+                {      0x52,0xE2,49               },/* 07 (49.500MHz) */
+
+                {      0x53,0xE2,50               },/* 08 (50.000MHz) */
+
+                {      0x74,0x67,52               },/* 09 (52.406MHz) */
+
+                {      0x6D,0x66,56               },/* 0A (56.250MHz) */
+
+                {      0x6C,0xC3,65               },/* 0B (65.000MHz) */
+
+                {      0x46,0x44,67               },/* 0C (67.765MHz) */
+
+                {      0xB1,0x46,68               },/* 0D (68.179MHz) */
+
+                {      0xD3,0x4A,72               },/* 0E (72.852MHz) */
+
+                {      0x29,0x61,75              },/* 0F (75.000MHz) */
+
+                {      0x6E,0x46,76               },/* 10 (75.800MHz) */
+
+                {      0x2B,0x61,78               },/* 11 (78.750MHz) */
+
+                {      0x31,0x42,79               },/* 12 (79.411MHz) */
+
+                {      0xAB,0x44,83               },/* 13 (83.950MHz) */
+
+                {      0x46,0x25,84               },/* 14 (84.800MHz) */
+
+                {      0x78,0x29,86               },/* 15 (86.600MHz) */
+
+                {      0x62,0x44,94               },/* 16 (94.500MHz) */
+
+                {      0x2B,0x41,104               },/* 17 (104.998MHz) */
+
+                {      0x3A,0x23,105               },/* 18 (105.882MHz) */
+
+                {      0x70,0x44,108               },/* 19 (107.862MHz) */
+
+                {      0x3C,0x23,109               },/* 1A (109.175MHz) */
+
+                {      0x5E,0x43,113              },/* 1B (113.309MHz) */
+
+                {      0xBC,0x44,116              },/* 1C (116.406MHz) */
+
+                {      0xE0,0x46,132              },/* 1D (132.258MHz) */
+
+                {      0x54,0x42,135               },/* 1E (135.500MHz) */
+
+                {      0x9C,0x22,139               },/* 1F (139.275MHz) */
+
+                {      0x41,0x22,157               },/* 20 (157.500MHz) */
+
+                {      0x70,0x24,162               },/* 21 (161.793MHz) */
+
+                {      0x30,0x21,175               },/* 22 (175.000MHz) */
+
+                {      0x4E,0x22,189              },/* 23 (188.520MHz) */
+
+                {      0xDE,0x26,194              },/* 24 (194.400MHz) */
+
+                {      0x62,0x06,202               },/* 25 (202.500MHz) */
+
+                {      0x3F,0x03,229               },/* 26 (229.500MHz) */
+
+                {      0xB8,0x06,234               },/* 27 (233.178MHz) */
+
+                {      0x34,0x02,253               },/* 28 (252.699MHz) */
+
+                {      0x58,0x04,255               },/* 29 (254.817MHz) */
+
+                {      0x24,0x01,265              },/* 2A (265.728MHz) */
+
+                {      0x9B,0x02,267               },/* 2B (266.952MHz) */
+
+                {      0x70,0x05,270               },/* 2C (269.65567MHz) */
+
+                {      0x25,0x01,272               },/* 2D (272.04199MHz) */
+
+                {      0x9C,0x02,277               },/* 2E (277.015MHz) */
+
+                {      0x27,0x01,286               },/* 2F (286.359985MHz) */
+
+                {      0xB3,0x04,291               },/* 30 (291.13266MHz) */
+
+                {      0xBC,0x05,292               },/* 31 (291.766MHz) */
+
+                {      0xF6,0x0A,310               },/* 32 (309.789459MHz) */
+
+                {      0x95,0x01,315               },/* 33 (315.195MHz) */
+
+                {      0xF0,0x09,324               },/* 34 (323.586792MHz) */
+
+                {      0xFE,0x0A,331               },/* 35 (330.615631MHz) */
+
+                {      0xF3,0x09,332              },/* 36 (332.177612MHz) */
+
+                {      0x5E,0x03,340              },/* 37 (340.477MHz) */
+
+                {      0xE8,0x07,376              },/* 38 (375.847504MHz) */
+
+                {      0xDE, 0x06,389             },/* 39 (388.631439MHz) */
+
+                {      0x52,0x2A,54               },/* 3A (54.000MHz) */
+
+                {      0x52,0x6A,27              },/* 3B (27.000MHz) */
+
+                {      0x62,0x24,70               },/* 3C (70.874991MHz) */
+
+                {      0x62,0x64,70               },/* 3D (70.1048912MHz) */
+
+                {      0xA8,0x4C,30               },/* 3E (30.1048912MHz) */
+
+                {      0x20,0x26,33               },/* 3F (33.7499957MHz) */
+
+                {      0x31,0xc2,39               },/* 40 (39.77MHz) */
+
+                {      0x11,0x21,30               },/* 41 (30MHz) }// NTSC 1024X768 */
+
+                {      0x2E,0x48,25               },/* 42 (25.175MHz) }// ScaleLCD */
+
+                {      0x24,0x46,25               },/* 43 (25.175MHz) */
+
+                {      0x26,0x64,28               },/* 44 (28.322MHz) */
+
+                {      0x37,0x64,40               },/* 45 (40.000MHz) */
+
+                {      0xA1,0x42,108               },/* 46 (95.000MHz) }// QVGA */
+
+                {      0x37,0x61,100               },/* 47 (100.00MHz) */
+
+                {      0x78,0x27,108               },/* 48 (108.200MHz) */
+
+                {      0xBF,0xC8,35               },/* 49 (35.2MHz) */
+
+                {      0x66,0x43,123               },/* 4A (122.61Mhz) */
+
+                {      0x2C,0x61,80               },/* 4B (80.350Mhz) */
+
+                {      0x3B,0x61,108               },/* 4C (107.385Mhz) */
+
+
+/*                {      0x60,0x36,30               },// 4D (30.200MHz)   }// No use
+
+                {      0x60,0x36,30               },// 4E (30.200MHz)   }// No use
+
+                {      0x60,0x36,30               },// 4F (30.200MHz)   }// No use
+
+                {      0x60,0x36,30               },// 50 (30.200MHz)   }// CHTV
+
+                {      0x40,0x4A,28               },// 51 (28.190MHz)
+
+                {      0x9F,0x46,44               },// 52 (43.600MHz)
+
+                {      0x97,0x2C,26               },// 53 (26.400MHz)
+
+                {      0x44,0xE4,25               },// 54 (24.600MHz)
+
+                {      0x7E,0x32,47               },// 55 (47.832MHz)
+
+                {      0x8A,0x24,31               },// 56 (31.500MHz)
+
+                {      0x97,0x2C,26               },// 57 (26.200MHz)
+
+                {      0xCE,0x3C,39               },// 58 (39.000MHz)
+
+                {      0x52,0x4A,36               },// 59 (36.000MHz)
+
+*/
+		{      0x69,0x61,191		  }, /* 4D (190.96MHz ) */
+		{      0x4F,0x22,192		  }, /* 4E (192.069MHz) */
+		{      0x28,0x26,322		  }, /* 4F (322.273MHz) */
+		{      0x5C,0x6B,27		  }, /* 50 (27.74HMz) */
+		{      0x57,0x24,126		  }, /* 51 (125.999MHz) */
+		{      0x5C,0x42,148		  }, /* 52 (148.5MHz) */
+		{      0x42,0x61,120		  }, /* 53 (120.839MHz) */
+		{      0x62,0x61,178		  }, /* 54 (178.992MHz) */
+		{      0x59,0x22,217		  }, /* 55 (217.325MHz) */
+		{      0x29,0x01,300		  }, /* 56 (299.505Mhz) */
+		{      0x52,0x63,74		  }, /* 57 (74.25MHz) */
+
+
+                {      0xFF,0x00,0                }/* End mark */
+ }  ;
+
+XGI330_VCLKDataStruct XGI_VBVCLKData[]=
+{
+                {      0x1B,0xE1,25               },/* 00 (25.175MHz) */
+
+                {      0x4E,0xE4,28               },/* 01 (28.322MHz) */
+
+                {      0x57,0xE4,31               },/* 02 (31.500MHz) */
+
+                {      0xC3,0xC8,36               },/* 03 (36.000MHz) */
+
+                {      0x42,0x47,40               },/* 04 (40.000MHz) */
+
+                {      0xFE,0xCD,43               },/* 05 (43.163MHz) */
+
+                {      0x5D,0xC4,44               },/* 06 (44.900MHz) */
+
+                {      0x52,0x47,49               },/* 07 (49.500MHz) */
+
+                {      0x53,0x47,50               },/* 08 (50.000MHz) */
+
+                {      0x74,0x67,52               },/* 09 (52.406MHz) */
+
+                {      0x6D,0x66,56               },/* 0A (56.250MHz) */
+
+                {      0x35,0x62,65               },/* 0B (65.000MHz) */
+
+                {      0x46,0x44,67               },/* 0C (67.765MHz) */
+
+                {      0xB1,0x46,68               },/* 0D (68.179MHz) */
+
+                {      0xD3,0x4A,72               },/* 0E (72.852MHz) */
+
+                {      0x29,0x61,75               },/* 0F (75.000MHz) */
+
+                {      0x6D,0x46,75               },/* 10 (75.800MHz) */
+
+                {      0x41,0x43,78               },/* 11 (78.750MHz) */
+
+                {      0x31,0x42,79               },/* 12 (79.411MHz) */
+
+                {      0xAB,0x44,83               },/* 13 (83.950MHz) */
+
+                {      0x46,0x25,84               },/* 14 (84.800MHz) */
+
+                {      0x78,0x29,86               },/* 15 (86.600MHz) */
+
+                {      0x62,0x44,94               },/* 16 (94.500MHz) */
+
+                {      0x2B,0x22,104               },/* 17 (104.998MHz) */
+
+                {      0x49,0x24,105               },/* 18 (105.882MHz) */
+
+                {      0xF8,0x2F,108               },/* 19 (108.279MHz) */
+
+                {      0x3C,0x23,109               },/* 1A (109.175MHz) */
+
+                {      0x5E,0x43,113               },/* 1B (113.309MHz) */
+
+                {      0xBC,0x44,116               },/* 1C (116.406MHz) */
+
+                {      0xE0,0x46,132               },/* 1D (132.258MHz) */
+
+                {      0xD4,0x28,135               },/* 1E (135.220MHz) */
+
+                {      0xEA,0x2A,139               },/* 1F (139.275MHz) */
+
+                {      0x41,0x22,157               },/* 20 (157.500MHz) */
+
+                {      0x70,0x24,162               },/* 21 (161.793MHz) */
+
+                {      0x30,0x21,175               },/* 22 (175.000MHz) */
+
+                {      0x4E,0x22,189               },/* 23 (188.520MHz) */
+
+                {      0xDE,0x26,194               },/* 24 (194.400MHz) */
+
+                {      0x70,0x07,202               },/* 25 (202.500MHz) */
+
+                {      0x3F,0x03,229               },/* 26 (229.500MHz) */
+
+                {      0xB8,0x06,234               },/* 27 (233.178MHz) */
+
+                {      0x34,0x02,253               },/* 28 (252.699997 MHz) */
+
+                {      0x58,0x04,255               },/* 29 (254.817MHz) */
+
+                {      0x24,0x01,265               },/* 2A (265.728MHz) */
+
+                {      0x9B,0x02,267               },/* 2B (266.952MHz) */
+
+                {      0x70,0x05,270               },/* 2C (269.65567 MHz) */
+
+                {      0x25,0x01,272               },/* 2D (272.041992 MHz) */
+
+                {      0x9C,0x02,277               },/* 2E (277.015MHz) */
+
+                {      0x27,0x01,286               },/* 2F (286.359985 MHz) */
+
+                {      0x3C,0x02,291               },/* 30 (291.132660 MHz) */
+
+                {      0xEF,0x0A,292               },/* 31 (291.766MHz) */
+
+                {      0xF6,0x0A,310               },/* 32 (309.789459 MHz) */
+
+                {      0x95,0x01,315               },/* 33 (315.195MHz) */
+
+                {      0xF0,0x09,324               },/* 34 (323.586792 MHz) */
+
+                {      0xFE,0x0A,331               },/* 35 (330.615631 MHz) */
+
+                {      0xF3,0x09,332               },/* 36 (332.177612 MHz) */
+
+                {      0xEA,0x08,340               },/* 37 (340.477MHz) */
+
+                {      0xE8,0x07,376               },/* 38 (375.847504 MHz) */
+
+                {      0xDE,0x06,389               },/* 39 (388.631439 MHz) */
+
+                {      0x52,0x2A,54                },/* 3A (54.000MHz) */
+
+                {      0x52,0x6A,27                },/* 3B (27.000MHz) */
+
+
+                {      0x62,0x24,70                },/* 3C (70.874991MHz) */
+
+
+                {      0x62,0x64,70                },/* 3D (70.1048912MHz) */
+
+                {      0xA8,0x4C,30                },/* 3E (30.1048912MHz) */
+
+                {      0x20,0x26,33                },/* 3F (33.7499957MHz) */
+
+                {      0x31,0xc2,39                },/* 40 (39.77MHz) */
+
+                {      0x11,0x21,30                },/* 41 (30MHz) }// NTSC 1024X768 */
+
+                {      0x2E,0x48,25                },/* 42 (25.175MHz) }// ScaleLCD */
+
+                {      0x24,0x46,25                },/* 43 (25.175MHz) */
+
+                {      0x26,0x64,28                },/* 44 (28.322MHz) */
+
+                {      0x37,0x64,40                },/* 45 (40.000MHz) */
+
+                {      0xA1,0x42,108               },/* 46 (95.000MHz) }// QVGA */
+
+                {      0x37,0x61,100               },/* 47 (100.00MHz) */
+
+                {      0x78,0x27,108               },/* 48 (108.200MHz) */
+
+                {      0xBF,0xC8,35                },/* 49 (35.2MHz) */
+
+                {      0x66,0x43,123               },/* 4A (122.61Mhz) */
+
+                {      0x2C,0x61,80                },/* 4B (80.350Mhz) */
+
+                {      0x3B,0x61,108               },/* 4C (107.385Mhz) */
+
+/*
+                {      0x60,0x36,30               },// 4D (30.200MHz)   }// No use
+
+                {      0x60,0x36,30               },// 4E (30.200MHz)   }// No use
+
+                {      0x60,0x36,30               },// 4F (30.200MHz)   }// No use
+
+                {      0x60,0x36,30               },// 50 (30.200MHz)   }// CHTV
+
+                {      0x40,0x4A,28               },// 51 (28.190MHz)
+
+                {      0x9F,0x46,44               },// 52 (43.600MHz)
+
+                {      0x97,0x2C,26               },// 53 (26.400MHz)
+
+                {      0x44,0xE4,25               },// 54 (24.600MHz)
+
+                {      0x7E,0x32,47               },// 55 (47.832MHz)
+
+                {      0x8A,0x24,31               },// 56 (31.500MHz)
+
+                {      0x97,0x2C,26               },// 57 (26.200MHz)
+
+                {      0xCE,0x3C,39               },// 58 (39.000MHz)
+
+                {      0x52,0x4A,36               },// 59 (36.000MHz)
+*/
+		{      0x69,0x61,191		  }, /* 4D (190.96MHz ) */
+		{      0x4F,0x22,192		  }, /* 4E (192.069MHz) */
+		{      0x28,0x26,322		  }, /* 4F (322.273MHz) */
+		{      0x5C,0x6B,27		  }, /* 50 (27.74HMz) */
+		{      0x57,0x24,126		  }, /* 51 (125.999MHz) */
+		{      0x5C,0x42,148		  }, /* 52 (148.5MHz) */
+		{      0x42,0x61,120		  }, /* 53 (120.839MHz) */
+		{      0x62,0x61,178		  }, /* 54 (178.992MHz) */
+		{      0x59,0x22,217		  }, /* 55 (217.325MHz) */
+		{      0x29,0x01,300		  }, /* 56 (299.505Mhz) */
+		{      0x52,0x63,74		  }, /* 57 (74.25MHz) */
+
+
+                {      0xFF,0x00,0                }      /* End mark */
+};
+
+UCHAR XGI660_TVDelayList[]=
+{
+          0x44,            /* ; 0 ExtNTSCDelay */
+          0x44,            /* ; 1 StNTSCDelay */
+          0x44,            /* ; 2 ExtPALDelay */
+          0x44,            /* ; 3 StPALDelay */
+          0x44,            /* ; 4 ExtHiTVDelay(1080i) */
+          0x44,            /* ; 5 StHiTVDelay(1080i) */
+          0x44,            /* ; 6 ExtYPbPrDelay(525i) */
+          0x44,            /* ; 7 StYPbPrDealy(525i) */
+          0x44,            /* ; 8 ExtYPbPrDelay(525p) */
+          0x44,            /* ; 9 StYPbPrDealy(525p) */
+          0x44,            /* ; A ExtYPbPrDelay(750p) */
+          0x44             /* ; B StYPbPrDealy(750p) */
+};
+
+UCHAR XGI660_TVDelayList2[]=
+{
+          0x44,           /* ; 0 ExtNTSCDelay */
+          0x44,           /* ; 1 StNTSCDelay */
+          0x44,           /* ; 2 ExtPALDelay */
+          0x44,           /* ; 3 StPALDelay */
+          0x44,           /* ; 4 ExtHiTVDelay */
+          0x44,           /* ; 5 StHiTVDelay */
+          0x44,           /* ; 6 ExtYPbPrDelay(525i) */
+          0x44,           /* ; 7 StYPbPrDealy(525i) */
+          0x44,           /* ; 8 ExtYPbPrDelay(525p) */
+          0x44,           /* ; 9 StYPbPrDealy(525p) */
+          0x44,           /* ; A ExtYPbPrDelay(750p) */
+          0x44            /* ; B StYPbPrDealy(750p) */
+};
+
+UCHAR XGI301TVDelayList[]=
+{
+	0x22,            /* ; 0 ExtNTSCDelay */
+	0x22,            /* ; 1 StNTSCDelay */
+	0x22,            /* ; 2 ExtPALDelay */
+	0x22,            /* ; 3 StPALDelay */
+	0x88,            /* ; 4 ExtHiTVDelay(1080i) */
+	0xBB,            /* ; 5 StHiTVDelay(1080i) */
+	0x22,            /* ; 6 ExtYPbPrDelay(525i) */
+	0x22,            /* ; 7 StYPbPrDealy(525i) */
+	0x22,            /* ; 8 ExtYPbPrDelay(525p) */
+	0x22,            /* ; 9 StYPbPrDealy(525p) */
+	0x22,            /* ; A ExtYPbPrDelay(750p) */
+	0x22            /* B StYPbPrDealy(750p) */
+};
+
+UCHAR XGI301TVDelayList2[]=
+{
+	0x22,           /* ; 0 ExtNTSCDelay */
+	0x22,           /* ; 1 StNTSCDelay */
+	0x22,           /* ; 2 ExtPALDelay */
+	0x22,           /* ; 3 StPALDelay */
+	0x22,           /* ; 4 ExtHiTVDelay */
+	0x22,           /* ; 5 StHiTVDelay */
+	0x22,           /* ; 6 ExtYPbPrDelay(525i) */
+	0x22,           /* ; 7 StYPbPrDealy(525i) */
+	0x22,           /* ; 8 ExtYPbPrDelay(525p) */
+	0x22,           /* ; 9 StYPbPrDealy(525p) */
+	0x22,           /* ; A ExtYPbPrDelay(750p) */
+	0x22            /* ; B StYPbPrDealy(750p) */
+};
+
+
+UCHAR TVAntiFlickList[]=
+{/* NTSCAntiFlicker */
+                      0x04,           /* ; 0 Adaptive */
+                      0x00,           /* ; 1 new anti-flicker ? */
+/* PALAntiFlicker */
+                      0x04,           /* ; 0 Adaptive */
+                      0x08,           /* ; 1 new anti-flicker ? */
+/* HiTVAntiFlicker */
+                      0x04,           /* ; 0 ? */
+                      0x00            /* ; 1 new anti-flicker ? */
+};
+
+
+UCHAR TVEdgeList[]=
+{
+      0x00,            /* ; 0 NTSC No Edge enhance */
+      0x04,            /* ; 1 NTSC Adaptive Edge enhance */
+      0x00,            /* ; 0 PAL No Edge enhance */
+      0x04,            /* ; 1 PAL Adaptive Edge enhance */
+      0x00,            /* ; 0 HiTV */
+      0x00             /* ; 1 HiTV */
+};
+
+ULONG TVPhaseList[]=
+{      0x08BAED21, /* ; 0 NTSC phase */
+       0x00E3052A, /* ; 1 PAL phase */
+       0x9B2EE421, /* ; 2 PAL-M phase */
+       0xBA3EF421, /* ; 3 PAL-N phase */
+       0xA7A28B1E, /* ; 4 NTSC 1024x768 */
+       0xE00A831E, /* ; 5 PAL-M 1024x768 */
+       0x00000000, /* ; 6 reserved */
+       0x00000000, /* ; 7 reserved */
+       0xD67BF021, /* ; 8 NTSC phase */
+       0xE986092A, /* ; 9 PAL phase */
+       0xA4EFE621, /* ; A PAL-M phase */
+       0x4694F621, /* ; B PAL-N phase */
+       0x8BDE711C, /* ; C NTSC 1024x768 */
+       0xE00A831E  /* ; D PAL-M 1024x768 */
+};
+
+UCHAR NTSCYFilter1[]=
+{
+		      0x00,0xF4,0x10,0x38     ,/* 0 : 320x text mode */
+                      0x00,0xF4,0x10,0x38     ,/* 1 : 360x text mode */
+                      0xEB,0x04,0x25,0x18     ,/* 2 : 640x text mode */
+                      0xF1,0x04,0x1F,0x18     ,/* 3 : 720x text mode */
+                      0x00,0xF4,0x10,0x38     ,/* 4 : 320x gra. mode */
+                      0xEB,0x04,0x25,0x18     ,/* 5 : 640x gra. mode */
+                      0xEB,0x15,0x25,0xF6     /* 6 : 800x gra. mode */
+};
+
+UCHAR PALYFilter1[]=
+{
+		      0x00,0xF4,0x10,0x38, /* 0 : 320x text mode */
+                      0x00,0xF4,0x10,0x38     ,/* 1 : 360x text mode */
+                      0xF1,0xF7,0x1F,0x32     ,/* 2 : 640x text mode */
+                      0xF3,0x00,0x1D,0x20     ,/* 3 : 720x text mode */
+                      0x00,0xF4,0x10,0x38     ,/* 4 : 320x gra. mode */
+                      0xF1,0xF7,0x1F,0x32     ,/* 5 : 640x gra. mode */
+                      0xFC,0xFB,0x14,0x2A     /* 6 : 800x gra. mode */
+};
+
+UCHAR PALMYFilter1[]=
+{
+		      0x00,0xF4,0x10,0x38, /* 0 : 320x text mode */
+                      0x00,0xF4,0x10,0x38, /* 1 : 360x text mode */
+                      0xEB,0x04,0x10,0x18, /* 2 : 640x text mode */
+                      0xF7,0x06,0x19,0x14, /* 3 : 720x text mode */
+                      0x00,0xF4,0x10,0x38, /* 4 : 320x gra. mode */
+                      0xEB,0x04,0x25,0x18, /* 5 : 640x gra. mode */
+                      0xEB,0x15,0x25,0xF6, /* 6 : 800x gra. mode */
+                      0xFF,0xFF,0xFF,0xFF  /* End of Table */
+};
+
+UCHAR PALNYFilter1[]=
+{
+		      0x00,0xF4,0x10,0x38, /* 0 : 320x text mode */
+                      0x00,0xF4,0x10,0x38, /* 1 : 360x text mode */
+                      0xEB,0x04,0x10,0x18, /* 2 : 640x text mode */
+                      0xF7,0x06,0x19,0x14, /* 3 : 720x text mode */
+                      0x00,0xF4,0x10,0x38, /* 4 : 320x gra. mode */
+                      0xEB,0x04,0x25,0x18, /* 5 : 640x gra. mode */
+                      0xEB,0x15,0x25,0xF6, /* 6 : 800x gra. mode */
+                      0xFF,0xFF,0xFF,0xFF  /* End of Table */
+};
+
+UCHAR NTSCYFilter2[]=
+{
+		      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 0 : 320x text mode */
+                      0x01,0x02,0xFE,0xF7,0x03,0x27,0x3C, /* 1 : 360x text mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 2 : 640x text mode */
+                      0x01,0x02,0xFE,0xF7,0x03,0x27,0x3C, /* 3 : 720x text mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 4 : 320x gra. mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 5 : 640x gra. mode */
+                      0x01,0x01,0xFC,0xF8,0x08,0x26,0x38, /* 6 : 800x gra. mode */
+                      0xFF,0xFF,0xFC,0x00,0x0F,0x22,0x28  /* 7 : 1024xgra. mode */
+};
+
+UCHAR PALYFilter2[]=
+{
+		      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 0 : 320x text mode */
+                      0x01,0x02,0xFE,0xF7,0x03,0x27,0x3C, /* 1 : 360x text mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 2 : 640x text mode */
+                      0x01,0x02,0xFE,0xF7,0x03,0x27,0x3C, /* 3 : 720x text mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 4 : 320x gra. mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 5 : 640x gra. mode */
+                      0x01,0x01,0xFC,0xF8,0x08,0x26,0x38, /* 6 : 800x gra. mode */
+                      0xFF,0xFF,0xFC,0x00,0x0F,0x22,0x28  /* 7 : 1024xgra. mode */
+};
+
+UCHAR PALMYFilter2[]=
+{
+		      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 0 : 320x text mode */
+                      0x01,0x02,0xFE,0xF7,0x03,0x27,0x3C, /* 1 : 360x text mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 2 : 640x text mode */
+                      0x01,0x02,0xFE,0xF7,0x03,0x27,0x3C, /* 3 : 720x text mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 4 : 320x gra. mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 5 : 640x gra. mode */
+                      0x01,0x01,0xFC,0xF8,0x08,0x26,0x38, /* 6 : 800x gra. mode */
+                      0xFF,0xFF,0xFC,0x00,0x0F,0x22,0x28  /* 7 : 1024xgra. mode */
+};
+
+UCHAR PALNYFilter2[]=
+{
+		      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 0 : 320x text mode */
+                      0x01,0x02,0xFE,0xF7,0x03,0x27,0x3C, /* 1 : 360x text mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 2 : 640x text mode */
+                      0x01,0x02,0xFE,0xF7,0x03,0x27,0x3C, /* 3 : 720x text mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 4 : 320x gra. mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 5 : 640x gra. mode */
+                      0x01,0x01,0xFC,0xF8,0x08,0x26,0x38, /* 6 : 800x gra. mode */
+                      0xFF,0xFF,0xFC,0x00,0x0F,0x22,0x28  /* 7 : 1024xgra. mode */
+};
+
+UCHAR XGI_NTSC1024AdjTime[]=
+{
+      0xa7,0x07,0xf2,0x6e,0x17,0x8b,0x73,0x53,
+      0x13,0x40,0x34,0xF4,0x63,0xBB,0xCC,0x7A,
+      0x58,0xe4,0x73,0xd0,0x13
+};
+
+XGI301C_Tap4TimingStruct HiTVTap4Timing[]=
+{
+	{0,{
+	0x00,0x20,0x00,0x00,0x7F,0x20,0x02,0x7F, /* ; C0-C7 */
+	0x7D,0x20,0x04,0x7F,0x7D,0x1F,0x06,0x7E, /* ; C8-CF */
+	0x7C,0x1D,0x09,0x7E,0x7C,0x1B,0x0B,0x7E, /* ; D0-D7 */
+	0x7C,0x19,0x0E,0x7D,0x7C,0x17,0x11,0x7C, /* ; D8-DF */
+	0x7C,0x14,0x14,0x7C,0x7C,0x11,0x17,0x7C, /* ; E0-E7 */
+	0x7D,0x0E,0x19,0x7C,0x7E,0x0B,0x1B,0x7C, /* ; EA-EF */
+	0x7E,0x09,0x1D,0x7C,0x7F,0x06,0x1F,0x7C, /* ; F0-F7 */
+	0x7F,0x04,0x20,0x7D,0x00,0x02,0x20,0x7E  /* ; F8-FF */
+	}
+	}
+};
+
+XGI301C_Tap4TimingStruct EnlargeTap4Timing[]=
+{
+	{0,{
+	0x00,0x20,0x00,0x00,0x7F,0x20,0x02,0x7F, /* ; C0-C7 */
+	0x7D,0x20,0x04,0x7F,0x7D,0x1F,0x06,0x7E, /* ; C8-CF */
+	0x7C,0x1D,0x09,0x7E,0x7C,0x1B,0x0B,0x7E, /* ; D0-D7 */
+	0x7C,0x19,0x0E,0x7D,0x7C,0x17,0x11,0x7C, /* ; D8-DF */
+	0x7C,0x14,0x14,0x7C,0x7C,0x11,0x17,0x7C, /* ; E0-E7 */
+	0x7D,0x0E,0x19,0x7C,0x7E,0x0B,0x1B,0x7C, /* ; EA-EF */
+	0x7E,0x09,0x1D,0x7C,0x7F,0x06,0x1F,0x7C, /* ; F0-F7 */
+	0x7F,0x04,0x20,0x7D,0x00,0x02,0x20,0x7E   /* ; F8-FF */
+	}
+	}
+};
+
+XGI301C_Tap4TimingStruct NoScaleTap4Timing[]=
+{
+	{0,{
+	0x00,0x20,0x00,0x00,0x7F,0x20,0x02,0x7F, /* ; C0-C7 */
+	0x7D,0x20,0x04,0x7F,0x7D,0x1F,0x06,0x7E, /* ; C8-CF */
+	0x7C,0x1D,0x09,0x7E,0x7C,0x1B,0x0B,0x7E, /* ; D0-D7 */
+	0x7C,0x19,0x0E,0x7D,0x7C,0x17,0x11,0x7C, /* ; D8-DF */
+	0x7C,0x14,0x14,0x7C,0x7C,0x11,0x17,0x7C, /* ; E0-E7 */
+	0x7D,0x0E,0x19,0x7C,0x7E,0x0B,0x1B,0x7C, /* ; EA-EF */
+	0x7E,0x09,0x1D,0x7C,0x7F,0x06,0x1F,0x7C, /* ; F0-F7 */
+	0x7F,0x04,0x20,0x7D,0x00,0x02,0x20,0x7E  /* ; F8-FF */
+	}
+	}
+};
+
+XGI301C_Tap4TimingStruct PALTap4Timing[]=
+{
+	{600,  {
+                0x05,0x19,0x05,0x7D,0x03,0x19,0x06,0x7E, /* ; C0-C7 */
+                0x02,0x19,0x08,0x7D,0x01,0x18,0x0A,0x7D, /* ; C8-CF */
+                0x00,0x18,0x0C,0x7C,0x7F,0x17,0x0E,0x7C, /* ; D0-D7 */
+                0x7E,0x16,0x0F,0x7D,0x7E,0x14,0x11,0x7D, /* ; D8-DF */
+                0x7D,0x13,0x13,0x7D,0x7D,0x11,0x14,0x7E, /* ; E0-E7 */
+                0x7D,0x0F,0x16,0x7E,0x7D,0x0E,0x17,0x7E, /* ; EA-EF */
+                0x7D,0x0C,0x18,0x7F,0x7D,0x0A,0x18,0x01, /* ; F0-F7 */
+                0x7D,0x08,0x19,0x02,0x7D,0x06,0x19,0x04  /* ; F8-FF */
+                }
+ 	},
+        {768,	{
+                0x08,0x12,0x08,0x7E,0x07,0x12,0x09,0x7E, /* ; C0-C7 */
+                0x06,0x12,0x0A,0x7E,0x05,0x11,0x0B,0x7F, /* ; C8-CF */
+                0x04,0x11,0x0C,0x7F,0x03,0x11,0x0C,0x00, /* ; D0-D7 */
+                0x03,0x10,0x0D,0x00,0x02,0x0F,0x0E,0x01, /* ; D8-DF */
+                0x01,0x0F,0x0F,0x01,0x01,0x0E,0x0F,0x02, /* ; E0-E7 */
+                0x00,0x0D,0x10,0x03,0x7F,0x0C,0x11,0x04, /* ; EA-EF */
+                0x7F,0x0C,0x11,0x04,0x7F,0x0B,0x11,0x05, /* ; F0-F7 */
+                0x7E,0x0A,0x12,0x06,0x7E,0x09,0x12,0x07  /* ; F8-FF */
+                }
+        },
+        {0xFFFF,
+        	{
+                0x04,0x1A,0x04,0x7E,0x02,0x1B,0x05,0x7E, /* ; C0-C7 */
+                0x01,0x1A,0x07,0x7E,0x00,0x1A,0x09,0x7D, /* ; C8-CF */
+                0x7F,0x19,0x0B,0x7D,0x7E,0x18,0x0D,0x7D, /* ; D0-D7 */
+                0x7D,0x17,0x10,0x7C,0x7D,0x15,0x12,0x7C, /* ; D8-DF */
+                0x7C,0x14,0x14,0x7C,0x7C,0x12,0x15,0x7D, /* ; E0-E7 */
+                0x7C,0x10,0x17,0x7D,0x7C,0x0D,0x18,0x7F, /* ; EA-EF */
+                0x7D,0x0B,0x19,0x7F,0x7D,0x09,0x1A,0x00, /* ; F0-F7 */
+                0x7D,0x07,0x1A,0x02,0x7E,0x05,0x1B,0x02  /* ; F8-FF */
+                }
+        }
+};
+
+XGI301C_Tap4TimingStruct NTSCTap4Timing[]=
+{
+	{480,	{
+              	0x04,0x1A,0x04,0x7E,0x03,0x1A,0x06,0x7D, /* ; C0-C7 */
+              	0x01,0x1A,0x08,0x7D,0x00,0x19,0x0A,0x7D, /* ; C8-CF */
+              	0x7F,0x19,0x0C,0x7C,0x7E,0x18,0x0E,0x7C, /* ; D0-D7 */
+              	0x7E,0x17,0x10,0x7B,0x7D,0x15,0x12,0x7C, /* ; D8-DF */
+              	0x7D,0x13,0x13,0x7D,0x7C,0x12,0x15,0x7D, /* ; E0-E7 */
+              	0x7C,0x10,0x17,0x7D,0x7C,0x0E,0x18,0x7E, /* ; EA-EF */
+              	0x7D,0x0C,0x19,0x7E,0x7D,0x0A,0x19,0x00, /* ; F0-F7 */
+              	0x7D,0x08,0x1A,0x01,0x7E,0x06,0x1A,0x02  /* ; F8-FF */
+        	}
+        },
+        {600,	{
+              	0x07,0x14,0x07,0x7E,0x06,0x14,0x09,0x7D, /* ; C0-C7 */
+              	0x05,0x14,0x0A,0x7D,0x04,0x13,0x0B,0x7E, /* ; C8-CF */
+              	0x03,0x13,0x0C,0x7E,0x02,0x12,0x0D,0x7F, /* ; D0-D7 */
+              	0x01,0x12,0x0E,0x7F,0x01,0x11,0x0F,0x7F, /* ; D8-DF */
+              	0x01,0x10,0x10,0x00,0x7F,0x0F,0x11,0x01, /* ; E0-E7 */
+              	0x7F,0x0E,0x12,0x01,0x7E,0x0D,0x12,0x03, /* ; EA-EF */
+              	0x7E,0x0C,0x13,0x03,0x7E,0x0B,0x13,0x04, /* ; F0-F7 */
+              	0x7E,0x0A,0x14,0x04,0x7D,0x09,0x14,0x06  /* ; F8-FF */
+        	}
+        },
+        {0xFFFF,
+        	{
+              	0x09,0x0F,0x09,0x7F,0x08,0x0F,0x09,0x00, /* ; C0-C7 */
+              	0x07,0x0F,0x0A,0x00,0x06,0x0F,0x0A,0x01, /* ; C8-CF */
+              	0x06,0x0E,0x0B,0x01,0x05,0x0E,0x0B,0x02, /* ; D0-D7 */
+              	0x04,0x0E,0x0C,0x02,0x04,0x0D,0x0C,0x03, /* ; D8-DF */
+              	0x03,0x0D,0x0D,0x03,0x02,0x0C,0x0D,0x05, /* ; E0-E7 */
+              	0x02,0x0C,0x0E,0x04,0x01,0x0B,0x0E,0x06, /* ; EA-EF */
+              	0x01,0x0B,0x0E,0x06,0x00,0x0A,0x0F,0x07, /* ; F0-F7 */
+              	0x00,0x0A,0x0F,0x07,0x00,0x09,0x0F,0x08  /* ; F8-FF */
+        	}
+        }
+};
+
+XGI301C_Tap4TimingStruct YPbPr525pTap4Timing[]=
+{
+	{480,	{
+              	0x04,0x1A,0x04,0x7E,0x03,0x1A,0x06,0x7D, /* ; C0-C7 */
+              	0x01,0x1A,0x08,0x7D,0x00,0x19,0x0A,0x7D, /* ; C8-CF */
+              	0x7F,0x19,0x0C,0x7C,0x7E,0x18,0x0E,0x7C, /* ; D0-D7 */
+              	0x7E,0x17,0x10,0x7B,0x7D,0x15,0x12,0x7C, /* ; D8-DF */
+              	0x7D,0x13,0x13,0x7D,0x7C,0x12,0x15,0x7D, /* ; E0-E7 */
+              	0x7C,0x10,0x17,0x7D,0x7C,0x0E,0x18,0x7E, /* ; EA-EF */
+              	0x7D,0x0C,0x19,0x7E,0x7D,0x0A,0x19,0x00, /* ; F0-F7 */
+              	0x7D,0x08,0x1A,0x01,0x7E,0x06,0x1A,0x02  /* ; F8-FF */
+        	}
+        },
+        {600,	{
+              	0x07,0x14,0x07,0x7E,0x06,0x14,0x09,0x7D, /* ; C0-C7 */
+              	0x05,0x14,0x0A,0x7D,0x04,0x13,0x0B,0x7E, /* ; C8-CF */
+              	0x03,0x13,0x0C,0x7E,0x02,0x12,0x0D,0x7F, /* ; D0-D7 */
+              	0x01,0x12,0x0E,0x7F,0x01,0x11,0x0F,0x7F, /* ; D8-DF */
+              	0x01,0x10,0x10,0x00,0x7F,0x0F,0x11,0x01, /* ; E0-E7 */
+              	0x7F,0x0E,0x12,0x01,0x7E,0x0D,0x12,0x03, /* ; EA-EF */
+              	0x7E,0x0C,0x13,0x03,0x7E,0x0B,0x13,0x04, /* ; F0-F7 */
+              	0x7E,0x0A,0x14,0x04,0x7D,0x09,0x14,0x06  /* ; F8-FF */
+        	}
+        },
+        {0xFFFF,
+        	{
+              	0x09,0x0F,0x09,0x7F,0x08,0x0F,0x09,0x00, /* ; C0-C7 */
+              	0x07,0x0F,0x0A,0x00,0x06,0x0F,0x0A,0x01, /* ; C8-CF */
+              	0x06,0x0E,0x0B,0x01,0x05,0x0E,0x0B,0x02, /* ; D0-D7 */
+              	0x04,0x0E,0x0C,0x02,0x04,0x0D,0x0C,0x03, /* ; D8-DF */
+              	0x03,0x0D,0x0D,0x03,0x02,0x0C,0x0D,0x05, /* ; E0-E7 */
+              	0x02,0x0C,0x0E,0x04,0x01,0x0B,0x0E,0x06, /* ; EA-EF */
+              	0x01,0x0B,0x0E,0x06,0x00,0x0A,0x0F,0x07, /* ; F0-F7 */
+              	0x00,0x0A,0x0F,0x07,0x00,0x09,0x0F,0x08  /* ; F8-FF */
+        	}
+        }
+};
+
+XGI301C_Tap4TimingStruct YPbPr525iTap4Timing[]=
+{
+	{480,	{
+              	0x04,0x1A,0x04,0x7E,0x03,0x1A,0x06,0x7D, /* ; C0-C7 */
+              	0x01,0x1A,0x08,0x7D,0x00,0x19,0x0A,0x7D, /* ; C8-CF */
+              	0x7F,0x19,0x0C,0x7C,0x7E,0x18,0x0E,0x7C, /* ; D0-D7 */
+              	0x7E,0x17,0x10,0x7B,0x7D,0x15,0x12,0x7C, /* ; D8-DF */
+              	0x7D,0x13,0x13,0x7D,0x7C,0x12,0x15,0x7D, /* ; E0-E7 */
+              	0x7C,0x10,0x17,0x7D,0x7C,0x0E,0x18,0x7E, /* ; EA-EF */
+              	0x7D,0x0C,0x19,0x7E,0x7D,0x0A,0x19,0x00, /* ; F0-F7 */
+              	0x7D,0x08,0x1A,0x01,0x7E,0x06,0x1A,0x02  /* ; F8-FF */
+        	}
+        },
+        {600,	{
+              	0x07,0x14,0x07,0x7E,0x06,0x14,0x09,0x7D, /* ; C0-C7 */
+              	0x05,0x14,0x0A,0x7D,0x04,0x13,0x0B,0x7E, /* ; C8-CF */
+              	0x03,0x13,0x0C,0x7E,0x02,0x12,0x0D,0x7F, /* ; D0-D7 */
+              	0x01,0x12,0x0E,0x7F,0x01,0x11,0x0F,0x7F, /* ; D8-DF */
+              	0x01,0x10,0x10,0x00,0x7F,0x0F,0x11,0x01, /* ; E0-E7 */
+              	0x7F,0x0E,0x12,0x01,0x7E,0x0D,0x12,0x03, /* ; EA-EF */
+              	0x7E,0x0C,0x13,0x03,0x7E,0x0B,0x13,0x04, /* ; F0-F7 */
+              	0x7E,0x0A,0x14,0x04,0x7D,0x09,0x14,0x06  /* ; F8-FF */
+        	}
+        },
+        {0xFFFF,
+        	{
+              	0x09,0x0F,0x09,0x7F,0x08,0x0F,0x09,0x00, /* ; C0-C7 */
+              	0x07,0x0F,0x0A,0x00,0x06,0x0F,0x0A,0x01, /* ; C8-CF */
+              	0x06,0x0E,0x0B,0x01,0x05,0x0E,0x0B,0x02, /* ; D0-D7 */
+              	0x04,0x0E,0x0C,0x02,0x04,0x0D,0x0C,0x03, /* ; D8-DF */
+              	0x03,0x0D,0x0D,0x03,0x02,0x0C,0x0D,0x05, /* ; E0-E7 */
+              	0x02,0x0C,0x0E,0x04,0x01,0x0B,0x0E,0x06, /* ; EA-EF */
+              	0x01,0x0B,0x0E,0x06,0x00,0x0A,0x0F,0x07, /* ; F0-F7 */
+              	0x00,0x0A,0x0F,0x07,0x00,0x09,0x0F,0x08  /* ; F8-FF */
+        	}
+        }
+};
+
+XGI301C_Tap4TimingStruct YPbPr750pTap4Timing[]=
+{        {0xFFFF,
+               {
+               0x05,0x19,0x05,0x7D,0x03,0x19,0x06,0x7E, /* ; C0-C7 */
+               0x02,0x19,0x08,0x7D,0x01,0x18,0x0A,0x7D, /* ; C8-CF */
+               0x00,0x18,0x0C,0x7C,0x7F,0x17,0x0E,0x7C, /* ; D0-D7 */
+               0x7E,0x16,0x0F,0x7D,0x7E,0x14,0x11,0x7D, /* ; D8-DF */
+               0x7D,0x13,0x13,0x7D,0x7D,0x11,0x14,0x7E, /* ; E0-E7 */
+               0x7D,0x0F,0x16,0x7E,0x7D,0x0E,0x17,0x7E, /* ; EA-EF */
+               0x7D,0x0C,0x18,0x7F,0x7D,0x0A,0x18,0x01, /* ; F0-F7 */
+               0x7D,0x08,0x19,0x02,0x7D,0x06,0x19,0x04 /* F8-FF */
+               }
+        }
+};
diff --git a/drivers/video/xgi/vb_util.c b/drivers/video/xgi/vb_util.c
new file mode 100644
index 0000000..11386af
--- /dev/null
+++ b/drivers/video/xgi/vb_util.c
@@ -0,0 +1,287 @@
+#include "osdef.h"
+#include "vb_def.h"
+#include "vgatypes.h"
+#include "vb_struct.h"
+
+#ifdef LINUX_KERNEL
+#include "XGIfb.h"
+#include <asm/io.h>
+#include <linux/types.h>
+#endif
+
+#ifdef TC
+#include <stdio.h>
+#include <string.h>
+#include <conio.h>
+#include <dos.h>
+#endif
+
+#ifdef WIN2000
+#include <dderror.h>
+#include <devioctl.h>
+#include <miniport.h>
+#include <ntddvdeo.h>
+#include <video.h>
+
+#include "xgiv.h"
+#include "dd_i2c.h"
+#include "tools.h"
+#endif
+
+#ifdef LINUX_XF86
+#include "xf86.h"
+#include "xf86PciInfo.h"
+#include "xgi.h"
+#include "xgi_regs.h"
+#endif
+
+
+
+
+void XGINew_SetReg1( ULONG , USHORT , USHORT ) ;
+void XGINew_SetReg2( ULONG , USHORT , USHORT ) ;
+void XGINew_SetReg3( ULONG , USHORT ) ;
+void XGINew_SetReg4( ULONG , ULONG ) ;
+UCHAR XGINew_GetReg1( ULONG , USHORT) ;
+UCHAR XGINew_GetReg2( ULONG ) ;
+ULONG XGINew_GetReg3( ULONG ) ;
+void XGINew_ClearDAC( PUCHAR ) ;
+void     XGINew_SetRegANDOR(ULONG Port,USHORT Index,USHORT DataAND,USHORT DataOR);
+void     XGINew_SetRegOR(ULONG Port,USHORT Index,USHORT DataOR);
+void     XGINew_SetRegAND(ULONG Port,USHORT Index,USHORT DataAND);
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetReg1 */
+/* Input : */
+/* Output : */
+/* Description : SR CRTC GR */
+/* --------------------------------------------------------------------- */
+void XGINew_SetReg1( ULONG port , USHORT index , USHORT data )
+{
+#ifdef LINUX_XF86
+    OutPortByte( ( PUCHAR )(ULONG)port , index ) ;
+    OutPortByte( ( PUCHAR )(ULONG)port + 1 , data ) ;
+#else
+    OutPortByte( port , index ) ;
+    OutPortByte( port + 1 , data ) ;
+#endif
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetReg2 */
+/* Input : */
+/* Output : */
+/* Description : AR( 3C0 ) */
+/* --------------------------------------------------------------------- */
+/*void XGINew_SetReg2( ULONG port , USHORT index , USHORT data )
+{
+    InPortByte( ( PUCHAR )port + 0x3da - 0x3c0 ) ;
+    OutPortByte( XGINew_P3c0 , index ) ;
+    OutPortByte( XGINew_P3c0 , data ) ;
+    OutPortByte( XGINew_P3c0 , 0x20 ) ;
+}*/
+
+
+/* --------------------------------------------------------------------- */
+/* Function : */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetReg3( ULONG port , USHORT data )
+{
+    OutPortByte( port , data ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetReg4 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetReg4( ULONG port , ULONG data )
+{
+    OutPortLong( port , data ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_GetReg1 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+UCHAR XGINew_GetReg1( ULONG port , USHORT index )
+{
+    UCHAR data ;
+
+#ifdef LINUX_XF86
+    OutPortByte( ( PUCHAR )(ULONG)port , index ) ;
+    data = InPortByte( ( PUCHAR )(ULONG)port + 1 ) ;
+#else
+    OutPortByte( port , index ) ;
+    data = InPortByte( port + 1 ) ;
+#endif
+
+    return( data ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_GetReg2 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+UCHAR XGINew_GetReg2( ULONG port )
+{
+    UCHAR data ;
+
+    data = InPortByte( port ) ;
+
+    return( data ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_GetReg3 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+ULONG XGINew_GetReg3( ULONG port )
+{
+    ULONG data ;
+
+    data = InPortLong( port ) ;
+
+    return( data ) ;
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetRegANDOR */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetRegANDOR( ULONG Port , USHORT Index , USHORT DataAND , USHORT DataOR )
+{
+    USHORT temp ;
+
+    temp = XGINew_GetReg1( Port , Index ) ;		/* XGINew_Part1Port index 02 */
+    temp = ( temp & ( DataAND ) ) | DataOR ;
+    XGINew_SetReg1( Port , Index , temp ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetRegAND */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetRegAND(ULONG Port,USHORT Index,USHORT DataAND)
+{
+    USHORT temp ;
+
+    temp = XGINew_GetReg1( Port , Index ) ;	/* XGINew_Part1Port index 02 */
+    temp &= DataAND ;
+    XGINew_SetReg1( Port , Index , temp ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetRegOR */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetRegOR( ULONG Port , USHORT Index , USHORT DataOR )
+{
+    USHORT temp ;
+
+    temp = XGINew_GetReg1( Port , Index ) ;	/* XGINew_Part1Port index 02 */
+    temp |= DataOR ;
+    XGINew_SetReg1( Port , Index , temp ) ;
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_ClearDAC( PUCHAR port )
+{
+    int i ;
+
+    OutPortByte( port , 0 ) ;
+    port++ ;
+    for( i = 0 ; i < 256 * 3 ; i++ )
+    {
+        OutPortByte( port , 0 ) ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : NewDelaySecond */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void NewDelaySeconds( int seconds )
+{
+#ifndef LINUX_XF86
+    int j ;
+#endif
+    int i ;
+
+
+    for( i = 0 ; i < seconds ; i++ )
+    {
+#ifdef TC
+        delay( 1000 ) ;
+#endif
+
+#ifdef WIN2000
+
+        for ( j = 0 ; j < 20000 ; j++ )
+            VideoPortStallExecution( 50 ) ;
+#endif
+
+#ifdef WINCE_HEADER
+#endif
+
+#ifdef LINUX_KERNEL
+#endif
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : Newdebugcode */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void Newdebugcode( UCHAR code )
+{
+#ifndef LINUX_XF86
+    ULONG ultemp ;
+#endif
+
+//    OutPortByte ( 0x80 , code ) ;
+    /* OutPortByte ( 0x300 , code ) ; */
+    /* NewDelaySeconds( 0x3 ) ; */
+}
+
+
+
diff --git a/drivers/video/xgi/vb_util.h b/drivers/video/xgi/vb_util.h
new file mode 100644
index 0000000..ea442ac
--- /dev/null
+++ b/drivers/video/xgi/vb_util.h
@@ -0,0 +1,16 @@
+#ifndef _VBUTIL_
+#define _VBUTIL_
+extern   void     NewDelaySeconds( int );
+extern   void     Newdebugcode( UCHAR );
+extern   void     XGINew_SetReg1(ULONG, USHORT, USHORT);
+extern   void     XGINew_SetReg3(ULONG, USHORT);
+extern   UCHAR    XGINew_GetReg1(ULONG, USHORT);
+extern   UCHAR    XGINew_GetReg2(ULONG);
+extern   void     XGINew_SetReg4(ULONG, ULONG);
+extern   ULONG    XGINew_GetReg3(ULONG);
+extern   void     XGINew_ClearDAC( PUCHAR ) ;
+extern   void     XGINew_SetRegOR(ULONG Port,USHORT Index,USHORT DataOR);
+extern   void     XGINew_SetRegAND(ULONG Port,USHORT Index,USHORT DataAND);
+extern   void     XGINew_SetRegANDOR(ULONG Port,USHORT Index,USHORT DataAND,USHORT DataOR);
+#endif
+
diff --git a/drivers/video/xgi/vgatypes.h b/drivers/video/xgi/vgatypes.h
new file mode 100644
index 0000000..295ea86
--- /dev/null
+++ b/drivers/video/xgi/vgatypes.h
@@ -0,0 +1,325 @@
+
+#ifndef _VGATYPES_
+#define _VGATYPES_
+
+#include "osdef.h"
+
+#ifdef LINUX_XF86
+#include "xf86Version.h"
+#include "xf86Pci.h"
+#endif
+
+#ifdef LINUX_KERNEL  /* We don't want the X driver to depend on kernel source */
+#include <linux/ioctl.h>
+#endif
+
+#ifndef FALSE
+#define FALSE   0
+#endif
+
+#ifndef TRUE
+#define TRUE    1
+#endif
+
+#ifndef NULL
+#define NULL    0
+#endif
+
+#ifndef CHAR
+typedef char CHAR;
+#endif
+
+#ifndef SHORT
+typedef short SHORT;
+#endif
+
+#ifndef LONG
+typedef long  LONG;
+#endif
+
+#ifndef UCHAR
+typedef unsigned char UCHAR;
+#endif
+
+#ifndef USHORT
+typedef unsigned short USHORT;
+#endif
+
+#ifndef ULONG
+typedef unsigned long ULONG;
+#endif
+
+#ifndef PUCHAR
+typedef UCHAR *PUCHAR;
+#endif
+
+#ifndef PUSHORT
+typedef USHORT *PUSHORT;
+#endif
+
+#ifndef PLONGU
+typedef ULONG *PULONG;
+#endif
+
+#ifndef VOID
+typedef void VOID;
+#endif
+
+#ifndef PVOID
+typedef void *PVOID;
+#endif
+
+#ifndef BOOLEAN
+typedef UCHAR BOOLEAN;
+#endif
+/*
+#ifndef bool
+typedef UCHAR bool;
+#endif
+*/
+#ifdef LINUX_KERNEL
+typedef unsigned long XGIIOADDRESS;
+#endif
+
+#ifdef LINUX_XF86
+#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,0,0,0)
+typedef unsigned char IOADDRESS;
+typedef unsigned char XGIIOADDRESS;
+#else
+typedef IOADDRESS XGIIOADDRESS;
+#endif
+#endif
+
+#ifndef VBIOS_VER_MAX_LENGTH
+#define VBIOS_VER_MAX_LENGTH    4
+#endif
+
+#ifndef WIN2000
+
+#ifndef LINUX_KERNEL   /* For the linux kernel, this is defined in xgifb.h */
+#ifndef XGI_CHIP_TYPE
+typedef enum _XGI_CHIP_TYPE {
+    XGI_VGALegacy = 0,
+#ifdef LINUX_XF86
+    XGI_530,
+    XGI_OLD,
+#endif
+    XGI_300,
+    XGI_630,
+    XGI_640,
+    XGI_315H,
+    XGI_315,
+    XGI_315PRO,
+    XGI_550,
+    XGI_650,
+    XGI_650M,
+    XGI_740,
+    XGI_330,
+    XGI_661,
+    XGI_660,
+    XGI_760,
+    XG40 = 32,
+    XG41,
+    XG42,
+    XG45,
+    XG20 = 48,
+    XG21,
+    XG27,
+    MAX_XGI_CHIP
+} XGI_CHIP_TYPE;
+#endif
+#endif
+
+#ifndef XGI_VB_CHIP_TYPE
+typedef enum _XGI_VB_CHIP_TYPE {
+    VB_CHIP_Legacy = 0,
+    VB_CHIP_301,
+    VB_CHIP_301B,
+    VB_CHIP_301LV,
+    VB_CHIP_302,
+    VB_CHIP_302B,
+    VB_CHIP_302LV,
+    VB_CHIP_301C,
+    VB_CHIP_302ELV,
+    VB_CHIP_UNKNOWN, /* other video bridge or no video bridge */
+    MAX_VB_CHIP
+} XGI_VB_CHIP_TYPE;
+#endif
+
+#ifndef XGI_LCD_TYPE
+typedef enum _XGI_LCD_TYPE {
+    LCD_INVALID = 0,
+    LCD_320x480,       /* FSTN, DSTN */
+    LCD_640x480,
+    LCD_640x480_2,     /* FSTN, DSTN */
+    LCD_640x480_3,     /* FSTN, DSTN */
+    LCD_800x600,
+    LCD_848x480,
+    LCD_1024x600,
+    LCD_1024x768,
+    LCD_1152x768,
+    LCD_1152x864,
+    LCD_1280x720,
+    LCD_1280x768,
+    LCD_1280x800,
+    LCD_1280x960,
+    LCD_1280x1024,
+    LCD_1400x1050,
+    LCD_1600x1200,
+    LCD_1680x1050,
+    LCD_1920x1440,
+    LCD_2048x1536,
+    LCD_CUSTOM,
+    LCD_UNKNOWN
+} XGI_LCD_TYPE;
+#endif
+
+#endif   /* not WIN2000 */
+
+#ifndef PXGI_DSReg
+typedef struct _XGI_DSReg
+{
+  UCHAR  jIdx;
+  UCHAR  jVal;
+} XGI_DSReg, *PXGI_DSReg;
+#endif
+
+#ifndef XGI_HW_DEVICE_INFO
+
+typedef struct _XGI_HW_DEVICE_INFO  XGI_HW_DEVICE_INFO, *PXGI_HW_DEVICE_INFO;
+
+typedef BOOLEAN (*PXGI_QUERYSPACE)   (PXGI_HW_DEVICE_INFO, ULONG, ULONG, ULONG *);
+
+struct _XGI_HW_DEVICE_INFO
+{
+    ULONG  ulExternalChip;       /* NO VB or other video bridge*/
+                                 /* if ujVBChipID = VB_CHIP_UNKNOWN, */
+#ifdef LINUX_XF86
+    PCITAG PciTag;		 /* PCI Tag */
+#endif
+
+    PUCHAR  pjVirtualRomBase;    /* ROM image */
+
+    BOOLEAN UseROM;		 /* Use the ROM image if provided */
+
+    PVOID   pDevice;
+
+    PUCHAR  pjVideoMemoryAddress;/* base virtual memory address */
+                                 /* of Linear VGA memory */
+
+    ULONG  ulVideoMemorySize;    /* size, in bytes, of the memory on the board */
+
+    PUCHAR pjIOAddress;          /* base I/O address of VGA ports (0x3B0) */
+
+    PUCHAR pjCustomizedROMImage;
+
+    PUCHAR pj2ndVideoMemoryAddress;
+    ULONG  ul2ndVideoMemorySize;
+
+    PUCHAR pj2ndIOAddress;
+/*#ifndef WIN2000
+    XGIIOADDRESS pjIOAddress;   //  base I/O address of VGA ports (0x3B0)
+#endif */
+    UCHAR  jChipType;            /* Used to Identify Graphics Chip */
+                                 /* defined in the data structure type  */
+                                 /* "XGI_CHIP_TYPE" */
+
+    UCHAR  jChipRevision;        /* Used to Identify Graphics Chip Revision */
+
+    UCHAR  ujVBChipID;           /* the ID of video bridge */
+                                 /* defined in the data structure type */
+                                 /* "XGI_VB_CHIP_TYPE" */
+
+    BOOLEAN    bNewScratch;
+
+    ULONG  ulCRT2LCDType;        /* defined in the data structure type */
+
+    ULONG usExternalChip;       /* NO VB or other video bridge (other than  */
+                                 /*  video bridge) */
+
+    BOOLEAN bIntegratedMMEnabled;/* supporting integration MM enable */
+
+    BOOLEAN bSkipDramSizing;     /* True: Skip video memory sizing. */
+
+    BOOLEAN bSkipSense;
+
+    BOOLEAN bIsPowerSaving;     /* True: XGIInit() is invoked by power management,
+                                   otherwise by 2nd adapter's initialzation */
+
+    PXGI_DSReg  pSR;             /* restore SR registers in initial function. */
+                                 /* end data :(idx, val) =  (FF, FF). */
+                                 /* Note : restore SR registers if  */
+                                 /* bSkipDramSizing = TRUE */
+
+    PXGI_DSReg  pCR;             /* restore CR registers in initial function. */
+                                 /* end data :(idx, val) =  (FF, FF) */
+                                 /* Note : restore cR registers if  */
+                                 /* bSkipDramSizing = TRUE */
+/*
+#endif
+*/
+
+    PXGI_QUERYSPACE  pQueryVGAConfigSpace;
+
+    PXGI_QUERYSPACE  pQueryNorthBridgeSpace;
+
+    UCHAR  szVBIOSVer[VBIOS_VER_MAX_LENGTH];
+
+};
+#endif
+
+/* Addtional IOCTL for communication xgifb <> X driver        */
+/* If changing this, xgifb.h must also be changed (for xgifb) */
+
+#ifdef LINUX_XF86  /* We don't want the X driver to depend on the kernel source */
+
+/* ioctl for identifying and giving some info (esp. memory heap start) */
+#define XGIFB_GET_INFO    0x80046ef8  /* Wow, what a terrible hack... */
+
+/* Structure argument for XGIFB_GET_INFO ioctl  */
+typedef struct _XGIFB_INFO xgifb_info, *pxgifb_info;
+
+struct _XGIFB_INFO {
+	CARD32 	xgifb_id;         	/* for identifying xgifb */
+#ifndef XGIFB_ID
+#define XGIFB_ID	  0x53495346    /* Identify myself with 'XGIF' */
+#endif
+ 	CARD32 	chip_id;		/* PCI ID of detected chip */
+	CARD32	memory;			/* video memory in KB which xgifb manages */
+	CARD32	heapstart;             	/* heap start (= xgifb "mem" argument) in KB */
+	CARD8 	fbvidmode;		/* current xgifb mode */
+
+	CARD8 	xgifb_version;
+	CARD8	xgifb_revision;
+	CARD8 	xgifb_patchlevel;
+
+	CARD8 	xgifb_caps;		/* xgifb's capabilities */
+
+	CARD32 	xgifb_tqlen;		/* turbo queue length (in KB) */
+
+	CARD32 	xgifb_pcibus;      	/* The card's PCI ID */
+	CARD32 	xgifb_pcislot;
+	CARD32 	xgifb_pcifunc;
+
+	CARD8 	xgifb_lcdpdc;
+
+	CARD8	xgifb_lcda;
+
+	CARD32	xgifb_vbflags;
+	CARD32	xgifb_currentvbflags;
+
+	CARD32 	xgifb_scalelcd;
+	CARD32 	xgifb_specialtiming;
+
+	CARD8 	xgifb_haveemi;
+	CARD8 	xgifb_emi30,xgifb_emi31,xgifb_emi32,xgifb_emi33;
+	CARD8 	xgifb_haveemilcd;
+
+	CARD8 	xgifb_lcdpdca;
+
+	CARD8 reserved[212]; 		/* for future use */
+};
+#endif
+
+#endif
+
-- 
1.6.5.1

