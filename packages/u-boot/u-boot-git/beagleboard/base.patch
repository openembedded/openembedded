diff --git a/Makefile b/Makefile
index e557d0d..3eac691 100644
--- a/Makefile
+++ b/Makefile
@@ -141,7 +141,7 @@ ifeq ($(ARCH),ppc)
 CROSS_COMPILE = ppc_8xx-
 endif
 ifeq ($(ARCH),arm)
-CROSS_COMPILE = arm-linux-
+CROSS_COMPILE = arm-none-linux-gnueabi-
 endif
 ifeq ($(ARCH),i386)
 CROSS_COMPILE = i386-linux-
@@ -253,7 +253,7 @@ LIBBOARD = board/$(BOARDDIR)/lib$(BOARD).a
 LIBBOARD := $(addprefix $(obj),$(LIBBOARD))
 
 # Add GCC lib
-PLATFORM_LIBS += -L $(shell dirname `$(CC) $(CFLAGS) -print-libgcc-file-name`) -lgcc
+PLATFORM_LIBS += -L $(shell dirname `$(CC) $(CFLAGS) -print-libgcc-file-name`) -lgcc -lgcc_eh
 
 # The "tools" are needed early, so put this first
 # Don't include stuff already done in $(LIBS)
@@ -2569,6 +2569,12 @@ SMN42_config	:	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm720t SMN42 siemens lpc2292
 
 #########################################################################
+## ARM CORTEX Systems
+#########################################################################
+omap3530beagle_config :    unconfig
+	@./mkconfig $(@:_config=) arm omap3 omap3530beagle
+
+#########################################################################
 ## XScale Systems
 #########################################################################
 
diff --git a/board/omap3530beagle/Makefile b/board/omap3530beagle/Makefile
new file mode 100644
index 0000000..7065345
--- /dev/null
+++ b/board/omap3530beagle/Makefile
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= omap3530beagle.o mem.o clock.o syslib.o sys_info.o nand.o
+SOBJS	:= lowlevel_init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $^
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff --git a/board/omap3530beagle/clock.c b/board/omap3530beagle/clock.c
new file mode 100644
index 0000000..1f4b4f3
--- /dev/null
+++ b/board/omap3530beagle/clock.c
@@ -0,0 +1,314 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * Author :
+ *      Sunil Kumar <sunilsaini05@gmail.com>
+ *      Shashi Ranjan <shashiranjanmca05@gmail.com>
+ *
+ * Derived from Beagle Board and OMAP3 SDP code by
+ *      Richard Woodruff <r-woodruff2@ti.com>
+ *      Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/bits.h>
+#include <asm/arch/clocks.h>
+#include <asm/arch/clocks_omap3.h>
+#include <asm/arch/mem.h>
+#include <asm/arch/sys_proto.h>
+#include <environment.h>
+#include <command.h>
+
+/******************************************************************************
+ * get_sys_clk_speed() - determine reference oscillator speed
+ *                       based on known 32kHz clock and gptimer.
+ *****************************************************************************/
+u32 get_osc_clk_speed(void)
+{
+	u32 start, cstart, cend, cdiff, val;
+
+	val = __raw_readl(PRM_CLKSRC_CTRL);
+
+	/* If SYS_CLK is being divided by 2, remove for now */
+	val = (val & (~BIT7)) | BIT6;
+	__raw_writel(val, PRM_CLKSRC_CTRL);
+
+	/* enable timer2 */
+	val = __raw_readl(CM_CLKSEL_WKUP) | BIT0;
+	__raw_writel(val, CM_CLKSEL_WKUP);	/* select sys_clk for GPT1 */
+
+	/* Enable I and F Clocks for GPT1 */
+	val = __raw_readl(CM_ICLKEN_WKUP) | BIT0 | BIT2;
+	__raw_writel(val, CM_ICLKEN_WKUP);
+	val = __raw_readl(CM_FCLKEN_WKUP) | BIT0;
+	__raw_writel(val, CM_FCLKEN_WKUP);
+
+	__raw_writel(0, OMAP34XX_GPT1 + TLDR);	/* start counting at 0 */
+	__raw_writel(GPT_EN, OMAP34XX_GPT1 + TCLR);	/* enable clock */
+
+	/* enable 32kHz source, determine sys_clk via gauging */
+	start = 20 + __raw_readl(S32K_CR);	/* start time in 20 cycles */
+	while (__raw_readl(S32K_CR) < start) ;	/* dead loop till start time */
+	/* get start sys_clk count */
+	cstart = __raw_readl(OMAP34XX_GPT1 + TCRR);
+	/* wait for 40 cycles */
+	while (__raw_readl(S32K_CR) < (start + 20)) ;
+	cend = __raw_readl(OMAP34XX_GPT1 + TCRR);  /* get end sys_clk count */
+	cdiff = cend - cstart;	/* get elapsed ticks */
+
+	/* based on number of ticks assign speed */
+	if (cdiff > 19000)
+		return (S38_4M);
+	else if (cdiff > 15200)
+		return (S26M);
+	else if (cdiff > 13000)
+		return (S24M);
+	else if (cdiff > 9000)
+		return (S19_2M);
+	else if (cdiff > 7600)
+		return (S13M);
+	else
+		return (S12M);
+}
+
+/******************************************************************************
+ * get_sys_clkin_sel() - returns the sys_clkin_sel field value based on
+ *                       input oscillator clock frequency.
+ *****************************************************************************/
+void get_sys_clkin_sel(u32 osc_clk, u32 *sys_clkin_sel)
+{
+	if (osc_clk == S38_4M)
+		*sys_clkin_sel = 4;
+	else if (osc_clk == S26M)
+		*sys_clkin_sel = 3;
+	else if (osc_clk == S19_2M)
+		*sys_clkin_sel = 2;
+	else if (osc_clk == S13M)
+		*sys_clkin_sel = 1;
+	else if (osc_clk == S12M)
+		*sys_clkin_sel = 0;
+}
+
+/******************************************************************************
+ * prcm_init() - inits clocks for PRCM as defined in clocks.h
+ *               called from SRAM, or Flash (using temp SRAM stack).
+ *****************************************************************************/
+void prcm_init(void)
+{
+	void (*f_lock_pll) (u32, u32, u32, u32);
+	int xip_safe, p0, p1, p2, p3;
+	u32 osc_clk = 0, sys_clkin_sel;
+	u32 clk_index, sil_index;
+	dpll_param *dpll_param_p;
+
+	f_lock_pll = (void *) ((u32) &_end_vect - (u32) &_start +
+			       SRAM_VECT_CODE);
+
+	xip_safe = running_in_sram();
+
+	/* Gauge the input clock speed and find out the sys_clkin_sel
+	 * value corresponding to the input clock.
+	 */
+	osc_clk = get_osc_clk_speed();
+	get_sys_clkin_sel(osc_clk, &sys_clkin_sel);
+
+	sr32(PRM_CLKSEL, 0, 3, sys_clkin_sel);	/* set input crystal speed */
+
+	/* If the input clock is greater than 19.2M always divide/2 */
+	if (sys_clkin_sel > 2) {
+		sr32(PRM_CLKSRC_CTRL, 6, 2, 2);	/* input clock divider */
+		clk_index = sys_clkin_sel / 2;
+	} else {
+		sr32(PRM_CLKSRC_CTRL, 6, 2, 1);	/* input clock divider */
+		clk_index = sys_clkin_sel;
+	}
+
+	/* The DPLL tables are defined according to sysclk value and
+	 * silicon revision. The clk_index value will be used to get
+	 * the values for that input sysclk from the DPLL param table
+	 * and sil_index will get the values for that SysClk for the
+	 * appropriate silicon rev.
+	 */
+	sil_index = get_cpu_rev() - 1;
+	/* Unlock MPU DPLL (slows things down, and needed later) */
+	sr32(CM_CLKEN_PLL_MPU, 0, 3, PLL_LOW_POWER_BYPASS);
+	wait_on_value(BIT0, 0, CM_IDLEST_PLL_MPU, LDELAY);
+
+	/* Getting the base address of Core DPLL param table */
+	dpll_param_p = (dpll_param *) get_core_dpll_param();
+	/* Moving it to the right sysclk and ES rev base */
+	dpll_param_p = dpll_param_p + 3 * clk_index + sil_index;
+	if (xip_safe) {
+		/* CORE DPLL */
+		/* sr32(CM_CLKSEL2_EMU) set override to work when asleep */
+		sr32(CM_CLKEN_PLL, 0, 3, PLL_FAST_RELOCK_BYPASS);
+		wait_on_value(BIT0, 0, CM_IDLEST_CKGEN, LDELAY);
+		/* For OMAP3 ES1.0 Errata 1.50, default value directly doesnt
+		   work. write another value and then default value. */
+		sr32(CM_CLKSEL1_EMU, 16, 5, CORE_M3X2 + 1);	/* m3x2 */
+		sr32(CM_CLKSEL1_EMU, 16, 5, CORE_M3X2);	        /* m3x2 */
+		sr32(CM_CLKSEL1_PLL, 27, 2, dpll_param_p->m2);	/* Set M2 */
+		sr32(CM_CLKSEL1_PLL, 16, 11, dpll_param_p->m);	/* Set M */
+		sr32(CM_CLKSEL1_PLL, 8, 7, dpll_param_p->n);	/* Set N */
+		sr32(CM_CLKSEL1_PLL, 6, 1, 0);	                /* 96M Src */
+		sr32(CM_CLKSEL_CORE, 8, 4, CORE_SSI_DIV);	/* ssi */
+		sr32(CM_CLKSEL_CORE, 4, 2, CORE_FUSB_DIV);	/* fsusb */
+		sr32(CM_CLKSEL_CORE, 2, 2, CORE_L4_DIV);	/* l4 */
+		sr32(CM_CLKSEL_CORE, 0, 2, CORE_L3_DIV);	/* l3 */
+		sr32(CM_CLKSEL_GFX, 0, 3, GFX_DIV);	        /* gfx */
+		sr32(CM_CLKSEL_WKUP, 1, 2, WKUP_RSM);	        /* reset mgr */
+		sr32(CM_CLKEN_PLL, 4, 4, dpll_param_p->fsel);	/* FREQSEL */
+		sr32(CM_CLKEN_PLL, 0, 3, PLL_LOCK);	        /* lock mode */
+		wait_on_value(BIT0, 1, CM_IDLEST_CKGEN, LDELAY);
+	} else if (running_in_flash()) {
+		/* if running from flash, jump to small relocated code
+		   area in SRAM. */
+		p0 = __raw_readl(CM_CLKEN_PLL);
+		sr32((u32) &p0, 0, 3, PLL_FAST_RELOCK_BYPASS);
+		sr32((u32) &p0, 4, 4, dpll_param_p->fsel);	/* FREQSEL */
+
+		p1 = __raw_readl(CM_CLKSEL1_PLL);
+		sr32((u32) &p1, 27, 2, dpll_param_p->m2);	/* Set M2 */
+		sr32((u32) &p1, 16, 11, dpll_param_p->m);	/* Set M */
+		sr32((u32) &p1, 8, 7, dpll_param_p->n);	        /* Set N */
+		sr32((u32) &p1, 6, 1, 0);	    /* set source for 96M */
+		p2 = __raw_readl(CM_CLKSEL_CORE);
+		sr32((u32) &p2, 8, 4, CORE_SSI_DIV);	/* ssi */
+		sr32((u32) &p2, 4, 2, CORE_FUSB_DIV);	/* fsusb */
+		sr32((u32) &p2, 2, 2, CORE_L4_DIV);	/* l4 */
+		sr32((u32) &p2, 0, 2, CORE_L3_DIV);	/* l3 */
+
+		p3 = CM_IDLEST_CKGEN;
+
+		(*f_lock_pll) (p0, p1, p2, p3);
+	}
+
+	/* PER DPLL */
+	sr32(CM_CLKEN_PLL, 16, 3, PLL_STOP);
+	wait_on_value(BIT1, 0, CM_IDLEST_CKGEN, LDELAY);
+
+	/* Getting the base address to PER  DPLL param table */
+	/* Set N */
+	dpll_param_p = (dpll_param *) get_per_dpll_param();
+	/* Moving it to the right sysclk base */
+	dpll_param_p = dpll_param_p + clk_index;
+	/* Errata 1.50 Workaround for OMAP3 ES1.0 only */
+	/* If using default divisors, write default divisor + 1
+	   and then the actual divisor value */
+	/* Need to change it to silicon and revision check */
+	if (1) {
+		sr32(CM_CLKSEL1_EMU, 24, 5, PER_M6X2 + 1);	  /* set M6 */
+		sr32(CM_CLKSEL1_EMU, 24, 5, PER_M6X2);	          /* set M6 */
+		sr32(CM_CLKSEL_CAM, 0, 5, PER_M5X2 + 1);	  /* set M5 */
+		sr32(CM_CLKSEL_CAM, 0, 5, PER_M5X2);	          /* set M5 */
+		sr32(CM_CLKSEL_DSS, 0, 5, PER_M4X2 + 1);	  /* set M4 */
+		sr32(CM_CLKSEL_DSS, 0, 5, PER_M4X2);	          /* set M4 */
+		sr32(CM_CLKSEL_DSS, 8, 5, PER_M3X2 + 1);	  /* set M3 */
+		sr32(CM_CLKSEL_DSS, 8, 5, PER_M3X2);	          /* set M3 */
+		sr32(CM_CLKSEL3_PLL, 0, 5, dpll_param_p->m2 + 1); /* set M2 */
+		sr32(CM_CLKSEL3_PLL, 0, 5, dpll_param_p->m2);	  /* set M2 */
+	} else {
+		sr32(CM_CLKSEL1_EMU, 24, 5, PER_M6X2);	          /* set M6 */
+		sr32(CM_CLKSEL_CAM, 0, 5, PER_M5X2);	          /* set M5 */
+		sr32(CM_CLKSEL_DSS, 0, 5, PER_M4X2);	          /* set M4 */
+		sr32(CM_CLKSEL_DSS, 8, 5, PER_M3X2);	          /* set M3 */
+		sr32(CM_CLKSEL3_PLL, 0, 5, dpll_param_p->m2);	  /* set M2 */
+	}
+	sr32(CM_CLKSEL2_PLL, 8, 11, dpll_param_p->m);	/* set m */
+	sr32(CM_CLKSEL2_PLL, 0, 7, dpll_param_p->n);	/* set n */
+	sr32(CM_CLKEN_PLL, 20, 4, dpll_param_p->fsel);	/* FREQSEL */
+	sr32(CM_CLKEN_PLL, 16, 3, PLL_LOCK);	/* lock mode */
+	wait_on_value(BIT1, 2, CM_IDLEST_CKGEN, LDELAY);
+
+	/* Getting the base address to MPU DPLL param table */
+	dpll_param_p = (dpll_param *) get_mpu_dpll_param();
+	/* Moving it to the right sysclk and ES rev base */
+	dpll_param_p = dpll_param_p + 3 * clk_index + sil_index;
+	/* MPU DPLL (unlocked already) */
+	sr32(CM_CLKSEL2_PLL_MPU, 0, 5, dpll_param_p->m2);	/* Set M2 */
+	sr32(CM_CLKSEL1_PLL_MPU, 8, 11, dpll_param_p->m);	/* Set M */
+	sr32(CM_CLKSEL1_PLL_MPU, 0, 7, dpll_param_p->n);	/* Set N */
+	sr32(CM_CLKEN_PLL_MPU, 4, 4, dpll_param_p->fsel);	/* FREQSEL */
+	sr32(CM_CLKEN_PLL_MPU, 0, 3, PLL_LOCK);	/* lock mode */
+	wait_on_value(BIT0, 1, CM_IDLEST_PLL_MPU, LDELAY);
+
+	/* Getting the base address to IVA DPLL param table */
+	dpll_param_p = (dpll_param *) get_iva_dpll_param();
+	/* Moving it to the right sysclk and ES rev base */
+	dpll_param_p = dpll_param_p + 3 * clk_index + sil_index;
+	/* IVA DPLL (set to 12*20=240MHz) */
+	sr32(CM_CLKEN_PLL_IVA2, 0, 3, PLL_STOP);
+	wait_on_value(BIT0, 0, CM_IDLEST_PLL_IVA2, LDELAY);
+	sr32(CM_CLKSEL2_PLL_IVA2, 0, 5, dpll_param_p->m2);	/* set M2 */
+	sr32(CM_CLKSEL1_PLL_IVA2, 8, 11, dpll_param_p->m);	/* set M */
+	sr32(CM_CLKSEL1_PLL_IVA2, 0, 7, dpll_param_p->n);	/* set N */
+	sr32(CM_CLKEN_PLL_IVA2, 4, 4, dpll_param_p->fsel);	/* FREQSEL */
+	sr32(CM_CLKEN_PLL_IVA2, 0, 3, PLL_LOCK);	/* lock mode */
+	wait_on_value(BIT0, 1, CM_IDLEST_PLL_IVA2, LDELAY);
+
+	/* Set up GPTimers to sys_clk source only */
+	sr32(CM_CLKSEL_PER, 0, 8, 0xff);
+	sr32(CM_CLKSEL_WKUP, 0, 1, 1);
+
+	sdelay(5000);
+}
+
+/******************************************************************************
+ * peripheral_enable() - Enable the clks & power for perifs (GPT2, UART1,...)
+ *****************************************************************************/
+void per_clocks_enable(void)
+{
+	/* Enable GP2 timer. */
+	sr32(CM_CLKSEL_PER, 0, 1, 0x1);	/* GPT2 = sys clk */
+	sr32(CM_ICLKEN_PER, 3, 1, 0x1);	/* ICKen GPT2 */
+	sr32(CM_FCLKEN_PER, 3, 1, 0x1);	/* FCKen GPT2 */
+
+#ifdef CFG_NS16550
+	/* Enable UART1 clocks */
+	sr32(CM_FCLKEN1_CORE, 13, 1, 0x1);
+	sr32(CM_ICLKEN1_CORE, 13, 1, 0x1);
+
+	/* UART 3 Clocks */
+	sr32(CM_FCLKEN_PER, 11, 1, 0x1);
+	sr32(CM_ICLKEN_PER, 11, 1, 0x1);
+#endif
+#ifdef CONFIG_DRIVER_OMAP34XX_I2C
+	/* Turn on all 3 I2C clocks */
+	sr32(CM_FCLKEN1_CORE, 15, 3, 0x7);
+	sr32(CM_ICLKEN1_CORE, 15, 3, 0x7);	/* I2C1,2,3 = on */
+#endif
+	/* Enable the ICLK for 32K Sync Timer as its used in udelay */
+	sr32(CM_ICLKEN_WKUP, 2, 1, 0x1);
+
+	sr32(CM_FCLKEN_IVA2, 0, 32, FCK_IVA2_ON);
+	sr32(CM_FCLKEN1_CORE, 0, 32, FCK_CORE1_ON);
+	sr32(CM_ICLKEN1_CORE, 0, 32, ICK_CORE1_ON);
+	sr32(CM_ICLKEN2_CORE, 0, 32, ICK_CORE2_ON);
+	sr32(CM_FCLKEN_WKUP, 0, 32, FCK_WKUP_ON);
+	sr32(CM_ICLKEN_WKUP, 0, 32, ICK_WKUP_ON);
+	sr32(CM_FCLKEN_DSS, 0, 32, FCK_DSS_ON);
+	sr32(CM_ICLKEN_DSS, 0, 32, ICK_DSS_ON);
+	sr32(CM_FCLKEN_CAM, 0, 32, FCK_CAM_ON);
+	sr32(CM_ICLKEN_CAM, 0, 32, ICK_CAM_ON);
+	sr32(CM_FCLKEN_PER, 0, 32, FCK_PER_ON);
+	sr32(CM_ICLKEN_PER, 0, 32, ICK_PER_ON);
+
+	sdelay(1000);
+}
diff --git a/board/omap3530beagle/config.mk b/board/omap3530beagle/config.mk
new file mode 100644
index 0000000..9639c43
--- /dev/null
+++ b/board/omap3530beagle/config.mk
@@ -0,0 +1,17 @@
+#
+# (C) Copyright 2006
+# Texas Instruments, <www.ti.com>
+#
+# Begale Board uses OMAP3 (ARM-CortexA8) cpu
+# see http://www.ti.com/ for more information on Texas Instruments
+#
+# Physical Address:
+# 8000'0000 (bank0)
+# A000/0000 (bank1)
+# Linux-Kernel is expected to be at 8000'8000, entry 8000'8000
+# (mem base + reserved)
+
+# For use with external or internal boots.
+TEXT_BASE = 0x80e80000
+
+
diff --git a/board/omap3530beagle/lowlevel_init.S b/board/omap3530beagle/lowlevel_init.S
new file mode 100644
index 0000000..1f9a0e9
--- /dev/null
+++ b/board/omap3530beagle/lowlevel_init.S
@@ -0,0 +1,360 @@
+/*
+ * Board specific setup info
+ *
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * Initial Code by:
+ * Richard Woodruff <r-woodruff2@ti.com>
+ * Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/arch/mem.h>
+#include <asm/arch/clocks_omap3.h>
+
+_TEXT_BASE:
+	.word	TEXT_BASE	/* sdram load addr from config.mk */
+
+#if !defined(CFG_NAND_BOOT) && !defined(CFG_NAND_BOOT)
+/**************************************************************************
+ * cpy_clk_code: relocates clock code into SRAM where its safer to execute
+ * R1 = SRAM destination address.
+ *************************************************************************/
+.global cpy_clk_code
+ cpy_clk_code:
+        /* Copy DPLL code into SRAM */
+        adr     r0, go_to_speed         /* get addr of clock setting code */
+        mov     r2, #384                /* r2 size to copy (div by 32 bytes) */
+        mov     r1, r1                  /* r1 <- dest address (passed in) */
+        add     r2, r2, r0              /* r2 <- source end address */
+next2:
+        ldmia   r0!, {r3-r10}           /* copy from source address [r0]    */
+        stmia   r1!, {r3-r10}           /* copy to   target address [r1]    */
+        cmp     r0, r2                  /* until source end address [r2]    */
+        bne     next2
+	mov	pc, lr                  /* back to caller */
+
+/* ***************************************************************************
+ *  go_to_speed: -Moves to bypass, -Commits clock dividers, -puts dpll at speed
+ *               -executed from SRAM.
+ *  R0 = CM_CLKEN_PLL-bypass value
+ *  R1 = CM_CLKSEL1_PLL-m, n, and divider values
+ *  R2 = CM_CLKSEL_CORE-divider values
+ *  R3 = CM_IDLEST_CKGEN - addr dpll lock wait
+ *
+ *  Note: If core unlocks/relocks and SDRAM is running fast already it gets
+ *        confused.  A reset of the controller gets it back.  Taking away its
+ *        L3 when its not in self refresh seems bad for it.  Normally, this
+ *	  code runs from flash before SDR is init so that should be ok.
+ ****************************************************************************/
+.global go_to_speed
+ go_to_speed:
+        stmfd sp!, {r4-r6}
+
+        /* move into fast relock bypass */
+        ldr     r4, pll_ctl_add
+        str     r0, [r4]
+wait1:
+        ldr     r5, [r3]       /* get status */
+        and     r5, r5, #0x1   /* isolate core status */
+        cmp     r5, #0x1       /* still locked? */
+        beq     wait1          /* if lock, loop */
+
+	/* set new dpll dividers _after_ in bypass */
+	ldr     r5, pll_div_add1
+        str     r1, [r5]          /* set m, n, m2 */
+        ldr     r5, pll_div_add2
+        str     r2, [r5]          /* set l3/l4/.. dividers*/
+        ldr     r5, pll_div_add3  /* wkup */
+        ldr     r2, pll_div_val3  /* rsm val */
+        str     r2, [r5]
+        ldr     r5, pll_div_add4  /* gfx */
+        ldr     r2, pll_div_val4
+        str     r2, [r5]
+        ldr     r5, pll_div_add5  /* emu */
+        ldr     r2, pll_div_val5
+        str     r2, [r5]
+
+        /* now prepare GPMC (flash) for new dpll speed */
+	/* flash needs to be stable when we jump back to it */
+        ldr     r5, flash_cfg3_addr
+        ldr     r2, flash_cfg3_val
+        str     r2, [r5]
+        ldr     r5, flash_cfg4_addr
+        ldr     r2, flash_cfg4_val
+        str     r2, [r5]
+        ldr     r5, flash_cfg5_addr
+        ldr     r2, flash_cfg5_val
+        str     r2, [r5]
+        ldr     r5, flash_cfg1_addr
+        ldr     r2, [r5]
+        orr     r2, r2, #0x3     /* up gpmc divider */
+        str     r2, [r5]
+
+        /* lock DPLL3 and wait a bit */
+        orr     r0, r0, #0x7   /* set up for lock mode */
+        str     r0, [r4]       /* lock */
+        nop                    /* ARM slow at this point working at sys_clk */
+        nop
+        nop
+        nop
+wait2:
+        ldr     r5, [r3]       /* get status */
+        and     r5, r5, #0x1   /* isolate core status */
+        cmp     r5, #0x1       /* still locked? */
+        bne     wait2          /* if lock, loop */
+        nop
+        nop
+        nop
+        nop
+        ldmfd sp!, {r4-r6}
+        mov     pc, lr           /* back to caller, locked */
+
+_go_to_speed: .word go_to_speed
+
+/* these constants need to be close for PIC code */
+/* The Nor has to be in the Flash Base CS0 for this condition to happen */
+flash_cfg1_addr:
+    .word (GPMC_CONFIG_CS0 + GPMC_CONFIG1)
+flash_cfg3_addr:
+    .word  (GPMC_CONFIG_CS0 + GPMC_CONFIG3)
+flash_cfg3_val:
+    .word  STNOR_GPMC_CONFIG3
+flash_cfg4_addr:
+    .word (GPMC_CONFIG_CS0 + GPMC_CONFIG4)
+flash_cfg4_val:
+    .word  STNOR_GPMC_CONFIG4
+flash_cfg5_val:
+    .word  STNOR_GPMC_CONFIG5
+flash_cfg5_addr:
+    .word (GPMC_CONFIG_CS0 + GPMC_CONFIG5)
+pll_ctl_add:
+    .word CM_CLKEN_PLL
+pll_div_add1:
+    .word CM_CLKSEL1_PLL
+pll_div_add2:
+    .word CM_CLKSEL_CORE
+pll_div_add3:
+    .word CM_CLKSEL_WKUP
+pll_div_val3:
+    .word (WKUP_RSM << 1)
+pll_div_add4:
+    .word CM_CLKSEL_GFX
+pll_div_val4:
+    .word (GFX_DIV << 0)
+pll_div_add5:
+    .word CM_CLKSEL1_EMU
+pll_div_val5:
+    .word CLSEL1_EMU_VAL
+
+#endif
+
+.globl lowlevel_init
+lowlevel_init:
+	ldr	sp,	SRAM_STACK
+        str     ip,	[sp]    /* stash old link register */
+	mov	ip,	lr	/* save link reg across call */
+	bl      s_init          /* go setup pll,mux,memory */
+        ldr     ip,	[sp]    /* restore save ip */
+	mov	lr,	ip	/* restore link reg */
+
+	/* back to arch calling code */
+	mov	pc,	lr
+
+	/* the literal pools origin */
+	.ltorg
+
+REG_CONTROL_STATUS:
+	.word CONTROL_STATUS
+SRAM_STACK:
+	.word LOW_LEVEL_SRAM_STACK
+
+/* DPLL(1-4) PARAM TABLES */
+/* Each of the tables has M, N, FREQSEL, M2 values defined for nominal
+ * OPP (1.2V). The fields are defined according to dpll_param struct(clock.c).
+ * The values are defined for all possible sysclk and for ES1 and ES2.
+ */
+
+mpu_dpll_param:
+/* 12MHz */
+/* ES1 */
+.word 0x0FE,0x07,0x05,0x01
+/* ES2 */
+.word 0x0FA,0x05,0x07,0x01
+/* 3410 */
+.word 0x085,0x05,0x07,0x01
+
+/* 13MHz */
+/* ES1 */
+.word 0x17D,0x0C,0x03,0x01
+/* ES2 */
+.word 0x1F4,0x0C,0x03,0x01
+/* 3410 */
+.word 0x10A,0x0C,0x03,0x01
+
+/* 19.2MHz */
+/* ES1 */
+.word 0x179,0x12,0x04,0x01
+/* ES2 */
+.word 0x271,0x17,0x03,0x01
+/* 3410 */
+.word 0x14C,0x17,0x03,0x01
+
+/* 26MHz */
+/* ES1 */
+.word 0x17D,0x19,0x03,0x01
+/* ES2 */
+.word 0x0FA,0x0C,0x07,0x01
+/* 3410 */
+.word 0x085,0x0C,0x07,0x01
+
+/* 38.4MHz */
+/* ES1 */
+.word 0x1FA,0x32,0x03,0x01
+/* ES2 */
+.word 0x271,0x2F,0x03,0x01
+/* 3410 */
+.word 0x14C,0x2F,0x03,0x01
+
+
+.globl get_mpu_dpll_param
+get_mpu_dpll_param:
+	adr r0, mpu_dpll_param
+	mov pc, lr
+
+iva_dpll_param:
+/* 12MHz */
+/* ES1 */
+.word 0x07D,0x05,0x07,0x01
+/* ES2 */
+.word 0x0B4,0x05,0x07,0x01
+/* 3410 */
+.word 0x085,0x05,0x07,0x01
+
+/* 13MHz */
+/* ES1 */
+.word 0x0FA,0x0C,0x03,0x01
+/* ES2 */
+.word 0x168,0x0C,0x03,0x01
+/* 3410 */
+.word 0x10A,0x0C,0x03,0x01
+
+/* 19.2MHz */
+/* ES1 */
+.word 0x082,0x09,0x07,0x01
+/* ES2 */
+.word 0x0E1,0x0B,0x06,0x01
+/* 3410 */
+.word 0x14C,0x17,0x03,0x01
+
+/* 26MHz */
+/* ES1 */
+.word 0x07D,0x0C,0x07,0x01
+/* ES2 */
+.word 0x0B4,0x0C,0x07,0x01
+/* 3410 */
+.word 0x085,0x0C,0x07,0x01
+
+/* 38.4MHz */
+/* ES1 */
+.word 0x13F,0x30,0x03,0x01
+/* ES2 */
+.word 0x0E1,0x17,0x06,0x01
+/* 3410 */
+.word 0x14C,0x2F,0x03,0x01
+
+
+.globl get_iva_dpll_param
+get_iva_dpll_param:
+	adr r0, iva_dpll_param
+	mov pc, lr
+
+/* Core DPLL targets for L3 at 166 & L133 */
+core_dpll_param:
+/* 12MHz */
+/* ES1 */
+.word M_12_ES1,M_12_ES1,FSL_12_ES1,M2_12_ES1
+/* ES2 */
+.word M_12,N_12,FSEL_12,M2_12
+/* 3410 */
+.word M_12,N_12,FSEL_12,M2_12
+
+/* 13MHz */
+/* ES1 */
+.word M_13_ES1,N_13_ES1,FSL_13_ES1,M2_13_ES1
+/* ES2 */
+.word M_13,N_13,FSEL_13,M2_13
+/* 3410 */
+.word M_13,N_13,FSEL_13,M2_13
+
+/* 19.2MHz */
+/* ES1 */
+.word M_19p2_ES1,N_19p2_ES1,FSL_19p2_ES1,M2_19p2_ES1
+/* ES2 */
+.word M_19p2,N_19p2,FSEL_19p2,M2_19p2
+/* 3410 */
+.word M_19p2,N_19p2,FSEL_19p2,M2_19p2
+
+/* 26MHz */
+/* ES1 */
+.word M_26_ES1,N_26_ES1,FSL_26_ES1,M2_26_ES1
+/* ES2 */
+.word M_26,N_26,FSEL_26,M2_26
+/* 3410 */
+.word M_26,N_26,FSEL_26,M2_26
+
+/* 38.4MHz */
+/* ES1 */
+.word M_38p4_ES1,N_38p4_ES1,FSL_38p4_ES1,M2_38p4_ES1
+/* ES2 */
+.word M_38p4,N_38p4,FSEL_38p4,M2_38p4
+/* 3410 */
+.word M_38p4,N_38p4,FSEL_38p4,M2_38p4
+
+.globl get_core_dpll_param
+get_core_dpll_param:
+	adr r0, core_dpll_param
+	mov pc, lr
+
+/* PER DPLL values are same for both ES1 and ES2 */
+per_dpll_param:
+/* 12MHz */
+.word 0xD8,0x05,0x07,0x09
+
+/* 13MHz */
+.word 0x1B0,0x0C,0x03,0x09
+
+/* 19.2MHz */
+.word 0xE1,0x09,0x07,0x09
+
+/* 26MHz */
+.word 0xD8,0x0C,0x07,0x09
+
+/* 38.4MHz */
+.word 0xE1,0x13,0x07,0x09
+
+.globl get_per_dpll_param
+get_per_dpll_param:
+	adr r0, per_dpll_param
+	mov pc, lr
+
diff --git a/board/omap3530beagle/mem.c b/board/omap3530beagle/mem.c
new file mode 100644
index 0000000..fb803be
--- /dev/null
+++ b/board/omap3530beagle/mem.c
@@ -0,0 +1,250 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * Initial Code from:
+ *     Richard Woodruff <r-woodruff2@ti.com>
+ *     Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/bits.h>
+#include <asm/arch/mem.h>
+#include <asm/arch/sys_proto.h>
+#include <command.h>
+
+/* Only One NAND allowed on board at a time.
+ * The GPMC CS Base for the same
+ */
+unsigned int nand_cs_base;
+unsigned int boot_flash_base;
+unsigned int boot_flash_off;
+unsigned int boot_flash_sec;
+unsigned int boot_flash_type;
+volatile unsigned int boot_flash_env_addr;
+
+/* help common/env_flash.c */
+#ifdef ENV_IS_VARIABLE
+
+uchar(*boot_env_get_char_spec) (int index);
+int (*boot_env_init) (void);
+int (*boot_saveenv) (void);
+void (*boot_env_relocate_spec) (void);
+
+/* 16 bit NAND */
+uchar env_get_char_spec(int index);
+int env_init(void);
+int saveenv(void);
+void env_relocate_spec(void);
+extern char *env_name_spec;
+
+u8 is_nand;
+
+#endif /* ENV_IS_VARIABLE */
+
+static u32 gpmc_m_nand[GPMC_MAX_REG] = {
+	M_NAND_GPMC_CONFIG1,
+	M_NAND_GPMC_CONFIG2,
+	M_NAND_GPMC_CONFIG3,
+	M_NAND_GPMC_CONFIG4,
+	M_NAND_GPMC_CONFIG5,
+	M_NAND_GPMC_CONFIG6, 0
+};
+
+/**************************************************************************
+ * make_cs1_contiguous() - for es2 and above remap cs1 behind cs0 to allow
+ *  command line mem=xyz use all memory with out discontinuous support
+ *  compiled in.  Could do it at the ATAG, but there really is two banks...
+ * Called as part of 2nd phase DDR init.
+ **************************************************************************/
+void make_cs1_contiguous(void)
+{
+	u32 size, a_add_low, a_add_high;
+
+	size = get_sdr_cs_size(SDRC_CS0_OSET);
+	size /= SZ_32M;		        /* find size to offset CS1 */
+	a_add_high = (size & 3) << 8;	/* set up low field */
+	a_add_low = (size & 0x3C) >> 2;	/* set up high field */
+	__raw_writel((a_add_high | a_add_low), SDRC_CS_CFG);
+
+}
+
+/********************************************************
+ *  mem_ok() - test used to see if timings are correct
+ *             for a part. Helps in guessing which part
+ *             we are currently using.
+ *******************************************************/
+u32 mem_ok(void)
+{
+	u32 val1, val2, addr;
+	u32 pattern = 0x12345678;
+
+	addr = OMAP34XX_SDRC_CS0;
+
+	__raw_writel(0x0, addr + 0x400);  /* clear pos A */
+	__raw_writel(pattern, addr);	  /* pattern to pos B */
+	__raw_writel(0x0, addr + 4);	  /* remove pattern off the bus */
+	val1 = __raw_readl(addr + 0x400); /* get pos A value */
+	val2 = __raw_readl(addr);	  /* get val2 */
+
+	if ((val1 != 0) || (val2 != pattern))  /* see if pos A value changed */
+		return (0);
+	else
+		return (1);
+}
+
+/********************************************************
+ *  sdrc_init() - init the sdrc chip selects CS0 and CS1
+ *  - early init routines, called from flash or
+ *  SRAM.
+ *******************************************************/
+void sdrc_init(void)
+{
+	/* only init up first bank here */
+	do_sdrc_init(SDRC_CS0_OSET, EARLY_INIT);
+}
+
+/*************************************************************************
+ * do_sdrc_init(): initialize the SDRAM for use.
+ *  -code sets up SDRAM basic SDRC timings for CS0
+ *  -optimal settings can be placed here, or redone after i2c
+ *      inspection of board info
+ *
+ *  - code called ones in C-Stack only context for CS0 and a possible 2nd
+ *      time depending on memory configuration from stack+global context
+ **************************************************************************/
+
+void do_sdrc_init(u32 offset, u32 early)
+{
+
+	/* reset sdrc controller */
+	__raw_writel(SOFTRESET, SDRC_SYSCONFIG);
+	wait_on_value(BIT0, BIT0, SDRC_STATUS, 12000000);
+	__raw_writel(0, SDRC_SYSCONFIG);
+
+	/* setup sdrc to ball mux */
+	__raw_writel(SDP_SDRC_SHARING, SDRC_SHARING);
+
+	/* SDRC_MCFG0 register */
+	(*(unsigned int *) 0x6D000080) = 0x02584099; /* from Micron */
+
+	/* SDRC_RFR_CTRL0 register */
+	(*(unsigned int *) 0x6D0000a4) = 0x54601;    /* for 166M */
+
+	/* SDRC_ACTIM_CTRLA0 register */
+	(*(unsigned int *) 0x6D00009c) = 0xa29db4c6; /* for 166M */
+
+	/* SDRC_ACTIM_CTRLB0 register */
+	(*(unsigned int *) 0x6D0000a0) = 0x12214;    /* for 166M */
+
+	/* Disble Power Down of CKE cuz of 1 CKE on combo part */
+	(*(unsigned int *) 0x6D000070) = 0x00000081;
+
+	/* SDRC_Manual command register */
+	(*(unsigned int *) 0x6D0000a8) = 0x00000000; /* NOP command */
+	(*(unsigned int *) 0x6D0000a8) = 0x00000001; /* Precharge command */
+	(*(unsigned int *) 0x6D0000a8) = 0x00000002; /* Auto-refresh command */
+	(*(unsigned int *) 0x6D0000a8) = 0x00000002; /* Auto-refresh command */
+
+	/* SDRC MR0 register */
+	(*(int *) 0x6D000084) = 0x00000032;	/*  Burst length = 4 */
+	/* CAS latency = 3, Write Burst = Read Burst Serial Mode */
+
+	/* SDRC DLLA control register */
+	(*(unsigned int *) 0x6D000060) = 0x0000A;
+	sdelay(0x20000);
+}
+
+void enable_gpmc_config(u32 *gpmc_config, u32 gpmc_base, u32 base, u32 size)
+{
+	__raw_writel(0, GPMC_CONFIG7 + gpmc_base);
+	sdelay(1000);
+	/* Delay for settling */
+	__raw_writel(gpmc_config[0], GPMC_CONFIG1 + gpmc_base);
+	__raw_writel(gpmc_config[1], GPMC_CONFIG2 + gpmc_base);
+	__raw_writel(gpmc_config[2], GPMC_CONFIG3 + gpmc_base);
+	__raw_writel(gpmc_config[3], GPMC_CONFIG4 + gpmc_base);
+	__raw_writel(gpmc_config[4], GPMC_CONFIG5 + gpmc_base);
+	__raw_writel(gpmc_config[5], GPMC_CONFIG6 + gpmc_base);
+	/* Enable the config */
+	__raw_writel((((size & 0xF) << 8) | ((base >> 24) & 0x3F) |
+		      (1 << 6)), GPMC_CONFIG7 + gpmc_base);
+	sdelay(2000);
+}
+
+/*****************************************************
+ * gpmc_init(): init gpmc bus
+ * Init GPMC for x16, MuxMode (SDRAM in x32).
+ * This code can only be executed from SRAM or SDRAM.
+ *****************************************************/
+void gpmc_init(void)
+{
+	/* putting a blanket check on GPMC based on ZeBu for now */
+	u32 mux = 0, mwidth;
+	u32 *gpmc_config = NULL;
+	u32 gpmc_base = 0;
+	u32 base = 0;
+	u32 size = 0;
+	u32 f_off = CFG_MONITOR_LEN;
+	u32 f_sec = 0;
+	u32 config = 0;
+
+	mux = BIT9;
+	mwidth = get_gpmc0_width();
+
+	/* global settings */
+	__raw_writel(0x0, GPMC_IRQENABLE);	/* isr's sources masked */
+	__raw_writel(0, GPMC_TIMEOUT_CONTROL);	/* timeout disable */
+
+	config = __raw_readl(GPMC_CONFIG);
+	config &= (~0xf00);
+	__raw_writel(config, GPMC_CONFIG);
+
+	/* Disable the GPMC0 config set by ROM code
+	 * It conflicts with our MPDB (both at 0x08000000)
+	 */
+	__raw_writel(0, GPMC_CONFIG7 + GPMC_CONFIG_CS0);
+	sdelay(1000);
+
+	/* CS 0 */
+	gpmc_config = gpmc_m_nand;
+	gpmc_base = GPMC_CONFIG_CS0 + (0 * GPMC_CONFIG_WIDTH);
+	base = PISMO1_NAND_BASE;
+	size = PISMO1_NAND_SIZE;
+	enable_gpmc_config(gpmc_config, gpmc_base, base, size);
+
+	f_off = SMNAND_ENV_OFFSET;
+	f_sec = SZ_128K;
+	is_nand = 1;
+	nand_cs_base = gpmc_base;
+
+	/* env setup */
+	boot_flash_base = base;
+	boot_flash_off = f_off;
+	boot_flash_sec = f_sec;
+	boot_flash_env_addr = f_off;
+
+#ifdef ENV_IS_VARIABLE
+	boot_env_get_char_spec = env_get_char_spec;
+	boot_env_init = env_init;
+	boot_saveenv = saveenv;
+	boot_env_relocate_spec = env_relocate_spec;
+#endif
+
+}
diff --git a/board/omap3530beagle/nand.c b/board/omap3530beagle/nand.c
new file mode 100644
index 0000000..2f94684
--- /dev/null
+++ b/board/omap3530beagle/nand.c
@@ -0,0 +1,408 @@
+/*
+ * (C) Copyright 2004-2008 Texas Instruments, <www.ti.com>
+ * Rohit Choraria <rohitkc@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/mem.h>
+#include <linux/mtd/nand_ecc.h>
+
+#if defined(CONFIG_CMD_NAND)
+
+#include <nand.h>
+
+unsigned char cs;
+volatile unsigned long gpmc_cs_base_add;
+
+#define GPMC_BUF_EMPTY 0
+#define GPMC_BUF_FULL 1
+
+#define ECC_P1_128_E(val)    ((val)  & 0x000000FF)	/* Bit 0 to 7 */
+#define ECC_P512_2048_E(val) (((val) & 0x00000F00)>>8)	/* Bit 8 to 11 */
+#define ECC_P1_128_O(val)    (((val) & 0x00FF0000)>>16)	/* Bit 16 to Bit 23 */
+#define ECC_P512_2048_O(val) (((val) & 0x0F000000)>>24)	/* Bit 24 to Bit 27 */
+
+/*
+ * omap_nand_hwcontrol - Set the address pointers corretly for the
+ *			following address/data/command operation
+ * @mtd:        MTD device structure
+ * @ctrl:	Says whether Address or Command or Data is following.
+ */
+static void omap_nand_hwcontrol(struct mtd_info *mtd, int ctrl)
+{
+	register struct nand_chip *this = mtd->priv;
+
+	/* Point the IO_ADDR to DATA and ADDRESS registers instead
+	   of chip address */
+	switch (ctrl) {
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *) gpmc_cs_base_add + GPMC_NAND_CMD;
+		this->IO_ADDR_R = (void *) gpmc_cs_base_add + GPMC_NAND_DAT;
+		break;
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *) gpmc_cs_base_add + GPMC_NAND_ADR;
+		this->IO_ADDR_R = (void *) gpmc_cs_base_add + GPMC_NAND_DAT;
+		break;
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *) gpmc_cs_base_add + GPMC_NAND_DAT;
+		this->IO_ADDR_R = (void *) gpmc_cs_base_add + GPMC_NAND_DAT;
+		break;
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *) gpmc_cs_base_add + GPMC_NAND_DAT;
+		this->IO_ADDR_R = (void *) gpmc_cs_base_add + GPMC_NAND_DAT;
+		break;
+	}
+}
+
+/*
+ * omap_nand_wait - called primarily after a program/erase operation
+ *			so that we access NAND again only after the device
+ *			is ready again.
+ * @mtd:        MTD device structure
+ * @chip:	nand_chip structure
+ * @state:	State from which wait function is being called i.e write/erase.
+ */
+static int omap_nand_wait(struct mtd_info *mtd, struct nand_chip *chip,
+			  int state)
+{
+	register struct nand_chip *this = mtd->priv;
+	int status = 0;
+
+	this->IO_ADDR_W = (void *) gpmc_cs_base_add + GPMC_NAND_CMD;
+	this->IO_ADDR_R = (void *) gpmc_cs_base_add + GPMC_NAND_DAT;
+	/* Send the status command and loop until the device is free */
+	while (!(status & 0x40)) {
+		__raw_writeb(NAND_CMD_STATUS & 0xFF, this->IO_ADDR_W);
+		status = __raw_readb(this->IO_ADDR_R);
+	}
+	return status;
+}
+
+#ifdef CFG_NAND_WIDTH_16
+/*
+ * omap_nand_write_buf16 - [DEFAULT] write buffer to chip
+ * @mtd:	MTD device structure
+ * @buf:	data buffer
+ * @len:	number of bytes to write
+ *
+ * Default write function for 16bit buswith
+ */
+static void omap_nand_write_buf(struct mtd_info *mtd, const u_char *buf,
+				int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+	u16 *p = (u16 *) buf;
+	len >>= 1;
+
+	for (i = 0; i < len; i++) {
+		writew(p[i], this->IO_ADDR_W);
+		while (GPMC_BUF_EMPTY == (readl(GPMC_STATUS) & GPMC_BUF_FULL)) ;
+	}
+}
+
+/*
+ * nand_read_buf16 - [DEFAULT] read chip data into buffer
+ * @mtd:	MTD device structure
+ * @buf:	buffer to store date
+ * @len:	number of bytes to read
+ *
+ * Default read function for 16bit buswith
+ */
+static void omap_nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+	u16 *p = (u16 *) buf;
+	len >>= 1;
+
+	for (i = 0; i < len; i++)
+		p[i] = readw(this->IO_ADDR_R);
+}
+
+#else
+/*
+ * omap_nand_write_buf -  write buffer to NAND controller
+ * @mtd:        MTD device structure
+ * @buf:        data buffer
+ * @len:        number of bytes to write
+ *
+ */
+static void omap_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf,
+				int len)
+{
+	int i;
+	int j = 0;
+	struct nand_chip *chip = mtd->priv;
+
+	for (i = 0; i < len; i++) {
+		writeb(buf[i], chip->IO_ADDR_W);
+		for (j = 0; j < 10; j++) ;
+	}
+
+}
+
+/*
+ * omap_nand_read_buf - read data from NAND controller into buffer
+ * @mtd:        MTD device structure
+ * @buf:        buffer to store date
+ * @len:        number of bytes to read
+ *
+ */
+static void omap_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	int i;
+	int j = 0;
+	struct nand_chip *chip = mtd->priv;
+
+	for (i = 0; i < len; i++) {
+		buf[i] = readb(chip->IO_ADDR_R);
+		while (GPMC_BUF_EMPTY == (readl(GPMC_STATUS) & GPMC_BUF_FULL));
+	}
+}
+#endif /* CFG_NAND_WIDTH_16 */
+
+/*
+ * omap_hwecc_init - Initialize the Hardware ECC for NAND flash in
+ *                   GPMC controller
+ * @mtd:        MTD device structure
+ *
+ */
+static void omap_hwecc_init(struct nand_chip *chip)
+{
+	unsigned long val = 0x0;
+
+	/* Init ECC Control Register */
+	/* Clear all ECC  | Enable Reg1 */
+	val = ((0x00000001 << 8) | 0x00000001);
+	__raw_writel(val, GPMC_BASE + GPMC_ECC_CONTROL);
+	__raw_writel(0x3fcff000, GPMC_BASE + GPMC_ECC_SIZE_CONFIG);
+}
+
+/*
+ * omap_correct_data - Compares the ecc read from nand spare area with
+ *                     ECC registers values
+ *			and corrects one bit error if it has occured
+ * @mtd:		 MTD device structure
+ * @dat:		 page data
+ * @read_ecc:		 ecc read from nand flash
+ * @calc_ecc: 		 ecc read from ECC registers
+ */
+static int omap_correct_data(struct mtd_info *mtd, u_char *dat,
+			     u_char *read_ecc, u_char *calc_ecc)
+{
+	return 0;
+}
+
+/*
+ *  omap_calculate_ecc - Generate non-inverted ECC bytes.
+ *
+ *  Using noninverted ECC can be considered ugly since writing a blank
+ *  page ie. padding will clear the ECC bytes. This is no problem as
+ *  long nobody is trying to write data on the seemingly unused page.
+ *  Reading an erased page will produce an ECC mismatch between
+ *  generated and read ECC bytes that has to be dealt with separately.
+ *  @mtd:	MTD structure
+ *  @dat:	unused
+ *  @ecc_code:	ecc_code buffer
+ */
+static int omap_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
+			      u_char *ecc_code)
+{
+	unsigned long val = 0x0;
+	unsigned long reg;
+
+	/* Start Reading from HW ECC1_Result = 0x200 */
+	reg = (unsigned long) (GPMC_BASE + GPMC_ECC1_RESULT);
+	val = __raw_readl(reg);
+
+	*ecc_code++ = ECC_P1_128_E(val);
+	*ecc_code++ = ECC_P1_128_O(val);
+	*ecc_code++ = ECC_P512_2048_E(val) | ECC_P512_2048_O(val) << 4;
+
+	return 0;
+}
+
+/*
+ * omap_enable_ecc - This function enables the hardware ecc functionality
+ * @mtd:        MTD device structure
+ * @mode:       Read/Write mode
+ */
+static void omap_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	struct nand_chip *chip = mtd->priv;
+	unsigned int val = __raw_readl(GPMC_BASE + GPMC_ECC_CONFIG);
+	unsigned int dev_width = (chip->options & NAND_BUSWIDTH_16) >> 1;
+
+	switch (mode) {
+	case NAND_ECC_READ:
+		__raw_writel(0x101, GPMC_BASE + GPMC_ECC_CONTROL);
+		/* ECC col width | CS | ECC Enable */
+		val = (dev_width << 7) | (cs << 1) | (0x1);
+		break;
+	case NAND_ECC_READSYN:
+		__raw_writel(0x100, GPMC_BASE + GPMC_ECC_CONTROL);
+		/* ECC col width | CS | ECC Enable */
+		val = (dev_width << 7) | (cs << 1) | (0x1);
+		break;
+	case NAND_ECC_WRITE:
+		__raw_writel(0x101, GPMC_BASE + GPMC_ECC_CONTROL);
+		/* ECC col width | CS | ECC Enable */
+		val = (dev_width << 7) | (cs << 1) | (0x1);
+		break;
+	default:
+		printf("Error: Unrecognized Mode[%d]!\n", mode);
+		break;
+	}
+
+	__raw_writel(val, GPMC_BASE + GPMC_ECC_CONFIG);
+}
+
+static struct nand_oobinfo hw_nand_oob_64 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 12,
+	.eccpos = {
+		   2, 3, 4, 5,
+		   6, 7, 8, 9,
+		   10, 11, 12, 13},
+	.oobfree = { {20, 50} }	/* don't care */
+};
+
+static struct nand_oobinfo sw_nand_oob_64 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 24,
+	.eccpos = {
+		   40, 41, 42, 43, 44, 45, 46, 47,
+		   48, 49, 50, 51, 52, 53, 54, 55,
+		   56, 57, 58, 59, 60, 61, 62, 63},
+	.oobfree = { {2, 38} }
+};
+
+void omap_nand_switch_ecc(struct mtd_info *mtd, int hardware)
+{
+	struct nand_chip *nand = mtd->priv;
+
+	if (!hardware) {
+		nand->eccmode = NAND_ECC_SOFT;
+		nand->autooob = &sw_nand_oob_64;
+		nand->eccsize = 256;	/* set default eccsize */
+		nand->eccbytes = 3;
+		nand->eccsteps = 8;
+		nand->enable_hwecc = 0;
+		nand->calculate_ecc = nand_calculate_ecc;
+		nand->correct_data = nand_correct_data;
+	} else {
+		nand->eccmode = NAND_ECC_HW3_512;
+		nand->autooob = &hw_nand_oob_64;
+		nand->eccsize = 512;
+		nand->eccbytes = 3;
+		nand->eccsteps = 4;
+		nand->enable_hwecc = omap_enable_hwecc;
+		nand->correct_data = omap_correct_data;
+		nand->calculate_ecc = omap_calculate_ecc;
+
+		omap_hwecc_init(nand);
+	}
+
+	mtd->eccsize = nand->eccsize;
+	nand->oobdirty = 1;
+
+	if (nand->options & NAND_BUSWIDTH_16) {
+		mtd->oobavail = mtd->oobsize - (nand->autooob->eccbytes + 2);
+		if (nand->autooob->eccbytes & 0x01)
+			mtd->oobavail--;
+	} else
+		mtd->oobavail = mtd->oobsize - (nand->autooob->eccbytes + 1);
+}
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand_new.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+int board_nand_init(struct nand_chip *nand)
+{
+	int gpmc_config = 0;
+	cs = 0;
+	while (cs <= GPMC_MAX_CS) {
+		/* Each GPMC set for a single CS is at offset 0x30 */
+		/* already remapped for us */
+		gpmc_cs_base_add = (GPMC_CONFIG_CS0 + (cs * 0x30));
+		/* xloader/Uboot would have written the NAND type for us
+		 * NOTE: This is a temporary measure and cannot handle ONENAND.
+		 * The proper way of doing this is to pass the setup of
+		 * u-boot up to kernel using kernel params - something on
+		 * the lines of machineID
+		 */
+		/* Check if NAND type is set */
+		if ((__raw_readl(gpmc_cs_base_add + GPMC_CONFIG1) & 0xC00) ==
+		    0x800) {
+			/* Found it!! */
+			break;
+		}
+		cs++;
+	}
+	if (cs > GPMC_MAX_CS) {
+		printf("NAND: Unable to find NAND settings in " \
+		       "GPMC Configuration - quitting\n");
+	}
+
+	gpmc_config = __raw_readl(GPMC_CONFIG);
+	/* Disable Write protect */
+	gpmc_config |= 0x10;
+	__raw_writel(gpmc_config, GPMC_CONFIG);
+
+	nand->IO_ADDR_R = (int *) gpmc_cs_base_add + GPMC_NAND_DAT;
+	nand->IO_ADDR_W = (int *) gpmc_cs_base_add + GPMC_NAND_CMD;
+
+	nand->hwcontrol = omap_nand_hwcontrol;
+	nand->options = NAND_NO_PADDING | NAND_CACHEPRG | NAND_NO_AUTOINCR |
+			NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR;
+	nand->read_buf = omap_nand_read_buf;
+	nand->write_buf = omap_nand_write_buf;
+	nand->eccmode = NAND_ECC_SOFT;
+	/* if RDY/BSY line is connected to OMAP then use the omap ready
+	 * function and the generic nand_wait function which reads the
+	 * status register after monitoring the RDY/BSY line. Otherwise
+	 * use a standard chip delay which is slightly more than tR
+	 * (AC Timing) of the NAND device and read the status register
+	 * until you get a failure or success
+	 */
+	nand->waitfunc = omap_nand_wait;
+	nand->chip_delay = 50;
+
+	return 0;
+}
+#endif /* (CONFIG_COMMANDS & CFG_CMD_NAND) */
diff --git a/board/omap3530beagle/omap3530beagle.c b/board/omap3530beagle/omap3530beagle.c
new file mode 100644
index 0000000..7d9a566
--- /dev/null
+++ b/board/omap3530beagle/omap3530beagle.c
@@ -0,0 +1,388 @@
+/*
+ * (C) Copyright 2004-2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * Author :
+ *      Sunil Kumar <sunilsaini05@gmail.com>
+ *      Shashi Ranjan <shashiranjanmca05@gmail.com>
+ *
+ * Derived from Beagle Board and 3430 SDP code by
+ *      Richard Woodruff <r-woodruff2@ti.com>
+ *      Syed Mohammed Khasim <khasim@ti.com>
+ *
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/bits.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/mem.h>
+#include <i2c.h>
+#include <asm/mach-types.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND) && defined(CFG_NAND_LEGACY)
+#include <linux/mtd/nand_legacy.h>
+extern struct nand_chip nand_dev_desc[CFG_MAX_NAND_DEVICE];
+#endif
+
+#define NOT_EARLY 0
+
+/* Permission values for registers -Full fledged permissions to all */
+#define UNLOCK_1 0xFFFFFFFF
+#define UNLOCK_2 0x00000000
+#define UNLOCK_3 0x0000FFFF
+
+/******************************************************************************
+ * Routine: delay
+ * Description: spinning delay to use before udelay works
+ *****************************************************************************/
+static inline void delay(unsigned long loops)
+{
+	__asm__ volatile ("1:\n" "subs %0, %1, #1\n"
+			  "bne 1b":"=r" (loops):"0"(loops));
+}
+
+/******************************************************************************
+ * Routine: board_init
+ * Description: Early hardware init.
+ *****************************************************************************/
+int board_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gpmc_init(); /* in SRAM or SDRAM, finish GPMC */
+	/* board id for Linux */
+	gd->bd->bi_arch_number = MACH_TYPE_OMAP3_BEAGLE;
+	/* boot param addr */
+	gd->bd->bi_boot_params = (OMAP34XX_SDRC_CS0 + 0x100);
+
+	return 0;
+}
+
+/******************************************************************************
+ * Routine: secure_unlock
+ * Description: Setup security registers for access
+ *              (GP Device only)
+ *****************************************************************************/
+void secure_unlock_mem(void)
+{
+	/* Protection Module Register Target APE (PM_RT) */
+	__raw_writel(UNLOCK_1, RT_REQ_INFO_PERMISSION_1);
+	__raw_writel(UNLOCK_1, RT_READ_PERMISSION_0);
+	__raw_writel(UNLOCK_1, RT_WRITE_PERMISSION_0);
+	__raw_writel(UNLOCK_2, RT_ADDR_MATCH_1);
+
+	__raw_writel(UNLOCK_3, GPMC_REQ_INFO_PERMISSION_0);
+	__raw_writel(UNLOCK_3, GPMC_READ_PERMISSION_0);
+	__raw_writel(UNLOCK_3, GPMC_WRITE_PERMISSION_0);
+
+	__raw_writel(UNLOCK_3, OCM_REQ_INFO_PERMISSION_0);
+	__raw_writel(UNLOCK_3, OCM_READ_PERMISSION_0);
+	__raw_writel(UNLOCK_3, OCM_WRITE_PERMISSION_0);
+	__raw_writel(UNLOCK_2, OCM_ADDR_MATCH_2);
+
+	/* IVA Changes */
+	__raw_writel(UNLOCK_3, IVA2_REQ_INFO_PERMISSION_0);
+	__raw_writel(UNLOCK_3, IVA2_READ_PERMISSION_0);
+	__raw_writel(UNLOCK_3, IVA2_WRITE_PERMISSION_0);
+
+	__raw_writel(UNLOCK_1, SMS_RG_ATT0);	/* SDRC region 0 public */
+}
+
+/******************************************************************************
+ * Routine: secureworld_exit()
+ * Description: If chip is EMU and boot type is external
+ *		configure secure registers and exit secure world
+ *              general use.
+ *****************************************************************************/
+void secureworld_exit()
+{
+	unsigned long i;
+
+	/* configrue non-secure access control register */
+	__asm__ __volatile__("mrc p15, 0, %0, c1, c1, 2":"=r"(i));
+	/* enabling co-processor CP10 and CP11 accesses in NS world */
+	__asm__ __volatile__("orr %0, %0, #0xC00":"=r"(i));
+	/* allow allocation of locked TLBs and L2 lines in NS world */
+	/* allow use of PLE registers in NS world also */
+	__asm__ __volatile__("orr %0, %0, #0x70000":"=r"(i));
+	__asm__ __volatile__("mcr p15, 0, %0, c1, c1, 2":"=r"(i));
+
+	/* Enable ASA in ACR register */
+	__asm__ __volatile__("mrc p15, 0, %0, c1, c0, 1":"=r"(i));
+	__asm__ __volatile__("orr %0, %0, #0x10":"=r"(i));
+	__asm__ __volatile__("mcr p15, 0, %0, c1, c0, 1":"=r"(i));
+
+	/* Exiting secure world */
+	__asm__ __volatile__("mrc p15, 0, %0, c1, c1, 0":"=r"(i));
+	__asm__ __volatile__("orr %0, %0, #0x31":"=r"(i));
+	__asm__ __volatile__("mcr p15, 0, %0, c1, c1, 0":"=r"(i));
+}
+
+/******************************************************************************
+ * Routine: setup_auxcr()
+ * Description: Write to AuxCR desired value using SMI.
+ *              general use.
+ *****************************************************************************/
+void setup_auxcr()
+{
+	unsigned long i;
+	volatile unsigned int j;
+	/* Save r0, r12 and restore them after usage */
+	__asm__ __volatile__("mov %0, r12":"=r"(j));
+	__asm__ __volatile__("mov %0, r0":"=r"(i));
+
+	/* GP Device ROM code API usage here */
+	/* r12 = AUXCR Write function and r0 value */
+	__asm__ __volatile__("mov r12, #0x3");
+	__asm__ __volatile__("mrc p15, 0, r0, c1, c0, 1");
+	/* Enabling ASA */
+	__asm__ __volatile__("orr r0, r0, #0x10");
+	/* SMI instruction to call ROM Code API */
+	__asm__ __volatile__(".word 0xE1600070");
+	__asm__ __volatile__("mov r0, %0":"=r"(i));
+	__asm__ __volatile__("mov r12, %0":"=r"(j));
+}
+
+/******************************************************************************
+ * Routine: try_unlock_sram()
+ * Description: If chip is GP/EMU(special) type, unlock the SRAM for
+ *              general use.
+ *****************************************************************************/
+void try_unlock_memory()
+{
+	int mode;
+	int in_sdram = running_in_sdram();
+
+	/* if GP device unlock device SRAM for general use */
+	/* secure code breaks for Secure/Emulation device - HS/E/T */
+	mode = get_device_type();
+	if (mode == GP_DEVICE)
+		secure_unlock_mem();
+
+	/* If device is EMU and boot is XIP external booting
+	 * Unlock firewalls and disable L2 and put chip
+	 * out of secure world
+	 */
+	/* Assuming memories are unlocked by the demon who put us in SDRAM */
+	if ((mode <= EMU_DEVICE) && (get_boot_type() == 0x1F)
+	    && (!in_sdram)) {
+		secure_unlock_mem();
+		secureworld_exit();
+	}
+
+	return;
+}
+
+/******************************************************************************
+ * Routine: s_init
+ * Description: Does early system init of muxing and clocks.
+ *              - Called path is with SRAM stack.
+ *****************************************************************************/
+void s_init(void)
+{
+	int in_sdram = running_in_sdram();
+
+	watchdog_init();
+
+	try_unlock_memory();
+
+	/* Right now flushing at low MPU speed.
+	   Need to move after clock init */
+	v7_flush_dcache_all(get_device_type());
+#ifndef CONFIG_ICACHE_OFF
+	icache_enable();
+#endif
+
+#ifdef CONFIG_L2_OFF
+	l2cache_disable();
+#else
+	l2cache_enable();
+#endif
+	/* Writing to AuxCR in U-boot using SMI for GP DEV */
+	/* Currently SMI in Kernel on ES2 devices seems to have an isse
+	 * Once that is resolved, we can postpone this config to kernel
+	 */
+	if (get_device_type() == GP_DEVICE)
+		setup_auxcr();
+
+	set_muxconf_regs();
+	delay(100);
+
+	prcm_init();
+
+	per_clocks_enable();
+
+	if (!in_sdram)
+		sdrc_init();
+}
+
+/******************************************************************************
+ * Routine: misc_init_r
+ * Description: Init ethernet (done here so udelay works)
+ *****************************************************************************/
+int misc_init_r(void)
+{
+
+	unsigned char byte;
+
+#ifdef CONFIG_DRIVER_OMAP34XX_I2C
+	i2c_init(CFG_I2C_SPEED, CFG_I2C_SLAVE);
+#endif
+	byte = 0x20;
+	i2c_write(0x4B, 0x7A, 1, &byte, 1);
+	byte = 0x03;
+	i2c_write(0x4B, 0x7D, 1, &byte, 1);
+	byte = 0xE0;
+	i2c_write(0x4B, 0x8E, 1, &byte, 1);
+	byte = 0x05;
+	i2c_write(0x4B, 0x91, 1, &byte, 1);
+	byte = 0x20;
+	i2c_write(0x4B, 0x96, 1, &byte, 1);
+	byte = 0x03;
+	i2c_write(0x4B, 0x99, 1, &byte, 1);
+	byte = 0x33;
+	i2c_write(0x4A, 0xEE, 1, &byte, 1);
+
+	*((uint *) 0x49058034) = 0xFFFFFAF9;
+	*((uint *) 0x49056034) = 0x0F9F0FFF;
+	*((uint *) 0x49058094) = 0x00000506;
+	*((uint *) 0x49056094) = 0xF060F000;
+
+	return (0);
+}
+
+
+/******************************************************************************
+ * Routine: wait_for_command_complete
+ * Description: Wait for posting to finish on watchdog
+ *****************************************************************************/
+void wait_for_command_complete(unsigned int wd_base)
+{
+	int pending = 1;
+	do {
+		pending = __raw_readl(wd_base + WWPS);
+	} while (pending);
+}
+
+/******************************************************************************
+ * Routine: watchdog_init
+ * Description: Shut down watch dogs
+ *****************************************************************************/
+void watchdog_init(void)
+{
+	/* There are 3 watch dogs WD1=Secure, WD2=MPU, WD3=IVA. WD1 is
+	 * either taken care of by ROM (HS/EMU) or not accessible (GP).
+	 * We need to take care of WD2-MPU or take a PRCM reset. WD3
+	 * should not be running and does not generate a PRCM reset.
+	 */
+
+	sr32(CM_FCLKEN_WKUP, 5, 1, 1);
+	sr32(CM_ICLKEN_WKUP, 5, 1, 1);
+	wait_on_value(BIT5, 0x20, CM_IDLEST_WKUP, 5);	/* some issue here */
+
+	__raw_writel(WD_UNLOCK1, WD2_BASE + WSPR);
+	wait_for_command_complete(WD2_BASE);
+	__raw_writel(WD_UNLOCK2, WD2_BASE + WSPR);
+}
+
+/******************************************************************************
+ * Routine: dram_init
+ * Description: sets uboots idea of sdram size
+ *****************************************************************************/
+int dram_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	unsigned int size0 = 0, size1 = 0;
+	u32 mtype, btype;
+
+	btype = get_board_type();
+	mtype = get_mem_type();
+
+	display_board_info(btype);
+
+	/* If a second bank of DDR is attached to CS1 this is
+	 * where it can be started.  Early init code will init
+	 * memory on CS0.
+	 */
+	if ((mtype == DDR_COMBO) || (mtype == DDR_STACKED))
+		do_sdrc_init(SDRC_CS1_OSET, NOT_EARLY);
+
+	size0 = get_sdr_cs_size(SDRC_CS0_OSET);
+	size1 = get_sdr_cs_size(SDRC_CS1_OSET);
+
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = size0;
+	gd->bd->bi_dram[1].start = PHYS_SDRAM_1 + size0;
+	gd->bd->bi_dram[1].size = size1;
+
+	return 0;
+}
+
+/******************************************************************************
+ * Routine: set_muxconf_regs
+ * Description: Setting up the configuration Mux registers specific to the
+ *              hardware. Many pins need to be moved from protect to primary
+ *              mode.
+ *****************************************************************************/
+void set_muxconf_regs(void)
+{
+	MUX_DEFAULT_ES2();
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND) && defined(CFG_NAND_LEGACY)
+/******************************************************************************
+ * Routine: nand+_init
+ * Description: Set up nand for nand and jffs2 commands
+ *****************************************************************************/
+void nand_init(void)
+{
+	extern flash_info_t flash_info[];
+
+	nand_probe(CFG_NAND_ADDR);
+	if (nand_dev_desc[0].ChipID != NAND_ChipID_UNKNOWN)
+		print_size(nand_dev_desc[0].totlen, "\n");
+
+#ifdef CFG_JFFS2_MEM_NAND
+	flash_info[CFG_JFFS2_FIRST_BANK].flash_id = nand_dev_desc[0].id;
+	/* only read kernel single meg partition */
+	flash_info[CFG_JFFS2_FIRST_BANK].size = 1024 * 1024 * 2;
+	/* 1024 blocks in 16meg chip (use less for raw/copied partition) */
+	flash_info[CFG_JFFS2_FIRST_BANK].sector_count = 1024;
+	/* ?, ram for now, open question, copy to RAM or adapt for NAND */
+	flash_info[CFG_JFFS2_FIRST_BANK].start[0] = 0x80200000;
+#endif
+}
+#endif
+
+/******************************************************************************
+ * Dummy function to handle errors for EABI incompatibility
+ *****************************************************************************/
+void raise(void)
+{
+}
+
+/******************************************************************************
+ * Dummy function to handle errors for EABI incompatibility
+ *****************************************************************************/
+void abort(void)
+{
+}
diff --git a/board/omap3530beagle/sys_info.c b/board/omap3530beagle/sys_info.c
new file mode 100644
index 0000000..a275557
--- /dev/null
+++ b/board/omap3530beagle/sys_info.c
@@ -0,0 +1,309 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * Derived from Beagle Board and 3430 SDP code by
+ *      Richard Woodruff <r-woodruff2@ti.com>
+ *      Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/bits.h>
+#include <asm/arch/mem.h>	/* get mem tables */
+#include <asm/arch/sys_proto.h>
+#include <i2c.h>
+
+/**************************************************************************
+ * get_gpmc0_type()
+ ***************************************************************************/
+u32 get_gpmc0_type(void)
+{
+	/* Default NAND */
+	return (2);
+}
+
+/****************************************************
+ * get_cpu_type() - low level get cpu type
+ * - no C globals yet.
+ ****************************************************/
+u32 get_cpu_type(void)
+{
+	/* fixme, need to get register defines for OMAP3 */
+	return (CPU_3430);
+}
+
+/******************************************
+ * get_cpu_rev(void) - extract version info
+ ******************************************/
+u32 get_cpu_rev(void)
+{
+	u32 cpuid = 0;
+	/* On ES1.0 the IDCODE register is not exposed on L4
+	 * so using CPU ID to differentiate
+	 * between ES2.0 and ES1.0.
+	 */
+	__asm__ __volatile__("mrc p15, 0, %0, c0, c0, 0":"=r"(cpuid));
+	if ((cpuid & 0xf) == 0x0)
+		return CPU_3430_ES1;
+	else
+		return CPU_3430_ES2;
+
+}
+
+/****************************************************
+ * is_mem_sdr() - return 1 if mem type in use is SDR
+ ****************************************************/
+u32 is_mem_sdr(void)
+{
+	volatile u32 *burst = (volatile u32 *) (SDRC_MR_0 + SDRC_CS0_OSET);
+	if (*burst == SDP_SDRC_MR_0_SDR)
+		return (1);
+	return (0);
+}
+
+/***********************************************************
+ * get_mem_type() - identify type of mDDR part used.
+ ***********************************************************/
+u32 get_mem_type(void)
+{
+	/* Current SDP3430 uses 2x16 MDDR Infenion parts */
+	return (DDR_DISCRETE);
+}
+
+/***********************************************************************
+ * get_cs0_size() - get size of chip select 0/1
+ ************************************************************************/
+u32 get_sdr_cs_size(u32 offset)
+{
+	u32 size;
+
+	/* get ram size field */
+	size = __raw_readl(SDRC_MCFG_0 + offset) >> 8;
+	size &= 0x3FF;		/* remove unwanted bits */
+	size *= SZ_2M;		/* find size in MB */
+	return (size);
+}
+
+/***********************************************************************
+ * get_board_type() - get board type based on current production stats.
+ *  - NOTE-1-: 2 I2C EEPROMs will someday be populated with proper info.
+ *    when they are available we can get info from there.  This should
+ *    be correct of all known boards up until today.
+ *  - NOTE-2- EEPROMs are populated but they are updated very slowly.  To
+ *    avoid waiting on them we will use ES version of the chip to get info.
+ *    A later version of the FPGA migth solve their speed issue.
+ ************************************************************************/
+u32 get_board_type(void)
+{
+	if (get_cpu_rev() == CPU_3430_ES2)
+		return SDP_3430_V2;
+	else
+		return SDP_3430_V1;
+}
+
+/******************************************************************
+ * get_sysboot_value() - get init word settings
+ ******************************************************************/
+inline u32 get_sysboot_value(void)
+{
+	return (0x0000003F & __raw_readl(CONTROL_STATUS));
+}
+
+/***************************************************************************
+ *  get_gpmc0_base() - Return current address hardware will be
+ *     fetching from. The below effectively gives what is correct, its a bit
+ *   mis-leading compared to the TRM.  For the most general case the mask
+ *   needs to be also taken into account this does work in practice.
+ *   - for u-boot we currently map:
+ *       -- 0 to nothing,
+ *       -- 4 to flash
+ *       -- 8 to enent
+ *       -- c to wifi
+ ****************************************************************************/
+u32 get_gpmc0_base(void)
+{
+	u32 b;
+
+	b = __raw_readl(GPMC_CONFIG_CS0 + GPMC_CONFIG7);
+	b &= 0x1F;		/* keep base [5:0] */
+	b = b << 24;		/* ret 0x0b000000 */
+	return (b);
+}
+
+/*******************************************************************
+ * get_gpmc0_width() - See if bus is in x8 or x16 (mainly for nand)
+ *******************************************************************/
+u32 get_gpmc0_width(void)
+{
+	return (WIDTH_16BIT);
+}
+
+/*************************************************************************
+ * get_board_rev() - setup to pass kernel board revision information
+ * returns:(bit[0-3] sub version, higher bit[7-4] is higher version)
+ *************************************************************************/
+u32 get_board_rev(void)
+{
+	return (0x20);
+}
+
+/*********************************************************************
+ *  display_board_info() - print banner with board info.
+ *********************************************************************/
+void display_board_info(u32 btype)
+{
+	char *bootmode[] = {
+		"NOR",
+		"ONND",
+		"NAND",
+		"P2a",
+		"NOR",
+		"NOR",
+		"P2a",
+		"P2b",
+	};
+	u32 brev = get_board_rev();
+	char cpu_3430s[] = "3530";
+	char db_ver[] = "0.0";	/* board type */
+	char mem_sdr[] = "mSDR";	/* memory type */
+	char mem_ddr[] = "LPDDR";
+	char t_tst[] = "TST";	/* security level */
+	char t_emu[] = "EMU";
+	char t_hs[] = "HS";
+	char t_gp[] = "GP";
+	char unk[] = "?";
+#ifdef CONFIG_LED_INFO
+	char led_string[CONFIG_LED_LEN] = { 0 };
+#endif
+	char p_l3[] = "165";
+	char p_cpu[] = "2";
+
+	char *cpu_s, *db_s, *mem_s, *sec_s;
+	u32 cpu, rev, sec;
+
+	rev = get_cpu_rev();
+	cpu = get_cpu_type();
+	sec = get_device_type();
+
+	if (is_mem_sdr())
+		mem_s = mem_sdr;
+	else
+		mem_s = mem_ddr;
+
+	cpu_s = cpu_3430s;
+
+	db_s = db_ver;
+	db_s[0] += (brev >> 4) & 0xF;
+	db_s[2] += brev & 0xF;
+
+	switch (sec) {
+	case TST_DEVICE:
+		sec_s = t_tst;
+		break;
+	case EMU_DEVICE:
+		sec_s = t_emu;
+		break;
+	case HS_DEVICE:
+		sec_s = t_hs;
+		break;
+	case GP_DEVICE:
+		sec_s = t_gp;
+		break;
+	default:
+		sec_s = unk;
+	}
+
+	printf("OMAP%s-%s rev %d, CPU-OPP%s L3-%sMHz\n", cpu_s, sec_s, rev,
+	       p_cpu, p_l3);
+	printf("OMAP3 Beagle Board + %s/%s\n",
+	       mem_s, bootmode[get_gpmc0_type()]);
+
+}
+
+/********************************************************
+ *  get_base(); get upper addr of current execution
+ *******************************************************/
+u32 get_base(void)
+{
+	u32 val;
+
+	__asm__ __volatile__("mov %0, pc \n":"=r"(val)::"memory");
+	val &= 0xF0000000;
+	val >>= 28;
+	return (val);
+}
+
+/********************************************************
+ *  running_in_flash() - tell if currently running in
+ *   flash.
+ *******************************************************/
+u32 running_in_flash(void)
+{
+	if (get_base() < 4)
+		return (1);	/* in flash */
+
+	return (0);		/* running in SRAM or SDRAM */
+}
+
+/********************************************************
+ *  running_in_sram() - tell if currently running in
+ *   sram.
+ *******************************************************/
+u32 running_in_sram(void)
+{
+	if (get_base() == 4)
+		return (1);	/* in SRAM */
+
+	return (0);		/* running in FLASH or SDRAM */
+}
+
+/********************************************************
+ *  running_in_sdram() - tell if currently running in
+ *   flash.
+ *******************************************************/
+u32 running_in_sdram(void)
+{
+	if (get_base() > 4)
+		return (1);	/* in sdram */
+
+	return (0);		/* running in SRAM or FLASH */
+}
+
+/***************************************************************
+ *  get_boot_type() - Is this an XIP type device or a stream one
+ *   bits 4-0 specify type.  Bit 5 sys mem/perif
+ ***************************************************************/
+u32 get_boot_type(void)
+{
+	u32 v;
+
+	v = get_sysboot_value() & (BIT4 | BIT3 | BIT2 | BIT1 | BIT0);
+	return v;
+}
+
+/*************************************************************
+ *  get_device_type(): tell if GP/HS/EMU/TST
+ *************************************************************/
+u32 get_device_type(void)
+{
+	int mode;
+
+	mode = __raw_readl(CONTROL_STATUS) & (DEVICE_MASK);
+	return (mode >>= 8);
+}
diff --git a/board/omap3530beagle/syslib.c b/board/omap3530beagle/syslib.c
new file mode 100644
index 0000000..002c6e8
--- /dev/null
+++ b/board/omap3530beagle/syslib.c
@@ -0,0 +1,72 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * Richard Woodruff <r-woodruff2@ti.com>
+ * Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/bits.h>
+#include <asm/arch/mem.h>
+#include <asm/arch/clocks.h>
+#include <asm/arch/sys_proto.h>
+
+/************************************************************
+ * sdelay() - simple spin loop.  Will be constant time as
+ *  its generally used in bypass conditions only.  This
+ *  is necessary until timers are accessible.
+ *
+ *  not inline to increase chances its in cache when called
+ *************************************************************/
+void sdelay(unsigned long loops)
+{
+	__asm__ volatile ("1:\n" "subs %0, %1, #1\n"
+			  "bne 1b":"=r" (loops):"0"(loops));
+}
+
+/*****************************************************************
+ * sr32 - clear & set a value in a bit range for a 32 bit address
+ *****************************************************************/
+void sr32(u32 addr, u32 start_bit, u32 num_bits, u32 value)
+{
+	u32 tmp, msk = 0;
+	msk = 1 << num_bits;
+	--msk;
+	tmp = __raw_readl(addr) & ~(msk << start_bit);
+	tmp |= value << start_bit;
+	__raw_writel(tmp, addr);
+}
+
+/*********************************************************************
+ * wait_on_value() - common routine to allow waiting for changes in
+ *   volatile regs.
+ *********************************************************************/
+u32 wait_on_value(u32 read_bit_mask, u32 match_value, u32 read_addr, u32 bound)
+{
+	u32 i = 0, val;
+	do {
+		++i;
+		val = __raw_readl(read_addr) & read_bit_mask;
+		if (val == match_value)
+			return (1);
+		if (i == bound)
+			return (0);
+	} while (1);
+}
diff --git a/board/omap3530beagle/u-boot.lds b/board/omap3530beagle/u-boot.lds
new file mode 100644
index 0000000..72f15f6
--- /dev/null
+++ b/board/omap3530beagle/u-boot.lds
@@ -0,0 +1,63 @@
+/*
+ * January 2004 - Changed to support H4 device 
+ * Copyright (c) 2004 Texas Instruments 
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/omap3/start.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	.ARM.extab   : { *(.ARM.extab* .gnu.linkonce.armextab.*) }
+	__exidx_start = .;
+	.ARM.exidx   : { *(.ARM.exidx* .gnu.linkonce.armexidx.*) }
+	__exidx_end = .;
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff --git a/common/cmd_nand.c b/common/cmd_nand.c
index 9e38bf7..0ae362c 100644
--- a/common/cmd_nand.c
+++ b/common/cmd_nand.c
@@ -37,6 +37,12 @@ int find_dev_and_part(const char *id, struct mtd_device **dev,
 		u8 *part_num, struct part_info **part);
 #endif
 
+#if defined(CONFIG_OMAP) && (defined(CONFIG_OMAP3_BEAGLE))
+extern void omap_nand_switch_ecc(nand_info_t *nand, int hardware);
+#else
+#define omap_nand_switch_ecc(x, y) do {} while(0)
+#endif
+
 static int nand_dump_oob(nand_info_t *nand, ulong off)
 {
 	return 0;
@@ -222,7 +228,7 @@ int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 	    strncmp(cmd, "dump", 4) != 0 &&
 	    strncmp(cmd, "read", 4) != 0 && strncmp(cmd, "write", 5) != 0 &&
 	    strcmp(cmd, "scrub") != 0 && strcmp(cmd, "markbad") != 0 &&
-	    strcmp(cmd, "biterr") != 0 &&
+	    strcmp(cmd, "biterr") != 0 && strncmp(cmd, "ecc", 3) != 0 &&
 	    strcmp(cmd, "lock") != 0 && strcmp(cmd, "unlock") != 0 )
 		goto usage;
 
@@ -307,6 +313,19 @@ int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 
 	}
 
+	if (strncmp(cmd, "ecc", 3) == 0) {
+		if (argc < 2)
+			goto usage;
+		if (strncmp(argv[2], "hw", 2) == 0)
+			omap_nand_switch_ecc(nand, 1);
+		else if (strncmp(argv[2], "sw", 2) == 0)
+			omap_nand_switch_ecc(nand, 0);
+		else
+			goto usage;
+
+		return 0;
+	}
+
 	/* read write */
 	if (strncmp(cmd, "read", 4) == 0 || strncmp(cmd, "write", 5) == 0) {
 		int read;
@@ -472,6 +491,7 @@ U_BOOT_CMD(nand, 5, 1, do_nand,
 	"nand scrub - really clean NAND erasing bad blocks (UNSAFE)\n"
 	"nand markbad off - mark bad block at offset (UNSAFE)\n"
 	"nand biterr off - make a bit error at offset (UNSAFE)\n"
+	"nand ecc [hw/sw] - switch the ecc calculation algorithm \n"
 	"nand lock [tight] [status] - bring nand to lock state or display locked pages\n"
 	"nand unlock [offset] [size] - unlock section\n");
 
diff --git a/cpu/omap3/Makefile b/cpu/omap3/Makefile
new file mode 100644
index 0000000..097447a
--- /dev/null
+++ b/cpu/omap3/Makefile
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2000-2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(CPU).a
+
+START	= start.o
+OBJS	= interrupts.o cpu.o mmc.o
+
+all:	.depend $(START) $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(START:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(START:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/cpu/omap3/config.mk b/cpu/omap3/config.mk
new file mode 100644
index 0000000..7551677
--- /dev/null
+++ b/cpu/omap3/config.mk
@@ -0,0 +1,34 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+PLATFORM_RELFLAGS += -fno-strict-aliasing  -fno-common -ffixed-r8 \
+	-msoft-float
+
+PLATFORM_CPPFLAGS += -march=armv7a
+# =========================================================================
+#
+# Supply options according to compiler version
+#
+# =========================================================================
+#PLATFORM_CPPFLAGS +=$(call cc-option,-mapcs-32,-mabi=apcs-gnu)
+PLATFORM_CPPFLAGS +=$(call cc-option)
+PLATFORM_RELFLAGS +=$(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,))
diff --git a/cpu/omap3/cpu.c b/cpu/omap3/cpu.c
new file mode 100644
index 0000000..59e6a58
--- /dev/null
+++ b/cpu/omap3/cpu.c
@@ -0,0 +1,221 @@
+/*
+ * (C) Copyright 2008 Texas Insturments
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * CPU specific code
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/arch/sys_proto.h>
+
+#ifdef CONFIG_USE_IRQ
+DECLARE_GLOBAL_DATA_PTR;
+#endif
+
+#ifndef CONFIG_L2_OFF
+void l2cache_disable(void);
+#endif
+
+/* read co-processor 15, register #1 (control register) */
+static unsigned long read_p15_c1(void)
+{
+	unsigned long value;
+
+	__asm__ __volatile__("mrc p15, 0, %0, c1, c0, 0\
+			     @ read control reg\n":"=r"(value)
+			     ::"memory");
+	return value;
+}
+
+/* write to co-processor 15, register #1 (control register) */
+static void write_p15_c1(unsigned long value)
+{
+	__asm__ __volatile__("mcr p15, 0, %0, c1, c0, 0\
+			     @ write it back\n"::"r"(value)
+			     : "memory");
+
+	read_p15_c1();
+}
+
+static void cp_delay(void)
+{
+	volatile int i;
+
+	/* Many OMAP regs need at least 2 nops  */
+	for (i = 0; i < 100; i++) ;
+}
+
+/* See also ARM Ref. Man. */
+#define C1_MMU		(1<<0)	/* mmu off/on */
+#define C1_ALIGN	(1<<1)	/* alignment faults off/on */
+#define C1_DC		(1<<2)	/* dcache off/on */
+#define C1_WB		(1<<3)	/* merging write buffer on/off */
+#define C1_BIG_ENDIAN	(1<<7)	/* big endian off/on */
+#define C1_SYS_PROT	(1<<8)	/* system protection */
+#define C1_ROM_PROT	(1<<9)	/* ROM protection */
+#define C1_IC		(1<<12)	/* icache off/on */
+#define C1_HIGH_VECTORS	(1<<13)	/* location of vectors: low/high addresses */
+#define RESERVED_1	(0xf << 3)	/* must be 111b for R/W */
+
+int cpu_init(void)
+{
+	/*
+	 * setup up stacks if necessary
+	 */
+#ifdef CONFIG_USE_IRQ
+	IRQ_STACK_START =
+	    _armboot_start - CFG_MALLOC_LEN - CFG_GBL_DATA_SIZE - 4;
+	FIQ_STACK_START = IRQ_STACK_START - CONFIG_STACKSIZE_IRQ;
+#endif
+	return 0;
+}
+
+int cleanup_before_linux(void)
+{
+	unsigned int i;
+
+	/*
+	 * this function is called just before we call linux
+	 * it prepares the processor for linux
+	 *
+	 * we turn off caches etc ...
+	 */
+	disable_interrupts();
+
+	/* turn off I/D-cache */
+	asm("mrc p15, 0, %0, c1, c0, 0":"=r"(i));
+	i &= ~(C1_DC | C1_IC);
+	asm("mcr p15, 0, %0, c1, c0, 0": :"r"(i));
+
+	/* invalidate I-cache */
+	arm_cache_flush();
+#ifndef CONFIG_L2_OFF
+	/* turn off L2 cache */
+	l2cache_disable();
+	/* invalidate L2 cache also */
+	v7_flush_dcache_all(get_device_type());
+#endif
+	i = 0;
+	/* mem barrier to sync up things */
+	asm("mcr p15, 0, %0, c7, c10, 4": :"r"(i));
+
+#ifndef CONFIG_L2_OFF
+	l2cache_enable();
+#endif
+
+	return (0);
+}
+
+int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	disable_interrupts();
+	reset_cpu(0);
+
+	/* NOTREACHED */
+	return (0);
+}
+
+void icache_enable(void)
+{
+	ulong reg;
+
+	reg = read_p15_c1();	/* get control reg. */
+	cp_delay();
+	write_p15_c1(reg | C1_IC);
+}
+
+void icache_disable(void)
+{
+	ulong reg;
+
+	reg = read_p15_c1();
+	cp_delay();
+	write_p15_c1(reg & ~C1_IC);
+}
+
+void l2cache_enable()
+{
+	unsigned long i;
+	volatile unsigned int j;
+
+	/* ES2 onwards we can disable/enable L2 ourselves */
+	if (get_cpu_rev() == CPU_3430_ES2) {
+		__asm__ __volatile__("mrc p15, 0, %0, c1, c0, 1":"=r"(i));
+		__asm__ __volatile__("orr %0, %0, #0x2":"=r"(i));
+		__asm__ __volatile__("mcr p15, 0, %0, c1, c0, 1":"=r"(i));
+	} else {
+		/* Save r0, r12 and restore them after usage */
+		__asm__ __volatile__("mov %0, r12":"=r"(j));
+		__asm__ __volatile__("mov %0, r0":"=r"(i));
+
+		/* GP Device ROM code API usage here */
+		/* r12 = AUXCR Write function and r0 value */
+		__asm__ __volatile__("mov r12, #0x3");
+		__asm__ __volatile__("mrc p15, 0, r0, c1, c0, 1");
+		__asm__ __volatile__("orr r0, r0, #0x2");
+		/* SMI instruction to call ROM Code API */
+		__asm__ __volatile__(".word 0xE1600070");
+		__asm__ __volatile__("mov r0, %0":"=r"(i));
+		__asm__ __volatile__("mov r12, %0":"=r"(j));
+	}
+
+}
+
+void l2cache_disable()
+{
+	unsigned long i;
+	volatile unsigned int j;
+
+	/* ES2 onwards we can disable/enable L2 ourselves */
+	if (get_cpu_rev() == CPU_3430_ES2) {
+		__asm__ __volatile__("mrc p15, 0, %0, c1, c0, 1":"=r"(i));
+		__asm__ __volatile__("bic %0, %0, #0x2":"=r"(i));
+		__asm__ __volatile__("mcr p15, 0, %0, c1, c0, 1":"=r"(i));
+	} else {
+		/* Save r0, r12 and restore them after usage */
+		__asm__ __volatile__("mov %0, r12":"=r"(j));
+		__asm__ __volatile__("mov %0, r0":"=r"(i));
+
+		/* GP Device ROM code API usage here */
+		/* r12 = AUXCR Write function and r0 value */
+		__asm__ __volatile__("mov r12, #0x3");
+		__asm__ __volatile__("mrc p15, 0, r0, c1, c0, 1");
+		__asm__ __volatile__("bic r0, r0, #0x2");
+		/* SMI instruction to call ROM Code API */
+		__asm__ __volatile__(".word 0xE1600070");
+		__asm__ __volatile__("mov r0, %0":"=r"(i));
+		__asm__ __volatile__("mov r12, %0":"=r"(j));
+	}
+}
+
+int icache_status(void)
+{
+	return (read_p15_c1() & C1_IC) != 0;
+}
diff --git a/cpu/omap3/interrupts.c b/cpu/omap3/interrupts.c
new file mode 100644
index 0000000..818b833
--- /dev/null
+++ b/cpu/omap3/interrupts.c
@@ -0,0 +1,304 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments
+ *
+ * Richard Woodruff <r-woodruff2@ti.com>
+ * Syed Moahmmed Khasim <khasim@ti.com>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/bits.h>
+
+#include <asm/proc-armv/ptrace.h>
+
+#define TIMER_LOAD_VAL 0
+
+/* macro to read the 32 bit timer */
+#define READ_TIMER (*(volatile ulong *)(CFG_TIMERBASE+TCRR))
+
+#ifdef CONFIG_USE_IRQ
+/* enable IRQ interrupts */
+void enable_interrupts(void)
+{
+	unsigned long temp;
+	__asm__ __volatile__("mrs %0, cpsr\n"
+			     "bic %0, %0, #0x80\n" "msr cpsr_c, %0":"=r"(temp)
+			     ::"memory");
+}
+
+/*
+ * disable IRQ/FIQ interrupts
+ * returns true if interrupts had been enabled before we disabled them
+ */
+int disable_interrupts(void)
+{
+	unsigned long old, temp;
+	__asm__ __volatile__("mrs %0, cpsr\n"
+			     "orr %1, %0, #0xc0\n"
+			     "msr cpsr_c, %1":"=r"(old), "=r"(temp)
+			     ::"memory");
+	return (old & 0x80) == 0;
+}
+#else
+void enable_interrupts(void)
+{
+	return;
+}
+int disable_interrupts(void)
+{
+	return 0;
+}
+#endif
+
+void bad_mode(void)
+{
+	panic("Resetting CPU ...\n");
+	reset_cpu(0);
+}
+
+void show_regs(struct pt_regs *regs)
+{
+	unsigned long flags;
+	const char *processor_modes[] = {
+		"USER_26", "FIQ_26", "IRQ_26", "SVC_26",
+		"UK4_26", "UK5_26", "UK6_26", "UK7_26",
+		"UK8_26", "UK9_26", "UK10_26", "UK11_26",
+		"UK12_26", "UK13_26", "UK14_26", "UK15_26",
+		"USER_32", "FIQ_32", "IRQ_32", "SVC_32",
+		"UK4_32", "UK5_32", "UK6_32", "ABT_32",
+		"UK8_32", "UK9_32", "UK10_32", "UND_32",
+		"UK12_32", "UK13_32", "UK14_32", "SYS_32",
+	};
+
+	flags = condition_codes(regs);
+
+	printf("pc : [<%08lx>]    lr : [<%08lx>]\n"
+	       "sp : %08lx  ip : %08lx  fp : %08lx\n",
+	       instruction_pointer(regs),
+	       regs->ARM_lr, regs->ARM_sp, regs->ARM_ip, regs->ARM_fp);
+	printf("r10: %08lx  r9 : %08lx  r8 : %08lx\n",
+	       regs->ARM_r10, regs->ARM_r9, regs->ARM_r8);
+	printf("r7 : %08lx  r6 : %08lx  r5 : %08lx  r4 : %08lx\n",
+	       regs->ARM_r7, regs->ARM_r6, regs->ARM_r5, regs->ARM_r4);
+	printf("r3 : %08lx  r2 : %08lx  r1 : %08lx  r0 : %08lx\n",
+	       regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
+	printf("Flags: %c%c%c%c",
+	       flags & CC_N_BIT ? 'N' : 'n',
+	       flags & CC_Z_BIT ? 'Z' : 'z',
+	       flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
+	printf("  IRQs %s  FIQs %s  Mode %s%s\n",
+	       interrupts_enabled(regs) ? "on" : "off",
+	       fast_interrupts_enabled(regs) ? "on" : "off",
+	       processor_modes[processor_mode(regs)],
+	       thumb_mode(regs) ? " (T)" : "");
+}
+
+void do_undefined_instruction(struct pt_regs *pt_regs)
+{
+	printf("undefined instruction\n");
+	show_regs(pt_regs);
+	bad_mode();
+}
+
+void do_software_interrupt(struct pt_regs *pt_regs)
+{
+	printf("software interrupt\n");
+	show_regs(pt_regs);
+	bad_mode();
+}
+
+void do_prefetch_abort(struct pt_regs *pt_regs)
+{
+	printf("prefetch abort\n");
+	show_regs(pt_regs);
+	bad_mode();
+}
+
+void do_data_abort(struct pt_regs *pt_regs)
+{
+	printf("data abort\n");
+	show_regs(pt_regs);
+	bad_mode();
+}
+
+void do_not_used(struct pt_regs *pt_regs)
+{
+	printf("not used\n");
+	show_regs(pt_regs);
+	bad_mode();
+}
+
+void do_fiq(struct pt_regs *pt_regs)
+{
+	printf("fast interrupt request\n");
+	show_regs(pt_regs);
+	bad_mode();
+}
+
+void do_irq(struct pt_regs *pt_regs)
+{
+	printf("interrupt request\n");
+	show_regs(pt_regs);
+	bad_mode();
+}
+
+
+static ulong timestamp;
+static ulong lastinc;
+
+/* nothing really to do with interrupts, just starts up a counter. */
+int interrupt_init(void)
+{
+	int32_t val;
+
+	/* Start the counter ticking up */
+	/* reload value on overflow */
+	*((int32_t *) (CFG_TIMERBASE + TLDR)) = TIMER_LOAD_VAL;
+	/* mask to enable timer */
+	val = (CFG_PVT << 2) | BIT5 | BIT1 | BIT0;
+	*((int32_t *) (CFG_TIMERBASE + TCLR)) = val;	/* start timer */
+
+	reset_timer_masked();	/* init the timestamp and lastinc value */
+
+	return (0);
+}
+
+/*
+ * timer without interrupts
+ */
+void reset_timer(void)
+{
+	reset_timer_masked();
+}
+
+ulong get_timer(ulong base)
+{
+	return get_timer_masked() - base;
+}
+
+void set_timer(ulong t)
+{
+	timestamp = t;
+}
+
+/* delay x useconds AND perserve advance timstamp value */
+void udelay(unsigned long usec)
+{
+	ulong tmo, tmp;
+
+	/* if "big" number, spread normalization to seconds */
+	if (usec >= 1000) {
+		/* if "big" number, spread normalization to seconds */
+		tmo = usec / 1000;
+		/* find number of "ticks" to wait to achieve target */
+		tmo *= CFG_HZ;
+		tmo /= 1000;	/* finish normalize. */
+	} else {/* else small number, don't kill it prior to HZ multiply */
+		tmo = usec * CFG_HZ;
+		tmo /= (1000 * 1000);
+	}
+
+	tmp = get_timer(0);	/* get current timestamp */
+	/* if setting this forward will roll time stamp */
+	if ((tmo + tmp + 1) < tmp)
+		/* reset "advancing" timestamp to 0, set lastinc value */
+		reset_timer_masked();
+	else
+		tmo += tmp;	/* else, set advancing stamp wake up time */
+	while (get_timer_masked() < tmo)	/* loop till event */
+		 /*NOP*/;
+}
+
+void reset_timer_masked(void)
+{
+	/* reset time */
+	lastinc = READ_TIMER;	/* capture current incrementer value time */
+	timestamp = 0;		/* start "advancing" time stamp from 0 */
+}
+
+ulong get_timer_masked(void)
+{
+	ulong now = READ_TIMER;	/* current tick value */
+
+	if (now >= lastinc)	/* normal mode (non roll) */
+		/* move stamp fordward with absoulte diff ticks */
+		timestamp += (now - lastinc);
+	else	/* we have rollover of incrementer */
+		timestamp += (0xFFFFFFFF - lastinc) + now;
+	lastinc = now;
+	return timestamp;
+}
+
+/* waits specified delay value and resets timestamp */
+void udelay_masked(unsigned long usec)
+{
+	ulong tmo;
+	ulong endtime;
+	signed long diff;
+
+	/* if "big" number, spread normalization to seconds */
+	if (usec >= 1000) {
+		/* start to normalize for usec to ticks per sec */
+		tmo = usec / 1000;
+		/* find number of "ticks" to wait to achieve target */
+		tmo *= CFG_HZ;
+		tmo /= 1000;	/* finish normalize. */
+	} else {		/* else small number, */
+				/* don't kill it prior to HZ multiply */
+		tmo = usec * CFG_HZ;
+		tmo /= (1000 * 1000);
+	}
+	endtime = get_timer_masked() + tmo;
+
+	do {
+		ulong now = get_timer_masked();
+		diff = endtime - now;
+	} while (diff >= 0);
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On ARM it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return get_timer(0);
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On ARM it returns the number of timer ticks per second.
+ */
+ulong get_tbclk(void)
+{
+	ulong tbclk;
+	tbclk = CFG_HZ;
+	return tbclk;
+}
+
diff --git a/cpu/omap3/mmc.c b/cpu/omap3/mmc.c
new file mode 100644
index 0000000..741360b
--- /dev/null
+++ b/cpu/omap3/mmc.c
@@ -0,0 +1,559 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ * Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation's version 2 of
+ * the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <fat.h>
+#include <mmc.h>
+#include <part.h>
+#include <i2c.h>
+
+const unsigned short mmc_transspeed_val[15][4] = {
+	{CLKD(10, 1), CLKD(10, 10), CLKD(10, 100), CLKD(10, 1000)},
+	{CLKD(12, 1), CLKD(12, 10), CLKD(12, 100), CLKD(12, 1000)},
+	{CLKD(13, 1), CLKD(13, 10), CLKD(13, 100), CLKD(13, 1000)},
+	{CLKD(15, 1), CLKD(15, 10), CLKD(15, 100), CLKD(15, 1000)},
+	{CLKD(20, 1), CLKD(20, 10), CLKD(20, 100), CLKD(20, 1000)},
+	{CLKD(26, 1), CLKD(26, 10), CLKD(26, 100), CLKD(26, 1000)},
+	{CLKD(30, 1), CLKD(30, 10), CLKD(30, 100), CLKD(30, 1000)},
+	{CLKD(35, 1), CLKD(35, 10), CLKD(35, 100), CLKD(35, 1000)},
+	{CLKD(40, 1), CLKD(40, 10), CLKD(40, 100), CLKD(40, 1000)},
+	{CLKD(45, 1), CLKD(45, 10), CLKD(45, 100), CLKD(45, 1000)},
+	{CLKD(52, 1), CLKD(52, 10), CLKD(52, 100), CLKD(52, 1000)},
+	{CLKD(55, 1), CLKD(55, 10), CLKD(55, 100), CLKD(55, 1000)},
+	{CLKD(60, 1), CLKD(60, 10), CLKD(60, 100), CLKD(60, 1000)},
+	{CLKD(70, 1), CLKD(70, 10), CLKD(70, 100), CLKD(70, 1000)},
+	{CLKD(80, 1), CLKD(80, 10), CLKD(80, 100), CLKD(80, 1000)}
+};
+
+mmc_card_data cur_card_data;
+static block_dev_desc_t mmc_blk_dev;
+
+block_dev_desc_t *mmc_get_dev(int dev)
+{
+	return ((block_dev_desc_t *) &mmc_blk_dev);
+}
+
+void twl4030_mmc_config(void)
+{
+	unsigned char data;
+
+	data = 0x20;
+	i2c_write(0x4B, 0x82, 1, &data, 1);
+	data = 0x2;
+	i2c_write(0x4B, 0x85, 1, &data, 1);
+}
+
+unsigned char mmc_board_init(void)
+{
+	unsigned int value = 0;
+
+	twl4030_mmc_config();
+
+	value = CONTROL_PBIAS_LITE;
+	CONTROL_PBIAS_LITE = value | (1 << 2) | (1 << 1) | (1 << 9);
+
+	value = CONTROL_DEV_CONF0;
+	CONTROL_DEV_CONF0 = value | (1 << 24);
+
+	return 1;
+}
+
+void mmc_init_stream(void)
+{
+	volatile unsigned int mmc_stat;
+
+	OMAP_HSMMC_CON |= INIT_INITSTREAM;
+
+	OMAP_HSMMC_CMD = MMC_CMD0;
+	do {
+		mmc_stat = OMAP_HSMMC_STAT;
+	} while (!(mmc_stat & CC_MASK));
+
+	OMAP_HSMMC_STAT = CC_MASK;
+
+	OMAP_HSMMC_CMD = MMC_CMD0;
+	do {
+		mmc_stat = OMAP_HSMMC_STAT;
+	} while (!(mmc_stat & CC_MASK));
+
+	OMAP_HSMMC_STAT = OMAP_HSMMC_STAT;
+	OMAP_HSMMC_CON &= ~INIT_INITSTREAM;
+}
+
+unsigned char mmc_clock_config(unsigned int iclk, unsigned short clk_div)
+{
+	unsigned int val;
+
+	mmc_reg_out(OMAP_HSMMC_SYSCTL, (ICE_MASK | DTO_MASK | CEN_MASK),
+		    (ICE_STOP | DTO_15THDTO | CEN_DISABLE));
+
+	switch (iclk) {
+	case CLK_INITSEQ:
+		val = MMC_INIT_SEQ_CLK / 2;
+		break;
+	case CLK_400KHZ:
+		val = MMC_400kHz_CLK;
+		break;
+	case CLK_MISC:
+		val = clk_div;
+		break;
+	default:
+		return 0;
+	}
+	mmc_reg_out(OMAP_HSMMC_SYSCTL,
+		    ICE_MASK | CLKD_MASK, (val << CLKD_OFFSET) | ICE_OSCILLATE);
+
+	while ((OMAP_HSMMC_SYSCTL & ICS_MASK) == ICS_NOTREADY) {
+	}
+
+	OMAP_HSMMC_SYSCTL |= CEN_ENABLE;
+	return 1;
+}
+
+unsigned char mmc_init_setup(void)
+{
+	unsigned int reg_val;
+
+	mmc_board_init();
+
+	OMAP_HSMMC_SYSCONFIG |= MMC_SOFTRESET;
+	while ((OMAP_HSMMC_SYSSTATUS & RESETDONE) == 0) ;
+
+	OMAP_HSMMC_SYSCTL |= SOFTRESETALL;
+	while ((OMAP_HSMMC_SYSCTL & SOFTRESETALL) != 0x0) ;
+
+	OMAP_HSMMC_HCTL = DTW_1_BITMODE | SDBP_PWROFF | SDVS_3V0;
+	OMAP_HSMMC_CAPA |= VS30_3V0SUP | VS18_1V8SUP;
+
+	reg_val = OMAP_HSMMC_CON & RESERVED_MASK;
+
+	OMAP_HSMMC_CON = CTPL_MMC_SD | reg_val | WPP_ACTIVEHIGH |
+	    CDP_ACTIVEHIGH | MIT_CTO | DW8_1_4BITMODE | MODE_FUNC |
+	    STR_BLOCK | HR_NOHOSTRESP | INIT_NOINIT | NOOPENDRAIN;
+
+	mmc_clock_config(CLK_INITSEQ, 0);
+	OMAP_HSMMC_HCTL |= SDBP_PWRON;
+
+	OMAP_HSMMC_IE = 0x307f0033;
+
+	mmc_init_stream();
+	return 1;
+}
+
+unsigned char mmc_send_cmd(unsigned int cmd, unsigned int arg,
+			   unsigned int *response)
+{
+	volatile unsigned int mmc_stat;
+
+	while ((OMAP_HSMMC_PSTATE & DATI_MASK) == DATI_CMDDIS) {
+	}
+
+	OMAP_HSMMC_BLK = BLEN_512BYTESLEN | NBLK_STPCNT;
+	OMAP_HSMMC_STAT = 0xFFFFFFFF;
+	OMAP_HSMMC_ARG = arg;
+	OMAP_HSMMC_CMD = cmd | CMD_TYPE_NORMAL | CICE_NOCHECK |
+	    CCCE_NOCHECK | MSBS_SGLEBLK | ACEN_DISABLE | BCE_DISABLE |
+	    DE_DISABLE;
+
+	while (1) {
+		do {
+			mmc_stat = OMAP_HSMMC_STAT;
+		} while (mmc_stat == 0);
+
+		if ((mmc_stat & ERRI_MASK) != 0)
+			return (unsigned char) mmc_stat;
+
+		if (mmc_stat & CC_MASK) {
+			OMAP_HSMMC_STAT = CC_MASK;
+			response[0] = OMAP_HSMMC_RSP10;
+			if ((cmd & RSP_TYPE_MASK) == RSP_TYPE_LGHT136) {
+				response[1] = OMAP_HSMMC_RSP32;
+				response[2] = OMAP_HSMMC_RSP54;
+				response[3] = OMAP_HSMMC_RSP76;
+			}
+			break;
+		}
+	}
+	return 1;
+}
+
+unsigned char mmc_read_data(unsigned int *output_buf)
+{
+	volatile unsigned int mmc_stat;
+	unsigned int read_count = 0;
+
+	/*
+	 * Start Polled Read
+	 */
+	while (1) {
+		do {
+			mmc_stat = OMAP_HSMMC_STAT;
+		} while (mmc_stat == 0);
+
+		if ((mmc_stat & ERRI_MASK) != 0)
+			return (unsigned char) mmc_stat;
+
+		if (mmc_stat & BRR_MASK) {
+			unsigned int k;
+
+			OMAP_HSMMC_STAT |= BRR_MASK;
+			for (k = 0; k < MMCSD_SECTOR_SIZE / 4; k++) {
+				*output_buf = OMAP_HSMMC_DATA;
+				output_buf++;
+				read_count += 4;
+			}
+		}
+
+		if (mmc_stat & BWR_MASK)
+			OMAP_HSMMC_STAT |= BWR_MASK;
+
+		if (mmc_stat & TC_MASK) {
+			OMAP_HSMMC_STAT |= TC_MASK;
+			break;
+		}
+	}
+	return 1;
+}
+
+unsigned char mmc_detect_card(mmc_card_data *mmc_card_cur)
+{
+	unsigned char err;
+	unsigned int argument = 0;
+	unsigned int ocr_value, ocr_recvd, ret_cmd41, hcs_val;
+	unsigned int resp[4];
+	unsigned short retry_cnt = 2000;
+
+	/* Set to Initialization Clock */
+	err = mmc_clock_config(CLK_400KHZ, 0);
+	if (err != 1)
+		return err;
+
+	mmc_card_cur->RCA = MMC_RELATIVE_CARD_ADDRESS;
+	argument = 0x00000000;
+
+	ocr_value = (0x1FF << 15);
+	err = mmc_send_cmd(MMC_CMD0, argument, resp);
+	if (err != 1)
+		return err;
+
+	argument = SD_CMD8_CHECK_PATTERN | SD_CMD8_2_7_3_6_V_RANGE;
+	err = mmc_send_cmd(MMC_SDCMD8, argument, resp);
+	hcs_val = (err == 1) ?
+	    MMC_OCR_REG_HOST_CAPACITY_SUPPORT_SECTOR :
+	    MMC_OCR_REG_HOST_CAPACITY_SUPPORT_BYTE;
+
+	argument = 0x0000 << 16;
+	err = mmc_send_cmd(MMC_CMD55, argument, resp);
+	if (err == 1) {
+		mmc_card_cur->card_type = SD_CARD;
+		ocr_value |= hcs_val;
+		ret_cmd41 = MMC_ACMD41;
+	} else {
+		mmc_card_cur->card_type = MMC_CARD;
+		ocr_value |= MMC_OCR_REG_ACCESS_MODE_SECTOR;
+		ret_cmd41 = MMC_CMD1;
+		OMAP_HSMMC_CON &= ~OD;
+		OMAP_HSMMC_CON |= OPENDRAIN;
+	}
+
+	argument = ocr_value;
+	err = mmc_send_cmd(ret_cmd41, argument, resp);
+	if (err != 1)
+		return err;
+
+	ocr_recvd = ((mmc_resp_r3 *) resp)->ocr;
+
+	while (!(ocr_recvd & (0x1 << 31)) && (retry_cnt > 0)) {
+		retry_cnt--;
+		if (mmc_card_cur->card_type == SD_CARD) {
+			argument = 0x0000 << 16;
+			err = mmc_send_cmd(MMC_CMD55, argument, resp);
+		}
+
+		argument = ocr_value;
+		err = mmc_send_cmd(ret_cmd41, argument, resp);
+		if (err != 1)
+			return err;
+		ocr_recvd = ((mmc_resp_r3 *) resp)->ocr;
+	}
+
+	if (!(ocr_recvd & (0x1 << 31)))
+		return 0;
+
+	if (mmc_card_cur->card_type == MMC_CARD) {
+		if ((ocr_recvd & MMC_OCR_REG_ACCESS_MODE_MASK) ==
+		    MMC_OCR_REG_ACCESS_MODE_SECTOR) {
+			mmc_card_cur->mode = SECTOR_MODE;
+		} else {
+			mmc_card_cur->mode = BYTE_MODE;
+		}
+
+		ocr_recvd &= ~MMC_OCR_REG_ACCESS_MODE_MASK;
+	} else {
+		if ((ocr_recvd & MMC_OCR_REG_HOST_CAPACITY_SUPPORT_MASK)
+		    == MMC_OCR_REG_HOST_CAPACITY_SUPPORT_SECTOR) {
+			mmc_card_cur->mode = SECTOR_MODE;
+		} else {
+			mmc_card_cur->mode = BYTE_MODE;
+		}
+		ocr_recvd &= ~MMC_OCR_REG_HOST_CAPACITY_SUPPORT_MASK;
+	}
+
+	ocr_recvd &= ~(0x1 << 31);
+	if (!(ocr_recvd & ocr_value))
+		return 0;
+
+	err = mmc_send_cmd(MMC_CMD2, argument, resp);
+	if (err != 1)
+		return err;
+
+	if (mmc_card_cur->card_type == MMC_CARD) {
+		argument = mmc_card_cur->RCA << 16;
+		err = mmc_send_cmd(MMC_CMD3, argument, resp);
+		if (err != 1)
+			return err;
+	} else {
+		argument = 0x00000000;
+		err = mmc_send_cmd(MMC_SDCMD3, argument, resp);
+		if (err != 1)
+			return err;
+
+		mmc_card_cur->RCA = ((mmc_resp_r6 *) resp)->newpublishedrca;
+	}
+
+	OMAP_HSMMC_CON &= ~OD;
+	OMAP_HSMMC_CON |= NOOPENDRAIN;
+	return 1;
+}
+
+unsigned char mmc_read_cardsize(mmc_card_data *mmc_dev_data,
+				mmc_csd_reg_t *cur_csd)
+{
+	mmc_extended_csd_reg_t ext_csd;
+	unsigned int size, count, blk_len, blk_no, card_size, argument;
+	unsigned char err;
+	unsigned int resp[4];
+
+	if (mmc_dev_data->mode == SECTOR_MODE) {
+		if (mmc_dev_data->card_type == SD_CARD) {
+			card_size =
+			    (((mmc_sd2_csd_reg_t *) cur_csd)->
+			     c_size_lsb & MMC_SD2_CSD_C_SIZE_LSB_MASK) |
+			    ((((mmc_sd2_csd_reg_t *) cur_csd)->
+			      c_size_msb & MMC_SD2_CSD_C_SIZE_MSB_MASK)
+			     << MMC_SD2_CSD_C_SIZE_MSB_OFFSET);
+			mmc_dev_data->size = card_size * 1024;
+			if (mmc_dev_data->size == 0)
+				return 0;
+		} else {
+			argument = 0x00000000;
+			err = mmc_send_cmd(MMC_CMD8, argument, resp);
+			if (err != 1)
+				return err;
+			err = mmc_read_data((unsigned int *) &ext_csd);
+			if (err != 1)
+				return err;
+			mmc_dev_data->size = ext_csd.sectorcount;
+
+			if (mmc_dev_data->size == 0)
+				mmc_dev_data->size = 8388608;
+		}
+	} else {
+		if (cur_csd->c_size_mult >= 8)
+			return 0;
+
+		if (cur_csd->read_bl_len >= 12)
+			return 0;
+
+		/* Compute size */
+		count = 1 << (cur_csd->c_size_mult + 2);
+		card_size = (cur_csd->c_size_lsb & MMC_CSD_C_SIZE_LSB_MASK) |
+		    ((cur_csd->c_size_msb & MMC_CSD_C_SIZE_MSB_MASK)
+		     << MMC_CSD_C_SIZE_MSB_OFFSET);
+		blk_no = (card_size + 1) * count;
+		blk_len = 1 << cur_csd->read_bl_len;
+		size = blk_no * blk_len;
+		mmc_dev_data->size = size / MMCSD_SECTOR_SIZE;
+		if (mmc_dev_data->size == 0)
+			return 0;
+	}
+	return 1;
+}
+
+unsigned char omap_mmc_read_sect(unsigned int start_sec, unsigned int num_bytes,
+				 mmc_card_data *mmc_c,
+				 unsigned long *output_buf)
+{
+	unsigned char err;
+	unsigned int argument;
+	unsigned int resp[4];
+	unsigned int num_sec_val =
+	    (num_bytes + (MMCSD_SECTOR_SIZE - 1)) / MMCSD_SECTOR_SIZE;
+	unsigned int sec_inc_val;
+
+	if (num_sec_val == 0)
+		return 1;
+
+	if (mmc_c->mode == SECTOR_MODE) {
+		argument = start_sec;
+		sec_inc_val = 1;
+	} else {
+		argument = start_sec * MMCSD_SECTOR_SIZE;
+		sec_inc_val = MMCSD_SECTOR_SIZE;
+	}
+
+	while (num_sec_val) {
+		err = mmc_send_cmd(MMC_CMD17, argument, resp);
+		if (err != 1)
+			return err;
+
+		err = mmc_read_data((unsigned int *) output_buf);
+		if (err != 1)
+			return err;
+
+		output_buf += (MMCSD_SECTOR_SIZE / 4);
+		argument += sec_inc_val;
+		num_sec_val--;
+	}
+	return 1;
+}
+
+unsigned char configure_mmc(mmc_card_data *mmc_card_cur)
+{
+	unsigned char ret_val;
+	unsigned int argument;
+	unsigned int resp[4];
+	unsigned int trans_clk, trans_fact, trans_unit, retries = 2;
+	mmc_csd_reg_t Card_CSD;
+	unsigned char trans_speed;
+
+	ret_val = mmc_init_setup();
+
+	if (ret_val != 1)
+		return ret_val;
+
+	do {
+		ret_val = mmc_detect_card(mmc_card_cur);
+		retries--;
+	} while ((retries > 0) && (ret_val != 1));
+
+	argument = mmc_card_cur->RCA << 16;
+	ret_val = mmc_send_cmd(MMC_CMD9, argument, resp);
+	if (ret_val != 1)
+		return ret_val;
+
+	((unsigned int *) &Card_CSD)[3] = resp[3];
+	((unsigned int *) &Card_CSD)[2] = resp[2];
+	((unsigned int *) &Card_CSD)[1] = resp[1];
+	((unsigned int *) &Card_CSD)[0] = resp[0];
+
+	if (mmc_card_cur->card_type == MMC_CARD)
+		mmc_card_cur->version = Card_CSD.spec_vers;
+
+	trans_speed = Card_CSD.tran_speed;
+
+	ret_val = mmc_send_cmd(MMC_CMD4, MMC_DSR_DEFAULT << 16, resp);
+	if (ret_val != 1)
+		return ret_val;
+
+	trans_unit = trans_speed & MMC_CSD_TRAN_SPEED_UNIT_MASK;
+	trans_fact = trans_speed & MMC_CSD_TRAN_SPEED_FACTOR_MASK;
+
+	if (trans_unit > MMC_CSD_TRAN_SPEED_UNIT_100MHZ)
+		return 0;
+
+	if ((trans_fact < MMC_CSD_TRAN_SPEED_FACTOR_1_0) ||
+	    (trans_fact > MMC_CSD_TRAN_SPEED_FACTOR_8_0))
+		return 0;
+
+	trans_unit >>= 0;
+	trans_fact >>= 3;
+
+	trans_clk = mmc_transspeed_val[trans_fact - 1][trans_unit] * 2;
+	ret_val = mmc_clock_config(CLK_MISC, trans_clk);
+
+	if (ret_val != 1)
+		return ret_val;
+
+	argument = mmc_card_cur->RCA << 16;
+	ret_val = mmc_send_cmd(MMC_CMD7_SELECT, argument, resp);
+	if (ret_val != 1)
+		return ret_val;
+
+	/* Configure the block length to 512 bytes */
+	argument = MMCSD_SECTOR_SIZE;
+	ret_val = mmc_send_cmd(MMC_CMD16, argument, resp);
+	if (ret_val != 1)
+		return ret_val;
+
+	/* get the card size in sectors */
+	ret_val = mmc_read_cardsize(mmc_card_cur, &Card_CSD);
+	if (ret_val != 1)
+		return ret_val;
+
+	return 1;
+}
+unsigned long mmc_bread(int dev_num, unsigned long blknr, lbaint_t blkcnt,
+			void *dst)
+{
+	omap_mmc_read_sect(blknr, (blkcnt * MMCSD_SECTOR_SIZE), &cur_card_data,
+			   (unsigned long *) dst);
+	return 1;
+}
+
+int mmc_init(int verbose)
+{
+	configure_mmc(&cur_card_data);
+
+	mmc_blk_dev.if_type = IF_TYPE_MMC;
+	mmc_blk_dev.part_type = PART_TYPE_DOS;
+	mmc_blk_dev.dev = 0;
+	mmc_blk_dev.lun = 0;
+	mmc_blk_dev.type = 0;
+
+	/* FIXME fill in the correct size (is set to 32MByte) */
+	mmc_blk_dev.blksz = MMCSD_SECTOR_SIZE;
+	mmc_blk_dev.lba = 0x10000;
+	mmc_blk_dev.removable = 0;
+	mmc_blk_dev.block_read = mmc_bread;
+
+	fat_register_device(&mmc_blk_dev, 1);
+	return 0;
+}
+
+int mmc_read(ulong src, uchar *dst, int size)
+{
+	return 0;
+}
+
+int mmc_write(uchar *src, ulong dst, int size)
+{
+	return 0;
+}
+
+int mmc2info(ulong addr)
+{
+	return 0;
+}
diff --git a/cpu/omap3/start.S b/cpu/omap3/start.S
new file mode 100644
index 0000000..98706ad
--- /dev/null
+++ b/cpu/omap3/start.S
@@ -0,0 +1,517 @@
+/*
+ *  armboot - Startup Code for OMAP3530/ARM Cortex CPU-core
+ *
+ *  Copyright (c) 2004	Texas Instruments <r-woodruff2@ti.com>
+ *
+ *  Copyright (c) 2001	Marius Grger <mag@sysgo.de>
+ *  Copyright (c) 2002	Alex Zpke <azu@sysgo.de>
+ *  Copyright (c) 2002	Gary Jennejohn <gj@denx.de>
+ *  Copyright (c) 2003	Richard Woodruff <r-woodruff2@ti.com>
+ *  Copyright (c) 2003	Kshitij <kshitij@ti.com>
+ *  Copyright (c) 2006-2008 Syed Mohammed Khasim <x0khasim@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+.globl _start
+_start: b	reset
+	ldr	pc, _undefined_instruction
+	ldr	pc, _software_interrupt
+	ldr	pc, _prefetch_abort
+	ldr	pc, _data_abort
+	ldr	pc, _not_used
+	ldr	pc, _irq
+	ldr	pc, _fiq
+
+_undefined_instruction: .word undefined_instruction
+_software_interrupt:	.word software_interrupt
+_prefetch_abort:	.word prefetch_abort
+_data_abort:		.word data_abort
+_not_used:		.word not_used
+_irq:			.word irq
+_fiq:			.word fiq
+_pad:			.word 0x12345678 /* now 16*4=64 */
+.global _end_vect
+_end_vect:
+
+	.balignl 16,0xdeadbeef
+/*************************************************************************
+ *
+ * Startup Code (reset vector)
+ *
+ * do important init only if we don't start from memory!
+ * setup Memory and board specific bits prior to relocation.
+ * relocate armboot to ram
+ * setup stack
+ *
+ *************************************************************************/
+
+_TEXT_BASE:
+	.word	TEXT_BASE
+
+.globl _armboot_start
+_armboot_start:
+	.word _start
+
+/*
+ * These are defined in the board-specific linker script.
+ */
+.globl _bss_start
+_bss_start:
+	.word __bss_start
+
+.globl _bss_end
+_bss_end:
+	.word _end
+
+#ifdef CONFIG_USE_IRQ
+/* IRQ stack memory (calculated at run-time) */
+.globl IRQ_STACK_START
+IRQ_STACK_START:
+	.word	0x0badc0de
+
+/* IRQ stack memory (calculated at run-time) */
+.globl FIQ_STACK_START
+FIQ_STACK_START:
+	.word 0x0badc0de
+#endif
+
+/*
+ * the actual reset code
+ */
+
+reset:
+	/*
+	 * set the cpu to SVC32 mode
+	 */
+	mrs	r0,cpsr
+	bic	r0,r0,#0x1f
+	orr	r0,r0,#0xd3
+	msr	cpsr,r0
+
+#if (CONFIG_OMAP34XX)
+       /* Copy vectors to mask ROM indirect addr */
+	adr	r0, _start		@ r0 <- current position of code
+        add     r0, r0, #4		@ skip reset vector
+	mov	r2, #64			@ r2 <- size to copy
+	add	r2, r0, r2		@ r2 <- source end address
+	mov	r1, #SRAM_OFFSET0	@ build vect addr
+	mov	r3, #SRAM_OFFSET1
+	add	r1, r1, r3
+	mov	r3, #SRAM_OFFSET2
+	add	r1, r1, r3
+next:
+	ldmia	r0!, {r3-r10}		@ copy from source address [r0]
+	stmia	r1!, {r3-r10}		@ copy to   target address [r1]
+	cmp	r0, r2			@ until source end address [r2]
+	bne	next			@ loop until equal */
+#if !defined(CFG_NAND_BOOT) && !defined(CFG_ONENAND_BOOT)
+	/* No need to copy/exec the clock code - DPLL adjust already done
+	 * in NAND/oneNAND Boot.
+	 */
+	bl	cpy_clk_code		@ put dpll adjust code behind vectors
+#endif /* NAND Boot */
+#endif
+	/* the mask ROM code should have PLL and others stable */
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+	bl  cpu_init_crit
+#endif
+
+#ifndef CONFIG_SKIP_RELOCATE_UBOOT
+relocate:				@ relocate U-Boot to RAM
+	adr	r0, _start		@ r0 <- current position of code
+	ldr	r1, _TEXT_BASE		@ test if we run from flash or RAM
+	cmp	r0, r1			@ don't reloc during debug
+	beq	stack_setup
+
+	ldr	r2, _armboot_start
+	ldr	r3, _bss_start
+	sub	r2, r3, r2		@ r2 <- size of armboot
+	add	r2, r0, r2		@ r2 <- source end address
+
+copy_loop:                              @ copy 32 bytes at a time
+	ldmia	r0!, {r3-r10}		@ copy from source address [r0]
+	stmia	r1!, {r3-r10}		@ copy to   target address [r1]
+	cmp	r0, r2			@ until source end addreee [r2]
+	ble	copy_loop
+#endif	/* CONFIG_SKIP_RELOCATE_UBOOT */
+
+	/* Set up the stack */
+stack_setup:
+	ldr	r0, _TEXT_BASE		@ upper 128 KiB: relocated uboot
+	sub	r0, r0, #CFG_MALLOC_LEN @ malloc area
+	sub	r0, r0, #CFG_GBL_DATA_SIZE @ bdinfo
+#ifdef CONFIG_USE_IRQ
+	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
+#endif
+	sub	sp, r0, #12		@ leave 3 words for abort-stack
+	and	sp, sp, #~7		@ 8 byte alinged for (ldr/str)d
+
+	/* Clear BSS (if any).  Is below tx (watch load addr - need space)  */
+clear_bss:
+	ldr	r0, _bss_start		@ find start of bss segment
+	ldr	r1, _bss_end		@ stop here
+	mov 	r2, #0x00000000		@ clear value
+clbss_l:
+	str	r2, [r0]		@ clear BSS location
+	cmp	r0, r1			@ are we at the end yet
+	add	r0, r0, #4		@ increment clear index pointer
+	bne	clbss_l                 @ keep clearing till at end
+
+	ldr	pc, _start_armboot	@ jump to C code
+
+_start_armboot: .word start_armboot
+
+
+/*************************************************************************
+ *
+ * CPU_init_critical registers
+ *
+ * setup important registers
+ * setup memory timing
+ *
+ *************************************************************************/
+cpu_init_crit:
+	/*
+	 * Invalidate L1 I/D
+	 */
+        mov	r0, #0			@ set up for MCR
+        mcr	p15, 0, r0, c8, c7, 0	@ invalidate TLBs
+        mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
+
+	/*
+	 * disable MMU stuff and caches
+	 */
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #0x00002000	@ clear bits 13 (--V-)
+	bic	r0, r0, #0x00000007	@ clear bits 2:0 (-CAM)
+	orr	r0, r0, #0x00000002	@ set bit 1 (--A-) Align
+	orr	r0, r0, #0x00000800	@ set bit 12 (Z---) BTB
+	mcr	p15, 0, r0, c1, c0, 0
+
+	/*
+	 * Jump to board specific initialization...
+	 * The Mask ROM will have already initialized
+	 * basic memory.  Go here to bump up clock rate and handle
+	 * wake up conditions.
+	 */
+	mov	ip, lr			@ persevere link reg across call
+	bl	lowlevel_init		@ go setup pll,mux,memory
+	mov	lr, ip			@ restore link
+	mov	pc, lr			@ back to my caller
+/*
+ *************************************************************************
+ *
+ * Interrupt handling
+ *
+ *************************************************************************
+ */
+@
+@ IRQ stack frame.
+@
+#define S_FRAME_SIZE	72
+
+#define S_OLD_R0	68
+#define S_PSR		64
+#define S_PC		60
+#define S_LR		56
+#define S_SP		52
+
+#define S_IP		48
+#define S_FP		44
+#define S_R10		40
+#define S_R9		36
+#define S_R8		32
+#define S_R7		28
+#define S_R6		24
+#define S_R5		20
+#define S_R4		16
+#define S_R3		12
+#define S_R2		8
+#define S_R1		4
+#define S_R0		0
+
+#define MODE_SVC 0x13
+#define I_BIT	 0x80
+
+/*
+ * use bad_save_user_regs for abort/prefetch/undef/swi ...
+ * use irq_save_user_regs / irq_restore_user_regs for IRQ/FIQ handling
+ */
+
+	.macro	bad_save_user_regs
+	sub	sp, sp, #S_FRAME_SIZE		@ carve out a frame on current
+						@  user stack
+	stmia	sp, {r0 - r12}			@ Save user registers (now in
+						@ svc mode) r0-r12
+
+	ldr	r2, _armboot_start
+	sub	r2, r2, #(CFG_MALLOC_LEN)
+	sub	r2, r2, #(CFG_GBL_DATA_SIZE+8)	@ set base 2 words into abort
+						@ stack
+	ldmia	r2, {r2 - r3}			@ get values for "aborted" pc
+						@ and cpsr (into parm regs)
+	add	r0, sp, #S_FRAME_SIZE		@ grab pointer to old stack
+
+	add	r5, sp, #S_SP
+	mov	r1, lr
+	stmia	r5, {r0 - r3}			@ save sp_SVC, lr_SVC, pc, cpsr
+	mov	r0, sp				@ save current stack into r0
+						@ (param register)
+	.endm
+
+	.macro	irq_save_user_regs
+	sub	sp, sp, #S_FRAME_SIZE
+	stmia	sp, {r0 - r12}			@ Calling r0-r12
+	add	r8, sp, #S_PC			@ !! R8 NEEDS to be saved !!
+						@ a reserved stack spot would
+						@ be good.
+	stmdb	r8, {sp, lr}^			@ Calling SP, LR
+	str	lr, [r8, #0]			@ Save calling PC
+	mrs	r6, spsr
+	str	r6, [r8, #4]			@ Save CPSR
+	str	r0, [r8, #8]			@ Save OLD_R0
+	mov	r0, sp
+	.endm
+
+	.macro	irq_restore_user_regs
+	ldmia	sp, {r0 - lr}^			@ Calling r0 - lr
+	mov	r0, r0
+	ldr	lr, [sp, #S_PC]			@ Get PC
+	add	sp, sp, #S_FRAME_SIZE
+	subs	pc, lr, #4			@ return & move spsr_svc into
+						@ cpsr
+	.endm
+
+	.macro get_bad_stack
+	ldr	r13, _armboot_start		@ setup our mode stack (enter
+						@ in banked mode)
+	sub	r13, r13, #(CFG_MALLOC_LEN)	@ move past malloc pool
+	sub	r13, r13, #(CFG_GBL_DATA_SIZE+8) @ move to reserved a couple
+						@ spots for abort stack
+
+	str	lr, [r13]			@ save caller lr in position 0
+						@ of saved stack
+	mrs	lr, spsr			@ get the spsr
+	str	lr, [r13, #4]			@ save spsr in position 1 of
+						@ saved stack
+
+	mov	r13, #MODE_SVC			@ prepare SVC-Mode
+	@ msr	spsr_c, r13
+	msr	spsr, r13			@ switch modes, make sure
+						@ moves will execute
+	mov	lr, pc				@ capture return pc
+	movs	pc, lr				@ jump to next instruction &
+						@ switch modes.
+	.endm
+
+	.macro get_bad_stack_swi
+	sub	r13, r13, #4			@ space on current stack for
+						@ scratch reg.
+	str	r0, [r13]			@ save R0's value.
+	ldr	r0, _armboot_start		@ get data regions start
+	sub	r0, r0, #(CFG_MALLOC_LEN)	@ move past malloc pool
+	sub	r0, r0, #(CFG_GBL_DATA_SIZE+8)	@ move past gbl and a couple
+						@ spots for abort stack
+	str	lr, [r0]			@ save caller lr in position 0
+						@ of saved stack
+	mrs	r0, spsr			@ get the spsr
+	str	lr, [r0, #4]			@ save spsr in position 1 of
+						@ saved stack
+	ldr	r0, [r13]			@ restore r0
+	add	r13, r13, #4			@ pop stack entry
+	.endm
+
+	.macro get_irq_stack			@ setup IRQ stack
+	ldr	sp, IRQ_STACK_START
+	.endm
+
+	.macro get_fiq_stack			@ setup FIQ stack
+	ldr	sp, FIQ_STACK_START
+	.endm
+
+/*
+ * exception handlers
+ */
+	.align	5
+undefined_instruction:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_undefined_instruction
+
+	.align	5
+software_interrupt:
+	get_bad_stack_swi
+	bad_save_user_regs
+	bl	do_software_interrupt
+
+	.align	5
+prefetch_abort:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_prefetch_abort
+
+	.align	5
+data_abort:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_data_abort
+
+	.align	5
+not_used:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_not_used
+
+#ifdef CONFIG_USE_IRQ
+
+	.align	5
+irq:
+	get_irq_stack
+	irq_save_user_regs
+	bl	do_irq
+	irq_restore_user_regs
+
+	.align	5
+fiq:
+	get_fiq_stack
+	/* someone ought to write a more effiction fiq_save_user_regs */
+	irq_save_user_regs
+	bl	do_fiq
+	irq_restore_user_regs
+
+#else
+
+	.align	5
+irq:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_irq
+
+	.align	5
+fiq:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_fiq
+
+#endif
+	.align 5
+.global arm_cache_flush
+arm_cache_flush:
+	mcr	p15, 0, r1, c7, c5, 0		@ invalidate I cache
+	mov	pc, lr				@ back to caller
+
+/*
+ *	v7_flush_dcache_all()
+ *
+ *	Flush the whole D-cache.
+ *
+ *	Corrupted registers: r0-r5, r7, r9-r11
+ *
+ *	- mm	- mm_struct describing address space
+ */
+	.align 5
+.global v7_flush_dcache_all
+v7_flush_dcache_all:
+	stmfd	r13!, {r0-r5, r7, r9-r12,r14}
+
+	mov	r7, r0				@ take a backup of device type
+	cmp	r0, #0x3			@ check if the device type is
+						@ GP
+	moveq r12, #0x1				@ set up to invalide L2
+smi: 	.word 0x01600070			@ Call SMI monitor (smieq)
+	cmp	r7, #0x3			@ compare again in case its
+						@ lost
+	beq	finished_inval			@ if GP device, inval done
+						@ above
+
+	mrc	p15, 1, r0, c0, c0, 1		@ read clidr
+	ands	r3, r0, #0x7000000		@ extract loc from clidr
+	mov	r3, r3, lsr #23			@ left align loc bit field
+	beq	finished_inval			@ if loc is 0, then no need to
+						@ clean
+	mov	r10, #0				@ start clean at cache level 0
+inval_loop1:
+	add	r2, r10, r10, lsr #1		@ work out 3x current cache
+						@ level
+	mov	r1, r0, lsr r2			@ extract cache type bits from
+						@ clidr
+	and	r1, r1, #7			@ mask of the bits for current
+						@ cache only
+	cmp	r1, #2				@ see what cache we have at
+						@ this level
+	blt	skip_inval			@ skip if no cache, or just
+						@ i-cache
+	mcr	p15, 2, r10, c0, c0, 0		@ select current cache level
+						@ in cssr
+	isb					@ isb to sych the new
+						@ cssr&csidr
+	mrc	p15, 1, r1, c0, c0, 0		@ read the new csidr
+	and	r2, r1, #7			@ extract the length of the
+						@ cache lines
+	add	r2, r2, #4			@ add 4 (line length offset)
+	ldr	r4, =0x3ff
+	ands	r4, r4, r1, lsr #3		@ find maximum number on the
+						@ way size
+	clz	r5, r4				@ find bit position of way
+						@ size increment
+	ldr	r7, =0x7fff
+	ands	r7, r7, r1, lsr #13		@ extract max number of the
+						@ index size
+inval_loop2:
+	mov	r9, r4				@ create working copy of max
+						@ way size
+inval_loop3:
+	orr	r11, r10, r9, lsl r5		@ factor way and cache number
+						@ into r11
+	orr	r11, r11, r7, lsl r2		@ factor index number into r11
+	mcr	p15, 0, r11, c7, c6, 2		@ invalidate by set/way
+	subs	r9, r9, #1			@ decrement the way
+	bge	inval_loop3
+	subs	r7, r7, #1			@ decrement the index
+	bge	inval_loop2
+skip_inval:
+	add	r10, r10, #2			@ increment cache number
+	cmp	r3, r10
+	bgt	inval_loop1
+finished_inval:
+	mov	r10, #0				@ swith back to cache level 0
+	mcr	p15, 2, r10, c0, c0, 0		@ select current cache level
+						@ in cssr
+	isb
+
+	ldmfd	r13!, {r0-r5, r7, r9-r12,pc}
+
+
+	.align	5
+.global reset_cpu
+reset_cpu:
+	ldr	r1, rstctl			@ get addr for global reset
+						@ reg
+	mov	r3, #0x2			@ full reset pll + mpu
+	str	r3, [r1]			@ force reset
+	mov	r0, r0
+_loop_forever:
+	b	_loop_forever
+rstctl:
+	.word	PRM_RSTCTRL
+
diff --git a/drivers/i2c/omap24xx_i2c.c b/drivers/i2c/omap24xx_i2c.c
index 7dab786..7782e9d 100644
--- a/drivers/i2c/omap24xx_i2c.c
+++ b/drivers/i2c/omap24xx_i2c.c
@@ -22,11 +22,13 @@
 
 #include <common.h>
 
-#ifdef CONFIG_DRIVER_OMAP24XX_I2C
+#if defined(CONFIG_DRIVER_OMAP24XX_I2C) || defined(CONFIG_DRIVER_OMAP34XX_I2C)
 
 #include <asm/arch/i2c.h>
 #include <asm/io.h>
 
+#define inb(a) __raw_readb(a)
+#define outb(a,v) __raw_writeb(a,v)
 #define inw(a) __raw_readw(a)
 #define outw(a,v) __raw_writew(a,v)
 
@@ -114,7 +116,11 @@ static int i2c_read_byte (u8 devaddr, u8 regoffset, u8 * value)
 
 		status = wait_for_pin ();
 		if (status & I2C_STAT_RRDY) {
-			*value = inw (I2C_DATA);
+#if defined(CONFIG_OMAP243X) || defined(CONFIG_OMAP34XX)
+                        *value = inb(I2C_DATA);
+#else
+                        *value = inw(I2C_DATA);
+#endif
 			udelay (20000);
 		} else {
 			i2c_error = 1;
@@ -155,8 +161,23 @@ static int i2c_write_byte (u8 devaddr, u8 regoffset, u8 value)
 	status = wait_for_pin ();
 
 	if (status & I2C_STAT_XRDY) {
-		/* send out two bytes */
-		outw ((value << 8) + regoffset, I2C_DATA);
+#if defined(CONFIG_OMAP243X) || defined(CONFIG_OMAP34XX)
+                /* send out 1 byte */
+                outb(regoffset, I2C_DATA);
+                outw(I2C_STAT_XRDY, I2C_STAT);
+                status = wait_for_pin();
+                if ((status & I2C_STAT_XRDY)) {
+                        /* send out next 1 byte */
+                        outb(value, I2C_DATA);
+                        outw(I2C_STAT_XRDY, I2C_STAT);
+                } else {
+                        i2c_error = 1;
+                }
+#else
+                /* send out two bytes */
+                outw ((value << 8) + regoffset, I2C_DATA);
+#endif
+
 		/* must have enough delay to allow BB bit to go low */
 		udelay (50000);
 		if (inw (I2C_STAT) & I2C_STAT_NACK) {
@@ -193,7 +214,11 @@ static void flush_fifo(void)
 	while(1){
 		stat = inw(I2C_STAT);
 		if(stat == I2C_STAT_RRDY){
-			inw(I2C_DATA);
+#if defined(CONFIG_OMAP243X) || defined(CONFIG_OMAP34XX)
+                        inb(I2C_DATA);
+#else
+                        inw(I2C_DATA);
+#endif
 			outw(I2C_STAT_RRDY,I2C_STAT);
 			udelay(1000);
 		}else
diff --git a/fs/jffs2/jffs2_1pass.c b/fs/jffs2/jffs2_1pass.c
index d1423c1..a75c606 100644
--- a/fs/jffs2/jffs2_1pass.c
+++ b/fs/jffs2/jffs2_1pass.c
@@ -304,7 +304,9 @@ static inline void *get_node_mem_nor(u32 off)
  */
 static inline void *get_fl_mem(u32 off, u32 size, void *ext_buf)
 {
+#if (defined(CONFIG_JFFS2_NAND) && defined(CONFIG_CMD_NAND)) || defined(ONFIG_CMD_FLASH)
 	struct mtdids *id = current_part->dev->id;
+#endif
 
 #if defined(CONFIG_CMD_FLASH)
 	if (id->type == MTD_DEV_TYPE_NOR)
@@ -322,7 +324,9 @@ static inline void *get_fl_mem(u32 off, u32 size, void *ext_buf)
 
 static inline void *get_node_mem(u32 off)
 {
-	struct mtdids *id = current_part->dev->id;
+#if (defined(CONFIG_JFFS2_NAND) && defined(CONFIG_CMD_NAND)) || defined(ONFIG_CMD_FLASH)
+        struct mtdids *id = current_part->dev->id;
+#endif
 
 #if defined(CONFIG_CMD_FLASH)
 	if (id->type == MTD_DEV_TYPE_NOR)
diff --git a/include/asm-arm/arch-omap3/bits.h b/include/asm-arm/arch-omap3/bits.h
new file mode 100644
index 0000000..8522335
--- /dev/null
+++ b/include/asm-arm/arch-omap3/bits.h
@@ -0,0 +1,48 @@
+/* bits.h
+ * Copyright (c) 2004 Texas Instruments
+ *
+ * This package is free software;  you can redistribute it and/or
+ * modify it under the terms of the license found in the file
+ * named COPYING that should have accompanied this file.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+#ifndef __bits_h
+#define __bits_h 1
+
+#define BIT0  (1<<0)
+#define BIT1  (1<<1)
+#define BIT2  (1<<2)
+#define BIT3  (1<<3)
+#define BIT4  (1<<4)
+#define BIT5  (1<<5)
+#define BIT6  (1<<6)
+#define BIT7  (1<<7)
+#define BIT8  (1<<8)
+#define BIT9  (1<<9)
+#define BIT10 (1<<10)
+#define BIT11 (1<<11)
+#define BIT12 (1<<12)
+#define BIT13 (1<<13)
+#define BIT14 (1<<14)
+#define BIT15 (1<<15)
+#define BIT16 (1<<16)
+#define BIT17 (1<<17)
+#define BIT18 (1<<18)
+#define BIT19 (1<<19)
+#define BIT20 (1<<20)
+#define BIT21 (1<<21)
+#define BIT22 (1<<22)
+#define BIT23 (1<<23)
+#define BIT24 (1<<24)
+#define BIT25 (1<<25)
+#define BIT26 (1<<26)
+#define BIT27 (1<<27)
+#define BIT28 (1<<28)
+#define BIT29 (1<<29)
+#define BIT30 (1<<30)
+#define BIT31 (1<<31)
+
+#endif
diff --git a/include/asm-arm/arch-omap3/clocks.h b/include/asm-arm/arch-omap3/clocks.h
new file mode 100644
index 0000000..7cdd58c
--- /dev/null
+++ b/include/asm-arm/arch-omap3/clocks.h
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+  */
+#ifndef _CLOCKS_H_
+#define _CLOCKS_H_
+
+#define LDELAY          12000000
+
+#define S12M		12000000
+#define S13M		13000000
+#define S19_2M		19200000
+#define S24M		24000000
+#define S26M		26000000
+#define S38_4M		38400000
+
+#define FCK_IVA2_ON	0x00000001
+#define FCK_CORE1_ON	0x03fffe29
+#define ICK_CORE1_ON	0x3ffffffb
+#define ICK_CORE2_ON	0x0000001f
+#define	FCK_WKUP_ON	0x000000e9
+#define ICK_WKUP_ON	0x0000003f
+#define FCK_DSS_ON	0x00000005
+#define ICK_DSS_ON	0x00000001
+#define FCK_CAM_ON	0x00000001
+#define ICK_CAM_ON	0x00000001
+#define FCK_PER_ON	0x0003ffff
+#define ICK_PER_ON	0x0003ffff
+
+/* Used to index into DPLL parameter tables */
+typedef struct {
+	unsigned int m;
+	unsigned int n;
+	unsigned int fsel;
+	unsigned int m2;
+} dpll_param;
+
+/* Following functions are exported from lowlevel_init.S */
+extern dpll_param *get_mpu_dpll_param(void);
+extern dpll_param *get_iva_dpll_param(void);
+extern dpll_param *get_core_dpll_param(void);
+extern dpll_param *get_per_dpll_param(void);
+
+extern void *_end_vect, *_start;
+
+#endif
diff --git a/include/asm-arm/arch-omap3/clocks_omap3.h b/include/asm-arm/arch-omap3/clocks_omap3.h
new file mode 100644
index 0000000..fdb0c4c
--- /dev/null
+++ b/include/asm-arm/arch-omap3/clocks_omap3.h
@@ -0,0 +1,101 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+  */
+#ifndef _CLOCKS_OMAP3_H_
+#define _CLOCKS_OMAP3_H_
+
+#define PLL_STOP               1	/* PER & IVA */
+#define PLL_LOW_POWER_BYPASS   5	/* MPU, IVA & CORE */
+#define PLL_FAST_RELOCK_BYPASS 6	/* CORE */
+#define PLL_LOCK               7	/* MPU, IVA, CORE & PER */
+
+/* The following configurations are OPP and SysClk value independant
+ * and hence are defined here. All the other DPLL related values are
+ * tabulated in lowlevel_init.S.
+ */
+
+/* CORE DPLL */
+#  define CORE_M3X2      2	/* 332MHz : CM_CLKSEL1_EMU */
+#  define CORE_SSI_DIV   3	/* 221MHz : CM_CLKSEL_CORE */
+#  define CORE_FUSB_DIV  2	/* 41.5MHz: */
+#  define CORE_L4_DIV    2	/*  83MHz : L4 */
+#  define CORE_L3_DIV    2	/* 166MHz : L3 {DDR} */
+#  define GFX_DIV        2	/*  83MHz : CM_CLKSEL_GFX */
+#  define WKUP_RSM       2	/* 41.5MHz: CM_CLKSEL_WKUP */
+
+/* PER DPLL */
+# define PER_M6X2       3	/* 288MHz: CM_CLKSEL1_EMU */
+# define PER_M5X2       4	/* 216MHz: CM_CLKSEL_CAM */
+# define PER_M4X2       2	/* 432MHz : CM_CLKSEL_DSS-dss1 */
+# define PER_M3X2       16	/* 54MHz : CM_CLKSEL_DSS-tv */
+
+#  define CLSEL1_EMU_VAL ((CORE_M3X2 << 16) | (PER_M6X2 << 24) | (0x0a50))
+
+# define M_12		0xA6
+# define N_12		0x05
+# define FSEL_12	0x07
+# define M2_12		0x01	/* M3 of 2 */
+
+# define M_12_ES1	0x19F
+# define N_12_ES1	0x0E
+# define FSL_12_ES1     0x03
+# define M2_12_ES1      0x1	/* M3 of 2 */
+
+# define M_13           0x14C
+# define N_13           0x0C
+# define FSEL_13	0x03
+# define M2_13		0x01	/* M3 of 2 */
+
+# define M_13_ES1	0x1B2
+# define N_13_ES1	0x10
+# define FSL_13_ES1     0x03
+# define M2_13_ES1	0x01	/* M3 of 2 */
+
+# define M_19p2         0x19F
+# define N_19p2         0x17
+# define FSEL_19p2      0x03
+# define M2_19p2        0x01	/* M3 of 2 */
+
+# define M_19p2_ES1	0x19F
+# define N_19p2_ES1	0x17
+# define FSL_19p2_ES1   0x03
+# define M2_19p2_ES1    0x01	/* M3 of 2 */
+
+# define M_26           0xA6
+# define N_26           0x0C
+# define FSEL_26        0x07
+# define M2_26          0x01	/* M3 of 2 */
+
+# define M_26_ES1	0x1B2
+# define N_26_ES1	0x21
+# define FSL_26_ES1	0x03
+# define M2_26_ES1	0x01	/* M3 of 2 */
+
+# define M_38p4         0x19F
+# define N_38p4         0x2F
+# define FSEL_38p4      0x03
+# define M2_38p4        0x01	/* M3 of 2 */
+
+# define M_38p4_ES1	0x19F
+# define N_38p4_ES1	0x2F
+# define FSL_38p4_ES1   0x03
+# define M2_38p4_ES1    0x01	/* M3 of 2 */
+
+#endif	/* endif _CLOCKS_OMAP3_H_ */
diff --git a/include/asm-arm/arch-omap3/cpu.h b/include/asm-arm/arch-omap3/cpu.h
new file mode 100644
index 0000000..d47defb
--- /dev/null
+++ b/include/asm-arm/arch-omap3/cpu.h
@@ -0,0 +1,250 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef _CPU_H
+#define _CPU_H
+
+/* Register offsets of common modules */
+/* Control */
+#define CONTROL_STATUS			(OMAP34XX_CTRL_BASE + 0x2F0)
+#define OMAP34XX_MCR			(OMAP34XX_CTRL_BASE + 0x8C)
+#define CONTROL_SCALABLE_OMAP_STATUS	(OMAP34XX_CTRL_BASE + 0x44C)
+#define CONTROL_SCALABLE_OMAP_OCP	(OMAP34XX_CTRL_BASE + 0x534)
+
+/* Tap Information */
+#define TAP_IDCODE_REG		(OMAP34XX_TAP_BASE+0x204)
+#define PRODUCTION_ID		(OMAP34XX_TAP_BASE+0x208)
+
+/* device type */
+#define DEVICE_MASK		(BIT8|BIT9|BIT10)
+#define TST_DEVICE		0x0
+#define EMU_DEVICE		0x1
+#define HS_DEVICE		0x2
+#define GP_DEVICE		0x3
+
+/* GPMC CS3/cs4/cs6 not avaliable */
+#define GPMC_BASE		(OMAP34XX_GPMC_BASE)
+#define GPMC_SYSCONFIG		(OMAP34XX_GPMC_BASE+0x10)
+#define GPMC_IRQSTATUS		(OMAP34XX_GPMC_BASE+0x18)
+#define GPMC_IRQENABLE		(OMAP34XX_GPMC_BASE+0x1C)
+#define GPMC_TIMEOUT_CONTROL	(OMAP34XX_GPMC_BASE+0x40)
+#define GPMC_CONFIG		(OMAP34XX_GPMC_BASE+0x50)
+#define GPMC_STATUS		(OMAP34XX_GPMC_BASE+0x54)
+
+#define GPMC_CONFIG_CS0		(OMAP34XX_GPMC_BASE+0x60)
+#define GPMC_CONFIG_WIDTH	(0x30)
+
+#define GPMC_CONFIG1		(0x00)
+#define GPMC_CONFIG2		(0x04)
+#define GPMC_CONFIG3		(0x08)
+#define GPMC_CONFIG4		(0x0C)
+#define GPMC_CONFIG5		(0x10)
+#define GPMC_CONFIG6		(0x14)
+#define GPMC_CONFIG7		(0x18)
+#define GPMC_NAND_CMD		(0x1C)
+#define GPMC_NAND_ADR		(0x20)
+#define GPMC_NAND_DAT		(0x24)
+
+#define GPMC_ECC_CONFIG		(0x1F4)
+#define GPMC_ECC_CONTROL	(0x1F8)
+#define GPMC_ECC_SIZE_CONFIG	(0x1FC)
+#define GPMC_ECC1_RESULT	(0x200)
+#define GPMC_ECC2_RESULT	(0x204)
+#define GPMC_ECC3_RESULT	(0x208)
+#define GPMC_ECC4_RESULT	(0x20C)
+#define GPMC_ECC5_RESULT	(0x210)
+#define GPMC_ECC6_RESULT	(0x214)
+#define GPMC_ECC7_RESULT	(0x218)
+#define GPMC_ECC8_RESULT	(0x21C)
+#define GPMC_ECC9_RESULT	(0x220)
+
+/* GPMC Mapping */
+# define FLASH_BASE		0x10000000	/* NOR flash, */
+						/* aligned to 256 Meg */
+# define FLASH_BASE_SDPV1	0x04000000	/* NOR flash, */
+						/* aligned to 64 Meg */
+# define FLASH_BASE_SDPV2	0x10000000	/* NOR flash, */
+						/* aligned to 256 Meg */
+# define DEBUG_BASE		0x08000000	/* debug board */
+# define NAND_BASE		0x30000000	/* NAND addr */
+						/* (actual size small port) */
+# define PISMO2_BASE		0x18000000	/* PISMO2 CS1/2 */
+# define ONENAND_MAP		0x20000000	/* OneNand addr */
+						/* (actual size small port) */
+
+/* SMS */
+#define SMS_SYSCONFIG		(OMAP34XX_SMS_BASE+0x10)
+#define SMS_RG_ATT0		(OMAP34XX_SMS_BASE+0x48)
+#define SMS_CLASS_ARB0		(OMAP34XX_SMS_BASE+0xD0)
+#define BURSTCOMPLETE_GROUP7	BIT31
+
+/* SDRC */
+#define SDRC_SYSCONFIG		(OMAP34XX_SDRC_BASE+0x10)
+#define SDRC_STATUS		(OMAP34XX_SDRC_BASE+0x14)
+#define SDRC_CS_CFG		(OMAP34XX_SDRC_BASE+0x40)
+#define SDRC_SHARING		(OMAP34XX_SDRC_BASE+0x44)
+#define SDRC_DLLA_CTRL		(OMAP34XX_SDRC_BASE+0x60)
+#define SDRC_DLLA_STATUS	(OMAP34XX_SDRC_BASE+0x64)
+#define SDRC_DLLB_CTRL		(OMAP34XX_SDRC_BASE+0x68)
+#define SDRC_DLLB_STATUS	(OMAP34XX_SDRC_BASE+0x6C)
+#define DLLPHASE		BIT1
+#define LOADDLL			BIT2
+#define DLL_DELAY_MASK		0xFF00
+#define DLL_NO_FILTER_MASK	(BIT8|BIT9)
+
+#define SDRC_POWER		(OMAP34XX_SDRC_BASE+0x70)
+#define WAKEUPPROC		BIT26
+
+#define SDRC_MCFG_0		(OMAP34XX_SDRC_BASE+0x80)
+#define SDRC_MR_0		(OMAP34XX_SDRC_BASE+0x84)
+#define SDRC_ACTIM_CTRLA_0	(OMAP34XX_SDRC_BASE+0x9C)
+#define SDRC_ACTIM_CTRLB_0	(OMAP34XX_SDRC_BASE+0xA0)
+#define SDRC_ACTIM_CTRLA_1	(OMAP34XX_SDRC_BASE+0xC4)
+#define SDRC_ACTIM_CTRLB_1	(OMAP34XX_SDRC_BASE+0xC8)
+#define SDRC_RFR_CTRL		(OMAP34XX_SDRC_BASE+0xA4)
+#define SDRC_RFR_CTRL		(OMAP34XX_SDRC_BASE+0xA4)
+#define SDRC_MANUAL_0		(OMAP34XX_SDRC_BASE+0xA8)
+#define OMAP34XX_SDRC_CS0	0x80000000
+#define OMAP34XX_SDRC_CS1	0xA0000000
+#define CMD_NOP			0x0
+#define CMD_PRECHARGE		0x1
+#define CMD_AUTOREFRESH		0x2
+#define CMD_ENTR_PWRDOWN	0x3
+#define CMD_EXIT_PWRDOWN	0x4
+#define CMD_ENTR_SRFRSH		0x5
+#define CMD_CKE_HIGH		0x6
+#define CMD_CKE_LOW		0x7
+#define SOFTRESET		BIT1
+#define SMART_IDLE		(0x2 << 3)
+#define REF_ON_IDLE		(0x1 << 6)
+
+/* timer regs offsets (32 bit regs) */
+#define TIDR			0x0	/* r */
+#define TIOCP_CFG		0x10	/* rw */
+#define TISTAT			0x14	/* r */
+#define TISR			0x18	/* rw */
+#define TIER			0x1C	/* rw */
+#define TWER			0x20	/* rw */
+#define TCLR			0x24	/* rw */
+#define TCRR			0x28	/* rw */
+#define TLDR			0x2C	/* rw */
+#define TTGR			0x30	/* rw */
+#define TWPS			0x34	/* r */
+#define TMAR			0x38	/* rw */
+#define TCAR1			0x3c	/* r */
+#define TSICR			0x40	/* rw */
+#define TCAR2			0x44	/* r */
+ /* enable sys_clk NO-prescale /1 */
+#define GPT_EN			((0<<2)|BIT1|BIT0)
+
+/* Watchdog */
+#define WWPS			0x34	/* r */
+#define WSPR			0x48	/* rw */
+#define WD_UNLOCK1		0xAAAA
+#define WD_UNLOCK2		0x5555
+
+/* PRCM */
+#define CM_FCLKEN_IVA2      0x48004000
+#define CM_CLKEN_PLL_IVA2   0x48004004
+#define CM_IDLEST_PLL_IVA2  0x48004024
+#define CM_CLKSEL1_PLL_IVA2 0x48004040
+#define CM_CLKSEL2_PLL_IVA2 0x48004044
+#define CM_CLKEN_PLL_MPU    0x48004904
+#define CM_IDLEST_PLL_MPU   0x48004924
+#define CM_CLKSEL1_PLL_MPU  0x48004940
+#define CM_CLKSEL2_PLL_MPU  0x48004944
+#define CM_FCLKEN1_CORE     0x48004a00
+#define CM_ICLKEN1_CORE     0x48004a10
+#define CM_ICLKEN2_CORE     0x48004a14
+#define CM_CLKSEL_CORE      0x48004a40
+#define CM_FCLKEN_GFX       0x48004b00
+#define CM_ICLKEN_GFX       0x48004b10
+#define CM_CLKSEL_GFX       0x48004b40
+#define CM_FCLKEN_WKUP      0x48004c00
+#define CM_ICLKEN_WKUP      0x48004c10
+#define CM_CLKSEL_WKUP      0x48004c40
+#define CM_IDLEST_WKUP      0x48004c20
+#define CM_CLKEN_PLL        0x48004d00
+#define CM_IDLEST_CKGEN     0x48004d20
+#define CM_CLKSEL1_PLL      0x48004d40
+#define CM_CLKSEL2_PLL      0x48004d44
+#define CM_CLKSEL3_PLL      0x48004d48
+#define CM_FCLKEN_DSS       0x48004e00
+#define CM_ICLKEN_DSS       0x48004e10
+#define CM_CLKSEL_DSS       0x48004e40
+#define CM_FCLKEN_CAM       0x48004f00
+#define CM_ICLKEN_CAM       0x48004f10
+#define CM_CLKSEL_CAM       0x48004F40
+#define CM_FCLKEN_PER       0x48005000
+#define CM_ICLKEN_PER       0x48005010
+#define CM_CLKSEL_PER       0x48005040
+#define CM_CLKSEL1_EMU      0x48005140
+
+#define PRM_CLKSEL           0x48306d40
+#define PRM_RSTCTRL          0x48307250
+#define PRM_CLKSRC_CTRL      0x48307270
+
+/* SMX-APE */
+#define PM_RT_APE_BASE_ADDR_ARM		(SMX_APE_BASE + 0x10000)
+#define PM_GPMC_BASE_ADDR_ARM		(SMX_APE_BASE + 0x12400)
+#define PM_OCM_RAM_BASE_ADDR_ARM	(SMX_APE_BASE + 0x12800)
+#define PM_OCM_ROM_BASE_ADDR_ARM	(SMX_APE_BASE + 0x12C00)
+#define PM_IVA2_BASE_ADDR_ARM		(SMX_APE_BASE + 0x14000)
+
+#define RT_REQ_INFO_PERMISSION_1	(PM_RT_APE_BASE_ADDR_ARM + 0x68)
+#define RT_READ_PERMISSION_0		(PM_RT_APE_BASE_ADDR_ARM + 0x50)
+#define RT_WRITE_PERMISSION_0		(PM_RT_APE_BASE_ADDR_ARM + 0x58)
+#define RT_ADDR_MATCH_1			(PM_RT_APE_BASE_ADDR_ARM + 0x60)
+
+#define GPMC_REQ_INFO_PERMISSION_0	(PM_GPMC_BASE_ADDR_ARM + 0x48)
+#define GPMC_READ_PERMISSION_0		(PM_GPMC_BASE_ADDR_ARM + 0x50)
+#define GPMC_WRITE_PERMISSION_0		(PM_GPMC_BASE_ADDR_ARM + 0x58)
+
+#define OCM_REQ_INFO_PERMISSION_0	(PM_OCM_RAM_BASE_ADDR_ARM + 0x48)
+#define OCM_READ_PERMISSION_0		(PM_OCM_RAM_BASE_ADDR_ARM + 0x50)
+#define OCM_WRITE_PERMISSION_0		(PM_OCM_RAM_BASE_ADDR_ARM + 0x58)
+#define OCM_ADDR_MATCH_2		(PM_OCM_RAM_BASE_ADDR_ARM + 0x80)
+
+#define IVA2_REQ_INFO_PERMISSION_0	(PM_IVA2_BASE_ADDR_ARM + 0x48)
+#define IVA2_READ_PERMISSION_0		(PM_IVA2_BASE_ADDR_ARM + 0x50)
+#define IVA2_WRITE_PERMISSION_0		(PM_IVA2_BASE_ADDR_ARM + 0x58)
+
+#define IVA2_REQ_INFO_PERMISSION_1	(PM_IVA2_BASE_ADDR_ARM + 0x68)
+#define IVA2_READ_PERMISSION_1		(PM_IVA2_BASE_ADDR_ARM + 0x70)
+#define IVA2_WRITE_PERMISSION_1		(PM_IVA2_BASE_ADDR_ARM + 0x78)
+
+#define IVA2_REQ_INFO_PERMISSION_2	(PM_IVA2_BASE_ADDR_ARM + 0x88)
+#define IVA2_READ_PERMISSION_2		(PM_IVA2_BASE_ADDR_ARM + 0x90)
+#define IVA2_WRITE_PERMISSION_2		(PM_IVA2_BASE_ADDR_ARM + 0x98)
+
+#define IVA2_REQ_INFO_PERMISSION_3	(PM_IVA2_BASE_ADDR_ARM + 0xA8)
+#define IVA2_READ_PERMISSION_3		(PM_IVA2_BASE_ADDR_ARM + 0xB0)
+#define IVA2_WRITE_PERMISSION_3		(PM_IVA2_BASE_ADDR_ARM + 0xB8)
+
+/* I2C base */
+#define I2C_BASE1		(OMAP34XX_CORE_L4_IO_BASE + 0x70000)
+#define I2C_BASE2		(OMAP34XX_CORE_L4_IO_BASE + 0x72000)
+#define I2C_BASE3		(OMAP34XX_CORE_L4_IO_BASE + 0x60000)
+
+#endif /* _CPU_H */
diff --git a/include/asm-arm/arch-omap3/i2c.h b/include/asm-arm/arch-omap3/i2c.h
new file mode 100644
index 0000000..5fb0979
--- /dev/null
+++ b/include/asm-arm/arch-omap3/i2c.h
@@ -0,0 +1,128 @@
+/*
+ * (C) Copyright 2004-2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _I2C_H_
+#define _I2C_H_
+
+#define I2C_DEFAULT_BASE I2C_BASE1
+
+#define I2C_REV                 (I2C_DEFAULT_BASE + 0x00)
+#define I2C_IE                  (I2C_DEFAULT_BASE + 0x04)
+#define I2C_STAT                (I2C_DEFAULT_BASE + 0x08)
+#define I2C_IV                  (I2C_DEFAULT_BASE + 0x0c)
+#define I2C_BUF                 (I2C_DEFAULT_BASE + 0x14)
+#define I2C_CNT                 (I2C_DEFAULT_BASE + 0x18)
+#define I2C_DATA                (I2C_DEFAULT_BASE + 0x1c)
+#define I2C_SYSC                (I2C_DEFAULT_BASE + 0x20)
+#define I2C_CON                 (I2C_DEFAULT_BASE + 0x24)
+#define I2C_OA                  (I2C_DEFAULT_BASE + 0x28)
+#define I2C_SA                  (I2C_DEFAULT_BASE + 0x2c)
+#define I2C_PSC                 (I2C_DEFAULT_BASE + 0x30)
+#define I2C_SCLL                (I2C_DEFAULT_BASE + 0x34)
+#define I2C_SCLH                (I2C_DEFAULT_BASE + 0x38)
+#define I2C_SYSTEST             (I2C_DEFAULT_BASE + 0x3c)
+
+/* I2C masks */
+
+/* I2C Interrupt Enable Register (I2C_IE): */
+#define I2C_IE_GC_IE    (1 << 5)
+#define I2C_IE_XRDY_IE  (1 << 4) /* Transmit data ready interrupt enable */
+#define I2C_IE_RRDY_IE  (1 << 3) /* Receive data ready interrupt enable */
+#define I2C_IE_ARDY_IE  (1 << 2) /* Register access ready interrupt enable */
+#define I2C_IE_NACK_IE  (1 << 1) /* No acknowledgment interrupt enable */
+#define I2C_IE_AL_IE    (1 << 0) /* Arbitration lost interrupt enable */
+
+/* I2C Status Register (I2C_STAT): */
+
+#define I2C_STAT_SBD    (1 << 15) /* Single byte data */
+#define I2C_STAT_BB     (1 << 12) /* Bus busy */
+#define I2C_STAT_ROVR   (1 << 11) /* Receive overrun */
+#define I2C_STAT_XUDF   (1 << 10) /* Transmit underflow */
+#define I2C_STAT_AAS    (1 << 9)  /* Address as slave */
+#define I2C_STAT_GC     (1 << 5)
+#define I2C_STAT_XRDY   (1 << 4)  /* Transmit data ready */
+#define I2C_STAT_RRDY   (1 << 3)  /* Receive data ready */
+#define I2C_STAT_ARDY   (1 << 2)  /* Register access ready */
+#define I2C_STAT_NACK   (1 << 1)  /* No acknowledgment interrupt enable */
+#define I2C_STAT_AL     (1 << 0)  /* Arbitration lost interrupt enable */
+
+/* I2C Interrupt Code Register (I2C_INTCODE): */
+
+#define I2C_INTCODE_MASK        7
+#define I2C_INTCODE_NONE        0
+#define I2C_INTCODE_AL          1	/* Arbitration lost */
+#define I2C_INTCODE_NAK         2	/* No acknowledgement/general call */
+#define I2C_INTCODE_ARDY        3	/* Register access ready */
+#define I2C_INTCODE_RRDY        4	/* Rcv data ready */
+#define I2C_INTCODE_XRDY        5	/* Xmit data ready */
+
+/* I2C Buffer Configuration Register (I2C_BUF): */
+
+#define I2C_BUF_RDMA_EN         (1 << 15) /* Receive DMA channel enable */
+#define I2C_BUF_XDMA_EN         (1 << 7)  /* Transmit DMA channel enable */
+
+/* I2C Configuration Register (I2C_CON): */
+
+#define I2C_CON_EN      (1 << 15)  /* I2C module enable */
+#define I2C_CON_BE      (1 << 14)  /* Big endian mode */
+#define I2C_CON_STB     (1 << 11)  /* Start byte mode (master mode only) */
+#define I2C_CON_MST     (1 << 10)  /* Master/slave mode */
+#define I2C_CON_TRX     (1 << 9)   /* Transmitter/receiver mode /*
+				   /* (master mode only) */
+#define I2C_CON_XA      (1 << 8)   /* Expand address */
+#define I2C_CON_STP     (1 << 1)   /* Stop condition (master mode only) */
+#define I2C_CON_STT     (1 << 0)   /* Start condition (master mode only) */
+
+/* I2C System Test Register (I2C_SYSTEST): */
+
+#define I2C_SYSTEST_ST_EN       (1 << 15) /* System test enable */
+#define I2C_SYSTEST_FREE        (1 << 14) /* Free running mode, on brkpoint) */
+#define I2C_SYSTEST_TMODE_MASK  (3 << 12) /* Test mode select */
+#define I2C_SYSTEST_TMODE_SHIFT (12)	  /* Test mode select */
+#define I2C_SYSTEST_SCL_I       (1 << 3)  /* SCL line sense input value */
+#define I2C_SYSTEST_SCL_O       (1 << 2)  /* SCL line drive output value */
+#define I2C_SYSTEST_SDA_I       (1 << 1)  /* SDA line sense input value */
+#define I2C_SYSTEST_SDA_O       (1 << 0)  /* SDA line drive output value */
+
+#define I2C_SCLL_SCLL        (0)
+#define I2C_SCLL_SCLL_M      (0xFF)
+#define I2C_SCLL_HSSCLL      (8)
+#define I2C_SCLH_HSSCLL_M    (0xFF)
+#define I2C_SCLH_SCLH        (0)
+#define I2C_SCLH_SCLH_M      (0xFF)
+#define I2C_SCLH_HSSCLH      (8)
+#define I2C_SCLH_HSSCLH_M    (0xFF)
+
+#define OMAP_I2C_STANDARD    100
+#define OMAP_I2C_FAST_MODE   400
+#define OMAP_I2C_HIGH_SPEED  3400
+
+#define SYSTEM_CLOCK_12      12000
+#define SYSTEM_CLOCK_13      13000
+#define SYSTEM_CLOCK_192     19200
+#define SYSTEM_CLOCK_96      96000
+
+#define I2C_IP_CLK SYSTEM_CLOCK_96
+#define I2C_PSC_MAX          (0x0f)
+#define I2C_PSC_MIN          (0x00)
+
+#endif /* _I2C_H_ */
diff --git a/include/asm-arm/arch-omap3/mem.h b/include/asm-arm/arch-omap3/mem.h
new file mode 100644
index 0000000..2c5cc51
--- /dev/null
+++ b/include/asm-arm/arch-omap3/mem.h
@@ -0,0 +1,220 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _MEM_H_
+#define _MEM_H_
+
+#define SDRC_CS0_OSET    0x0
+#define SDRC_CS1_OSET    0x30 /* mirror CS1 regs appear offset 0x30 from CS0 */
+
+#ifndef __ASSEMBLY__
+
+typedef enum {
+	STACKED = 0,
+	IP_DDR = 1,
+	COMBO_DDR = 2,
+	IP_SDR = 3,
+} mem_t;
+
+#endif /* __ASSEMBLY__ */
+
+#define EARLY_INIT 1
+
+/* Slower full frequency range default timings for x32 operation*/
+#define SDP_SDRC_SHARING		0x00000100
+#define SDP_SDRC_MR_0_SDR		0x00000031
+
+/* optimized timings good for current shipping parts */
+#define SDP_3430_SDRC_RFR_CTRL_165MHz   0x0004e201  /* 7.8us/6ns - 50=0x4e2 */
+
+#define DLL_OFFSET              0
+#define DLL_WRITEDDRCLKX2DIS    1
+#define DLL_ENADLL              1
+#define DLL_LOCKDLL             0
+#define DLL_DLLPHASE_72         0
+#define DLL_DLLPHASE_90         1
+
+/* rkw - need to find of 90/72 degree recommendation for speed like before */
+#define SDP_SDRC_DLLAB_CTRL ((DLL_ENADLL << 3) | \
+    (DLL_LOCKDLL << 2) | (DLL_DLLPHASE_90 << 1))
+
+/* Infineon part of 3430SDP (165MHz optimized) 6.06ns
+ *   ACTIMA
+ *	TDAL = Twr/Tck + Trp/tck = 15/6 + 18/6 = 2.5 + 3 = 5.5 -> 6
+ *	TDPL (Twr) = 15/6	= 2.5 -> 3
+ *	TRRD = 12/6	= 2
+ *	TRCD = 18/6	= 3
+ *	TRP = 18/6	= 3
+ *	TRAS = 42/6	= 7
+ *	TRC = 60/6	= 10
+ *	TRFC = 72/6	= 12
+ *   ACTIMB
+ *	TCKE = 2
+ *	XSR = 120/6 = 20
+ */
+#define TDAL_165   6
+#define TDPL_165   3
+#define TRRD_165   2
+#define TRCD_165   3
+#define TRP_165    3
+#define TRAS_165   7
+#define TRC_165   10
+#define TRFC_165  12
+#define V_ACTIMA_165 ((TRFC_165 << 27) | (TRC_165 << 22) | (TRAS_165 << 18) \
+		| (TRP_165 << 15) | (TRCD_165 << 12) | (TRRD_165 << 9) | \
+		(TDPL_165 << 6) | (TDAL_165))
+
+#define TWTR_165   1
+#define TCKE_165   2
+#define TXP_165    2
+#define XSR_165    20
+#define V_ACTIMB_165 (((TCKE_165 << 12) | (XSR_165 << 0)) |	\
+			(TXP_165 << 8) | (TWTR_165 << 16))
+
+# define SDP_SDRC_ACTIM_CTRLA_0     V_ACTIMA_165
+# define SDP_SDRC_ACTIM_CTRLB_0     V_ACTIMB_165
+# define SDP_SDRC_RFR_CTRL          SDP_3430_SDRC_RFR_CTRL_165MHz
+
+/*
+ * GPMC settings -
+ * Definitions is as per the following format
+ * # define <PART>_GPMC_CONFIG<x> <value>
+ * Where:
+ * PART is the part name e.g. STNOR - Intel Strata Flash
+ * x is GPMC config registers from 1 to 6 (there will be 6 macros)
+ * Value is corresponding value
+ *
+ * For every valid PRCM configuration there should be only one definition of
+ * the same. if values are independent of the board, this definition will be
+ * present in this file if values are dependent on the board, then this should
+ * go into corresponding mem-boardName.h file
+ *
+ * Currently valid part Names are (PART):
+ * STNOR - Intel Strata Flash
+ * SMNAND - Samsung NAND
+ * MPDB - H4 MPDB board
+ * SBNOR - Sibley NOR
+ * MNAND - Micron Large page x16 NAND
+ * ONNAND - Samsung One NAND
+ *
+ * include/configs/file.h contains the defn - for all CS we are interested
+ * #define OMAP34XX_GPMC_CSx PART
+ * #define OMAP34XX_GPMC_CSx_SIZE Size
+ * #define OMAP34XX_GPMC_CSx_MAP Map
+ * Where:
+ * x - CS number
+ * PART - Part Name as defined above
+ * SIZE - how big is the mapping to be
+ *   GPMC_SIZE_128M - 0x8
+ *   GPMC_SIZE_64M  - 0xC
+ *   GPMC_SIZE_32M  - 0xE
+ *   GPMC_SIZE_16M  - 0xF
+ * MAP  - Map this CS to which address(GPMC address space)- Absolute address
+ *   >>24 before being used.
+ */
+#define GPMC_SIZE_128M  0x8
+#define GPMC_SIZE_64M   0xC
+#define GPMC_SIZE_32M   0xE
+#define GPMC_SIZE_16M   0xF
+
+# define SMNAND_GPMC_CONFIG1 0x00000800
+# define SMNAND_GPMC_CONFIG2 0x00141400
+# define SMNAND_GPMC_CONFIG3 0x00141400
+# define SMNAND_GPMC_CONFIG4 0x0F010F01
+# define SMNAND_GPMC_CONFIG5 0x010C1414
+# define SMNAND_GPMC_CONFIG6 0x1F0F0A80
+# define SMNAND_GPMC_CONFIG7 0x00000C44
+
+# define M_NAND_GPMC_CONFIG1 0x00001800
+# define M_NAND_GPMC_CONFIG2 0x00141400
+# define M_NAND_GPMC_CONFIG3 0x00141400
+# define M_NAND_GPMC_CONFIG4 0x0F010F01
+# define M_NAND_GPMC_CONFIG5 0x010C1414
+# define M_NAND_GPMC_CONFIG6 0x1f0f0A80
+# define M_NAND_GPMC_CONFIG7 0x00000C44
+
+# define STNOR_GPMC_CONFIG1  0x3
+# define STNOR_GPMC_CONFIG2  0x00151501
+# define STNOR_GPMC_CONFIG3  0x00060602
+# define STNOR_GPMC_CONFIG4  0x11091109
+# define STNOR_GPMC_CONFIG5  0x01141F1F
+# define STNOR_GPMC_CONFIG6  0x000004c4
+
+# define SIBNOR_GPMC_CONFIG1  0x1200
+# define SIBNOR_GPMC_CONFIG2  0x001f1f00
+# define SIBNOR_GPMC_CONFIG3  0x00080802
+# define SIBNOR_GPMC_CONFIG4  0x1C091C09
+# define SIBNOR_GPMC_CONFIG5  0x01131F1F
+# define SIBNOR_GPMC_CONFIG6  0x1F0F03C2
+
+# define SDPV2_MPDB_GPMC_CONFIG1  0x00611200
+# define SDPV2_MPDB_GPMC_CONFIG2  0x001F1F01
+# define SDPV2_MPDB_GPMC_CONFIG3  0x00080803
+# define SDPV2_MPDB_GPMC_CONFIG4  0x1D091D09
+# define SDPV2_MPDB_GPMC_CONFIG5  0x041D1F1F
+# define SDPV2_MPDB_GPMC_CONFIG6  0x1D0904C4
+
+# define MPDB_GPMC_CONFIG1  0x00011000
+# define MPDB_GPMC_CONFIG2  0x001f1f01
+# define MPDB_GPMC_CONFIG3  0x00080803
+# define MPDB_GPMC_CONFIG4  0x1c0b1c0a
+# define MPDB_GPMC_CONFIG5  0x041f1F1F
+# define MPDB_GPMC_CONFIG6  0x1F0F04C4
+
+# define P2_GPMC_CONFIG1  0x0
+# define P2_GPMC_CONFIG2  0x0
+# define P2_GPMC_CONFIG3  0x0
+# define P2_GPMC_CONFIG4  0x0
+# define P2_GPMC_CONFIG5  0x0
+# define P2_GPMC_CONFIG6  0x0
+
+# define ONENAND_GPMC_CONFIG1 0x00001200
+# define ONENAND_GPMC_CONFIG2 0x000F0F01
+# define ONENAND_GPMC_CONFIG3 0x00030301
+# define ONENAND_GPMC_CONFIG4 0x0F040F04
+# define ONENAND_GPMC_CONFIG5 0x010F1010
+# define ONENAND_GPMC_CONFIG6 0x1F060000
+
+/* max number of GPMC Chip Selects */
+#define GPMC_MAX_CS	8
+/* max number of GPMC regs */
+#define GPMC_MAX_REG	7
+
+#define PISMO1_NOR	1
+#define PISMO1_NAND	2
+#define PISMO2_CS0	3
+#define PISMO2_CS1	4
+#define PISMO1_ONENAND	5
+#define DBG_MPDB	6
+#define PISMO2_NAND_CS0 7
+#define PISMO2_NAND_CS1 8
+
+/* make it readable for the gpmc_init */
+#define PISMO1_NOR_BASE		FLASH_BASE
+#define PISMO1_NAND_BASE	NAND_BASE
+#define PISMO2_CS0_BASE		PISMO2_MAP1
+#define PISMO1_ONEN_BASE	ONENAND_MAP
+#define DBG_MPDB_BASE		DEBUG_BASE
+
+#endif /* endif _MEM_H_ */
diff --git a/include/asm-arm/arch-omap3/mmc.h b/include/asm-arm/arch-omap3/mmc.h
new file mode 100644
index 0000000..8631aae
--- /dev/null
+++ b/include/asm-arm/arch-omap3/mmc.h
@@ -0,0 +1,235 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ * Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation's version 2 of
+ * the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef MMC_H
+#define MMC_H
+
+#include "mmc_host_def.h"
+
+/* Responses */
+#define RSP_TYPE_NONE	  (RSP_TYPE_NORSP   | CCCE_NOCHECK | CICE_NOCHECK)
+#define RSP_TYPE_R1	  (RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
+#define RSP_TYPE_R1B	  (RSP_TYPE_LGHT48B | CCCE_CHECK   | CICE_CHECK)
+#define RSP_TYPE_R2	  (RSP_TYPE_LGHT136 | CCCE_CHECK   | CICE_NOCHECK)
+#define RSP_TYPE_R3	  (RSP_TYPE_LGHT48  | CCCE_NOCHECK | CICE_NOCHECK)
+#define RSP_TYPE_R4	  (RSP_TYPE_LGHT48  | CCCE_NOCHECK | CICE_NOCHECK)
+#define RSP_TYPE_R5	  (RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
+#define RSP_TYPE_R6	  (RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
+#define RSP_TYPE_R7	  (RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
+
+/* All supported commands */
+#define MMC_CMD0          (INDEX(0)  | RSP_TYPE_NONE | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD1          (INDEX(1)  | RSP_TYPE_R3   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD2          (INDEX(2)  | RSP_TYPE_R2   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD3          (INDEX(3)  | RSP_TYPE_R1   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_SDCMD3        (INDEX(3)  | RSP_TYPE_R6   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD4          (INDEX(4)  | RSP_TYPE_NONE | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD6          (INDEX(6)  | RSP_TYPE_R1B  | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD7_SELECT   (INDEX(7)  | RSP_TYPE_R1B  | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD7_DESELECT (INDEX(7)  | RSP_TYPE_NONE | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD8          (INDEX(8)  | RSP_TYPE_R1   | DP_DATA    | DDIR_READ)
+#define MMC_SDCMD8        (INDEX(8)  | RSP_TYPE_R7   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD9          (INDEX(9)  | RSP_TYPE_R2   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD12         (INDEX(12) | RSP_TYPE_R1B  | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD13         (INDEX(13) | RSP_TYPE_R1   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD15         (INDEX(15) | RSP_TYPE_NONE | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD16         (INDEX(16) | RSP_TYPE_R1   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD17         (INDEX(17) | RSP_TYPE_R1   | DP_DATA    | DDIR_READ)
+#define MMC_CMD24         (INDEX(24) | RSP_TYPE_R1   | DP_DATA    | DDIR_WRITE)
+#define MMC_ACMD6         (INDEX(6)  | RSP_TYPE_R1   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_ACMD41        (INDEX(41) | RSP_TYPE_R3   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_ACMD51        (INDEX(51) | RSP_TYPE_R1   | DP_DATA    | DDIR_READ)
+#define MMC_CMD55         (INDEX(55) | RSP_TYPE_R1   | DP_NO_DATA | DDIR_WRITE)
+
+#define MMC_AC_CMD_RCA_MASK     (unsigned int)(0xFFFF << 16)
+#define MMC_BC_CMD_DSR_MASK     (unsigned int)(0xFFFF << 16)
+#define MMC_DSR_DEFAULT         (0x0404)
+#define SD_CMD8_CHECK_PATTERN	(0xAA)
+#define SD_CMD8_2_7_3_6_V_RANGE	(0x01 << 8)
+
+/* Clock Configurations and Macros */
+
+#define MMC_CLOCK_REFERENCE		(96)
+#define MMC_RELATIVE_CARD_ADDRESS	(0x1234)
+#define MMC_INIT_SEQ_CLK		(MMC_CLOCK_REFERENCE * 1000 / 80)
+#define MMC_400kHz_CLK			(MMC_CLOCK_REFERENCE * 1000 / 400)
+#define CLKDR(r, f, u)			((((r)*100) / ((f)*(u))) + 1)
+#define CLKD(f, u)			(CLKDR(MMC_CLOCK_REFERENCE, f, u))
+
+#define MMC_OCR_REG_ACCESS_MODE_MASK			(0x3 << 29)
+#define MMC_OCR_REG_ACCESS_MODE_BYTE    		(0x0 << 29)
+#define MMC_OCR_REG_ACCESS_MODE_SECTOR  		(0x2 << 29)
+
+#define MMC_OCR_REG_HOST_CAPACITY_SUPPORT_MASK		(0x1 << 30)
+#define MMC_OCR_REG_HOST_CAPACITY_SUPPORT_BYTE		(0x0 << 30)
+#define MMC_OCR_REG_HOST_CAPACITY_SUPPORT_SECTOR	(0x1 << 30)
+
+#define MMC_SD2_CSD_C_SIZE_LSB_MASK         (0xFFFF)
+#define MMC_SD2_CSD_C_SIZE_MSB_MASK         (0x003F)
+#define MMC_SD2_CSD_C_SIZE_MSB_OFFSET       (16)
+#define MMC_CSD_C_SIZE_LSB_MASK             (0x0003)
+#define MMC_CSD_C_SIZE_MSB_MASK             (0x03FF)
+#define MMC_CSD_C_SIZE_MSB_OFFSET           (2)
+
+#define MMC_CSD_TRAN_SPEED_UNIT_MASK        (0x07 << 0)
+#define MMC_CSD_TRAN_SPEED_FACTOR_MASK      (0x0F << 3)
+#define MMC_CSD_TRAN_SPEED_UNIT_100MHZ      (0x3 << 0)
+#define MMC_CSD_TRAN_SPEED_FACTOR_1_0       (0x01 << 3)
+#define MMC_CSD_TRAN_SPEED_FACTOR_8_0       (0x0F << 3)
+
+typedef struct {
+	unsigned not_used:1;
+	unsigned crc:7;
+	unsigned ecc:2;
+	unsigned file_format:2;
+	unsigned tmp_write_protect:1;
+	unsigned perm_write_protect:1;
+	unsigned copy:1;
+	unsigned file_format_grp:1;
+	unsigned content_prot_app:1;
+	unsigned reserved_1:4;
+	unsigned write_bl_partial:1;
+	unsigned write_bl_len:4;
+	unsigned r2w_factor:3;
+	unsigned default_ecc:2;
+	unsigned wp_grp_enable:1;
+	unsigned wp_grp_size:5;
+	unsigned erase_grp_mult:5;
+	unsigned erase_grp_size:5;
+	unsigned c_size_mult:3;
+	unsigned vdd_w_curr_max:3;
+	unsigned vdd_w_curr_min:3;
+	unsigned vdd_r_curr_max:3;
+	unsigned vdd_r_curr_min:3;
+	unsigned c_size_lsb:2;
+	unsigned c_size_msb:10;
+	unsigned reserved_2:2;
+	unsigned dsr_imp:1;
+	unsigned read_blk_misalign:1;
+	unsigned write_blk_misalign:1;
+	unsigned read_bl_partial:1;
+	unsigned read_bl_len:4;
+	unsigned ccc:12;
+	unsigned tran_speed:8;
+	unsigned nsac:8;
+	unsigned taac:8;
+	unsigned reserved_3:2;
+	unsigned spec_vers:4;
+	unsigned csd_structure:2;
+} mmc_csd_reg_t;
+
+/* csd for sd2.0 */
+typedef struct {
+	unsigned not_used:1;
+	unsigned crc:7;
+	unsigned reserved_1:2;
+	unsigned file_format:2;
+	unsigned tmp_write_protect:1;
+	unsigned perm_write_protect:1;
+	unsigned copy:1;
+	unsigned file_format_grp:1;
+	unsigned reserved_2:5;
+	unsigned write_bl_partial:1;
+	unsigned write_bl_len:4;
+	unsigned r2w_factor:3;
+	unsigned reserved_3:2;
+	unsigned wp_grp_enable:1;
+	unsigned wp_grp_size:7;
+	unsigned sector_size:7;
+	unsigned erase_blk_len:1;
+	unsigned reserved_4:1;
+	unsigned c_size_lsb:16;
+	unsigned c_size_msb:6;
+	unsigned reserved_5:6;
+	unsigned dsr_imp:1;
+	unsigned read_blk_misalign:1;
+	unsigned write_blk_misalign:1;
+	unsigned read_bl_partial:1;
+	unsigned read_bl_len:4;
+	unsigned ccc:12;
+	unsigned tran_speed:8;
+	unsigned nsac:8;
+	unsigned taac:8;
+	unsigned reserved_6:6;
+	unsigned csd_structure:2;
+} mmc_sd2_csd_reg_t;
+
+/* extended csd - 512 bytes long */
+typedef struct {
+	unsigned char reserved_1[181];
+	unsigned char erasedmemorycontent;
+	unsigned char reserved_2;
+	unsigned char buswidthmode;
+	unsigned char reserved_3;
+	unsigned char highspeedinterfacetiming;
+	unsigned char reserved_4;
+	unsigned char powerclass;
+	unsigned char reserved_5;
+	unsigned char commandsetrevision;
+	unsigned char reserved_6;
+	unsigned char commandset;
+	unsigned char extendedcsdrevision;
+	unsigned char reserved_7;
+	unsigned char csdstructureversion;
+	unsigned char reserved_8;
+	unsigned char cardtype;
+	unsigned char reserved_9[3];
+	unsigned char powerclass_52mhz_1_95v;
+	unsigned char powerclass_26mhz_1_95v;
+	unsigned char powerclass_52mhz_3_6v;
+	unsigned char powerclass_26mhz_3_6v;
+	unsigned char reserved_10;
+	unsigned char minreadperf_4b_26mhz;
+	unsigned char minwriteperf_4b_26mhz;
+	unsigned char minreadperf_8b_26mhz_4b_52mhz;
+	unsigned char minwriteperf_8b_26mhz_4b_52mhz;
+	unsigned char minreadperf_8b_52mhz;
+	unsigned char minwriteperf_8b_52mhz;
+	unsigned char reserved_11;
+	unsigned int sectorcount;
+	unsigned char reserved_12[288];
+	unsigned char supportedcommandsets;
+	unsigned char reserved_13[7];
+} mmc_extended_csd_reg_t;
+
+/* mmc sd responce */
+typedef struct {
+	unsigned int ocr;
+} mmc_resp_r3;
+
+typedef struct {
+	unsigned short cardstatus;
+	unsigned short newpublishedrca;
+} mmc_resp_r6;
+
+extern mmc_card_data mmc_dev;
+
+unsigned char mmc_lowlevel_init(void);
+unsigned char mmc_send_command(unsigned int cmd, unsigned int arg,
+			       unsigned int *response);
+unsigned char mmc_setup_clock(unsigned int iclk, unsigned short clkd);
+unsigned char mmc_set_opendrain(unsigned char state);
+unsigned char mmc_read_data(unsigned int *output_buf);
+
+#endif /* MMC_H */
diff --git a/include/asm-arm/arch-omap3/mmc_host_def.h b/include/asm-arm/arch-omap3/mmc_host_def.h
new file mode 100644
index 0000000..37aaa08
--- /dev/null
+++ b/include/asm-arm/arch-omap3/mmc_host_def.h
@@ -0,0 +1,166 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ * Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation's version 2 of
+ * the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef MMC_HOST_DEF_H
+#define MMC_HOST_DEF_H
+
+/*
+ * OMAP HSMMC register definitions
+ */
+#define OMAP_HSMMC_SYSCONFIG		(*(unsigned int *) 0x4809C010)
+#define OMAP_HSMMC_SYSSTATUS		(*(unsigned int *) 0x4809C014)
+#define OMAP_HSMMC_CON			(*(unsigned int *) 0x4809C02C)
+#define OMAP_HSMMC_BLK			(*(unsigned int *) 0x4809C104)
+#define OMAP_HSMMC_ARG			(*(unsigned int *) 0x4809C108)
+#define OMAP_HSMMC_CMD			(*(unsigned int *) 0x4809C10C)
+#define OMAP_HSMMC_RSP10		(*(unsigned int *) 0x4809C110)
+#define OMAP_HSMMC_RSP32		(*(unsigned int *) 0x4809C114)
+#define OMAP_HSMMC_RSP54		(*(unsigned int *) 0x4809C118)
+#define OMAP_HSMMC_RSP76		(*(unsigned int *) 0x4809C11C)
+#define OMAP_HSMMC_DATA			(*(unsigned int *) 0x4809C120)
+#define OMAP_HSMMC_PSTATE		(*(unsigned int *) 0x4809C124)
+#define OMAP_HSMMC_HCTL			(*(unsigned int *) 0x4809C128)
+#define OMAP_HSMMC_SYSCTL		(*(unsigned int *) 0x4809C12C)
+#define OMAP_HSMMC_STAT			(*(unsigned int *) 0x4809C130)
+#define OMAP_HSMMC_IE			(*(unsigned int *) 0x4809C134)
+#define OMAP_HSMMC_CAPA			(*(unsigned int *) 0x4809C140)
+
+/* T2 Register definitions */
+#define CONTROL_DEV_CONF0		(*(unsigned int *) 0x48002274)
+#define CONTROL_PBIAS_LITE		(*(unsigned int *) 0x48002520)
+
+/*
+ * OMAP HS MMC Bit definitions
+ */
+#define MMC_SOFTRESET			(0x1 << 1)
+#define RESETDONE			(0x1 << 0)
+#define NOOPENDRAIN			(0x0 << 0)
+#define OPENDRAIN			(0x1 << 0)
+#define OD				(0x1 << 0)
+#define INIT_NOINIT			(0x0 << 1)
+#define INIT_INITSTREAM			(0x1 << 1)
+#define HR_NOHOSTRESP			(0x0 << 2)
+#define STR_BLOCK 			(0x0 << 3)
+#define MODE_FUNC			(0x0 << 4)
+#define DW8_1_4BITMODE 			(0x0 << 5)
+#define MIT_CTO				(0x0 << 6)
+#define CDP_ACTIVEHIGH			(0x0 << 7)
+#define WPP_ACTIVEHIGH 			(0x0 << 8)
+#define RESERVED_MASK			(0x3 << 9)
+#define CTPL_MMC_SD 			(0x0 << 11)
+#define BLEN_512BYTESLEN		(0x200 << 0)
+#define NBLK_STPCNT			(0x0 << 16)
+#define DE_DISABLE			(0x0 << 0)
+#define BCE_DISABLE			(0x0 << 1)
+#define ACEN_DISABLE			(0x0 << 2)
+#define DDIR_OFFSET			(4)
+#define DDIR_MASK			(0x1 << 4)
+#define DDIR_WRITE			(0x0 << 4)
+#define DDIR_READ			(0x1 << 4)
+#define MSBS_SGLEBLK			(0x0 << 5)
+#define RSP_TYPE_OFFSET			(16)
+#define RSP_TYPE_MASK			(0x3 << 16)
+#define RSP_TYPE_NORSP			(0x0 << 16)
+#define RSP_TYPE_LGHT136		(0x1 << 16)
+#define RSP_TYPE_LGHT48			(0x2 << 16)
+#define RSP_TYPE_LGHT48B		(0x3 << 16)
+#define CCCE_NOCHECK			(0x0 << 19)
+#define CCCE_CHECK			(0x1 << 19)
+#define CICE_NOCHECK			(0x0 << 20)
+#define CICE_CHECK			(0x1 << 20)
+#define DP_OFFSET			(21)
+#define DP_MASK				(0x1 << 21)
+#define DP_NO_DATA			(0x0 << 21)
+#define DP_DATA				(0x1 << 21)
+#define CMD_TYPE_NORMAL		        (0x0 << 22)
+#define INDEX_OFFSET			(24)
+#define INDEX_MASK			(0x3f << 24)
+#define INDEX(i)			(i << 24)
+#define DATI_MASK			(0x1 << 1)
+#define DATI_CMDDIS			(0x1 << 1)
+#define DTW_1_BITMODE			(0x0 << 1)
+#define DTW_4_BITMODE			(0x1 << 1)
+#define SDBP_PWROFF			(0x0 << 8)
+#define SDBP_PWRON			(0x1 << 8)
+#define SDVS_1V8			(0x5 << 9)
+#define SDVS_3V0			(0x6 << 9)
+#define ICE_MASK			(0x1 << 0)
+#define ICE_STOP			(0x0 << 0)
+#define ICS_MASK			(0x1 << 1)
+#define ICS_NOTREADY			(0x0 << 1)
+#define ICE_OSCILLATE			(0x1 << 0)
+#define CEN_MASK			(0x1 << 2)
+#define CEN_DISABLE			(0x0 << 2)
+#define CEN_ENABLE			(0x1 << 2)
+#define CLKD_OFFSET			(6)
+#define CLKD_MASK			(0x3FF << 6)
+#define DTO_MASK			(0xF << 16)
+#define DTO_15THDTO			(0xE << 16)
+#define SOFTRESETALL			(0x1 << 24)
+#define CC_MASK				(0x1 << 0)
+#define TC_MASK				(0x1 << 1)
+#define BWR_MASK			(0x1 << 4)
+#define BRR_MASK			(0x1 << 5)
+#define ERRI_MASK			(0x1 << 15)
+#define IE_CC				(0x01 << 0)
+#define IE_TC				(0x01 << 1)
+#define IE_BWR				(0x01 << 4)
+#define IE_BRR				(0x01 << 5)
+#define IE_CTO				(0x01 << 16)
+#define IE_CCRC			        (0x01 << 17)
+#define IE_CEB				(0x01 << 18)
+#define IE_CIE				(0x01 << 19)
+#define IE_DTO				(0x01 << 20)
+#define IE_DCRC				(0x01 << 21)
+#define IE_DEB				(0x01 << 22)
+#define IE_CERR				(0x01 << 28)
+#define IE_BADA				(0x01 << 29)
+
+#define VS30_3V0SUP		        (1 << 25)
+#define VS18_1V8SUP			(1 << 26)
+
+/* Driver definitions */
+#define MMCSD_SECTOR_SIZE		(512)
+#define MMC_CARD			0
+#define SD_CARD				1
+#define BYTE_MODE			0
+#define SECTOR_MODE			1
+#define CLK_INITSEQ		        0
+#define CLK_400KHZ		        1
+#define CLK_MISC			2
+
+typedef struct {
+	unsigned int card_type;
+	unsigned int version;
+	unsigned int mode;
+	unsigned int size;
+	unsigned int RCA;
+} mmc_card_data;
+
+#define mmc_reg_out(addr, mask, val)\
+	(addr) = (((addr)) & (~(mask))) | ((val) & (mask));
+#define mmc_reg_out(addr, mask, val)\
+	(addr) = (((addr)) & (~(mask))) | ((val) & (mask));
+
+#endif /* MMC_HOST_DEF_H */
diff --git a/include/asm-arm/arch-omap3/mux.h b/include/asm-arm/arch-omap3/mux.h
new file mode 100644
index 0000000..ec4aeb0
--- /dev/null
+++ b/include/asm-arm/arch-omap3/mux.h
@@ -0,0 +1,757 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments, <www.ti.com>
+ * Syed Mohammed Khasim <x0khasim@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _MUX_H_
+#define _MUX_H_
+
+/*
+ * IEN  - Input Enable
+ * IDIS - Input Disable
+ * PTD  - Pull type Down
+ * PTU  - Pull type Up
+ * DIS  - Pull type selection is inactive
+ * EN   - Pull type selection is active
+ * M0   - Mode 0
+ */
+
+#define  IEN	(1 << 8)
+
+#define  IDIS	(0 << 8)
+#define  PTU	(1 << 4)
+#define  PTD	(0 << 4)
+#define  EN		(1 << 3)
+#define  DIS	(0 << 3)
+
+#define  M0	0
+#define  M1	1
+#define  M2	2
+#define  M3	3
+#define  M4	4
+#define  M5	5
+#define  M6	6
+#define  M7	7
+
+/*
+ * To get the actual address the offset has to added
+ * with OMAP34XX_CTRL_BASE to get the actual address
+ */
+
+ /*SDRC*/
+#define  CONTROL_PADCONF_SDRC_D0             0x0030
+#define  CONTROL_PADCONF_SDRC_D1             0x0032
+#define  CONTROL_PADCONF_SDRC_D2             0x0034
+#define  CONTROL_PADCONF_SDRC_D3             0x0036
+#define  CONTROL_PADCONF_SDRC_D4             0x0038
+#define  CONTROL_PADCONF_SDRC_D5             0x003A
+#define  CONTROL_PADCONF_SDRC_D6             0x003C
+#define  CONTROL_PADCONF_SDRC_D7             0x003E
+#define  CONTROL_PADCONF_SDRC_D8             0x0040
+#define  CONTROL_PADCONF_SDRC_D9             0x0042
+#define  CONTROL_PADCONF_SDRC_D10            0x0044
+#define  CONTROL_PADCONF_SDRC_D11            0x0046
+#define  CONTROL_PADCONF_SDRC_D12            0x0048
+#define  CONTROL_PADCONF_SDRC_D13            0x004A
+#define  CONTROL_PADCONF_SDRC_D14            0x004C
+#define  CONTROL_PADCONF_SDRC_D15            0x004E
+#define  CONTROL_PADCONF_SDRC_D16            0x0050
+#define  CONTROL_PADCONF_SDRC_D17            0x0052
+#define  CONTROL_PADCONF_SDRC_D18            0x0054
+#define  CONTROL_PADCONF_SDRC_D19            0x0056
+#define  CONTROL_PADCONF_SDRC_D20            0x0058
+#define  CONTROL_PADCONF_SDRC_D21            0x005A
+#define  CONTROL_PADCONF_SDRC_D22            0x005C
+#define  CONTROL_PADCONF_SDRC_D23            0x005E
+#define  CONTROL_PADCONF_SDRC_D24            0x0060
+#define  CONTROL_PADCONF_SDRC_D25            0x0062
+#define  CONTROL_PADCONF_SDRC_D26            0x0064
+#define  CONTROL_PADCONF_SDRC_D27            0x0066
+#define  CONTROL_PADCONF_SDRC_D28            0x0068
+#define  CONTROL_PADCONF_SDRC_D29            0x006A
+#define  CONTROL_PADCONF_SDRC_D30            0x006C
+#define  CONTROL_PADCONF_SDRC_D31            0x006E
+#define  CONTROL_PADCONF_SDRC_CLK            0x0070
+#define  CONTROL_PADCONF_SDRC_DQS0           0x0072
+#define  CONTROL_PADCONF_SDRC_DQS1           0x0074
+#define  CONTROL_PADCONF_SDRC_DQS2           0x0076
+#define  CONTROL_PADCONF_SDRC_DQS3           0x0078
+     /*GPMC*/
+#define  CONTROL_PADCONF_GPMC_A1             0x007A
+#define  CONTROL_PADCONF_GPMC_A2             0x007C
+#define  CONTROL_PADCONF_GPMC_A3             0x007E
+#define  CONTROL_PADCONF_GPMC_A4             0x0080
+#define  CONTROL_PADCONF_GPMC_A5             0x0082
+#define  CONTROL_PADCONF_GPMC_A6             0x0084
+#define  CONTROL_PADCONF_GPMC_A7             0x0086
+#define  CONTROL_PADCONF_GPMC_A8             0x0088
+#define  CONTROL_PADCONF_GPMC_A9             0x008A
+#define  CONTROL_PADCONF_GPMC_A10            0x008C
+#define  CONTROL_PADCONF_GPMC_D0             0x008E
+#define  CONTROL_PADCONF_GPMC_D1             0x0090
+#define  CONTROL_PADCONF_GPMC_D2             0x0092
+#define  CONTROL_PADCONF_GPMC_D3             0x0094
+#define  CONTROL_PADCONF_GPMC_D4             0x0096
+#define  CONTROL_PADCONF_GPMC_D5             0x0098
+#define  CONTROL_PADCONF_GPMC_D6             0x009A
+#define  CONTROL_PADCONF_GPMC_D7             0x009C
+#define  CONTROL_PADCONF_GPMC_D8             0x009E
+#define  CONTROL_PADCONF_GPMC_D9             0x00A0
+#define  CONTROL_PADCONF_GPMC_D10            0x00A2
+#define  CONTROL_PADCONF_GPMC_D11            0x00A4
+#define  CONTROL_PADCONF_GPMC_D12            0x00A6
+#define  CONTROL_PADCONF_GPMC_D13            0x00A8
+#define  CONTROL_PADCONF_GPMC_D14            0x00AA
+#define  CONTROL_PADCONF_GPMC_D15            0x00AC
+#define  CONTROL_PADCONF_GPMC_nCS0           0x00AE
+#define  CONTROL_PADCONF_GPMC_nCS1           0x00B0
+#define  CONTROL_PADCONF_GPMC_nCS2           0x00B2
+#define  CONTROL_PADCONF_GPMC_nCS3           0x00B4
+#define  CONTROL_PADCONF_GPMC_nCS4           0x00B6
+#define  CONTROL_PADCONF_GPMC_nCS5           0x00B8
+#define  CONTROL_PADCONF_GPMC_nCS6           0x00BA
+#define  CONTROL_PADCONF_GPMC_nCS7           0x00BC
+#define  CONTROL_PADCONF_GPMC_CLK            0x00BE
+#define  CONTROL_PADCONF_GPMC_nADV_ALE       0x00C0
+#define  CONTROL_PADCONF_GPMC_nOE            0x00C2
+#define  CONTROL_PADCONF_GPMC_nWE            0x00C4
+#define  CONTROL_PADCONF_GPMC_nBE0_CLE       0x00C6
+#define  CONTROL_PADCONF_GPMC_nBE1           0x00C8
+#define  CONTROL_PADCONF_GPMC_nWP            0x00CA
+#define  CONTROL_PADCONF_GPMC_WAIT0          0x00CC
+#define  CONTROL_PADCONF_GPMC_WAIT1          0x00CE
+#define  CONTROL_PADCONF_GPMC_WAIT2          0x00D0
+#define  CONTROL_PADCONF_GPMC_WAIT3          0x00D2
+     /*DSS*/
+#define  CONTROL_PADCONF_DSS_PCLK            0x00D4
+#define  CONTROL_PADCONF_DSS_HSYNC           0x00D6
+#define  CONTROL_PADCONF_DSS_VSYNC           0x00D8
+#define  CONTROL_PADCONF_DSS_ACBIAS          0x00DA
+#define  CONTROL_PADCONF_DSS_DATA0           0x00DC
+#define  CONTROL_PADCONF_DSS_DATA1           0x00DE
+#define  CONTROL_PADCONF_DSS_DATA2           0x00E0
+#define  CONTROL_PADCONF_DSS_DATA3           0x00E2
+#define  CONTROL_PADCONF_DSS_DATA4           0x00E4
+#define  CONTROL_PADCONF_DSS_DATA5           0x00E6
+#define  CONTROL_PADCONF_DSS_DATA6           0x00E8
+#define  CONTROL_PADCONF_DSS_DATA7           0x00EA
+#define  CONTROL_PADCONF_DSS_DATA8           0x00EC
+#define  CONTROL_PADCONF_DSS_DATA9           0x00EE
+#define  CONTROL_PADCONF_DSS_DATA10          0x00F0
+#define  CONTROL_PADCONF_DSS_DATA11          0x00F2
+#define  CONTROL_PADCONF_DSS_DATA12          0x00F4
+#define  CONTROL_PADCONF_DSS_DATA13          0x00F6
+#define  CONTROL_PADCONF_DSS_DATA14          0x00F8
+#define  CONTROL_PADCONF_DSS_DATA15          0x00FA
+#define  CONTROL_PADCONF_DSS_DATA16          0x00FC
+#define  CONTROL_PADCONF_DSS_DATA17          0x00FE
+#define  CONTROL_PADCONF_DSS_DATA18          0x0100
+#define  CONTROL_PADCONF_DSS_DATA19          0x0102
+#define  CONTROL_PADCONF_DSS_DATA20          0x0104
+#define  CONTROL_PADCONF_DSS_DATA21          0x0106
+#define  CONTROL_PADCONF_DSS_DATA22          0x0108
+#define  CONTROL_PADCONF_DSS_DATA23          0x010A
+     /*CAMERA*/
+#define  CONTROL_PADCONF_CAM_HS              0x010C
+#define  CONTROL_PADCONF_CAM_VS              0x010E
+#define  CONTROL_PADCONF_CAM_XCLKA           0x0110
+#define  CONTROL_PADCONF_CAM_PCLK            0x0112
+#define  CONTROL_PADCONF_CAM_FLD             0x0114
+#define  CONTROL_PADCONF_CAM_D0              0x0116
+#define  CONTROL_PADCONF_CAM_D1              0x0118
+#define  CONTROL_PADCONF_CAM_D2              0x011A
+#define  CONTROL_PADCONF_CAM_D3              0x011C
+#define  CONTROL_PADCONF_CAM_D4              0x011E
+#define  CONTROL_PADCONF_CAM_D5              0x0120
+#define  CONTROL_PADCONF_CAM_D6              0x0122
+#define  CONTROL_PADCONF_CAM_D7              0x0124
+#define  CONTROL_PADCONF_CAM_D8              0x0126
+#define  CONTROL_PADCONF_CAM_D9              0x0128
+#define  CONTROL_PADCONF_CAM_D10             0x012A
+#define  CONTROL_PADCONF_CAM_D11             0x012C
+#define  CONTROL_PADCONF_CAM_XCLKB           0x012E
+#define  CONTROL_PADCONF_CAM_WEN             0x0130
+#define  CONTROL_PADCONF_CAM_STROBE          0x0132
+#define  CONTROL_PADCONF_CSI2_DX0            0x0134
+#define  CONTROL_PADCONF_CSI2_DY0            0x0136
+#define  CONTROL_PADCONF_CSI2_DX1            0x0138
+#define  CONTROL_PADCONF_CSI2_DY1            0x013A
+/*Audio Interface */
+#define  CONTROL_PADCONF_McBSP2_FSX          0x013C
+#define  CONTROL_PADCONF_McBSP2_CLKX         0x013E
+#define  CONTROL_PADCONF_McBSP2_DR           0x0140
+#define  CONTROL_PADCONF_McBSP2_DX           0x0142
+#define  CONTROL_PADCONF_MMC1_CLK            0x0144
+#define  CONTROL_PADCONF_MMC1_CMD            0x0146
+#define  CONTROL_PADCONF_MMC1_DAT0           0x0148
+#define  CONTROL_PADCONF_MMC1_DAT1           0x014A
+#define  CONTROL_PADCONF_MMC1_DAT2           0x014C
+#define  CONTROL_PADCONF_MMC1_DAT3           0x014E
+#define  CONTROL_PADCONF_MMC1_DAT4           0x0150
+#define  CONTROL_PADCONF_MMC1_DAT5           0x0152
+#define  CONTROL_PADCONF_MMC1_DAT6           0x0154
+#define  CONTROL_PADCONF_MMC1_DAT7           0x0156
+/*Wireless LAN */
+#define  CONTROL_PADCONF_MMC2_CLK            0x0158
+#define  CONTROL_PADCONF_MMC2_CMD            0x015A
+#define  CONTROL_PADCONF_MMC2_DAT0           0x015C
+#define  CONTROL_PADCONF_MMC2_DAT1           0x015E
+#define  CONTROL_PADCONF_MMC2_DAT2           0x0160
+#define  CONTROL_PADCONF_MMC2_DAT3           0x0162
+#define  CONTROL_PADCONF_MMC2_DAT4           0x0164
+#define  CONTROL_PADCONF_MMC2_DAT5           0x0166
+#define  CONTROL_PADCONF_MMC2_DAT6           0x0168
+#define  CONTROL_PADCONF_MMC2_DAT7           0x016A
+/*Bluetooth*/
+#define  CONTROL_PADCONF_McBSP3_DX           0x016C
+#define  CONTROL_PADCONF_McBSP3_DR           0x016E
+#define  CONTROL_PADCONF_McBSP3_CLKX         0x0170
+#define  CONTROL_PADCONF_McBSP3_FSX          0x0172
+#define  CONTROL_PADCONF_UART2_CTS           0x0174
+#define  CONTROL_PADCONF_UART2_RTS           0x0176
+#define  CONTROL_PADCONF_UART2_TX            0x0178
+#define  CONTROL_PADCONF_UART2_RX            0x017A
+/*Modem Interface */
+#define  CONTROL_PADCONF_UART1_TX            0x017C
+#define  CONTROL_PADCONF_UART1_RTS           0x017E
+#define  CONTROL_PADCONF_UART1_CTS           0x0180
+#define  CONTROL_PADCONF_UART1_RX            0x0182
+#define  CONTROL_PADCONF_McBSP4_CLKX         0x0184
+#define  CONTROL_PADCONF_McBSP4_DR           0x0186
+#define  CONTROL_PADCONF_McBSP4_DX           0x0188
+#define  CONTROL_PADCONF_McBSP4_FSX          0x018A
+#define  CONTROL_PADCONF_McBSP1_CLKR         0x018C
+#define  CONTROL_PADCONF_McBSP1_FSR          0x018E
+#define  CONTROL_PADCONF_McBSP1_DX           0x0190
+#define  CONTROL_PADCONF_McBSP1_DR           0x0192
+#define  CONTROL_PADCONF_McBSP_CLKS          0x0194
+#define  CONTROL_PADCONF_McBSP1_FSX          0x0196
+#define  CONTROL_PADCONF_McBSP1_CLKX         0x0198
+/*Serial Interface*/
+#define  CONTROL_PADCONF_UART3_CTS_RCTX      0x019A
+#define  CONTROL_PADCONF_UART3_RTS_SD        0x019C
+#define  CONTROL_PADCONF_UART3_RX_IRRX       0x019E
+#define  CONTROL_PADCONF_UART3_TX_IRTX       0x01A0
+#define  CONTROL_PADCONF_HSUSB0_CLK          0x01A2
+#define  CONTROL_PADCONF_HSUSB0_STP          0x01A4
+#define  CONTROL_PADCONF_HSUSB0_DIR          0x01A6
+#define  CONTROL_PADCONF_HSUSB0_NXT          0x01A8
+#define  CONTROL_PADCONF_HSUSB0_DATA0        0x01AA
+#define  CONTROL_PADCONF_HSUSB0_DATA1        0x01AC
+#define  CONTROL_PADCONF_HSUSB0_DATA2        0x01AE
+#define  CONTROL_PADCONF_HSUSB0_DATA3        0x01B0
+#define  CONTROL_PADCONF_HSUSB0_DATA4        0x01B2
+#define  CONTROL_PADCONF_HSUSB0_DATA5        0x01B4
+#define  CONTROL_PADCONF_HSUSB0_DATA6        0x01B6
+#define  CONTROL_PADCONF_HSUSB0_DATA7        0x01B8
+#define  CONTROL_PADCONF_I2C1_SCL            0x01BA
+#define  CONTROL_PADCONF_I2C1_SDA            0x01BC
+#define  CONTROL_PADCONF_I2C2_SCL            0x01BE
+#define  CONTROL_PADCONF_I2C2_SDA            0x01C0
+#define  CONTROL_PADCONF_I2C3_SCL            0x01C2
+#define  CONTROL_PADCONF_I2C3_SDA            0x01C4
+#define  CONTROL_PADCONF_I2C4_SCL            0x0A00
+#define  CONTROL_PADCONF_I2C4_SDA            0x0A02
+#define  CONTROL_PADCONF_HDQ_SIO             0x01C6
+#define  CONTROL_PADCONF_McSPI1_CLK          0x01C8
+#define  CONTROL_PADCONF_McSPI1_SIMO         0x01CA
+#define  CONTROL_PADCONF_McSPI1_SOMI         0x01CC
+#define  CONTROL_PADCONF_McSPI1_CS0          0x01CE
+#define  CONTROL_PADCONF_McSPI1_CS1          0x01D0
+#define  CONTROL_PADCONF_McSPI1_CS2          0x01D2
+#define  CONTROL_PADCONF_McSPI1_CS3          0x01D4
+#define  CONTROL_PADCONF_McSPI2_CLK          0x01D6
+#define  CONTROL_PADCONF_McSPI2_SIMO         0x01D8
+#define  CONTROL_PADCONF_McSPI2_SOMI         0x01DA
+#define  CONTROL_PADCONF_McSPI2_CS0          0x01DC
+#define  CONTROL_PADCONF_McSPI2_CS1          0x01DE
+/*Control and debug */
+#define  CONTROL_PADCONF_SYS_32K             0x0A04
+#define  CONTROL_PADCONF_SYS_CLKREQ          0x0A06
+#define  CONTROL_PADCONF_SYS_nIRQ            0x01E0
+#define  CONTROL_PADCONF_SYS_BOOT0           0x0A0A
+#define  CONTROL_PADCONF_SYS_BOOT1           0x0A0C
+#define  CONTROL_PADCONF_SYS_BOOT2           0x0A0E
+#define  CONTROL_PADCONF_SYS_BOOT3           0x0A10
+#define  CONTROL_PADCONF_SYS_BOOT4           0x0A12
+#define  CONTROL_PADCONF_SYS_BOOT5           0x0A14
+#define  CONTROL_PADCONF_SYS_BOOT6           0x0A16
+#define  CONTROL_PADCONF_SYS_OFF_MODE        0x0A18
+#define  CONTROL_PADCONF_SYS_CLKOUT1         0x0A1A
+#define  CONTROL_PADCONF_SYS_CLKOUT2         0x01E2
+#define  CONTROL_PADCONF_JTAG_nTRST          0x0A1C
+#define  CONTROL_PADCONF_JTAG_TCK            0x0A1E
+#define  CONTROL_PADCONF_JTAG_TMS            0x0A20
+#define  CONTROL_PADCONF_JTAG_TDI            0x0A22
+#define  CONTROL_PADCONF_JTAG_EMU0           0x0A24
+#define  CONTROL_PADCONF_JTAG_EMU1           0x0A26
+#define  CONTROL_PADCONF_ETK_CLK             0x0A28
+#define  CONTROL_PADCONF_ETK_CTL             0x0A2A
+#define  CONTROL_PADCONF_ETK_D0              0x0A2C
+#define  CONTROL_PADCONF_ETK_D1              0x0A2E
+#define  CONTROL_PADCONF_ETK_D2              0x0A30
+#define  CONTROL_PADCONF_ETK_D3              0x0A32
+#define  CONTROL_PADCONF_ETK_D4              0x0A34
+#define  CONTROL_PADCONF_ETK_D5              0x0A36
+#define  CONTROL_PADCONF_ETK_D6              0x0A38
+#define  CONTROL_PADCONF_ETK_D7              0x0A3A
+#define  CONTROL_PADCONF_ETK_D8              0x0A3C
+#define  CONTROL_PADCONF_ETK_D9              0x0A3E
+#define  CONTROL_PADCONF_ETK_D10             0x0A40
+#define  CONTROL_PADCONF_ETK_D11             0x0A42
+#define  CONTROL_PADCONF_ETK_D12             0x0A44
+#define  CONTROL_PADCONF_ETK_D13             0x0A46
+#define  CONTROL_PADCONF_ETK_D14             0x0A48
+#define  CONTROL_PADCONF_ETK_D15             0x0A4A
+#define  CONTROL_PADCONF_ETK_CLK_ES2         0x05D8
+#define  CONTROL_PADCONF_ETK_CTL_ES2         0x05DA
+#define  CONTROL_PADCONF_ETK_D0_ES2          0x05DC
+#define  CONTROL_PADCONF_ETK_D1_ES2          0x05DE
+#define  CONTROL_PADCONF_ETK_D2_ES2          0x05E0
+#define  CONTROL_PADCONF_ETK_D3_ES2          0x05E2
+#define  CONTROL_PADCONF_ETK_D4_ES2          0x05E4
+#define  CONTROL_PADCONF_ETK_D5_ES2          0x05E6
+#define  CONTROL_PADCONF_ETK_D6_ES2          0x05E8
+#define  CONTROL_PADCONF_ETK_D7_ES2          0x05EA
+#define  CONTROL_PADCONF_ETK_D8_ES2          0x05EC
+#define  CONTROL_PADCONF_ETK_D9_ES2          0x05EE
+#define  CONTROL_PADCONF_ETK_D10_ES2         0x05F0
+#define  CONTROL_PADCONF_ETK_D11_ES2         0x05F2
+#define  CONTROL_PADCONF_ETK_D12_ES2         0x05F4
+#define  CONTROL_PADCONF_ETK_D13_ES2         0x05F6
+#define  CONTROL_PADCONF_ETK_D14_ES2         0x05F8
+#define  CONTROL_PADCONF_ETK_D15_ES2         0x05FA
+/*Die to Die */
+#define  CONTROL_PADCONF_d2d_mcad0           0x01E4
+#define  CONTROL_PADCONF_d2d_mcad1           0x01E6
+#define  CONTROL_PADCONF_d2d_mcad2           0x01E8
+#define  CONTROL_PADCONF_d2d_mcad3           0x01EA
+#define  CONTROL_PADCONF_d2d_mcad4           0x01EC
+#define  CONTROL_PADCONF_d2d_mcad5           0x01EE
+#define  CONTROL_PADCONF_d2d_mcad6           0x01F0
+#define  CONTROL_PADCONF_d2d_mcad7           0x01F2
+#define  CONTROL_PADCONF_d2d_mcad8           0x01F4
+#define  CONTROL_PADCONF_d2d_mcad9           0x01F6
+#define  CONTROL_PADCONF_d2d_mcad10          0x01F8
+#define  CONTROL_PADCONF_d2d_mcad11          0x01FA
+#define  CONTROL_PADCONF_d2d_mcad12          0x01FC
+#define  CONTROL_PADCONF_d2d_mcad13          0x01FE
+#define  CONTROL_PADCONF_d2d_mcad14          0x0200
+#define  CONTROL_PADCONF_d2d_mcad15          0x0202
+#define  CONTROL_PADCONF_d2d_mcad16          0x0204
+#define  CONTROL_PADCONF_d2d_mcad17          0x0206
+#define  CONTROL_PADCONF_d2d_mcad18          0x0208
+#define  CONTROL_PADCONF_d2d_mcad19          0x020A
+#define  CONTROL_PADCONF_d2d_mcad20          0x020C
+#define  CONTROL_PADCONF_d2d_mcad21          0x020E
+#define  CONTROL_PADCONF_d2d_mcad22          0x0210
+#define  CONTROL_PADCONF_d2d_mcad23          0x0212
+#define  CONTROL_PADCONF_d2d_mcad24          0x0214
+#define  CONTROL_PADCONF_d2d_mcad25          0x0216
+#define  CONTROL_PADCONF_d2d_mcad26          0x0218
+#define  CONTROL_PADCONF_d2d_mcad27          0x021A
+#define  CONTROL_PADCONF_d2d_mcad28          0x021C
+#define  CONTROL_PADCONF_d2d_mcad29          0x021E
+#define  CONTROL_PADCONF_d2d_mcad30          0x0220
+#define  CONTROL_PADCONF_d2d_mcad31          0x0222
+#define  CONTROL_PADCONF_d2d_mcad32          0x0224
+#define  CONTROL_PADCONF_d2d_mcad33          0x0226
+#define  CONTROL_PADCONF_d2d_mcad34          0x0228
+#define  CONTROL_PADCONF_d2d_mcad35          0x022A
+#define  CONTROL_PADCONF_d2d_mcad36          0x022C
+#define  CONTROL_PADCONF_d2d_clk26mi         0x022E
+#define  CONTROL_PADCONF_d2d_nrespwron       0x0230
+#define  CONTROL_PADCONF_d2d_nreswarm        0x0232
+#define  CONTROL_PADCONF_d2d_arm9nirq        0x0234
+#define  CONTROL_PADCONF_d2d_uma2p6fiq       0x0236
+#define  CONTROL_PADCONF_d2d_spint           0x0238
+#define  CONTROL_PADCONF_d2d_frint           0x023A
+#define  CONTROL_PADCONF_d2d_dmareq0         0x023C
+#define  CONTROL_PADCONF_d2d_dmareq1         0x023E
+#define  CONTROL_PADCONF_d2d_dmareq2         0x0240
+#define  CONTROL_PADCONF_d2d_dmareq3         0x0242
+#define  CONTROL_PADCONF_d2d_n3gtrst         0x0244
+#define  CONTROL_PADCONF_d2d_n3gtdi          0x0246
+#define  CONTROL_PADCONF_d2d_n3gtdo          0x0248
+#define  CONTROL_PADCONF_d2d_n3gtms          0x024A
+#define  CONTROL_PADCONF_d2d_n3gtck          0x024C
+#define  CONTROL_PADCONF_d2d_n3grtck         0x024E
+#define  CONTROL_PADCONF_d2d_mstdby          0x0250
+#define  CONTROL_PADCONF_d2d_swakeup         0x0A4C
+#define  CONTROL_PADCONF_d2d_idlereq         0x0252
+#define  CONTROL_PADCONF_d2d_idleack         0x0254
+#define  CONTROL_PADCONF_d2d_mwrite          0x0256
+#define  CONTROL_PADCONF_d2d_swrite          0x0258
+#define  CONTROL_PADCONF_d2d_mread           0x025A
+#define  CONTROL_PADCONF_d2d_sread           0x025C
+#define  CONTROL_PADCONF_d2d_mbusflag        0x025E
+#define  CONTROL_PADCONF_d2d_sbusflag        0x0260
+#define  CONTROL_PADCONF_sdrc_cke0	     0x0262
+#define  CONTROL_PADCONF_sdrc_cke1	     0x0264
+
+#define 	MUX_VAL(OFFSET,VALUE)\
+		__raw_writew((VALUE), OMAP34XX_CTRL_BASE + (OFFSET));
+
+#define		CP(x)	(CONTROL_PADCONF_##x)
+
+/*
+ * IEN  - Input Enable
+ * IDIS - Input Disable
+ * PTD  - Pull type Down
+ * PTU  - Pull type Up
+ * DIS  - Pull type selection is inactive
+ * EN   - Pull type selection is active
+ * M0   - Mode 0
+ * The commented string gives the final mux configuration for that pin
+ */
+#define MUX_DEFAULT_ES2() \
+	/*SDRC*/\
+	MUX_VAL(CP(SDRC_D0),        (IEN  | PTD | DIS | M0)) /*SDRC_D0*/\
+	MUX_VAL(CP(SDRC_D1),        (IEN  | PTD | DIS | M0)) /*SDRC_D1*/\
+	MUX_VAL(CP(SDRC_D2),        (IEN  | PTD | DIS | M0)) /*SDRC_D2*/\
+	MUX_VAL(CP(SDRC_D3),        (IEN  | PTD | DIS | M0)) /*SDRC_D3*/\
+	MUX_VAL(CP(SDRC_D4),        (IEN  | PTD | DIS | M0)) /*SDRC_D4*/\
+	MUX_VAL(CP(SDRC_D5),        (IEN  | PTD | DIS | M0)) /*SDRC_D5*/\
+	MUX_VAL(CP(SDRC_D6),        (IEN  | PTD | DIS | M0)) /*SDRC_D6*/\
+	MUX_VAL(CP(SDRC_D7),        (IEN  | PTD | DIS | M0)) /*SDRC_D7*/\
+	MUX_VAL(CP(SDRC_D8),        (IEN  | PTD | DIS | M0)) /*SDRC_D8*/\
+	MUX_VAL(CP(SDRC_D9),        (IEN  | PTD | DIS | M0)) /*SDRC_D9*/\
+	MUX_VAL(CP(SDRC_D10),       (IEN  | PTD | DIS | M0)) /*SDRC_D10*/\
+	MUX_VAL(CP(SDRC_D11),       (IEN  | PTD | DIS | M0)) /*SDRC_D11*/\
+	MUX_VAL(CP(SDRC_D12),       (IEN  | PTD | DIS | M0)) /*SDRC_D12*/\
+	MUX_VAL(CP(SDRC_D13),       (IEN  | PTD | DIS | M0)) /*SDRC_D13*/\
+	MUX_VAL(CP(SDRC_D14),       (IEN  | PTD | DIS | M0)) /*SDRC_D14*/\
+	MUX_VAL(CP(SDRC_D15),       (IEN  | PTD | DIS | M0)) /*SDRC_D15*/\
+	MUX_VAL(CP(SDRC_D16),       (IEN  | PTD | DIS | M0)) /*SDRC_D16*/\
+	MUX_VAL(CP(SDRC_D17),       (IEN  | PTD | DIS | M0)) /*SDRC_D17*/\
+	MUX_VAL(CP(SDRC_D18),       (IEN  | PTD | DIS | M0)) /*SDRC_D18*/\
+	MUX_VAL(CP(SDRC_D19),       (IEN  | PTD | DIS | M0)) /*SDRC_D19*/\
+	MUX_VAL(CP(SDRC_D20),       (IEN  | PTD | DIS | M0)) /*SDRC_D20*/\
+	MUX_VAL(CP(SDRC_D21),       (IEN  | PTD | DIS | M0)) /*SDRC_D21*/\
+	MUX_VAL(CP(SDRC_D22),       (IEN  | PTD | DIS | M0)) /*SDRC_D22*/\
+	MUX_VAL(CP(SDRC_D23),       (IEN  | PTD | DIS | M0)) /*SDRC_D23*/\
+	MUX_VAL(CP(SDRC_D24),       (IEN  | PTD | DIS | M0)) /*SDRC_D24*/\
+	MUX_VAL(CP(SDRC_D25),       (IEN  | PTD | DIS | M0)) /*SDRC_D25*/\
+	MUX_VAL(CP(SDRC_D26),       (IEN  | PTD | DIS | M0)) /*SDRC_D26*/\
+	MUX_VAL(CP(SDRC_D27),       (IEN  | PTD | DIS | M0)) /*SDRC_D27*/\
+	MUX_VAL(CP(SDRC_D28),       (IEN  | PTD | DIS | M0)) /*SDRC_D28*/\
+	MUX_VAL(CP(SDRC_D29),       (IEN  | PTD | DIS | M0)) /*SDRC_D29*/\
+	MUX_VAL(CP(SDRC_D30),       (IEN  | PTD | DIS | M0)) /*SDRC_D30*/\
+	MUX_VAL(CP(SDRC_D31),       (IEN  | PTD | DIS | M0)) /*SDRC_D31*/\
+	MUX_VAL(CP(SDRC_CLK),       (IEN  | PTD | DIS | M0)) /*SDRC_CLK*/\
+	MUX_VAL(CP(SDRC_DQS0),      (IEN  | PTD | DIS | M0)) /*SDRC_DQS0*/\
+	MUX_VAL(CP(SDRC_DQS1),      (IEN  | PTD | DIS | M0)) /*SDRC_DQS1*/\
+	MUX_VAL(CP(SDRC_DQS2),      (IEN  | PTD | DIS | M0)) /*SDRC_DQS2*/\
+	MUX_VAL(CP(SDRC_DQS3),      (IEN  | PTD | DIS | M0)) /*SDRC_DQS3*/\
+	/*GPMC*/\
+	MUX_VAL(CP(GPMC_A1),        (IDIS | PTD | DIS | M0)) /*GPMC_A1*/\
+	MUX_VAL(CP(GPMC_A2),        (IDIS | PTD | DIS | M0)) /*GPMC_A2*/\
+	MUX_VAL(CP(GPMC_A3),        (IDIS | PTD | DIS | M0)) /*GPMC_A3*/\
+	MUX_VAL(CP(GPMC_A4),        (IDIS | PTD | DIS | M0)) /*GPMC_A4*/\
+	MUX_VAL(CP(GPMC_A5),        (IDIS | PTD | DIS | M0)) /*GPMC_A5*/\
+	MUX_VAL(CP(GPMC_A6),        (IDIS | PTD | DIS | M0)) /*GPMC_A6*/\
+	MUX_VAL(CP(GPMC_A7),        (IDIS | PTD | DIS | M0)) /*GPMC_A7*/\
+	MUX_VAL(CP(GPMC_A8),        (IDIS | PTD | DIS | M0)) /*GPMC_A8*/\
+	MUX_VAL(CP(GPMC_A9),        (IDIS | PTD | DIS | M0)) /*GPMC_A9*/\
+	MUX_VAL(CP(GPMC_A10),       (IDIS | PTD | DIS | M0)) /*GPMC_A10*/\
+	MUX_VAL(CP(GPMC_D0),        (IEN  | PTD | DIS | M0)) /*GPMC_D0*/\
+	MUX_VAL(CP(GPMC_D1),        (IEN  | PTD | DIS | M0)) /*GPMC_D1*/\
+	MUX_VAL(CP(GPMC_D2),        (IEN  | PTD | DIS | M0)) /*GPMC_D2*/\
+	MUX_VAL(CP(GPMC_D3),        (IEN  | PTD | DIS | M0)) /*GPMC_D3*/\
+	MUX_VAL(CP(GPMC_D4),        (IEN  | PTD | DIS | M0)) /*GPMC_D4*/\
+	MUX_VAL(CP(GPMC_D5),        (IEN  | PTD | DIS | M0)) /*GPMC_D5*/\
+	MUX_VAL(CP(GPMC_D6),        (IEN  | PTD | DIS | M0)) /*GPMC_D6*/\
+	MUX_VAL(CP(GPMC_D7),        (IEN  | PTD | DIS | M0)) /*GPMC_D7*/\
+	MUX_VAL(CP(GPMC_D8),        (IEN  | PTD | DIS | M0)) /*GPMC_D8*/\
+	MUX_VAL(CP(GPMC_D9),        (IEN  | PTD | DIS | M0)) /*GPMC_D9*/\
+	MUX_VAL(CP(GPMC_D10),       (IEN  | PTD | DIS | M0)) /*GPMC_D10*/\
+	MUX_VAL(CP(GPMC_D11),       (IEN  | PTD | DIS | M0)) /*GPMC_D11*/\
+	MUX_VAL(CP(GPMC_D12),       (IEN  | PTD | DIS | M0)) /*GPMC_D12*/\
+	MUX_VAL(CP(GPMC_D13),       (IEN  | PTD | DIS | M0)) /*GPMC_D13*/\
+	MUX_VAL(CP(GPMC_D14),       (IEN  | PTD | DIS | M0)) /*GPMC_D14*/\
+	MUX_VAL(CP(GPMC_D15),       (IEN  | PTD | DIS | M0)) /*GPMC_D15*/\
+	MUX_VAL(CP(GPMC_nCS0),      (IDIS | PTU | EN  | M0)) /*GPMC_nCS0*/\
+	MUX_VAL(CP(GPMC_nCS1),      (IDIS | PTU | EN  | M0)) /*GPMC_nCS1*/\
+	MUX_VAL(CP(GPMC_nCS2),      (IDIS | PTU | EN  | M0)) /*GPMC_nCS2*/\
+	MUX_VAL(CP(GPMC_nCS3),      (IDIS | PTU | EN  | M0)) /*GPMC_nCS3*/\
+	/* For Beagle Rev 2 boards*/\
+	MUX_VAL(CP(GPMC_nCS4),      (IDIS | PTU | EN  | M0))\
+	MUX_VAL(CP(GPMC_nCS5),      (IDIS | PTD | DIS | M0))\
+	MUX_VAL(CP(GPMC_nCS6),      (IEN  | PTD | DIS | M1))\
+	MUX_VAL(CP(GPMC_nCS7),      (IEN  | PTU | EN  | M1))\
+	MUX_VAL(CP(GPMC_nBE1),      (IEN  | PTD | DIS | M0))\
+	MUX_VAL(CP(GPMC_WAIT2),     (IEN  | PTU | EN  | M0))\
+	MUX_VAL(CP(GPMC_WAIT3),     (IEN  | PTU | EN  | M0))\
+	/* till here */							\
+	MUX_VAL(CP(GPMC_CLK),       (IDIS | PTD | DIS | M0)) /*GPMC_CLK*/\
+	MUX_VAL(CP(GPMC_nADV_ALE),  (IDIS | PTD | DIS | M0)) /*GPMC_nADV_ALE*/\
+	MUX_VAL(CP(GPMC_nOE),       (IDIS | PTD | DIS | M0)) /*GPMC_nOE*/\
+	MUX_VAL(CP(GPMC_nWE),       (IDIS | PTD | DIS | M0)) /*GPMC_nWE*/\
+	MUX_VAL(CP(GPMC_nBE0_CLE),  (IDIS | PTD | DIS | M0)) /*GPMC_nBE0_CLE*/\
+	MUX_VAL(CP(GPMC_nWP),       (IEN  | PTD | DIS | M0)) /*GPMC_nWP*/\
+	MUX_VAL(CP(GPMC_WAIT0),     (IEN  | PTU | EN  | M0)) /*GPMC_WAIT0*/\
+	MUX_VAL(CP(GPMC_WAIT1),     (IEN  | PTU | EN  | M0)) /*GPMC_WAIT1*/\
+	/*DSS*/\
+	MUX_VAL(CP(DSS_PCLK),       (IDIS | PTD | DIS | M0)) /*DSS_PCLK*/\
+	MUX_VAL(CP(DSS_HSYNC),      (IDIS | PTD | DIS | M0)) /*DSS_HSYNC*/\
+	MUX_VAL(CP(DSS_VSYNC),      (IDIS | PTD | DIS | M0)) /*DSS_VSYNC*/\
+	MUX_VAL(CP(DSS_ACBIAS),     (IDIS | PTD | DIS | M0)) /*DSS_ACBIAS*/\
+	MUX_VAL(CP(DSS_DATA0),      (IDIS | PTD | DIS | M0)) /*DSS_DATA0*/\
+	MUX_VAL(CP(DSS_DATA1),      (IDIS | PTD | DIS | M0)) /*DSS_DATA1*/\
+	MUX_VAL(CP(DSS_DATA2),      (IDIS | PTD | DIS | M0)) /*DSS_DATA2*/\
+	MUX_VAL(CP(DSS_DATA3),      (IDIS | PTD | DIS | M0)) /*DSS_DATA3*/\
+	MUX_VAL(CP(DSS_DATA4),      (IDIS | PTD | DIS | M0)) /*DSS_DATA4*/\
+	MUX_VAL(CP(DSS_DATA5),      (IDIS | PTD | DIS | M0)) /*DSS_DATA5*/\
+	MUX_VAL(CP(DSS_DATA6),      (IDIS | PTD | DIS | M0)) /*DSS_DATA6*/\
+	MUX_VAL(CP(DSS_DATA7),      (IDIS | PTD | DIS | M0)) /*DSS_DATA7*/\
+	MUX_VAL(CP(DSS_DATA8),      (IDIS | PTD | DIS | M0)) /*DSS_DATA8*/\
+	MUX_VAL(CP(DSS_DATA9),      (IDIS | PTD | DIS | M0)) /*DSS_DATA9*/\
+	MUX_VAL(CP(DSS_DATA10),     (IDIS | PTD | DIS | M0)) /*DSS_DATA10*/\
+	MUX_VAL(CP(DSS_DATA11),     (IDIS | PTD | DIS | M0)) /*DSS_DATA11*/\
+	MUX_VAL(CP(DSS_DATA12),     (IDIS | PTD | DIS | M0)) /*DSS_DATA12*/\
+	MUX_VAL(CP(DSS_DATA13),     (IDIS | PTD | DIS | M0)) /*DSS_DATA13*/\
+	MUX_VAL(CP(DSS_DATA14),     (IDIS | PTD | DIS | M0)) /*DSS_DATA14*/\
+	MUX_VAL(CP(DSS_DATA15),     (IDIS | PTD | DIS | M0)) /*DSS_DATA15*/\
+	MUX_VAL(CP(DSS_DATA16),     (IDIS | PTD | DIS | M0)) /*DSS_DATA16*/\
+	MUX_VAL(CP(DSS_DATA17),     (IDIS | PTD | DIS | M0)) /*DSS_DATA17*/\
+	MUX_VAL(CP(DSS_DATA18),     (IDIS | PTD | DIS | M0)) /*DSS_DATA18*/\
+	MUX_VAL(CP(DSS_DATA19),     (IDIS | PTD | DIS | M0)) /*DSS_DATA19*/\
+	MUX_VAL(CP(DSS_DATA20),     (IDIS | PTD | DIS | M0)) /*DSS_DATA20*/\
+	MUX_VAL(CP(DSS_DATA21),     (IDIS | PTD | DIS | M0)) /*DSS_DATA21*/\
+	MUX_VAL(CP(DSS_DATA22),     (IDIS | PTD | DIS | M0)) /*DSS_DATA22*/\
+	MUX_VAL(CP(DSS_DATA23),     (IDIS | PTD | DIS | M0)) /*DSS_DATA23*/\
+	/*CAMERA*/\
+	MUX_VAL(CP(CAM_HS),         (IEN  | PTU | EN  | M0)) /*CAM_HS */\
+	MUX_VAL(CP(CAM_VS),         (IEN  | PTU | EN  | M0)) /*CAM_VS */\
+	MUX_VAL(CP(CAM_XCLKA),      (IDIS | PTD | DIS | M0)) /*CAM_XCLKA*/\
+	MUX_VAL(CP(CAM_PCLK),       (IEN  | PTU | EN  | M0)) /*CAM_PCLK*/\
+	MUX_VAL(CP(CAM_FLD),        (IDIS | PTD | DIS | M4)) /*GPIO_98*/\
+							     /* - CAM_RESET*/\
+	MUX_VAL(CP(CAM_D0),         (IEN  | PTD | DIS | M0)) /*CAM_D0*/\
+	MUX_VAL(CP(CAM_D1),         (IEN  | PTD | DIS | M0)) /*CAM_D1*/\
+	MUX_VAL(CP(CAM_D2),         (IEN  | PTD | DIS | M0)) /*CAM_D2*/\
+	MUX_VAL(CP(CAM_D3),         (IEN  | PTD | DIS | M0)) /*CAM_D3*/\
+	MUX_VAL(CP(CAM_D4),         (IEN  | PTD | DIS | M0)) /*CAM_D4*/\
+	MUX_VAL(CP(CAM_D5),         (IEN  | PTD | DIS | M0)) /*CAM_D5*/\
+	MUX_VAL(CP(CAM_D6),         (IEN  | PTD | DIS | M0)) /*CAM_D6*/\
+	MUX_VAL(CP(CAM_D7),         (IEN  | PTD | DIS | M0)) /*CAM_D7*/\
+	MUX_VAL(CP(CAM_D8),         (IEN  | PTD | DIS | M0)) /*CAM_D8*/\
+	MUX_VAL(CP(CAM_D9),         (IEN  | PTD | DIS | M0)) /*CAM_D9*/\
+	MUX_VAL(CP(CAM_D10),        (IEN  | PTD | DIS | M0)) /*CAM_D10*/\
+	MUX_VAL(CP(CAM_D11),        (IEN  | PTD | DIS | M0)) /*CAM_D11*/\
+	MUX_VAL(CP(CAM_XCLKB),      (IDIS | PTD | DIS | M0)) /*CAM_XCLKB*/\
+	MUX_VAL(CP(CAM_WEN),        (IEN  | PTD | DIS | M4)) /*GPIO_167*/\
+	MUX_VAL(CP(CAM_STROBE),     (IDIS | PTD | DIS | M0)) /*CAM_STROBE*/\
+	MUX_VAL(CP(CSI2_DX0),       (IEN  | PTD | DIS | M0)) /*CSI2_DX0*/\
+	MUX_VAL(CP(CSI2_DY0),       (IEN  | PTD | DIS | M0)) /*CSI2_DY0*/\
+	MUX_VAL(CP(CSI2_DX1),       (IEN  | PTD | DIS | M0)) /*CSI2_DX1*/\
+	MUX_VAL(CP(CSI2_DY1),       (IEN  | PTD | DIS | M0)) /*CSI2_DY1*/\
+	/*Audio Interface */\
+	MUX_VAL(CP(McBSP2_FSX),     (IEN  | PTD | DIS | M0)) /*McBSP2_FSX*/\
+	MUX_VAL(CP(McBSP2_CLKX),    (IEN  | PTD | DIS | M0)) /*McBSP2_CLKX*/\
+	MUX_VAL(CP(McBSP2_DR),      (IEN  | PTD | DIS | M0)) /*McBSP2_DR*/\
+	MUX_VAL(CP(McBSP2_DX),      (IDIS | PTD | DIS | M0)) /*McBSP2_DX*/\
+	/*Expansion card  */\
+	MUX_VAL(CP(MMC1_CLK),       (IDIS | PTU | EN  | M0)) /*MMC1_CLK*/\
+	MUX_VAL(CP(MMC1_CMD),       (IEN  | PTU | EN  | M0)) /*MMC1_CMD*/\
+	MUX_VAL(CP(MMC1_DAT0),      (IEN  | PTU | EN  | M0)) /*MMC1_DAT0*/\
+	MUX_VAL(CP(MMC1_DAT1),      (IEN  | PTU | EN  | M0)) /*MMC1_DAT1*/\
+	MUX_VAL(CP(MMC1_DAT2),      (IEN  | PTU | EN  | M0)) /*MMC1_DAT2*/\
+	MUX_VAL(CP(MMC1_DAT3),      (IEN  | PTU | EN  | M0)) /*MMC1_DAT3*/\
+	MUX_VAL(CP(MMC1_DAT4),      (IEN  | PTU | EN  | M0)) /*MMC1_DAT4*/\
+	MUX_VAL(CP(MMC1_DAT5),      (IEN  | PTU | EN  | M0)) /*MMC1_DAT5*/\
+	MUX_VAL(CP(MMC1_DAT6),      (IEN  | PTU | EN  | M0)) /*MMC1_DAT6*/\
+	MUX_VAL(CP(MMC1_DAT7),      (IEN  | PTU | EN  | M0)) /*MMC1_DAT7*/\
+	/*Wireless LAN */\
+	MUX_VAL(CP(MMC2_CLK),       (IEN  | PTU | EN  | M4)) /*GPIO_130*/\
+	MUX_VAL(CP(MMC2_CMD),       (IEN  | PTU | EN  | M4)) /*GPIO_131*/\
+	MUX_VAL(CP(MMC2_DAT0),      (IEN  | PTU | EN  | M4)) /*GPIO_132*/\
+	MUX_VAL(CP(MMC2_DAT1),      (IEN  | PTU | EN  | M4)) /*GPIO_133*/\
+	MUX_VAL(CP(MMC2_DAT2),      (IEN  | PTU | EN  | M4)) /*GPIO_134*/\
+	MUX_VAL(CP(MMC2_DAT3),      (IEN  | PTU | EN  | M4)) /*GPIO_135*/\
+	MUX_VAL(CP(MMC2_DAT4),      (IEN  | PTU | EN  | M4)) /*GPIO_136*/\
+	MUX_VAL(CP(MMC2_DAT5),      (IEN  | PTU | EN  | M4)) /*GPIO_137*/\
+	MUX_VAL(CP(MMC2_DAT6),      (IEN  | PTU | EN  | M4)) /*GPIO_138*/\
+	MUX_VAL(CP(MMC2_DAT7),      (IEN  | PTU | EN  | M4)) /*GPIO_139*/\
+	/*Bluetooth*/\
+	MUX_VAL(CP(McBSP3_DX),      (IDIS | PTD | DIS | M4)) /*GPIO_140*/\
+	MUX_VAL(CP(McBSP3_DR),      (IDIS | PTD | DIS | M4)) /*GPIO_142*/\
+	MUX_VAL(CP(McBSP3_CLKX),    (IDIS | PTD | DIS | M4)) /*GPIO_141*/\
+	MUX_VAL(CP(McBSP3_FSX),     (IDIS | PTD | DIS | M4)) /*GPIO_143*/\
+	MUX_VAL(CP(UART2_CTS),      (IEN  | PTU | EN  | M0)) /*UART2_CTS*/\
+	MUX_VAL(CP(UART2_RTS),      (IDIS | PTD | DIS | M0)) /*UART2_RTS*/\
+	MUX_VAL(CP(UART2_TX),       (IDIS | PTD | DIS | M0)) /*UART2_TX*/\
+	MUX_VAL(CP(UART2_RX),       (IEN  | PTD | DIS | M0)) /*UART2_RX*/\
+	/*Modem Interface */\
+	MUX_VAL(CP(UART1_TX),       (IDIS | PTD | DIS | M0)) /*UART1_TX*/\
+	MUX_VAL(CP(UART1_RTS),      (IDIS | PTD | DIS | M4)) /*GPIO_149*/ \
+	MUX_VAL(CP(UART1_CTS),      (IDIS | PTD | DIS | M4)) /*GPIO_150*/ \
+	MUX_VAL(CP(UART1_RX),       (IEN  | PTD | DIS | M0)) /*UART1_RX*/\
+	MUX_VAL(CP(McBSP4_CLKX),    (IEN  | PTD | DIS | M1)) /*SSI1_DAT_RX*/\
+	MUX_VAL(CP(McBSP4_DR),      (IEN  | PTD | DIS | M1)) /*SSI1_FLAG_RX*/\
+	MUX_VAL(CP(McBSP4_DX),      (IEN  | PTD | DIS | M1)) /*SSI1_RDY_RX*/\
+	MUX_VAL(CP(McBSP4_FSX),     (IEN  | PTD | DIS | M1)) /*SSI1_WAKE*/\
+	MUX_VAL(CP(McBSP1_CLKR),    (IDIS | PTD | DIS | M4)) /*GPIO_156*/\
+	MUX_VAL(CP(McBSP1_FSR),     (IDIS | PTU | EN  | M4)) /*GPIO_157*/\
+							     /* - BT_WAKEUP*/\
+	MUX_VAL(CP(McBSP1_DX),      (IDIS | PTD | DIS | M4)) /*GPIO_158*/\
+	MUX_VAL(CP(McBSP1_DR),      (IDIS | PTD | DIS | M4)) /*GPIO_159*/\
+	MUX_VAL(CP(McBSP_CLKS),     (IEN  | PTU | DIS | M0)) /*McBSP_CLKS*/\
+	MUX_VAL(CP(McBSP1_FSX),     (IDIS | PTD | DIS | M4)) /*GPIO_161*/\
+	MUX_VAL(CP(McBSP1_CLKX),    (IDIS | PTD | DIS | M4)) /*GPIO_162*/\
+	/*Serial Interface*/\
+	MUX_VAL(CP(UART3_CTS_RCTX), (IEN  | PTD | EN  | M0)) /*UART3_CTS_*/\
+							     /* RCTX*/\
+	MUX_VAL(CP(UART3_RTS_SD),   (IDIS | PTD | DIS | M0)) /*UART3_RTS_SD */\
+	MUX_VAL(CP(UART3_RX_IRRX),  (IEN  | PTD | DIS | M0)) /*UART3_RX_IRRX*/\
+	MUX_VAL(CP(UART3_TX_IRTX),  (IDIS | PTD | DIS | M0)) /*UART3_TX_IRTX*/\
+	MUX_VAL(CP(HSUSB0_CLK),     (IEN  | PTD | DIS | M0)) /*HSUSB0_CLK*/\
+	MUX_VAL(CP(HSUSB0_STP),     (IDIS | PTU | EN  | M0)) /*HSUSB0_STP*/\
+	MUX_VAL(CP(HSUSB0_DIR),     (IEN  | PTD | DIS | M0)) /*HSUSB0_DIR*/\
+	MUX_VAL(CP(HSUSB0_NXT),     (IEN  | PTD | DIS | M0)) /*HSUSB0_NXT*/\
+	MUX_VAL(CP(HSUSB0_DATA0),   (IEN  | PTD | DIS | M0)) /*HSUSB0_DATA0*/\
+	MUX_VAL(CP(HSUSB0_DATA1),   (IEN  | PTD | DIS | M0)) /*HSUSB0_DATA1*/\
+	MUX_VAL(CP(HSUSB0_DATA2),   (IEN  | PTD | DIS | M0)) /*HSUSB0_DATA2*/\
+	MUX_VAL(CP(HSUSB0_DATA3),   (IEN  | PTD | DIS | M0)) /*HSUSB0_DATA3*/\
+	MUX_VAL(CP(HSUSB0_DATA4),   (IEN  | PTD | DIS | M0)) /*HSUSB0_DATA4*/\
+	MUX_VAL(CP(HSUSB0_DATA5),   (IEN  | PTD | DIS | M0)) /*HSUSB0_DATA5*/\
+	MUX_VAL(CP(HSUSB0_DATA6),   (IEN  | PTD | DIS | M0)) /*HSUSB0_DATA6*/\
+	MUX_VAL(CP(HSUSB0_DATA7),   (IEN  | PTD | DIS | M0)) /*HSUSB0_DATA7*/\
+	MUX_VAL(CP(I2C1_SCL),       (IEN  | PTU | EN  | M0)) /*I2C1_SCL*/\
+	MUX_VAL(CP(I2C1_SDA),       (IEN  | PTU | EN  | M0)) /*I2C1_SDA*/\
+	MUX_VAL(CP(I2C2_SCL),       (IEN  | PTU | EN  | M0)) /*I2C2_SCL*/\
+	MUX_VAL(CP(I2C2_SDA),       (IEN  | PTU | EN  | M0)) /*I2C2_SDA*/\
+	MUX_VAL(CP(I2C3_SCL),       (IEN  | PTU | EN  | M0)) /*I2C3_SCL*/\
+	MUX_VAL(CP(I2C3_SDA),       (IEN  | PTU | EN  | M0)) /*I2C3_SDA*/\
+	MUX_VAL(CP(I2C4_SCL),       (IEN  | PTU | EN  | M0)) /*I2C4_SCL*/\
+	MUX_VAL(CP(I2C4_SDA),       (IEN  | PTU | EN  | M0)) /*I2C4_SDA*/\
+	MUX_VAL(CP(HDQ_SIO),        (IDIS | PTU | EN  | M4)) /*HDQ_SIO*/\
+	MUX_VAL(CP(McSPI1_CLK),     (IEN  | PTD | DIS | M0)) /*McSPI1_CLK*/\
+	MUX_VAL(CP(McSPI1_SIMO),    (IEN  | PTD | DIS | M0)) /*McSPI1_SIMO  */\
+	MUX_VAL(CP(McSPI1_SOMI),    (IEN  | PTD | DIS | M0)) /*McSPI1_SOMI  */\
+	MUX_VAL(CP(McSPI1_CS0),     (IEN  | PTD | EN  | M0)) /*McSPI1_CS0*/\
+	MUX_VAL(CP(McSPI1_CS1),     (IDIS | PTD | EN  | M0)) /*McSPI1_CS1*/\
+	MUX_VAL(CP(McSPI1_CS2),     (IDIS | PTD | DIS | M4)) /*GPIO_176*/\
+							     /* - NOR_DPD*/\
+	MUX_VAL(CP(McSPI1_CS3),     (IEN  | PTD | EN  | M0)) /*McSPI1_CS3*/\
+	MUX_VAL(CP(McSPI2_CLK),     (IEN  | PTD | DIS | M0)) /*McSPI2_CLK*/\
+	MUX_VAL(CP(McSPI2_SIMO),    (IEN  | PTD | DIS | M0)) /*McSPI2_SIMO*/\
+	MUX_VAL(CP(McSPI2_SOMI),    (IEN  | PTD | DIS | M0)) /*McSPI2_SOMI*/\
+	MUX_VAL(CP(McSPI2_CS0),     (IEN  | PTD | EN  | M0)) /*McSPI2_CS0*/\
+	MUX_VAL(CP(McSPI2_CS1),     (IEN  | PTD | EN  | M0)) /*McSPI2_CS1*/\
+	/*Control and debug */\
+	MUX_VAL(CP(SYS_32K),        (IEN  | PTD | DIS | M0)) /*SYS_32K*/\
+	MUX_VAL(CP(SYS_CLKREQ),     (IEN  | PTD | DIS | M0)) /*SYS_CLKREQ*/\
+	MUX_VAL(CP(SYS_nIRQ),       (IEN  | PTU | EN  | M0)) /*SYS_nIRQ*/\
+	MUX_VAL(CP(SYS_BOOT0),      (IEN  | PTD | DIS | M4)) /*GPIO_2*/\
+							     /* - PEN_IRQ */\
+	MUX_VAL(CP(SYS_BOOT1),      (IEN  | PTD | DIS | M4)) /*GPIO_3 */\
+	MUX_VAL(CP(SYS_BOOT2),      (IEN  | PTD | DIS | M4)) /*GPIO_4*/\
+							     /* - MMC1_WP */\
+	MUX_VAL(CP(SYS_BOOT3),      (IEN  | PTD | DIS | M4)) /*GPIO_5*/\
+							     /* - LCD_ENVDD*/\
+	MUX_VAL(CP(SYS_BOOT4),      (IEN  | PTD | DIS | M4)) /*GPIO_6*/\
+							     /* - LAN_INTR0*/\
+	MUX_VAL(CP(SYS_BOOT5),      (IEN  | PTD | DIS | M4)) /*GPIO_7*/\
+							     /* - MMC2_WP*/\
+	MUX_VAL(CP(SYS_BOOT6),      (IDIS  | PTD | DIS | M4)) /*GPIO_8*/\
+							     /* - LCD_ENBKL*/\
+	MUX_VAL(CP(SYS_OFF_MODE),   (IEN  | PTD | DIS | M0)) /*SYS_OFF_MODE*/\
+	MUX_VAL(CP(SYS_CLKOUT1),    (IEN  | PTD | DIS | M0)) /*SYS_CLKOUT1*/\
+	MUX_VAL(CP(SYS_CLKOUT2),    (IEN  | PTU | EN  | M4)) /*GPIO_186*/\
+	MUX_VAL(CP(ETK_CLK_ES2),    (IDIS | PTU | EN  | M3)) /*HSUSB1_STP*/\
+	MUX_VAL(CP(ETK_CTL_ES2),    (IDIS | PTD | DIS | M3)) /*HSUSB1_CLK*/\
+	MUX_VAL(CP(ETK_D0_ES2),     (IEN  | PTD | DIS | M3)) /*HSUSB1_DATA0*/\
+	MUX_VAL(CP(ETK_D1_ES2),     (IEN  | PTD | DIS | M3)) /*HSUSB1_DATA1*/\
+	MUX_VAL(CP(ETK_D2_ES2),     (IEN  | PTD | DIS | M3)) /*HSUSB1_DATA2*/\
+	MUX_VAL(CP(ETK_D3_ES2),     (IEN  | PTD | DIS | M3)) /*HSUSB1_DATA7*/\
+	MUX_VAL(CP(ETK_D4_ES2),     (IEN  | PTD | DIS | M3)) /*HSUSB1_DATA4*/\
+	MUX_VAL(CP(ETK_D5_ES2),     (IEN  | PTD | DIS | M3)) /*HSUSB1_DATA5*/\
+	MUX_VAL(CP(ETK_D6_ES2),     (IEN  | PTD | DIS | M3)) /*HSUSB1_DATA6*/\
+	MUX_VAL(CP(ETK_D7_ES2),     (IEN  | PTD | DIS | M3)) /*HSUSB1_DATA3*/\
+	MUX_VAL(CP(ETK_D8_ES2),     (IEN  | PTD | DIS | M3)) /*HSUSB1_DIR*/\
+	MUX_VAL(CP(ETK_D9_ES2),     (IEN  | PTD | DIS | M3)) /*HSUSB1_NXT*/\
+	MUX_VAL(CP(ETK_D10_ES2),    (IDIS | PTU | EN  | M4)) /*GPIO_24*/\
+	MUX_VAL(CP(ETK_D15),        (IEN  | PTU | EN  | M4)) /*GPIO_29*/\
+	MUX_VAL(CP(d2d_mcad1),      (IEN  | PTD | EN  | M0)) /*d2d_mcad1*/\
+	MUX_VAL(CP(d2d_mcad2),      (IEN  | PTD | EN  | M0)) /*d2d_mcad2*/\
+	MUX_VAL(CP(d2d_mcad3),      (IEN  | PTD | EN  | M0)) /*d2d_mcad3*/\
+	MUX_VAL(CP(d2d_mcad4),      (IEN  | PTD | EN  | M0)) /*d2d_mcad4*/\
+	MUX_VAL(CP(d2d_mcad5),      (IEN  | PTD | EN  | M0)) /*d2d_mcad5*/\
+	MUX_VAL(CP(d2d_mcad6),      (IEN  | PTD | EN  | M0)) /*d2d_mcad6*/\
+	MUX_VAL(CP(d2d_mcad7),      (IEN  | PTD | EN  | M0)) /*d2d_mcad7*/\
+	MUX_VAL(CP(d2d_mcad8),      (IEN  | PTD | EN  | M0)) /*d2d_mcad8*/\
+	MUX_VAL(CP(d2d_mcad9),      (IEN  | PTD | EN  | M0)) /*d2d_mcad9*/\
+	MUX_VAL(CP(d2d_mcad10),     (IEN  | PTD | EN  | M0)) /*d2d_mcad10*/\
+	MUX_VAL(CP(d2d_mcad11),     (IEN  | PTD | EN  | M0)) /*d2d_mcad11*/\
+	MUX_VAL(CP(d2d_mcad12),     (IEN  | PTD | EN  | M0)) /*d2d_mcad12*/\
+	MUX_VAL(CP(d2d_mcad13),     (IEN  | PTD | EN  | M0)) /*d2d_mcad13*/\
+	MUX_VAL(CP(d2d_mcad14),     (IEN  | PTD | EN  | M0)) /*d2d_mcad14*/\
+	MUX_VAL(CP(d2d_mcad15),     (IEN  | PTD | EN  | M0)) /*d2d_mcad15*/\
+	MUX_VAL(CP(d2d_mcad16),     (IEN  | PTD | EN  | M0)) /*d2d_mcad16*/\
+	MUX_VAL(CP(d2d_mcad17),     (IEN  | PTD | EN  | M0)) /*d2d_mcad17*/\
+	MUX_VAL(CP(d2d_mcad18),     (IEN  | PTD | EN  | M0)) /*d2d_mcad18*/\
+	MUX_VAL(CP(d2d_mcad19),     (IEN  | PTD | EN  | M0)) /*d2d_mcad19*/\
+	MUX_VAL(CP(d2d_mcad20),     (IEN  | PTD | EN  | M0)) /*d2d_mcad20*/\
+	MUX_VAL(CP(d2d_mcad21),     (IEN  | PTD | EN  | M0)) /*d2d_mcad21*/\
+	MUX_VAL(CP(d2d_mcad22),     (IEN  | PTD | EN  | M0)) /*d2d_mcad22*/\
+	MUX_VAL(CP(d2d_mcad23),     (IEN  | PTD | EN  | M0)) /*d2d_mcad23*/\
+	MUX_VAL(CP(d2d_mcad24),     (IEN  | PTD | EN  | M0)) /*d2d_mcad24*/\
+	MUX_VAL(CP(d2d_mcad25),     (IEN  | PTD | EN  | M0)) /*d2d_mcad25*/\
+	MUX_VAL(CP(d2d_mcad26),     (IEN  | PTD | EN  | M0)) /*d2d_mcad26*/\
+	MUX_VAL(CP(d2d_mcad27),     (IEN  | PTD | EN  | M0)) /*d2d_mcad27*/\
+	MUX_VAL(CP(d2d_mcad28),     (IEN  | PTD | EN  | M0)) /*d2d_mcad28*/\
+	MUX_VAL(CP(d2d_mcad29),     (IEN  | PTD | EN  | M0)) /*d2d_mcad29*/\
+	MUX_VAL(CP(d2d_mcad30),     (IEN  | PTD | EN  | M0)) /*d2d_mcad30*/\
+	MUX_VAL(CP(d2d_mcad31),     (IEN  | PTD | EN  | M0)) /*d2d_mcad31*/\
+	MUX_VAL(CP(d2d_mcad32),     (IEN  | PTD | EN  | M0)) /*d2d_mcad32*/\
+	MUX_VAL(CP(d2d_mcad33),     (IEN  | PTD | EN  | M0)) /*d2d_mcad33*/\
+	MUX_VAL(CP(d2d_mcad34),     (IEN  | PTD | EN  | M0)) /*d2d_mcad34*/\
+	MUX_VAL(CP(d2d_mcad35),     (IEN  | PTD | EN  | M0)) /*d2d_mcad35*/\
+	MUX_VAL(CP(d2d_mcad36),     (IEN  | PTD | EN  | M0)) /*d2d_mcad36*/\
+	MUX_VAL(CP(d2d_clk26mi),    (IEN  | PTD | DIS | M0)) /*d2d_clk26mi*/\
+	MUX_VAL(CP(d2d_nrespwron),  (IEN  | PTD | EN  | M0)) /*d2d_nrespwron*/\
+	MUX_VAL(CP(d2d_nreswarm),   (IEN  | PTU | EN  | M0)) /*d2d_nreswarm */\
+	MUX_VAL(CP(d2d_arm9nirq),   (IEN  | PTD | DIS | M0)) /*d2d_arm9nirq */\
+	MUX_VAL(CP(d2d_uma2p6fiq),  (IEN  | PTD | DIS | M0)) /*d2d_uma2p6fiq*/\
+	MUX_VAL(CP(d2d_spint),      (IEN  | PTD | EN  | M0)) /*d2d_spint*/\
+	MUX_VAL(CP(d2d_frint),      (IEN  | PTD | EN  | M0)) /*d2d_frint*/\
+	MUX_VAL(CP(d2d_dmareq0),    (IEN  | PTD | DIS | M0)) /*d2d_dmareq0*/\
+	MUX_VAL(CP(d2d_dmareq1),    (IEN  | PTD | DIS | M0)) /*d2d_dmareq1*/\
+	MUX_VAL(CP(d2d_dmareq2),    (IEN  | PTD | DIS | M0)) /*d2d_dmareq2*/\
+	MUX_VAL(CP(d2d_dmareq3),    (IEN  | PTD | DIS | M0)) /*d2d_dmareq3*/\
+	MUX_VAL(CP(d2d_n3gtrst),    (IEN  | PTD | DIS | M0)) /*d2d_n3gtrst*/\
+	MUX_VAL(CP(d2d_n3gtdi),     (IEN  | PTD | DIS | M0)) /*d2d_n3gtdi*/\
+	MUX_VAL(CP(d2d_n3gtdo),     (IEN  | PTD | DIS | M0)) /*d2d_n3gtdo*/\
+	MUX_VAL(CP(d2d_n3gtms),     (IEN  | PTD | DIS | M0)) /*d2d_n3gtms*/\
+	MUX_VAL(CP(d2d_n3gtck),     (IEN  | PTD | DIS | M0)) /*d2d_n3gtck*/\
+	MUX_VAL(CP(d2d_n3grtck),    (IEN  | PTD | DIS | M0)) /*d2d_n3grtck*/\
+	MUX_VAL(CP(d2d_mstdby),     (IEN  | PTU | EN  | M0)) /*d2d_mstdby*/\
+	MUX_VAL(CP(d2d_swakeup),    (IEN  | PTD | EN  | M0)) /*d2d_swakeup*/\
+	MUX_VAL(CP(d2d_idlereq),    (IEN  | PTD | DIS | M0)) /*d2d_idlereq*/\
+	MUX_VAL(CP(d2d_idleack),    (IEN  | PTU | EN  | M0)) /*d2d_idleack*/\
+	MUX_VAL(CP(d2d_mwrite),     (IEN  | PTD | DIS | M0)) /*d2d_mwrite*/\
+	MUX_VAL(CP(d2d_swrite),     (IEN  | PTD | DIS | M0)) /*d2d_swrite*/\
+	MUX_VAL(CP(d2d_mread),      (IEN  | PTD | DIS | M0)) /*d2d_mread*/\
+	MUX_VAL(CP(d2d_sread),      (IEN  | PTD | DIS | M0)) /*d2d_sread*/\
+	MUX_VAL(CP(d2d_mbusflag),   (IEN  | PTD | DIS | M0)) /*d2d_mbusflag*/\
+	MUX_VAL(CP(d2d_sbusflag),   (IEN  | PTD | DIS | M0)) /*d2d_sbusflag*/\
+	MUX_VAL(CP(sdrc_cke0),      (IDIS | PTU | EN  | M0)) /*sdrc_cke0*/\
+	MUX_VAL(CP(sdrc_cke1),      (IDIS | PTD | DIS | M7)) /*sdrc_cke1*/\
+							     /* - not used */
+#endif
diff --git a/include/asm-arm/arch-omap3/omap3.h b/include/asm-arm/arch-omap3/omap3.h
new file mode 100644
index 0000000..095bb29
--- /dev/null
+++ b/include/asm-arm/arch-omap3/omap3.h
@@ -0,0 +1,131 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ * Syed Mohammed Khasim <x0khasim@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _OMAP3_H_
+#define _OMAP3_H_
+
+/* Stuff on L3 Interconnect */
+#define SMX_APE_BASE			0x68000000
+
+/* GPMC */
+#define OMAP34XX_GPMC_BASE		(0x6E000000)
+
+/* SMS */
+#define OMAP34XX_SMS_BASE		0x6C000000
+
+/* SDRC */
+#define OMAP34XX_SDRC_BASE		0x6D000000
+
+/*
+ * L4 Peripherals - L4 Wakeup and L4 Core now
+ */
+#define OMAP34XX_CORE_L4_IO_BASE	0x48000000
+#define OMAP34XX_WAKEUP_L4_IO_BASE	0x48300000
+#define OMAP34XX_L4_PER			0x49000000
+#define OMAP34XX_L4_IO_BASE		OMAP34XX_CORE_L4_IO_BASE
+
+/* CONTROL */
+#define OMAP34XX_CTRL_BASE		(OMAP34XX_L4_IO_BASE+0x2000)
+
+/* UART */
+#define OMAP34XX_UART1			(OMAP34XX_L4_IO_BASE+0x6a000)
+#define OMAP34XX_UART2			(OMAP34XX_L4_IO_BASE+0x6c000)
+#define OMAP34XX_UART3			(OMAP34XX_L4_PER+0x20000)
+
+/* General Purpose Timers */
+#define OMAP34XX_GPT1			0x48318000
+#define OMAP34XX_GPT2			0x49032000
+#define OMAP34XX_GPT3			0x49034000
+#define OMAP34XX_GPT4			0x49036000
+#define OMAP34XX_GPT5			0x49038000
+#define OMAP34XX_GPT6			0x4903A000
+#define OMAP34XX_GPT7			0x4903C000
+#define OMAP34XX_GPT8			0x4903E000
+#define OMAP34XX_GPT9			0x49040000
+#define OMAP34XX_GPT10			0x48086000
+#define OMAP34XX_GPT11			0x48088000
+#define OMAP34XX_GPT12			0x48304000
+
+/* WatchDog Timers (1 secure, 3 GP) */
+#define WD1_BASE			(0x4830C000)
+#define WD2_BASE			(0x48314000)
+#define WD3_BASE			(0x49030000)
+
+/* 32KTIMER */
+#define SYNC_32KTIMER_BASE		(0x48320000)
+#define S32K_CR				(SYNC_32KTIMER_BASE+0x10)
+
+/* omap3 GPIO registers */
+#define OMAP34XX_GPIO1_BASE		0x48310000
+#define OMAP34XX_GPIO2_BASE		0x49050000
+#define OMAP34XX_GPIO3_BASE		0x49052000
+#define OMAP34XX_GPIO4_BASE		0x49054000
+#define OMAP34XX_GPIO5_BASE		0x49056000
+#define OMAP34XX_GPIO6_BASE		0x49058000
+
+/* base address for indirect vectors (internal boot mode) */
+#define SRAM_OFFSET0			0x40000000
+#define SRAM_OFFSET1			0x00200000
+#define SRAM_OFFSET2			0x0000F800
+#define SRAM_VECT_CODE			(SRAM_OFFSET0|SRAM_OFFSET1|\
+					 SRAM_OFFSET2)
+
+#define LOW_LEVEL_SRAM_STACK		0x4020FFFC
+
+#define DEBUG_LED1			149	/* gpio */
+#define DEBUG_LED2			150	/* gpio */
+
+#define XDR_POP		5	/* package on package part */
+#define SDR_DISCRETE	4	/* 128M memory SDR module */
+#define DDR_STACKED	3	/* stacked part on 2422 */
+#define DDR_COMBO	2	/* combo part on cpu daughter card */
+#define DDR_DISCRETE	1	/* 2x16 parts on daughter card */
+
+#define DDR_100		100	/* type found on most mem d-boards */
+#define DDR_111		111	/* some combo parts */
+#define DDR_133		133	/* most combo, some mem d-boards */
+#define DDR_165		165	/* future parts */
+
+#define CPU_3430	0x3430
+
+/* 343x real hardware:
+ *  ES1     = rev 0
+ */
+
+/* 343x code defines:
+ * ES1     = 0+1 = 1
+ * ES1     = 1+1 = 1
+ */
+#define CPU_3430_ES1		1
+#define CPU_3430_ES2		2
+
+#define WIDTH_8BIT		0x0000
+#define WIDTH_16BIT		0x1000	/* bit pos for 16 bit in gpmc */
+
+/* SDP definitions according to FPGA Rev. Is this OK?? */
+#define SDP_3430_V1		0x1
+#define SDP_3430_V2		0x2
+
+#endif
diff --git a/include/asm-arm/arch-omap3/sys_proto.h b/include/asm-arm/arch-omap3/sys_proto.h
new file mode 100644
index 0000000..271b554
--- /dev/null
+++ b/include/asm-arm/arch-omap3/sys_proto.h
@@ -0,0 +1,64 @@
+/*
+ * (C) Copyright 2004-2008
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+  */
+#ifndef _SYS_PROTO_H_
+#define _SYS_PROTO_H_
+
+void prcm_init(void);
+void per_clocks_enable(void);
+
+void memif_init(void);
+void sdrc_init(void);
+void do_sdrc_init(u32, u32);
+void gpmc_init(void);
+
+void watchdog_init(void);
+void set_muxconf_regs(void);
+
+u32 get_cpu_type(void);
+u32 get_cpu_rev(void);
+u32 get_mem_type(void);
+u32 get_sysboot_value(void);
+u32 get_gpmc0_base(void);
+u32 is_gpmc_muxed(void);
+u32 get_gpmc0_type(void);
+u32 get_gpmc0_width(void);
+u32 get_board_type(void);
+void display_board_info(u32);
+u32 get_sdr_cs_size(u32 offset);
+u32 running_in_sdram(void);
+u32 running_in_sram(void);
+u32 running_in_flash(void);
+u32 running_from_internal_boot(void);
+u32 get_device_type(void);
+void l2cache_enable(void);
+void secureworld_exit(void);
+void setup_auxcr(void);
+void try_unlock_memory(void);
+u32 get_boot_type(void);
+void audio_init(void);
+void dss_init(void);
+void arm_cache_flush(void);
+void v7_flush_dcache_all(u32);
+void sr32(u32 addr, u32 start_bit, u32 num_bits, u32 value);
+u32 wait_on_value(u32 read_bit_mask, u32 match_value, u32 read_addr, u32 bound);
+void sdelay(unsigned long loops);
+
+#endif
diff --git a/include/configs/omap3530beagle.h b/include/configs/omap3530beagle.h
new file mode 100644
index 0000000..20efbf3
--- /dev/null
+++ b/include/configs/omap3530beagle.h
@@ -0,0 +1,292 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments.
+ * Richard Woodruff <r-woodruff2@ti.com>
+ * Syed Mohammed Khasim <x0khasim@ti.com>
+ *
+ * Configuration settings for the TI OMAP3530 Beagle board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+#include <asm/sizes.h>
+
+/*
+ * High Level Configuration Options
+ */
+#define CONFIG_ARMCORTEXA8	1	/* This is an ARM V7 CPU core */
+#define CONFIG_OMAP		1	/* in a TI OMAP core */
+#define CONFIG_OMAP34XX		1	/* which is a 34XX */
+#define CONFIG_OMAP3430		1	/* which is in a 3430 */
+#define CONFIG_OMAP3_BEAGLE	1	/* working with BEAGLE */
+#define CONFIG_DOS_PARTITION	1
+
+#include <asm/arch/cpu.h>	/* get chip and board defs */
+#include <asm/arch/omap3.h>
+
+/* Clock Defines */
+#define V_OSCK                   26000000	/* Clock output from T2 */
+#define V_SCLK                   (V_OSCK >> 1)
+
+#undef CONFIG_USE_IRQ		/* no support for IRQs */
+#define CONFIG_MISC_INIT_R
+
+#define CONFIG_CMDLINE_TAG       1	/* enable passing of ATAGs */
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG        1
+#define CONFIG_REVISION_TAG      1
+
+/*
+ * Size of malloc() pool
+ */
+#define CFG_ENV_SIZE             SZ_128K /* Total Size Environment Sector */
+#define CFG_MALLOC_LEN           (CFG_ENV_SIZE + SZ_128K)
+#define CFG_GBL_DATA_SIZE        128	 /* bytes reserved for initial data */
+
+/*
+ * Hardware drivers
+ */
+
+/*
+ * NS16550 Configuration
+ */
+#define V_NS16550_CLK            (48000000)	/* 48MHz (APLL96/2) */
+
+#define CFG_NS16550
+#define CFG_NS16550_SERIAL
+#define CFG_NS16550_REG_SIZE     (-4)
+#define CFG_NS16550_CLK          V_NS16550_CLK
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_CONS_INDEX        3
+#define CFG_NS16550_COM3         OMAP34XX_UART3
+#define CONFIG_SERIAL3           3	/* UART3 on Beagle Rev 2 */
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_BAUDRATE          115200
+#define CFG_BAUDRATE_TABLE       {4800, 9600, 19200, 38400, 57600, 115200}
+#define CONFIG_MMC		1
+#define CFG_MMC_BASE		0xF0000000
+#define CONFIG_DOS_PARTITION	1
+
+/* commands to include */
+
+#define CONFIG_CMD_EXT2		/* EXT2 Support			*/
+#define CONFIG_CMD_FAT		/* FAT support			*/
+#define CONFIG_CMD_JFFS2	/* JFFS2 Support		*/
+
+#define CONFIG_CMD_I2C		/* I2C serial bus support	*/
+#define CONFIG_CMD_MMC		/* MMC support			*/
+#define CONFIG_CMD_NAND		/* NAND support			*/
+
+#define CONFIG_CMD_AUTOSCRIPT	/* autoscript support		*/
+#define CONFIG_CMD_BDI		/* bdinfo			*/
+#define CONFIG_CMD_BOOTD	/* bootd			*/
+#define CONFIG_CMD_CONSOLE	/* coninfo			*/
+#define CONFIG_CMD_ECHO		/* echo arguments		*/
+#define CONFIG_CMD_ENV		/* saveenv			*/
+#define CONFIG_CMD_ITEST	/* Integer (and string) test	*/
+#define CONFIG_CMD_LOADB	/* loadb			*/
+#define CONFIG_CMD_MEMORY	/* md mm nm mw cp cmp crc base loop mtest */
+#define CONFIG_CMD_MISC		/* misc functions like sleep etc*/
+#define CONFIG_CMD_RUN		/* run command in env variable	*/
+
+#define CFG_NO_FLASH
+#define CFG_I2C_SPEED            100
+#define CFG_I2C_SLAVE            1
+#define CFG_I2C_BUS              0
+#define CFG_I2C_BUS_SELECT       1
+#define CONFIG_DRIVER_OMAP34XX_I2C 1
+
+/*
+ *  Board NAND Info.
+ */
+#define CFG_NAND_ADDR NAND_BASE	/* physical address to access nand */
+#define CFG_NAND_BASE NAND_BASE	/* physical address to access nand at CS0 */
+#define CFG_NAND_WIDTH_16
+
+#define CFG_MAX_NAND_DEVICE      1	/* Max number of NAND devices */
+#define SECTORSIZE               512
+
+#define NAND_ALLOW_ERASE_ALL
+#define ADDR_COLUMN              1
+#define ADDR_PAGE                2
+#define ADDR_COLUMN_PAGE         3
+
+#define NAND_ChipID_UNKNOWN      0x00
+#define NAND_MAX_FLOORS          1
+#define NAND_MAX_CHIPS           1
+#define NAND_NO_RB               1
+#define CFG_NAND_WP
+
+#define CONFIG_JFFS2_NAND
+/* nand device jffs2 lives on */
+#define CONFIG_JFFS2_DEV		"nand0"
+/* start of jffs2 partition */
+#define CONFIG_JFFS2_PART_OFFSET	0x680000
+#define CONFIG_JFFS2_PART_SIZE 	0xf980000	/* size of jffs2 partition */
+
+/* Environment information */
+#define CONFIG_BOOTDELAY         10
+
+#define CONFIG_BOOTCOMMAND "nand read 80200000 280000 400000 ; bootm 80200000"
+
+#define CONFIG_BOOTARGS "setenv bootargs console=ttyS2,115200n8 noinitrd root=/dev/mtdblock4 rw rootfstype=jffs2"
+
+#define CONFIG_NETMASK           255.255.254.0
+#define CONFIG_IPADDR            128.247.77.90
+#define CONFIG_SERVERIP          128.247.77.158
+#define CONFIG_BOOTFILE          "uImage"
+#define CONFIG_AUTO_COMPLETE     1
+/*
+ * Miscellaneous configurable options
+ */
+#define V_PROMPT                 "OMAP3 beagleboard.org # "
+
+#define CFG_LONGHELP		/* undef to save memory */
+#define CFG_PROMPT               V_PROMPT
+#define CFG_CBSIZE               256	/* Console I/O Buffer Size */
+/* Print Buffer Size */
+#define CFG_PBSIZE               (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)
+#define CFG_MAXARGS              16	/* max number of command args */
+#define CFG_BARGSIZE             CFG_CBSIZE	/* Boot Argument Buffer Size */
+
+#define CFG_MEMTEST_START        (OMAP34XX_SDRC_CS0)	/* memtest works on */
+#define CFG_MEMTEST_END          (OMAP34XX_SDRC_CS0+0x01F00000) /* 31MB */
+
+#undef	CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CFG_LOAD_ADDR            (OMAP34XX_SDRC_CS0) /* default load address */
+
+/* 2430 has 12 GP timers, they can be driven by the SysClk (12/13/19.2) or by
+ * 32KHz clk, or from external sig. This rate is divided by a local divisor.
+ */
+#define V_PVT                    7
+
+#define CFG_TIMERBASE            OMAP34XX_GPT2
+#define CFG_PVT                  V_PVT	/* 2^(pvt+1) */
+#define CFG_HZ                   ((V_SCLK)/(2 << CFG_PVT))
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	SZ_128K	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	SZ_4K	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	SZ_4K	/* FIQ stack */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	2	/* CS1 may or may not be populated */
+#define PHYS_SDRAM_1		OMAP34XX_SDRC_CS0
+#define PHYS_SDRAM_1_SIZE	SZ_32M	/* at least 32 meg */
+#define PHYS_SDRAM_2		OMAP34XX_SDRC_CS1
+
+/* SDRAM Bank Allocation method */
+#define SDRC_R_B_C		1
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+
+/* **** PISMO SUPPORT *** */
+
+/* Configure the PISMO */
+#define PISMO1_NOR_SIZE_SDPV2	GPMC_SIZE_128M
+#define PISMO1_NOR_SIZE		GPMC_SIZE_64M
+
+#define PISMO1_NAND_SIZE	GPMC_SIZE_128M
+#define PISMO1_ONEN_SIZE	GPMC_SIZE_128M
+#define DBG_MPDB_SIZE		GPMC_SIZE_16M
+#define PISMO2_SIZE		0
+
+#define CFG_MAX_FLASH_SECT	(520)	/* max number of sectors on one chip */
+#define CFG_MAX_FLASH_BANKS      2	/* max number of flash banks */
+#define CFG_MONITOR_LEN		SZ_256K	/* Reserve 2 sectors */
+
+#define PHYS_FLASH_SIZE_SDPV2	SZ_128M
+#define PHYS_FLASH_SIZE		SZ_32M
+
+#define CFG_FLASH_BASE		boot_flash_base
+#define PHYS_FLASH_SECT_SIZE	boot_flash_sec
+/* Dummy declaration of flash banks to get compilation right */
+#define CFG_FLASH_BANKS_LIST	{0, 0}
+
+#define CFG_MONITOR_BASE	CFG_FLASH_BASE	/* Monitor at start of flash */
+#define CFG_ONENAND_BASE	ONENAND_MAP
+
+#define CFG_ENV_IS_IN_NAND	1
+#define ONENAND_ENV_OFFSET	0x260000	/* environment starts here  */
+#define SMNAND_ENV_OFFSET	0x260000	/* environment starts here  */
+
+#define CFG_ENV_SECT_SIZE	boot_flash_sec
+#define CFG_ENV_OFFSET		boot_flash_off
+#define CFG_ENV_ADDR		SMNAND_ENV_OFFSET
+
+/*-----------------------------------------------------------------------
+ * CFI FLASH driver setup
+ */
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(100*CFG_HZ)	/* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(100*CFG_HZ)	/* Timeout for Flash Write */
+
+/* Flash banks JFFS2 should use */
+#define CFG_MAX_MTD_BANKS	(CFG_MAX_FLASH_BANKS+CFG_MAX_NAND_DEVICE)
+#define CFG_JFFS2_MEM_NAND
+#define CFG_JFFS2_FIRST_BANK	CFG_MAX_FLASH_BANKS	/* use flash_info[2] */
+#define CFG_JFFS2_NUM_BANKS	1
+
+#define ENV_IS_VARIABLE		1
+
+#ifndef __ASSEMBLY__
+extern unsigned int nand_cs_base;
+extern unsigned int boot_flash_base;
+extern volatile unsigned int boot_flash_env_addr;
+extern unsigned int boot_flash_off;
+extern unsigned int boot_flash_sec;
+extern unsigned int boot_flash_type;
+#endif
+
+
+#define WRITE_NAND_COMMAND(d, adr)\
+		       __raw_writew(d, (nand_cs_base + GPMC_NAND_CMD))
+#define WRITE_NAND_ADDRESS(d, adr)\
+		       __raw_writew(d, (nand_cs_base + GPMC_NAND_ADR))
+#define WRITE_NAND(d, adr) __raw_writew(d, (nand_cs_base + GPMC_NAND_DAT))
+#define READ_NAND(adr) __raw_readw((nand_cs_base + GPMC_NAND_DAT))
+
+/* Other NAND Access APIs */
+#define NAND_WP_OFF()\
+		do {*(volatile u32 *)(GPMC_CONFIG) |= 0x00000010; } while (0)
+#define NAND_WP_ON()\
+		do {*(volatile u32 *)(GPMC_CONFIG) &= ~0x00000010; } while (0)
+#define NAND_DISABLE_CE(nand)
+#define NAND_ENABLE_CE(nand)
+#define NAND_WAIT_READY(nand)	udelay(10)
+
+#endif				/* __CONFIG_H */
