Index: busybox-1.01/include/usage.h
===================================================================
--- busybox-1.01.orig/include/usage.h	2008-05-21 22:31:10.000000000 +0200
+++ busybox-1.01/include/usage.h	2008-05-21 22:31:24.000000000 +0200
@@ -2625,7 +2625,7 @@
 	"/dev/tty2\n"
 
 #define udhcpc_trivial_usage \
-	"[-Cfbnqv] [-c CLIENTID] [-H HOSTNAME] [-i INTERFACE]\n[-p pidfile] [-r IP] [-s script]"
+	"[-Cfbznqv] [-c CLIENTID] [-H HOSTNAME] [-i INTERFACE]\n[-p pidfile] [-r IP] [-s script]"
 #define udhcpc_full_usage \
 	"\t-c,\t--clientid=CLIENTID\tSet client identifier\n" \
 	"\t-C,\t--clientid-none\tSuppress default client identifier\n" \
@@ -2634,6 +2634,7 @@
 	"\t-f,\t--foreground\tDo not fork after getting lease\n" \
 	"\t-b,\t--background\tFork to background if lease cannot be immediately negotiated.\n" \
 	"\t-i,\t--interface=INTERFACE\tInterface to use (default: eth0)\n" \
+	"\t-z,\t--zeroconf\tWith Zeroconf address attibution support\n" \
 	"\t-n,\t--now\tExit with failure if lease cannot be immediately negotiated.\n" \
 	"\t-p,\t--pidfile=file\tStore process ID of daemon in file\n" \
 	"\t-q,\t--quit\tQuit after obtaining lease\n" \
Index: busybox-1.01/networking/udhcp/Config.in
===================================================================
--- busybox-1.01.orig/networking/udhcp/Config.in	2008-05-21 22:31:10.000000000 +0200
+++ busybox-1.01/networking/udhcp/Config.in	2008-05-21 22:31:24.000000000 +0200
@@ -26,6 +26,18 @@
 
 	  See http://udhcp.busybox.net for further details.
 
+config CONFIG_UDHCPC_ZEROCONF
+	bool "udhcp Client with zeroconf support"
+	default n
+	depends on CONFIG_UDHCPC
+	help
+	  Zeroconf support allows udhcpc to assign static address on dhcp
+	  server less network.
+
+	  Take a look to busybox/networking/udhcp/samples/ for udhcpc script
+
+	  http://udhcp.busybox.net/lists/udhcp/2005-May/000124.html
+
 config CONFIG_DUMPLEASES
 	bool "Lease display utility (dumpleases)"
 	default n
Index: busybox-1.01/networking/udhcp/Makefile.in
===================================================================
--- busybox-1.01.orig/networking/udhcp/Makefile.in	2008-05-21 22:31:10.000000000 +0200
+++ busybox-1.01/networking/udhcp/Makefile.in	2008-05-21 22:31:24.000000000 +0200
@@ -34,11 +34,25 @@
 endif
 endif
 
+ifeq ($(CONFIG_UDHCPC_ZEROCONF), y)
+# this if you want to include Zeroconf support directly in DHCP client
+ZEROCONF=1
+endif
+
+
+ifdef ZEROCONF
+CFLAGS += -DUDHCP_ZEROCONF
+endif
+
 UDHCP-y:=
 UDHCP-$(CONFIG_UDHCP_SHARED)    += common.c options.c packet.c pidfile.c \
 				   signalpipe.c socket.c
 UDHCP-$(CONFIG_UDHCPC)		+= dhcpc.c clientpacket.c clientsocket.c \
 				   script.c
+ifdef ZEROCONF
+UDHCP-$(CONFIG_UDHCPC)          += zeroconf.c
+endif
+
 UDHCP-$(CONFIG_UDHCPD)		+= dhcpd.c arpping.c files.c leases.c \
 				   serverpacket.c static_leases.c
 UDHCP-$(CONFIG_DUMPLEASES)	+= dumpleases.c
Index: busybox-1.01/networking/udhcp/dhcpc.c
===================================================================
--- busybox-1.01.orig/networking/udhcp/dhcpc.c	2008-05-21 22:31:10.000000000 +0200
+++ busybox-1.01/networking/udhcp/dhcpc.c	2008-05-21 22:31:24.000000000 +0200
@@ -43,6 +43,9 @@
 #include "socket.h"
 #include "common.h"
 #include "signalpipe.h"
+#ifdef UDHCP_ZEROCONF
+#include "zeroconf.h"
+#endif
 
 static int state;
 static unsigned long requested_ip; /* = 0 */
@@ -57,6 +60,10 @@
 #define LISTEN_RAW 2
 static int listen_mode;
 
+/* Warning: 2k038 bug :P */
+
+#define TIMEOUT_INFINITE 0x7fffffff
+
 struct client_config_t client_config = {
 	/* Default options. */
 	abort_if_no_lease: 0,
@@ -85,6 +92,7 @@
 "  -b, --background                Fork to background if lease cannot be\n"
 "                                  immediately negotiated.\n"
 "  -i, --interface=INTERFACE       Interface to use (default: eth0)\n"
+"  -z, --zeroconf                  With Zeroconf address attibution support\n"
 "  -n, --now                       Exit with failure if lease cannot be\n"
 "                                  immediately negotiated.\n"
 "  -p, --pidfile=file              Store process ID of daemon in file\n"
@@ -127,6 +135,9 @@
 		break;
 	case RENEW_REQUESTED: /* impatient are we? fine, square 1 */
 		run_script(NULL, "deconfig");
+#ifdef UDHCP_ZEROCONF
+		zeroconf_event(ZEROCONF_EVENT_DHCPOUT);
+#endif
 	case REQUESTING:
 	case RELEASED:
 		change_mode(LISTEN_RAW);
@@ -157,6 +168,9 @@
 		temp_addr.s_addr = requested_ip;
 		LOG(LOG_INFO, "Unicasting a release of %s to %s",
 				inet_ntoa(temp_addr), buffer);
+#ifdef UDHCP_ZEROCONF
+		zeroconf_event(ZEROCONF_EVENT_DHCPOUT);
+#endif
 		send_release(server_addr, requested_ip); /* unicast */
 		run_script(NULL, "deconfig");
 	}
@@ -164,7 +178,7 @@
 
 	change_mode(LISTEN_NONE);
 	state = RELEASED;
-	timeout = 0x7fffffff;
+	timeout = TIMEOUT_INFINITE;
 }
 
 
@@ -191,9 +205,12 @@
 	int c, len;
 	struct dhcpMessage packet;
 	struct in_addr temp_addr;
-	long now;
+	unsigned long now;
 	int max_fd;
 	int sig;
+#ifdef UDHCP_ZEROCONF
+	int with_zeroconf = 0;
+#endif
 	int no_clientid = 0;
  	char hostbuf[256];	/* SUSv2: hostnames are <= 255 bytes */
 
@@ -205,6 +222,7 @@
 		{"hostname",	required_argument,	0, 'H'},
 		{"hostname",    required_argument,      0, 'h'},
 		{"interface",	required_argument,	0, 'i'},
+		{"zeroconf",	no_argument,		0, 'z'},
 		{"now", 	no_argument,		0, 'n'},
 		{"pidfile",	required_argument,	0, 'p'},
 		{"quit",	no_argument,		0, 'q'},
@@ -226,7 +244,7 @@
 	/* get options */
 	while (1) {
 		int option_index = 0;
- 		c = getopt_long(argc, argv, "c:fbH:h:i:np:qr:s:t:v", arg_options, &option_index);
+ 		c = getopt_long(argc, argv, "c:fbH:h:i:znp:qr:s:t:v", arg_options, &option_index);
 		if (c == -1) break;
 
 		switch (c) {
@@ -262,6 +280,13 @@
 		case 'i':
 			client_config.interface =  optarg;
 			break;
+		case 'z':
+#ifdef UDHCP_ZEROCONF
+			with_zeroconf = 1;
+#else
+			printf("Zeroconf support not included in this build.\n");
+#endif
+			break;
 		case 'n':
 			client_config.abort_if_no_lease = 1;
 			break;
@@ -296,6 +321,11 @@
 			   NULL, client_config.arp) < 0)
 		return 1;
 
+#ifdef UDHCP_ZEROCONF
+		zeroconf_init(with_zeroconf, client_config.arp, client_config.interface,
+                      client_config.ifindex);
+#endif
+
 	/* if not set, and not suppressed, setup the default client ID */
 	if (!client_config.clientid && !no_clientid) {
 		client_config.clientid = xmalloc(6 + 3);
@@ -310,12 +340,25 @@
 
 	state = INIT_SELECTING;
 	run_script(NULL, "deconfig");
+
+#ifdef UDHCP_ZEROCONF
+	zeroconf_event(ZEROCONF_EVENT_DHCPOUT);
+#endif
+
 	change_mode(LISTEN_RAW);
 
 	for (;;) {
 
-		tv.tv_sec = timeout - uptime();
+     		/* configures timeout for select(), the smaller between DHCP and Zeroconf timeouts */
+#ifdef UDHCP_ZEROCONF
+     		zeroconf_set_smallest_timeout(&tv, timeout);
+#else
+		tv.tv_sec = timeout - time(NULL);
+		if (tv.tv_sec < 0) {
+			tv.tv_sec = 0;
+		}
 		tv.tv_usec = 0;
+#endif
 
 		if (listen_mode != LISTEN_NONE && fd < 0) {
 			if (listen_mode == LISTEN_KERNEL)
@@ -327,16 +370,38 @@
 				return 0;
 			}
 		}
-		max_fd = udhcp_sp_fd_set(&rfds, fd);
 
-		if (tv.tv_sec > 0) {
+#ifdef UDHCP_ZEROCONF
+		if (zeroconf_fd > -1) {
+			max_fd = udhcp_sp_fd_set2(&rfds, fd, zeroconf_fd);
+		} else {
+			max_fd = udhcp_sp_fd_set(&rfds, fd);
+		}
+#else
+		max_fd = udhcp_sp_fd_set(&rfds, fd);
+#endif
+		if (tv.tv_sec > 0 || tv.tv_usec > 0) {
 			DEBUG(LOG_INFO, "Waiting on select...");
 			retval = select(max_fd + 1, &rfds, NULL, NULL, &tv);
 		} else retval = 0; /* If we already timed out, fall through */
 
-		now = uptime();
+		now = time(NULL);
 		if (retval == 0) {
-			/* timeout dropped to zero */
+			/* timeout, must be forwarded to Zeroconf and DHCP state machines */
+
+#ifdef UDHCP_ZEROCONF
+			/* Zeroconf has its own timeout tests, just tick it */
+			zeroconf_event(ZEROCONF_EVENT_TICK);
+#endif
+
+			if (timeout > now) {
+				/* it is not DHCP's timeout */
+				continue;
+			}
+
+			DEBUG(LOG_INFO, "DHCP timeout");
+
+			/* DHCP timeout dropped to zero */
 			switch (state) {
 			case INIT_SELECTING:
 				if (packet_num < 3) {
@@ -375,6 +440,9 @@
 				} else {
 					/* timed out, go back to init state */
 					if (state == RENEW_REQUESTED) run_script(NULL, "deconfig");
+#ifdef UDHCP_ZEROCONF
+					zeroconf_event(ZEROCONF_EVENT_DHCPOUT);
+#endif
 					state = INIT_SELECTING;
 					timeout = now;
 					packet_num = 0;
@@ -409,6 +477,9 @@
 					state = INIT_SELECTING;
 					LOG(LOG_INFO, "Lease lost, entering init state");
 					run_script(NULL, "deconfig");
+#ifdef UDHCP_ZEROCONF
+					zeroconf_event(ZEROCONF_EVENT_DHCPOUT);
+#endif
 					timeout = now;
 					packet_num = 0;
 					change_mode(LISTEN_RAW);
@@ -422,10 +493,21 @@
 				break;
 			case RELEASED:
 				/* yah, I know, *you* say it would never happen */
-				timeout = 0x7fffffff;
+				timeout = TIMEOUT_INFINITE;
 				break;
 			}
+#ifdef UDHCP_ZEROCONF
+		} else if (retval > 0 && zeroconf_fd > -1 && FD_ISSET(zeroconf_fd, &rfds)) {
+			/* zeroconf packet is ready, process */
+
+			DEBUG(LOG_INFO, "Socket data for Zeroconf");
+
+			zeroconf_event(ZEROCONF_EVENT_SOCKETREADY);
+#endif
 		} else if (retval > 0 && listen_mode != LISTEN_NONE && FD_ISSET(fd, &rfds)) {
+
+			DEBUG(LOG_INFO, "Socket data for DHCP");
+
 			/* a packet is ready, read it */
 
 			if (listen_mode == LISTEN_KERNEL)
@@ -496,6 +578,9 @@
 					start = now;
 					timeout = t1 + start;
 					requested_ip = packet.yiaddr;
+#ifdef UDHCP_ZEROCONF
+					zeroconf_event(ZEROCONF_EVENT_DHCPIN);
+#endif
 					run_script(&packet,
 						   ((state == RENEWING || state == REBINDING) ? "renew" : "bound"));
 
@@ -510,8 +595,12 @@
 					/* return to init state */
 					LOG(LOG_INFO, "Received DHCP NAK");
 					run_script(&packet, "nak");
-					if (state != REQUESTING)
+					if (state != REQUESTING) {
 						run_script(NULL, "deconfig");
+#ifdef UDHCP_ZEROCONF
+						zeroconf_event(ZEROCONF_EVENT_DHCPOUT);
+#endif
+					}
 					state = INIT_SELECTING;
 					timeout = now;
 					requested_ip = 0;
Index: busybox-1.01/networking/udhcp/options.c
===================================================================
--- busybox-1.01.orig/networking/udhcp/options.c	2008-05-21 22:31:10.000000000 +0200
+++ busybox-1.01/networking/udhcp/options.c	2008-05-21 22:31:24.000000000 +0200
@@ -70,7 +70,8 @@
 	length = 308;
 	while (!done) {
 		if (i >= length) {
-			LOG(LOG_WARNING, "bogus packet, option fields too long.");
+			if (length > 0)
+				LOG(LOG_WARNING, "bogus packet, option fields too long.");
 			return NULL;
 		}
 		if (optionptr[i + OPT_CODE] == code) {
Index: busybox-1.01/networking/udhcp/samples/WARNING_LEASEFAIL
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ busybox-1.01/networking/udhcp/samples/WARNING_LEASEFAIL	2008-05-21 22:31:24.000000000 +0200
@@ -0,0 +1,7 @@
+WARNING ABOUT leasefail SCRIPT IN ZEROCONF-ENABLED CONFIGURATIONS
+
+if your UDHCP compilation flags are set to support Zeroconf, you
+should not do any network configuration in 'leasefail' script, since
+it would damage the configurations that 'zeroconf' script may have
+done just before 'leasefail' is run.
+
Index: busybox-1.01/networking/udhcp/samples/sample.zeroconf
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ busybox-1.01/networking/udhcp/samples/sample.zeroconf	2008-05-21 22:31:24.000000000 +0200
@@ -0,0 +1,53 @@
+#!/bin/sh
+# udhcpc script edited by Tim Riker <Tim@Rikers.org> with zerconf support
+
+[ -z "$1" ] && echo "Error: should be called from udhcpc" && exit 1
+
+RESOLV_CONF="/etc/resolv.conf"
+[ -n "$broadcast" ] && BROADCAST="broadcast $broadcast"
+[ -n "$subnet" ] && NETMASK="netmask $subnet"
+
+case "$1" in
+    deconfig)
+    /sbin/ifconfig $interface 0.0.0.0
+    ;;
+
+    renew|bound)
+    /sbin/ifconfig $interface $ip $BROADCAST $NETMASK
+
+    if [ -n "$router" ] ; then
+	echo "deleting routers"
+	while route del default gw 0.0.0.0 dev $interface ; do
+	    :
+	done
+
+	for i in $router ; do
+	    route add default gw $i dev $interface
+	done
+    fi
+
+    echo -n > $RESOLV_CONF
+    [ -n "$domain" ] && echo "search $domain" >> $RESOLV_CONF
+
+    for i in $dns ; do
+      echo "adding dns $i"
+      echo "nameserver $i" >> $RESOLV_CONF
+    done
+    ;;
+
+    zeroconf)
+    /sbin/ifconfig $interface $ip broadcast 169.254.255.255 netmask 255.255.0.0
+
+    echo "deleting routers"
+
+    while /sbin/route del default gw 0.0.0.0 dev $interface ; do
+	:
+    done
+
+    echo -n > $RESOLV_CONF
+    ;;
+
+esac
+
+exit 0
+
Index: busybox-1.01/networking/udhcp/signalpipe.c
===================================================================
--- busybox-1.01.orig/networking/udhcp/signalpipe.c	2008-05-21 22:31:10.000000000 +0200
+++ busybox-1.01/networking/udhcp/signalpipe.c	2008-05-21 22:31:24.000000000 +0200
@@ -60,6 +60,13 @@
 	return signal_pipe[0] > extra_fd ? signal_pipe[0] : extra_fd;
 }
 
+int udhcp_sp_fd_set2(fd_set *rfds, int extra_fd, int extra_fd2)
+{
+	int max_fd = udhcp_sp_fd_set(rfds, extra_fd);
+	if (extra_fd2 >= 0) FD_SET(extra_fd2, rfds);
+	return (max_fd > extra_fd2 ? max_fd : extra_fd2);
+}
+
 
 /* Read a signal from the signal pipe. Returns 0 if there is
  * no signal, -1 on error (and sets errno appropriately), and
Index: busybox-1.01/networking/udhcp/signalpipe.h
===================================================================
--- busybox-1.01.orig/networking/udhcp/signalpipe.h	2008-05-21 22:31:10.000000000 +0200
+++ busybox-1.01/networking/udhcp/signalpipe.h	2008-05-21 22:31:24.000000000 +0200
@@ -19,4 +19,5 @@
 
 void udhcp_sp_setup(void);
 int udhcp_sp_fd_set(fd_set *rfds, int extra_fd);
+int udhcp_sp_fd_set2(fd_set *rfds, int extra_fd, int extra_fd2);
 int udhcp_sp_read(fd_set *rfds);
Index: busybox-1.01/networking/udhcp/zeroconf.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ busybox-1.01/networking/udhcp/zeroconf.c	2008-05-21 22:31:24.000000000 +0200
@@ -0,0 +1,604 @@
+/* zeroconf.c
+ *
+ * Zeroconf handling
+ * Based on draft-ietf-zeroconf-ipv4-linklocal.txt (July 2004)
+ *
+ * Elvis Pf√ºtzenreuter <elvis@indt.org> May 2005
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* TODO (future): Excess traffic in DHCP socket (while DHCP lease has not been granted)
+ * TODO: Tests with autoimmune response (two network interfaces in the same net, with/wo 2 udhcpc)
+ * TODO (future): ARP "is-at" in broadcast mode if using link-local address - move to kernel ?
+ */
+
+#include <sys/time.h>
+#include <sys/file.h>
+#include <unistd.h>
+#include <getopt.h>
+#include <stdlib.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <signal.h>
+#include <time.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <errno.h>
+#if __GLIBC__ >=2 && __GLIBC_MINOR >= 1
+#include <netpacket/packet.h>
+#include <net/ethernet.h>
+#else
+#include <asm/types.h>
+#include <linux/if_packet.h>
+#include <linux/if_ether.h>
+#endif
+
+#ifndef MAC_BCAST_ADDR
+#define MAC_BCAST_ADDR		(uint8_t *) "\xff\xff\xff\xff\xff\xff"
+#endif
+
+#include "arpping.h"
+#include "common.h"
+#include "packet.h"
+#include "script.h"
+#include "zeroconf.h"
+
+
+/* Prototypes */
+static void choose_addr(void);
+static void disarm_timeout(void);
+static int is_timeout_disarmed(void);
+static int arp_conflict(void);
+static void arp_probe(void);
+static void arp_announce(struct in_addr *target);
+static void initial_time(void);
+static void probe(void);
+static void active_announce(void);
+static void active_rest(void);
+static int timeout_passed(void);
+static int timeout_exhausted(void);
+static void _disable(void);
+static void disable(void);
+static void disable_permanently(void);
+static void rate_limit(void);
+
+
+/* static variables */
+
+int state;
+int conflicted;
+int conflict_count;
+
+int zeroconf_fd;
+struct timeval timeout;
+int timeout_count;
+char* interface;
+int ifindex;
+
+struct in_addr linklocal_addr;
+uint8_t mac_addr[6];
+uint64_t mac_addr_as_int;
+
+
+/* Inits zeroconf structures and state machine */
+
+void zeroconf_init(int enable, uint8_t arp[], const char* pinterface, int pifindex)
+{
+	int i;
+
+	if (enable) {
+		state = ZEROCONF_SM_DISABLED;
+	} else {
+		state = ZEROCONF_SM_PERMANENTLY_DISABLED;
+	}
+
+	disarm_timeout();
+	linklocal_addr.s_addr = 0;
+	conflicted = 0;
+	zeroconf_fd = -1;
+	mac_addr_as_int = 0;
+
+	conflict_count = 0;
+
+	for(i = 0; i < 6; ++i) {
+		mac_addr[i] = arp[i];
+		mac_addr_as_int <<= 8;
+		mac_addr_as_int += arp[i];
+	}
+
+	interface = strdup(pinterface);
+	ifindex = pifindex;
+}
+
+/* generates address in 169.254.0.0/16 range, excluding 169.254.0.0/24 and
+ * 169.254.255.0/24 edge ranges */
+
+static void choose_addr()
+{
+	if (conflicted) {
+
+		/* conflicts took place sometime, our MAC-derived address
+		 * is not good enough, try random() for a change */
+
+		linklocal_addr.s_addr = (169 << 24) +
+				(254 << 16) +
+				256 + (random() % (65536 - 256 - 256));
+
+		DEBUG(LOG_INFO, "zeroconf: previous address conflicted, trying random this time");
+
+	} else {
+		/* calculate IP address based on MAC so it will be the same
+		 * every time the machine is turned on */
+
+		linklocal_addr.s_addr = (169 << 24) +
+				(254 << 16) +
+				256 + ((mac_addr_as_int + 13371361) % (65536 - 256 - 256));
+	}
+
+	linklocal_addr.s_addr = htonl(linklocal_addr.s_addr);
+
+	LOG(LOG_INFO, "zeroconf: address selected is %s", inet_ntoa(linklocal_addr));
+}
+
+/* Helper function to set TIMEVAL structure to smallest timeout
+ * between DHCP and zeroconf (NOTE: other_timeout is UNIX time seconds since 1970) */
+
+void zeroconf_set_smallest_timeout(struct timeval* tv, long int other_timeout)
+{
+	struct timeval now;
+	gettimeofday(&now, NULL);
+
+	if (other_timeout <= 0) {
+		*tv = now;
+	} else if (is_timeout_disarmed()) {
+		tv->tv_sec = other_timeout;
+		tv->tv_usec = 0;
+	} else if (other_timeout <= timeout.tv_sec) {
+		tv->tv_sec = other_timeout;
+		tv->tv_usec = 0;
+	} else {
+		*tv = timeout;
+	}
+
+	/* we want differential timeout for select(), so we subtract time */
+	tv->tv_sec -= now.tv_sec;
+	tv->tv_usec -= now.tv_usec;
+
+	while (tv->tv_usec < 0) {
+		tv->tv_usec += 1000000;
+		tv->tv_sec -= 1;
+	}
+
+	if (tv->tv_sec < 0) {
+		/* glup */
+		tv->tv_sec = tv->tv_usec = 0;
+	}
+
+// DEBUG(LOG_INFO, "zeroconf_set_smallest_timeout: o=%d, z=%d:%d, tv set to %d:%d, now is %d:%d",
+//			other_timeout, timeout.tv_sec, timeout.tv_usec,
+// 			tv->tv_sec, tv->tv_usec, now.tv_sec, now.tv_usec);
+}
+
+/* Sets timeout to a moment in absolute time */
+
+static void set_timeout(long int usecs, int times)
+{
+	struct timeval now;
+	gettimeofday(&now, NULL);
+
+	timeout.tv_sec = now.tv_sec + (usecs / 1000000);
+	timeout.tv_usec = now.tv_usec + (usecs % 1000000);
+
+	if (timeout.tv_usec >= 1000000) {
+		timeout.tv_usec -= 1000000;
+		timeout.tv_sec += 1;
+	}
+
+	/* If "times" is zero, timeout_count is not touched, it is used by some
+	 * machine states that can receive several timeout events without going
+	 * to another state (e.g. probe). */
+
+	if (times > 0) {
+		timeout_count = times;
+	}
+
+	DEBUG(LOG_INFO, "zeroconf timeout set to %d:%d, now is %d:%d",	timeout.tv_sec,
+							 		timeout.tv_usec,
+									now.tv_sec,
+									now.tv_usec);
+}
+
+/* Disarms timeout bomb :) */
+
+static void disarm_timeout()
+{
+	timeout.tv_sec = timeout.tv_usec = 0;
+}
+
+/* Timeout test functions */
+
+static int is_timeout_disarmed()
+{
+	return timeout.tv_sec == 0 && timeout.tv_usec == 0;
+}
+
+/* Tests if timeout moment has passed (i.e. timeout is done) */
+
+static int timeout_passed()
+{
+	struct timeval now;
+	gettimeofday(&now, NULL);
+
+	if (timeout.tv_sec == 0 && timeout.tv_usec == 0) {
+		/* timeout disarmed */
+		return 0;
+	}
+
+	return ((now.tv_sec > timeout.tv_sec) ||
+	    (now.tv_sec == timeout.tv_sec &&
+	     now.tv_usec >= timeout.tv_usec));
+}
+
+static int timeout_exhausted()
+{
+	return timeout_count <= 0;
+}
+
+/* Does the low-level disabling task, it is used by many functions */
+
+static void _disable()
+{
+	close(zeroconf_fd);
+	zeroconf_fd = -1;
+	disarm_timeout();
+}
+
+/* State machine transition: disables zeroconf (probably because DHCP got an address) */
+
+static void disable()
+{
+	LOG(LOG_INFO, "zeroconf: state is Disabled.");
+	_disable();
+	state = ZEROCONF_SM_DISABLED;
+}
+
+static void disable_permanently()
+{
+	LOG(LOG_INFO, "zeroconf: state is Disabled permanently.");
+	_disable();
+	state = ZEROCONF_SM_DISABLED_PERMANENTLY;
+}
+
+/* Sends ARP probe to see if our chosen IP address has another owner */
+
+static void arp_probe()
+{
+	struct arpMsg arpbuffer;
+	struct sockaddr iface;
+
+	memset(&arpbuffer, 0, sizeof(arpbuffer));
+	memcpy(arpbuffer.h_dest, MAC_BCAST_ADDR, 6);		/* MAC DA */
+	memcpy(arpbuffer.h_source, mac_addr, 6);	/* MAC SA */
+	arpbuffer.h_proto = htons(ETH_P_ARP);			/* protocol type (Ethernet) */
+	arpbuffer.htype = htons(ARPHRD_ETHER);			/* hardware type */
+	arpbuffer.ptype = htons(ETH_P_IP);			/* protocol type (ARP message) */
+	arpbuffer.hlen = 6;					/* hardware address length */
+	arpbuffer.plen = 4;					/* protocol address length */
+	arpbuffer.operation = htons(ARPOP_REQUEST);		/* ARP op code */
+	// arpbuffer.sInaddr = 0;				/* source IP address */
+	memcpy(arpbuffer.sHaddr, mac_addr, 6);		/* source hardware address */
+	memcpy(arpbuffer.tInaddr, &linklocal_addr, sizeof(linklocal_addr));	/* target IP address */
+
+	memset(&iface, 0, sizeof(iface));
+	strcpy(iface.sa_data, interface);
+
+	DEBUG(LOG_INFO, "zeroconf: Sending ARP probe.");
+
+	if (sendto(zeroconf_fd, &arpbuffer, sizeof(arpbuffer), 0, &iface, sizeof(iface)) < 0) {
+
+		/* serious error, disable zeroconf completely */
+
+		LOG(LOG_ERR, "zeroconf: packet socket error in sendto(), disabling zeroconf.");
+
+		disable_permanently();
+	}
+}
+
+/* Announces the link-local address as broadcasted ARP "is-at" packets. */
+
+static void arp_announce(struct in_addr *target)
+{
+	struct arpMsg arpbuffer;
+	struct sockaddr iface;
+
+	memset(&arpbuffer, 0, sizeof(arpbuffer));
+	memcpy(arpbuffer.h_dest, MAC_BCAST_ADDR, 6);		/* MAC DA */
+	memcpy(arpbuffer.h_source, mac_addr, 6);		/* MAC SA */
+	arpbuffer.h_proto = htons(ETH_P_ARP);			/* protocol type (Ethernet) */
+	arpbuffer.htype = htons(ARPHRD_ETHER);			/* hardware type */
+	arpbuffer.ptype = htons(ETH_P_IP);			/* protocol type (ARP message) */
+	arpbuffer.hlen = 6;					/* hardware address length */
+	arpbuffer.plen = 4;					/* protocol address length */
+	arpbuffer.operation = htons(ARPOP_REPLY);		/* ARP op code */
+	memcpy(arpbuffer.sInaddr, &linklocal_addr, sizeof(linklocal_addr));	/* source IP address */
+	memcpy(arpbuffer.sHaddr, mac_addr, 6);			/* source hardware address */
+	memcpy(arpbuffer.tInaddr, target, sizeof(struct in_addr));		/* target IP address */
+
+	memset(&iface, 0, sizeof(iface));
+	strcpy(iface.sa_data, interface);
+
+	DEBUG(LOG_INFO, "zeroconf: Sending ARP announcement.");
+
+	if (sendto(zeroconf_fd, &arpbuffer, sizeof(arpbuffer), 0, &iface, sizeof(iface)) < 0) {
+
+		/* serious error, disable zeroconf completely */
+
+		LOG(LOG_ERR, "zeroconf: packet socket error in sendto(), disabling zeroconf.");
+
+		disable_permanently();
+	}
+}
+
+/* State machine transition: enables zeroconf (probably because DHCP didn't get a
+ * better IP address yet */
+
+static void initial_time()
+{
+	struct ifreq iface;
+	int optval = 1;
+
+	if (zeroconf_fd >= 0) {
+		close(zeroconf_fd);
+	}
+
+	zeroconf_fd = socket(PF_PACKET, SOCK_PACKET, htons(ETH_P_ARP));
+
+	if (zeroconf_fd < 0) {
+		LOG(LOG_ERR, "zeroconf: link socket creation error, disabling zeroconf.");
+		disable_permanently();
+		return;
+	}
+
+	if (setsockopt(zeroconf_fd, SOL_SOCKET, SO_BROADCAST, &optval, sizeof(optval)) == -1) {
+		LOG(LOG_ERR, "zeroconf: Could not setsocketopt(BROADCAST) link socket");
+		disable_permanently();
+		return;
+	}
+
+	strncpy(iface.ifr_ifrn.ifrn_name, interface, IFNAMSIZ);
+	if (setsockopt(zeroconf_fd, SOL_SOCKET, SO_BINDTODEVICE, (char*) &iface, sizeof(iface)) < 0) {
+		LOG(LOG_ERR, "zeroconf: Could not setsocketopt(BINDTODEVICE) link socket");
+		disable_permanently();
+		return;
+	}
+
+	choose_addr();
+	state = ZEROCONF_SM_INITIALTIME;
+
+	/* Timeout is one-shot */
+	set_timeout(ZEROCONF_PROBE_WAIT_MINIMUM +
+			  random() % (ZEROCONF_PROBE_WAIT_MAXIMUM - ZEROCONF_PROBE_WAIT_MINIMUM),
+			  1);
+}
+
+/* State machine transition: after initial time, probe to see if the chosen link-local
+ * address does not have an owner */
+
+static void probe()
+{
+	if (state != ZEROCONF_SM_PROBE) {
+		DEBUG(LOG_INFO, "zeroconf: Changed state to PROBE");
+		state = ZEROCONF_SM_PROBE;
+
+		/* Timeout will fire for ZEROCONF_PROBE_NUM times */
+
+		set_timeout(ZEROCONF_PROBE_MIN +
+					random() % (ZEROCONF_PROBE_MAX - ZEROCONF_PROBE_MIN),
+				     ZEROCONF_PROBE_NUM);
+		arp_probe();
+
+	} else if (! timeout_exhausted()) {
+
+		/* Timeout count not exausthed, probe again */
+
+		DEBUG(LOG_INFO, "zeroconf: PROBE state maintained, probing again");
+
+		set_timeout(ZEROCONF_PROBE_MIN +
+					random() % (ZEROCONF_PROBE_MAX - ZEROCONF_PROBE_MIN),
+				     0);
+		arp_probe();
+	} else {
+		DEBUG(LOG_INFO, "zeroconf: PROBE complete, going to active/ann state");
+		active_announce();
+	}
+
+}
+
+/* State machine transition: link-local address is ours, hooray! */
+
+static void active_announce()
+{
+	if (state != ZEROCONF_SM_ACTIVE_ANNOUNCE) {
+		LOG(LOG_INFO, "zeroconf: state is Active/Announce, Link-local address %s",
+				inet_ntoa(linklocal_addr));
+
+		struct dhcpMessage fake;
+		bzero(&fake, sizeof(fake));
+		fake.yiaddr = linklocal_addr.s_addr;
+
+		run_script(&fake, "zeroconf");
+
+		state = ZEROCONF_SM_ACTIVE_ANNOUNCE;
+
+		/* Timeout will shoot ZEROCONF_ANNOUNCE_NUM times */
+		set_timeout(ZEROCONF_ANNOUNCE_WAIT, ZEROCONF_ANNOUNCE_NUM);
+		arp_announce(&linklocal_addr);
+
+	} else if (! timeout_exhausted()) {
+		DEBUG(LOG_INFO, "zeroconf: Announcing again link-local address");
+		set_timeout(ZEROCONF_ANNOUNCE_INTERVAL, 0);
+		arp_announce(&linklocal_addr);
+
+	} else {
+		active_rest();
+	}
+}
+
+/* Machine state: active and no more announcements due. Rest in peace */
+
+static void active_rest()
+{
+	DEBUG(LOG_INFO, "zeroconf: State is Active/rest");
+	state = ZEROCONF_SM_ACTIVE_REST;
+	conflict_count = 0;
+	disarm_timeout();
+}
+
+/* Machine state: too many conflicts in link-local negotiation, sleep for a while */
+
+static void rate_limit()
+{
+	DEBUG(LOG_INFO, "zeroconf: State is Rate limit");
+
+	_disable();
+	state = ZEROCONF_SM_RATE_LIMIT;
+	linklocal_addr.s_addr = 0;
+
+	/* One-shot timeout */
+	set_timeout(ZEROCONF_RATE_LIMIT_INTERVAL, 1);
+}
+
+/* Reads link-layer socket about ARP packets, and detects conflicts */
+
+static int arp_conflict()
+{
+	if (zeroconf_fd < 0) {
+		DEBUG(LOG_INFO, "zeroconf: arp_conflict(): hey, socket is closed, do not call me!");
+		return 0;
+	}
+
+	struct arpMsg arpbuffer;
+
+	if (recv(zeroconf_fd, &arpbuffer, sizeof(arpbuffer), 0) < 0) {
+
+		/* socket error, we disable zeroconf completely */
+
+		LOG(LOG_ERR, "zeroconf: link socket read error, disabling zeroconf.");
+
+		if (state == ZEROCONF_SM_ACTIVE_ANNOUNCE || state == ZEROCONF_SM_ACTIVE_REST) {
+			run_script(NULL, "deconfig");
+		}
+		disable_permanently();
+		return 0;
+	}
+
+	if (arpbuffer.operation == htons(ARPOP_REPLY) &&
+	    bcmp(arpbuffer.sHaddr, mac_addr, 6) != 0 &&
+	    *((uint32_t *) arpbuffer.sInaddr) == linklocal_addr.s_addr) {
+
+		/* if the packet is ARPOP_REPLY, and the source MAC address is not ours,
+		 * and the source IP address *is* ours, there is a conflict. */
+
+		LOG(LOG_INFO, "zeroconf: conflict: %02x:%02x:%02x:%02x:%02x:%02x claims "
+			      "to have same IP as ours.", arpbuffer.sHaddr[0], arpbuffer.sHaddr[1],
+			      arpbuffer.sHaddr[2], arpbuffer.sHaddr[3], arpbuffer.sHaddr[4],
+			      arpbuffer.sHaddr[5]);
+		return 1;
+	}
+
+	if (arpbuffer.operation == htons(ARPOP_REQUEST) &&
+	    bcmp(arpbuffer.sHaddr, mac_addr, 6) != 0 &&
+	    *((uint32_t *) arpbuffer.tInaddr) == linklocal_addr.s_addr) {
+
+		/* if the packet is ARPOP_REQUEST, and the source MAC address is not ours,
+		 * and the target IP addres *is* ours, send ARP reply as broadcast
+		 * (ok, it will duplicate kernel response, a kernel patch for Zeroconf
+		 * would be a better solution) */
+
+		LOG(LOG_INFO, "zeroconf: ARP request for our address, answering in broadcast.");
+		arp_announce((struct in_addr*) &arpbuffer.sInaddr);
+	}
+
+	/* No conflict detected */
+
+	return 0;
+}
+
+/* main state machine controller */
+
+void zeroconf_event(int event)
+{
+	if (state == ZEROCONF_SM_PERMANENTLY_DISABLED) {
+		DEBUG(LOG_INFO, "zeroconf: event: we are permanently disabled, ignoring.");
+		return;
+
+	} else if (event == ZEROCONF_EVENT_DHCPIN) {
+		/* DHCP offers a better address, cut off zeroconf */
+		DEBUG(LOG_INFO, "zeroconf: Going to disabled state.");
+		disable();
+
+	} else if (event == ZEROCONF_EVENT_DHCPOUT) {
+		if (state == ZEROCONF_SM_DISABLED) {
+			/* If zeroconf is off but not permanently off, turn it on */
+			DEBUG(LOG_INFO, "zeroconf: Going to 'initial time' state.");
+			initial_time();
+		}
+
+	} else if (event == ZEROCONF_EVENT_SOCKETREADY) {
+		if (arp_conflict() &&
+		    state != ZEROCONF_SM_DISABLED && state != ZEROCONF_SM_DISABLED_PERMANENTLY) {
+			DEBUG(LOG_INFO, "zeroconf: Conflict detected and we are not disabled.");
+			conflicted = 1;
+			++conflict_count;
+			if (conflict_count > ZEROCONF_MAX_COLLISIONS) {
+				DEBUG(LOG_INFO, "zeroconf: Too many conflicts, rate limiting!");
+				rate_limit();
+			} else {
+				DEBUG(LOG_INFO, "zeroconf: Back to square one.");
+				initial_time();
+			}
+		}
+	}
+
+	/* We grab every opportunity to test if timeout has elapsed */
+
+	if (timeout_passed()) {
+		DEBUG(LOG_INFO, "zeroconf: a timeout has passed");
+
+		disarm_timeout();
+		--timeout_count;
+
+		if (state == ZEROCONF_SM_INITIALTIME) {
+			DEBUG(LOG_INFO, "zeroconf: initial time T/O, going to probe");
+			probe();
+
+		} else if (state == ZEROCONF_SM_PROBE) {
+			DEBUG(LOG_INFO, "zeroconf: probe T/O, probing again");
+			probe();
+
+		} else if (state == ZEROCONF_SM_ACTIVE_ANNOUNCE) {
+			DEBUG(LOG_INFO, "zeroconf: announce T/O, announcing again");
+			active_announce();
+
+		} else if (state == ZEROCONF_SM_RATE_LIMIT) {
+			DEBUG(LOG_INFO, "zeroconf: rate limit T/O, going to initial time");
+			initial_time();
+		}
+	}
+}
+
Index: busybox-1.01/networking/udhcp/zeroconf.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ busybox-1.01/networking/udhcp/zeroconf.h	2008-05-21 22:31:24.000000000 +0200
@@ -0,0 +1,44 @@
+/* dhcpc.h */
+#ifndef _ZEROCONF_H
+#define _ZEROCONF_H
+
+#include <sys/time.h>
+
+#define ZEROCONF_SM_PERMANENTLY_DISABLED -1
+#define ZEROCONF_SM_DISABLED_PERMANENTLY ZEROCONF_SM_PERMANENTLY_DISABLED
+#define ZEROCONF_SM_DISABLED 0
+#define ZEROCONF_SM_INITIALTIME 1
+#define ZEROCONF_SM_PROBE 2
+#define ZEROCONF_SM_ACTIVE_ANNOUNCE 4
+#define ZEROCONF_SM_ACTIVE_REST 5
+#define ZEROCONF_SM_ACTIVE_DEFENDING 6
+#define ZEROCONF_SM_RATE_LIMIT 7
+
+#define ZEROCONF_EVENT_TICK 1
+#define ZEROCONF_EVENT_DHCPIN 2
+#define ZEROCONF_EVENT_DHCPOUT 3
+#define ZEROCONF_EVENT_START ZEROCONF_EVENT_DHCP_OUT
+#define ZEROCONF_EVENT_SOCKETREADY 4
+
+extern int zeroconf_fd;
+
+void zeroconf_init(int enable, uint8_t arp[], const char* interface, int ifindex);
+void zeroconf_event(int event);
+void zeroconf_set_smallest_timeout(struct timeval* tm, long int other_timeout);
+
+/* Zeroconf constants, time constants in microseconds */
+
+#define ZEROCONF_PROBE_WAIT_MINIMUM	 500*1000
+#define ZEROCONF_PROBE_WAIT_MAXIMUM	1000*1000
+#define ZEROCONF_PROBE_MIN 		 200*1000
+#define ZEROCONF_PROBE_MAX		 400*1000
+#define ZEROCONF_PROBE_NUM		3
+#define ZEROCONF_ANNOUNCE_WAIT		1000*1000
+#define ZEROCONF_ANNOUNCE_NUM		2
+#define ZEROCONF_ANNOUNCE_INTERVAL	2000*1000
+#define ZEROCONF_MAX_COLLISIONS		10
+#define ZEROCONF_RATE_LIMIT_INTERVAL	60*1000*1000
+#define ZEROCONF_DEFEND_INTERVAL	10*1000*1000
+
+#endif
+
Index: busybox-1.01/examples/udhcp/simple.script
===================================================================
--- busybox-1.01.orig/examples/udhcp/simple.script	2008-05-21 22:35:23.000000000 +0200
+++ busybox-1.01/examples/udhcp/simple.script	2008-05-21 22:35:45.000000000 +0200
@@ -1,6 +1,5 @@
 #!/bin/sh
-
-# udhcpc script edited by Tim Riker <Tim@Rikers.org>
+# udhcpc script edited by Tim Riker <Tim@Rikers.org> with zerconf support
 
 [ -z "$1" ] && echo "Error: should be called from udhcpc" && exit 1
 
@@ -9,31 +8,46 @@
 [ -n "$subnet" ] && NETMASK="netmask $subnet"
 
 case "$1" in
-	deconfig)
-		/sbin/ifconfig $interface 0.0.0.0
-		;;
-
-	renew|bound)
-		/sbin/ifconfig $interface $ip $BROADCAST $NETMASK
-
-		if [ -n "$router" ] ; then
-			while route del default gw 0.0.0.0 dev $interface 2>/dev/null ; do
-				:
-			done
-
-			metric=0
-			for i in $router ; do
-				route add default gw $i dev $interface metric $((metric++))
-			done
-		fi
-
-		echo -n > $RESOLV_CONF
-		[ -n "$domain" ] && echo search $domain >> $RESOLV_CONF
-		for i in $dns ; do
-			echo adding dns $i
-			echo nameserver $i >> $RESOLV_CONF
-		done
-		;;
+    deconfig)
+    /sbin/ifconfig $interface 0.0.0.0
+    ;;
+
+    renew|bound)
+    /sbin/ifconfig $interface $ip $BROADCAST $NETMASK
+
+    if [ -n "$router" ] ; then
+	echo "deleting routers"
+	while route del default gw 0.0.0.0 dev $interface ; do
+	    :
+	done
+
+	for i in $router ; do
+	    route add default gw $i dev $interface
+	done
+    fi
+
+    echo -n > $RESOLV_CONF
+    [ -n "$domain" ] && echo "search $domain" >> $RESOLV_CONF
+
+    for i in $dns ; do
+      echo "adding dns $i"
+      echo "nameserver $i" >> $RESOLV_CONF
+    done
+    ;;
+
+    zeroconf)
+    /sbin/ifconfig $interface $ip broadcast 169.254.255.255 netmask 255.255.0.0
+
+    echo "deleting routers"
+
+    while /sbin/route del default gw 0.0.0.0 dev $interface ; do
+	:
+    done
+
+    echo -n > $RESOLV_CONF
+    ;;
+
 esac
 
 exit 0
+
