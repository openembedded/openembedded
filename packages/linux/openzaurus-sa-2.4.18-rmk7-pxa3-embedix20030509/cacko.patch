diff -Nur linux/arch/arm/def-configs/collie-jffs2 /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/arch/arm/def-configs/collie-jffs2
--- linux/arch/arm/def-configs/collie-jffs2	1970-01-01 07:00:00.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/arch/arm/def-configs/collie-jffs2	2003-06-23 01:47:03.000000000 +0700
@@ -0,0 +1,917 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_ARM=y
+# CONFIG_EISA is not set
+# CONFIG_SBUS is not set
+# CONFIG_MCA is not set
+CONFIG_UID16=y
+# CONFIG_SMP is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_OBSOLETE is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_ARCA5K is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_RPC is not set
+CONFIG_ARCH_SA1100=y
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_ANAKIN is not set
+
+#
+# Archimedes/A5000 Implementations
+#
+
+#
+# Archimedes/A5000 Implementations (select only ONE)
+#
+# CONFIG_ARCH_ARC is not set
+# CONFIG_ARCH_A5K is not set
+
+#
+# Footbridge Implementations
+#
+# CONFIG_ARCH_CATS is not set
+# CONFIG_ARCH_PERSONAL_SERVER is not set
+# CONFIG_ARCH_EBSA285_ADDIN is not set
+# CONFIG_ARCH_EBSA285_HOST is not set
+# CONFIG_ARCH_NETWINDER is not set
+
+#
+# SA11x0 Implementations
+#
+# CONFIG_SA1100_ASSABET is not set
+# CONFIG_ASSABET_NEPONSET is not set
+# CONFIG_SA1100_BRUTUS is not set
+# CONFIG_SA1100_CERF is not set
+CONFIG_SA1100_COLLIE=y
+CONFIG_LOCOMO=y
+# CONFIG_COLLIE_TS is not set
+# CONFIG_COLLIE_TR0 is not set
+# CONFIG_COLLIE_TR1 is not set
+# CONFIG_COLLIE_DEV is not set
+# CONFIG_SA1100_BITSY is not set
+# CONFIG_SA1100_EXTENEX1 is not set
+# CONFIG_SA1100_FLEXANET is not set
+# CONFIG_SA1100_FREEBIRD is not set
+# CONFIG_SA1100_GRAPHICSCLIENT is not set
+# CONFIG_SA1100_JORNADA720 is not set
+# CONFIG_SA1100_HUW_WEBPANEL is not set
+# CONFIG_SA1100_ITSY is not set
+# CONFIG_SA1100_LART is not set
+# CONFIG_SA1100_NANOENGINE is not set
+# CONFIG_SA1100_OMNIMETER is not set
+# CONFIG_SA1100_PANGOLIN is not set
+# CONFIG_SA1100_PLEB is not set
+# CONFIG_SA1100_SHERMAN is not set
+# CONFIG_SA1100_PFS168 is not set
+# CONFIG_SA1100_VICTOR is not set
+# CONFIG_SA1100_XP860 is not set
+# CONFIG_SA1100_YOPY is not set
+# CONFIG_SA1100_USB is not set
+# CONFIG_SA1100_USB_NETLINK is not set
+# CONFIG_SA1100_USB_CHAR is not set
+
+#
+# LinkUp 7200/7205/7210 Implementations
+#
+# CONFIG_L7205SDB is not set
+# CONFIG_IRIS_16MB is not set
+# CONFIG_IRIS_32MB is not set
+# CONFIG_NO_FLASH_BOOT_PARAM is not set
+# CONFIG_IRIS is not set
+
+#
+# CLPS711X/EP721X Implementations
+#
+# CONFIG_ARCH_P720T is not set
+# CONFIG_ARCH_ACORN is not set
+# CONFIG_FOOTBRIDGE is not set
+# CONFIG_FOOTBRIDGE_HOST is not set
+# CONFIG_FOOTBRIDGE_ADDIN is not set
+CONFIG_CPU_32=y
+# CONFIG_CPU_26 is not set
+
+#
+# Processor Type
+#
+# CONFIG_CPU_32v3 is not set
+CONFIG_CPU_32v4=y
+# CONFIG_CPU_ARM610 is not set
+# CONFIG_CPU_ARM710 is not set
+# CONFIG_CPU_ARM720T is not set
+# CONFIG_CPU_ARM920T is not set
+# CONFIG_CPU_ARM1020 is not set
+# CONFIG_CPU_SA110 is not set
+CONFIG_CPU_SA1100=y
+CONFIG_DISCONTIGMEM=y
+# CONFIG_CPU_BIG_ENDIAN is not set
+
+#
+# General setup
+#
+# CONFIG_PCI is not set
+# CONFIG_ISA is not set
+# CONFIG_ISA_DMA is not set
+# CONFIG_CPU_FREQ is not set
+CONFIG_HOTPLUG=y
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=y
+# CONFIG_I82365 is not set
+# CONFIG_TCIC is not set
+# CONFIG_PCMCIA_CLPS6700 is not set
+CONFIG_PCMCIA_SA1100=y
+CONFIG_NET=y
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_XIP_ROM is not set
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_KCORE_ELF=y
+# CONFIG_KCORE_AOUT is not set
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_PM=y
+CONFIG_APM=y
+# CONFIG_APM_IGNORE_USER_SUSPEND is not set
+CONFIG_APM_CPU_IDLE=y
+CONFIG_APM_DISPLAY_BLANK=y
+CONFIG_APM_RTC_IS_GMT=y
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE="mem=20M root=/dev/mtdblock4"
+# CONFIG_PFS168_CMDLINE is not set
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+CONFIG_FREEPG_SIGNAL=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_BOOTLDR_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_AMDSTD is not set
+# CONFIG_MTD_SHARP is not set
+# CONFIG_MTD_SHARP16 is not set
+CONFIG_MTD_COLLIE=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_JEDEC is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_SUN_UFLASH is not set
+# CONFIG_MTD_NORA is not set
+# CONFIG_MTD_PNC2000 is not set
+# CONFIG_MTD_RPXLITE is not set
+# CONFIG_MTD_SC520CDP is not set
+# CONFIG_MTD_NETSC520 is not set
+# CONFIG_MTD_SBC_GXX is not set
+# CONFIG_MTD_ELAN_104NC is not set
+CONFIG_MTD_SA1100=y
+# CONFIG_MTD_L7200 is not set
+# CONFIG_MTD_SA1100_REDBOOT_PARTITIONS is not set
+# CONFIG_MTD_SA1100_BOOTLDR_PARTITIONS is not set
+# CONFIG_MTD_DC21285 is not set
+# CONFIG_MTD_IQ80310 is not set
+# CONFIG_MTD_DBOX2 is not set
+# CONFIG_MTD_CSTM_MIPS_IXX is not set
+# CONFIG_MTD_CFI_FLAGADM is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_MIXMEM is not set
+# CONFIG_MTD_OCTAGON is not set
+# CONFIG_MTD_VMAX is not set
+# CONFIG_MTD_OCELOT is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_MTDROM_L7200 is not set
+# CONFIG_MTD_MTDRAM_L7200 is not set
+# CONFIG_MTD_MTDROM_SA1100 is not set
+CONFIG_MTD_MTDRAM_SA1100=y
+CONFIG_MTDRAM_TOTAL_SIZE=12288
+CONFIG_MTDRAM_ERASE_SIZE=1
+CONFIG_MTDRAM_ABS_POS=C1400000
+# CONFIG_MTD_MTDRAM is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC1000 is not set
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOCPROBE is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+CONFIG_BLK_DEV_LOOP=m
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=m
+CONFIG_BLK_DEV_RAM_SIZE=1024
+# CONFIG_BLK_DEV_INITRD is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_BLK_DEV_LVM is not set
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_NETLINK=y
+# CONFIG_RTNETLINK is not set
+# CONFIG_NETLINK_DEV is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_FILTER is not set
+CONFIG_UNIX=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_INET_ECN is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_IPV6 is not set
+# CONFIG_KHTTPD is not set
+# CONFIG_ATM is not set
+
+#
+#  
+#
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_LLC is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_SUNLANCE is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNLANCE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_NET_PCI is not set
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_ACENIC_OMIT_TIGON_I is not set
+# CONFIG_MYRI_SBUS is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=y
+# CONFIG_PPP_SYNC_TTY is not set
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+# CONFIG_PPPOE is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# PCMCIA network device support
+#
+CONFIG_NET_PCMCIA=y
+# CONFIG_PCMCIA_3C589 is not set
+# CONFIG_PCMCIA_3C574 is not set
+# CONFIG_PCMCIA_FMVJ18X is not set
+CONFIG_PCMCIA_PCNET=y
+# CONFIG_PCMCIA_NMCLAN is not set
+# CONFIG_PCMCIA_SMC91C92 is not set
+# CONFIG_PCMCIA_XIRC2PS is not set
+# CONFIG_ARCNET_COM20020_CS is not set
+# CONFIG_PCMCIA_IBMTR is not set
+# CONFIG_NET_PCMCIA_RADIO is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+CONFIG_IRDA=y
+
+#
+# IrDA protocols
+#
+# CONFIG_IRLAN is not set
+# CONFIG_IRNET is not set
+CONFIG_IRCOMM=y
+# CONFIG_IRDA_ULTRA is not set
+# CONFIG_IRDA_OPTIONS is not set
+
+#
+# Infrared-port device drivers
+#
+
+#
+# SIR device drivers
+#
+CONFIG_IRTTY_SIR=y
+CONFIG_IRPORT_SIR=y
+
+#
+# Dongle support
+#
+# CONFIG_DONGLE is not set
+
+#
+# FIR device drivers
+#
+# CONFIG_USB_IRDA is not set
+# CONFIG_NSC_FIR is not set
+# CONFIG_WINBOND_FIR is not set
+# CONFIG_TOSHIBA_FIR is not set
+# CONFIG_SMC_IRCC_FIR is not set
+CONFIG_SA1100_FIR=y
+
+#
+# ATA/IDE/MFM/RLL support
+#
+CONFIG_IDE=y
+
+#
+# IDE, ATA and ATAPI Block devices
+#
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_HD_IDE is not set
+# CONFIG_BLK_DEV_HD is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDEDISK_VENDOR is not set
+# CONFIG_BLK_DEV_IDEDISK_FUJITSU is not set
+# CONFIG_BLK_DEV_IDEDISK_IBM is not set
+# CONFIG_BLK_DEV_IDEDISK_MAXTOR is not set
+# CONFIG_BLK_DEV_IDEDISK_QUANTUM is not set
+# CONFIG_BLK_DEV_IDEDISK_SEAGATE is not set
+# CONFIG_BLK_DEV_IDEDISK_WD is not set
+# CONFIG_BLK_DEV_COMMERIAL is not set
+# CONFIG_BLK_DEV_TIVO is not set
+CONFIG_BLK_DEV_IDECS=y
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+
+#
+# IDE chipset support/bugfixes
+#
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_CMD640_ENHANCED is not set
+# CONFIG_BLK_DEV_ISAPNP is not set
+# CONFIG_IDE_CHIPSETS is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_DMA_NONPCI is not set
+# CONFIG_BLK_DEV_IDE_MODES is not set
+
+#
+# SCSI support
+#
+# CONFIG_SCSI is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+# CONFIG_I2O_BLOCK is not set
+# CONFIG_I2O_LAN is not set
+# CONFIG_I2O_SCSI is not set
+# CONFIG_I2O_PROC is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input core support
+#
+# CONFIG_INPUT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+# CONFIG_VT_CONSOLE is not set
+CONFIG_SERIAL=m
+# CONFIG_SERIAL_FORCE16550A is not set
+# CONFIG_SERIAL_EXTENDED is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_SERIAL_21285 is not set
+# CONFIG_SERIAL_21285_OLD is not set
+# CONFIG_SERIAL_21285_CONSOLE is not set
+# CONFIG_SERIAL_SA1100 is not set
+# CONFIG_SERIAL_SA1100_OLD is not set
+# CONFIG_SERIAL_SA1100_CONSOLE is not set
+CONFIG_SA1100_DEFAULT_BAUDRATE=9600
+CONFIG_SERIAL_COLLIE=y
+# CONFIG_SERIAL_COLLIE_CONSOLE is not set
+CONFIG_COLLIE_DEFAULT_BAUDRATE=9600
+# CONFIG_SERIAL_AMBA is not set
+# CONFIG_SERIAL_AMBA_CONSOLE is not set
+# CONFIG_SERIAL_CLPS711X is not set
+# CONFIG_SERIAL_CLPS711X_CONSOLE is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=32
+CONFIG_UCB1200=y
+CONFIG_TOUCHSCREEN_UCB1200=y
+# CONFIG_AUDIO_UCB1200 is not set
+# CONFIG_ADC_UCB1200 is not set
+# CONFIG_TOUCHSCREEN_BITSY is not set
+# CONFIG_PROFILER is not set
+# CONFIG_PFS168_SPI is not set
+# CONFIG_PFS168_DTMF is not set
+# CONFIG_PFS168_MISC is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_JOYSTICK is not set
+
+#
+# Input core support is needed for joysticks
+#
+# CONFIG_QIC02_TAPE is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_INTEL_RNG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+CONFIG_SA1100_RTC=y
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+CONFIG_PCMCIA_SERIAL_CS=m
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FS_SYNC=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_BFS_FS is not set
+CONFIG_FAT_FS=m
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+CONFIG_VFAT_FS=m
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_CRAMFS=m
+# CONFIG_TMPFS is not set
+CONFIG_RAMFS=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+CONFIG_MINIX_FS=m
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+CONFIG_NFS_FS=m
+CONFIG_NFS_V3=y
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFSD is not set
+# CONFIG_NFSD_V3 is not set
+CONFIG_SUNRPC=m
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_SMB_FS=m
+CONFIG_SMB_NLS_DEFAULT=y
+CONFIG_SMB_NLS_REMOTE="cp437"
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_SMB_NLS=y
+CONFIG_NLS=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Console drivers
+#
+CONFIG_PC_KEYMAP=y
+# CONFIG_VGA_CONSOLE is not set
+
+#
+# Frame-buffer support
+#
+CONFIG_FB=y
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FB_L7200 is not set
+# CONFIG_FB_IRIS is not set
+CONFIG_FB_COLLIE=y
+# CONFIG_COLLIE_LOGO_SCREEN is not set
+# CONFIG_FB_ACORN is not set
+# CONFIG_FB_CLPS711X is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_EPSON1356 is not set
+# CONFIG_FB_SA1100 is not set
+# CONFIG_FB_ANAKIN is not set
+# CONFIG_FB_E1355 is not set
+# CONFIG_FB_VIRTUAL is not set
+CONFIG_FBCON_ADVANCED=y
+# CONFIG_FBCON_MFB is not set
+# CONFIG_FBCON_CFB2 is not set
+# CONFIG_FBCON_CFB4 is not set
+# CONFIG_FBCON_CFB8 is not set
+CONFIG_FBCON_CFB16=y
+# CONFIG_FBCON_CFB24 is not set
+# CONFIG_FBCON_CFB32 is not set
+# CONFIG_FBCON_AFB is not set
+# CONFIG_FBCON_ILBM is not set
+# CONFIG_FBCON_IPLAN2P2 is not set
+# CONFIG_FBCON_IPLAN2P4 is not set
+# CONFIG_FBCON_IPLAN2P8 is not set
+# CONFIG_FBCON_MAC is not set
+# CONFIG_FBCON_VGA_PLANES is not set
+# CONFIG_FBCON_VGA is not set
+# CONFIG_FBCON_HGA is not set
+CONFIG_FBCON_ROTATE_R=y
+# CONFIG_FBCON_ROTATE_L is not set
+# CONFIG_FBCON_FONTWIDTH8_ONLY is not set
+CONFIG_FBCON_FONTS=y
+CONFIG_FONT_8x8=y
+# CONFIG_FONT_8x16 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+# CONFIG_SOUND_ASSABET_UDA1341 is not set
+# CONFIG_SOUND_BITSY_UDA1341 is not set
+# CONFIG_SOUND_SA1111_UDA1341 is not set
+# CONFIG_SOUND_SA1100SSP is not set
+CONFIG_SOUND_COLLIE_SSP=y
+CONFIG_COLLIE_PCM1741=y
+# CONFIG_COLLIE_PCM1717 is not set
+# CONFIG_SOUND_CMPCI is not set
+# CONFIG_SOUND_EMU10K1 is not set
+# CONFIG_SOUND_FUSION is not set
+# CONFIG_SOUND_CS4281 is not set
+# CONFIG_SOUND_ES1370 is not set
+# CONFIG_SOUND_ES1371 is not set
+# CONFIG_SOUND_ESSSOLO1 is not set
+# CONFIG_SOUND_MAESTRO is not set
+# CONFIG_SOUND_MAESTRO3 is not set
+# CONFIG_SOUND_ICH is not set
+# CONFIG_SOUND_SONICVIBES is not set
+# CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+# CONFIG_SOUND_VIA82CXXX is not set
+# CONFIG_MIDI_VIA82CXXX is not set
+# CONFIG_SOUND_OSS is not set
+# CONFIG_SOUND_TVMIXER is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# USB Device Support
+#
+CONFIG_USBD=m
+CONFIG_USBD_VENDORID=4dd
+CONFIG_USBD_PRODUCTID=8002
+CONFIG_USBD_PRODUCT_NAME="SL Series"
+CONFIG_USBD_MANUFACTURER="Sharp"
+CONFIG_USBD_USE_SERIAL_NUMBER=y
+CONFIG_USBD_SERIAL_NUMBER_STR="A01234"
+CONFIG_USBD_SELFPOWERED=y
+CONFIG_USBD_MONITOR=m
+
+#
+# 
+#
+CONFIG_USBD_PROCFS=y
+
+#
+# USB Device functions --
+#
+
+#
+# Network Function
+#
+CONFIG_USBD_NET=m
+CONFIG_USBD_NET_VENDORID=4DD
+CONFIG_USBD_NET_PRODUCTID=8004
+CONFIG_USBD_NET_IFNAME="usbd"
+CONFIG_USBD_NET_OUT_ENDPOINT=1
+CONFIG_USBD_NET_OUT_PKTSIZE=64
+CONFIG_USBD_NET_IN_ENDPOINT=2
+CONFIG_USBD_NET_IN_PKTSIZE=64
+# CONFIG_USBD_NET_ALWAYSUP is not set
+CONFIG_USBD_NET_CDC=y
+CONFIG_USBD_NET_REMOTE_MACADDR="400002000001"
+CONFIG_USBD_NET_REMOTE_OUI=400002
+CONFIG_USBD_NET_LOCAL_MACADDR="400001000001"
+CONFIG_USBD_NET_LOCAL_OUI=400001
+
+#
+# Serial Function
+#
+CONFIG_USBD_SERIAL=m
+CONFIG_USBD_SERIAL_VENDORID=4dd
+CONFIG_USBD_SERIAL_PRODUCTID=8002
+# CONFIG_USBD_SERIAL_CDC is not set
+CONFIG_USBD_SERIAL_OUT_ENDPOINT=1
+CONFIG_USBD_SERIAL_IN_PKTSIZE=64
+CONFIG_USBD_SERIAL_IN_ENDPOINT=2
+CONFIG_USBD_SERIAL_OUT_PKTSIZE=64
+# CONFIG_USBD_SERIAL_SAFE is not set
+
+#
+# USB Device bus interfaces --
+#
+
+#
+# Intel StrongArm SA-1110 Bus Interface Driver
+#
+CONFIG_USBD_SA1100_BUS=m
+# CONFIG_SA1100_NEW_DMA_COOPERATION is not set
+CONFIG_USBD_STALL_TIMEOUT=0
+CONFIG_USBD_STALL_DISCONNECT_DURATION=2
+# CONFIG_USBD_TRAFFIC_KEEPAWAKE is not set
+
+#
+# Generic Bus Interface
+#
+# CONFIG_USBD_GENERIC_BUS is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BLUEZ is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_NO_FRAME_POINTER is not set
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_INFO is not set
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_NO_PGT_CACHE is not set
+# CONFIG_DEBUG_LL is not set
+# CONFIG_DEBUG_DC21285_PORT is not set
+# CONFIG_DEBUG_CLPS711X_UART2 is not set
diff -Nur linux/drivers/mtd/Config.in /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/mtd/Config.in
--- linux/drivers/mtd/Config.in	2003-05-13 16:18:19.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/mtd/Config.in	2003-06-23 01:47:03.000000000 +0700
@@ -14,6 +14,7 @@
    dep_tristate '  MTD partitioning support' CONFIG_MTD_PARTITIONS $CONFIG_MTD
    dep_tristate '  MTD concatenating support' CONFIG_MTD_CONCAT $CONFIG_MTD
    dep_tristate '  RedBoot partition table parsing' CONFIG_MTD_REDBOOT_PARTS $CONFIG_MTD_PARTITIONS
+   dep_tristate	'  Cacko Hybrid partition table' CONFIG_CACKO_HYBRID_PARTITIONS $CONFIG_MTD_PARTITIONS $CONFIG_SA1100_COLLIE
    dep_tristate '  Command line partition table parsing' CONFIG_MTD_CMDLINE_PARTS $CONFIG_MTD_PARTITIONS
    if [ "$CONFIG_ARM" = "y" ]; then
       dep_tristate '  ARM Firmware Suite partition parsing' CONFIG_MTD_AFS_PARTS $CONFIG_MTD_PARTITIONS
diff -Nur linux/drivers/mtd/chips/Config.in /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/mtd/chips/Config.in
--- linux/drivers/mtd/chips/Config.in	2003-05-13 16:18:19.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/mtd/chips/Config.in	2003-06-23 01:47:03.000000000 +0700
@@ -49,6 +49,7 @@
 dep_tristate '  Support for RAM chips in bus mapping' CONFIG_MTD_RAM $CONFIG_MTD
 dep_tristate '  Support for ROM chips in bus mapping' CONFIG_MTD_ROM $CONFIG_MTD
 dep_tristate '  Support for absent chips in bus mapping' CONFIG_MTD_ABSENT $CONFIG_MTD
+dep_tristate '  pre-CFI Sharp (32) chip support (Collie)' CONFIG_MTD_COLLIE $CONFIG_MTD
 
 bool '  Older (theoretically obsoleted now) drivers for non-CFI chips' CONFIG_MTD_OBSOLETE_CHIPS
 dep_tristate '  AMD compatible flash chip support (non-CFI)' CONFIG_MTD_AMDSTD $CONFIG_MTD $CONFIG_MTD_OBSOLETE_CHIPS
diff -Nur linux/drivers/mtd/chips/Makefile /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/mtd/chips/Makefile
--- linux/drivers/mtd/chips/Makefile	2003-05-13 16:18:19.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/mtd/chips/Makefile	2003-06-23 01:47:03.000000000 +0700
@@ -25,6 +25,7 @@
 obj-$(CONFIG_MTD_RAM)		+= map_ram.o
 obj-$(CONFIG_MTD_ROM)		+= map_rom.o
 obj-$(CONFIG_MTD_SHARP)		+= sharp.o
+obj-$(CONFIG_MTD_COLLIE)	+= collie_sharp.o
 obj-$(CONFIG_MTD_ABSENT)	+= map_absent.o
 
 include $(TOPDIR)/Rules.make
diff -Nur linux/drivers/mtd/chips/collie_sharp.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/mtd/chips/collie_sharp.c
--- linux/drivers/mtd/chips/collie_sharp.c	1970-01-01 07:00:00.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/mtd/chips/collie_sharp.c	2003-06-23 01:47:03.000000000 +0700
@@ -0,0 +1,731 @@
+/*
+ * MTD chip driver for non-CFI Sharp flash chips
+ *
+ * Copyright 2000,2001 David A. Schleef <ds@schleef.org>
+ *           2000,2001 Lineo, Inc.
+ *
+ * $Id: sharp.c,v 1.4 2001/04/29 16:21:17 dwmw2 Exp $
+ *
+ * Devices supported:
+ *   LH28F016SCT Symmetrical block flash memory, 2Mx8
+ *   LH28F008SCT Symmetrical block flash memory, 1Mx8
+ *
+ * Documentation:
+ *   http://www.sharpmeg.com/datasheets/memic/flashcmp/
+ *   http://www.sharpmeg.com/datasheets/memic/flashcmp/01symf/16m/016sctl9.pdf
+ *   016sctl9.pdf
+ *
+ * Limitations:
+ *   This driver only supports 4x1 arrangement of chips.
+ *   Not tested on anything but PowerPC.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/cfi.h>
+#include <linux/delay.h>
+#include <asm/hardware.h>
+
+#define CMD_RESET		0xffffffff
+#define CMD_READ_ID		0x90909090
+#define CMD_READ_STATUS		0x70707070
+#define CMD_CLEAR_STATUS	0x50505050
+#define CMD_BLOCK_ERASE_1	0x20202020
+#define CMD_BLOCK_ERASE_2	0xd0d0d0d0
+#define CMD_BYTE_WRITE		0x40404040
+#define CMD_SUSPEND		0xb0b0b0b0
+#define CMD_RESUME		0xd0d0d0d0
+#define CMD_SET_BLOCK_LOCK_1	0x60606060
+#define CMD_SET_BLOCK_LOCK_2	0x01010101
+#define CMD_SET_MASTER_LOCK_1	0x60606060
+#define CMD_SET_MASTER_LOCK_2	0xf1f1f1f1
+#define CMD_CLEAR_BLOCK_LOCKS_1	0x60606060
+#define CMD_CLEAR_BLOCK_LOCKS_2	0xd0d0d0d0
+
+#define SR_READY		0x80808080 // 1 = ready
+#define SR_ERASE_SUSPEND	0x40404040 // 1 = block erase suspended
+#define SR_ERROR_ERASE		0x20202020 // 1 = error in block erase or clear lock bits
+#define SR_ERROR_WRITE		0x10101010 // 1 = error in byte write or set lock bit
+#define	SR_VPP			0x08080808 // 1 = Vpp is low
+#define SR_WRITE_SUSPEND	0x04040404 // 1 = byte write suspended
+#define SR_PROTECT		0x02020202 // 1 = lock bit set
+#define SR_RESERVED		0x01010101
+
+#define SR_ERRORS (SR_ERROR_ERASE|SR_ERROR_WRITE|SR_VPP|SR_PROTECT)
+
+#define	BLOCK_MASK		0xfffe0000
+/* Configuration options */
+
+//#undef AUTOUNLOCK  /* automatically unlocks blocks before erasing */
+#define AUTOUNLOCK
+struct mtd_info *collie_probe(struct map_info *);
+
+static int collie_probe_map(struct map_info *map,struct mtd_info *mtd);
+
+static int collie_read(struct mtd_info *mtd, loff_t from, size_t len,
+	size_t *retlen, u_char *buf);
+static int collie_write(struct mtd_info *mtd, loff_t from, size_t len,
+	size_t *retlen, const u_char *buf);
+static int collie_erase(struct mtd_info *mtd, struct erase_info *instr);
+static void collie_sync(struct mtd_info *mtd);
+static int collie_suspend(struct mtd_info *mtd);
+static void collie_resume(struct mtd_info *mtd);
+static void collie_destroy(struct mtd_info *mtd);
+
+static int collie_write_oneword(struct map_info *map, struct flchip *chip,
+	unsigned long adr, __u32 datum);
+static int collie_erase_oneblock(struct map_info *map, struct flchip *chip,
+	unsigned long adr);
+#ifdef AUTOUNLOCK
+static inline void collie_unlock_oneblock(struct map_info *map, struct flchip *chip,
+	unsigned long adr);
+#endif
+
+
+struct collie_info{
+	struct flchip *chip;
+	int bogus;
+	int chipshift;
+	int numchips;
+	struct flchip chips[1];
+};
+
+struct mtd_info *collie_probe(struct map_info *map);
+static void collie_destroy(struct mtd_info *mtd);
+
+static struct mtd_chip_driver collie_chipdrv = {
+	probe: collie_probe,
+	destroy: collie_destroy,
+	name: "collie",
+	module: THIS_MODULE
+};
+static void collie_udelay(unsigned long i){
+	if (in_interrupt()) {
+		udelay(i);
+	} else {
+		schedule();
+	}
+
+}
+struct mtd_info *collie_probe(struct map_info *map)
+{
+	struct mtd_info *mtd = NULL;
+	struct collie_info *collie = NULL;
+	int width;
+
+	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
+	if(!mtd)
+		return NULL;
+
+	collie = kmalloc(sizeof(*collie), GFP_KERNEL);
+	if(!collie)
+		return NULL;
+
+	memset(mtd, 0, sizeof(*mtd));
+
+	width = collie_probe_map(map,mtd);
+	if(!width){
+		kfree(mtd);
+		kfree(collie);
+		return NULL;
+	}
+	//MSC0 = 0xfff8e352;
+        MSC0 = 0xfff8fff8;
+
+	mtd->priv = map;
+	mtd->type = MTD_NORFLASH;
+	mtd->erase = collie_erase;
+	mtd->read = collie_read;
+	mtd->write = collie_write;
+	mtd->sync = collie_sync;
+	mtd->suspend = collie_suspend;
+	mtd->resume = collie_resume;
+	mtd->flags = MTD_CAP_NORFLASH;
+	mtd->name = map->name;
+
+	memset(collie, 0, sizeof(*collie));
+
+	//collie->chipshift = 23;
+	collie->chipshift = 24;
+	collie->numchips = 1;
+	collie->chips[0].start = 0;
+	collie->chips[0].state = FL_READY;
+	collie->chips[0].mutex = &collie->chips[0]._spinlock;
+	collie->chips[0].word_write_time = 0;
+	init_waitqueue_head(&collie->chips[0].wq);
+	spin_lock_init(&collie->chips[0]._spinlock);
+
+	map->fldrv = &collie_chipdrv;
+	map->fldrv_priv = collie;
+
+	MOD_INC_USE_COUNT;
+	return mtd;
+}
+
+static int collie_probe_map(struct map_info *map,struct mtd_info *mtd)
+{
+	unsigned long tmp;
+	unsigned long base = 0;
+	u32 read0, read4;
+	int width = 4;
+
+	tmp = map->read32(map, base+0);
+
+	map->write32(map, CMD_READ_ID, base+0);
+
+	read0=map->read32(map, base+0);
+	read4=map->read32(map, base+4);
+	//if(read0 == 0x89898989){
+	if(read0 == 0x00b000b0){
+		//printk("Looks like collie flash\n");
+		switch(read4){
+		case 0xaaaaaaaa:
+		case 0xa0a0a0a0:
+			/* aa - LH28F016SCT-L95 2Mx8, 32 64k blocks*/
+			/* a0 - LH28F016SCT-Z4  2Mx8, 32 64k blocks*/
+			mtd->erasesize = 0x10000 * width;
+			mtd->size = 0x200000 * width;
+			return width;
+		case 0xa6a6a6a6:
+			/* a6 - LH28F008SCT-L12 1Mx8, 16 64k blocks*/
+			/* a6 - LH28F008SCR-L85 1Mx8, 16 64k blocks*/
+			mtd->erasesize = 0x10000 * width;
+			mtd->size = 0x100000 * width;
+			return width;
+		case 0x00b000b0:
+			/* a6 - LH28F640BFHE 8 64k * 2 chip blocks*/
+			mtd->erasesize = 0x10000 * width / 2;
+			mtd->size = 0x800000 * width / 2;
+			return width;
+#if 0
+		case 0x00000000: /* unknown */
+			/* XX - LH28F004SCT 512kx8, 8 64k blocks*/
+			mtd->erasesize = 0x10000 * width;
+			mtd->size = 0x100000 * width;
+			return width;
+#endif
+		default:
+			printk("Sort-of looks like collie flash, 0x%08x 0x%08x\n",
+				read0,read4);
+		}
+	}else if((map->read32(map, base+0) == CMD_READ_ID)){
+		/* RAM, probably */
+		printk("Looks like RAM\n");
+		map->write32(map, tmp, base+0);
+	}else{
+		printk("Doesn't look like collie flash, 0x%08x 0x%08x\n",
+			read0,read4);
+	}
+
+	return 0;
+}
+
+/* This function returns with the chip->mutex lock held. */
+static inline int collie_wait(struct map_info *map, struct flchip *chip)
+{
+	__u32 status;
+	unsigned long timeo = jiffies + HZ;
+	DECLARE_WAITQUEUE(wait, current);
+	int adr = 0;
+
+	//timeo = jiffies + HZ * 10;
+retry:
+	spin_lock_bh(chip->mutex);
+
+	switch(chip->state){
+	case FL_READY:
+		map->write32(map,CMD_READ_STATUS,adr);
+		chip->state = FL_STATUS;
+	case FL_STATUS:
+		status = map->read32(map,adr);
+		if((status & SR_READY)==SR_READY)
+			break;
+		//printk(".status=%08x\n",status);
+		spin_unlock_bh(chip->mutex);
+		if (time_after(jiffies, timeo)) {
+			printk("Waiting for chip to be ready timed out in erase\n");
+			return -EIO;	
+		}
+		collie_udelay(1);
+		goto retry;
+	default:
+		//printk("Waiting for chip\n");
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+
+		spin_unlock_bh(chip->mutex);
+
+		//schedule();
+		collie_udelay(1);
+
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&chip->wq, &wait);
+
+		if(signal_pending(current))
+			return -EINTR;
+
+		timeo = jiffies + HZ;
+
+		goto retry;
+	}
+
+	map->write32(map,CMD_RESET, adr);
+
+	chip->state = FL_READY;
+
+	return 0;
+}
+
+static void collie_release(struct flchip *chip)
+{
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+}
+
+static int collie_read(struct mtd_info *mtd, loff_t from, size_t len,
+	size_t *retlen, u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct collie_info *collie = map->fldrv_priv;
+	int chipnum;
+	int ret = 0;
+	int ofs = 0;
+
+	chipnum = (from >> collie->chipshift);
+	ofs = from & ((1 << collie->chipshift)-1);
+
+	*retlen = 0;
+
+	while(len){
+		unsigned long thislen;
+
+		if(chipnum>=collie->numchips)
+			break;
+
+		thislen = len;
+		if(ofs+thislen >= (1<<collie->chipshift))
+			thislen = (1<<collie->chipshift) - ofs;
+
+		ret = collie_wait(map,&collie->chips[chipnum]);
+		if(ret<0)
+			break;
+
+		map->copy_from(map,buf,ofs,thislen);
+
+		collie_release(&collie->chips[chipnum]);
+
+		*retlen += thislen;
+		len -= thislen;
+		buf += thislen;
+
+		ofs = 0;
+		chipnum++;
+	}
+	return ret;
+}
+
+static int collie_write(struct mtd_info *mtd, loff_t to, size_t len,
+	size_t *retlen, const u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct collie_info *collie = map->fldrv_priv;
+	int ret = 0;
+	int i,j;
+	int chipnum;
+	unsigned long ofs;
+	union { u32 l; unsigned char uc[4]; } tbuf;
+
+	*retlen = 0;
+
+	while(len){
+		tbuf.l = 0xffffffff;
+		chipnum = to >> collie->chipshift;
+		ofs = to & ((1<<collie->chipshift)-1);
+
+		j=0;
+		for(i=ofs&3;i<4 && len;i++){
+			tbuf.uc[i] = *buf;
+			buf++;
+			to++;
+			len--;
+			j++;
+		}
+		collie_write_oneword(map, &collie->chips[chipnum], ofs&~3, tbuf.l);
+		if(ret<0)
+			return ret;
+		(*retlen)+=j;
+	}
+
+	return 0;
+}
+
+static int collie_write_oneword(struct map_info *map, struct flchip *chip,
+	unsigned long adr, __u32 datum)
+{
+	int ret;
+	int try;
+	int i;
+	u32 status = 0;
+
+	ret = collie_wait(map,chip);
+	if(ret<0)
+		return ret;
+
+	for(try=0;try<10;try++){
+		map->write32(map,CMD_BYTE_WRITE,adr);
+		/* cpu_to_le32 -> hack to fix the writel be->le conversion */
+		map->write32(map,cpu_to_le32(datum),adr);
+
+		chip->state = FL_WRITING;
+
+		map->write32(map,CMD_READ_STATUS,adr);
+
+		for(i=0;i<100;i++){
+			status = map->read32(map,adr);
+			if((status & SR_READY)==SR_READY)
+				break;
+		}
+
+#ifdef AUTOUNLOCK
+		if (status & SR_PROTECT){ /* lock block */
+#if 0
+			map->write32(map,CMD_CLEAR_BLOCK_LOCKS_1,adr);
+			map->write32(map,CMD_CLEAR_BLOCK_LOCKS_2,adr);
+#else
+			map->write32(map,CMD_CLEAR_STATUS,adr);
+			//map->write32(map,CMD_RESET,adr);
+
+			collie_unlock_oneblock(map,chip,adr);
+
+			map->write32(map,CMD_CLEAR_STATUS,adr);
+			map->write32(map,CMD_RESET,adr);
+
+#endif
+			continue;
+		}
+#endif
+		if(i==100){
+			printk("collie: timed out writing\n");
+		}
+
+		if(!(status&SR_ERRORS))
+			break;
+
+		printk("collie: error writing byte at addr=%08lx status=%08x\n",adr,status);
+
+		map->write32(map,CMD_CLEAR_STATUS,adr);
+	}
+	map->write32(map,CMD_RESET,adr);
+	chip->state = FL_READY;
+
+	collie_release(chip);
+
+	return 0;
+}
+
+static int collie_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct map_info *map = mtd->priv;
+	struct collie_info *collie = map->fldrv_priv;
+	unsigned long adr,len;
+	int chipnum, ret=0;
+
+//printk("collie_erase()\n");
+	if(instr->addr & (mtd->erasesize - 1))
+		return -EINVAL;
+	if(instr->len & (mtd->erasesize - 1))
+		return -EINVAL;
+	if(instr->len + instr->addr > mtd->size)
+		return -EINVAL;
+
+	chipnum = instr->addr >> collie->chipshift;
+	adr = instr->addr & ((1<<collie->chipshift)-1);
+	len = instr->len;
+//printk("--+* erase adr %08x [%08x]\n",adr,len);
+	while(len){
+		ret = collie_erase_oneblock(map, &collie->chips[chipnum], adr);
+		if(ret)return ret;
+		if (adr >= 0xfe0000) {
+			adr += mtd->erasesize / 8;
+			len -= mtd->erasesize / 8;
+		} else {
+
+			adr += mtd->erasesize;
+			len -= mtd->erasesize;
+		}
+		if(adr >> collie->chipshift){
+			adr = 0;
+			chipnum++;
+			if(chipnum>=collie->numchips)
+				break;
+		}
+	}
+	instr->state = MTD_ERASE_DONE;
+	if(instr->callback)
+		instr->callback(instr);
+//printk("--+* erase end %08x \n\n",adr);
+
+	return 0;
+}
+
+static inline int collie_do_wait_for_ready(struct map_info *map, struct flchip *chip,
+	unsigned long adr)
+{
+	int ret;
+	int timeo;
+	int status;
+	DECLARE_WAITQUEUE(wait, current);
+
+	map->write32(map,CMD_READ_STATUS,adr);
+	status = map->read32(map,adr);
+
+	timeo = jiffies + HZ * 10;
+
+	while(jiffies<timeo){
+		map->write32(map,CMD_READ_STATUS,adr);
+		status = map->read32(map,adr);
+		if((status & SR_READY)==SR_READY){
+			ret = 0;
+			goto out;
+		}
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+
+		spin_unlock_bh(chip->mutex);
+
+		schedule_timeout(1);
+		schedule();
+
+		spin_lock_bh(chip->mutex);
+
+		remove_wait_queue(&chip->wq, &wait);
+		set_current_state(TASK_RUNNING);
+#if 0
+		if (signal_pending(current)){
+			ret = -EINTR;
+			goto out;
+		}
+#endif
+		
+	}
+	ret = -ETIME;
+out:
+	return ret;
+}
+
+static int collie_erase_oneblock(struct map_info *map, struct flchip *chip,
+	unsigned long adr)
+{
+	int ret;
+	//int timeo;
+	int status;
+	//int i;
+
+	//printk("collie_erase_oneblock()\n");
+
+	ret = collie_wait(map,chip);
+	if (ret <0)
+		return ret;
+#ifdef AUTOUNLOCK
+	/* This seems like a good place to do an unlock */
+	collie_unlock_oneblock(map,chip,adr);
+#endif
+
+	map->write32(map,CMD_BLOCK_ERASE_1,adr);
+	map->write32(map,CMD_BLOCK_ERASE_2,adr);
+
+	chip->state = FL_ERASING;
+
+	ret = collie_do_wait_for_ready(map,chip,adr);
+	if(ret<0){
+		spin_unlock_bh(chip->mutex);
+		return ret;
+	}
+	map->write32(map,CMD_READ_STATUS,adr);
+	status = map->read32(map,adr);
+	if(!(status&SR_ERRORS)){
+		map->write32(map,CMD_RESET,adr);
+		chip->state = FL_READY;
+		spin_unlock_bh(chip->mutex);
+		return 0;
+	}
+
+	printk("collie: error erasing block at addr=%08lx status=%08x\n",adr,status);
+	map->write32(map,CMD_CLEAR_STATUS,adr);
+
+	//wake_up(&chip->wq);
+	//spin_unlock_bh(chip->mutex);
+	
+	collie_release(chip);
+	
+	return -EIO;
+}
+
+#ifdef AUTOUNLOCK
+static inline void collie_unlock_oneblock(struct map_info *map, struct flchip *chip,
+	unsigned long adr)
+{
+	u32 status;
+
+	map->write32(map,CMD_CLEAR_BLOCK_LOCKS_1,adr & BLOCK_MASK);
+	map->write32(map,CMD_CLEAR_BLOCK_LOCKS_2,adr & BLOCK_MASK);
+
+	collie_do_wait_for_ready(map,chip,adr);
+
+	status = map->read32(map,adr);
+	if(!(status&SR_ERRORS)){
+		map->write32(map,CMD_RESET,adr);
+		chip->state = FL_READY;
+		return;
+	}
+
+	printk("collie: error unlocking block at addr=%08lx status=%08x\n",adr,status);
+	map->write32(map,CMD_CLEAR_STATUS,adr);
+}
+#endif
+
+static void collie_sync(struct mtd_info *mtd)
+{
+	//printk("collie_sync()\n");
+}
+
+static int collie_suspend(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct collie_info *collie = map->fldrv_priv;
+	int i;
+	struct flchip *chip;
+	int ret = 0;
+
+	//printk("collie_suspend()\n");
+#if 1
+	for (i=0; !ret && i<collie->numchips; i++) {
+                chip = &collie->chips[i];
+		ret = collie_wait(map,chip);
+
+
+		if (ret){
+			ret = -EAGAIN;
+		} else {
+			chip->state = FL_PM_SUSPENDED;
+			spin_unlock_bh(chip->mutex);
+		}
+	}
+#else
+	for (i=0; !ret && i<collie->numchips; i++) {
+                chip = &collie->chips[i];
+
+                spin_lock_bh(chip->mutex);
+
+                switch(chip->state) {
+		case FL_READY:
+		case FL_STATUS:
+			chip->oldstate = chip->state;
+			chip->state = FL_PM_SUSPENDED;
+			/* No need to wake_up() on this state change -
+			 * as the whole point is that nobody can do anything
+			 * with the chip now anyway.
+			 */
+		case FL_PM_SUSPENDED:
+			break;
+
+		default:
+			ret = -EAGAIN;
+			break;
+		}		
+		spin_unlock_bh(chip->mutex);
+	}
+
+	/* Unlock the chips again */
+	if (ret) {
+		for (i--; i >=0; i--) {
+			chip = &collie->chips[i];
+			
+			spin_lock_bh(chip->mutex);
+			if (chip->state == FL_PM_SUSPENDED) {
+				chip->state = chip->oldstate;
+				wake_up(&chip->wq);
+			}
+			spin_unlock_bh(chip->mutex);
+		}
+	}
+#endif	
+	return ret;
+
+}
+
+static void collie_resume(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct collie_info *collie = map->fldrv_priv;
+	int i;
+	struct flchip *chip;
+	
+	//printk("collie_resume()\n");
+#if 0
+	for (i=0; i<collie->numchips; i++) {
+		chip = &collie->chips[i];
+		if (chip->state == FL_PM_SUSPENDED) {
+			map->write32(map,CMD_RESET,chip->start);
+			chip->state = FL_READY;
+			collie_release(chip);
+		}
+	}
+#else	
+	for (i=0; i<collie->numchips; i++) {
+		chip = &collie->chips[i];
+	
+		spin_lock_bh(chip->mutex);	
+		
+		if (chip->state == FL_PM_SUSPENDED) {
+			/* We need to force it back to a known state. */
+			//cfi_write(map, CMD(0xff), 0);
+			map->write32(map,CMD_RESET,chip->start);
+			chip->state = FL_READY;
+			wake_up(&chip->wq);
+		}
+		
+		spin_unlock_bh(chip->mutex);
+	}
+#endif
+}
+
+static void collie_destroy(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct collie_info *collie = map->fldrv_priv;
+	
+	//printk("collie_destroy()\n");
+	//kfree(collie->cmdset_priv);
+	kfree(collie);
+
+}
+
+#if LINUX_VERSION_CODE < 0x020212 && defined(MODULE)
+#define collie_probe_init init_module
+#define collie_probe_exit cleanup_module
+#endif
+
+int __init collie_probe_init(void)
+{
+	printk("MTD Sharp chip driver <ds@lineo.com>\n");
+
+	register_mtd_chip_driver(&collie_chipdrv);
+
+	return 0;
+}
+
+static void __exit collie_probe_exit(void)
+{
+	unregister_mtd_chip_driver(&collie_chipdrv);
+}
+
+module_init(collie_probe_init);
+module_exit(collie_probe_exit);
+
diff -Nur linux/drivers/mtd/maps/Config.in /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/mtd/maps/Config.in
--- linux/drivers/mtd/maps/Config.in	2003-05-13 16:18:19.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/mtd/maps/Config.in	2003-06-23 01:47:03.000000000 +0700
@@ -76,7 +76,7 @@
    dep_tristate '  CFI Flash device mapped on Nora' CONFIG_MTD_NORA $CONFIG_MTD_CFI
    dep_tristate '  CFI Flash device mapped on ARM Integrator/P720T' CONFIG_MTD_ARM_INTEGRATOR $CONFIG_MTD_CFI
    dep_tristate '  Cirrus CDB89712 evaluation board mappings' CONFIG_MTD_CDB89712 $CONFIG_MTD_CFI $CONFIG_ARCH_CDB89712
-   dep_tristate '  CFI Flash device mapped on StrongARM SA11x0' CONFIG_MTD_SA1100 $CONFIG_MTD_CFI $CONFIG_ARCH_SA1100 $CONFIG_MTD_PARTITIONS
+   dep_tristate '  CFI Flash device mapped on StrongARM SA11x0' CONFIG_MTD_SA1100 $CONFIG_ARCH_SA1100 $CONFIG_MTD_PARTITIONS
    dep_tristate '  CFI Flash device mapped on DC21285 Footbridge' CONFIG_MTD_DC21285 $CONFIG_MTD_CFI $CONFIG_ARCH_FOOTBRIDGE $CONFIG_MTD_PARTITIONS
    dep_tristate '  CFI Flash device mapped on the XScale IQ80310 board' CONFIG_MTD_IQ80310 $CONFIG_MTD_CFI $CONFIG_ARCH_IQ80310
    dep_tristate '  CFI Flash device mapped on the FortuNet board' CONFIG_MTD_FORTUNET $CONFIG_MTD_CFI $CONFIG_MTD_PARTITIONS $CONFIG_ARCH_FORTUNET
diff -Nur linux/drivers/mtd/maps/Makefile /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/mtd/maps/Makefile
--- linux/drivers/mtd/maps/Makefile	2003-05-13 16:18:19.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/mtd/maps/Makefile	2003-06-23 01:47:03.000000000 +0700
@@ -35,6 +35,7 @@
 obj-$(CONFIG_MTD_RPXLITE)	+= rpxlite.o
 obj-$(CONFIG_MTD_TQM8XXL)	+= tqm8xxl.o
 obj-$(CONFIG_MTD_SA1100)        += sa1100-flash.o
+obj-$(CONFIG_MTD_COLLIE)        += sa1100-flash.o
 ifeq ($(CONFIG_ASSABET_NEPONSET),y)
   obj-$(CONFIG_MTD_SA1100)      += neponset-flash.o
 endif
diff -Nur linux/drivers/mtd/maps/sa1100-flash.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/mtd/maps/sa1100-flash.c
--- linux/drivers/mtd/maps/sa1100-flash.c	2003-05-13 16:18:19.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/mtd/maps/sa1100-flash.c	2003-06-23 01:47:03.000000000 +0700
@@ -790,6 +790,73 @@
 };
 #endif
 
+#ifdef CONFIG_SA1100_COLLIE
+#define COLLIE_FLASH_SIZE			0x01000000
+
+static struct mtd_partition collie_partitions[] = {
+        {
+		name:       "Angel Monitor",
+		offset:     0,
+		size:       0x00020000,
+                mask_flags: MTD_WRITEABLE
+        },
+        {
+		name:       "CF Updater",
+                offset: MTDPART_OFS_APPEND,
+		size:       0x00020000,
+                mask_flags: MTD_WRITEABLE
+        },
+        {
+		name:       "Diagnostics",
+                offset: MTDPART_OFS_APPEND,
+		size:       0x00080000,
+                mask_flags: MTD_WRITEABLE
+        },
+        {
+		name:       "kernel",
+                offset: MTDPART_OFS_APPEND,
+		size:       0x00100000,
+        },
+#ifdef CONFIG_CACKO_HYBRID_PARTITIONS
+	{
+		name:       "cramfs",
+                offset: MTDPART_OFS_APPEND,
+                size:       0x00500000,
+        },
+	{
+		name:       "jffs2",
+                offset: MTDPART_OFS_APPEND,
+                size:       0x00920000,
+        },
+#else
+	{
+		name:       "jffs2",
+                offset: MTDPART_OFS_APPEND,
+                size:       0x00e20000,
+        },
+#endif
+	{
+		name:       "angel stuff",
+                offset: MTDPART_OFS_APPEND,
+                size:       0x00020000,
+        }
+};
+
+#include <asm/arch/tc35143.h>
+#include <asm/ucb1200.h>
+
+static void collie_set_vpp(int vpp)
+{
+	ucb1200_set_io_direction(TC35143_GPIO_VPEN_ON, TC35143_IODIR_OUTPUT);
+	if (vpp) {
+		ucb1200_set_io(TC35143_GPIO_VPEN_ON, TC35143_IODAT_HIGH);
+	} else {
+		ucb1200_set_io(TC35143_GPIO_VPEN_ON, TC35143_IODAT_LOW);
+	}
+}
+
+#endif
+
 extern int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts);
 extern int parse_bootldr_partitions(struct mtd_info *master, struct mtd_partition **pparts);
 
@@ -965,6 +1032,14 @@
 		sa1100_map.size = YOPY_FLASH_SIZE;
 	}
 #endif
+#ifdef CONFIG_SA1100_COLLIE
+	if (machine_is_collie()) {
+		parts = collie_partitions;
+		nb_parts = ARRAY_SIZE(collie_partitions);
+		sa1100_map.size = COLLIE_FLASH_SIZE;
+		sa1100_map.set_vpp = collie_set_vpp;
+	}
+#endif
 
 	/*
 	 * For simple flash devices, use ioremap to map the flash.
@@ -985,7 +1060,11 @@
 	 * specific machine settings might have been set above.
 	 */
 	printk(KERN_NOTICE "SA1100 flash: probing %d-bit flash bus\n", sa1100_map.buswidth*8);
+#ifdef CONFIG_MTD_COLLIE
+	mymtd = do_map_probe("collie", &sa1100_map);
+#else
 	mymtd = do_map_probe("cfi_probe", &sa1100_map);
+#endif
 	ret = -ENXIO;
 	if (!mymtd)
 		goto out_err;
diff -Nur linux/drivers/s390/block/dasd.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/s390/block/dasd.c
--- linux/drivers/s390/block/dasd.c	2003-05-13 16:18:23.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/s390/block/dasd.c	2003-06-23 01:47:03.000000000 +0700
@@ -4290,102 +4290,38 @@
 #ifdef CONFIG_DASD_DIAG
                 dasd_diag_cleanup ();
                 DASD_DRIVER_DEBUG_EVENT (1, "cleanup_dasd",
-                                         "DIAG discipline %s", "success");
-                printk (KERN_INFO PRINTK_HEADER
-			"De-Registered DIAG discipline successfully\n");
-#endif /* CONFIG_DASD_ECKD_BUILTIN */
-	}
-#ifdef CONFIG_DASD_FBA
-	dasd_fba_cleanup ();
-	DASD_DRIVER_DEBUG_EVENT (1, "cleanup_dasd",
-				 "FBA discipline %s", "success");
-	printk (KERN_INFO PRINTK_HEADER
-		"De-Registered FBA discipline successfully\n");
-#endif /* CONFIG_DASD_ECKD_BUILTIN */
-#ifdef CONFIG_DASD_ECKD
-	dasd_eckd_cleanup ();
-	DASD_DRIVER_DEBUG_EVENT (1, "cleanup_dasd",
-				 "ECKD discipline %s", "success");
-	printk (KERN_INFO PRINTK_HEADER
-		"De-Registered ECKD discipline successfully\n");
-#endif /* CONFIG_DASD_ECKD_BUILTIN */
-        
-	dasd_proc_cleanup ();
-        
-	list_for_each_safe (l, n, &dasd_major_info[0].list) {
-		major_info = list_entry (l, major_info_t, list);
-		for (i = 0; i < DASD_PER_MAJOR; i++) {
-			kfree (major_info->dasd_device[i]);
-		}
-		if ((major_info->flags & DASD_MAJOR_INFO_REGISTERED) &&
-		    (rc = dasd_unregister_major (major_info)) == 0) {
-			DASD_DRIVER_DEBUG_EVENT (1, "cleanup_dasd",
-						 "major %d: success",
-						 major_info->gendisk.major);
-			printk (KERN_INFO PRINTK_HEADER
-				"Unregistered successfully from major no %u\n",
-				major_info->gendisk.major);
-		} else {
-			DASD_DRIVER_DEBUG_EVENT (1, "cleanup_dasd",
-						 "major %d: failed",
-						 major_info->gendisk.major);
-			printk (KERN_WARNING PRINTK_HEADER
-				"Couldn't unregister successfully from major no %d rc = %d\n",
-				major_info->gendisk.major, rc);
-  		}
-  	}
-	list_for_each_safe (l, n, &dasd_range_head.list) {
-		range = list_entry (l, dasd_range_t, list);
-                dasd_remove_range(range);
-        }
-
-#ifndef MODULE
-        for( i = 0; i < 256; i++ )
-                if ( dasd[i] ) {
-                        kfree(dasd[i]);
-                        dasd[i] = NULL;
-                }
-#endif /* MODULE */
-        if (dasd_devfs_handle) 
-                devfs_unregister(dasd_devfs_handle);
-        if (dasd_debug_area != NULL )
-                debug_unregister(dasd_debug_area);
-	printk (KERN_INFO PRINTK_HEADER "shutdown completed\n");
-        DASD_DRIVER_DEBUG_EVENT(0,"cleanup_dasd","%s","LEAVE");
-}
-
-#ifdef MODULE
-int
-init_module (void)
-{
-	int rc = 0;
-	rc = dasd_init ();
-	return rc;
-}
-
-void
-cleanup_module (void)
-{
-	cleanup_dasd ();
-	return;
-}
-#endif
-
-/*
- * Overrides for Emacs so that we follow Linus's tabbing style.
- * Emacs will notice this stuff at the end of the file and automatically
- * adjust the settings for this buffer only.  This must remain at the end
- * of the file.
- * ---------------------------------------------------------------------------
- * Local variables:
- * c-indent-level: 4
- * c-brace-imaginary-offset: 0
- * c-brace-offset: -4
- * c-argdecl-indent: 4
- * c-label-offset: -4
- * c-continued-statement-offset: 4
- * c-continued-brace-offset: 0
- * indent-tabs-mode: nil
- * tab-width: 8
- * End:
- */
+                                    >     ?     ?     ?     %?     0?     ;?     F?     Q?     \?     g?     r?     }?     ?     ?     ?     ?     ?     ?     ?     ?     ?     ?     ?     @     @     @     "@     -@     8@     C@     N@     Y@     d@     o@     z@     @     @     @     @     @     @     @     @     @     @     @     A     A     A     (A     3A     >A     IA     TA     _A     A     A     A     A     A     A     A     A     A     A     B     B     B     #B     .B     9B     DB     OB     ZB     eB     pB     {B     B     B     B     B     B     B     B     B     B     B     C     C     C     ,C     >C     NC     ZC    _C     kC    |C                                                                  (    0    8    @    H    P    X    `    h    p    x                                                                        
+            "    *    2    :    B    J    R    \    d    l    t    |                                                                                    &    .    6    >    F    N    V    ^    f    n    v    ~                                                                                    &    .    6    >    F    N    V    ^    f    n    v    ~                                                                     
+            "    *    2    :    B    J    R    Z    b    j    r    z                                                                    	    	    	    	    $	    ,	    4	    <	    D	    L	    T	    \	    d	    l	    t	    |	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    
+    
+    
+    
+    &
+    .
+    6
+    >
+    F
+    N
+    V
+    ^
+    f
+    n
+    v
+    ~
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+                    &    .    6    >    F    N    V    ^    f    n    v    ~                                                                           $ 
\ No newline at end of file
diff -Nur linux/drivers/usb/device/bi/Config.in /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/usb/device/bi/Config.in
--- linux/drivers/usb/device/bi/Config.in	2003-05-13 16:18:44.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/usb/device/bi/Config.in	2003-06-23 01:49:28.000000000 +0700
@@ -12,8 +12,8 @@
     dep_mbool '    USB traffic keeps device awake' CONFIG_USBD_TRAFFIC_KEEPAWAKE $CONFIG_SA1110_CALYPSO
 
     if [ "$CONFIG_USBD_SA1100_BUS" = "y" -o "$CONFIG_USBD_SA1100_BUS" = "m" ]; then
-       int '    USBD Stall watchdog timeout (seconds, 0 for none)' CONFIG_USBD_STALL_TIMEOUT "0" $CONFIG_USBD_SA1100_BUS
-       int '    USBD Stall disconnect duration (seconds)' CONFIG_USBD_STALL_DISCONNECT_DURATION "2" $CONFIG_USBD_SA1100_BUS
+       int '    USBD Stall watchdog timeout (seconds, 0 for none)' CONFIG_USBD_STALL_TIMEOUT "0"
+       int '    USBD Stall disconnect duration (seconds)' CONFIG_USBD_STALL_DISCONNECT_DURATION "2"
     fi
 fi
 
diff -Nur linux/drivers/usb/device/net_fd/Config.in /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/usb/device/net_fd/Config.in
--- linux/drivers/usb/device/net_fd/Config.in	2003-05-13 16:18:45.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/usb/device/net_fd/Config.in	2003-06-23 01:49:06.000000000 +0700
@@ -32,7 +32,7 @@
       if [ "$CONFIG_ARCH_SA1110" = "n" ]; then
          bool    '     RNDIS Mode (not working yet)' CONFIG_USBD_NET_RNDIS
       fi
-      string  '   Default Remote MAC Address (e.g. 400002000001)' CONFIG_USBD_NET_REMOTE_MACADDR "" 
+      string  '   Default Remote MAC Address (e.g. 400002000001)' CONFIG_USBD_NET_REMOTE_MACADDR "400002000001" 
       hex     '    RemoteNetwork OUI (e.g. 400002)' CONFIG_USBD_NET_REMOTE_OUI "400002"
       bool    '    Use MAC Address as device Serial Number' CONFIG_USBD_MAC_AS_SERIAL_NUMBER
    fi
diff -Nur linux/drivers/video/Config.in /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/video/Config.in
--- linux/drivers/video/Config.in	2003-05-13 16:18:57.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/video/Config.in	2003-06-23 01:47:03.000000000 +0700
@@ -459,6 +459,8 @@
 	 bool '    VGA 8x16 font' CONFIG_FONT_8x16
 	 if [ "$CONFIG_FBCON_FONTWIDTH8_ONLY" = "n" ]; then
 	    bool '    Mac console 6x11 font (not supported by all drivers)' CONFIG_FONT_6x11
+	    bool '    X11 Clean 5x8 font (not supported by all drivers)' CONFIG_FONT_5x8
+	    bool '    X11 Clean 4x6 font (not supported by all drivers)' CONFIG_FONT_4x6
 	 fi
 	 bool '    Pearl (old m68k) console 8x8 font' CONFIG_FONT_PEARL_8x8
 	 bool '    Acorn console 8x8 font' CONFIG_FONT_ACORN_8x8
@@ -472,6 +474,8 @@
 	 if [ "$CONFIG_FBCON_FONTWIDTH8_ONLY" = "n" ]; then
 	    bool '    Sparc console 12x22 font (not supported by all drivers)' CONFIG_FONT_SUN12x22
 	    bool '    Mac console 6x11 font (not supported by all drivers)' CONFIG_FONT_6x11
+	    bool '    X11 Clean 5x8 font (not supported by all drivers)' CONFIG_FONT_5x8
+	    bool '    X11 Clean 4x6 font (not supported by all drivers)' CONFIG_FONT_4x6
 	 fi
 	 bool '    Pearl (old m68k) console 8x8 font' CONFIG_FONT_PEARL_8x8
 	 bool '    Acorn console 8x8 font' CONFIG_FONT_ACORN_8x8
diff -Nur linux/drivers/video/Config.in~ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/video/Config.in~
--- linux/drivers/video/Config.in~	1970-01-01 07:00:00.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/video/Config.in~	2003-06-23 01:47:03.000000000 +0700
@@ -0,0 +1,496 @@
+#
+# Video configuration
+#
+
+mainmenu_option next_comment
+comment 'Frame-buffer support'
+
+bool 'Support for frame buffer devices (EXPERIMENTAL)' CONFIG_FB
+
+if [ "$CONFIG_FB" = "y" ]; then
+   define_bool CONFIG_DUMMY_CONSOLE y
+   if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+      if [ "$CONFIG_PCI" = "y" ]; then
+         tristate '  nVidia Riva support (EXPERIMENTAL)' CONFIG_FB_RIVA
+      fi
+      if [ "$CONFIG_AMIGA" = "y" -o "$CONFIG_PCI" = "y" ]; then
+	 tristate '  Cirrus Logic support (EXPERIMENTAL)' CONFIG_FB_CLGEN
+	 tristate '  Permedia2 support (EXPERIMENTAL)' CONFIG_FB_PM2
+	 if [ "$CONFIG_FB_PM2" = "y" -o "$CONFIG_FB_PM2" = "m" ]; then
+	    if [ "$CONFIG_PCI" = "y" ]; then
+	       bool '    enable FIFO disconnect feature' CONFIG_FB_PM2_FIFO_DISCONNECT
+	       bool '    generic Permedia2 PCI board support' CONFIG_FB_PM2_PCI
+	    fi
+	    if [ "$CONFIG_AMIGA" = "y" ]; then
+	       bool '    Phase5 CVisionPPC/BVisionPPC support' CONFIG_FB_PM2_CVPPC
+	    fi
+	 fi
+      fi
+      if [ "$CONFIG_PCI" = "y" ]; then
+         tristate '  Permedia3 support (EXPERIMENTAL)' CONFIG_FB_PM3
+      fi
+   fi
+   if [ "$CONFIG_ARM" = "y" ]; then
+     dep_bool '  Collie LCD support' CONFIG_FB_COLLIE $CONFIG_SA1100_COLLIE
+     dep_bool '  Acorn VIDC support' CONFIG_FB_ACORN $CONFIG_ARCH_ACORN
+     dep_bool '  Anakin LCD support' CONFIG_FB_ANAKIN $CONFIG_ARCH_ANAKIN
+     dep_bool '  CLPS711X LCD support' CONFIG_FB_CLPS711X $CONFIG_ARCH_CLPS711X
+     dep_bool '  SA-1100 LCD support' CONFIG_FB_SA1100 $CONFIG_ARCH_SA1100
+     if [ "$CONFIG_FB_SA1100" = "y" -a "$CONFIG_SA1100_CERF" = "y" ]; then
+        choice 'CerfBoard LCD Display Size' \
+		"3.8_Color		CONFIG_CERF_LCD_38_A \
+		 3.8_Mono		CONFIG_CERF_LCD_38_B \
+		 5.7		CONFIG_CERF_LCD_57_A \
+		 7.2		CONFIG_CERF_LCD_72_A" 5.7
+     fi
+     if [ "$CONFIG_FB_SA1100" = "y" -a "$CONFIG_SA1100_CERF_CPLD" = "y" ]; then
+       bool 'Cerfboard Backlight (CerfPDA)' CONFIG_SA1100_CERF_LCD_BACKLIGHT
+     fi
+     dep_bool '  PXA LCD support' CONFIG_FB_PXA $CONFIG_ARCH_PXA
+     if [ "$CONFIG_FB_PXA" = "y" -a "$CONFIG_PXA_CERF_PDA" = "y" ]; then
+        choice 'LCD Bit Depth' \
+               "8-Bpp          CONFIG_FB_PXA_8BPP \
+                16-Bpp         CONFIG_FB_PXA_16BPP" Bit-Depth
+     fi
+     dep_bool '  Cotulla LCD support' CONFIG_FB_COTULLA $CONFIG_ARCH_PXA
+     dep_bool '  Poodle LCD support' CONFIG_FB_POODLE $CONFIG_ARCH_PXA_POODLE
+     if [ "$CONFIG_FB_POODLE" = "y" ]; then
+	dep_bool '  Cached FB support' CONFIG_POODLE_CONSISTENT_ALLOC $CONFIG_FB_POODLE
+     fi
+     dep_bool '  Corgi LCD support' CONFIG_FB_CORGI $CONFIG_ARCH_PXA_CORGI
+     dep_bool '  SHARP LOGO screen support' CONFIG_SHARP_LOGO_SCREEN $CONFIG_ARCH_SHARP_SL
+   fi
+   dep_tristate '  CyberPro 2000/2010/5000 support' CONFIG_FB_CYBER2000 $CONFIG_PCI
+   if [ "$CONFIG_APOLLO" = "y" ]; then
+      define_bool CONFIG_FB_APOLLO y
+   fi
+   if [ "$CONFIG_Q40" = "y" ]; then
+      define_bool CONFIG_FB_Q40 y
+   fi
+   if [ "$CONFIG_AMIGA" = "y" ]; then
+      tristate '  Amiga native chipset support' CONFIG_FB_AMIGA
+      if [ "$CONFIG_FB_AMIGA" != "n" ]; then
+	 bool '    Amiga OCS chipset support' CONFIG_FB_AMIGA_OCS
+	 bool '    Amiga ECS chipset support' CONFIG_FB_AMIGA_ECS
+	 bool '    Amiga AGA chipset support' CONFIG_FB_AMIGA_AGA
+      fi
+   fi
+   if [ "$CONFIG_ZORRO" = "y" ]; then
+      tristate '  Amiga CyberVision support' CONFIG_FB_CYBER
+      if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+	 bool '  Amiga CyberVision3D support (EXPERIMENTAL)' CONFIG_FB_VIRGE
+	 tristate '  Amiga RetinaZ3 support (EXPERIMENTAL)' CONFIG_FB_RETINAZ3
+	 bool '  Amiga FrameMaster II/Rainbow II support (EXPERIMENTAL)' CONFIG_FB_FM2
+      fi
+   fi
+   if [ "$CONFIG_ATARI" = "y" ]; then
+      bool '  Atari native chipset support' CONFIG_FB_ATARI
+      tristate '  ATI Mach64 display support' CONFIG_FB_ATY
+      if [ "$CONFIG_FB_ATY" != "n" ]; then
+	 define_bool CONFIG_FB_ATY_GX y
+      fi
+   fi
+   if [ "$CONFIG_PPC" = "y" ]; then
+      dep_bool '  Open Firmware frame buffer device support' CONFIG_FB_OF $CONFIG_ALL_PPC
+      dep_bool '  Apple "control" display support' CONFIG_FB_CONTROL $CONFIG_ALL_PPC
+      dep_bool '  Apple "platinum" display support' CONFIG_FB_PLATINUM $CONFIG_ALL_PPC
+      dep_bool '  Apple "valkyrie" display support' CONFIG_FB_VALKYRIE $CONFIG_ALL_PPC
+      bool '  Chips 65550 display support' CONFIG_FB_CT65550
+      bool '  IMS Twin Turbo display support' CONFIG_FB_IMSTT
+      bool '  S3 Trio display support' CONFIG_FB_S3TRIO
+      tristate '  VGA 16-color graphics console' CONFIG_FB_VGA16
+   fi
+   if [ "$CONFIG_PARISC" = "y" ]; then
+      bool '  Generic STI frame buffer device support' CONFIG_FB_STI
+   fi
+   if [ "$CONFIG_MAC" = "y" ]; then
+      define_bool CONFIG_FB_MAC y
+      bool '  Apple "valkyrie" display support' CONFIG_FB_VALKYRIE
+#      bool '  Apple DAFB display support' CONFIG_FB_DAFB
+   fi
+   if [ "$CONFIG_HP300" = "y" ]; then
+      define_bool CONFIG_FB_HP300 y
+   fi
+   if [ "$ARCH" = "alpha" ]; then
+      tristate '  TGA framebuffer support' CONFIG_FB_TGA
+   fi
+   if [ "$ARCH" = "i386" ]; then
+      bool '  VESA VGA graphics console' CONFIG_FB_VESA
+      tristate '  VGA 16-color graphics console' CONFIG_FB_VGA16
+      tristate '  Hercules mono graphics console (EXPERIMENTAL)' CONFIG_FB_HGA
+      define_bool CONFIG_VIDEO_SELECT y
+   fi
+   if [ "$CONFIG_VISWS" = "y" ]; then
+      tristate '  SGI Visual Workstation framebuffer support' CONFIG_FB_SGIVW
+      define_bool CONFIG_BUS_I2C y
+   fi
+   if [ "$CONFIG_SUN3" = "y" -o "$CONFIG_SUN3X" = "y" ]; then
+      bool '  Sun3 framebuffer support' CONFIG_FB_SUN3
+      if [ "$CONFIG_FB_SUN3" != "n" ]; then
+         bool '    BWtwo support' CONFIG_FB_BWTWO
+         bool '    CGsix (GX,TurboGX) support' CONFIG_FB_CGSIX
+      fi
+   fi
+   if [ "$CONFIG_SH_DREAMCAST" = "y" ]; then
+      tristate '  NEC PowerVR 2 display support' CONFIG_FB_PVR2
+      dep_bool '    Debug pvr2fb' CONFIG_FB_PVR2_DEBUG $CONFIG_FB_PVR2
+   fi
+   if [ "$CONFIG_SUPERH" = "y" ]; then
+      bool '  Epson 1355 framebuffer support' CONFIG_FB_E1355
+      if [ "$CONFIG_FB_E1355" = "y" ]; then
+         hex '    Register Base Address' CONFIG_E1355_REG_BASE a8000000
+         hex '    Framebuffer Base Address' CONFIG_E1355_FB_BASE a8200000
+      fi
+   fi
+   if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+      if [ "$CONFIG_PCI" != "n" ]; then
+	 tristate '  Matrox acceleration (EXPERIMENTAL)' CONFIG_FB_MATROX
+	 if [ "$CONFIG_FB_MATROX" != "n" ]; then
+	    bool '    Millennium I/II support' CONFIG_FB_MATROX_MILLENIUM
+	    bool '    Mystique support' CONFIG_FB_MATROX_MYSTIQUE
+	    bool '    G100/G200/G400/G450/G550 support' CONFIG_FB_MATROX_G100
+            if [ "$CONFIG_I2C" != "n" ]; then
+	       dep_tristate '      Matrox I2C support' CONFIG_FB_MATROX_I2C $CONFIG_FB_MATROX $CONFIG_I2C_ALGOBIT
+	       if [ "$CONFIG_FB_MATROX_G100" = "y" ]; then
+	          dep_tristate '      G400 second head support' CONFIG_FB_MATROX_MAVEN $CONFIG_FB_MATROX_I2C
+	       fi
+            fi
+            dep_tristate '      G450/G550 second head support' CONFIG_FB_MATROX_G450 $CONFIG_FB_MATROX_G100
+	    bool '    Multihead support' CONFIG_FB_MATROX_MULTIHEAD
+	 fi
+	 tristate '  ATI Mach64 display support (EXPERIMENTAL)' CONFIG_FB_ATY
+	 if [ "$CONFIG_FB_ATY" != "n" ]; then
+	    bool '    Mach64 GX support (EXPERIMENTAL)' CONFIG_FB_ATY_GX
+	    bool '    Mach64 CT/VT/GT/LT (incl. 3D RAGE) support' CONFIG_FB_ATY_CT
+	 fi
+ 	 tristate '  ATI Radeon display support (EXPERIMENTAL)' CONFIG_FB_RADEON
+	 tristate '  ATI Rage128 display support (EXPERIMENTAL)' CONFIG_FB_ATY128
+	 tristate '  SIS acceleration (EXPERIMENTAL)' CONFIG_FB_SIS
+	 if [ "$CONFIG_FB_SIS" != "n" ]; then
+	    bool '    SIS 630/540/730 support' CONFIG_FB_SIS_300
+	    bool '    SIS 315H/315 support' CONFIG_FB_SIS_315
+	 fi
+	 tristate '  3Dfx Banshee/Voodoo3 display support (EXPERIMENTAL)' CONFIG_FB_3DFX
+	 tristate '  3Dfx Voodoo Graphics (sst1) support (EXPERIMENTAL)' CONFIG_FB_VOODOO1
+	 tristate '  Trident support (EXPERIMENTAL)' CONFIG_FB_TRIDENT
+      fi
+   fi
+   if [ "$ARCH" = "sparc" -o "$ARCH" = "sparc64" ]; then
+      bool '  SBUS and UPA framebuffers' CONFIG_FB_SBUS
+      if [ "$CONFIG_FB_SBUS" != "n" ]; then
+	 if [ "$ARCH" = "sparc64" ]; then
+	    bool '    Creator/Creator3D support' CONFIG_FB_CREATOR
+	 fi
+	 bool '    CGsix (GX,TurboGX) support' CONFIG_FB_CGSIX
+	 bool '    BWtwo support' CONFIG_FB_BWTWO
+	 bool '    CGthree support' CONFIG_FB_CGTHREE
+	 if [ "$ARCH" = "sparc" ]; then
+	    bool '    TCX (SS4/SS5 only) support' CONFIG_FB_TCX
+	    bool '    CGfourteen (SX) support' CONFIG_FB_CGFOURTEEN
+	    bool '    P9100 (Sparcbook 3 only) support' CONFIG_FB_P9100
+	 fi
+	 bool '    Leo (ZX) support' CONFIG_FB_LEO
+      fi
+   fi
+   if [ "$ARCH" = "sparc" ]; then
+      if [ "$CONFIG_PCI" != "n" ]; then
+	 bool '  PCI framebuffers' CONFIG_FB_PCI
+	 if [ "$CONFIG_FB_PCI" != "n" ]; then
+	    bool '    IGA 168x display support' CONFIG_FB_IGA
+	 fi
+      fi
+   fi
+   if [ "$ARCH" = "sparc64" ]; then
+      if [ "$CONFIG_PCI" != "n" ]; then
+	 bool '  PCI framebuffers' CONFIG_FB_PCI
+	 if [ "$CONFIG_FB_PCI" != "n" ]; then
+	    tristate '    ATI Mach64 display support' CONFIG_FB_ATY
+	    if [ "$CONFIG_FB_ATY" != "n" ]; then
+	       define_bool CONFIG_FB_ATY_CT y
+	    fi
+	 fi
+      fi
+   fi
+   if [ "$CONFIG_HD64461" = "y" ]; then
+      tristate '  HD64461 Frame Buffer support' CONFIG_FB_HIT
+   fi
+   if [ "$CONFIG_DECSTATION" = "y" ]; then
+     if [ "$CONFIG_TC" = "y" ]; then
+       bool '  PMAG-BA TURBOchannel framebuffer support' CONFIG_FB_PMAG_BA
+       bool '  PMAGB-B TURBOchannel framebuffer spport' CONFIG_FB_PMAGB_B
+       bool '  Maxine (Personal DECstation) onboard framebuffer spport' CONFIG_FB_MAXINE
+     fi
+   fi
+   if [ "$CONFIG_NINO" = "y" ]; then
+      bool '  TMPTX3912/PR31700 frame buffer support' CONFIG_FB_TX3912
+   fi
+   if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+      tristate '  Virtual Frame Buffer support (ONLY FOR TESTING!)' CONFIG_FB_VIRTUAL
+   fi
+
+   bool '  Advanced low level driver options' CONFIG_FBCON_ADVANCED
+   if [ "$CONFIG_FBCON_ADVANCED" = "y" ]; then
+      tristate '    Monochrome support' CONFIG_FBCON_MFB
+      tristate '    2 bpp packed pixels support' CONFIG_FBCON_CFB2
+      tristate '    4 bpp packed pixels support' CONFIG_FBCON_CFB4
+      tristate '    8 bpp packed pixels support' CONFIG_FBCON_CFB8
+      tristate '    16 bpp packed pixels support' CONFIG_FBCON_CFB16
+      tristate '    24 bpp packed pixels support' CONFIG_FBCON_CFB24
+      tristate '    32 bpp packed pixels support' CONFIG_FBCON_CFB32
+      tristate '    Amiga bitplanes support' CONFIG_FBCON_AFB
+      tristate '    Amiga interleaved bitplanes support' CONFIG_FBCON_ILBM
+      tristate '    Atari interleaved bitplanes (2 planes) support' CONFIG_FBCON_IPLAN2P2
+      tristate '    Atari interleaved bitplanes (4 planes) support' CONFIG_FBCON_IPLAN2P4
+      tristate '    Atari interleaved bitplanes (8 planes) support' CONFIG_FBCON_IPLAN2P8
+#      tristate '    Atari interleaved bitplanes (16 planes) support' CONFIG_FBCON_IPLAN2P16
+      tristate '    Mac variable bpp packed pixels support' CONFIG_FBCON_MAC
+      tristate '    VGA 16-color planar support' CONFIG_FBCON_VGA_PLANES
+      tristate '    VGA characters/attributes support' CONFIG_FBCON_VGA
+      tristate '    HGA monochrome support (EXPERIMENTAL)' CONFIG_FBCON_HGA
+   else
+      # Guess what we need
+      if [ "$CONFIG_FB_ACORN" = "y" -o "$CONFIG_FB_AMIGA" = "y" -o \
+	   "$CONFIG_FB_ATARI" = "y" -o "$CONFIG_FB_CYBER" = "y" -o \
+	   "$CONFIG_FB_MAC" = "y" -o "$CONFIG_FB_RETINAZ3" = "y" -o \
+	   "$CONFIG_FB_VIRGE" = "y" -o "$CONFIG_FB_VIRTUAL" = "y" -o \
+	   "$CONFIG_FB_BWTWO" = "y" -o "$CONFIG_FB_CLGEN" = "y"  -o \
+	   "$CONFIG_FB_TX3912" = "y" -o "$CONFIG_FB_CLPS711X" = "y" ]; then
+	 define_tristate CONFIG_FBCON_MFB y
+      else
+	 if [ "$CONFIG_FB_ACORN" = "m" -o "$CONFIG_FB_AMIGA" = "m" -o \
+	      "$CONFIG_FB_ATARI" = "m" -o "$CONFIG_FB_CYBER" = "m" -o \
+	      "$CONFIG_FB_MAC" = "m" -o "$CONFIG_FB_RETINAZ3" = "m" -o \
+	      "$CONFIG_FB_VIRGE" = "m" -o "$CONFIG_FB_VIRTUAL" = "m" -o \
+	      "$CONFIG_FB_BWTWO" = "m" -o "$CONFIG_FB_CLGEN" = "m" -o \
+	      "$CONFIG_FB_TX3912" = "m" -o "$CONFIG_FB_CLPS711X" = "m"  ]; then
+	    define_tristate CONFIG_FBCON_MFB m
+	 fi
+      fi
+      if [ "$CONFIG_FB_ACORN" = "y" -o "$CONFIG_FB_MAC" = "y" -o \
+	   "$CONFIG_FB_SA1100" = "y" -o "$CONFIG_FB_VIRTUAL" = "y" -o \
+	   "$CONFIG_FB_TX3912" = "y"  -o "$CONFIG_FB_CLPS711X" = "y" -o \
+	   "$CONFIG_FB_PXA" = "y" ]; then
+	 define_tristate CONFIG_FBCON_CFB2 y
+	 define_tristate CONFIG_FBCON_CFB4 y
+      else
+	 if [ "$CONFIG_FB_ACORN" = "m" -o "$CONFIG_FB_MAC" = "m" -o \
+	      "$CONFIG_FB_SA1100" = "m" -o "$CONFIG_FB_VIRTUAL" = "m" -o \
+	      "$CONFIG_FB_TX3912" = "m" -o "$CONFIG_FB_CLPS711X" = "m" ]; then
+	    define_tristate CONFIG_FBCON_CFB2 m
+	    define_tristate CONFIG_FBCON_CFB4 m
+	 fi
+      fi
+      if [ "$CONFIG_FB_ACORN" = "y" -o "$CONFIG_FB_ATARI" = "y" -o \
+	   "$CONFIG_FB_ATY" = "y" -o "$CONFIG_FB_MAC" = "y" -o \
+	   "$CONFIG_FB_OF" = "y" -o "$CONFIG_FB_TGA" = "y" -o \
+	   "$CONFIG_FB_VESA" = "y" -o "$CONFIG_FB_VIRTUAL" = "y" -o \
+	   "$CONFIG_FB_TCX" = "y" -o "$CONFIG_FB_CGTHREE" = "y" -o \
+	   "$CONFIG_FB_CONTROL" = "y" -o "$CONFIG_FB_CLGEN" = "y" -o \
+	   "$CONFIG_FB_CGFOURTEEN" = "y" -o "$CONFIG_FB_G364" = "y" -o \
+	   "$CONFIG_FB_VIRGE" = "y" -o "$CONFIG_FB_CYBER" = "y" -o \
+	   "$CONFIG_FB_VALKYRIE" = "y" -o "$CONFIG_FB_PLATINUM" = "y" -o \
+           "$CONFIG_FB_IGA" = "y" -o "$CONFIG_FB_MATROX" = "y" -o \
+	   "$CONFIG_FB_CT65550" = "y" -o "$CONFIG_FB_PM2" = "y" -o \
+	   "$CONFIG_FB_P9100" = "y" -o "$CONFIG_FB_ATY128" = "y" -o \
+	   "$CONFIG_FB_RIVA" = "y" -o "$CONFIG_FB_RADEON" = "y" -o \
+	   "$CONFIG_FB_SGIVW" = "y" -o "$CONFIG_FB_CYBER2000" = "y" -o \
+	   "$CONFIG_FB_SA1100" = "y" -o "$CONFIG_FB_3DFX" = "y" -o \
+	   "$CONFIG_FB_PMAG_BA" = "y" -o "$CONFIG_FB_PMAGB_B" = "y" -o \
+	   "$CONFIG_FB_MAXINE" = "y" -o "$CONFIG_FB_TX3912" = "y" -o \
+	   "$CONFIG_FB_SIS" = "y" -o "$CONFIG_FB_PM3" = "y" -o \
+	   "$CONFIG_FB_PXA" = "y" ]; then
+	 define_tristate CONFIG_FBCON_CFB8 y
+      else
+	 if [ "$CONFIG_FB_ACORN" = "m" -o "$CONFIG_FB_ATARI" = "m" -o \
+	      "$CONFIG_FB_ATY" = "m" -o "$CONFIG_FB_MAC" = "m" -o \
+	      "$CONFIG_FB_OF" = "m" -o "$CONFIG_FB_TGA" = "m" -o \
+	      "$CONFIG_FB_VESA" = "m" -o "$CONFIG_FB_VIRTUAL" = "m" -o \
+	      "$CONFIG_FB_TCX" = "m" -o "$CONFIG_FB_CGTHREE" = "m" -o \
+	      "$CONFIG_FB_CONTROL" = "m" -o "$CONFIG_FB_CLGEN" = "m" -o \
+	      "$CONFIG_FB_CGFOURTEEN" = "m" -o "$CONFIG_FB_G364" = "m" -o \
+	      "$CONFIG_FB_VIRGE" = "m" -o "$CONFIG_FB_CYBER" = "m" -o \
+	      "$CONFIG_FB_VALKYRIE" = "m" -o "$CONFIG_FB_PLATINUM" = "m" -o \
+              "$CONFIG_FB_IGA" = "m" -o "$CONFIG_FB_MATROX" = "m" -o \
+	      "$CONFIG_FB_CT65550" = "m" -o "$CONFIG_FB_PM2" = "m" -o \
+	      "$CONFIG_FB_P9100" = "m" -o "$CONFIG_FB_ATY128" = "m" -o \
+	      "$CONFIG_FB_RIVA" = "m" -o "$CONFIG_FB_3DFX" = "m" -o \
+	      "$CONFIG_FB_SGIVW" = "m" -o "$CONFIG_FB_CYBER2000" = "m" -o \
+	      "$CONFIG_FB_PMAG_BA" = "m" -o "$CONFIG_FB_PMAGB_B" = "m" -o \
+	      "$CONFIG_FB_MAXINE" = "m" -o "$CONFIG_FB_RADEON" = "m" -o \
+	      "$CONFIG_FB_SA1100" = "m" -o "$CONFIG_FB_SIS" = "m" -o \
+	      "$CONFIG_FB_TX3912" = "m" -o "$CONFIG_FB_PM3" = "m" ]; then
+	    define_tristate CONFIG_FBCON_CFB8 m
+	 fi
+      fi
+      if [ "$CONFIG_FB_ATARI" = "y" -o "$CONFIG_FB_ATY" = "y" -o \
+	   "$CONFIG_FB_MAC" = "y" -o "$CONFIG_FB_VESA" = "y" -o \
+	   "$CONFIG_FB_VIRTUAL" = "y" -o "$CONFIG_FB_TBOX" = "y" -o \
+	   "$CONFIG_FB_Q40" = "y" -o "$CONFIG_FB_RADEON" = "y" -o \
+	   "$CONFIG_FB_CONTROL" = "y" -o "$CONFIG_FB_CLGEN" = "y" -o \
+	   "$CONFIG_FB_VIRGE" = "y" -o "$CONFIG_FB_CYBER" = "y" -o \
+	   "$CONFIG_FB_VALKYRIE" = "y" -o "$CONFIG_FB_PLATINUM" = "y" -o \
+	   "$CONFIG_FB_CT65550" = "y" -o "$CONFIG_FB_MATROX" = "y" -o \
+	   "$CONFIG_FB_PM2" = "y" -o "$CONFIG_FB_SGIVW" = "y" -o \
+	   "$CONFIG_FB_RIVA" = "y" -o "$CONFIG_FB_ATY128" = "y" -o \
+	   "$CONFIG_FB_CYBER2000" = "y" -o "$CONFIG_FB_3DFX" = "y"  -o \
+	   "$CONFIG_FB_SIS" = "y" -o "$CONFIG_FB_SA1100" = "y" -o \
+	   "$CONFIG_FB_PVR2" = "y" -o "$CONFIG_FB_VOODOO1" = "y" -o \
+	   "$CONFIG_FB_ANAKIN" = "y" -o "$CONFIG_FB_PM3" = "y" -o \
+	   "$CONFIG_FB_PXA" = "y" ]; then
+	 define_tristate CONFIG_FBCON_CFB16 y
+      else
+	 if [ "$CONFIG_FB_ATARI" = "m" -o "$CONFIG_FB_ATY" = "m" -o \
+	      "$CONFIG_FB_MAC" = "m" -o "$CONFIG_FB_VESA" = "m" -o \
+	      "$CONFIG_FB_VIRTUAL" = "m" -o "$CONFIG_FB_TBOX" = "m" -o \
+	      "$CONFIG_FB_Q40" = "m" -o "$CONFIG_FB_3DFX" = "m" -o \
+	      "$CONFIG_FB_CONTROL" = "m" -o "$CONFIG_FB_CLGEN" = "m" -o \
+	      "$CONFIG_FB_VIRGE" = "m" -o "$CONFIG_FB_CYBER" = "m" -o \
+	      "$CONFIG_FB_VALKYRIE" = "m" -o "$CONFIG_FB_PLATINUM" = "m" -o \
+	      "$CONFIG_FB_CT65550" = "m" -o "$CONFIG_FB_MATROX" = "m" -o \
+	      "$CONFIG_FB_PM2" = "m" -o "$CONFIG_FB_SGIVW" = "m" -o \
+	      "$CONFIG_FB_RIVA" = "m" -o "$CONFIG_FB_ATY128" = "m" -o \
+	      "$CONFIG_FB_CYBER2000" = "m" -o "$CONFIG_FB_SIS" = "m" -o \
+	      "$CONFIG_FB_SA1100" = "m" -o "$CONFIG_FB_RADEON" = "m" -o \
+	      "$CONFIG_FB_PVR2" = "m" -o "$CONFIG_FB_VOODOO1" = "m" -o \
+	      "$CONFIG_FB_ANAKIN" = "m"  -o "$CONFIG_FB_PM3" = "m" ]; then
+	    define_tristate CONFIG_FBCON_CFB16 m
+	 fi
+      fi
+      if [ "$CONFIG_FB_ATY" = "y" -o "$CONFIG_FB_VIRTUAL" = "y" -o \
+	   "$CONFIG_FB_CLGEN" = "y" -o "$CONFIG_FB_VESA" = "y" -o \
+	   "$CONFIG_FB_MATROX" = "y" -o "$CONFIG_FB_PM2" = "y" -o \
+           "$CONFIG_FB_ATY128" = "y" -o "$CONFIG_FB_RADEON" = "y" -o \
+	   "$CONFIG_FB_CYBER2000" = "y" -o "$CONFIG_FB_PVR2" = "y" -o \
+	   "$CONFIG_FB_VOODOO1" = "y" -o "$CONFIG_FB_PM3" = "y" ]; then
+	 define_tristate CONFIG_FBCON_CFB24 y
+      else
+	 if [ "$CONFIG_FB_ATY" = "m" -o "$CONFIG_FB_VIRTUAL" = "m" -o \
+	      "$CONFIG_FB_CLGEN" = "m" -o "$CONFIG_FB_VESA" = "m" -o \
+	      "$CONFIG_FB_MATROX" = "m" -o "$CONFIG_FB_PM2" = "m" -o \
+	      "$CONFIG_FB_ATY128" = "m" -o "$CONFIG_FB_RADEON" = "m" -o \
+	      "$CONFIG_FB_CYBER2000" = "m" -o "$CONFIG_FB_PVR2" = "m" -o \
+	      "$CONFIG_FB_VOODOO1" = "m" -o "$cONFIG_FB_PM3" = "m" ]; then
+	    define_tristate CONFIG_FBCON_CFB24 m
+	 fi
+      fi
+      if [ "$CONFIG_FB_ATARI" = "y" -o "$CONFIG_FB_ATY" = "y" -o \
+	   "$CONFIG_FB_VESA" = "y" -o "$CONFIG_FB_VIRTUAL" = "y" -o \
+	   "$CONFIG_FB_CONTROL" = "y" -o "$CONFIG_FB_CLGEN" = "y" -o \
+	   "$CONFIG_FB_TGA" = "y" -o "$CONFIG_FB_PLATINUM" = "y" -o \
+	   "$CONFIG_FB_MATROX" = "y" -o "$CONFIG_FB_PM2" = "y" -o \
+	   "$CONFIG_FB_RIVA" = "y" -o "$CONFIG_FB_ATY128" = "y" -o \
+	   "$CONFIG_FB_FM2" = "y" -o "$CONFIG_FB_SGIVW" = "y" -o \
+	   "$CONFIG_FB_RADEON" = "y" -o "$CONFIG_FB_PVR2" = "y" -o \
+	   "$CONFIG_FB_3DFX" = "y" -o "$CONFIG_FB_SIS" = "y" -o \
+	   "$CONFIG_FB_VOODOO1" = "y" -o "$CONFIG_FB_PM3" = "y" ]; then
+	 define_tristate CONFIG_FBCON_CFB32 y
+      else
+	 if [ "$CONFIG_FB_ATARI" = "m" -o "$CONFIG_FB_ATY" = "m" -o \
+	      "$CONFIG_FB_VESA" = "m" -o "$CONFIG_FB_VIRTUAL" = "m" -o \
+	      "$CONFIG_FB_CONTROL" = "m" -o "$CONFIG_FB_CLGEN" = "m" -o \
+	      "$CONFIG_FB_TGA" = "m" -o "$CONFIG_FB_PLATINUM" = "m" -o \
+	      "$CONFIG_FB_MATROX" = "m" -o "$CONFIG_FB_PM2" = "m" -o \
+	      "$CONFIG_FB_RIVA" = "m" -o "$CONFIG_FB_ATY128" = "m" -o \
+	      "$CONFIG_FB_3DFX" = "m" -o "$CONFIG_FB_RADEON" = "m" -o \
+	      "$CONFIG_FB_SGIVW" = "m" -o "$CONFIG_FB_SIS" = "m" -o \
+	      "$CONFIG_FB_PVR2" = "m" -o "$CONFIG_FB_VOODOO1" = "m" -o \
+	      "$CONFIG_FB_PM3" = "m" ]; then
+	    define_tristate CONFIG_FBCON_CFB32 m
+	 fi
+      fi
+      if [ "$CONFIG_FB_AMIGA" = "y" ]; then
+	 define_tristate CONFIG_FBCON_AFB y
+	 define_tristate CONFIG_FBCON_ILBM y
+      else
+	 if [ "$CONFIG_FB_AMIGA" = "m" ]; then
+	    define_tristate CONFIG_FBCON_AFB m
+	    define_tristate CONFIG_FBCON_ILBM m
+	 fi
+      fi
+      if [ "$CONFIG_FB_ATARI" = "y" ]; then
+	 define_tristate CONFIG_FBCON_IPLAN2P2 y
+	 define_tristate CONFIG_FBCON_IPLAN2P4 y
+	 define_tristate CONFIG_FBCON_IPLAN2P8 y
+#	 define_tristate CONFIG_FBCON_IPLAN2P16 y
+      else
+	 if [ "$CONFIG_FB_ATARI" = "m" ]; then
+	    define_tristate CONFIG_FBCON_IPLAN2P2 m
+	    define_tristate CONFIG_FBCON_IPLAN2P4 m
+	    define_tristate CONFIG_FBCON_IPLAN2P8 m
+#	    define_tristate CONFIG_FBCON_IPLAN2P16 m
+	 fi
+      fi
+      if [ "$CONFIG_FB_MAC" = "y" -o "$CONFIG_FB_VIRTUAL" = "y" ]; then
+	 define_tristate CONFIG_FBCON_MAC  y
+      else
+	 if [ "$CONFIG_FB_MAC" = "m" -o "$CONFIG_FB_VIRTUAL" = "m" ]; then
+	    define_tristate CONFIG_FBCON_MAC  m
+	 fi
+      fi
+      if [ "$CONFIG_FB_VGA16" = "y" ]; then
+	 define_tristate CONFIG_FBCON_VGA_PLANES y
+      else
+	 if [ "$CONFIG_FB_VGA16" = "m" ]; then
+	    define_tristate CONFIG_FBCON_VGA_PLANES m
+	 fi
+      fi
+      if [ "$CONFIG_FB_HGA" = "y" ]; then
+	 define_tristate CONFIG_FBCON_HGA y
+      else
+	 if [ "$CONFIG_FB_HGA" = "m" ]; then
+	    define_tristate CONFIG_FBCON_HGA m
+	 fi
+      fi
+      if [ "$CONFIG_FB_STI" = "y" ]; then
+	 define_tristate CONFIG_FBCON_STI y
+      fi
+   fi
+   dep_bool '  Rotate FrameBuffer Console (right)' CONFIG_FBCON_ROTATE_R $CONFIG_FBCON_CFB16
+   dep_bool '  Rotate FrameBuffer Console (left)'  CONFIG_FBCON_ROTATE_L $CONFIG_FBCON_CFB16
+   bool '  Support only 8 pixels wide fonts' CONFIG_FBCON_FONTWIDTH8_ONLY
+   if [ "$ARCH" = "sparc" -o "$ARCH" = "sparc64" ]; then
+      bool '  Sparc console 8x16 font' CONFIG_FONT_SUN8x16
+      if [ "$CONFIG_FBCON_FONTWIDTH8_ONLY" = "n" ]; then
+	 bool '  Sparc console 12x22 font (not supported by all drivers)' CONFIG_FONT_SUN12x22
+      fi
+      bool '  Select other fonts' CONFIG_FBCON_FONTS
+      if [ "$CONFIG_FBCON_FONTS" = "y" ]; then
+	 bool '    VGA 8x8 font' CONFIG_FONT_8x8
+	 bool '    VGA 8x16 font' CONFIG_FONT_8x16
+	 if [ "$CONFIG_FBCON_FONTWIDTH8_ONLY" = "n" ]; then
+	    bool '    Mac console 6x11 font (not supported by all drivers)' CONFIG_FONT_6x11
+	 fi
+	 bool '    Pearl (old m68k) console 8x8 font' CONFIG_FONT_PEARL_8x8
+	 bool '    Acorn console 8x8 font' CONFIG_FONT_ACORN_8x8
+      fi
+   else
+      bool '  Select compiled-in fonts' CONFIG_FBCON_FONTS
+      if [ "$CONFIG_FBCON_FONTS" = "y" ]; then
+	 bool '    VGA 8x8 font' CONFIG_FONT_8x8
+	 bool '    VGA 8x16 font' CONFIG_FONT_8x16
+	 bool '    Sparc console 8x16 font' CONFIG_FONT_SUN8x16
+	 if [ "$CONFIG_FBCON_FONTWIDTH8_ONLY" = "n" ]; then
+	    bool '    Sparc console 12x22 font (not supported by all drivers)' CONFIG_FONT_SUN12x22
+	    bool '    Mac console 6x11 font (not supported by all drivers)' CONFIG_FONT_6x11
+	 fi
+	 bool '    Pearl (old m68k) console 8x8 font' CONFIG_FONT_PEARL_8x8
+	 bool '    Acorn console 8x8 font' CONFIG_FONT_ACORN_8x8
+      else
+	 define_bool CONFIG_FONT_8x8 y
+	 define_bool CONFIG_FONT_8x16 y
+	 if [ "$CONFIG_MAC" = "y" ]; then
+	    if [ "$CONFIG_FBCON_FONTWIDTH8_ONLY" = "n" ]; then
+	       define_bool CONFIG_FONT_6x11 y
+	    fi
+	 fi
+	 if [ "$CONFIG_AMIGA" = "y" ]; then
+	    define_bool CONFIG_FONT_PEARL_8x8 y
+	 fi
+	 if [ "$CONFIG_ARM" = "y" -a "$CONFIG_ARCH_ACORN" = "y" ]; then
+	    define_bool CONFIG_FONT_ACORN_8x8 y
+	 fi
+      fi
+   fi
+fi
+
+endmenu
diff -Nur linux/drivers/video/Makefile /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/video/Makefile
--- linux/drivers/video/Makefile	2003-05-13 16:18:57.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/video/Makefile	2003-06-23 01:47:03.000000000 +0700
@@ -33,6 +33,8 @@
 obj-$(CONFIG_FONT_6x11)           += font_6x11.o
 obj-$(CONFIG_FONT_PEARL_8x8)      += font_pearl_8x8.o
 obj-$(CONFIG_FONT_ACORN_8x8)      += font_acorn_8x8.o
+obj-$(CONFIG_FONT_5x8)      += font_5x8.o
+obj-$(CONFIG_FONT_4x6)      += font_4x6.o
 
 # Add fbmon.o back into obj-$(CONFIG_FB) in 2.5.x
 obj-$(CONFIG_FB)                  += fbmem.o fbcmap.o modedb.o fbcon.o fonts.o
diff -Nur linux/drivers/video/Makefile~ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/video/Makefile~
--- linux/drivers/video/Makefile~	1970-01-01 07:00:00.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/video/Makefile~	2003-06-23 01:47:03.000000000 +0700
@@ -0,0 +1,165 @@
+# Makefile for the Linux video drivers.
+# 5 Aug 1999, James Simmons, <mailto:jsimmons@edgeglobal.com>
+# Rewritten to use lists instead of if-statements.
+
+O_TARGET := video.o
+
+mod-subdirs	:= matrox
+
+# All of the (potential) objects that export symbols.
+# This list comes from 'grep -l EXPORT_SYMBOL *.[hc]'.
+
+export-objs    := fbmem.o fbcmap.o fbcon.o fbmon.o modedb.o \
+		  fbcon-afb.o fbcon-ilbm.o \
+		  fbcon-vga.o fbcon-iplan2p2.o fbcon-iplan2p4.o \
+		  fbcon-iplan2p8.o fbcon-vga-planes.o fbcon-cfb16.o \
+		  fbcon-cfb2.o fbcon-cfb24.o fbcon-cfb32.o fbcon-cfb4.o \
+		  fbcon-cfb8.o fbcon-mac.o fbcon-mfb.o \
+		  cyber2000fb.o sa1100fb.o fbcon-hga.o pxafb.o cotulla_fb.o discovery_frontlight.o
+
+# Each configuration option enables a list of files.
+
+obj-$(CONFIG_DUMMY_CONSOLE)       += dummycon.o
+obj-$(CONFIG_SGI_NEWPORT_CONSOLE) += newport_con.o
+obj-$(CONFIG_PROM_CONSOLE)        += promcon.o promcon_tbl.o
+obj-$(CONFIG_STI_CONSOLE)         += sticon.o sticon-bmode.o sticore.o
+obj-$(CONFIG_VGA_CONSOLE)         += vgacon.o
+obj-$(CONFIG_MDA_CONSOLE)         += mdacon.o
+
+obj-$(CONFIG_FONT_SUN8x16)        += font_sun8x16.o
+obj-$(CONFIG_FONT_SUN12x22)       += font_sun12x22.o
+obj-$(CONFIG_FONT_8x8)            += font_8x8.o
+obj-$(CONFIG_FONT_8x16)           += font_8x16.o
+obj-$(CONFIG_FONT_6x11)           += font_6x11.o
+obj-$(CONFIG_FONT_PEARL_8x8)      += font_pearl_8x8.o
+obj-$(CONFIG_FONT_ACORN_8x8)      += font_acorn_8x8.o
+
+# Add fbmon.o back into obj-$(CONFIG_FB) in 2.5.x
+obj-$(CONFIG_FB)                  += fbmem.o fbcmap.o modedb.o fbcon.o fonts.o
+# Only include macmodes.o if we have FB support and are PPC
+ifeq ($(CONFIG_FB),y)
+obj-$(CONFIG_PPC)                 += macmodes.o
+endif
+
+obj-$(CONFIG_FB_ACORN)            += acornfb.o
+obj-$(CONFIG_FB_AMIGA)            += amifb.o
+obj-$(CONFIG_FB_PM2)              += pm2fb.o fbgen.o
+obj-$(CONFIG_FB_PM3)              += pm3fb.o fbgen.o
+obj-$(CONFIG_FB_APOLLO)           += dnfb.o
+obj-$(CONFIG_FB_Q40)              += q40fb.o
+obj-$(CONFIG_FB_ATARI)            += atafb.o
+obj-$(CONFIG_FB_ATY128)           += aty128fb.o
+obj-$(CONFIG_FB_RADEON)		  += radeonfb.o
+obj-$(CONFIG_FB_IGA)              += igafb.o
+obj-$(CONFIG_FB_CONTROL)          += controlfb.o
+obj-$(CONFIG_FB_PLATINUM)         += platinumfb.o
+obj-$(CONFIG_FB_VALKYRIE)         += valkyriefb.o
+obj-$(CONFIG_FB_CT65550)          += chipsfb.o
+obj-$(CONFIG_FB_CLPS711X)         += clps711xfb.o
+obj-$(CONFIG_FB_CYBER)            += cyberfb.o
+obj-$(CONFIG_FB_CYBER2000)        += cyber2000fb.o
+obj-$(CONFIG_FB_SGIVW)            += sgivwfb.o
+obj-$(CONFIG_FB_3DFX)             += tdfxfb.o
+obj-$(CONFIG_FB_MAC)              += macfb.o macmodes.o
+obj-$(CONFIG_FB_HP300)            += hpfb.o
+obj-$(CONFIG_FB_OF)               += offb.o
+obj-$(CONFIG_FB_IMSTT)            += imsttfb.o
+obj-$(CONFIG_FB_RETINAZ3)         += retz3fb.o
+obj-$(CONFIG_FB_CLGEN)            += clgenfb.o fbgen.o
+obj-$(CONFIG_FB_TRIDENT)          += tridentfb.o fbgen.o
+obj-$(CONFIG_FB_S3TRIO)           += S3triofb.o
+obj-$(CONFIG_FB_TGA)              += tgafb.o fbgen.o
+obj-$(CONFIG_FB_VESA)             += vesafb.o 
+obj-$(CONFIG_FB_VGA16)            += vga16fb.o fbcon-vga-planes.o
+obj-$(CONFIG_FB_VIRGE)            += virgefb.o
+obj-$(CONFIG_FB_G364)             += g364fb.o
+obj-$(CONFIG_FB_FM2)              += fm2fb.o
+obj-$(CONFIG_FB_CREATOR)          += creatorfb.o sbusfb.o
+obj-$(CONFIG_FB_CGSIX)            += cgsixfb.o sbusfb.o
+obj-$(CONFIG_FB_BWTWO)            += bwtwofb.o sbusfb.o
+obj-$(CONFIG_FB_CGTHREE)          += cgthreefb.o sbusfb.o
+obj-$(CONFIG_FB_TCX)              += tcxfb.o sbusfb.o
+obj-$(CONFIG_FB_CGFOURTEEN)       += cgfourteenfb.o sbusfb.o
+obj-$(CONFIG_FB_P9100)            += p9100fb.o sbusfb.o
+obj-$(CONFIG_FB_LEO)              += leofb.o sbusfb.o
+obj-$(CONFIG_FB_STI)	          += stifb.o sticore.o fbgen.o
+obj-$(CONFIG_FB_PMAG_BA)          += pmag-ba-fb.o
+obj-$(CONFIG_FB_PMAGB_B)          += pmagb-b-fb.o
+obj-$(CONFIG_FB_MAXINE)           += maxinefb.o
+obj-$(CONFIG_FB_TX3912)           += tx3912fb.o
+obj-$(CONFIG_FB_COLLIE)           += colliefb.o collie_frontlight.o
+obj-$(CONFIG_FB_COTULLA)          += cotulla_fb.o discovery_frontlight.o
+obj-$(CONFIG_FB_POODLE)           += cotulla_fb.o poodle_frontlight.o
+obj-$(CONFIG_FB_CORGI)            += w100fb.o fbgen.o corgi_backlight.o
+
+
+subdir-$(CONFIG_FB_MATROX)	  += matrox
+ifeq ($(CONFIG_FB_MATROX),y)
+obj-y				  += matrox/matrox.o
+endif
+
+subdir-$(CONFIG_FB_RIVA)	  += riva
+ifeq ($(CONFIG_FB_RIVA),y)
+obj-y				  += riva/rivafb.o
+endif
+
+subdir-$(CONFIG_FB_SIS)		  += sis
+ifeq ($(CONFIG_FB_SIS),y)
+obj-y				  += sis/sisfb.o
+endif
+
+subdir-$(CONFIG_FB_ATY)		  += aty
+ifeq ($(CONFIG_FB_ATY),y)
+obj-y				  += aty/atyfb.o
+endif
+
+obj-$(CONFIG_FB_SUN3)             += sun3fb.o
+obj-$(CONFIG_FB_BWTWO)            += bwtwofb.o
+obj-$(CONFIG_FB_HGA)              += hgafb.o  
+obj-$(CONFIG_FB_SA1100)           += sa1100fb.o
+obj-$(CONFIG_FB_PXA)	  += pxafb.o
+ifeq ($(CONFIG_PXA_CERF_PDA),y)
+obj-$(CONFIG_FB_PXA)              += lcdctrl.o lcdctrl_cerf.o
+endif
+obj-$(CONFIG_FB_VIRTUAL)          += vfb.o  
+obj-$(CONFIG_FB_HIT)              += hitfb.o fbgen.o
+obj-$(CONFIG_FB_E1355)            += epson1355fb.o fbgen.o
+obj-$(CONFIG_FB_PVR2)             += pvr2fb.o
+obj-$(CONFIG_FB_VOODOO1)          += sstfb.o
+obj-$(CONFIG_FB_ANAKIN)           += anakinfb.o
+
+# Generic Low Level Drivers
+
+obj-$(CONFIG_FBCON_AFB)           += fbcon-afb.o
+obj-$(CONFIG_FBCON_CFB2)          += fbcon-cfb2.o
+obj-$(CONFIG_FBCON_CFB4)          += fbcon-cfb4.o
+obj-$(CONFIG_FBCON_CFB8)          += fbcon-cfb8.o
+obj-$(CONFIG_FBCON_CFB16)         += fbcon-cfb16.o
+obj-$(CONFIG_FBCON_CFB24)         += fbcon-cfb24.o
+obj-$(CONFIG_FBCON_CFB32)         += fbcon-cfb32.o
+obj-$(CONFIG_FBCON_ILBM)          += fbcon-ilbm.o
+obj-$(CONFIG_FBCON_IPLAN2P2)      += fbcon-iplan2p2.o
+obj-$(CONFIG_FBCON_IPLAN2P4)      += fbcon-iplan2p4.o
+obj-$(CONFIG_FBCON_IPLAN2P8)      += fbcon-iplan2p8.o
+obj-$(CONFIG_FBCON_IPLAN2P16)     += fbcon-iplan2p16.o
+obj-$(CONFIG_FBCON_MAC)           += fbcon-mac.o
+obj-$(CONFIG_FBCON_MFB)           += fbcon-mfb.o
+obj-$(CONFIG_FBCON_VGA)           += fbcon-vga.o
+obj-$(CONFIG_FBCON_HGA)           += fbcon-hga.o
+obj-$(CONFIG_FBCON_STI)           += fbcon-sti.o
+
+include $(TOPDIR)/Rules.make
+
+clean:
+	rm -f core *.o *.a *.s
+
+../conmakehash: ../conmakehash.c
+	$(HOSTCC) $(HOSTCFLAGS) -o ../conmakehash ../conmakehash.c
+
+promcon_tbl.c: prom.uni ../char/conmakehash
+	../char/conmakehash prom.uni | \
+	sed -e '/#include <[^>]*>/p' -e 's/types/init/' \
+	    -e 's/dfont\(_uni.*\]\)/promfont\1 __initdata/' > promcon_tbl.c
+
+promcon_tbl.o: promcon_tbl.c $(TOPDIR)/include/linux/types.h
+
diff -Nur linux/drivers/video/collieLogoScreen.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/video/collieLogoScreen.c
--- linux/drivers/video/collieLogoScreen.c	2003-05-13 16:18:58.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/video/collieLogoScreen.c	2003-06-23 01:47:03.000000000 +0700
@@ -2,166 +2,248 @@
 #ifndef __initdata
 #define __initdata
 #endif
-static int	logo_screen_width __initdata = 32;
-static int	logo_screen_height __initdata = 160;
-static unsigned short	logo_screen_data[] __initdata ={
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c30,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x8bcf,0xaaeb,0x8410,0x7c30,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c30,0x83ef,0x8bcf,0x8410,0x7c30,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0xba69,0xf800,0xe145,0xa30c,0x7c30,0x7c30,0x7bef,0x7bef,0x7bef,0x7c10,0x8bcf,0xc249,0xe8a2,0xf041,0xe104,0xb2aa,0x8410,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xd945,0xf800,0xf800,0xf800,0xd986,0x9b4d,0x7c10,0x7bef,0x7c10,0x8bcf,0xe104,0xf800,0xf800,0xf800,0xf800,0xf800,0xc9c7,0x7c10,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x8bcf,0xf082,0xf800,0xf800,0xf800,0xf800,0xd1c7,0x7c30,0x7c10,0x7c30,0xd1a6,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xb2aa,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0xb2aa,0xf800,0xf800,0xf800,0xf800,0xf800,0xa32c,0x7c30,0x7c30,0xa34d,0xf820,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xe8a2,0x8bcf,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0xd1a6,0xf800,0xf800,0xf800,0xf800,0xe104,0x8410,0x7c10,0x7c30,0xd186,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xa2eb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x83ef,0xe8e3,0xf800,0xf800,0xf800,0xf800,0xb28a,0x7430,0x7c10,0x8bef,0xf082,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xca08,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x9bae,0xf841,0xf800,0xf800,0xf800,0xf820,0x936d,0x7c10,0x7c30,0xb2cb,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xe8c3,0x83ef,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7430,0xba69,0xf800,0xf800,0xf800,0xf800,0xd965,0x7c30,0x7c10,0x7c30,0xc9c7,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf820,0x936d,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0xc9c7,0xf800,0xf800,0xf800,0xf800,0xb28a,0x7430,0x7c10,0x8410,0xe124,0xf800,0xf800,0xf800,0xf800,0xf800,0xd945,0xb269,0xe8a2,0xf800,0xf800,0xf800,0xa2eb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xd924,0xf800,0xf800,0xf800,0xf820,0x9b4d,0x7c10,0x7c10,0x83ef,0xf082,0xf800,0xf800,0xf800,0xf800,0xf820,0x936d,0x6c92,0xba8a,0xf800,0xf800,0xf800,0xb2cb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7c10,0x83ef,0xe904,0xf800,0xf800,0xf800,0xf0a2,0x83ef,0x7c10,0x7c10,0x9b8e,0xf820,0xf800,0xf800,0xf800,0xf800,0xe145,0x8410,0x7c10,0x9bae,0xf820,0xf800,0xf800,0xba49,0x7430,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7c10,0x83cf,0xf061,0xf800,0xf800,0xf800,0xd1e7,0x7c30,0x7bef,0x7430,0xba69,0xf800,0xf800,0xf800,0xf800,0xf800,0xc249,0x7c51,0x7c10,0x9bcf,0xf841,0xf800,0xf800,0xc208,0x7451,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7c10,0x8bcf,0xf841,0xf800,0xf800,0xf800,0xb269,0x7430,0x7bef,0x7c30,0xc9e7,0xf800,0xf800,0xf800,0xf800,0xf800,0xaaaa,0x7c30,0x7c10,0x9bcf,0xf841,0xf800,0xf800,0xca08,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7c10,0x9bcf,0xf841,0xf800,0xf800,0xf800,0xaaeb,0x7c30,0x7c10,0x7c10,0xd165,0xf800,0xf800,0xf800,0xf800,0xf800,0xa30c,0x7c30,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xd208,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7c10,0xa38e,0xf820,0xf800,0xf800,0xf800,0x9b4d,0x7c10,0x7c10,0x8410,0xe124,0xf800,0xf800,0xf800,0xf800,0xf820,0x938e,0x7c10,0x7430,0xba49,0xf800,0xf800,0xf800,0xd1e7,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf841,0x8bcf,0x7c10,0x7c10,0x83cf,0xf0a2,0xf800,0xf800,0xf800,0xf800,0xf082,0x83ef,0x7c10,0x7c51,0xca08,0xf800,0xf800,0xf800,0xca08,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf061,0x83cf,0x7c10,0x7c10,0x8bef,0xf841,0xf800,0xf800,0xf800,0xf800,0xd9a6,0x7c30,0x7c10,0x7c10,0xd186,0xf800,0xf800,0xf800,0xc228,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7c10,0x9bae,0xf820,0xf800,0xf800,0xe904,0x83ef,0x7c10,0x7c10,0xa34d,0xf820,0xf800,0xf800,0xf800,0xf800,0xc228,0x7451,0x7c10,0x8410,0xe124,0xf800,0xf800,0xf800,0xba08,0x7430,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7c10,0x9bcf,0xf841,0xf800,0xf800,0xe145,0x8410,0x7c10,0x7c51,0xba28,0xf800,0xf800,0xf800,0xf800,0xf800,0xb269,0x7430,0x7c10,0x83ef,0xf082,0xf800,0xf800,0xf800,0xb28a,0x7430,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7c10,0x8bcf,0xf841,0xf800,0xf800,0xf061,0x83cf,0x7c10,0x7c30,0xd186,0xf800,0xf800,0xf800,0xf800,0xf800,0xaaeb,0x7c30,0x7c10,0xa34d,0xf820,0xf800,0xf800,0xf800,0xaaeb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7c10,0x83cf,0xf0a2,0xf800,0xf800,0xf800,0xaaeb,0x7471,0x938e,0xf061,0xf800,0xf800,0xf800,0xf800,0xf820,0x9b6d,0x7c10,0x7c30,0xc208,0xf800,0xf800,0xf800,0xf800,0xa30c,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7c10,0x8410,0xe124,0xf800,0xf800,0xf800,0xf041,0xd1e7,0xf0a2,0xf800,0xf800,0xf800,0xf800,0xf800,0xf0a2,0x83ef,0x7c10,0x7c10,0xd965,0xf800,0xf800,0xf800,0xf820,0x938e,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xd186,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xd1e7,0x7c30,0x7c10,0x83ef,0xe8a2,0xf800,0xf800,0xf800,0xf0a2,0x83ef,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0xba8a,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xb2aa,0x7430,0x7c30,0xab2c,0xf800,0xf800,0xf800,0xf800,0xd1c7,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x93ae,0xf861,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf841,0x936d,0x7c10,0x7c30,0xc9c7,0xf800,0xf800,0xf800,0xf800,0xb269,0x7430,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c30,0xd965,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xc9e7,0x7c30,0x7c10,0x83ef,0xe8c3,0xf800,0xf800,0xf800,0xf800,0xa30c,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0xa32c,0xf841,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf061,0x938e,0x7c10,0x7c10,0x8bef,0xe145,0xf800,0xf800,0xf800,0xf841,0x8bae,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0xba49,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf820,0xaacb,0x7c30,0x7bef,0x7bef,0x7c10,0x8410,0xa30c,0xd186,0xf820,0xd965,0x7c30,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xb2aa,0xe8a2,0xf800,0xf800,0xf800,0xe8c3,0xab0c,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c30,0x7c30,0x9b8e,0x9b4d,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0x7c10,0x7451,0x7c10,0xa34d,0xb249,0xa34d,0x8430,0x7430,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7430,0x7430,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x8bef,0x9b6d,0x9b6d,0x9b6d,0x938e,0x938e,0x93ae,0x938e,0x936d,0x9b6d,0x9b6d,0x9b6d,0x9b6d,0x9b6d,0x9b6d,0x9b6d,0x9b6d,0x9b6d,0x9b6d,0x9b6d,0x93cf,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf820,0xf820,0xf820,0xf820,0xf820,0xf820,0xf820,0xf820,0xf820,0xf820,0xf820,0xf820,0xf820,0xf820,0xf820,0xf820,0xf820,0xf820,0xf800,0xd208,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xd208,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xd208,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xd208,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xd208,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xd208,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xa36d,0xf0e3,0xe8c3,0xe8c3,0xe8c3,0xe8c3,0xe8c3,0xe8c3,0xe8c3,0xf800,0xf800,0xf800,0xf800,0xf0a2,0xe8e3,0xe8c3,0xe8c3,0xe8c3,0xe8c3,0xf0a2,0xca69,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x83ef,0x83ef,0x83ef,0x83ef,0x83ef,0x83ef,0x83ef,0x83ef,0x8bae,0xf041,0xf800,0xf800,0xf800,0xa2eb,0x7c10,0x83ef,0x83ef,0x83ef,0x83ef,0x83ef,0x83ef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x83cf,0xf041,0xf800,0xf800,0xf800,0x9b0c,0x7c30,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x83cf,0xf041,0xf800,0xf800,0xf800,0x9aeb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x83cf,0xf041,0xf800,0xf800,0xf800,0x9aeb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x83cf,0xf041,0xf800,0xf800,0xf800,0x9aeb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x83cf,0xf041,0xf800,0xf800,0xf800,0x9aeb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x83cf,0xf041,0xf800,0xf800,0xf800,0x9aeb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x83cf,0xf041,0xf800,0xf800,0xf800,0x9aeb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x83cf,0xf041,0xf800,0xf800,0xf800,0x9aeb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x83cf,0xf041,0xf800,0xf800,0xf800,0x9aeb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x83cf,0xf041,0xf800,0xf800,0xf800,0x9aeb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x83cf,0xf041,0xf800,0xf800,0xf800,0x9aeb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7430,0x7430,0x7430,0x7430,0x7430,0x7430,0x7451,0x7bef,0xf061,0xf800,0xf800,0xf800,0x9b2c,0x7451,0x7430,0x7430,0x7430,0x7430,0x7430,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x93ae,0xb2aa,0xb28a,0xb28a,0xb28a,0xb28a,0xb28a,0xb2aa,0xba69,0xf841,0xf800,0xf800,0xf800,0xc1e7,0xb2aa,0xb28a,0xb28a,0xb28a,0xb28a,0xba8a,0xa34d,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xd208,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xd208,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xd208,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xd208,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xd208,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xd208,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x93ae,0xc228,0xca08,0xca08,0xca08,0xca08,0xca08,0xca08,0xca08,0xca08,0xca08,0xca08,0xca08,0xca08,0xca08,0xca08,0xca08,0xca08,0xca08,0xc9c7,0xb30c,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x9bae,0xa34d,0x7471,0x7471,0x7c51,0x7c51,0x7c51,0x7c51,0x7c51,0x7c51,0x7c51,0x7c51,0x7c51,0x7c51,0x7c51,0x7c51,0x7c51,0x7c51,0x7c51,0x7c51,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf820,0xd1a6,0x8b8e,0x7430,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf061,0xb28a,0x8410,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xe145,0x9b4d,0x7c30,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf820,0xca08,0x8bae,0x7c30,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x9b8e,0xf0a2,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf082,0xaaaa,0x7c10,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x8bcf,0xc9c7,0xf820,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xd965,0x9b6d,0x7c30,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c30,0xa30c,0xe0e3,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf820,0xc249,0x8bef,0x7c30,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0x8410,0xe124,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xe8c3,0xaaeb,0x7c30,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xd145,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xd186,0x938e,0x7c30,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xd924,0xf800,0xf800,0xf800,0xf820,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf841,0xba69,0x83ef,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xd924,0xf800,0xf800,0xf800,0xba8a,0xba49,0xf841,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xe904,0xa32c,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xd924,0xf800,0xf800,0xf800,0xb2aa,0x7471,0x9b6d,0xd965,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xba8a,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xd924,0xf800,0xf800,0xf800,0xb28a,0x7430,0x7c10,0x7c30,0xb2cb,0xe8a2,0xf800,0xf800,0xf800,0xf800,0xf800,0xd208,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xd924,0xf800,0xf800,0xf800,0xb28a,0x7430,0x7bef,0x7c10,0x7c30,0x8410,0xc208,0xf820,0xf800,0xf800,0xf800,0xd208,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xd924,0xf800,0xf800,0xf800,0xb28a,0x7430,0x7bef,0x7bef,0x7c30,0x7c30,0xa30c,0xf082,0xf800,0xf800,0xf800,0xd208,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xd924,0xf800,0xf800,0xf800,0xb28a,0x7430,0x7c10,0x7c30,0x938e,0xd965,0xf800,0xf800,0xf800,0xf800,0xf800,0xd208,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xd924,0xf800,0xf800,0xf800,0xb28a,0x7451,0x7c30,0xb2eb,0xf841,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xd208,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xd924,0xf800,0xf800,0xf800,0xb2aa,0x9b4d,0xd965,0xf820,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xd208,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xd924,0xf800,0xf800,0xf800,0xf0a2,0xf820,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xd208,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xd145,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xd208,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0x7c30,0xd924,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf082,0xaaeb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7451,0x8bae,0xc9e7,0xf820,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf820,0xd1c7,0x8bcf,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x8410,0xb2aa,0xf082,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xe0e3,0xa32c,0x7c30,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x8bcf,0xe124,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf082,0xba49,0x8410,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf820,0xd1a6,0x93ae,0x7c30,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xe8e3,0xa32c,0x7c30,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf061,0xc228,0x83ef,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf820,0xd186,0x938e,0x7c30,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xe8c3,0xab0c,0x7c30,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf861,0xc208,0x83ef,0x7c30,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xd965,0x936d,0x7c30,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab0c,0xe8e3,0xaaeb,0x7c30,0x7c30,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x93ae,0x93ae,0x7bef,0x83cf,0x83cf,0x83cf,0x83cf,0x83cf,0x83cf,0x83cf,0x83cf,0x83cf,0x83cf,0x83cf,0x83cf,0x83cf,0x83cf,0x83cf,0x83cf,0x83cf,0x83ef,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xa34d,0xf082,0xf061,0xf061,0xf061,0xf061,0xf061,0xf061,0xf061,0xf061,0xf061,0xf061,0xf061,0xf061,0xf061,0xf061,0xf061,0xf061,0xf061,0xf041,0xd965,0x83ef,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf061,0x8bcf,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf820,0x93ae,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf820,0x9b4d,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xa2eb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xaaeb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab4d,0xf841,0xf841,0xf841,0xf841,0xf841,0xf841,0xf841,0xf841,0xf041,0xf841,0xf841,0xf841,0xf841,0xf841,0xf841,0xf841,0xf820,0xf800,0xf800,0xf800,0xaaeb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x83ef,0x8bcf,0x8bcf,0x8bcf,0x8bcf,0x8bcf,0x8bcf,0x8bcf,0x8bef,0x93cf,0x8bef,0x8bef,0x8bcf,0x8bcf,0x8bcf,0x8bcf,0x8c10,0xb2cb,0xf800,0xf800,0xf800,0xaacb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7c30,0x83ef,0xd945,0xba49,0x8410,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x93ef,0xf841,0xf800,0xf800,0xb28a,0x7430,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xd186,0xf800,0xf800,0xba49,0x7430,0x7bef,0x7bef,0x7bef,0x7c10,0x83cf,0xf061,0xf800,0xf800,0xb28a,0x7430,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c51,0xc208,0xf800,0xf800,0xf800,0xb269,0x7430,0x7bef,0x7bef,0x7bef,0x7c10,0x83ef,0xe8c3,0xf800,0xf800,0xb28a,0x7430,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7430,0xb2aa,0xf800,0xf800,0xf800,0xf800,0xaaeb,0x7c30,0x7bef,0x7bef,0x7bef,0x7c10,0x83ef,0xe104,0xf800,0xf800,0xb28a,0x7430,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0xa32c,0xf841,0xf800,0xf800,0xf800,0xf800,0xa2eb,0x7c30,0x7bef,0x7bef,0x7bef,0x7c10,0x8410,0xe124,0xf800,0xf800,0xb28a,0x7430,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0x938e,0xf082,0xf800,0xf800,0xf800,0xf800,0xf800,0x9b0c,0x7c30,0x7bef,0x7bef,0x7bef,0x7c10,0x83ef,0xe104,0xf800,0xf800,0xb28a,0x7430,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x8bcf,0xe0e3,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xa30c,0x7c30,0x7bef,0x7bef,0x7bef,0x7c10,0x83ef,0xe8c3,0xf800,0xf800,0xb28a,0x7430,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x8410,0xd965,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xaacb,0x7c30,0x7bef,0x7bef,0x7bef,0x7c10,0x8bef,0xf061,0xf800,0xf800,0xb2cb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c30,0xc9e7,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xba49,0x7451,0x7bef,0x7bef,0x7bef,0x7c30,0xa34d,0xf800,0xf800,0xf800,0xaaeb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0xba8a,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xe8e3,0x83ef,0x7c10,0x7bef,0x7bef,0x7451,0xc9e7,0xf800,0xf800,0xf800,0xa30c,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x9b8e,0xf841,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xb28a,0x7451,0x7c10,0x7430,0x8bae,0xf0a2,0xf800,0xf800,0xf820,0x9b6d,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf0c3,0xf800,0xf800,0xf800,0xf841,0xba69,0x936d,0xa32c,0xe124,0xf800,0xf800,0xf800,0xf841,0x8bcf,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xd186,0x9bae,0xf841,0xf800,0xf800,0xf800,0xf800,0xf820,0xf800,0xf800,0xf800,0xf800,0xf800,0xe904,0x83ef,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xe104,0x8bef,0x7c10,0xe8c3,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xca28,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf0a2,0x938e,0x7c30,0x7c30,0xd1a6,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xaacb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf841,0xa32c,0x7c30,0x7bef,0x7c30,0xa34d,0xf820,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf841,0x938e,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xb2cb,0x7c51,0x7bef,0x7bef,0x7bef,0x7c30,0xd186,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xc9e7,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xc228,0x7c30,0x7c10,0x7bef,0x7bef,0x7bef,0x7c10,0x938e,0xf082,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf082,0x938e,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xd165,0x7c10,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0xa30c,0xf082,0xf800,0xf800,0xf800,0xf800,0xf082,0xa32c,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab0c,0xe124,0x8bef,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0x93cf,0xc9e7,0xe124,0xe124,0xc9e7,0x93ae,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x9b8e,0x93ae,0x7451,0x7c30,0x7c30,0x7c30,0x7c30,0x7c30,0x7c30,0x7c30,0x7c30,0x7c30,0x7430,0x7451,0x7c30,0x7c30,0x7451,0x7451,0x7c30,0x7c30,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x8bcf,0xa30c,0xa2eb,0xa2eb,0xa2eb,0xa2eb,0xa2eb,0xa2eb,0xa2eb,0xa2eb,0xa2eb,0xa2eb,0xa2eb,0xa2eb,0xa2eb,0xa2eb,0xa2eb,0xa2eb,0xa2eb,0xa2cb,0x9b4d,0x8410,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf082,0x83cf,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf841,0x8bcf,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf820,0x9b6d,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xa30c,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xa2eb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0xab2c,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xaaeb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x9b6d,0xd945,0xd924,0xd924,0xd924,0xd924,0xd145,0xe124,0xf800,0xf800,0xf800,0xe8a2,0xd145,0xd924,0xd924,0xd924,0xd145,0xe104,0xf800,0xf800,0xf800,0xb2aa,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7430,0xaaeb,0xf800,0xf800,0xf800,0xb269,0x7451,0x7c10,0x7c10,0x7c10,0x7c30,0x9bae,0xf820,0xf800,0xf800,0xb28a,0x7430,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0x7c10,0x7c10,0x7c10,0x7451,0xba28,0xf800,0xf800,0xf800,0xa30c,0x7c30,0x7c10,0x7c10,0x7c10,0x7c10,0x8bcf,0xf041,0xf800,0xf800,0xba28,0x7430,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c51,0xc9e7,0xf800,0xf800,0xf820,0x936d,0x7c10,0x7bef,0x7bef,0x7bef,0x7c10,0x83cf,0xf082,0xf800,0xf800,0xba08,0x7451,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0xd1c7,0xf800,0xf800,0xf041,0x8bcf,0x7c10,0x7bef,0x7bef,0x7bef,0x7c10,0x83ef,0xe8c3,0xf800,0xf800,0xba08,0x7451,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xd165,0xf800,0xf800,0xf061,0x83cf,0x7c10,0x7bef,0x7bef,0x7bef,0x7c10,0x83ef,0xe8e3,0xf800,0xf800,0xc228,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xd924,0xf800,0xf800,0xf061,0x83cf,0x7c10,0x7bef,0x7bef,0x7bef,0x7c10,0x8410,0xe104,0xf800,0xf800,0xba08,0x7451,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xd924,0xf800,0xf800,0xf061,0x83cf,0x7c10,0x7bef,0x7bef,0x7bef,0x7c10,0x83ef,0xe8e3,0xf800,0xf800,0xba08,0x7451,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xd924,0xf800,0xf800,0xf061,0x83cf,0x7c10,0x7bef,0x7bef,0x7bef,0x7c10,0x83cf,0xe8a2,0xf800,0xf800,0xba69,0x7430,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xd186,0xf800,0xf800,0xf820,0x938e,0x7c10,0x7bef,0x7bef,0x7bef,0x7c10,0x8bcf,0xf041,0xf800,0xf800,0xb2aa,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0xc9e7,0xf800,0xf800,0xf800,0xaaeb,0x7430,0x7bef,0x7bef,0x7bef,0x7c30,0xb2cb,0xf800,0xf800,0xf800,0xaaeb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7451,0xc208,0xf800,0xf800,0xf800,0xd986,0x7c30,0x7c10,0x7bef,0x7c10,0x7c51,0xd186,0xf800,0xf800,0xf800,0xa30c,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0xaaeb,0xf800,0xf800,0xf800,0xf800,0xb28a,0x7c51,0x7430,0x7451,0xa30c,0xf820,0xf800,0xf800,0xf820,0x9b6d,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x8bef,0xf061,0xf800,0xf800,0xf800,0xf820,0xc9e7,0xaaeb,0xc249,0xf841,0xf800,0xf800,0xf800,0xf041,0x8bcf,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c10,0xe124,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xe124,0x8410,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0xc228,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xc249,0x7c51,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x93cf,0xf082,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xaaeb,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0xc9e7,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf082,0x8bcf,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x8bef,0xe8c3,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xba69,0x7c30,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0xa32c,0xf061,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xe104,0x8bcf,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c51,0xa32c,0xe8a2,0xf800,0xf800,0xf800,0xf800,0xe124,0x938e,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c30,0x83ef,0xb2aa,0xc9e7,0xc9e7,0xab0c,0x7c10,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7c10,0x7c30,0x7c51,0x7c51,0x7c30,0x7c10,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,
-	0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef,0x7bef};
+static int      logo_screen_width __initdata = 320;
+static int      logo_screen_height __initdata = 240;
+static unsigned short   logo_screen_data[] __initdata ={
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xFF10,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD56B,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0xD56B,0xE60B,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD5B1,0xD56B,0xC484,0xABC5,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xC460,0xBC00,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xC484,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0xE540,0xC460,0xBC00,0xBC00,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xBC00,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xE540,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE20,0xE540,0xBC00,0xC50D,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xC484,0xE540,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xF5E0,0xEDA0,0xE540,0xE540,0xE540,0xE540,0xEDA0,0xEDA0,0xF5E0,0xFE20,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xE540,0xBC00,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBC00,0xEDA0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xD4E0,0xBC25,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBC25,0xC460,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0xC460,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xAB60,0xC460,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xE540,0xD56B,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xC50D,0xB3C0,0xD4E0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE63,0xFE63,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0xBC00,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xABA4,0xBC00,0xD4E0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE63,0xFE63,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xC460,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xBC00,0xD4E0,0xEDA0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xD4E0,0xD5B1,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD56B,0xAB60,0xBC00,0xD4E0,0xEDA0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE63,0xFE62,0xFE62,0xFE63,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xE540,0xD56B,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBC25,0xAB60,0xC460,0xD4E0,0xEDA0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0xBC25,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xB3C0,0xC460,0xD4E0,0xEDA0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0xAB60,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xB3C0,0xC460,0xD4E0,0xEDA0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0xB3C0,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xCD2D,0xAB60,0xBC00,0xC460,0xD4E0,0xEDA0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0xB3C0,0xD5B1,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBC25,0xAB60,0xBC00,0xC460,0xD4E0,0xEDA0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0xBC00,0xC484,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xAB60,0xBC00,0xC460,0xE540,0xEDA0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xE540,0xBC00,0xAB60,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xAB60,0xBC00,0xD4E0,0xE540,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xE540,0xC460,0xAB60,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD5B1,0xA320,0xB3C0,0xC460,0xD4E0,0xE540,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xE540,0xC460,0xAB60,0xC50D,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xB469,0xAB60,0xB3C0,0xC460,0xD4E0,0xE540,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0xD4E0,0xB3C0,0xAB60,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xAB60,0xAB60,0xBC00,0xC460,0xD4E0,0xE540,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0xD4E0,0xC460,0xAB60,0xC50D,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x92C0,0xAB60,0xBC00,0xC460,0xD4E0,0xE540,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xE540,0xD4E0,0xBC00,0xAB60,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xAB60,0xBC00,0xC460,0xD4E0,0xE540,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xE540,0xD4E0,0xBC00,0xAB60,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xCD2D,0xA320,0xB3C0,0xBC00,0xC460,0xD4E0,0xEDA0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xEDA0,0xD4E0,0xBC00,0xAB60,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBC25,0xAB60,0xB3C0,0xC460,0xD4E0,0xE540,0xEDA0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0xE540,0xC460,0xB3C0,0xD5B1,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xAB60,0xB3C0,0xC460,0xD4E0,0xE540,0xEDA0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0xD4E0,0xBC00,0xC50D,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xAB60,0xBC00,0xC460,0xD4E0,0xE540,0xEDA0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0xD4E0,0xBC25,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD5B1,0xA320,0xAB60,0xBC00,0xC460,0xD4E0,0xE540,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0xD4E0,0xD56B,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xC50D,0xA320,0xB3C0,0xBC00,0xC460,0xD4E0,0xE540,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE62,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xE540,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xABC5,0xAB60,0xB3C0,0xC460,0xD4E0,0xD4E0,0xEDA0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE62,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xF66B,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x9CF3,0x8C30,0x630C,0x73AE,0x8C30,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xAB60,0xB3C0,0xC460,0xD4E0,0xE540,0xEDA0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE62,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE63,0x7453,0x7453,0x7453,0x7453,0x7453,0x630C,0x2944,0x0840,0x0840,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x73AE,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xAB60,0xBC00,0xC460,0xD4E0,0xE540,0xEDA0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0x94B2,0x2944,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x630C,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD5B1,0xA320,0xAB60,0xBC00,0xC460,0xD4E0,0xE540,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xE540,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x73AE,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xB469,0xAB60,0xB3C0,0xBC00,0xC460,0xD4E0,0xE540,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xC460,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xAB60,0xB3C0,0xC460,0xD4E0,0xD4E0,0xEDA0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xABA4,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xAB60,0xBC00,0xC460,0xD4E0,0xE540,0xEDA0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x4A69,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD56B,0xA320,0xAB60,0xBC00,0xC460,0xD4E0,0xE540,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0x9324,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x630C,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xABC5,0xAB60,0xB3C0,0xBC00,0xC460,0xD4E0,0xE540,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x630C,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xAB60,0xB3C0,0xC460,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x4A49,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD5B1,0xA320,0xAB60,0xBC00,0xC460,0xD4E0,0xE540,0xEDA0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x2944,0x8C30,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBC25,0xAB60,0xB3C0,0xBC00,0xC460,0xD4E0,0xE540,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x4A69,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xAB60,0xB3C0,0xC460,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xD4E0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x1081,0x1081,0x1081,0x1081,0x1081,0x1081,0x0840,0x0840,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x630C,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD5B1,0xA320,0xAB60,0xBC00,0xC460,0xD4E0,0xE540,0xEDA0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0x51C0,0x0000,0x0000,0x0000,0x0000,0x0840,0x1081,0x18C2,0x18C2,0x2944,0x2944,0x2944,0x2944,0x2944,0x2944,0x2944,0x18C2,0x18C2,0x18C2,0x1081,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x2944,0x8C30,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xABC5,0xAB60,0xB3C0,0xBC00,0xC460,0xD4E0,0xE540,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xC484,0x0000,0x0000,0x0000,0x0840,0x1081,0x18C2,0x2944,0x2944,0x39C7,0x39C7,0x39C7,0x4A49,0x4A49,0x4A49,0x4A49,0x39C7,0x39C7,0x39C7,0x39C7,0x2944,0x18C2,0x18C2,0x0840,0x0000,0x0840,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x4A49,0x94B2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xAB60,0xB3C0,0xC460,0xD4E0,0xE540,0xEDA0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xD4E0,0x0840,0x0000,0x0000,0x0840,0x18C2,0x2944,0x39C7,0x39C7,0x4A49,0x4A49,0x4A49,0x4A49,0x4A49,0x4A49,0x4A49,0x4A49,0x4A49,0x4A49,0x4A49,0x39C7,0x2944,0x2944,0x18C2,0x0000,0x0840,0x0840,0x1081,0x1081,0x0840,0x0840,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x52AA,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xCD2D,0xA320,0xAB60,0xBC00,0xC460,0xD4E0,0xE540,0xEDA0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0x4140,0x0000,0x0000,0x1081,0x2944,0x39C7,0x4A49,0x4A49,0x4A49,0x4A49,0x39C7,0x39C7,0x2944,0x2944,0x18C2,0x18C2,0x18C2,0x18C2,0x18C2,0x18C2,0x18C2,0x18C2,0x18C2,0x0840,0x0000,0x0840,0x1081,0x1081,0x18C2,0x18C2,0x18C2,0x1081,0x1081,0x0840,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x2944,0x94B2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xABA4,0xAB60,0xB3C0,0xC460,0xC460,0xD4E0,0xE540,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0x51C0,0x0000,0x0000,0x18C2,0x2944,0x39C7,0x4A49,0x4A49,0x39C7,0x2944,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x1081,0x18C2,0x18C2,0x18C2,0x2944,0x2944,0x18C2,0x18C2,0x18C2,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x630C,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xAB60,0xBC00,0xC460,0xD4E0,0xE540,0xEDA0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0x51C0,0x0000,0x0000,0x18C2,0x2944,0x4A49,0x4A49,0x39C7,0x18C2,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x2944,0x2944,0x2944,0x2944,0x2944,0x2944,0x18C2,0x18C2,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x4A49,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xB469,0xA320,0xB3C0,0xBC00,0xC460,0xD4E0,0xE540,0xEDA0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xD4E0,0x4140,0x0000,0x0000,0x1081,0x2944,0x4A49,0x4A49,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x1081,0x2944,0x2944,0x39C7,0x39C7,0x2944,0x2944,0x2944,0x18C2,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x39C7,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xAB60,0xB3C0,0xC460,0xC460,0xD4E0,0xE540,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xD4E0,0x0840,0x0000,0x0000,0x0000,0x1081,0x2944,0x2944,0x1081,0x0840,0x0840,0x1081,0x1081,0x1081,0x1081,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x2944,0x39C7,0x39C7,0x39C7,0x2944,0x2944,0x18C2,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x39C7,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD5B1,0xA320,0xAB60,0xBC00,0xC460,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xC460,0x0840,0x0000,0x0000,0x1081,0x4A49,0x73AE,0x8C30,0x8C30,0x94B2,0x94B2,0x94B2,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x94B2,0x94B2,0x8C30,0x630C,0x4A49,0x39C7,0x2944,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x1081,0x2944,0x2944,0x39C7,0x39C7,0x2944,0x2944,0x18C2,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x52AA,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xABC5,0xA320,0xB3C0,0xBC00,0xC460,0xD4E0,0xE540,0xEDA0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0x6260,0x0840,0x0000,0x0000,0x0000,0x630C,0xB596,0xDEDA,0xF77D,0xF79D,0xF79D,0xF79D,0xF79D,0xF79D,0xF7BE,0xF7BE,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xF79D,0xF77D,0xEF3C,0xD679,0xC617,0x9CF3,0x73AE,0x4A49,0x2944,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x2944,0x39C7,0x39C7,0x2944,0x2944,0x18C2,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x73AE,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xAB60,0xB3C0,0xC460,0xC460,0xD4E0,0xE540,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0x6260,0x0000,0x0000,0x0000,0x0000,0x39C7,0xB596,0xF79D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xE71B,0xC617,0x9CF3,0x73AE,0x4A49,0x2944,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x2944,0x39C7,0x39C7,0x2944,0x2944,0x18C2,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xCD2D,0xA320,0xAB60,0xBC00,0xC460,0xD4E0,0xD4E0,0xE540,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xD4E0,0x18C2,0x0000,0x0000,0x0000,0x0000,0x18C2,0xB596,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF5D,0xDEDA,0xB596,0x94B2,0x73AE,0x4A49,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x2944,0x39C7,0x39C7,0x2944,0x18C2,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x52AA,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xABA4,0xA320,0xB3C0,0xBC00,0xC460,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0x6260,0x0840,0x0000,0x0000,0x0000,0x0000,0x1081,0x9CF3,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xEF3C,0xD679,0xB596,0x8C30,0x4A49,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x2944,0x2944,0x2944,0x2944,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xD4E0,0x51C0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x8C30,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xD679,0x9CF3,0x630C,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x18C2,0x2944,0x18C2,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x630C,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xCD2D,0xA320,0xAB60,0xB3C0,0xC460,0xC460,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0x9324,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x630C,0xF79D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xE71B,0xB596,0x73AE,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x1081,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xABA4,0xA320,0xAB60,0xBC00,0xC460,0xD4E0,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xD4E0,0x51C0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4A69,0xEF3C,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF3C,0xB596,0x73AE,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x8C30,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x92C0,0xAB60,0xB3C0,0xBC00,0xC460,0xD4E0,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0x9324,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0xDEDA,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF3C,0xB596,0x630C,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4A69,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xD4E0,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xD4E0,0x51C0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0xC617,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xE71B,0xB596,0x52AA,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xB469,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xD4E0,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0x6260,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0xB596,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xDEDA,0x9CF3,0x4A49,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xABC5,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xD4E0,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xC484,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x8C30,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xC617,0x8C30,0x39C7,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x630C,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xD4E0,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xE540,0x6260,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x73AE,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xE71B,0xB596,0x8C30,0x39C7,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x92C0,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xD4E0,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xABA4,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x52AA,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xD679,0x9CF3,0x8C30,0x4A49,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x92C0,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xD4E0,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xD4E0,0x51C0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0xE71B,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xDEDA,0xB596,0x9CF3,0x8C30,0x630C,0x39C7,0x18C2,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x94B2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x92C0,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xD4E0,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0x6260,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0xD679,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xE71B,0xC617,0xB596,0x9CF3,0x8C30,0x73AE,0x630C,0x4A49,0x2944,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x52AA,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x92C0,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xD4E0,0xD4E0,0xE540,0xE540,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE63,0xFE63,0xFE63,0xFE63,0xFE63,0xFE63,0xFE63,0xFE62,0xFE62,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xABC5,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0xB596,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF3C,0xD679,0xB596,0x9CF3,0x8C30,0x73AE,0x73AE,0x630C,0x630C,0x4A69,0x2944,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x92C0,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xE540,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE63,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xE540,0x6260,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x94B2,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xE71B,0xC617,0xB596,0x94B2,0x8C30,0x73AE,0x73AE,0x73AE,0x73AE,0x73AE,0x630C,0x528A,0x2944,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x94B2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x92C0,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE62,0xFE60,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0x9324,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x630C,0xF79D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xDEDA,0xC617,0x9CF3,0x94B2,0x8C30,0x8C30,0x8C30,0x8C30,0x8C30,0x8C30,0x8C30,0x8C30,0x73AE,0x4A49,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x4A49,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xABC5,0xA320,0xAB60,0xAB60,0xBC00,0xBC00,0xC460,0xD4E0,0xD4E0,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xD4E0,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4A49,0xE71B,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xD679,0xB596,0x9CF3,0x94B2,0x94B2,0x94B2,0x94B2,0x94B2,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x94B2,0x8C30,0x630C,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x8C30,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xCD2D,0x92C0,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xE540,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0x6260,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0xD679,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xE71B,0xC617,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0xB596,0xB596,0xC617,0xD679,0xD679,0xD679,0xC617,0xB596,0x94B2,0x630C,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xA320,0xAB60,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xE540,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xC484,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0xB596,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xD679,0xB596,0x9CF3,0x9CF3,0xB596,0xB596,0xC617,0xDEDA,0xEF5D,0xF79D,0xFFFF,0xFFFF,0xF7BE,0xF79D,0xE71B,0xC617,0x9CF3,0x630C,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x2944,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8C30,0x73AE,0x630C,0x52AA,0x4A69,0x4A49,0x2944,0x2944,0x18C2,0x18C2,0x18C2,0x18C2,0x18C2,0x1081,0x0840,0x0840,0x0840,0x0840,0x0000,0x0000,0x0000,0x0000,0x0840,0x0840,0x0840,0x0840,0x0840,0x1081,0x18C2,0x18C2,0x2944,0x2944,0x4A69,0x630C,0x94B2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xCD2D,0x92C0,0xA320,0xAB60,0xB3C0,0xBC00,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xE540,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xE540,0x6260,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x8C30,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xDEDA,0xC617,0xB596,0xB596,0xB596,0xD679,0xE71B,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xC617,0x94B2,0x528A,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x39C7,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x630C,0x52AA,0x4A49,0x2944,0x2944,0x18C2,0x18C2,0x18C2,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x2944,0x52AA,0x94B2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xABC5,0xA320,0xAB60,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xC460,0xD4E0,0xD4E0,0xE540,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xBC25,0x52AA,0x528A,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x52AA,0xEF3C,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xE71B,0xD679,0xC617,0xC617,0xD679,0xE71B,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF3C,0xB596,0x8C30,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x18C2,0x18C2,0x1081,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x39C7,0x8C30,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xAB60,0xA320,0xAB60,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xC460,0xD4E0,0xD4E0,0xE540,0xEDA0,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0x6260,0x73AE,0xC617,0x8C30,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0xDEDA,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xDEDA,0xD679,0xD679,0xE71B,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xDEDA,0x9CF3,0x4A49,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x4A69,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xA320,0xAB60,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xD4E0,0xE540,0xEDA0,0xF5E0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xBC00,0x4A49,0x9CF3,0xEF5D,0xF79D,0x9CF3,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0xB596,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xE71B,0xDEDA,0xDEDA,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xC617,0x73AE,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x4A69,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xA320,0xAB60,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xE540,0xE540,0xEDA0,0xEDA0,0xF5E0,0xF5E0,0xF5E0,0xFE20,0xFE20,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xE540,0x92C0,0x52AA,0xB596,0xF7BE,0xFFFF,0xFFFF,0xB596,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x9CF3,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xE71B,0xEF5D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xE71B,0x9CF3,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x18C2,0x18C2,0x18C2,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x73AE,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD5B1,0x92C0,0xA320,0xAB60,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xE540,0xE540,0xE540,0xEDA0,0xEDA0,0xEDA0,0xEDA0,0xEDA0,0xF5E0,0xF5E0,0xF5E0,0xF5E0,0xF5E0,0xF5E0,0xEDA0,0xE540,0xC460,0x6260,0x73AE,0xD679,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xD679,0x39C7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x8C30,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xF77D,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xC617,0x630C,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x51C0,0x7A60,0xA320,0xAB60,0xA320,0xA320,0x7A60,0x4140,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x2944,0x39C7,0x4A69,0x630C,0x73AE,0x73AE,0x73AE,0x630C,0x4A49,0x2944,0x18C2,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xCD2D,0x92C0,0xA320,0xAB60,0xB3C0,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xE540,0xE540,0xE540,0xE540,0xE540,0xE540,0xE540,0xE540,0xE540,0xD4E0,0xC460,0xA320,0x6260,0x94B2,0xE71B,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0x630C,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x630C,0xE71B,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xB596,0x73AE,0x39C7,0x2944,0x2944,0x2944,0x2944,0x2944,0x39C7,0x39C7,0x39C7,0x4A49,0x4A49,0x4A49,0x39C7,0x39C7,0x2944,0x4140,0x92C0,0xAB60,0xAB60,0xBC00,0xBC00,0xBC00,0xBC00,0xB3C0,0xAB60,0x69C0,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x2944,0x630C,0x94B2,0xB596,0xDEDA,0xEF5D,0xF77D,0xF79D,0xF79D,0xF79D,0xF79D,0xEF5D,0xDEDA,0xB596,0x94B2,0x73AE,0x4A49,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xB469,0x92C0,0xA320,0xAB60,0xB3C0,0xBC00,0xBC00,0xC460,0xC460,0xC460,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xC460,0xBC00,0x7A60,0x528A,0xB596,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0x9CF3,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x52AA,0xDEDA,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xE71B,0xC617,0xB596,0x9CF3,0x9CF3,0x94B2,0x94B2,0x94B2,0x94B2,0x8C30,0x8C30,0x8C30,0x8C30,0x8C30,0x73AE,0x9324,0xAB60,0xA320,0x7A60,0x9324,0xCCC5,0xD4E0,0xD4E0,0xD4E0,0xC460,0xBC00,0xAB60,0x7A60,0x0840,0x0000,0x0000,0x0000,0x18C2,0x528A,0x9CF3,0xD679,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xD679,0xB596,0x94B2,0x73AE,0x4A49,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xABA4,0xA320,0xAB60,0xAB60,0xB3C0,0xBC00,0xBC00,0xBC00,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xBC00,0xBC00,0xAB60,0x51C0,0x630C,0xC617,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xD679,0x39C7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x52AA,0xD679,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xE71B,0xD679,0xC617,0xC617,0xB596,0xB596,0xB596,0x9CF3,0x9CF3,0x9CF3,0x94B2,0x8C30,0x9324,0xAB60,0xA320,0x69C0,0x69C0,0xABC5,0xEDA0,0xF5E0,0xEDA0,0xE540,0xD4E0,0xD4E0,0xC460,0xAB60,0x69C0,0x0000,0x0000,0x4A69,0xB596,0xEF5D,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xB596,0x630C,0x39C7,0x2944,0x2944,0x2944,0x4A49,0x8C30,0xE71B,0xFFFF,0xFFFF,0xF7BE,0xD679,0xB596,0x9CF3,0x8C30,0x630C,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x92C0,0xA320,0xAB60,0xAB60,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xBC00,0xBC00,0xBC00,0xBC00,0xBC00,0xBC00,0xBC00,0xB3C0,0xB3C0,0xAB60,0x7A60,0x2944,0x73AE,0xD679,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0x94B2,0x2944,0x1081,0x0000,0x0000,0x0000,0x0000,0x0840,0x2944,0x39C7,0x8C30,0xD679,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF5D,0xE71B,0xDEDA,0xD679,0xC617,0xB596,0xB596,0x9CF3,0x94B2,0x8C30,0x9324,0xAB60,0xAB60,0x69C0,0x61A0,0x9324,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE20,0xF5E0,0xE540,0xD4E0,0xC460,0xAB60,0x51C0,0x73AE,0xEF3C,0xFFFF,0xFFFF,0xFFFF,0xF79D,0x94B2,0x2944,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0xB596,0xFFFF,0xFFFF,0xF77D,0xD679,0xB596,0x9CF3,0x94B2,0x630C,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x94B2,0x92C0,0xA320,0xA320,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xA320,0x7A60,0x4140,0x0840,0x52AA,0xD679,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xDEDA,0x9CF3,0x8C30,0x73AE,0x73AE,0x73AE,0x8C30,0x94B2,0xB596,0xD679,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xEF3C,0xDEDA,0xD679,0xC617,0xB596,0x9CF3,0x9CF3,0x94B2,0x9324,0xAB60,0xB3C0,0x69C0,0x61A0,0x92C0,0xEDA0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xEDA0,0xD4E0,0xC460,0xAB60,0xD5B1,0xFFFF,0xFFFF,0xFFFF,0xE71B,0x4A49,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0xD679,0xFFFF,0xFFFF,0xF79D,0xDEDA,0xC617,0x9CF3,0x8C30,0x4A49,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4A49,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x18C2,0x69C0,0x7A60,0x92C0,0xA320,0xA320,0xA320,0xA320,0xA320,0xA320,0xA320,0x92C0,0x7A60,0x69C0,0x4140,0x0840,0x0000,0x2944,0xC617,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xEF5D,0xEF3C,0xEF3C,0xF77D,0xF79D,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xDEDA,0xD679,0xC617,0xB596,0x9CF3,0x9CF3,0x94B2,0x73AE,0xA320,0xB3C0,0x92C0,0x61A0,0x7A60,0xE540,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xEDA0,0xD4E0,0xC460,0xB3C0,0xDEDA,0xFFFF,0xD679,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x630C,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xE71B,0xC617,0x9CF3,0x73AE,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x8C30,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x630C,0x0000,0x0840,0x1081,0x2944,0x4140,0x4140,0x4140,0x4140,0x2944,0x18C2,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x8C30,0xF79D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF3C,0xDEDA,0xD679,0xC617,0xB596,0x9CF3,0x94B2,0x8C30,0x73AE,0xA320,0xB3C0,0xB3C0,0x69C0,0x69C0,0xD4E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0xD4E0,0xBC00,0xABA4,0xC617,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x39C7,0x39C7,0x0840,0x0000,0x39C7,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xD679,0x9CF3,0x73AE,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0xD679,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xE71B,0xDEDA,0xC617,0xB596,0xB596,0x9CF3,0x94B2,0x8C30,0x73AE,0x9324,0xAB60,0xBC00,0x7A60,0x61A0,0xA320,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0xD4E0,0xBC00,0xA320,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x73AE,0x94B2,0x8C30,0x18C2,0x0000,0x4A49,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xD679,0x9CF3,0x73AE,0x0000,0x0000,0x0000,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x52AA,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x630C,0xF79D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xF77D,0xEF3C,0xE71B,0xD679,0xD679,0xC617,0xC617,0xC617,0xC617,0xC617,0xC617,0xC617,0xC617,0xC617,0xC617,0xC617,0xD679,0xD679,0xDEDA,0xE71B,0xE71B,0xEF5D,0xF77D,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF5D,0xE71B,0xD679,0xC617,0xB596,0xB596,0x9CF3,0x94B2,0x8C30,0x73AE,0x9324,0xAB60,0xBC00,0xBC00,0x61A0,0x69C0,0xE540,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0xD4E0,0xBC00,0x7A60,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x2944,0x630C,0x94B2,0x9CF3,0x9CF3,0x94B2,0x18C2,0x0000,0x94B2,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xC617,0x9CF3,0x630C,0x0000,0x0000,0x1081,0x18C2,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8C30,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0xB596,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xEF3C,0xDEDA,0xC617,0xB596,0xB596,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0xB596,0xB596,0xB596,0xC617,0xD679,0xDEDA,0xE71B,0xEF5D,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xEF3C,0xDEDA,0xD679,0xC617,0xB596,0xB596,0x9CF3,0x94B2,0x8C30,0x73AE,0x9324,0xAB60,0xBC00,0xD4E0,0x92C0,0x61A0,0x92C0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xEDA0,0xD4E0,0xB3C0,0x51C0,0x0000,0x0000,0x0000,0x0840,0x630C,0x94B2,0x9CF3,0x9CF3,0x9CF3,0x94B2,0x4A69,0x0000,0x2944,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xE71B,0xB596,0x94B2,0x4A49,0x0000,0x0000,0x2944,0x2944,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4A49,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0xD679,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xDEDA,0xC617,0xB596,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0xB596,0xC617,0xDEDA,0xEF5D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xF77D,0xE71B,0xDEDA,0xD679,0xC617,0xB596,0x9CF3,0x9CF3,0x94B2,0x8C30,0x73AE,0x9324,0xAB60,0xBC00,0xD4E0,0xD4E0,0x69C0,0x61A0,0xD4E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0xD4E0,0xAB60,0x18C2,0x0000,0x0000,0x0840,0x4A49,0x630C,0x73AE,0x630C,0x630C,0x2944,0x0840,0x18C2,0xC617,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xD679,0x9CF3,0x8C30,0x18C2,0x0000,0x18C2,0x39C7,0x39C7,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4A49,0xEF3C,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF5D,0xDEDA,0xD679,0xC617,0xC617,0xC617,0xD679,0xD679,0xDEDA,0xDEDA,0xE71B,0xE71B,0xEF3C,0xEF3C,0xEF3C,0xEF3C,0xEF3C,0xEF3C,0xEF3C,0xE71B,0xE71B,0xE71B,0xDEDA,0xDEDA,0xD679,0xD679,0xD679,0xC617,0xC617,0xB596,0xB596,0xB596,0xB596,0xB596,0xC617,0xD679,0xE71B,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xEF5D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF5D,0xE71B,0xD679,0xD679,0xC617,0xB596,0x9CF3,0x9CF3,0x94B2,0x8C30,0x73AE,0x9324,0xAB60,0xBC00,0xC460,0xE540,0xC484,0x61A0,0x7A60,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0xD4E0,0xA320,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x528A,0xD679,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xE71B,0xB596,0x94B2,0x4A49,0x0000,0x0000,0x39C7,0x4A49,0x39C7,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x630C,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x630C,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xF7BE,0xF7BE,0xF7BE,0xF7BE,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xDEDA,0xEF5D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xEF3C,0xE71B,0xD679,0xC617,0xC617,0xB596,0x9CF3,0x9CF3,0x94B2,0x8C30,0x8C30,0x9324,0xAB60,0xBC00,0xC460,0xE540,0xF5E0,0xBC00,0x61A0,0x92C0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xEDA0,0xC460,0x9324,0x630C,0x4A49,0x39C7,0x39C7,0x39C7,0x528A,0x8C30,0xD679,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xC617,0x94B2,0x52AA,0x0840,0x0000,0x18C2,0x52AA,0x4A69,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x39C7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x94B2,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xE71B,0xC617,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xEF3C,0xE71B,0xD679,0xD679,0xC617,0xB596,0xB596,0x9CF3,0x94B2,0x8C30,0x8C30,0x73AE,0xAB60,0xBC00,0xC460,0xE540,0xF5E0,0xFE60,0xA320,0x61A0,0xB3C0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xB3C0,0xBC00,0xEDA0,0xC460,0xD679,0xFFFF,0xF7BE,0xF79D,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xD679,0x94B2,0x4A69,0x0840,0x0000,0x0840,0x528A,0x630C,0x39C7,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x94B2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x39C7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x9CF3,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF3C,0xD679,0xC617,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF5D,0xE71B,0xDEDA,0xD679,0xC617,0xB596,0xB596,0x9CF3,0x94B2,0x94B2,0x8C30,0x73AE,0xA320,0xB3C0,0xC460,0xD4E0,0xEDA0,0xFE20,0xFE60,0x92C0,0x61A0,0xC460,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xA320,0x92C0,0xD4E0,0xEDA0,0xC484,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xC617,0x8C30,0x2944,0x0000,0x0000,0x18C2,0x4A49,0x630C,0x528A,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x52AA,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xB596,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xDEDA,0xC617,0xC617,0xDEDA,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xEF3C,0xDEDA,0xD679,0xC617,0xB596,0xB596,0x9CF3,0x9CF3,0x94B2,0x8C30,0x8C30,0x9324,0xAB60,0xBC00,0xD4E0,0xEDA0,0xFE20,0xFE60,0xFE60,0x92C0,0x61A0,0xD4E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xD4E0,0x92C0,0xC460,0xFE60,0xD4E0,0xDEDA,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF3C,0xC617,0x9CF3,0x52AA,0x1081,0x0000,0x0840,0x2944,0x52AA,0x630C,0x528A,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x630C,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xC617,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xC617,0xC617,0xC617,0xE71B,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF5D,0xE71B,0xDEDA,0xD679,0xC617,0xB596,0xB596,0x9CF3,0x9CF3,0x94B2,0x8C30,0x73AE,0x9324,0xB3C0,0xC460,0xE540,0xF5E0,0xFE60,0xFE60,0xFE60,0x92C0,0x61A0,0xD4E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xC460,0xC460,0xFE60,0xF5E0,0xB469,0x9CF3,0xC617,0xD679,0xD679,0xD679,0xC617,0xB596,0x9CF3,0x73AE,0x4A69,0x18C2,0x0000,0x0000,0x0000,0x18C2,0x39C7,0x4A69,0x4A49,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x8C30,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x630C,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0xC617,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xDEDA,0xC617,0xC617,0xDEDA,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xEF5D,0xE71B,0xDEDA,0xD679,0xC617,0xB596,0xB596,0x9CF3,0x9CF3,0x94B2,0x8C30,0x73AE,0x9324,0xB3C0,0xC460,0xE540,0xFE20,0xFE60,0xFE60,0xFE60,0x92C0,0x61A0,0xD4E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xEDA0,0xFE60,0xFE60,0x92C0,0x0840,0x18C2,0x18C2,0x18C2,0x18C2,0x18C2,0x18C2,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x2944,0x2944,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x630C,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0xC617,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xD679,0xC617,0xD679,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF5D,0xE71B,0xDEDA,0xD679,0xC617,0xB596,0xB596,0x9CF3,0x9CF3,0x94B2,0x8C30,0x73AE,0xA320,0xBC00,0xD4E0,0xEDA0,0xFE60,0xFE60,0xFE60,0xFE20,0x92C0,0x61A0,0xC460,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xB3C0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x0840,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8C30,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0xC617,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xC617,0xC617,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xF77D,0xE71B,0xDEDA,0xD679,0xC617,0xB596,0xB596,0x9CF3,0x9CF3,0x94B2,0x8C30,0x73AE,0xA320,0xBC00,0xD4E0,0xEDA0,0xFE60,0xFE60,0xFE60,0xFE20,0x92C0,0x61A0,0xC460,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xBC00,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8C30,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0xC617,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xDEDA,0xC617,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xEF3C,0xDEDA,0xD679,0xC617,0xC617,0xB596,0x9CF3,0x9CF3,0x94B2,0x8C30,0x8C30,0xA320,0xBC00,0xD4E0,0xEDA0,0xFE60,0xFE60,0xFE60,0xFE60,0xA320,0x61A0,0xC460,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xBC00,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x73AE,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8C30,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xB596,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xC617,0xF79D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF5D,0xE71B,0xDEDA,0xD679,0xC617,0xB596,0xB596,0x9CF3,0x94B2,0x94B2,0x8C30,0xA320,0xBC00,0xD4E0,0xEDA0,0xFE60,0xFE60,0xFE60,0xFE60,0xAB60,0x61A0,0xB3C0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xC460,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x9CF3,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xB596,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xE71B,0xF79D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xEF3C,0xDEDA,0xD679,0xC617,0xB596,0xB596,0x9CF3,0x9CF3,0x94B2,0x8C30,0xA320,0xBC00,0xD4E0,0xEDA0,0xFE60,0xFE60,0xFE60,0xFE60,0xBC00,0x61A0,0xA320,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE60,0xFE60,0xFE60,0xFE60,0xC460,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x9CF3,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xB596,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF5D,0xE71B,0xDEDA,0xD679,0xC617,0xB596,0xB596,0x9CF3,0x94B2,0x8C30,0xA320,0xBC00,0xD4E0,0xEDA0,0xFE60,0xFE60,0xFE60,0xFE60,0xD4E0,0x69C0,0x7A60,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE62,0xFE60,0xF5E0,0xFE60,0xFE60,0xC460,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x9CF3,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xEF3C,0xDEDA,0xD679,0xC617,0xB596,0xB596,0x9CF3,0x9CF3,0x94B2,0xA320,0xBC00,0xD4E0,0xEDA0,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0x7A60,0x69C0,0xD4E0,0xFE60,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0xC460,0xFE20,0xFE60,0xC460,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x8C30,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xF77D,0xE71B,0xDEDA,0xD679,0xC617,0xB596,0xB596,0x9CF3,0x9CF3,0xA320,0xB3C0,0xC460,0xE540,0xFE20,0xFE60,0xFE60,0xFE60,0xFE20,0x92C0,0x61A0,0xAB60,0xFE60,0xFE62,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xBC00,0xA320,0xF5E0,0xFE60,0xC460,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x630C,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF5D,0xE71B,0xDEDA,0xD679,0xC617,0xB596,0xB596,0x9CF3,0xAB60,0xB3C0,0xC460,0xE540,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xC460,0x61A0,0x7A60,0xF5E0,0xFE62,0xFE86,0xFE86,0xFE63,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0xA320,0x92C0,0xF5E0,0xFE60,0xBC00,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4A49,0xEF5D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xEF3C,0xE71B,0xD679,0xC617,0xC617,0xB596,0x9CF3,0xABC5,0xAB60,0xC460,0xD4E0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0x7A60,0x61A0,0xC460,0xFE62,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xC460,0x92C0,0xA320,0xFE60,0xFE20,0x9324,0x18C2,0x2944,0x39C7,0x4A49,0x4A69,0x52AA,0x52AA,0x52AA,0x4A49,0x2944,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0xE71B,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xEF3C,0xDEDA,0xD679,0xC617,0xB596,0xB596,0x94B2,0xAB60,0xBC00,0xD4E0,0xEDA0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xA320,0x61A0,0x92C0,0xFE20,0xFE63,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xC460,0xAB60,0xD4E0,0xFE60,0xF5E0,0xABC5,0x9CF3,0xB596,0xB596,0xB596,0xC617,0xC617,0xC617,0xC617,0xB596,0x94B2,0x73AE,0x4A49,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0xD679,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xE71B,0xDEDA,0xD679,0xC617,0xB596,0xB596,0xABA4,0xB3C0,0xC460,0xE540,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xD4E0,0x69C0,0x69C0,0xD4E0,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0xF5E0,0xFE60,0xFE60,0xD4E0,0xD679,0xEF5D,0xF79D,0xF79D,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xF77D,0xDEDA,0xC617,0x9CF3,0x73AE,0x4A49,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0xC617,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF5D,0xE71B,0xDEDA,0xD679,0xC617,0xB596,0x9CF3,0xAB60,0xC460,0xD4E0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0x7A60,0x61A0,0xA320,0xFE60,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xCCC5,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xD679,0xB596,0x94B2,0x630C,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x9CF3,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF5D,0xE71B,0xDEDA,0xD679,0xC617,0xB596,0xABA4,0xB3C0,0xC460,0xE540,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xBC00,0x61A0,0x69C0,0xE540,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0xD679,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xE71B,0xC617,0x9CF3,0x73AE,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x8C30,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xEF5D,0xE71B,0xD679,0xD679,0xC617,0x9CF3,0xAB60,0xC460,0xD4E0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0x7A60,0x61A0,0xA320,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xD56B,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xDEDA,0xB596,0x9CF3,0x73AE,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x39C7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x528A,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xEF3C,0xE71B,0xD679,0xC617,0xB596,0xABC5,0xB3C0,0xC460,0xE540,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xB3C0,0x61A0,0x69C0,0xE540,0xFE60,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xC484,0x9CF3,0x8C30,0x73AE,0x630C,0x4A49,0x4A69,0x630C,0x8C30,0xC617,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xD679,0xB596,0x94B2,0x630C,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x4A49,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0xE71B,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xEF3C,0xDEDA,0xD679,0xC617,0xB596,0xAB60,0xBC00,0xD4E0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0x7A60,0x61A0,0x92C0,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0x4140,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x39C7,0x9CF3,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xDEDA,0xC617,0x9CF3,0x8C30,0x4A49,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x52AA,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0xC617,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xEF3C,0xDEDA,0xD679,0xC617,0xB469,0xAB60,0xC460,0xE540,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xBC00,0x61A0,0x61A0,0xD4E0,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xAB60,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x73AE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xE71B,0xC617,0xB596,0x94B2,0x73AE,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x630C,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x9CF3,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xE71B,0xDEDA,0xD679,0xC617,0xABA4,0xBC00,0xD4E0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0x7A60,0x61A0,0x7A60,0xFE20,0xFE60,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xEDA0,0x4140,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0xB596,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF3C,0xD679,0xB596,0x94B2,0x73AE,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x73AE,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x630C,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF5D,0xE71B,0xDEDA,0xD679,0xB596,0xAB60,0xC460,0xE540,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xC460,0x69C0,0x61A0,0xC460,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xC460,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x528A,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF3C,0xD679,0xB596,0x9CF3,0x8C30,0x4A49,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x630C,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8C30,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0xE71B,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xF77D,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF5D,0xE71B,0xD679,0xC617,0xB469,0xB3C0,0xD4E0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xA320,0x61A0,0x7A60,0xF5E0,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0x7A60,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF3C,0xD679,0xB596,0x9CF3,0x8C30,0x528A,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8C30,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xC617,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xEF3C,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xEF3C,0xDEDA,0xD679,0xC617,0xABA4,0xC460,0xE540,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xE540,0x69C0,0x61A0,0xB3C0,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xEDA0,0x4140,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x1081,0x0000,0x0000,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF3C,0xD679,0xB596,0x9CF3,0x8C30,0x528A,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8C30,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x73AE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xE71B,0xE71B,0xEF5D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xE71B,0xDEDA,0xD679,0xC50D,0xAB60,0xD4E0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xB3C0,0x61A0,0x69C0,0xE540,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE60,0xD4E0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x630C,0x73AE,0x18C2,0x1081,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xE71B,0xD679,0xB596,0x9CF3,0x8C30,0x528A,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x1081,0x18C2,0x18C2,0x18C2,0x18C2,0x18C2,0x18C2,0x18C2,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x9CF3,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xDEDA,0xD679,0xE71B,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF5D,0xE71B,0xD679,0xC617,0xABC5,0xBC00,0xE540,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xEDA0,0x7A60,0x61A0,0x92C0,0xFE20,0xFE60,0xFE60,0xFE62,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xCCC5,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x630C,0x9CF3,0x94B2,0x18C2,0x39C7,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xE71B,0xC617,0xB596,0x94B2,0x8C30,0x4A49,0x0000,0x0000,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x18C2,0x2944,0x39C7,0x39C7,0x39C7,0x39C7,0x39C7,0x39C7,0x39C7,0x2944,0x2944,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x630C,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x9CF3,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xC617,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF3C,0xD679,0xD679,0xDEDA,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xEF3C,0xDEDA,0xD679,0xB596,0xAB60,0xD4E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xBC00,0x61A0,0x61A0,0xC460,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xE60B,0x4A49,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0x8C30,0x9CF3,0x9CF3,0x630C,0x0000,0x8C30,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xE71B,0xC617,0xB596,0x94B2,0x73AE,0x39C7,0x0000,0x0000,0x2944,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x2944,0x4A49,0x4A69,0x52AA,0x52AA,0x52AA,0x52AA,0x528A,0x4A69,0x4A49,0x39C7,0x18C2,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x94B2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x630C,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xE71B,0xC617,0xC617,0xD679,0xEF5D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xE71B,0xD679,0xC617,0xABC5,0xC460,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0x7A60,0x61A0,0x7A60,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xE540,0xEF3C,0xC617,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4A49,0x94B2,0x94B2,0x630C,0x0840,0x39C7,0xF79D,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xDEDA,0xC617,0x9CF3,0x94B2,0x73AE,0x2944,0x0000,0x18C2,0x4A49,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x39C7,0x4A69,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x528A,0x39C7,0x2944,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8C30,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0xEF3C,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xDEDA,0xB596,0xB596,0xD679,0xE71B,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xEF3C,0xDEDA,0xD679,0xC50D,0xB3C0,0xE540,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xC484,0x61A0,0x61A0,0xB3C0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xCCC5,0xFFFF,0xFFFF,0x8C30,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x39C7,0x2944,0x0840,0x4A49,0xDEDA,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF3C,0xD679,0xB596,0x9CF3,0x8C30,0x630C,0x0840,0x0000,0x39C7,0x52AA,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x39C7,0x528A,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x4A49,0x2944,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x73AE,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8C30,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x94B2,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xD679,0xB596,0xB596,0xC617,0xE71B,0xF79D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF3C,0xDEDA,0xD679,0xC617,0xAB60,0xD4E0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0x92C0,0x61A0,0x69C0,0xEDA0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xD5B1,0xFFFF,0xFFFF,0xFFFF,0x94B2,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x2944,0x8C30,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xE71B,0xC617,0xB596,0x94B2,0x73AE,0x39C7,0x0000,0x0840,0x630C,0x52AA,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x2944,0x4A49,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x4A49,0x2944,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x73AE,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xE71B,0xC617,0xB596,0xB596,0xC617,0xDEDA,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF5D,0xE71B,0xD679,0xC617,0xB469,0xBC00,0xE540,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xE540,0x69C0,0x69C0,0xC484,0xFE60,0xFE60,0xFE60,0xFE60,0xE540,0xE71B,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xDEDA,0x8C30,0x39C7,0x2944,0x2944,0x39C7,0x630C,0xB596,0xEF3C,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF3C,0xD679,0xB596,0x9CF3,0x8C30,0x52AA,0x0840,0x0000,0x39C7,0x8C30,0x4A49,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x2944,0x4A49,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x4A49,0x2944,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x528A,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x630C,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x9CF3,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xDEDA,0xB596,0x9CF3,0x9CF3,0xB596,0xD679,0xEF5D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xE71B,0xD679,0xC617,0xB596,0xAB60,0xC460,0xEDA0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xC484,0x92C0,0xC460,0xFE60,0xFE60,0xFE60,0xFE20,0xCCC5,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xEF5D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xD679,0xB596,0x9CF3,0x8C30,0x528A,0x0840,0x0000,0x18C2,0x630C,0x73AE,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x39C7,0x528A,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x4A69,0x39C7,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x4A49,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xD679,0xB596,0x9CF3,0x9CF3,0xB596,0xD679,0xEF3C,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xE71B,0xD679,0xC617,0xB596,0x94B2,0xB3C0,0xD4E0,0xF5E0,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xD4E0,0xE540,0xFE60,0xFE60,0xFE60,0xE540,0xB469,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xD679,0xB596,0x94B2,0x73AE,0x39C7,0x0840,0x0000,0x1081,0x52AA,0x8C30,0x528A,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x2944,0x4A49,0x52AA,0x630C,0x630C,0x630C,0x630C,0x528A,0x39C7,0x2944,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x52AA,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x39C7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x9CF3,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF3C,0xD679,0xB596,0x9CF3,0x9CF3,0xB596,0xD679,0xE71B,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF3C,0xDEDA,0xD679,0xB596,0xB596,0x9CF3,0x8C30,0xB3C0,0xD4E0,0xEDA0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0xA320,0x1081,0xB596,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xD679,0xB596,0x94B2,0x630C,0x18C2,0x0000,0x0000,0x18C2,0x630C,0x8C30,0x630C,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x2944,0x39C7,0x4A69,0x52AA,0x630C,0x52AA,0x4A69,0x39C7,0x2944,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xE71B,0xC617,0x9CF3,0x9CF3,0x9CF3,0xB596,0xC617,0xE71B,0xF79D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xE71B,0xD679,0xC617,0xB596,0x9CF3,0x94B2,0x8C30,0x73AE,0x9324,0xBC00,0xD4E0,0xEDA0,0xFE20,0xFE20,0xFE60,0xFE60,0xFE60,0xFE20,0xEDA0,0xBC00,0x1081,0x0000,0x1081,0x8C30,0xEF5D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xDEDA,0xB596,0x9CF3,0x73AE,0x2944,0x0840,0x0000,0x0000,0x18C2,0x630C,0x8C30,0x630C,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x2944,0x39C7,0x4A49,0x4A49,0x4A49,0x39C7,0x2944,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x73AE,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x9CF3,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xDEDA,0xC617,0x9CF3,0x9CF3,0x9CF3,0xB596,0xC617,0xDEDA,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xE71B,0xD679,0xC617,0xB596,0x9CF3,0x94B2,0x8C30,0x630C,0x39C7,0x1081,0x4140,0x7A60,0xAB60,0xBC00,0xD4E0,0xD4E0,0xE540,0xE540,0xD4E0,0xA320,0x18C2,0x0000,0x0000,0x0000,0x0000,0x39C7,0x94B2,0xD679,0xF77D,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xEF3C,0xD679,0xB596,0x94B2,0x630C,0x2944,0x0840,0x0000,0x0000,0x0000,0x2944,0x52AA,0x630C,0x4A49,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x2944,0x39C7,0x39C7,0x39C7,0x39C7,0x2944,0x18C2,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xD679,0xB596,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0xC617,0xDEDA,0xEF5D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xE71B,0xD679,0xB596,0x9CF3,0x8C30,0x630C,0x4A49,0x18C2,0x0840,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x2944,0x4140,0x69C0,0x69C0,0x4140,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x39C7,0x73AE,0x94B2,0x9CF3,0xB596,0xB596,0x9CF3,0x94B2,0x8C30,0x630C,0x39C7,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x39C7,0x39C7,0x2944,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x2944,0x2944,0x2944,0x18C2,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x9CF3,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x73AE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xE71B,0xD679,0xB596,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0xC617,0xD679,0xEF5D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xDEDA,0xC617,0x9CF3,0x73AE,0x4A69,0x18C2,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x18C2,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x18C2,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x18C2,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4A49,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x73AE,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xB596,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xDEDA,0xC617,0xB596,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0xB596,0xD679,0xEF3C,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xC617,0x9CF3,0x630C,0x2944,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x39C7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0xEF3C,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF3C,0xD679,0xB596,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0xB596,0xD679,0xEF3C,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xDEDA,0xB596,0x73AE,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xE71B,0xD679,0xB596,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0xB596,0xD679,0xE71B,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xC617,0x8C30,0x39C7,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x73AE,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x73AE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xDEDA,0xC617,0xB596,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0xB596,0xD679,0xE71B,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xD679,0x9CF3,0x4A69,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x630C,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x9CF3,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x8C30,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xE71B,0xD679,0xB596,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0xB596,0xD679,0xE71B,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xDEDA,0x9CF3,0x630C,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4A69,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x52AA,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x73AE,0xF79D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xDEDA,0xC617,0xB596,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0xB596,0xD679,0xEF5D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xDEDA,0x9CF3,0x630C,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x1081,0x18C2,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x630C,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x630C,0xE71B,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xF79D,0xF77D,0xF77D,0xF77D,0xF77D,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xE71B,0xD679,0xB596,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0xB596,0xC617,0xE71B,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF3C,0xC617,0x8C30,0x4A49,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x2944,0x4A49,0x52AA,0x630C,0x4A69,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x8C30,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x528A,0xC617,0xE71B,0xF79D,0xF7BE,0xFFFF,0xFFFF,0xF7BE,0xF7BE,0xF79D,0xF77D,0xEF5D,0xEF3C,0xEF3C,0xE71B,0xE71B,0xE71B,0xE71B,0xE71B,0xE71B,0xEF5D,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xD679,0xC617,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0xC617,0xE71B,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xD679,0x94B2,0x52AA,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x2944,0x52AA,0x630C,0x630C,0x630C,0x630C,0x630C,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x9CF3,0x0840,0x0840,0x1081,0x18C2,0x18C2,0x2944,0x4140,0x4140,0x18C2,0x18C2,0x1081,0x0840,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x528A,0x9CF3,0xC617,0xD679,0xE71B,0xE71B,0xE71B,0xE71B,0xE71B,0xDEDA,0xDEDA,0xDEDA,0xD679,0xD679,0xD679,0xD679,0xD679,0xD679,0xD679,0xDEDA,0xEF3C,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xDEDA,0xC617,0xB596,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0xC617,0xE71B,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xD679,0x94B2,0x52AA,0x2944,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x4A49,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x4A69,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x52AA,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x9324,0x7A60,0x7A60,0x92C0,0x92C0,0xA320,0xA320,0xA320,0xA320,0xA320,0xA320,0x92C0,0x92C0,0x7A60,0x7A60,0x61A0,0x4140,0x18C2,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x4A69,0x94B2,0xB596,0xB596,0xC617,0xD679,0xD679,0xD679,0xD679,0xC617,0xC617,0xC617,0xC617,0xC617,0xB596,0xB596,0xC617,0xC617,0xD679,0xDEDA,0xEF3C,0xF7BE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xE71B,0xC617,0xB596,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0xC617,0xEF3C,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xD679,0x9CF3,0x52AA,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x52AA,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xCD2D,0xABA4,0x92C0,0xA320,0xA320,0xA320,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xA320,0xA320,0xA320,0x92C0,0x7A60,0x69C0,0x51C0,0x4140,0x1081,0x0840,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4A49,0x8C30,0x9CF3,0xB596,0xB596,0xB596,0xB596,0xB596,0xB596,0xB596,0xB596,0xB596,0xB596,0xB596,0xB596,0xB596,0xB596,0xB596,0xC617,0xD679,0xEF3C,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xE71B,0xD679,0xB596,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0xB596,0xD679,0xEF5D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xDEDA,0x9CF3,0x630C,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x52AA,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x8C30,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD5B1,0xAB60,0x92C0,0xA320,0xA320,0xAB60,0xAB60,0xAB60,0xAB60,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xA320,0xA320,0xA320,0x7A60,0x7A60,0x69C0,0x4140,0x4140,0x18C2,0x1081,0x0840,0x0840,0x0000,0x0000,0x39C7,0x73AE,0x94B2,0x94B2,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0xB596,0xB596,0xC617,0xDEDA,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF3C,0xD679,0xB596,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0xB596,0xD679,0xF79D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xC617,0x73AE,0x39C7,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4A49,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x52AA,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x8C30,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xB469,0x92C0,0xA320,0xA320,0xAB60,0xAB60,0xAB60,0xB3C0,0xB3C0,0xB3C0,0xBC00,0xBC00,0xBC00,0xBC00,0xBC00,0xBC00,0xC460,0xBC00,0xBC00,0xBC00,0xBC00,0xBC00,0xBC00,0xBC00,0xBC00,0xB3C0,0xB3C0,0xB3C0,0xAB60,0xAB60,0xAB60,0xAB60,0xA320,0xA320,0xA320,0xA320,0x92C0,0x7A60,0x7A60,0x69C0,0x69C0,0x51C0,0x6260,0x9324,0x73AE,0x8C30,0x8C30,0x8C30,0x8C30,0x8C30,0x8C30,0x8C30,0x8C30,0x8C30,0x8C30,0x8C30,0x8C30,0x94B2,0x9CF3,0x9CF3,0xB596,0xC617,0xE71B,0xEF3C,0xEF3C,0xEF3C,0xEF5D,0xF79D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xD679,0xB596,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0xB596,0xE71B,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xE71B,0x9CF3,0x528A,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x39C7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x39C7,0x94B2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBC25,0x92C0,0xA320,0xA320,0xAB60,0xAB60,0xB3C0,0xB3C0,0xBC00,0xBC00,0xBC00,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xBC00,0xBC00,0xBC00,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xA320,0xA320,0xA320,0xA320,0xA320,0xA320,0xA320,0xA320,0xA320,0xA320,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xAB60,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xBC00,0xBC00,0xC460,0xC484,0xE540,0xE60B,0xE60B,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xDEDA,0xB596,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0xC617,0xEF5D,0xFFFF,0xFFFF,0xF7BE,0xD679,0x94B2,0x39C7,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x2944,0x73AE,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xCD2D,0x92C0,0xA320,0xA320,0xAB60,0xAB60,0xB3C0,0xB3C0,0xBC00,0xBC00,0xC460,0xC460,0xC460,0xC460,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xC460,0xC460,0xC460,0xC460,0xC460,0xBC00,0xBC00,0xBC00,0xBC00,0xBC00,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xB3C0,0xBC00,0xBC00,0xBC00,0xBC00,0xBC00,0xC460,0xC460,0xC460,0xC460,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xE540,0xEDA0,0xF5E0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFF10,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xDEDA,0xC617,0x9CF3,0x9CF3,0x9CF3,0x9CF3,0xB596,0xDEDA,0xF7BE,0xFFFF,0xF7BE,0xD679,0x8C30,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x630C,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x2944,0x73AE,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xA320,0xA320,0xAB60,0xAB60,0xB3C0,0xBC00,0xBC00,0xC460,0xC460,0xC460,0xC460,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xE540,0xE540,0xE540,0xE540,0xE540,0xE540,0xE540,0xE540,0xE540,0xE540,0xE540,0xE540,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xC460,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xE540,0xE540,0xEDA0,0xEDA0,0xF5E0,0xFE20,0xFE20,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE63,0xFE62,0xFE20,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xDEDA,0xC617,0xB596,0x9CF3,0x9CF3,0xB596,0xC617,0xEF5D,0xFFFF,0xF7BE,0xD679,0x8C30,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x4A69,0x630C,0x630C,0x630C,0x630C,0x630C,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x39C7,0x630C,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xC50D,0x92C0,0xA320,0xAB60,0xAB60,0xB3C0,0xBC00,0xBC00,0xC460,0xC460,0xC460,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xE540,0xE540,0xE540,0xEDA0,0xEDA0,0xEDA0,0xEDA0,0xEDA0,0xF5E0,0xF5E0,0xEDA0,0xEDA0,0xEDA0,0xEDA0,0xEDA0,0xE540,0xE540,0xE540,0xE540,0xE540,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xE540,0xE540,0xE540,0xEDA0,0xEDA0,0xF5E0,0xFE20,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE60,0xFF10,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xE71B,0xD679,0xC617,0xB596,0xB596,0xC617,0xE71B,0xF7BE,0xF7BE,0xDEDA,0x8C30,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x39C7,0x52AA,0x52AA,0x4A49,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x1081,0x18C2,0x2944,0x2944,0x4A49,0x4A49,0x4A49,0x4A49,0x39C7,0x2944,0x18C2,0x18C2,0x1081,0x0840,0x0840,0x0840,0x1081,0x18C2,0x2944,0x39C7,0x630C,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xA320,0xA320,0xAB60,0xB3C0,0xB3C0,0xBC00,0xC460,0xC460,0xC460,0xD4E0,0xD4E0,0xD4E0,0xE540,0xE540,0xE540,0xEDA0,0xEDA0,0xF5E0,0xF5E0,0xFE20,0xFE20,0xFE20,0xFE20,0xFE20,0xFE20,0xFE20,0xFE20,0xFE20,0xF5E0,0xF5E0,0xF5E0,0xF5E0,0xEDA0,0xEDA0,0xEDA0,0xE540,0xE540,0xE540,0xE540,0xE540,0xE540,0xE540,0xE540,0xE540,0xE540,0xE540,0xE540,0xEDA0,0xEDA0,0xF5E0,0xF5E0,0xFE20,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xEF5D,0xDEDA,0xD679,0xC617,0xC617,0xDEDA,0xF77D,0xF7BE,0xDEDA,0x94B2,0x39C7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x2944,0x52AA,0x8C30,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x92C0,0xA320,0xAB60,0xAB60,0xB3C0,0xBC00,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xD4E0,0xE540,0xE540,0xE540,0xEDA0,0xF5E0,0xF5E0,0xFE20,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xFE20,0xFE20,0xF5E0,0xF5E0,0xF5E0,0xF5E0,0xEDA0,0xEDA0,0xEDA0,0xEDA0,0xEDA0,0xEDA0,0xF5E0,0xF5E0,0xF5E0,0xFE20,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xE71B,0xDEDA,0xDEDA,0xDEDA,0xEF5D,0xF7BE,0xDEDA,0x94B2,0x39C7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x4A49,0x8C30,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xCD2D,0x92C0,0xA320,0xAB60,0xB3C0,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xD4E0,0xE540,0xE540,0xEDA0,0xEDA0,0xF5E0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xFE20,0xFE20,0xFE20,0xFE20,0xFE20,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xEF3C,0xEF3C,0xF77D,0xF79D,0xDEDA,0x94B2,0x39C7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x4A49,0x8C30,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBC25,0xA320,0xA320,0xAB60,0xB3C0,0xBC00,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xD4E0,0xE540,0xE540,0xEDA0,0xF5E0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xF7BE,0xEF5D,0xC617,0x8C30,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x630C,0x9CF3,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xABA4,0xA320,0xAB60,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xD4E0,0xE540,0xE540,0xEDA0,0xF5E0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF79D,0xDEDA,0x9CF3,0x52AA,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x528A,0x9CF3,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x92C0,0xA320,0xAB60,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xE540,0xE540,0xEDA0,0xF5E0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE63,0xFE63,0xFE63,0xFE63,0xFE63,0xFE63,0xFE63,0xFE62,0xFE62,0xFE62,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xFE20,0xFE20,0xFE20,0xFE60,0xFE60,0xFE60,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xD679,0x9CF3,0x630C,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x39C7,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x2944,0x8C30,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x92C0,0xA320,0xAB60,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xE540,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xF5E0,0xEDA0,0xEDA0,0xEDA0,0xEDA0,0xEDA0,0xF5E0,0xFE20,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xC617,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF77D,0xDEDA,0xB596,0x8C30,0x39C7,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x39C7,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x4A49,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x92C0,0xA320,0xAB60,0xB3C0,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xE540,0xEDA0,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE62,0xFE62,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xF5E0,0xEDA0,0xE540,0xE540,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xD4E0,0xE540,0xF5E0,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE60,0xFE20,0x39C7,0x8C30,0xD679,0xF77D,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xF7BE,0xF77D,0xE71B,0xD679,0xB596,0x94B2,0x528A,0x39C7,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x4A49,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x528A,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x92C0,0xA320,0xAB60,0xB3C0,0xBC00,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xE540,0xEDA0,0xF5E0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE62,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xF5E0,0xEDA0,0xE540,0xD4E0,0xD4E0,0xC460,0xC460,0xC460,0xBC00,0xBC00,0xC460,0xD4E0,0xE540,0xFE62,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xABA4,0x0000,0x0840,0x39C7,0x8C30,0x9CF3,0xB596,0xC617,0xC617,0xC617,0xC617,0xC617,0xD679,0xD679,0xD679,0xD679,0xD679,0xDEDA,0xDEDA,0xD679,0xD679,0xC617,0xC617,0xB596,0xB596,0x9CF3,0x8C30,0x52AA,0x4A49,0x39C7,0x2944,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x4A49,0x4A49,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x528A,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x9B0D,0xBA29,0xB24A,0x8B90,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x92C0,0xA320,0xAB60,0xB3C0,0xBC00,0xBC00,0xC460,0xD4E0,0xD4E0,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE62,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xF5E0,0xEDA0,0xE540,0xD4E0,0xD4E0,0xC460,0xBC00,0xBC00,0xB3C0,0xAB60,0xA320,0xA320,0xA320,0xAB60,0xC460,0xEDA0,0xFE60,0xFE60,0xFE60,0xF5E0,0x2944,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x2944,0x2944,0x2944,0x2944,0x2944,0x2944,0x2944,0x2944,0x2944,0x2944,0x2944,0x2944,0x18C2,0x18C2,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x0840,0x0840,0x0840,0x0840,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x39C7,0x4A69,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x4A49,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD166,0xF800,0xD904,0xE8A3,0xF800,0xE0E4,0x8B90,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x92C0,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xE540,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE62,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xF5E0,0xEDA0,0xE540,0xD4E0,0xC460,0xC460,0xBC00,0xB3C0,0xAB60,0xA320,0x7A60,0x18C2,0x0840,0x0840,0x1081,0x18C2,0x4140,0x51C0,0x6260,0x6260,0x2944,0x0000,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x18C2,0x2944,0x2944,0x18C2,0x18C2,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x4A49,0x4A49,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x9CF3,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xAAAC,0xF061,0x8B90,0x7453,0x7453,0x8BB0,0xD145,0xF800,0xA2CC,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x92C0,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xE540,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xF5E0,0xEDA0,0xE540,0xD4E0,0xC460,0xC460,0xBC00,0xB3C0,0xAB60,0xA320,0x51C0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x2944,0x18C2,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x2944,0x2944,0x2944,0x2944,0x2944,0x2944,0x18C2,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x4A49,0x4A49,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x8C30,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBA29,0xD904,0x7453,0x7453,0x7453,0x7453,0x7453,0xA2CC,0xF800,0x936F,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x92C0,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xE540,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0xEDA0,0xE540,0xD4E0,0xD4E0,0xC460,0xBC00,0xB3C0,0xAB60,0xA320,0x69C0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x39C7,0x2944,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x2944,0x2944,0x2944,0x2944,0x2944,0x2944,0x2944,0x18C2,0x0000,0x0000,0x0000,0x0000,0x18C2,0x4A49,0x4A69,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x4A49,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x9B0D,0xF061,0x83F1,0x7453,0x7453,0x7453,0x7453,0x7453,0xC987,0xD145,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xE540,0xE540,0xF5E0,0xF5E0,0xFE60,0xFE60,0xFE62,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xF5E0,0xE540,0xE540,0xD4E0,0xC460,0xBC00,0xB3C0,0xAB60,0xA320,0x7A60,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x4A49,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x2944,0x2944,0x2944,0x2944,0x2944,0x2944,0x2944,0x1081,0x0000,0x0000,0x0000,0x18C2,0x39C7,0x4A49,0x39C7,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x94B2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xE8A3,0xD166,0x7453,0x7453,0x7453,0x7453,0x83F1,0xD145,0xD904,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xABC5,0xA320,0xAB60,0xB3C0,0xB3C0,0xBC00,0xC460,0xD4E0,0xD4E0,0xE540,0xE540,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE62,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xEDA0,0xE540,0xD4E0,0xC460,0xC460,0xBC00,0xAB60,0xA320,0x92C0,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0x52AA,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x2944,0x2944,0x2944,0x2944,0x2944,0x2944,0x18C2,0x0840,0x0000,0x0000,0x18C2,0x39C7,0x39C7,0x39C7,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x4A49,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8B90,0xD145,0x7453,0x7453,0x7453,0x7453,0xB24A,0xF800,0xE882,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xB469,0xA320,0xAB60,0xAB60,0xB3C0,0xBC00,0xC460,0xD4E0,0xD4E0,0xE540,0xE540,0xF5E0,0xF5E0,0xFE60,0xFE60,0xFE62,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0xEDA0,0xE540,0xD4E0,0xC460,0xBC00,0xB3C0,0xAB60,0xA320,0x4140,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x52AA,0x4A69,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x2944,0x2944,0x2944,0x2944,0x18C2,0x1081,0x0000,0x0000,0x1081,0x2944,0x39C7,0x2944,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x94B2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD5B1,0x92C0,0xAB60,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xE540,0xE540,0xEDA0,0xF5E0,0xFE60,0xFE60,0xFE62,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xF5E0,0xE540,0xD4E0,0xD4E0,0xC460,0xBC00,0xB3C0,0xAB60,0x92C0,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0x630C,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x18C2,0x18C2,0x18C2,0x1081,0x0000,0x0000,0x1081,0x18C2,0x2944,0x2944,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8B90,0xF061,0xBA29,0x8B90,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x92C0,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE62,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xF5E0,0xE540,0xD4E0,0xD4E0,0xC460,0xBC00,0xAB60,0xA320,0x69C0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x630C,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x0840,0x0840,0x0000,0x0000,0x0840,0x1081,0x18C2,0x18C2,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x73AE,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xAAAC,0xE882,0xF800,0xD166,0x83F1,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xABA4,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE62,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xF5E0,0xE540,0xD4E0,0xC460,0xC460,0xB3C0,0xAB60,0xA320,0x4140,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x630C,0x39C7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x0840,0x0840,0x1081,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x83F1,0xD145,0xF800,0xF061,0xBA29,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD5B1,0x92C0,0xAB60,0xAB60,0xB3C0,0xBC00,0xC460,0xD4E0,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xF5E0,0xE540,0xD4E0,0xC460,0xC460,0xB3C0,0xAB60,0x92C0,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x630C,0x39C7,0x2944,0x2944,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x2944,0x18C2,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x528A,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xAAAC,0xF820,0xBA29,0xF061,0xE882,0x936F,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE60,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xF5E0,0xE540,0xD4E0,0xC460,0xC460,0xB3C0,0xAB60,0x92C0,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x528A,0x39C7,0x39C7,0x630C,0x52AA,0x39C7,0x18C2,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x39C7,0x39C7,0x2944,0x2944,0x18C2,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8B90,0xF800,0x83F1,0x9B2E,0xE882,0xF800,0xA2CC,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD5B1,0x92C0,0xAB60,0xAB60,0xB3C0,0xBC00,0xC460,0xD4E0,0xD4E0,0xE540,0xEDA0,0xF5E0,0xFE20,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xF5E0,0xE540,0xD4E0,0xC460,0xC460,0xB3C0,0xAB60,0x92C0,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x2944,0x1081,0x0840,0x2944,0x4A49,0x630C,0x630C,0x528A,0x39C7,0x18C2,0x0840,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x2944,0x4A49,0x4A49,0x4A49,0x39C7,0x2944,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8BB0,0xB24A,0xC987,0xF800,0xF800,0xF800,0xE882,0xD145,0x9B0D,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xABC5,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xD4E0,0xE540,0xF5E0,0xFE20,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0xE540,0xD4E0,0xC460,0xC460,0xB3C0,0xAB60,0x92C0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x39C7,0x528A,0x630C,0x630C,0x52AA,0x4A49,0x39C7,0x2944,0x18C2,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x0840,0x0840,0x0840,0x0840,0x1081,0x18C2,0x2944,0x39C7,0x4A49,0x4A69,0x4A69,0x4A69,0x4A49,0x2944,0x18C2,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x630C,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8B90,0xF800,0xE882,0xC987,0xB24A,0x9B2E,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xC460,0xD4E0,0xE540,0xEDA0,0xFE20,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0xEDA0,0xD4E0,0xD4E0,0xC460,0xB3C0,0xAB60,0x92C0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x2944,0x39C7,0x4A49,0x4A49,0x4A49,0x39C7,0x2944,0x2944,0x18C2,0x0840,0x0840,0x1081,0x18C2,0x18C2,0x2944,0x2944,0x39C7,0x39C7,0x4A49,0x4A49,0x4A69,0x4A69,0x4A69,0x4A49,0x4A49,0x4A49,0x2944,0x18C2,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8B90,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD5B1,0xA320,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xD4E0,0xD4E0,0xEDA0,0xF5E0,0xFE60,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xEDA0,0xE540,0xD4E0,0xC460,0xBC00,0xAB60,0x92C0,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x2944,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x1081,0x18C2,0x18C2,0x18C2,0x18C2,0x0840,0x0840,0x1081,0x18C2,0x18C2,0x2944,0x2944,0x39C7,0x39C7,0x39C7,0x39C7,0x39C7,0x39C7,0x39C7,0x39C7,0x2944,0x18C2,0x1081,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x9B0D,0xBA29,0xB24A,0x8B90,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD5B1,0xA320,0xAB60,0xAB60,0xBC00,0xC460,0xC460,0xD4E0,0xE540,0xF5E0,0xFE20,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xF5E0,0xE540,0xD4E0,0xC460,0xBC00,0xAB60,0xA320,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x4A49,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x0840,0x1081,0x1081,0x18C2,0x18C2,0x18C2,0x18C2,0x18C2,0x18C2,0x1081,0x0840,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x8C30,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD166,0xF800,0xD904,0xE8A3,0xF800,0xE0E4,0x8B90,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xC50D,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xD4E0,0xE540,0xEDA0,0xFE20,0xFE60,0xFE62,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0xEDA0,0xD4E0,0xC460,0xBC00,0xB3C0,0xA320,0x4140,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x4A69,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xAAAC,0xF061,0x8B90,0x7453,0x7453,0x8BB0,0xD145,0xF800,0xA2CC,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xC50D,0xA320,0xAB60,0xB3C0,0xBC00,0xC460,0xD4E0,0xE540,0xF5E0,0xFE60,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xEDA0,0xE540,0xD4E0,0xC460,0xB3C0,0xAB60,0x7A60,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0x4A69,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x630C,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBA29,0xD904,0x7453,0x7453,0x7453,0x7453,0x7453,0xA2CC,0xF800,0x936F,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xC484,0xA320,0xAB60,0xBC00,0xC460,0xD4E0,0xE540,0xF5E0,0xFE60,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xEDA0,0xD4E0,0xC460,0xBC00,0xB3C0,0xA320,0x4140,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x39C7,0x4A69,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x9B0D,0xF061,0x83F1,0x7453,0x7453,0x7453,0x7453,0x7453,0xC987,0xD145,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xB469,0xA320,0xB3C0,0xBC00,0xC460,0xD4E0,0xEDA0,0xFE20,0xFE60,0xFE62,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0xE540,0xD4E0,0xC460,0xBC00,0xAB60,0x92C0,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x4A49,0x4A49,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x630C,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xE8A3,0xD166,0x7453,0x7453,0x7453,0x7453,0x83F1,0xD145,0xD904,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xABC5,0xAB60,0xB3C0,0xC460,0xD4E0,0xE540,0xF5E0,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE20,0xF5E0,0xE540,0xD4E0,0xC460,0xBC00,0xAB60,0x69C0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x4A69,0x39C7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8B90,0xD145,0x7453,0x7453,0x7453,0x7453,0xB24A,0xF800,0xE882,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xAB60,0xAB60,0xBC00,0xC460,0xD4E0,0xEDA0,0xFE60,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE60,0xFE60,0xFE20,0xF5E0,0xE540,0xD4E0,0xC460,0xBC00,0xA320,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x39C7,0x4A69,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x73AE,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xA320,0xB3C0,0xC460,0xD4E0,0xE540,0xFE20,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE60,0xFE60,0xFE60,0xF5E0,0xE540,0xD4E0,0xC460,0xB3C0,0x92C0,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x4A49,0x4A49,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x4A69,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xB24A,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF800,0xF061,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD5B1,0xAB60,0xB3C0,0xC460,0xD4E0,0xF5E0,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE60,0xFE60,0xFE60,0xFE20,0xEDA0,0xE540,0xC460,0xB3C0,0x7A60,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x52AA,0x39C7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x83F1,0x9B2E,0x9B2E,0xF061,0xD166,0x9B2E,0x9B2E,0x9B2E,0x9B2E,0x8B90,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xB469,0xAB60,0xBC00,0xD4E0,0xE540,0xFE20,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0xE540,0xD4E0,0xBC00,0x7A60,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x630C,0x630C,0x2944,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2944,0x94B2,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8BB0,0xE8A3,0xF800,0xA2CC,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xABA4,0xB3C0,0xC460,0xD4E0,0xF5E0,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xF5E0,0xE540,0xC460,0x7A60,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x1081,0x1081,0x1081,0x18C2,0x2944,0x4A49,0x94B2,0x4A49,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x8C30,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x936F,0xF061,0xD145,0x9B2E,0xF061,0xA2CC,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xAB60,0xBC00,0xD4E0,0xEDA0,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE60,0xFE60,0xFE20,0xD4E0,0x92C0,0x1081,0x0000,0x0000,0x0000,0x1081,0x18C2,0x2944,0x39C7,0x4A49,0x52AA,0x8C30,0x73AE,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x73AE,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xAAAC,0xF061,0xB26B,0x7453,0x7453,0x9B0D,0xE8A3,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xCD2D,0xAB60,0xC460,0xD4E0,0xF5E0,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE60,0xFE60,0xFE20,0xD4E0,0x51C0,0x0840,0x0000,0x0840,0x18C2,0x2944,0x39C7,0x4A49,0x73AE,0x73AE,0x39C7,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x73AE,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x83F1,0x8BB0,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBC25,0xB3C0,0xD4E0,0xEDA0,0xFE60,0xFE62,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xFE20,0xB3C0,0x18C2,0x0000,0x1081,0x18C2,0x2944,0x39C7,0x39C7,0x2944,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x18C2,0x8C30,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x9B0D,0xD145,0xD904,0xC987,0x9B0D,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xAB60,0xBC00,0xD4E0,0xFE20,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE20,0x92C0,0x0840,0x0840,0x1081,0x18C2,0x1081,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x2944,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBA29,0xF800,0xC987,0xBA29,0xD145,0xF800,0xE8A3,0x8BB0,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD5B1,0xAB60,0xC460,0xEDA0,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE62,0xFE60,0xD4E0,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x4A49,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8BB0,0xF800,0x9B0D,0x7453,0x7453,0x7453,0x8BB0,0xE0E4,0xE882,0x83F1,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xB469,0xBC00,0xD4E0,0xFE20,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0x6260,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x73AE,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xB24A,0xE8A3,0x7453,0x7453,0x7453,0x7453,0x7453,0x83F1,0xE882,0xBA29,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xAB60,0xC460,0xEDA0,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE60,0x9324,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1081,0x528A,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBA29,0xD904,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBA29,0xD904,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xB3C0,0xD4E0,0xFE20,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE60,0xE60B,0x73AE,0x18C2,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x4A49,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x9B0D,0xF061,0x83F1,0x7453,0x7453,0x7453,0x7453,0x7453,0xBA29,0xD904,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xB469,0xC460,0xF5E0,0xFE60,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE60,0x7453,0x7453,0x7453,0x9CF3,0x39C7,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x52AA,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xE8A3,0xE8A3,0x8BB0,0x7453,0x7453,0x7453,0x7453,0xE8A3,0xC1E8,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xB3C0,0xD4E0,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE60,0xFEC9,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8C30,0x39C7,0x0840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0840,0x18C2,0x4A69,0x8C30,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x83F1,0xE0E4,0xF800,0xD145,0xBA29,0xBA29,0xE8A3,0xF061,0x8BB0,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD5B1,0xC460,0xF5E0,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFE60,0xFE60,0xFE62,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE62,0xFE60,0xFE62,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x9CF3,0x630C,0x39C7,0x0840,0x0840,0x0840,0x0840,0x0840,0x0840,0x0840,0x0840,0x0840,0x1081,0x2944,0x4A49,0x73AE,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x936F,0xC1E8,0xD904,0xD904,0xC1E8,0x8BB0,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBC25,0xD4E0,0xFE60,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE60,0xFE60,0xFE60,0xFE62,0xFE62,0xFE62,0xFE60,0xFE60,0xFE60,0xFE60,0xFE60,0xFE62,0xFE20,0xFF10,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x83F1,0x8B90,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBC00,0xFE20,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE60,0xFE60,0xFE88,0xFF10,0x7453,0x7453,0x7453,0xFF10,0xFF10,0xFF10,0xFF10,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBA29,0xF800,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xCCC5,0xE540,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xFEC9,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x83F1,0x8B90,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBC00,0xFE20,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0xF66B,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD5B1,0xE540,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE60,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xB24A,0xF800,0xF800,0xF800,0xF800,0xF061,0xD904,0xD904,0xD904,0xAAAC,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xC460,0xFE60,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE20,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBA29,0xE8A3,0x9B2E,0x9B2E,0xE8A3,0xD904,0xBA29,0xBA29,0xD904,0xD904,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xE540,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE20,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xAAAC,0xE882,0x7453,0x7453,0xD904,0xBA29,0x7453,0x7453,0xBA29,0xD904,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xCCC5,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE20,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8B90,0xF800,0x8BB0,0x83F1,0xF061,0xE882,0x83F1,0x7453,0xE882,0xBA29,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xEDA0,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE20,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xE8A3,0xE8A3,0xC1C8,0xE0E4,0xF061,0xE882,0xE882,0xE882,0x83F1,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD56B,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE60,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8B90,0xE882,0xE882,0x8BB0,0x83F1,0xB24A,0xB24A,0x83F1,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xEDA0,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xE60B,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFF10,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x8BB0,0xD904,0xD904,0xD904,0xD904,0xD904,0xD145,0x7453,0x9B0D,0xBA29,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xEDA0,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFE88,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x83F1,0xBA29,0xBA29,0xBA29,0xBA29,0xBA29,0xB24A,0x7453,0x8B90,0x9B0D,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xFF10,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFEC9,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xFE88,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x9B0D,0xC987,0x83F1,0x7453,0x7453,0x7453,0x7453,0x7453,0x8B90,0x9B0D,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE63,0xFF10,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBA29,0xF800,0xF061,0x9B0D,0x7453,0x7453,0x7453,0x7453,0xBA29,0xD904,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xF66B,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBA29,0xD904,0xC1C8,0xF800,0xD145,0x83F1,0x7453,0x7453,0xBA29,0xD904,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xFEA8,0xFE63,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBA29,0xD904,0x7453,0x9B0D,0xF061,0xF061,0x936F,0x7453,0xBA29,0xD904,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xFEC9,0xFE62,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE86,0xFE62,0xFE88,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBA29,0xD904,0x7453,0x7453,0x8BB0,0xE0E4,0xF800,0xA2CC,0xBA29,0xD904,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xFE88,0xFE62,0xFE62,0xFE63,0xFE86,0xFE86,0xFE63,0xFE62,0xFEA8,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBA29,0xD904,0x7453,0x7453,0x7453,0x7453,0xBA29,0xF800,0xC1C8,0xD904,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xFF10,0xFE20,0xFE60,0xFE60,0xFEA8,0xFF10,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xBA29,0xD904,0x7453,0x7453,0x7453,0x7453,0x7453,0xA2CC,0xF800,0xD904,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xB24A,0xD145,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0xD166,0xC987,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,0x7453,
+
+};
diff -Nur linux/drivers/video/font_4x6.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/video/font_4x6.c
--- linux/drivers/video/font_4x6.c	1970-01-01 07:00:00.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/video/font_4x6.c	2003-06-23 01:47:03.000000000 +0700
@@ -0,0 +1,1059 @@
+/*       Font file generated by Jay Carlson from clR4x6.bdf */
+
+/*
+COMMENT  Copyright 1989 Dale Schumacher, dal@syntel.mn.org
+COMMENT                 399 Beacon Ave.
+COMMENT                 St. Paul, MN  55104-3527
+COMMENT  
+COMMENT  Permission to use, copy, modify, and distribute this software and
+COMMENT  its documentation for any purpose and without fee is hereby
+COMMENT  granted, provided that the above copyright notice appear in all
+COMMENT  copies and that both that copyright notice and this permission
+COMMENT  notice appear in supporting documentation, and that the name of
+COMMENT  Dale Schumacher not be used in advertising or publicity pertaining to
+COMMENT  distribution of the software without specific, written prior
+COMMENT  permission.  Dale Schumacher makes no representations about the
+COMMENT  suitability of this software for any purpose.  It is provided "as
+COMMENT  is" without express or implied warranty.
+*/
+
+#include <video/font.h>
+
+#define FONTDATAMAX (6 * 256)
+
+static unsigned char fontdata_4x6[FONTDATAMAX] = {
+
+	 /* 0 0x00 C000 */
+	0x10, /* 00010000 */
+	0x10, /* 00010000 */
+	0x10, /* 00010000 */
+	0x10, /* 00010000 */
+	0x10, /* 00010000 */
+	0xf0, /* 11110000 */
+
+	 /* 1 0x01 C001 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 2 0x02 C002 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 3 0x03 C003 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 4 0x04 C004 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 5 0x05 C005 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 6 0x06 C006 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 7 0x07 C007 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 8 0x08 C010 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 9 0x09 C011 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 10 0x0a C012 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 11 0x0b C013 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 12 0x0c C014 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 13 0x0d C015 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 14 0x0e C016 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 15 0x0f C017 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 16 0x10 C020 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 17 0x11 C021 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 18 0x12 C022 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 19 0x13 C023 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 20 0x14 C024 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 21 0x15 C025 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 22 0x16 C026 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 23 0x17 C027 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 24 0x18 C030 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 25 0x19 C031 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 26 0x1a C032 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 27 0x1b C033 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 28 0x1c C034 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 29 0x1d C035 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 30 0x1e C036 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 31 0x1f C037 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 32 0x20 C040 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 33 0x21 ! */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 34 0x22 " */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 35 0x23 # */
+	0xa0, /* 10100000 */
+	0xe0, /* 11100000 */
+	0xa0, /* 10100000 */
+	0xe0, /* 11100000 */
+	0xa0, /* 10100000 */
+	0x00, /* 00000000 */
+
+	 /* 36 0x24 $ */
+	0xe0, /* 11100000 */
+	0xc0, /* 11000000 */
+	0xe0, /* 11100000 */
+	0x60, /* 01100000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+
+	 /* 37 0x25 % */
+	0xa0, /* 10100000 */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+	0x80, /* 10000000 */
+	0xa0, /* 10100000 */
+	0x00, /* 00000000 */
+
+	 /* 38 0x26 & */
+	0xe0, /* 11100000 */
+	0x40, /* 01000000 */
+	0xe0, /* 11100000 */
+	0xa0, /* 10100000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+
+	 /* 39 0x27 ' */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 40 0x28 ( */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+
+	 /* 41 0x29 ) */
+	0x40, /* 01000000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 42 0x2a * */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0xe0, /* 11100000 */
+	0x40, /* 01000000 */
+	0xa0, /* 10100000 */
+	0x00, /* 00000000 */
+
+	 /* 43 0x2b + */
+	0x00, /* 00000000 */
+	0x40, /* 01000000 */
+	0xe0, /* 11100000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 44 0x2c , */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 45 0x2d - */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 46 0x2e . */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 47 0x2f / */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+	0x80, /* 10000000 */
+	0x80, /* 10000000 */
+	0x00, /* 00000000 */
+
+	 /* 48 0x30 0 */
+	0xe0, /* 11100000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+
+	 /* 49 0x31 1 */
+	0x40, /* 01000000 */
+	0xc0, /* 11000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 50 0x32 2 */
+	0xe0, /* 11100000 */
+	0x20, /* 00100000 */
+	0xe0, /* 11100000 */
+	0x80, /* 10000000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+
+	 /* 51 0x33 3 */
+	0xe0, /* 11100000 */
+	0x20, /* 00100000 */
+	0xe0, /* 11100000 */
+	0x20, /* 00100000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+
+	 /* 52 0x34 4 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xe0, /* 11100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+
+	 /* 53 0x35 5 */
+	0xe0, /* 11100000 */
+	0x80, /* 10000000 */
+	0xe0, /* 11100000 */
+	0x20, /* 00100000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+
+	 /* 54 0x36 6 */
+	0xe0, /* 11100000 */
+	0x80, /* 10000000 */
+	0xe0, /* 11100000 */
+	0xa0, /* 10100000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+
+	 /* 55 0x37 7 */
+	0xe0, /* 11100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+
+	 /* 56 0x38 8 */
+	0xe0, /* 11100000 */
+	0xa0, /* 10100000 */
+	0xe0, /* 11100000 */
+	0xa0, /* 10100000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+
+	 /* 57 0x39 9 */
+	0xe0, /* 11100000 */
+	0xa0, /* 10100000 */
+	0xe0, /* 11100000 */
+	0x20, /* 00100000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+
+	 /* 58 0x3a : */
+	0x00, /* 00000000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 59 0x3b ; */
+	0x00, /* 00000000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 60 0x3c < */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+	0x80, /* 10000000 */
+	0x40, /* 01000000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+
+	 /* 61 0x3d = */
+	0x00, /* 00000000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 62 0x3e > */
+	0x80, /* 10000000 */
+	0x40, /* 01000000 */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+	0x80, /* 10000000 */
+	0x00, /* 00000000 */
+
+	 /* 63 0x3f ? */
+	0xc0, /* 11000000 */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 64 0x40 @ */
+	0xe0, /* 11100000 */
+	0xa0, /* 10100000 */
+	0xe0, /* 11100000 */
+	0x80, /* 10000000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+
+	 /* 65 0x41 A */
+	0x40, /* 01000000 */
+	0xa0, /* 10100000 */
+	0xe0, /* 11100000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0x00, /* 00000000 */
+
+	 /* 66 0x42 B */
+	0xc0, /* 11000000 */
+	0xa0, /* 10100000 */
+	0xc0, /* 11000000 */
+	0xa0, /* 10100000 */
+	0xc0, /* 11000000 */
+	0x00, /* 00000000 */
+
+	 /* 67 0x43 C */
+	0x60, /* 01100000 */
+	0x80, /* 10000000 */
+	0x80, /* 10000000 */
+	0x80, /* 10000000 */
+	0x60, /* 01100000 */
+	0x00, /* 00000000 */
+
+	 /* 68 0x44 D */
+	0xc0, /* 11000000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xc0, /* 11000000 */
+	0x00, /* 00000000 */
+
+	 /* 69 0x45 E */
+	0xe0, /* 11100000 */
+	0x80, /* 10000000 */
+	0xc0, /* 11000000 */
+	0x80, /* 10000000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+
+	 /* 70 0x46 F */
+	0xe0, /* 11100000 */
+	0x80, /* 10000000 */
+	0xc0, /* 11000000 */
+	0x80, /* 10000000 */
+	0x80, /* 10000000 */
+	0x00, /* 00000000 */
+
+	 /* 71 0x47 G */
+	0x60, /* 01100000 */
+	0x80, /* 10000000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0x60, /* 01100000 */
+	0x00, /* 00000000 */
+
+	 /* 72 0x48 H */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xe0, /* 11100000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0x00, /* 00000000 */
+
+	 /* 73 0x49 I */
+	0xe0, /* 11100000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+
+	 /* 74 0x4a J */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0xa0, /* 10100000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 75 0x4b K */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xc0, /* 11000000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0x00, /* 00000000 */
+
+	 /* 76 0x4c L */
+	0x80, /* 10000000 */
+	0x80, /* 10000000 */
+	0x80, /* 10000000 */
+	0x80, /* 10000000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+
+	 /* 77 0x4d M */
+	0xa0, /* 10100000 */
+	0xe0, /* 11100000 */
+	0xe0, /* 11100000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0x00, /* 00000000 */
+
+	 /* 78 0x4e N */
+	0xa0, /* 10100000 */
+	0xe0, /* 11100000 */
+	0xe0, /* 11100000 */
+	0xe0, /* 11100000 */
+	0xa0, /* 10100000 */
+	0x00, /* 00000000 */
+
+	 /* 79 0x4f O */
+	0x40, /* 01000000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 80 0x50 P */
+	0xc0, /* 11000000 */
+	0xa0, /* 10100000 */
+	0xc0, /* 11000000 */
+	0x80, /* 10000000 */
+	0x80, /* 10000000 */
+	0x00, /* 00000000 */
+
+	 /* 81 0x51 Q */
+	0x40, /* 01000000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xc0, /* 11000000 */
+	0x60, /* 01100000 */
+	0x00, /* 00000000 */
+
+	 /* 82 0x52 R */
+	0xc0, /* 11000000 */
+	0xa0, /* 10100000 */
+	0xc0, /* 11000000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0x00, /* 00000000 */
+
+	 /* 83 0x53 S */
+	0x60, /* 01100000 */
+	0x80, /* 10000000 */
+	0x40, /* 01000000 */
+	0x20, /* 00100000 */
+	0xc0, /* 11000000 */
+	0x00, /* 00000000 */
+
+	 /* 84 0x54 T */
+	0xe0, /* 11100000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 85 0x55 U */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+
+	 /* 86 0x56 V */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 87 0x57 W */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xe0, /* 11100000 */
+	0xe0, /* 11100000 */
+	0xa0, /* 10100000 */
+	0x00, /* 00000000 */
+
+	 /* 88 0x58 X */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0x40, /* 01000000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0x00, /* 00000000 */
+
+	 /* 89 0x59 Y */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 90 0x5a Z */
+	0xe0, /* 11100000 */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+	0x80, /* 10000000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+
+	 /* 91 0x5b [ */
+	0x60, /* 01100000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x60, /* 01100000 */
+	0x00, /* 00000000 */
+
+	 /* 92 0x5c \ */
+	0x80, /* 10000000 */
+	0x80, /* 10000000 */
+	0x40, /* 01000000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+
+	 /* 93 0x5d ] */
+	0x60, /* 01100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x60, /* 01100000 */
+	0x00, /* 00000000 */
+
+	 /* 94 0x5e ^ */
+	0x40, /* 01000000 */
+	0xa0, /* 10100000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 95 0x5f _ */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+
+	 /* 96 0x60 ` */
+	0x40, /* 01000000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 97 0x61 a */
+	0x00, /* 00000000 */
+	0x40, /* 01000000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0x60, /* 01100000 */
+	0x00, /* 00000000 */
+
+	 /* 98 0x62 b */
+	0x80, /* 10000000 */
+	0xc0, /* 11000000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xc0, /* 11000000 */
+	0x00, /* 00000000 */
+
+	 /* 99 0x63 c */
+	0x00, /* 00000000 */
+	0x60, /* 01100000 */
+	0x80, /* 10000000 */
+	0x80, /* 10000000 */
+	0x60, /* 01100000 */
+	0x00, /* 00000000 */
+
+	 /* 100 0x64 d */
+	0x20, /* 00100000 */
+	0x60, /* 01100000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0x60, /* 01100000 */
+	0x00, /* 00000000 */
+
+	 /* 101 0x65 e */
+	0x00, /* 00000000 */
+	0x60, /* 01100000 */
+	0xe0, /* 11100000 */
+	0x80, /* 10000000 */
+	0x60, /* 01100000 */
+	0x00, /* 00000000 */
+
+	 /* 102 0x66 f */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+	0xe0, /* 11100000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 103 0x67 g */
+	0x00, /* 00000000 */
+	0x60, /* 01100000 */
+	0xa0, /* 10100000 */
+	0x60, /* 01100000 */
+	0x20, /* 00100000 */
+	0xc0, /* 11000000 */
+
+	 /* 104 0x68 h */
+	0x80, /* 10000000 */
+	0xc0, /* 11000000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0x00, /* 00000000 */
+
+	 /* 105 0x69 i */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 106 0x6a j */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0xa0, /* 10100000 */
+	0x40, /* 01000000 */
+
+	 /* 107 0x6b k */
+	0x80, /* 10000000 */
+	0xa0, /* 10100000 */
+	0xc0, /* 11000000 */
+	0xc0, /* 11000000 */
+	0xa0, /* 10100000 */
+	0x00, /* 00000000 */
+
+	 /* 108 0x6c l */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 109 0x6d m */
+	0x00, /* 00000000 */
+	0xe0, /* 11100000 */
+	0xe0, /* 11100000 */
+	0xe0, /* 11100000 */
+	0xa0, /* 10100000 */
+	0x00, /* 00000000 */
+
+	 /* 110 0x6e n */
+	0x00, /* 00000000 */
+	0xc0, /* 11000000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0x00, /* 00000000 */
+
+	 /* 111 0x6f o */
+	0x00, /* 00000000 */
+	0x40, /* 01000000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 112 0x70 p */
+	0x00, /* 00000000 */
+	0xc0, /* 11000000 */
+	0xa0, /* 10100000 */
+	0xc0, /* 11000000 */
+	0x80, /* 10000000 */
+	0x80, /* 10000000 */
+
+	 /* 113 0x71 q */
+	0x00, /* 00000000 */
+	0x60, /* 01100000 */
+	0xa0, /* 10100000 */
+	0x60, /* 01100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+
+	 /* 114 0x72 r */
+	0x00, /* 00000000 */
+	0xc0, /* 11000000 */
+	0xa0, /* 10100000 */
+	0x80, /* 10000000 */
+	0x80, /* 10000000 */
+	0x00, /* 00000000 */
+
+	 /* 115 0x73 s */
+	0x00, /* 00000000 */
+	0x60, /* 01100000 */
+	0xc0, /* 11000000 */
+	0x60, /* 01100000 */
+	0xc0, /* 11000000 */
+	0x00, /* 00000000 */
+
+	 /* 116 0x74 t */
+	0x40, /* 01000000 */
+	0xe0, /* 11100000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 117 0x75 u */
+	0x00, /* 00000000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+
+	 /* 118 0x76 v */
+	0x00, /* 00000000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 119 0x77 w */
+	0x00, /* 00000000 */
+	0xa0, /* 10100000 */
+	0xe0, /* 11100000 */
+	0xe0, /* 11100000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+
+	 /* 120 0x78 x */
+	0x00, /* 00000000 */
+	0xa0, /* 10100000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0xa0, /* 10100000 */
+	0x00, /* 00000000 */
+
+	 /* 121 0x79 y */
+	0x00, /* 00000000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0x60, /* 01100000 */
+	0x20, /* 00100000 */
+	0xc0, /* 11000000 */
+
+	 /* 122 0x7a z */
+	0x00, /* 00000000 */
+	0xe0, /* 11100000 */
+	0x60, /* 01100000 */
+	0xc0, /* 11000000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+
+	 /* 123 0x7b { */
+	0x60, /* 01100000 */
+	0x40, /* 01000000 */
+	0xc0, /* 11000000 */
+	0x40, /* 01000000 */
+	0x60, /* 01100000 */
+	0x00, /* 00000000 */
+
+	 /* 124 0x7c | */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 125 0x7d } */
+	0xc0, /* 11000000 */
+	0x40, /* 01000000 */
+	0x60, /* 01100000 */
+	0x40, /* 01000000 */
+	0xc0, /* 11000000 */
+	0x00, /* 00000000 */
+
+	 /* 126 0x7e ~ */
+	0x20, /* 00100000 */
+	0xe0, /* 11100000 */
+	0x80, /* 10000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 127 0x7f C177 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0xa0, /* 10100000 */
+	0xa0, /* 10100000 */
+	0xe0, /* 11100000 */
+	0x00, /* 00000000 */
+
+};
+
+struct fbcon_font_desc font_clean_4x6 = {
+	CLEAN4x6_IDX,
+	"Clean4x6",
+	4,
+	6,
+	fontdata_4x6,
+	-1000	/* Try avoiding this font if possible unless screen really small */
+};
diff -Nur linux/drivers/video/font_5x8.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/video/font_5x8.c
--- linux/drivers/video/font_5x8.c	1970-01-01 07:00:00.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/video/font_5x8.c	2003-06-23 01:47:03.000000000 +0700
@@ -0,0 +1,1314 @@
+/*       Font file generated by Jay Carlson from clR5x8.bdf */
+
+/*
+COMMENT  Copyright 1989 Dale Schumacher, dal@syntel.mn.org
+COMMENT                 399 Beacon Ave.
+COMMENT                 St. Paul, MN  55104-3527
+COMMENT  
+COMMENT  Permission to use, copy, modify, and distribute this software and
+COMMENT  its documentation for any purpose and without fee is hereby
+COMMENT  granted, provided that the above copyright notice appear in all
+COMMENT  copies and that both that copyright notice and this permission
+COMMENT  notice appear in supporting documentation, and that the name of
+COMMENT  Dale Schumacher not be used in advertising or publicity pertaining to
+COMMENT  distribution of the software without specific, written prior
+COMMENT  permission.  Dale Schumacher makes no representations about the
+COMMENT  suitability of this software for any purpose.  It is provided "as
+COMMENT  is" without express or implied warranty.
+*/
+
+#include <video/font.h>
+
+#define FONTDATAMAX (8 * 256)
+
+static unsigned char fontdata_5x8[FONTDATAMAX] = {
+
+	 /* 0 0x00 C000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 1 0x01 C001 */
+	0x00, /* 00000000 */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x78, /* 01111000 */
+	0x48, /* 01001000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 2 0x02 C002 */
+	0x00, /* 00000000 */
+	0x70, /* 01110000 */
+	0x48, /* 01001000 */
+	0x70, /* 01110000 */
+	0x48, /* 01001000 */
+	0x70, /* 01110000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 3 0x03 C003 */
+	0x00, /* 00000000 */
+	0x38, /* 00111000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x38, /* 00111000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 4 0x04 C004 */
+	0x00, /* 00000000 */
+	0x70, /* 01110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x70, /* 01110000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 5 0x05 C005 */
+	0x00, /* 00000000 */
+	0x78, /* 01111000 */
+	0x40, /* 01000000 */
+	0x70, /* 01110000 */
+	0x40, /* 01000000 */
+	0x78, /* 01111000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 6 0x06 C006 */
+	0x00, /* 00000000 */
+	0x78, /* 01111000 */
+	0x40, /* 01000000 */
+	0x70, /* 01110000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 7 0x07 C007 */
+	0x00, /* 00000000 */
+	0x38, /* 00111000 */
+	0x40, /* 01000000 */
+	0x58, /* 01011000 */
+	0x48, /* 01001000 */
+	0x38, /* 00111000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 8 0x08 C010 */
+	0x00, /* 00000000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x78, /* 01111000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 9 0x09 C011 */
+	0x00, /* 00000000 */
+	0x70, /* 01110000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x70, /* 01110000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 10 0x0a C012 */
+	0x00, /* 00000000 */
+	0x18, /* 00011000 */
+	0x08, /* 00001000 */
+	0x08, /* 00001000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 11 0x0b C013 */
+	0x00, /* 00000000 */
+	0x48, /* 01001000 */
+	0x50, /* 01010000 */
+	0x60, /* 01100000 */
+	0x50, /* 01010000 */
+	0x48, /* 01001000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 12 0x0c C014 */
+	0x00, /* 00000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x78, /* 01111000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 13 0x0d C015 */
+	0x00, /* 00000000 */
+	0x48, /* 01001000 */
+	0x78, /* 01111000 */
+	0x78, /* 01111000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 14 0x0e C016 */
+	0x00, /* 00000000 */
+	0x48, /* 01001000 */
+	0x68, /* 01101000 */
+	0x58, /* 01011000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 15 0x0f C017 */
+	0x00, /* 00000000 */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 16 0x10 C020 */
+	0x00, /* 00000000 */
+	0x70, /* 01110000 */
+	0x48, /* 01001000 */
+	0x70, /* 01110000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 17 0x11 C021 */
+	0x00, /* 00000000 */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x18, /* 00011000 */
+	0x00, /* 00000000 */
+
+	 /* 18 0x12 C022 */
+	0x00, /* 00000000 */
+	0x70, /* 01110000 */
+	0x48, /* 01001000 */
+	0x70, /* 01110000 */
+	0x50, /* 01010000 */
+	0x48, /* 01001000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 19 0x13 C023 */
+	0x00, /* 00000000 */
+	0x38, /* 00111000 */
+	0x40, /* 01000000 */
+	0x30, /* 00110000 */
+	0x08, /* 00001000 */
+	0x70, /* 01110000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 20 0x14 C024 */
+	0x00, /* 00000000 */
+	0xf8, /* 11111000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 21 0x15 C025 */
+	0x00, /* 00000000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 22 0x16 C026 */
+	0x00, /* 00000000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x30, /* 00110000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 23 0x17 C027 */
+	0x00, /* 00000000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x78, /* 01111000 */
+	0x78, /* 01111000 */
+	0x48, /* 01001000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 24 0x18 C030 */
+	0x00, /* 00000000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 25 0x19 C031 */
+	0x00, /* 00000000 */
+	0x88, /* 10001000 */
+	0x50, /* 01010000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 26 0x1a C032 */
+	0x00, /* 00000000 */
+	0x78, /* 01111000 */
+	0x10, /* 00010000 */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+	0x78, /* 01111000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 27 0x1b C033 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 28 0x1c C034 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 29 0x1d C035 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 30 0x1e C036 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 31 0x1f C037 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 32 0x20 C040 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 33 0x21 ! */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+
+	 /* 34 0x22 " */
+	0x28, /* 00101000 */
+	0x28, /* 00101000 */
+	0x28, /* 00101000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 35 0x23 # */
+	0x50, /* 01010000 */
+	0x50, /* 01010000 */
+	0xf8, /* 11111000 */
+	0x50, /* 01010000 */
+	0xf8, /* 11111000 */
+	0x50, /* 01010000 */
+	0x50, /* 01010000 */
+	0x00, /* 00000000 */
+
+	 /* 36 0x24 $ */
+	0x20, /* 00100000 */
+	0x78, /* 01111000 */
+	0xa0, /* 10100000 */
+	0x70, /* 01110000 */
+	0x28, /* 00101000 */
+	0xf0, /* 11110000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+
+	 /* 37 0x25 % */
+	0x60, /* 01100000 */
+	0x68, /* 01101000 */
+	0x10, /* 00010000 */
+	0x20, /* 00100000 */
+	0x58, /* 01011000 */
+	0x18, /* 00011000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 38 0x26 & */
+	0x30, /* 00110000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x28, /* 00101000 */
+	0x50, /* 01010000 */
+	0x50, /* 01010000 */
+	0x28, /* 00101000 */
+	0x00, /* 00000000 */
+
+	 /* 39 0x27 ' */
+	0x10, /* 00010000 */
+	0x10, /* 00010000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 40 0x28 ( */
+	0x08, /* 00001000 */
+	0x10, /* 00010000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x10, /* 00010000 */
+	0x08, /* 00001000 */
+	0x00, /* 00000000 */
+
+	 /* 41 0x29 ) */
+	0x40, /* 01000000 */
+	0x20, /* 00100000 */
+	0x10, /* 00010000 */
+	0x10, /* 00010000 */
+	0x10, /* 00010000 */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 42 0x2a * */
+	0x00, /* 00000000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x78, /* 01111000 */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 43 0x2b + */
+	0x00, /* 00000000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0xf8, /* 11111000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 44 0x2c , */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+
+	 /* 45 0x2d - */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0xf8, /* 11111000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 46 0x2e . */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+
+	 /* 47 0x2f / */
+	0x08, /* 00001000 */
+	0x08, /* 00001000 */
+	0x10, /* 00010000 */
+	0x10, /* 00010000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+
+	 /* 48 0x30 0 */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x58, /* 01011000 */
+	0x68, /* 01101000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x00, /* 00000000 */
+
+	 /* 49 0x31 1 */
+	0x20, /* 00100000 */
+	0x60, /* 01100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+
+	 /* 50 0x32 2 */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x08, /* 00001000 */
+	0x10, /* 00010000 */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+	0x78, /* 01111000 */
+	0x00, /* 00000000 */
+
+	 /* 51 0x33 3 */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x08, /* 00001000 */
+	0x30, /* 00110000 */
+	0x08, /* 00001000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x00, /* 00000000 */
+
+	 /* 52 0x34 4 */
+	0x08, /* 00001000 */
+	0x18, /* 00011000 */
+	0x18, /* 00011000 */
+	0x28, /* 00101000 */
+	0x28, /* 00101000 */
+	0x78, /* 01111000 */
+	0x08, /* 00001000 */
+	0x00, /* 00000000 */
+
+	 /* 53 0x35 5 */
+	0x78, /* 01111000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x70, /* 01110000 */
+	0x08, /* 00001000 */
+	0x08, /* 00001000 */
+	0x70, /* 01110000 */
+	0x00, /* 00000000 */
+
+	 /* 54 0x36 6 */
+	0x30, /* 00110000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x70, /* 01110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x00, /* 00000000 */
+
+	 /* 55 0x37 7 */
+	0x78, /* 01111000 */
+	0x08, /* 00001000 */
+	0x08, /* 00001000 */
+	0x10, /* 00010000 */
+	0x10, /* 00010000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+
+	 /* 56 0x38 8 */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x00, /* 00000000 */
+
+	 /* 57 0x39 9 */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x38, /* 00111000 */
+	0x08, /* 00001000 */
+	0x08, /* 00001000 */
+	0x30, /* 00110000 */
+	0x00, /* 00000000 */
+
+	 /* 58 0x3a : */
+	0x00, /* 00000000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+
+	 /* 59 0x3b ; */
+	0x00, /* 00000000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+
+	 /* 60 0x3c < */
+	0x08, /* 00001000 */
+	0x10, /* 00010000 */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+	0x20, /* 00100000 */
+	0x10, /* 00010000 */
+	0x08, /* 00001000 */
+	0x00, /* 00000000 */
+
+	 /* 61 0x3d = */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0xf8, /* 11111000 */
+	0x00, /* 00000000 */
+	0xf8, /* 11111000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 62 0x3e > */
+	0x40, /* 01000000 */
+	0x20, /* 00100000 */
+	0x10, /* 00010000 */
+	0x08, /* 00001000 */
+	0x10, /* 00010000 */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 63 0x3f ? */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x08, /* 00001000 */
+	0x10, /* 00010000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+
+	 /* 64 0x40 @ */
+	0x00, /* 00000000 */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x58, /* 01011000 */
+	0x58, /* 01011000 */
+	0x40, /* 01000000 */
+	0x30, /* 00110000 */
+	0x00, /* 00000000 */
+
+	 /* 65 0x41 A */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x78, /* 01111000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x00, /* 00000000 */
+
+	 /* 66 0x42 B */
+	0x70, /* 01110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x70, /* 01110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x70, /* 01110000 */
+	0x00, /* 00000000 */
+
+	 /* 67 0x43 C */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x00, /* 00000000 */
+
+	 /* 68 0x44 D */
+	0x70, /* 01110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x70, /* 01110000 */
+	0x00, /* 00000000 */
+
+	 /* 69 0x45 E */
+	0x78, /* 01111000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x70, /* 01110000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x78, /* 01111000 */
+	0x00, /* 00000000 */
+
+	 /* 70 0x46 F */
+	0x78, /* 01111000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x70, /* 01110000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 71 0x47 G */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x40, /* 01000000 */
+	0x58, /* 01011000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x38, /* 00111000 */
+	0x00, /* 00000000 */
+
+	 /* 72 0x48 H */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x78, /* 01111000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x00, /* 00000000 */
+
+	 /* 73 0x49 I */
+	0x70, /* 01110000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x70, /* 01110000 */
+	0x00, /* 00000000 */
+
+	 /* 74 0x4a J */
+	0x18, /* 00011000 */
+	0x08, /* 00001000 */
+	0x08, /* 00001000 */
+	0x08, /* 00001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x00, /* 00000000 */
+
+	 /* 75 0x4b K */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x50, /* 01010000 */
+	0x60, /* 01100000 */
+	0x50, /* 01010000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x00, /* 00000000 */
+
+	 /* 76 0x4c L */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x78, /* 01111000 */
+	0x00, /* 00000000 */
+
+	 /* 77 0x4d M */
+	0x48, /* 01001000 */
+	0x78, /* 01111000 */
+	0x78, /* 01111000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x00, /* 00000000 */
+
+	 /* 78 0x4e N */
+	0x48, /* 01001000 */
+	0x68, /* 01101000 */
+	0x68, /* 01101000 */
+	0x58, /* 01011000 */
+	0x58, /* 01011000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x00, /* 00000000 */
+
+	 /* 79 0x4f O */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x00, /* 00000000 */
+
+	 /* 80 0x50 P */
+	0x70, /* 01110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x70, /* 01110000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 81 0x51 Q */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x18, /* 00011000 */
+
+	 /* 82 0x52 R */
+	0x70, /* 01110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x70, /* 01110000 */
+	0x50, /* 01010000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x00, /* 00000000 */
+
+	 /* 83 0x53 S */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x40, /* 01000000 */
+	0x30, /* 00110000 */
+	0x08, /* 00001000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x00, /* 00000000 */
+
+	 /* 84 0x54 T */
+	0xf8, /* 11111000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+
+	 /* 85 0x55 U */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x00, /* 00000000 */
+
+	 /* 86 0x56 V */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x30, /* 00110000 */
+	0x30, /* 00110000 */
+	0x00, /* 00000000 */
+
+	 /* 87 0x57 W */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x78, /* 01111000 */
+	0x78, /* 01111000 */
+	0x48, /* 01001000 */
+	0x00, /* 00000000 */
+
+	 /* 88 0x58 X */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x00, /* 00000000 */
+
+	 /* 89 0x59 Y */
+	0x88, /* 10001000 */
+	0x88, /* 10001000 */
+	0x50, /* 01010000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+
+	 /* 90 0x5a Z */
+	0x78, /* 01111000 */
+	0x08, /* 00001000 */
+	0x10, /* 00010000 */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x78, /* 01111000 */
+	0x00, /* 00000000 */
+
+	 /* 91 0x5b [ */
+	0x38, /* 00111000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x38, /* 00111000 */
+	0x00, /* 00000000 */
+
+	 /* 92 0x5c \ */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x10, /* 00010000 */
+	0x10, /* 00010000 */
+	0x08, /* 00001000 */
+	0x08, /* 00001000 */
+
+	 /* 93 0x5d ] */
+	0x70, /* 01110000 */
+	0x10, /* 00010000 */
+	0x10, /* 00010000 */
+	0x10, /* 00010000 */
+	0x10, /* 00010000 */
+	0x10, /* 00010000 */
+	0x70, /* 01110000 */
+	0x00, /* 00000000 */
+
+	 /* 94 0x5e ^ */
+	0x20, /* 00100000 */
+	0x50, /* 01010000 */
+	0x88, /* 10001000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 95 0x5f _ */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0xf8, /* 11111000 */
+
+	 /* 96 0x60 ` */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x10, /* 00010000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 97 0x61 a */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x38, /* 00111000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x58, /* 01011000 */
+	0x28, /* 00101000 */
+	0x00, /* 00000000 */
+
+	 /* 98 0x62 b */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x70, /* 01110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x70, /* 01110000 */
+	0x00, /* 00000000 */
+
+	 /* 99 0x63 c */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x38, /* 00111000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x38, /* 00111000 */
+	0x00, /* 00000000 */
+
+	 /* 100 0x64 d */
+	0x08, /* 00001000 */
+	0x08, /* 00001000 */
+	0x38, /* 00111000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x38, /* 00111000 */
+	0x00, /* 00000000 */
+
+	 /* 101 0x65 e */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x78, /* 01111000 */
+	0x40, /* 01000000 */
+	0x30, /* 00110000 */
+	0x00, /* 00000000 */
+
+	 /* 102 0x66 f */
+	0x18, /* 00011000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x70, /* 01110000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+
+	 /* 103 0x67 g */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x38, /* 00111000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x38, /* 00111000 */
+	0x08, /* 00001000 */
+	0x30, /* 00110000 */
+
+	 /* 104 0x68 h */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x70, /* 01110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x00, /* 00000000 */
+
+	 /* 105 0x69 i */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+	0x60, /* 01100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x70, /* 01110000 */
+	0x00, /* 00000000 */
+
+	 /* 106 0x6a j */
+	0x10, /* 00010000 */
+	0x00, /* 00000000 */
+	0x30, /* 00110000 */
+	0x10, /* 00010000 */
+	0x10, /* 00010000 */
+	0x10, /* 00010000 */
+	0x10, /* 00010000 */
+	0x60, /* 01100000 */
+
+	 /* 107 0x6b k */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x48, /* 01001000 */
+	0x50, /* 01010000 */
+	0x60, /* 01100000 */
+	0x50, /* 01010000 */
+	0x48, /* 01001000 */
+	0x00, /* 00000000 */
+
+	 /* 108 0x6c l */
+	0x60, /* 01100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x70, /* 01110000 */
+	0x00, /* 00000000 */
+
+	 /* 109 0x6d m */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0xd0, /* 11010000 */
+	0xa8, /* 10101000 */
+	0xa8, /* 10101000 */
+	0xa8, /* 10101000 */
+	0x88, /* 10001000 */
+	0x00, /* 00000000 */
+
+	 /* 110 0x6e n */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x70, /* 01110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x00, /* 00000000 */
+
+	 /* 111 0x6f o */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x00, /* 00000000 */
+
+	 /* 112 0x70 p */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x70, /* 01110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x70, /* 01110000 */
+	0x40, /* 01000000 */
+
+	 /* 113 0x71 q */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x38, /* 00111000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x38, /* 00111000 */
+	0x08, /* 00001000 */
+
+	 /* 114 0x72 r */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x58, /* 01011000 */
+	0x60, /* 01100000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 115 0x73 s */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x38, /* 00111000 */
+	0x40, /* 01000000 */
+	0x30, /* 00110000 */
+	0x08, /* 00001000 */
+	0x70, /* 01110000 */
+	0x00, /* 00000000 */
+
+	 /* 116 0x74 t */
+	0x00, /* 00000000 */
+	0x20, /* 00100000 */
+	0x78, /* 01111000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x18, /* 00011000 */
+	0x00, /* 00000000 */
+
+	 /* 117 0x75 u */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x38, /* 00111000 */
+	0x00, /* 00000000 */
+
+	 /* 118 0x76 v */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x30, /* 00110000 */
+	0x00, /* 00000000 */
+
+	 /* 119 0x77 w */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x88, /* 10001000 */
+	0xa8, /* 10101000 */
+	0xa8, /* 10101000 */
+	0xa8, /* 10101000 */
+	0x50, /* 01010000 */
+	0x00, /* 00000000 */
+
+	 /* 120 0x78 x */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x30, /* 00110000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x00, /* 00000000 */
+
+	 /* 121 0x79 y */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x48, /* 01001000 */
+	0x38, /* 00111000 */
+	0x08, /* 00001000 */
+	0x30, /* 00110000 */
+
+	 /* 122 0x7a z */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x78, /* 01111000 */
+	0x10, /* 00010000 */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+	0x78, /* 01111000 */
+	0x00, /* 00000000 */
+
+	 /* 123 0x7b { */
+	0x08, /* 00001000 */
+	0x10, /* 00010000 */
+	0x10, /* 00010000 */
+	0x20, /* 00100000 */
+	0x10, /* 00010000 */
+	0x10, /* 00010000 */
+	0x08, /* 00001000 */
+	0x00, /* 00000000 */
+
+	 /* 124 0x7c | */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x00, /* 00000000 */
+
+	 /* 125 0x7d } */
+	0x40, /* 01000000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x10, /* 00010000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x40, /* 01000000 */
+	0x00, /* 00000000 */
+
+	 /* 126 0x7e ~ */
+	0x28, /* 00101000 */
+	0x50, /* 01010000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+	0x00, /* 00000000 */
+
+	 /* 127 0x7f C177 */
+	0x00, /* 00000000 */
+	0x20, /* 00100000 */
+	0x20, /* 00100000 */
+	0x50, /* 01010000 */
+	0x50, /* 01010000 */
+	0x88, /* 10001000 */
+	0xf8, /* 11111000 */
+	0x00, /* 00000000 */
+};
+
+struct fbcon_font_desc font_clean_5x8 = {
+	CLEAN5x8_IDX,
+	"Clean5x8",
+	5,
+	8,
+	fontdata_5x8,
+	-1000	/* Try avoiding this font if possible unless screen really small */
+};
diff -Nur linux/drivers/video/fonts.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/video/fonts.c
--- linux/drivers/video/fonts.c	2003-05-13 16:19:00.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/video/fonts.c	2003-06-23 01:47:03.000000000 +0700
@@ -56,6 +56,16 @@
 #undef NO_FONTS
     &font_pearl_8x8,
 #endif
+#ifdef CONFIG_FONT_5x8
+#if defined(CONFIG_FBCON_MAC) /* XXX fixme, need better test */
+#undef NO_FONTS
+#endif
+    &font_clean_5x8,
+#endif
+#ifdef CONFIG_FONT_4x6
+#undef NO_FONTS
+    &font_clean_4x6,
+#endif
 };
 
 #define num_fonts (sizeof(fbcon_fonts)/sizeof(*fbcon_fonts))
diff -Nur linux/drivers/video/fonts.c~ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/video/fonts.c~
--- linux/drivers/video/fonts.c~	1970-01-01 07:00:00.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/drivers/video/fonts.c~	2003-06-23 01:47:03.000000000 +0700
@@ -0,0 +1,131 @@
+/*
+ * linux/drivers/video/fonts.c -- `Soft' font definitions
+ *
+ *    Created 1995 by Geert Uytterhoeven
+ *    Rewritten 1998 by Martin Mares <mj@ucw.cz>
+ *
+ *	2001 - Documented with DocBook
+ *	- Brad Douglas <brad@neruo.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#if defined(__mc68000__) || defined(CONFIG_APUS)
+#include <asm/setup.h>
+#endif
+#include <video/font.h>
+
+#define NO_FONTS
+
+static struct fbcon_font_desc *fbcon_fonts[] = {
+#ifdef CONFIG_FONT_8x8
+#undef NO_FONTS
+    &font_vga_8x8,
+#endif
+#ifdef CONFIG_FONT_8x16
+#undef NO_FONTS
+    &font_vga_8x16,
+#endif
+#ifdef CONFIG_FONT_6x11
+#if defined(CONFIG_FBCON_MAC) || defined(CONFIG_FB_SBUS)
+#undef NO_FONTS
+#endif
+    &font_vga_6x11,
+#endif
+#ifdef CONFIG_FONT_SUN8x16
+#undef NO_FONTS
+    &font_sun_8x16,
+#endif
+#ifdef CONFIG_FONT_SUN12x22
+#if defined(CONFIG_FB_SBUS) || defined(CONFIG_FBCON_CFB8) || defined(CONFIG_FBCON_CFB16) || defined(CONFIG_FBCON_CFB24) || defined(CONFIG_FBCON_CFB32)
+#undef NO_FONTS
+#endif
+    &font_sun_12x22,
+#endif
+#ifdef CONFIG_FONT_ACORN_8x8
+#undef NO_FONTS
+    &font_acorn_8x8,
+#endif
+#ifdef CONFIG_FONT_PEARL_8x8
+#undef NO_FONTS
+    &font_pearl_8x8,
+#endif
+};
+
+#define num_fonts (sizeof(fbcon_fonts)/sizeof(*fbcon_fonts))
+
+#ifdef NO_FONTS
+#error No fonts configured.
+#endif
+
+
+/**
+ *	fbcon_find_font - find a font
+ *	@name: string name of a font
+ *
+ *	Find a specified font with string name @name.
+ *
+ *	Returns %NULL if no font found, or a pointer to the
+ *	specified font.
+ *
+ */
+
+struct fbcon_font_desc *fbcon_find_font(char *name)
+{
+   unsigned int i;
+
+   for (i = 0; i < num_fonts; i++)
+      if (!strcmp(fbcon_fonts[i]->name, name))
+	  return fbcon_fonts[i];
+   return NULL;
+}
+
+
+/**
+ *	fbcon_get_default_font - get default font
+ *	@xres: screen size of X
+ *	@yres: screen size of Y
+ *
+ *	Get the default font for a specified screen size.
+ *	Dimensions are in pixels.
+ *
+ *	Returns %NULL if no font is found, or a pointer to the
+ *	chosen font.
+ *
+ */
+
+struct fbcon_font_desc *fbcon_get_default_font(int xres, int yres)
+{
+    int i, c, cc;
+    struct fbcon_font_desc *f, *g;
+
+    g = NULL;
+    cc = -10000;
+    for(i=0; i<num_fonts; i++) {
+	f = fbcon_fonts[i];
+	c = f->pref;
+#if defined(__mc68000__) || defined(CONFIG_APUS)
+#ifdef CONFIG_FONT_PEARL_8x8
+	if (MACH_IS_AMIGA && f->idx == PEARL8x8_IDX)
+	    c = 100;
+#endif
+#ifdef CONFIG_FONT_6x11
+	if (MACH_IS_MAC && xres < 640 && f->idx == VGA6x11_IDX)
+	    c = 100;
+#endif
+#endif
+	if ((yres < 400) == (f->height <= 8))
+	    c += 1000;
+	if (c > cc) {
+	    cc = c;
+	    g = f;
+	}
+    }
+    return g;
+}
diff -Nur linux/fs/jffs2/GNUmakefile /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/GNUmakefile
--- linux/fs/jffs2/GNUmakefile	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/GNUmakefile	1970-01-01 07:00:00.000000000 +0700
@@ -1,49 +0,0 @@
-# GNUmakefile for JFFS2 build outside kernel tree
-# $Id: GNUmakefile,v 1.6 2002/09/03 16:38:24 dwmw2 Exp $
-
-LINUXDIR=/lib/modules/$(shell uname -r)/build
-
-ifndef VERSION
-# Someone just typed 'make' in this directory.
-# Invoke a kernel build process, with only this dir in SUBDIRS.
-
-modules:
-	$(MAKE) -C $(LINUXDIR) CONFIG_JFFS2_FS_NAND=y SUBDIRS=`pwd` modules
-
-nonand:
-	make -C $(LINUXDIR) SUBDIRS=`pwd` modules
-
-dep:
-	make -C $(LINUXDIR) SUBDIRS=`pwd` dep
-
-clean:
-	rm -f *.o
-
-else
-
-ifndef CONFIG_JFFS2_FS
-# Invoked from a kernel build tree, but CONFIG_JFFS2_FS isn't set. 
-# That means we must have got here from the hack above - pretend
-# CONFIG_JFFS2_FS _was_ set so that we actually build it, and also
-# pull in the local MTD include files in case they're also newer than
-# the ones in the kernel tree. And turn on debugging. 
-
-CC += -I$(shell pwd)/../../include
-
-CONFIG_JFFS2_FS := m
-EXTRA_CFLAGS += -DCONFIG_JFFS2_FS_DEBUG=1 -g -Werror
-
-ifeq ($(CONFIG_JFFS2_FS_NAND),y)
-EXTRA_CFLAGS += -DCONFIG_JFFS2_FS_NAND=1
-endif
-endif
-
-# Check whether we've put the JFFS2 stuff in the superblock and inode unions
-OUT_OF_KERNEL_CFLAGS := $(shell grep -q jffs2 $(TOPDIR)/include/linux/fs.h || echo "-DJFFS2_OUT_OF_KERNEL")
-EXTRA_CFLAGS += $(OUT_OF_KERNEL_CFLAGS)
-
-
-include Makefile
-
-
-endif
diff -Nur linux/fs/jffs2/LICENCE /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/LICENCE
--- linux/fs/jffs2/LICENCE	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/LICENCE	1970-01-01 07:00:00.000000000 +0700
@@ -1,35 +0,0 @@
-The files in this directory and elsewhere which refer to this LICENCE
-file are part of JFFS2, the Journalling Flash File System v2.
-
-	Copyright (C) 2001, 2002 Red Hat, Inc.
-
-JFFS2 is free software; you can redistribute it and/or modify it under
-the terms of the GNU General Public License as published by the Free
-Software Foundation; either version 2 or (at your option) any later 
-version.
-
-JFFS2 is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License along
-with JFFS2; if not, write to the Free Software Foundation, Inc.,
-59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
-
-As a special exception, if other files instantiate templates or use
-macros or inline functions from these files, or you compile these
-files and link them with other works to produce a work based on these
-files, these files do not by themselves cause the resulting work to be
-covered by the GNU General Public License. However the source code for
-these files must still be made available in accordance with section (3)
-of the GNU General Public License.
-
-This exception does not invalidate any other reasons why a work based on
-this file might be covered by the GNU General Public License.
-
-For information on obtaining alternative licences for JFFS2, see 
-http://sources.redhat.com/jffs2/jffs2-licence.html
-
-
-	$Id: LICENCE,v 1.1 2002/05/20 14:56:37 dwmw2 Exp $
diff -Nur linux/fs/jffs2/Makefile /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/Makefile
--- linux/fs/jffs2/Makefile	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/Makefile	2003-06-23 01:47:03.000000000 +0700
@@ -1,7 +1,7 @@
 #
 # Makefile for the linux Journalling Flash FileSystem (JFFS) routines.
 #
-# $Id: Makefile,v 1.34 2002/03/08 11:27:59 dwmw2 Exp $
+# $Id: Makefile,v 1.25 2001/09/25 20:59:41 dwmw2 Exp $
 #
 # Note! Dependencies are done automagically by 'make dep', which also
 # removes any old dependencies. DON'T put your own dependencies here
@@ -10,27 +10,17 @@
 # Note 2! The CFLAGS definitions are now in the main makefile...
 
 
-COMPR_OBJS	:= compr.o compr_rubin.o compr_rtime.o compr_zlib.o
-JFFS2_OBJS	:= dir.o file.o ioctl.o nodelist.o malloc.o \
-	read.o nodemgmt.o readinode.o write.o scan.o gc.o \
-	symlink.o build.o erase.o background.o fs.o writev.o
-
-LINUX_OBJS-24	:= super-v24.o crc32.o
-LINUX_OBJS-25	:= super.o
-
-NAND_OBJS-$(CONFIG_JFFS2_FS_NAND)	:= wbuf.o
-PROC_FS_OBJS-$(CONFIG_JFFS2_PROC_FS)	:= jffs2_proc.o
-NODEMERGE_OBJS-$(CONFIG_JFFS2_NODEMERGE)	:= nodemerge.o
+COMPR_OBJS	:= compr.o compr_rubin.o compr_rtime.o pushpull.o \
+			compr_zlib.o zlib.o
 
-subdir-y	:= compressors
+JFFS2_OBJS	:= crc32.o dir.o file.o ioctl.o nodelist.o malloc.o \
+	read.o nodemgmt.o readinode.o super.o write.o scan.o gc.o \
+	symlink.o build.o erase.o background.o
 
 O_TARGET := jffs2.o
 
-obj-y := $(COMPR_OBJS) $(JFFS2_OBJS) $(VERS_OBJS) $(NAND_OBJS-y) $(PROC_FS_OBJS-y) \
-	 $(NODEMERGE_OBJS-y) $(LINUX_OBJS-$(VERSION)$(PATCHLEVEL))
+obj-y := $(COMPR_OBJS) $(JFFS2_OBJS)
 obj-m := $(O_TARGET)
 
-obj-y += $(join $(subdir-y),$(subdir-y:%=/%.o))
-
 include $(TOPDIR)/Rules.make
 
diff -Nur linux/fs/jffs2/README.Locking /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/README.Locking
--- linux/fs/jffs2/README.Locking	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/README.Locking	1970-01-01 07:00:00.000000000 +0700
@@ -1,116 +0,0 @@
-	$Id: README.Locking,v 1.4 2002/03/08 16:20:06 dwmw2 Exp $
-
-	JFFS2 LOCKING DOCUMENTATION
-	---------------------------
-
-At least theoretically, JFFS2 does not require the Big Kernel Lock
-(BKL), which was always helpfully obtained for it by Linux 2.4 VFS
-code. It has its own locking, as described below.
-
-This document attempts to describe the existing locking rules for
-JFFS2. It is not expected to remain perfectly up to date, but ought to
-be fairly close.
-
-
-	alloc_sem
-	---------
-
-The alloc_sem is a per-filesystem semaphore, used primarily to ensure
-contiguous allocation of space on the medium. It is automatically
-obtained during space allocations (jffs2_reserve_space()) and freed
-upon write completion (jffs2_complete_reservation()). Note that
-the garbage collector will obtain this right at the beginning of
-jffs2_garbage_collect_pass() and release it at the end, thereby
-preventing any other write activity on the file system during a
-garbage collect pass.
-
-When writing new nodes, the alloc_sem must be held until the new nodes
-have been properly linked into the data structures for the inode to
-which they belong. This is for the benefit of NAND flash - adding new
-nodes to an inode may obsolete old ones, and by holding the alloc_sem
-until this happens we ensure that any data in the write-buffer at the
-time this happens are part of the new node, not just something that
-was written afterwards. Hence, we can ensure the newly-obsoleted nodes
-don't actually get erased until the write-buffer has been flushed to
-the medium.
-
-With the introduction of NAND flash support and the write-buffer, 
-the alloc_sem is also used to protect the wbuf-related members of the
-jffs2_sb_info structure. Atomically reading the wbuf_len member to see
-if the wbuf is currently holding any data is permitted, though.
-
-Ordering constraints: See f->sem.
-
-
-	File Semaphore f->sem
-	---------------------
-
-This is the JFFS2-internal equivalent of the inode semaphore i->i_sem.
-It protects the contents of the jffs2_inode_info private inode data,
-including the linked list of node fragments (but see the notes below on
-erase_completion_lock), etc.
-
-The reason that the i_sem itself isn't used for this purpose is to
-avoid deadlocks with garbage collection -- the VFS will lock the i_sem
-before calling a function which may need to allocate space. The
-allocation may trigger garbage-collection, which may need to move a
-node belonging to the inode which was locked in the first place by the
-VFS. If the garbage collection code were to attempt to lock the i_sem
-of the inode from which it's garbage-collecting a physical node, this
-lead to deadlock, unless we played games with unlocking the i_sem
-before calling the space allocation functions.
-
-Instead of playing such games, we just have an extra internal
-semaphore, which is obtained by the garbage collection code and also
-by the normal file system code _after_ allocation of space.
-
-Ordering constraints: 
-
-	1. Never attempt to allocate space or lock alloc_sem with 
-	   any f->sem held.
-	2. Never attempt to lock two file semaphores in one thread.
-	   No ordering rules have been made for doing so.
-
-
-	erase_completion_lock spinlock
-	------------------------------
-
-This is used to serialise access to the eraseblock lists, to the
-per-eraseblock lists of physical jffs2_raw_node_ref structures, and
-(NB) the per-inode list of physical nodes. The latter is a special
-case - see below.
-
-As the MTD API permits erase-completion callback functions to be
-called from bottom-half (timer) context, and these functions access
-the data structures protected by this lock, it must be locked with
-spin_lock_bh().
-
-Note that the per-inode list of physical nodes (f->nodes) is a special
-case. Any changes to _valid_ nodes (i.e. ->flash_offset & 1 == 0) in
-the list are protected by the file semaphore f->sem. But the erase
-code may remove _obsolete_ nodes from the list while holding only the
-erase_completion_lock. So you can walk the list only while holding the
-erase_completion_lock, and can drop the lock temporarily mid-walk as
-long as the pointer you're holding is to a _valid_ node, not an
-obsolete one.
-
-The erase_completion_lock is also used to protect the c->gc_task
-pointer when the garbage collection thread exits. The code to kill the
-GC thread locks it, sends the signal, then unlocks it - while the GC
-thread itself locks it, zeroes c->gc_task, then unlocks on the exit path.
-
-	node_free_sem
-	-------------
-
-This semaphore is only used by the erase code which frees obsolete
-node references and the jffs2_garbage_collect_deletion_dirent()
-function. The latter function on NAND flash must read _obsolete_ nodes
-to determine whether the 'deletion dirent' under consideration can be
-discarded or whether it is still required to show that an inode has
-been unlinked. Because reading from the flash may sleep, the
-erase_completion_lock cannot be held, so an alternative, more
-heavyweight lock was required to prevent the erase code from freeing
-the jffs2_raw_node_ref structures in question while the garbage
-collection code is looking at them.
-
-Suggestions for alternative solutions to this problem would be welcomed.
diff -Nur linux/fs/jffs2/TODO /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/TODO
--- linux/fs/jffs2/TODO	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/TODO	2003-06-23 01:47:03.000000000 +0700
@@ -1,6 +1,8 @@
-$Id: TODO,v 1.9 2002/07/11 10:39:04 dwmw2 Exp $
+$Id: TODO,v 1.3 2001/03/01 23:26:48 dwmw2 Exp $
 
- - disable compression in commit_write()?
+ - disable compression in commit_write()? Or at least optimise the 'always write
+	whole page' bit.
+ - fix zlib. It's ugly as hell and there are at least three copies in the kernel tree
  - fine-tune the allocation / GC thresholds
  - chattr support - turning on/off and tuning compression per-inode
  - checkpointing (do we need this? scan is quite fast)
@@ -8,37 +10,11 @@
 	mount doesn't have to read the flash twice for large files.
 	Make this a per-inode option, changable with chattr, so you can
 	decide which inodes should be in-core immediately after mount.
+ - stop it depending on a block device. mount(8) needs a change for this.
+ - make it work on NAND flash. We need to know when we can GC
+	deletion dirents, etc. And think about holes/truncation. It can
+	all be done reasonably simply, but it need implementing.
+ - NAND flash will require new dirent/dnode structures on the medium with
+	ECC data in rather than just the CRC we're using ATM.
  - test, test, test
 
- - NAND flash support:
-	- flush_wbuf using GC to fill it, don't just pad.
-	- Deal with write errors. Data don't get lost - we just have to write 
-	  the affected node(s) out again somewhere else.
-	- make fsync flush only if actually required
-	- make sys_sync() work.
-	- reboot notifier
-	- timed flush of old wbuf
-	- fix magical second arg of jffs2_flush_wbuf(). Split into two or more functions instead.
-
-
- - Optimisations:
-   - Stop GC from decompressing and immediately recompressing nodes which could
-     just be copied intact.
-   - Furthermore, in the case where it could be copied intact we don't even need
-     to call iget() for it -- if we use (raw_node_raw->flash_offset & 2) as a flag
-     to show a node can be copied intact and it's _not_ in icache, we could just do
-     it, fix up the next_in_ino list and move on. We would need a way to find out
-     _whether_ it's in icache though -- if it's in icache we also need to do the 
-     fragment lists, etc. P'raps a flag or pointer in the jffs2_inode_cache could
-     help.
-   - Stop keeping name in-core with struct jffs2_full_dirent. If we keep the hash in 
-     the full dirent, we only need to go to the flash in lookup() when we think we've
-     got a match, and in readdir(). 
-   - Doubly-linked next_in_ino list to allow us to free obsoleted raw_node_refs immediately?
-   - Remove totlen from jffs2_raw_node_ref? Need to have totlen passed into
-	jffs2_mark_node_obsolete(). Can all callers work it out?
-   - Don't check data CRC on node scan during mount. We don't really need to know 
-	yet. This means we can't build up node fragment lists, and hence can't 
-	build accurate clean/dirty information. But we don't _need_ that for reading,
-	only for writing. And in fact we don't even need it for writing until we 
-	start to need GC.
diff -Nur linux/fs/jffs2/background.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/background.c
--- linux/fs/jffs2/background.c	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/background.c	2003-06-23 01:47:03.000000000 +0700
@@ -1,61 +1,59 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
+ * Copyright (C) 2001 Red Hat, Inc.
  *
  * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: background.c,v 1.31 2002/08/20 15:41:28 gleixner Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
  *
- * ChangeLog:
- *     27-Nov-2002 Lineo Japan, Inc.  add effective-gc mode
- *     25-Nov-2002 Lineo Japan, Inc.  end GC when jffs2_garbage_collect_pass
- *       returns -ENOSPC
- *     23-Nov-2002 Lineo Japan, Inc.  reverse precedence between
- *       c->nodemerge_list and c->very_dirty_list
- *     15-Nov-2002 Lineo Japan, Inc.  add nodemerge facility and c->nodemerge_list
- *				      correct indentation
- *     29-Oct-2002 Lineo Japan, Inc.  add reserved blocks for badblock
- *				      add c->cont_gc_count
- *     24-Oct-2002 Lineo Japan, Inc.  add min. available blocks
- *
- * ChangeLog:
- *     05-Dec-2002 SHARP  adjust gc-end conditions
- *     27-Nov-2002 Lineo Japan, Inc.  add effective-gc mode
- *     25-Nov-2002 Lineo Japan, Inc.  end GC when jffs2_garbage_collect_pass
- *       returns -ENOSPC
- *     23-Nov-2002 Lineo Japan, Inc.  reverse precedence between
- *       c->nodemerge_list and c->very_dirty_list
- *     15-Nov-2002 Lineo Japan, Inc.  add nodemerge facility and c->nodemerge_list
- *				      correct indentation
- *     29-Oct-2002 Lineo Japan, Inc.  add reserved blocks for badblock
- *				      add c->cont_gc_count
- *     24-Oct-2002 Lineo Japan, Inc.  add min. available blocks
+ * $Id: background.c,v 1.16 2001/10/08 09:22:38 dwmw2 Exp $
  *
  */
 
 #define __KERNEL_SYSCALLS__
 
 #include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/unistd.h>
 #include <linux/jffs2.h>
 #include <linux/mtd/mtd.h>
 #include <linux/interrupt.h>
 #include <linux/completion.h>
-#include <linux/mtd/compatmac.h> /* recalc_sigpending() */
-#include <linux/unistd.h>
 #include "nodelist.h"
 
 
 static int jffs2_garbage_collect_thread(void *);
-static int thread_should_do_effective_gc(struct jffs2_sb_info *c);
-static int thread_should_wake(struct jffs2_sb_info *c, int);
+static int thread_should_wake(struct jffs2_sb_info *c);
 
 void jffs2_garbage_collect_trigger(struct jffs2_sb_info *c)
 {
 	spin_lock_bh(&c->erase_completion_lock);
-        if (c->gc_task && thread_should_wake(c, 0))
+        if (c->gc_task && thread_should_wake(c))
                 send_sig(SIGHUP, c->gc_task, 1);
 	spin_unlock_bh(&c->erase_completion_lock);
 }
@@ -88,13 +86,6 @@
 
 void jffs2_stop_garbage_collect_thread(struct jffs2_sb_info *c)
 {
-	if (c->mtd->type == MTD_NANDFLASH) {
-		/* stop a eventually scheduled wbuf flush timer */
-		del_timer_sync(&c->wbuf_timer);
-		/* make sure, that a scheduled wbuf flush task is completed */
-		flush_scheduled_tasks();
-	}
-
 	spin_lock_bh(&c->erase_completion_lock);
 	if (c->gc_task) {
 		D1(printk(KERN_DEBUG "jffs2: Killing GC task %d\n", c->gc_task->pid));
@@ -107,28 +98,24 @@
 static int jffs2_garbage_collect_thread(void *_c)
 {
 	struct jffs2_sb_info *c = _c;
-	int ret = 0;
-	jffs2_gcmode_t gcmode = GCMODE_NORMAL;
 
 	daemonize();
-
+	current->tty = NULL;
 	c->gc_task = current;
 	up(&c->gc_thread_start);
 
         sprintf(current->comm, "jffs2_gcd_mtd%d", c->mtd->index);
 
-	set_user_nice(current, 10);
+	/* FIXME in the 2.2 backport */
+	current->nice = 10;
 
 	for (;;) {
 		spin_lock_irq(&current->sigmask_lock);
-		if (gcmode == GCMODE_NORMAL)
-			siginitsetinv (&current->blocked, sigmask(SIGUSR1) | sigmask(SIGHUP) | sigmask(SIGKILL) | sigmask(SIGSTOP) | sigmask(SIGCONT));
-		else
-			siginitsetinv (&current->blocked, sigmask(SIGKILL) | sigmask(SIGSTOP) | sigmask(SIGCONT));
+		siginitsetinv (&current->blocked, sigmask(SIGHUP) | sigmask(SIGKILL) | sigmask(SIGSTOP) | sigmask(SIGCONT));
 		recalc_sigpending();
 		spin_unlock_irq(&current->sigmask_lock);
 
-		if (gcmode == GCMODE_NORMAL && (ret == -ENOSPC || !thread_should_wake(c, 1))) {
+		if (!thread_should_wake(c)) {
                         set_current_state (TASK_INTERRUPTIBLE);
 			D1(printk(KERN_DEBUG "jffs2_garbage_collect_thread sleeping...\n"));
 			/* Yes, there's a race here; we checked thread_should_wake() before
@@ -138,7 +125,8 @@
 			schedule();
 		}
                 
-		cond_resched();
+		if (current->need_resched)
+			schedule();
 
                 /* Put_super will send a SIGKILL and then wait on the sem. 
                  */
@@ -161,20 +149,12 @@
                                 D1(printk(KERN_DEBUG "jffs2_garbage_collect_thread(): SIGKILL received.\n"));
 				spin_lock_bh(&c->erase_completion_lock);
                                 c->gc_task = NULL;
-				c->effective_gc_count = 0;
 				spin_unlock_bh(&c->erase_completion_lock);
 				complete_and_exit(&c->gc_thread_exit, 0);
 
 			case SIGHUP:
 				D1(printk(KERN_DEBUG "jffs2_garbage_collect_thread(): SIGHUP received.\n"));
 				break;
-
-			case SIGUSR1:
-				gcmode = GCMODE_EFFECTIVE;
-				c->effective_gc_count++;
-				D1(printk(KERN_DEBUG "jffs2_garbage_collect_thread(): SIGUSR1 received. effective_gc_count=(%d)\n", c->effective_gc_count));
-				break;
-
 			default:
 				D1(printk(KERN_DEBUG "jffs2_garbage_collect_thread(): signal %ld received\n", signr));
 
@@ -186,134 +166,18 @@
 		recalc_sigpending();
 		spin_unlock_irq(&current->sigmask_lock);
 
-		if (gcmode == GCMODE_EFFECTIVE && ! thread_should_do_effective_gc(c)) {
-			gcmode = GCMODE_NORMAL;
-			c->effective_gc_count++;
-			ret = 0;
-			continue;
-		}
-
 		D1(printk(KERN_DEBUG "jffs2_garbage_collect_thread(): pass\n"));
-		ret = jffs2_garbage_collect_pass(c, gcmode);
-		if (gcmode == GCMODE_EFFECTIVE && ret <= 0) {
-			gcmode = GCMODE_NORMAL;
-			c->effective_gc_count++;
-		}
+		jffs2_garbage_collect_pass(c);
 	}
 }
 
-static int thread_should_do_effective_gc(struct jffs2_sb_info *c)
+static int thread_should_wake(struct jffs2_sb_info *c)
 {
-	int ret = 0;
-
-	spin_lock_bh(&c->erase_completion_lock);
-
-	if (thread_should_wake_by_nodemerge_list(c, 1))	// add for /proc/.../.nodemerge
-		ret = 1;
-
-	if (NR_AVAIL_BLOCKS(c) < JFFS2_RESERVED_BLOCKS_GCTRIGGER) {
-		uint32_t dirty_now, erasing_dirty_now, nonerasing_dirty_now;
-		int32_t avail_blocks;
-
-		dirty_now = c->dirty_size;
-		erasing_dirty_now = c->erasing_dirty_size;
-		nonerasing_dirty_now = ((dirty_now >= erasing_dirty_now) ? (dirty_now - erasing_dirty_now) : 0);
-		avail_blocks = NR_AVAIL_BLOCKS(c);
-
-		if(ret){
-			if (avail_blocks <= JFFS2_RESERVED_BLOCKS_GCMERGE)
-				ret = 0;
-		}else{
-			if (avail_blocks <= 1 ||
-			    dirty_now < c->sector_size ||
-			    nonerasing_dirty_now / c->sector_size < JFFS2_RESERVED_BLOCKS_DIRTY)
-				ret = 0;
-			else
-				ret = 1;
-		}
-	}
-	else
-		ret = 1;
-
-	spin_unlock_bh(&c->erase_completion_lock);
-
-	return ret;
-}
-
-#ifdef CONFIG_JFFS2_NODEMERGE
-static inline int thread_should_wake_by_nodemerge_list(struct jffs2_sb_info *c, int from_effective_gc)
-{
-	if (c->flags & JFFS2_SB_FLAG_GCING_A_BLOCK)
-		return 1;
-#ifdef CONFIG_ARCH_SHARP_SL
-	else if (! list_empty(&c->very_dirty_list))
+	D1(printk(KERN_DEBUG "thread_should_wake(): nr_free_blocks %d, nr_erasing_blocks %d, dirty_size 0x%x\n", 
+		  c->nr_free_blocks, c->nr_erasing_blocks, c->dirty_size));
+	if (c->nr_free_blocks + c->nr_erasing_blocks < JFFS2_RESERVED_BLOCKS_GCTRIGGER &&
+	    c->dirty_size > c->sector_size)
 		return 1;
-#endif
-	else if (! list_empty(&c->nodemerge_list)){
-		if(NR_AVAIL_BLOCKS(c) >= JFFS2_RESERVED_BLOCKS_CLEAN){
-			return 1;
-		}else{
-			if(from_effective_gc &&
-			   jffs2_get_dirty_block(&c->nodemerge_list) != NULL){
-				return 1;
-			}else{
-				return 0;
-			}
-		}
-	}
-	else
+	else 
 		return 0;
 }
-#else
-static inline int thread_should_wake_by_nodemerge_list(struct jffs2_sb_info* c, int from_effective_gc)
-{
-	return 0;
-}
-#endif
-
-static int thread_should_wake(struct jffs2_sb_info *c, int from_gc_loop)
-{
-	int ret = 0;
-
-	if (thread_should_wake_by_nodemerge_list(c, 0))
-		ret = 1;
-
-	if (NR_AVAIL_BLOCKS(c) < JFFS2_RESERVED_BLOCKS_GCTRIGGER) {
-		uint32_t dirty_now, erasing_dirty_now, nonerasing_dirty_now;
-		int32_t avail_blocks;
-
-		dirty_now = c->dirty_size;
-		erasing_dirty_now = c->erasing_dirty_size;
-		nonerasing_dirty_now = ((dirty_now >= erasing_dirty_now) ? (dirty_now - erasing_dirty_now) : 0);
-		avail_blocks = NR_AVAIL_BLOCKS(c);
-
-		if(ret){
-			if (c->cont_gc_count >= JFFS2_MAX_CONT_GC ||
-			    avail_blocks <= JFFS2_RESERVED_BLOCKS_GCMERGE)
-				ret = 0;
-		}else{
-			if (c->cont_gc_count >= JFFS2_MAX_CONT_GC ||
-			    avail_blocks <= 1 ||
-			    dirty_now < c->sector_size ||
-			    nonerasing_dirty_now / c->sector_size < JFFS2_RESERVED_BLOCKS_DIRTY)
-				ret = 0;
-			else {
-				c->cont_gc_count++;
-				ret = 1;
-			}
-		}
-	}
-	else if (from_gc_loop && ! ret)
-		c->cont_gc_count = 0;
-
-	D1(printk(KERN_DEBUG "thread_should_wake(): nr_free_blocks %d, nr_erasing_blocks %d, dirty_size 0x%x, cont_gc_count %d: %s\n", 
-		  c->nr_free_blocks, c->nr_erasing_blocks, c->dirty_size, c->cont_gc_count, ret?"yes":"no"));
-
-	return ret;
-}
-
-/*
- * Local variables:
- *   c-basic-offset: 8
- * End:
- */
diff -Nur linux/fs/jffs2/build.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/build.c
--- linux/fs/jffs2/build.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/build.c	2003-06-23 01:47:03.000000000 +0700
@@ -1,27 +1,45 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
+ * Copyright (C) 2001 Red Hat, Inc.
  *
  * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: build.c,v 1.41 2002/09/06 14:12:44 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
  *
- * ChangeLog:
- *     15-Nov-2002 Lineo Japan, Inc.  add nodemerge facility
- *     20-Sep-2002 Lineo Japan, Inc.  add jffs2_orphaned_inodes
- *					but it is useless right now
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: build.c,v 1.16.2.2 2002/03/12 15:36:43 dwmw2 Exp $
  *
  */
 
 #include <linux/kernel.h>
+#include <linux/jffs2.h>
 #include <linux/slab.h>
 #include "nodelist.h"
 
-static enum { ORPHANED_DELETE, ORPHANED_ERROR } orphaned_inodes_mode;
-
 int jffs2_build_inode_pass1(struct jffs2_sb_info *, struct jffs2_inode_cache *);
 int jffs2_build_remove_unlinked_inode(struct jffs2_sb_info *, struct jffs2_inode_cache *);
 
@@ -33,7 +51,7 @@
  - Scan directory tree from top down, setting nlink in inocaches
  - Scan inocaches for inodes with nlink==0
 */
-static int jffs2_build_filesystem(struct jffs2_sb_info *c)
+int jffs2_build_filesystem(struct jffs2_sb_info *c)
 {
 	int ret;
 	int i;
@@ -50,7 +68,6 @@
 		return ret;
 
 	D1(printk(KERN_DEBUG "Scanned flash completely\n"));
-	D1(jffs2_dump_block_lists(c));
 	/* Now build the data map for each inode, marking obsoleted nodes
 	   as such, and also increase nlink of any children. */
 	for_each_inode(i, c, ic) {
@@ -60,11 +77,9 @@
 			D1(printk(KERN_WARNING "Eep. jffs2_build_inode_pass1 for ino %d returned %d\n", ic->ino, ret));
 			return ret;
 		}
-		cond_resched();
 	}
 	D1(printk(KERN_DEBUG "Pass 1 complete\n"));
-	D1(jffs2_dump_block_lists(c));
-	
+
 	/* Next, scan for inodes with nlink == 0 and remove them. If
 	   they were directories, then decrement the nlink of their
 	   children too, and repeat the scan. As that's going to be
@@ -78,16 +93,6 @@
 			if (ic->nlink)
 				continue;
 			
-			/* XXX: Can get high latency here. Move the cond_resched() from the end of the loop? */
-
-			switch (orphaned_inodes_mode) {
-			case ORPHANED_ERROR:
-				printk(KERN_ERR "%s: detect orphaned inode\n", __func__);
-				return -EIO;
-
-			default:
-				break;
-			}
 			ret = jffs2_build_remove_unlinked_inode(c, ic);
 			if (ret)
 				break;
@@ -95,12 +100,8 @@
 		   and furthermore that it had children and their nlink has now
 		   gone to zero too. So we have to restart the scan. */
 		} 
-		D1(jffs2_dump_block_lists(c));
-
-		cond_resched();
-	
 	} while(ret == -EAGAIN);
-
+	
 	D1(printk(KERN_DEBUG "Pass 2 complete\n"));
 	
 	/* Finally, we can scan again and free the dirent nodes and scan_info structs */
@@ -121,13 +122,8 @@
 			jffs2_free_full_dirent(fd);
 		}
 		kfree(scan);
-		cond_resched();
 	}
 	D1(printk(KERN_DEBUG "Pass 3 complete\n"));
-	D1(jffs2_dump_block_lists(c));
-
-	/* Rotate the lists by some number to ensure wear levelling */
-	jffs2_rotate_lists(c);
 
 	return ret;
 }
@@ -136,7 +132,7 @@
 {
 	struct jffs2_tmp_dnode_info *tn;
 	struct jffs2_full_dirent *fd;
-	rb_root_t fragtree = RB_ROOT;
+	struct jffs2_node_frag *fraglist = NULL;
 	struct jffs2_tmp_dnode_info *metadata = NULL;
 
 	D1(printk(KERN_DEBUG "jffs2_build_inode building inode #%u\n", ic->ino));
@@ -153,56 +149,52 @@
 		
 		if (metadata && tn->version > metadata->version) {
 			D1(printk(KERN_DEBUG "jffs2_build_inode_pass1 ignoring old metadata at 0x%08x\n",
-				  ref_offset(metadata->fn->raw)));
+				  metadata->fn->raw->flash_offset &~3));
 			
-			jffs2_mark_node_obsolete(c, metadata->fn->raw);
 			jffs2_free_full_dnode(metadata->fn);
 			jffs2_free_tmp_dnode_info(metadata);
 			metadata = NULL;
 		}
 			
 		if (tn->fn->size) {
-			jffs2_add_full_dnode_to_fraglist (c, &fragtree, tn->fn);
+			jffs2_add_full_dnode_to_fraglist (c, &fraglist, tn->fn);
 			jffs2_free_tmp_dnode_info(tn);
 		} else {
 			if (!metadata) {
 				metadata = tn;
 			} else {
-				/* This will only happen if it has the _same_ version
-				   number as the existing metadata node. */
 				D1(printk(KERN_DEBUG "jffs2_build_inode_pass1 ignoring new metadata at 0x%08x\n",
-					  ref_offset(tn->fn->raw)));
+					  tn->fn->raw->flash_offset &~3));
 				
-				jffs2_mark_node_obsolete(c, tn->fn->raw);
 				jffs2_free_full_dnode(tn->fn);
 				jffs2_free_tmp_dnode_info(tn);
 			}
 		}
 	}
-
-	if (ic->scan->version) {
-		/* It's a regular file, so truncate it to the last known
-		   i_size, if necessary */
-		D1(printk(KERN_DEBUG "jffs2_build_inode_pass1 truncating fraglist to 0x%08x\n", ic->scan->isize));
-		jffs2_truncate_fraglist_1(c, &fragtree, ic->scan->isize);
-	}
-	
+		
 	/* OK. Now clear up */
 	if (metadata) {
 		jffs2_free_full_dnode(metadata->fn);
 		jffs2_free_tmp_dnode_info(metadata);
 	}
 	metadata = NULL;
-
-	jffs2_kill_fragtree(&fragtree, NULL);
+	
+	while (fraglist) {
+		struct jffs2_node_frag *frag;
+		frag = fraglist;
+		fraglist = fraglist->next;
+		
+		if (frag->node && !(--frag->node->frags)) {
+			jffs2_free_full_dnode(frag->node);
+		}
+		jffs2_free_node_frag(frag);
+	}
 
 	/* Now for each child, increase nlink */
 	for(fd=ic->scan->dents; fd; fd = fd->next) {
 		struct jffs2_inode_cache *child_ic;
 		if (!fd->ino)
 			continue;
-		
-		/* XXX: Can get high latency here with huge directories */
 
 		child_ic = jffs2_get_ino_cache(c, fd->ino);
 		if (!child_ic) {
@@ -239,38 +231,25 @@
 	D1(printk(KERN_DEBUG "JFFS2: Removing ino #%u with nlink == zero.\n", ic->ino));
 	
 	for (raw = ic->nodes; raw != (void *)ic; raw = raw->next_in_ino) {
-		D1(printk(KERN_DEBUG "obsoleting node at 0x%08x\n", ref_offset(raw)));
+		D1(printk(KERN_DEBUG "obsoleting node at 0x%08x\n", raw->flash_offset&~3));
 		jffs2_mark_node_obsolete(c, raw);
 	}
 
 	if (ic->scan->dents) {
-		int whinged = 0;
-		D1(printk(KERN_DEBUG "Inode #%u was a directory which may have children...\n", ic->ino));
-
+		printk(KERN_NOTICE "Inode #%u was a directory with children - removing those too...\n", ic->ino);
+	
 		while(ic->scan->dents) {
 			struct jffs2_inode_cache *child_ic;
 
 			fd = ic->scan->dents;
 			ic->scan->dents = fd->next;
 
-			if (!fd->ino) {
-				/* It's a deletion dirent. Ignore it */
-				D1(printk(KERN_DEBUG "Child \"%s\" is a deletion dirent, skipping...\n", fd->name));
-				jffs2_free_full_dirent(fd);
-				continue;
-			}
-			if (!whinged) {
-				whinged = 1;
-				printk(KERN_NOTICE "Inode #%u was a directory with children - removing those too...\n", ic->ino);
-			}
-
 			D1(printk(KERN_DEBUG "Removing child \"%s\", ino #%u\n",
 				  fd->name, fd->ino));
 			
 			child_ic = jffs2_get_ino_cache(c, fd->ino);
 			if (!child_ic) {
 				printk(KERN_NOTICE "Cannot remove child \"%s\", ino #%u, because it doesn't exist\n", fd->name, fd->ino);
-				jffs2_free_full_dirent(fd);
 				continue;
 			}
 			jffs2_free_full_dirent(fd);
@@ -280,82 +259,7 @@
 	}
 	kfree(ic->scan);
 	ic->scan = NULL;
-
-	/*
-	   We don't delete the inocache from the hash list and free it yet. 
-	   The erase code will do that, when all the nodes are completely gone.
-	*/
-
+	//	jffs2_del_ino_cache(c, ic);
+	//	jffs2_free_inode_cache(ic);
 	return ret;
 }
-
-int jffs2_do_mount_fs(struct jffs2_sb_info *c)
-{
-	int i;
-
-	c->free_size = c->flash_size;
-	c->nr_blocks = c->flash_size / c->sector_size;
-	c->blocks = kmalloc(sizeof(struct jffs2_eraseblock) * c->nr_blocks, GFP_KERNEL);
-	if (!c->blocks)
-		return -ENOMEM;
-	for (i=0; i<c->nr_blocks; i++) {
-		INIT_LIST_HEAD(&c->blocks[i].list);
-		c->blocks[i].offset = i * c->sector_size;
-		c->blocks[i].free_size = c->sector_size;
-		c->blocks[i].dirty_size = 0;
-		c->blocks[i].wasted_size = 0;
-		c->blocks[i].used_size = 0;
-		c->blocks[i].first_node = NULL;
-		c->blocks[i].last_node = NULL;
-	}
-
-	init_MUTEX(&c->alloc_sem);
-	init_MUTEX(&c->erase_free_sem);
-	init_waitqueue_head(&c->erase_wait);
-	spin_lock_init(&c->erase_completion_lock);
-	spin_lock_init(&c->inocache_lock);
-
-	INIT_LIST_HEAD(&c->clean_list);
-	INIT_LIST_HEAD(&c->very_dirty_list);
-	INIT_LIST_HEAD(&c->dirty_list);
-	INIT_LIST_HEAD(&c->erasable_list);
-	INIT_LIST_HEAD(&c->erasing_list);
-	INIT_LIST_HEAD(&c->erase_pending_list);
-	INIT_LIST_HEAD(&c->erasable_pending_wbuf_list);
-	INIT_LIST_HEAD(&c->erase_complete_list);
-	INIT_LIST_HEAD(&c->free_list);
-	INIT_LIST_HEAD(&c->bad_list);
-	INIT_LIST_HEAD(&c->bad_used_list);
-#ifdef CONFIG_JFFS2_NODEMERGE
-	INIT_LIST_HEAD(&c->nodemerge_list);
-#endif
-	c->highest_ino = 1;
-
-	if (jffs2_build_filesystem(c)) {
-		D1(printk(KERN_DEBUG "build_fs failed\n"));
-		jffs2_free_ino_caches(c);
-		jffs2_free_raw_node_refs(c);
-		kfree(c->blocks);
-		return -EIO;
-	}
-	return 0;
-}
-
-
-static int __init jffs2_setup(char* s)
-{
-	if (strcmp(s, "error") == 0)
-		orphaned_inodes_mode = ORPHANED_ERROR;
-	else
-		orphaned_inodes_mode = ORPHANED_DELETE;
-	return 1;
-}
-
-
-__setup("jffs2_orphaned_inodes=", jffs2_setup);
-
-/*
- * Local variables:
- *   c-basic-offset: 8
- * End:
- */
diff -Nur linux/fs/jffs2/compr.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compr.c
--- linux/fs/jffs2/compr.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compr.c	2003-06-23 01:47:03.000000000 +0700
@@ -1,43 +1,54 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
+ * Copyright (C) 2001 Red Hat, Inc.
  *
  * Created by Arjan van de Ven <arjanv@redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: compr.c,v 1.24 2002/05/20 14:56:37 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
  *
- * ChangeLog:
- *     20-Nov-2002 Lineo Japan, Inc.  don't choose rtime compressor
+ * $Id: compr.c,v 1.17 2001/09/23 09:56:46 dwmw2 Exp $
  *
  */
 
-#ifdef __KERNEL__
 #include <linux/kernel.h>
 #include <linux/string.h>
+#include <linux/types.h>
 #include <linux/errno.h>
-#else 
-#define KERN_DEBUG
-#define KERN_NOTICE
-#define KERN_WARNING
-#define printk printf
-#include <stdio.h>
-#include <stdint.h>
-#include <errno.h>
-#endif
-
 #include <linux/jffs2.h>
 
-int jffs2_zlib_compress(unsigned char *data_in, unsigned char *cpage_out, uint32_t *sourcelen, uint32_t *dstlen);
-void jffs2_zlib_decompress(unsigned char *data_in, unsigned char *cpage_out, uint32_t srclen, uint32_t destlen);
-int jffs2_rtime_compress(unsigned char *data_in, unsigned char *cpage_out, uint32_t *sourcelen, uint32_t *dstlen);
-void jffs2_rtime_decompress(unsigned char *data_in, unsigned char *cpage_out, uint32_t srclen, uint32_t destlen);
-int jffs2_rubinmips_compress(unsigned char *data_in, unsigned char *cpage_out, uint32_t *sourcelen, uint32_t *dstlen);
-void jffs2_rubinmips_decompress(unsigned char *data_in, unsigned char *cpage_out, uint32_t srclen, uint32_t destlen);
-int jffs2_dynrubin_compress(unsigned char *data_in, unsigned char *cpage_out, uint32_t *sourcelen, uint32_t *dstlen);
-void jffs2_dynrubin_decompress(unsigned char *data_in, unsigned char *cpage_out, uint32_t srclen, uint32_t destlen);
+int zlib_compress(unsigned char *data_in, unsigned char *cpage_out, __u32 *sourcelen, __u32 *dstlen);
+void zlib_decompress(unsigned char *data_in, unsigned char *cpage_out, __u32 srclen, __u32 destlen);
+int rtime_compress(unsigned char *data_in, unsigned char *cpage_out, __u32 *sourcelen, __u32 *dstlen);
+void rtime_decompress(unsigned char *data_in, unsigned char *cpage_out, __u32 srclen, __u32 destlen);
+int rubinmips_compress(unsigned char *data_in, unsigned char *cpage_out, __u32 *sourcelen, __u32 *dstlen);
+void rubinmips_decompress(unsigned char *data_in, unsigned char *cpage_out, __u32 srclen, __u32 destlen);
+int dynrubin_compress(unsigned char *data_in, unsigned char *cpage_out, __u32 *sourcelen, __u32 *dstlen);
+void dynrubin_decompress(unsigned char *data_in, unsigned char *cpage_out, __u32 srclen, __u32 destlen);
 
 
 /* jffs2_compress:
@@ -58,33 +69,31 @@
  * *datalen accordingly to show the amount of data which were compressed.
  */
 unsigned char jffs2_compress(unsigned char *data_in, unsigned char *cpage_out, 
-		    uint32_t *datalen, uint32_t *cdatalen)
+		    __u32 *datalen, __u32 *cdatalen)
 {
 	int ret;
 
-	ret = jffs2_zlib_compress(data_in, cpage_out, datalen, cdatalen);
+	ret = zlib_compress(data_in, cpage_out, datalen, cdatalen);
 	if (!ret) {
 		return JFFS2_COMPR_ZLIB;
 	}
 #if 0 /* Disabled 23/9/1. With zlib it hardly ever gets a look in */
-	ret = jffs2_dynrubin_compress(data_in, cpage_out, datalen, cdatalen);
+	ret = dynrubin_compress(data_in, cpage_out, datalen, cdatalen);
 	if (!ret) {
 		return JFFS2_COMPR_DYNRUBIN;
 	}
 #endif
 #if 0 /* Disabled 26/2/1. Obsoleted by dynrubin */
-	ret = jffs2_rubinmips_compress(data_in, cpage_out, datalen, cdatalen);
+	ret = rubinmips_compress(data_in, cpage_out, datalen, cdatalen);
 	if (!ret) {
 		return JFFS2_COMPR_RUBINMIPS;
 	}
 #endif
-#ifndef CONFIG_ARCH_SHARP_SL
 	/* rtime does manage to recompress already-compressed data */
-	ret = jffs2_rtime_compress(data_in, cpage_out, datalen, cdatalen);
+	ret = rtime_compress(data_in, cpage_out, datalen, cdatalen);
 	if (!ret) {
 		return JFFS2_COMPR_RTIME;
 	}
-#endif
 #if 0
 	/* We don't need to copy. Let the caller special-case the COMPR_NONE case. */
 	/* If we get here, no compression is going to work */
@@ -99,7 +108,7 @@
 
 
 int jffs2_decompress(unsigned char comprtype, unsigned char *cdata_in, 
-		     unsigned char *data_out, uint32_t cdatalen, uint32_t datalen)
+		     unsigned char *data_out, __u32 cdatalen, __u32 datalen)
 {
 	switch (comprtype) {
 	case JFFS2_COMPR_NONE:
@@ -112,23 +121,23 @@
 		break;
 
 	case JFFS2_COMPR_ZLIB:
-		jffs2_zlib_decompress(cdata_in, data_out, cdatalen, datalen);
+		zlib_decompress(cdata_in, data_out, cdatalen, datalen);
 		break;
 
 	case JFFS2_COMPR_RTIME:
-		jffs2_rtime_decompress(cdata_in, data_out, cdatalen, datalen);
+		rtime_decompress(cdata_in, data_out, cdatalen, datalen);
 		break;
 
 	case JFFS2_COMPR_RUBINMIPS:
 #if 0 /* Disabled 23/9/1 */
-		jffs2_rubinmips_decompress(cdata_in, data_out, cdatalen, datalen);
+		rubinmips_decompress(cdata_in, data_out, cdatalen, datalen);
 #else
 		printk(KERN_WARNING "JFFS2: Rubinmips compression encountered but support not compiled in!\n");
 #endif
 		break;
 	case JFFS2_COMPR_DYNRUBIN:
 #if 1 /* Phase this one out */
-		jffs2_dynrubin_decompress(cdata_in, data_out, cdatalen, datalen);
+		dynrubin_decompress(cdata_in, data_out, cdatalen, datalen);
 #else
 		printk(KERN_WARNING "JFFS2: Dynrubin compression encountered but support not compiled in!\n");
 #endif
diff -Nur linux/fs/jffs2/compr_rtime.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compr_rtime.c
--- linux/fs/jffs2/compr_rtime.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compr_rtime.c	2003-06-23 01:47:03.000000000 +0700
@@ -1,13 +1,37 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
+ * Copyright (C) 2001 Red Hat, Inc.
  *
  * Created by Arjan van de Ven <arjanv@redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: compr_rtime.c,v 1.9 2002/05/20 14:56:37 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: compr_rtime.c,v 1.5 2001/03/15 15:38:23 dwmw2 Exp $
  *
  *
  * Very simple lz77-ish encoder.
@@ -19,9 +43,6 @@
  *
  * The algorithm is intended to only send "whole bytes", no bit-messing.
  *
- * ChangeLog:
- *     20-Nov-2002 Lineo Japan, Inc.  don't choose rtime compressor
- *
  */
 
 #include <linux/kernel.h>
@@ -29,10 +50,9 @@
 #include <linux/errno.h>
 #include <linux/string.h> 
 
-#ifndef CONFIG_ARCH_SHARP_SL
 /* _compress returns the compressed size, -1 if bigger */
-int jffs2_rtime_compress(unsigned char *data_in, unsigned char *cpage_out, 
-		   uint32_t *sourcelen, uint32_t *dstlen)
+int rtime_compress(unsigned char *data_in, unsigned char *cpage_out, 
+		   __u32 *sourcelen, __u32 *dstlen)
 {
 	int positions[256];
 	int outpos = 0;
@@ -69,11 +89,10 @@
 	*dstlen = outpos;
 	return 0;
 }		   
-#endif
 
 
-void jffs2_rtime_decompress(unsigned char *data_in, unsigned char *cpage_out,
-		      uint32_t srclen, uint32_t destlen)
+void rtime_decompress(unsigned char *data_in, unsigned char *cpage_out,
+		      __u32 srclen, __u32 destlen)
 {
 	int positions[256];
 	int outpos = 0;
diff -Nur linux/fs/jffs2/compr_rubin.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compr_rubin.c
--- linux/fs/jffs2/compr_rubin.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compr_rubin.c	2003-06-23 01:47:03.000000000 +0700
@@ -1,13 +1,37 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
+ * Copyright (C) 2001 Red Hat, Inc.
  *
  * Created by Arjan van de Ven <arjanv@redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: compr_rubin.c,v 1.17 2002/05/20 14:56:37 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: compr_rubin.c,v 1.13 2001/09/23 10:06:05 rmk Exp $
  *
  */
 
@@ -19,7 +43,7 @@
 
 
 
-static void init_rubin(struct rubin_state *rs, int div, int *bits)
+void init_rubin(struct rubin_state *rs, int div, int *bits)
 {	
 	int c;
 
@@ -32,7 +56,7 @@
 }
 
 
-static int encode(struct rubin_state *rs, long A, long B, int symbol)
+int encode(struct rubin_state *rs, long A, long B, int symbol)
 {
 
 	long i0, i1;
@@ -67,7 +91,7 @@
 }
 
 
-static void end_rubin(struct rubin_state *rs)
+void end_rubin(struct rubin_state *rs)
 {				
 
 	int i;
@@ -80,7 +104,7 @@
 }
 
 
-static void init_decode(struct rubin_state *rs, int div, int *bits)
+void init_decode(struct rubin_state *rs, int div, int *bits)
 {
 	init_rubin(rs, div, bits);		
 
@@ -127,7 +151,7 @@
 	rs->rec_q = rec_q;
 }
 
-static int decode(struct rubin_state *rs, long A, long B)
+int decode(struct rubin_state *rs, long A, long B)
 {
 	unsigned long p = rs->p, q = rs->q;
 	long i0, threshold;
@@ -188,8 +212,8 @@
 
 
 
-static int rubin_do_compress(int bit_divider, int *bits, unsigned char *data_in, 
-		      unsigned char *cpage_out, uint32_t *sourcelen, uint32_t *dstlen)
+int rubin_do_compress(int bit_divider, int *bits, unsigned char *data_in, 
+		      unsigned char *cpage_out, __u32 *sourcelen, __u32 *dstlen)
 	{
 	int outpos = 0;
 	int pos=0;
@@ -222,20 +246,20 @@
 }		   
 #if 0
 /* _compress returns the compressed size, -1 if bigger */
-int jffs2_rubinmips_compress(unsigned char *data_in, unsigned char *cpage_out, 
-		   uint32_t *sourcelen, uint32_t *dstlen)
+int rubinmips_compress(unsigned char *data_in, unsigned char *cpage_out, 
+		   __u32 *sourcelen, __u32 *dstlen)
 {
 	return rubin_do_compress(BIT_DIVIDER_MIPS, bits_mips, data_in, cpage_out, sourcelen, dstlen);
 }
 #endif
-int jffs2_dynrubin_compress(unsigned char *data_in, unsigned char *cpage_out, 
-		   uint32_t *sourcelen, uint32_t *dstlen)
+int dynrubin_compress(unsigned char *data_in, unsigned char *cpage_out, 
+		   __u32 *sourcelen, __u32 *dstlen)
 {
 	int bits[8];
 	unsigned char histo[256];
 	int i;
 	int ret;
-	uint32_t mysrclen, mydstlen;
+	__u32 mysrclen, mydstlen;
 
 	mysrclen = *sourcelen;
 	mydstlen = *dstlen - 8;
@@ -291,8 +315,8 @@
 	return 0;
 }
 
-static void rubin_do_decompress(int bit_divider, int *bits, unsigned char *cdata_in, 
-			 unsigned char *page_out, uint32_t srclen, uint32_t destlen)
+void rubin_do_decompress(int bit_divider, int *bits, unsigned char *cdata_in, 
+			 unsigned char *page_out, __u32 srclen, __u32 destlen)
 {
 	int outpos = 0;
 	struct rubin_state rs;
@@ -306,14 +330,14 @@
 }		   
 
 
-void jffs2_rubinmips_decompress(unsigned char *data_in, unsigned char *cpage_out, 
-		   uint32_t sourcelen, uint32_t dstlen)
+void rubinmips_decompress(unsigned char *data_in, unsigned char *cpage_out, 
+		   __u32 sourcelen, __u32 dstlen)
 {
 	rubin_do_decompress(BIT_DIVIDER_MIPS, bits_mips, data_in, cpage_out, sourcelen, dstlen);
 }
 
-void jffs2_dynrubin_decompress(unsigned char *data_in, unsigned char *cpage_out, 
-		   uint32_t sourcelen, uint32_t dstlen)
+void dynrubin_decompress(unsigned char *data_in, unsigned char *cpage_out, 
+		   __u32 sourcelen, __u32 dstlen)
 {
 	int bits[8];
 	int c;
diff -Nur linux/fs/jffs2/compr_rubin.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compr_rubin.h
--- linux/fs/jffs2/compr_rubin.h	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compr_rubin.h	2003-06-23 01:47:03.000000000 +0700
@@ -1,7 +1,7 @@
 /* Rubin encoder/decoder header       */
 /* work started at   : aug   3, 1994  */
 /* last modification : aug  15, 1994  */
-/* $Id: compr_rubin.h,v 1.6 2002/01/25 01:49:26 dwmw2 Exp $ */
+/* $Id: compr_rubin.h,v 1.5 2001/02/26 13:50:01 dwmw2 Exp $ */
 
 #include "pushpull.h"
 
@@ -19,3 +19,10 @@
 	int bit_divider;
 	int bits[8];
 };
+
+
+void init_rubin (struct rubin_state *rs, int div, int *bits);
+int encode (struct rubin_state *, long, long, int);
+void end_rubin (struct rubin_state *);
+void init_decode (struct rubin_state *, int div, int *bits);
+int decode (struct rubin_state *, long, long);
diff -Nur linux/fs/jffs2/compr_zlib.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compr_zlib.c
--- linux/fs/jffs2/compr_zlib.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compr_zlib.c	2003-06-23 01:47:03.000000000 +0700
@@ -1,28 +1,72 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
+ * Copyright (C) 2001 Red Hat, Inc.
  *
  * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: compr_zlib.c,v 1.18 2002/05/20 14:56:37 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: compr_zlib.c,v 1.8 2001/09/20 15:28:31 dwmw2 Exp $
  *
  */
 
-#ifndef __KERNEL__
-#error "The userspace support got too messy and was removed. Update your mkfs.jffs2"
-#endif
+#include "zlib.h"
 
-#include <linux/config.h>
+#ifdef __KERNEL__
 #include <linux/kernel.h>
 #include <linux/mtd/compatmac.h> /* for min() */
 #include <linux/slab.h>
 #include <linux/jffs2.h>
-#include <linux/zlib.h>
 #include "nodelist.h"
 
+static void *zalloc(void *opaque, unsigned nr, unsigned size)
+{
+	/* How much does it request? Should we use vmalloc? Or be dynamic? */
+	return kmalloc(nr * size, GFP_KERNEL);
+}
+
+static void zfree(void *opaque, void *addr)
+{
+	kfree(addr);
+}
+#else
+#define min(x,y) ((x)<(y)?(x):(y))
+#ifndef D1
+#define D1(x)
+#endif
+#define KERN_DEBUG
+#define KERN_NOTICE
+#define KERN_WARNING
+#define printk printf
+#include <stdio.h>
+#include <asm/types.h>
+#endif
+
 	/* Plan: call deflate() with avail_in == *sourcelen, 
 		avail_out = *dstlen - 12 and flush == Z_FINISH. 
 		If it doesn't manage to finish,	call it again with
@@ -32,37 +76,8 @@
 	*/
 #define STREAM_END_SPACE 12
 
-static DECLARE_MUTEX(deflate_sem);
-static DECLARE_MUTEX(inflate_sem);
-static void *deflate_workspace;
-static void *inflate_workspace;
-
-int __init jffs2_zlib_init(void)
-{
-	deflate_workspace = vmalloc(zlib_deflate_workspacesize());
-	if (!deflate_workspace) {
-		printk(KERN_WARNING "Failed to allocate %d bytes for deflate workspace\n", zlib_deflate_workspacesize());
-		return -ENOMEM;
-	}
-	D1(printk(KERN_DEBUG "Allocated %d bytes for deflate workspace\n", zlib_deflate_workspacesize()));
-	inflate_workspace = vmalloc(zlib_inflate_workspacesize());
-	if (!inflate_workspace) {
-		printk(KERN_WARNING "Failed to allocate %d bytes for inflate workspace\n", zlib_inflate_workspacesize());
-		vfree(deflate_workspace);
-		return -ENOMEM;
-	}
-	D1(printk(KERN_DEBUG "Allocated %d bytes for inflate workspace\n", zlib_inflate_workspacesize()));
-	return 0;
-}
-
-void jffs2_zlib_exit(void)
-{
-	vfree(deflate_workspace);
-	vfree(inflate_workspace);
-}
-
-int jffs2_zlib_compress(unsigned char *data_in, unsigned char *cpage_out, 
-		   uint32_t *sourcelen, uint32_t *dstlen)
+int zlib_compress(unsigned char *data_in, unsigned char *cpage_out, 
+		   __u32 *sourcelen, __u32 *dstlen)
 {
 	z_stream strm;
 	int ret;
@@ -70,15 +85,18 @@
 	if (*dstlen <= STREAM_END_SPACE)
 		return -1;
 
-	down(&deflate_sem);
-	strm.workspace = deflate_workspace;
+#ifdef __KERNEL__
+	strm.zalloc = zalloc;
+	strm.zfree = zfree;
+#else
+	strm.zalloc = (void *)0;
+	strm.zfree = (void *)0;
+#endif
 
-	if (Z_OK != zlib_deflateInit(&strm, 3)) {
+	if (Z_OK != deflateInit(&strm, 3)) {
 		printk(KERN_WARNING "deflateInit failed\n");
-		up(&deflate_sem);
 		return -1;
 	}
-
 	strm.next_in = data_in;
 	strm.total_in = 0;
 	
@@ -90,49 +108,52 @@
 		strm.avail_in = min((unsigned)(*sourcelen-strm.total_in), strm.avail_out);
 		D1(printk(KERN_DEBUG "calling deflate with avail_in %d, avail_out %d\n",
 			  strm.avail_in, strm.avail_out));
-		ret = zlib_deflate(&strm, Z_PARTIAL_FLUSH);
+		ret = deflate(&strm, Z_PARTIAL_FLUSH);
 		D1(printk(KERN_DEBUG "deflate returned with avail_in %d, avail_out %d, total_in %ld, total_out %ld\n", 
 			  strm.avail_in, strm.avail_out, strm.total_in, strm.total_out));
 		if (ret != Z_OK) {
 			D1(printk(KERN_DEBUG "deflate in loop returned %d\n", ret));
-			zlib_deflateEnd(&strm);
-			up(&deflate_sem);
+			deflateEnd(&strm);
 			return -1;
 		}
 	}
 	strm.avail_out += STREAM_END_SPACE;
 	strm.avail_in = 0;
-	ret = zlib_deflate(&strm, Z_FINISH);
-	zlib_deflateEnd(&strm);
-	up(&deflate_sem);
+	ret = deflate(&strm, Z_FINISH);
 	if (ret != Z_STREAM_END) {
 		D1(printk(KERN_DEBUG "final deflate returned %d\n", ret));
+		deflateEnd(&strm);
 		return -1;
 	}
+	deflateEnd(&strm);
 
-	D1(printk(KERN_DEBUG "zlib compressed %ld bytes into %ld\n",
-		  strm.total_in, strm.total_out));
+	D1(printk(KERN_DEBUG "zlib compressed %ld bytes into %ld\n", strm.total_in, strm.total_out));
 
 	if (strm.total_out >= strm.total_in)
 		return -1;
 
+
 	*dstlen = strm.total_out;
 	*sourcelen = strm.total_in;
 	return 0;
 }
 
-void jffs2_zlib_decompress(unsigned char *data_in, unsigned char *cpage_out,
-		      uint32_t srclen, uint32_t destlen)
+void zlib_decompress(unsigned char *data_in, unsigned char *cpage_out,
+		      __u32 srclen, __u32 destlen)
 {
 	z_stream strm;
 	int ret;
 
-	down(&inflate_sem);
-	strm.workspace = inflate_workspace;
+#ifdef __KERNEL__
+	strm.zalloc = zalloc;
+	strm.zfree = zfree;
+#else
+	strm.zalloc = (void *)0;
+	strm.zfree = (void *)0;
+#endif
 
-	if (Z_OK != zlib_inflateInit(&strm)) {
+	if (Z_OK != inflateInit(&strm)) {
 		printk(KERN_WARNING "inflateInit failed\n");
-		up(&inflate_sem);
 		return;
 	}
 	strm.next_in = data_in;
@@ -143,11 +164,10 @@
 	strm.avail_out = destlen;
 	strm.total_out = 0;
 
-	while((ret = zlib_inflate(&strm, Z_FINISH)) == Z_OK)
+	while((ret = inflate(&strm, Z_FINISH)) == Z_OK)
 		;
 	if (ret != Z_STREAM_END) {
 		printk(KERN_NOTICE "inflate returned %d\n", ret);
 	}
-	zlib_inflateEnd(&strm);
-	up(&inflate_sem);
+	inflateEnd(&strm);
 }
diff -Nur linux/fs/jffs2/compressors/Makefile /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/Makefile
--- linux/fs/jffs2/compressors/Makefile	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/Makefile	1970-01-01 07:00:00.000000000 +0700
@@ -1,8 +0,0 @@
-O_TARGET	:= compressors.o
-
-subdir-y	:= zlib_deflate
-subdir-y	+= zlib_inflate
-
-obj-y	:= $(join $(subdir-y),$(subdir-y:%=/%.o))
-
-include $(TOPDIR)/Rules.make
diff -Nur linux/fs/jffs2/compressors/zlib_deflate/Makefile /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_deflate/Makefile
--- linux/fs/jffs2/compressors/zlib_deflate/Makefile	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_deflate/Makefile	1970-01-01 07:00:00.000000000 +0700
@@ -1,16 +0,0 @@
-#
-# This is a modified version of zlib, which does all memory
-# allocation ahead of time.
-#
-# This is the compression code, see zlib_inflate for the
-# decompression code.
-#
-
-O_TARGET    := zlib_deflate.o
-
-export-objs := deflate_syms.o
-
-obj-y := deflate.o deftree.o deflate_syms.o
-obj-m := $(O_TARGET)
-
-include $(TOPDIR)/Rules.make
diff -Nur linux/fs/jffs2/compressors/zlib_deflate/deflate.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_deflate/deflate.c
--- linux/fs/jffs2/compressors/zlib_deflate/deflate.c	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_deflate/deflate.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,1250 +0,0 @@
-/* +++ deflate.c */
-/* deflate.c -- compress data using the deflation algorithm
- * Copyright (C) 1995-1996 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h 
- */
-
-/*
- *  ALGORITHM
- *
- *      The "deflation" process depends on being able to identify portions
- *      of the input text which are identical to earlier input (within a
- *      sliding window trailing behind the input currently being processed).
- *
- *      The most straightforward technique turns out to be the fastest for
- *      most input files: try all possible matches and select the longest.
- *      The key feature of this algorithm is that insertions into the string
- *      dictionary are very simple and thus fast, and deletions are avoided
- *      completely. Insertions are performed at each input character, whereas
- *      string matches are performed only when the previous match ends. So it
- *      is preferable to spend more time in matches to allow very fast string
- *      insertions and avoid deletions. The matching algorithm for small
- *      strings is inspired from that of Rabin & Karp. A brute force approach
- *      is used to find longer strings when a small match has been found.
- *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
- *      (by Leonid Broukhis).
- *         A previous version of this file used a more sophisticated algorithm
- *      (by Fiala and Greene) which is guaranteed to run in linear amortized
- *      time, but has a larger average cost, uses more memory and is patented.
- *      However the F&G algorithm may be faster for some highly redundant
- *      files if the parameter max_chain_length (described below) is too large.
- *
- *  ACKNOWLEDGEMENTS
- *
- *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
- *      I found it in 'freeze' written by Leonid Broukhis.
- *      Thanks to many people for bug reports and testing.
- *
- *  REFERENCES
- *
- *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
- *      Available in ftp://ds.internic.net/rfc/rfc1951.txt
- *
- *      A description of the Rabin and Karp algorithm is given in the book
- *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
- *
- *      Fiala,E.R., and Greene,D.H.
- *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
- *
- */
-
-#include <linux/module.h>
-#include <linux/zutil.h>
-#include "defutil.h"
-
-
-/* ===========================================================================
- *  Function prototypes.
- */
-typedef enum {
-    need_more,      /* block not completed, need more input or more output */
-    block_done,     /* block flush performed */
-    finish_started, /* finish started, need only more output at next deflate */
-    finish_done     /* finish done, accept no more input or output */
-} block_state;
-
-typedef block_state (*compress_func) OF((deflate_state *s, int flush));
-/* Compression function. Returns the block state after the call. */
-
-local void fill_window    OF((deflate_state *s));
-local block_state deflate_stored OF((deflate_state *s, int flush));
-local block_state deflate_fast   OF((deflate_state *s, int flush));
-local block_state deflate_slow   OF((deflate_state *s, int flush));
-local void lm_init        OF((deflate_state *s));
-local void putShortMSB    OF((deflate_state *s, uInt b));
-local void flush_pending  OF((z_streamp strm));
-local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));
-local uInt longest_match  OF((deflate_state *s, IPos cur_match));
-
-#ifdef DEBUG_ZLIB
-local  void check_match OF((deflate_state *s, IPos start, IPos match,
-                            int length));
-#endif
-
-/* ===========================================================================
- * Local data
- */
-
-#define NIL 0
-/* Tail of hash chains */
-
-#ifndef TOO_FAR
-#  define TOO_FAR 4096
-#endif
-/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
-
-#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
-/* Minimum amount of lookahead, except at the end of the input file.
- * See deflate.c for comments about the MIN_MATCH+1.
- */
-
-/* Values for max_lazy_match, good_match and max_chain_length, depending on
- * the desired pack level (0..9). The values given below have been tuned to
- * exclude worst case performance for pathological files. Better values may be
- * found for specific files.
- */
-typedef struct config_s {
-   ush good_length; /* reduce lazy search above this match length */
-   ush max_lazy;    /* do not perform lazy search above this match length */
-   ush nice_length; /* quit search above this match length */
-   ush max_chain;
-   compress_func func;
-} config;
-
-local const config configuration_table[10] = {
-/*      good lazy nice chain */
-/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
-/* 1 */ {4,    4,  8,    4, deflate_fast}, /* maximum speed, no lazy matches */
-/* 2 */ {4,    5, 16,    8, deflate_fast},
-/* 3 */ {4,    6, 32,   32, deflate_fast},
-
-/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
-/* 5 */ {8,   16, 32,   32, deflate_slow},
-/* 6 */ {8,   16, 128, 128, deflate_slow},
-/* 7 */ {8,   32, 128, 256, deflate_slow},
-/* 8 */ {32, 128, 258, 1024, deflate_slow},
-/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* maximum compression */
-
-/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
- * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
- * meaning.
- */
-
-#define EQUAL 0
-/* result of memcmp for equal strings */
-
-/* ===========================================================================
- * Update a hash value with the given input byte
- * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
- *    input characters, so that a running hash key can be computed from the
- *    previous key instead of complete recalculation each time.
- */
-#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)
-
-
-/* ===========================================================================
- * Insert string str in the dictionary and set match_head to the previous head
- * of the hash chain (the most recent string with same hash key). Return
- * the previous length of the hash chain.
- * IN  assertion: all calls to to INSERT_STRING are made with consecutive
- *    input characters and the first MIN_MATCH bytes of str are valid
- *    (except for the last MIN_MATCH-1 bytes of the input file).
- */
-#define INSERT_STRING(s, str, match_head) \
-   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
-    s->prev[(str) & s->w_mask] = match_head = s->head[s->ins_h], \
-    s->head[s->ins_h] = (Pos)(str))
-
-/* ===========================================================================
- * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
- * prev[] will be initialized on the fly.
- */
-#define CLEAR_HASH(s) \
-    s->head[s->hash_size-1] = NIL; \
-    memset((charf *)s->head, 0, (unsigned)(s->hash_size-1)*sizeof(*s->head));
-
-/* ========================================================================= */
-int zlib_deflateInit_(strm, level, version, stream_size)
-    z_streamp strm;
-    int level;
-    const char *version;
-    int stream_size;
-{
-    return zlib_deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS,
-			      DEF_MEM_LEVEL,
-			      Z_DEFAULT_STRATEGY, version, stream_size);
-    /* To do: ignore strm->next_in if we use it as window */
-}
-
-/* ========================================================================= */
-int zlib_deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
-		       version, stream_size)
-    z_streamp strm;
-    int  level;
-    int  method;
-    int  windowBits;
-    int  memLevel;
-    int  strategy;
-    const char *version;
-    int stream_size;
-{
-    deflate_state *s;
-    int noheader = 0;
-    static char* my_version = ZLIB_VERSION;
-    deflate_workspace *mem;
-
-    ushf *overlay;
-    /* We overlay pending_buf and d_buf+l_buf. This works since the average
-     * output size for (length,distance) codes is <= 24 bits.
-     */
-
-    if (version == Z_NULL || version[0] != my_version[0] ||
-        stream_size != sizeof(z_stream)) {
-	return Z_VERSION_ERROR;
-    }
-    if (strm == Z_NULL) return Z_STREAM_ERROR;
-
-    strm->msg = Z_NULL;
-
-    if (level == Z_DEFAULT_COMPRESSION) level = 6;
-
-    mem = (deflate_workspace *) strm->workspace;
-
-    if (windowBits < 0) { /* undocumented feature: suppress zlib header */
-        noheader = 1;
-        windowBits = -windowBits;
-    }
-    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
-        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
-	strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
-        return Z_STREAM_ERROR;
-    }
-    s = (deflate_state *) &(mem->deflate_memory);
-    strm->state = (struct internal_state FAR *)s;
-    s->strm = strm;
-
-    s->noheader = noheader;
-    s->w_bits = windowBits;
-    s->w_size = 1 << s->w_bits;
-    s->w_mask = s->w_size - 1;
-
-    s->hash_bits = memLevel + 7;
-    s->hash_size = 1 << s->hash_bits;
-    s->hash_mask = s->hash_size - 1;
-    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
-
-    s->window = (Bytef *) mem->window_memory;
-    s->prev   = (Posf *)  mem->prev_memory;
-    s->head   = (Posf *)  mem->head_memory;
-
-    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
-
-    overlay = (ushf *) mem->overlay_memory;
-    s->pending_buf = (uchf *) overlay;
-    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);
-
-    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
-    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
-
-    s->level = level;
-    s->strategy = strategy;
-    s->method = (Byte)method;
-
-    return zlib_deflateReset(strm);
-}
-
-/* ========================================================================= */
-int zlib_deflateSetDictionary (strm, dictionary, dictLength)
-    z_streamp strm;
-    const Bytef *dictionary;
-    uInt  dictLength;
-{
-    deflate_state *s;
-    uInt length = dictLength;
-    uInt n;
-    IPos hash_head = 0;
-
-    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL)
-	return Z_STREAM_ERROR;
-
-    s = (deflate_state *) strm->state;
-    if (s->status != INIT_STATE) return Z_STREAM_ERROR;
-
-    strm->adler = zlib_adler32(strm->adler, dictionary, dictLength);
-
-    if (length < MIN_MATCH) return Z_OK;
-    if (length > MAX_DIST(s)) {
-	length = MAX_DIST(s);
-#ifndef USE_DICT_HEAD
-	dictionary += dictLength - length; /* use the tail of the dictionary */
-#endif
-    }
-    memcpy((charf *)s->window, dictionary, length);
-    s->strstart = length;
-    s->block_start = (long)length;
-
-    /* Insert all strings in the hash table (except for the last two bytes).
-     * s->lookahead stays null, so s->ins_h will be recomputed at the next
-     * call of fill_window.
-     */
-    s->ins_h = s->window[0];
-    UPDATE_HASH(s, s->ins_h, s->window[1]);
-    for (n = 0; n <= length - MIN_MATCH; n++) {
-	INSERT_STRING(s, n, hash_head);
-    }
-    if (hash_head) hash_head = 0;  /* to make compiler happy */
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int zlib_deflateReset (strm)
-    z_streamp strm;
-{
-    deflate_state *s;
-    
-    if (strm == Z_NULL || strm->state == Z_NULL)
-        return Z_STREAM_ERROR;
-
-    strm->total_in = strm->total_out = 0;
-    strm->msg = Z_NULL;
-    strm->data_type = Z_UNKNOWN;
-
-    s = (deflate_state *)strm->state;
-    s->pending = 0;
-    s->pending_out = s->pending_buf;
-
-    if (s->noheader < 0) {
-        s->noheader = 0; /* was set to -1 by deflate(..., Z_FINISH); */
-    }
-    s->status = s->noheader ? BUSY_STATE : INIT_STATE;
-    strm->adler = 1;
-    s->last_flush = Z_NO_FLUSH;
-
-    zlib_tr_init(s);
-    lm_init(s);
-
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int zlib_deflateParams(strm, level, strategy)
-    z_streamp strm;
-    int level;
-    int strategy;
-{
-    deflate_state *s;
-    compress_func func;
-    int err = Z_OK;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    s = (deflate_state *) strm->state;
-
-    if (level == Z_DEFAULT_COMPRESSION) {
-	level = 6;
-    }
-    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
-	return Z_STREAM_ERROR;
-    }
-    func = configuration_table[s->level].func;
-
-    if (func != configuration_table[level].func && strm->total_in != 0) {
-	/* Flush the last buffer: */
-	err = zlib_deflate(strm, Z_PARTIAL_FLUSH);
-    }
-    if (s->level != level) {
-	s->level = level;
-	s->max_lazy_match   = configuration_table[level].max_lazy;
-	s->good_match       = configuration_table[level].good_length;
-	s->nice_match       = configuration_table[level].nice_length;
-	s->max_chain_length = configuration_table[level].max_chain;
-    }
-    s->strategy = strategy;
-    return err;
-}
-
-/* =========================================================================
- * Put a short in the pending buffer. The 16-bit value is put in MSB order.
- * IN assertion: the stream state is correct and there is enough room in
- * pending_buf.
- */
-local void putShortMSB (s, b)
-    deflate_state *s;
-    uInt b;
-{
-    put_byte(s, (Byte)(b >> 8));
-    put_byte(s, (Byte)(b & 0xff));
-}   
-
-/* =========================================================================
- * Flush as much pending output as possible. All deflate() output goes
- * through this function so some applications may wish to modify it
- * to avoid allocating a large strm->next_out buffer and copying into it.
- * (See also read_buf()).
- */
-local void flush_pending(strm)
-    z_streamp strm;
-{
-    deflate_state *s = (deflate_state *) strm->state;
-    unsigned len = s->pending;
-
-    if (len > strm->avail_out) len = strm->avail_out;
-    if (len == 0) return;
-
-    if (strm->next_out != Z_NULL) {
-	memcpy(strm->next_out, s->pending_out, len);
-	strm->next_out += len;
-    }
-    s->pending_out += len;
-    strm->total_out += len;
-    strm->avail_out  -= len;
-    s->pending -= len;
-    if (s->pending == 0) {
-        s->pending_out = s->pending_buf;
-    }
-}
-
-/* ========================================================================= */
-int zlib_deflate (strm, flush)
-    z_streamp strm;
-    int flush;
-{
-    int old_flush; /* value of flush param for previous deflate call */
-    deflate_state *s;
-
-    if (strm == Z_NULL || strm->state == Z_NULL ||
-	flush > Z_FINISH || flush < 0) {
-        return Z_STREAM_ERROR;
-    }
-    s = (deflate_state *) strm->state;
-
-    if ((strm->next_in == Z_NULL && strm->avail_in != 0) ||
-	(s->status == FINISH_STATE && flush != Z_FINISH)) {
-        return Z_STREAM_ERROR;
-    }
-    if (strm->avail_out == 0) return Z_BUF_ERROR;
-
-    s->strm = strm; /* just in case */
-    old_flush = s->last_flush;
-    s->last_flush = flush;
-
-    /* Write the zlib header */
-    if (s->status == INIT_STATE) {
-
-        uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
-        uInt level_flags = (s->level-1) >> 1;
-
-        if (level_flags > 3) level_flags = 3;
-        header |= (level_flags << 6);
-	if (s->strstart != 0) header |= PRESET_DICT;
-        header += 31 - (header % 31);
-
-        s->status = BUSY_STATE;
-        putShortMSB(s, header);
-
-	/* Save the adler32 of the preset dictionary: */
-	if (s->strstart != 0) {
-	    putShortMSB(s, (uInt)(strm->adler >> 16));
-	    putShortMSB(s, (uInt)(strm->adler & 0xffff));
-	}
-	strm->adler = 1L;
-    }
-
-    /* Flush as much pending output as possible */
-    if (s->pending != 0) {
-        flush_pending(strm);
-        if (strm->avail_out == 0) {
-	    /* Since avail_out is 0, deflate will be called again with
-	     * more output space, but possibly with both pending and
-	     * avail_in equal to zero. There won't be anything to do,
-	     * but this is not an error situation so make sure we
-	     * return OK instead of BUF_ERROR at next call of deflate:
-             */
-	    s->last_flush = -1;
-	    return Z_OK;
-	}
-
-    /* Make sure there is something to do and avoid duplicate consecutive
-     * flushes. For repeated and useless calls with Z_FINISH, we keep
-     * returning Z_STREAM_END instead of Z_BUFF_ERROR.
-     */
-    } else if (strm->avail_in == 0 && flush <= old_flush &&
-	       flush != Z_FINISH) {
-        return Z_BUF_ERROR;
-    }
-
-    /* User must not provide more input after the first FINISH: */
-    if (s->status == FINISH_STATE && strm->avail_in != 0) {
-        return Z_BUF_ERROR;
-    }
-
-    /* Start a new block or continue the current one.
-     */
-    if (strm->avail_in != 0 || s->lookahead != 0 ||
-        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
-        block_state bstate;
-
-	bstate = (*(configuration_table[s->level].func))(s, flush);
-
-        if (bstate == finish_started || bstate == finish_done) {
-            s->status = FINISH_STATE;
-        }
-        if (bstate == need_more || bstate == finish_started) {
-	    if (strm->avail_out == 0) {
-	        s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
-	    }
-	    return Z_OK;
-	    /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
-	     * of deflate should use the same flush parameter to make sure
-	     * that the flush is complete. So we don't have to output an
-	     * empty block here, this will be done at next call. This also
-	     * ensures that for a very small output buffer, we emit at most
-	     * one empty block.
-	     */
-	}
-        if (bstate == block_done) {
-            if (flush == Z_PARTIAL_FLUSH) {
-                zlib_tr_align(s);
-	    } else if (flush == Z_PACKET_FLUSH) {
-		/* Output just the 3-bit `stored' block type value,
-		   but not a zero length. */
-		zlib_tr_stored_type_only(s);
-            } else { /* FULL_FLUSH or SYNC_FLUSH */
-                zlib_tr_stored_block(s, (char*)0, 0L, 0);
-                /* For a full flush, this empty block will be recognized
-                 * as a special marker by inflate_sync().
-                 */
-                if (flush == Z_FULL_FLUSH) {
-                    CLEAR_HASH(s);             /* forget history */
-                }
-            }
-            flush_pending(strm);
-	    if (strm->avail_out == 0) {
-	      s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
-	      return Z_OK;
-	    }
-        }
-    }
-    Assert(strm->avail_out > 0, "bug2");
-
-    if (flush != Z_FINISH) return Z_OK;
-    if (s->noheader) return Z_STREAM_END;
-
-    /* Write the zlib trailer (adler32) */
-    putShortMSB(s, (uInt)(strm->adler >> 16));
-    putShortMSB(s, (uInt)(strm->adler & 0xffff));
-    flush_pending(strm);
-    /* If avail_out is zero, the application will call deflate again
-     * to flush the rest.
-     */
-    s->noheader = -1; /* write the trailer only once! */
-    return s->pending != 0 ? Z_OK : Z_STREAM_END;
-}
-
-/* ========================================================================= */
-int zlib_deflateEnd (strm)
-    z_streamp strm;
-{
-    int status;
-    deflate_state *s;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    s = (deflate_state *) strm->state;
-
-    status = s->status;
-    if (status != INIT_STATE && status != BUSY_STATE &&
-	status != FINISH_STATE) {
-      return Z_STREAM_ERROR;
-    }
-
-    strm->state = Z_NULL;
-
-    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
-}
-
-/* =========================================================================
- * Copy the source state to the destination state.
- */
-int zlib_deflateCopy (dest, source)
-    z_streamp dest;
-    z_streamp source;
-{
-#ifdef MAXSEG_64K
-    return Z_STREAM_ERROR;
-#else
-    deflate_state *ds;
-    deflate_state *ss;
-    ushf *overlay;
-    deflate_workspace *mem;
-
-
-    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
-        return Z_STREAM_ERROR;
-    }
-
-    ss = (deflate_state *) source->state;
-
-    *dest = *source;
-
-    mem = (deflate_workspace *) dest->workspace;
-
-    ds = &(mem->deflate_memory);
-
-    dest->state = (struct internal_state FAR *) ds;
-    *ds = *ss;
-    ds->strm = dest;
-
-    ds->window = (Bytef *) mem->window_memory;
-    ds->prev   = (Posf *)  mem->prev_memory;
-    ds->head   = (Posf *)  mem->head_memory;
-    overlay = (ushf *) mem->overlay_memory;
-    ds->pending_buf = (uchf *) overlay;
-
-    memcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
-    memcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));
-    memcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));
-    memcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);
-
-    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
-    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
-    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;
-
-    ds->l_desc.dyn_tree = ds->dyn_ltree;
-    ds->d_desc.dyn_tree = ds->dyn_dtree;
-    ds->bl_desc.dyn_tree = ds->bl_tree;
-
-    return Z_OK;
-#endif
-}
-
-/* ===========================================================================
- * Read a new buffer from the current input stream, update the adler32
- * and total number of bytes read.  All deflate() input goes through
- * this function so some applications may wish to modify it to avoid
- * allocating a large strm->next_in buffer and copying from it.
- * (See also flush_pending()).
- */
-local int read_buf(strm, buf, size)
-    z_streamp strm;
-    Bytef *buf;
-    unsigned size;
-{
-    unsigned len = strm->avail_in;
-
-    if (len > size) len = size;
-    if (len == 0) return 0;
-
-    strm->avail_in  -= len;
-
-    if (!((deflate_state *)(strm->state))->noheader) {
-        strm->adler = zlib_adler32(strm->adler, strm->next_in, len);
-    }
-    memcpy(buf, strm->next_in, len);
-    strm->next_in  += len;
-    strm->total_in += len;
-
-    return (int)len;
-}
-
-/* ===========================================================================
- * Initialize the "longest match" routines for a new zlib stream
- */
-local void lm_init (s)
-    deflate_state *s;
-{
-    s->window_size = (ulg)2L*s->w_size;
-
-    CLEAR_HASH(s);
-
-    /* Set the default configuration parameters:
-     */
-    s->max_lazy_match   = configuration_table[s->level].max_lazy;
-    s->good_match       = configuration_table[s->level].good_length;
-    s->nice_match       = configuration_table[s->level].nice_length;
-    s->max_chain_length = configuration_table[s->level].max_chain;
-
-    s->strstart = 0;
-    s->block_start = 0L;
-    s->lookahead = 0;
-    s->match_length = s->prev_length = MIN_MATCH-1;
-    s->match_available = 0;
-    s->ins_h = 0;
-}
-
-/* ===========================================================================
- * Set match_start to the longest match starting at the given string and
- * return its length. Matches shorter or equal to prev_length are discarded,
- * in which case the result is equal to prev_length and match_start is
- * garbage.
- * IN assertions: cur_match is the head of the hash chain for the current
- *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
- * OUT assertion: the match length is not greater than s->lookahead.
- */
-/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
- * match.S. The code will be functionally equivalent.
- */
-local uInt longest_match(s, cur_match)
-    deflate_state *s;
-    IPos cur_match;                             /* current match */
-{
-    unsigned chain_length = s->max_chain_length;/* max hash chain length */
-    register Bytef *scan = s->window + s->strstart; /* current string */
-    register Bytef *match;                       /* matched string */
-    register int len;                           /* length of current match */
-    int best_len = s->prev_length;              /* best match length so far */
-    int nice_match = s->nice_match;             /* stop if match long enough */
-    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
-        s->strstart - (IPos)MAX_DIST(s) : NIL;
-    /* Stop when cur_match becomes <= limit. To simplify the code,
-     * we prevent matches with the string of window index 0.
-     */
-    Posf *prev = s->prev;
-    uInt wmask = s->w_mask;
-
-#ifdef UNALIGNED_OK
-    /* Compare two bytes at a time. Note: this is not always beneficial.
-     * Try with and without -DUNALIGNED_OK to check.
-     */
-    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
-    register ush scan_start = *(ushf*)scan;
-    register ush scan_end   = *(ushf*)(scan+best_len-1);
-#else
-    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
-    register Byte scan_end1  = scan[best_len-1];
-    register Byte scan_end   = scan[best_len];
-#endif
-
-    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
-     * It is easy to get rid of this optimization if necessary.
-     */
-    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
-
-    /* Do not waste too much time if we already have a good match: */
-    if (s->prev_length >= s->good_match) {
-        chain_length >>= 2;
-    }
-    /* Do not look for matches beyond the end of the input. This is necessary
-     * to make deflate deterministic.
-     */
-    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
-
-    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
-
-    do {
-        Assert(cur_match < s->strstart, "no future");
-        match = s->window + cur_match;
-
-        /* Skip to next match if the match length cannot increase
-         * or if the match length is less than 2:
-         */
-#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
-        /* This code assumes sizeof(unsigned short) == 2. Do not use
-         * UNALIGNED_OK if your compiler uses a different size.
-         */
-        if (*(ushf*)(match+best_len-1) != scan_end ||
-            *(ushf*)match != scan_start) continue;
-
-        /* It is not necessary to compare scan[2] and match[2] since they are
-         * always equal when the other bytes match, given that the hash keys
-         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
-         * strstart+3, +5, ... up to strstart+257. We check for insufficient
-         * lookahead only every 4th comparison; the 128th check will be made
-         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
-         * necessary to put more guard bytes at the end of the window, or
-         * to check more often for insufficient lookahead.
-         */
-        Assert(scan[2] == match[2], "scan[2]?");
-        scan++, match++;
-        do {
-        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 scan < strend);
-        /* The funny "do {}" generates better code on most compilers */
-
-        /* Here, scan <= window+strstart+257 */
-        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
-        if (*scan == *match) scan++;
-
-        len = (MAX_MATCH - 1) - (int)(strend-scan);
-        scan = strend - (MAX_MATCH-1);
-
-#else /* UNALIGNED_OK */
-
-        if (match[best_len]   != scan_end  ||
-            match[best_len-1] != scan_end1 ||
-            *match            != *scan     ||
-            *++match          != scan[1])      continue;
-
-        /* The check at best_len-1 can be removed because it will be made
-         * again later. (This heuristic is not always a win.)
-         * It is not necessary to compare scan[2] and match[2] since they
-         * are always equal when the other bytes match, given that
-         * the hash keys are equal and that HASH_BITS >= 8.
-         */
-        scan += 2, match++;
-        Assert(*scan == *match, "match[2]?");
-
-        /* We check for insufficient lookahead only every 8th comparison;
-         * the 256th check will be made at strstart+258.
-         */
-        do {
-        } while (*++scan == *++match && *++scan == *++match &&
-                 *++scan == *++match && *++scan == *++match &&
-                 *++scan == *++match && *++scan == *++match &&
-                 *++scan == *++match && *++scan == *++match &&
-                 scan < strend);
-
-        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
-
-        len = MAX_MATCH - (int)(strend - scan);
-        scan = strend - MAX_MATCH;
-
-#endif /* UNALIGNED_OK */
-
-        if (len > best_len) {
-            s->match_start = cur_match;
-            best_len = len;
-            if (len >= nice_match) break;
-#ifdef UNALIGNED_OK
-            scan_end = *(ushf*)(scan+best_len-1);
-#else
-            scan_end1  = scan[best_len-1];
-            scan_end   = scan[best_len];
-#endif
-        }
-    } while ((cur_match = prev[cur_match & wmask]) > limit
-             && --chain_length != 0);
-
-    if ((uInt)best_len <= s->lookahead) return best_len;
-    return s->lookahead;
-}
-
-#ifdef DEBUG_ZLIB
-/* ===========================================================================
- * Check that the match at match_start is indeed a match.
- */
-local void check_match(s, start, match, length)
-    deflate_state *s;
-    IPos start, match;
-    int length;
-{
-    /* check that the match is indeed a match */
-    if (memcmp((charf *)s->window + match,
-                (charf *)s->window + start, length) != EQUAL) {
-        fprintf(stderr, " start %u, match %u, length %d\n",
-		start, match, length);
-        do {
-	    fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
-	} while (--length != 0);
-        z_error("invalid match");
-    }
-    if (z_verbose > 1) {
-        fprintf(stderr,"\\[%d,%d]", start-match, length);
-        do { putc(s->window[start++], stderr); } while (--length != 0);
-    }
-}
-#else
-#  define check_match(s, start, match, length)
-#endif
-
-/* ===========================================================================
- * Fill the window when the lookahead becomes insufficient.
- * Updates strstart and lookahead.
- *
- * IN assertion: lookahead < MIN_LOOKAHEAD
- * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
- *    At least one byte has been read, or avail_in == 0; reads are
- *    performed for at least two bytes (required for the zip translate_eol
- *    option -- not supported here).
- */
-local void fill_window(s)
-    deflate_state *s;
-{
-    register unsigned n, m;
-    register Posf *p;
-    unsigned more;    /* Amount of free space at the end of the window. */
-    uInt wsize = s->w_size;
-
-    do {
-        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
-
-        /* Deal with !@#$% 64K limit: */
-        if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
-            more = wsize;
-
-        } else if (more == (unsigned)(-1)) {
-            /* Very unlikely, but possible on 16 bit machine if strstart == 0
-             * and lookahead == 1 (input done one byte at time)
-             */
-            more--;
-
-        /* If the window is almost full and there is insufficient lookahead,
-         * move the upper half to the lower one to make room in the upper half.
-         */
-        } else if (s->strstart >= wsize+MAX_DIST(s)) {
-
-            memcpy((charf *)s->window, (charf *)s->window+wsize,
-                   (unsigned)wsize);
-            s->match_start -= wsize;
-            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
-            s->block_start -= (long) wsize;
-
-            /* Slide the hash table (could be avoided with 32 bit values
-               at the expense of memory usage). We slide even when level == 0
-               to keep the hash table consistent if we switch back to level > 0
-               later. (Using level 0 permanently is not an optimal usage of
-               zlib, so we don't care about this pathological case.)
-             */
-            n = s->hash_size;
-            p = &s->head[n];
-            do {
-                m = *--p;
-                *p = (Pos)(m >= wsize ? m-wsize : NIL);
-            } while (--n);
-
-            n = wsize;
-            p = &s->prev[n];
-            do {
-                m = *--p;
-                *p = (Pos)(m >= wsize ? m-wsize : NIL);
-                /* If n is not on any hash chain, prev[n] is garbage but
-                 * its value will never be used.
-                 */
-            } while (--n);
-            more += wsize;
-        }
-        if (s->strm->avail_in == 0) return;
-
-        /* If there was no sliding:
-         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
-         *    more == window_size - lookahead - strstart
-         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
-         * => more >= window_size - 2*WSIZE + 2
-         * In the BIG_MEM or MMAP case (not yet supported),
-         *   window_size == input_size + MIN_LOOKAHEAD  &&
-         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
-         * Otherwise, window_size == 2*WSIZE so more >= 2.
-         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
-         */
-        Assert(more >= 2, "more < 2");
-
-        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
-        s->lookahead += n;
-
-        /* Initialize the hash value now that we have some input: */
-        if (s->lookahead >= MIN_MATCH) {
-            s->ins_h = s->window[s->strstart];
-            UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
-#if MIN_MATCH != 3
-            Call UPDATE_HASH() MIN_MATCH-3 more times
-#endif
-        }
-        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
-         * but this is not important since only literal bytes will be emitted.
-         */
-
-    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
-}
-
-/* ===========================================================================
- * Flush the current block, with given end-of-file flag.
- * IN assertion: strstart is set to the end of the current match.
- */
-#define FLUSH_BLOCK_ONLY(s, eof) { \
-   zlib_tr_flush_block(s, (s->block_start >= 0L ? \
-                   (charf *)&s->window[(unsigned)s->block_start] : \
-                   (charf *)Z_NULL), \
-		(ulg)((long)s->strstart - s->block_start), \
-		(eof)); \
-   s->block_start = s->strstart; \
-   flush_pending(s->strm); \
-   Tracev((stderr,"[FLUSH]")); \
-}
-
-/* Same but force premature exit if necessary. */
-#define FLUSH_BLOCK(s, eof) { \
-   FLUSH_BLOCK_ONLY(s, eof); \
-   if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \
-}
-
-/* ===========================================================================
- * Copy without compression as much as possible from the input stream, return
- * the current block state.
- * This function does not insert new strings in the dictionary since
- * uncompressible data is probably not useful. This function is used
- * only for the level=0 compression option.
- * NOTE: this function should be optimized to avoid extra copying from
- * window to pending_buf.
- */
-local block_state deflate_stored(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
-     * to pending_buf_size, and each stored block has a 5 byte header:
-     */
-    ulg max_block_size = 0xffff;
-    ulg max_start;
-
-    if (max_block_size > s->pending_buf_size - 5) {
-        max_block_size = s->pending_buf_size - 5;
-    }
-
-    /* Copy as much as possible from input to output: */
-    for (;;) {
-        /* Fill the window as much as possible: */
-        if (s->lookahead <= 1) {
-
-            Assert(s->strstart < s->w_size+MAX_DIST(s) ||
-		   s->block_start >= (long)s->w_size, "slide too late");
-
-            fill_window(s);
-            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;
-
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-	Assert(s->block_start >= 0L, "block gone");
-
-	s->strstart += s->lookahead;
-	s->lookahead = 0;
-
-	/* Emit a stored block if pending_buf will be full: */
- 	max_start = s->block_start + max_block_size;
-        if (s->strstart == 0 || (ulg)s->strstart >= max_start) {
-	    /* strstart == 0 is possible when wraparound on 16-bit machine */
-	    s->lookahead = (uInt)(s->strstart - max_start);
-	    s->strstart = (uInt)max_start;
-            FLUSH_BLOCK(s, 0);
-	}
-	/* Flush if we may have to slide, otherwise block_start may become
-         * negative and the data will be gone:
-         */
-        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
-            FLUSH_BLOCK(s, 0);
-	}
-    }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
-    return flush == Z_FINISH ? finish_done : block_done;
-}
-
-/* ===========================================================================
- * Compress as much as possible from the input stream, return the current
- * block state.
- * This function does not perform lazy evaluation of matches and inserts
- * new strings in the dictionary only for unmatched strings or for short
- * matches. It is used only for the fast compression options.
- */
-local block_state deflate_fast(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    IPos hash_head = NIL; /* head of the hash chain */
-    int bflush;           /* set if current block must be flushed */
-
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the next match, plus MIN_MATCH bytes to insert the
-         * string following the next match.
-         */
-        if (s->lookahead < MIN_LOOKAHEAD) {
-            fill_window(s);
-            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
-	        return need_more;
-	    }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-
-        /* Insert the string window[strstart .. strstart+2] in the
-         * dictionary, and set hash_head to the head of the hash chain:
-         */
-        if (s->lookahead >= MIN_MATCH) {
-            INSERT_STRING(s, s->strstart, hash_head);
-        }
-
-        /* Find the longest match, discarding those <= prev_length.
-         * At this point we have always match_length < MIN_MATCH
-         */
-        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
-            /* To simplify the code, we prevent matches with the string
-             * of window index 0 (in particular we have to avoid a match
-             * of the string with itself at the start of the input file).
-             */
-            if (s->strategy != Z_HUFFMAN_ONLY) {
-                s->match_length = longest_match (s, hash_head);
-            }
-            /* longest_match() sets match_start */
-        }
-        if (s->match_length >= MIN_MATCH) {
-            check_match(s, s->strstart, s->match_start, s->match_length);
-
-            bflush = zlib_tr_tally(s, s->strstart - s->match_start,
-                               s->match_length - MIN_MATCH);
-
-            s->lookahead -= s->match_length;
-
-            /* Insert new strings in the hash table only if the match length
-             * is not too large. This saves time but degrades compression.
-             */
-            if (s->match_length <= s->max_insert_length &&
-                s->lookahead >= MIN_MATCH) {
-                s->match_length--; /* string at strstart already in hash table */
-                do {
-                    s->strstart++;
-                    INSERT_STRING(s, s->strstart, hash_head);
-                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
-                     * always MIN_MATCH bytes ahead.
-                     */
-                } while (--s->match_length != 0);
-                s->strstart++; 
-            } else {
-                s->strstart += s->match_length;
-                s->match_length = 0;
-                s->ins_h = s->window[s->strstart];
-                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
-#if MIN_MATCH != 3
-                Call UPDATE_HASH() MIN_MATCH-3 more times
-#endif
-                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
-                 * matter since it will be recomputed at next deflate call.
-                 */
-            }
-        } else {
-            /* No match, output a literal byte */
-            Tracevv((stderr,"%c", s->window[s->strstart]));
-            bflush = zlib_tr_tally (s, 0, s->window[s->strstart]);
-            s->lookahead--;
-            s->strstart++; 
-        }
-        if (bflush) FLUSH_BLOCK(s, 0);
-    }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
-    return flush == Z_FINISH ? finish_done : block_done;
-}
-
-/* ===========================================================================
- * Same as above, but achieves better compression. We use a lazy
- * evaluation for matches: a match is finally adopted only if there is
- * no better match at the next window position.
- */
-local block_state deflate_slow(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    IPos hash_head = NIL;    /* head of hash chain */
-    int bflush;              /* set if current block must be flushed */
-
-    /* Process the input block. */
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the next match, plus MIN_MATCH bytes to insert the
-         * string following the next match.
-         */
-        if (s->lookahead < MIN_LOOKAHEAD) {
-            fill_window(s);
-            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
-	        return need_more;
-	    }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-
-        /* Insert the string window[strstart .. strstart+2] in the
-         * dictionary, and set hash_head to the head of the hash chain:
-         */
-        if (s->lookahead >= MIN_MATCH) {
-            INSERT_STRING(s, s->strstart, hash_head);
-        }
-
-        /* Find the longest match, discarding those <= prev_length.
-         */
-        s->prev_length = s->match_length, s->prev_match = s->match_start;
-        s->match_length = MIN_MATCH-1;
-
-        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
-            s->strstart - hash_head <= MAX_DIST(s)) {
-            /* To simplify the code, we prevent matches with the string
-             * of window index 0 (in particular we have to avoid a match
-             * of the string with itself at the start of the input file).
-             */
-            if (s->strategy != Z_HUFFMAN_ONLY) {
-                s->match_length = longest_match (s, hash_head);
-            }
-            /* longest_match() sets match_start */
-
-            if (s->match_length <= 5 && (s->strategy == Z_FILTERED ||
-                 (s->match_length == MIN_MATCH &&
-                  s->strstart - s->match_start > TOO_FAR))) {
-
-                /* If prev_match is also MIN_MATCH, match_start is garbage
-                 * but we will ignore the current match anyway.
-                 */
-                s->match_length = MIN_MATCH-1;
-            }
-        }
-        /* If there was a match at the previous step and the current
-         * match is not better, output the previous match:
-         */
-        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
-            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
-            /* Do not insert strings in hash table beyond this. */
-
-            check_match(s, s->strstart-1, s->prev_match, s->prev_length);
-
-            bflush = zlib_tr_tally(s, s->strstart -1 - s->prev_match,
-				   s->prev_length - MIN_MATCH);
-
-            /* Insert in hash table all strings up to the end of the match.
-             * strstart-1 and strstart are already inserted. If there is not
-             * enough lookahead, the last two strings are not inserted in
-             * the hash table.
-             */
-            s->lookahead -= s->prev_length-1;
-            s->prev_length -= 2;
-            do {
-                if (++s->strstart <= max_insert) {
-                    INSERT_STRING(s, s->strstart, hash_head);
-                }
-            } while (--s->prev_length != 0);
-            s->match_available = 0;
-            s->match_length = MIN_MATCH-1;
-            s->strstart++;
-
-            if (bflush) FLUSH_BLOCK(s, 0);
-
-        } else if (s->match_available) {
-            /* If there was no match at the previous position, output a
-             * single literal. If there was a match but the current match
-             * is longer, truncate the previous match to a single literal.
-             */
-            Tracevv((stderr,"%c", s->window[s->strstart-1]));
-            if (zlib_tr_tally (s, 0, s->window[s->strstart-1])) {
-                FLUSH_BLOCK_ONLY(s, 0);
-            }
-            s->strstart++;
-            s->lookahead--;
-            if (s->strm->avail_out == 0) return need_more;
-        } else {
-            /* There is no previous match to compare with, wait for
-             * the next step to decide.
-             */
-            s->match_available = 1;
-            s->strstart++;
-            s->lookahead--;
-        }
-    }
-    Assert (flush != Z_NO_FLUSH, "no flush?");
-    if (s->match_available) {
-        Tracevv((stderr,"%c", s->window[s->strstart-1]));
-        zlib_tr_tally (s, 0, s->window[s->strstart-1]);
-        s->match_available = 0;
-    }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
-    return flush == Z_FINISH ? finish_done : block_done;
-}
-
-ZEXTERN int ZEXPORT zlib_deflate_workspacesize ()
-{
-    return sizeof(deflate_workspace);
-}
diff -Nur linux/fs/jffs2/compressors/zlib_deflate/deflate_syms.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_deflate/deflate_syms.c
--- linux/fs/jffs2/compressors/zlib_deflate/deflate_syms.c	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_deflate/deflate_syms.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,21 +0,0 @@
-/*
- * linux/lib/zlib_deflate/deflate_syms.c
- *
- * Exported symbols for the deflate functionality.
- *
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-
-#include <linux/zlib.h>
-
-EXPORT_SYMBOL(zlib_deflate_workspacesize);
-EXPORT_SYMBOL(zlib_deflate);
-EXPORT_SYMBOL(zlib_deflateInit_);
-EXPORT_SYMBOL(zlib_deflateInit2_);
-EXPORT_SYMBOL(zlib_deflateEnd);
-EXPORT_SYMBOL(zlib_deflateReset);
-EXPORT_SYMBOL(zlib_deflateCopy);
-EXPORT_SYMBOL(zlib_deflateParams);
-MODULE_LICENSE("GPL");
diff -Nur linux/fs/jffs2/compressors/zlib_deflate/deftree.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_deflate/deftree.c
--- linux/fs/jffs2/compressors/zlib_deflate/deftree.c	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_deflate/deftree.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,1096 +0,0 @@
-/* +++ trees.c */
-/* trees.c -- output deflated data using Huffman coding
- * Copyright (C) 1995-1996 Jean-loup Gailly
- * For conditions of distribution and use, see copyright notice in zlib.h 
- */
-
-/*
- *  ALGORITHM
- *
- *      The "deflation" process uses several Huffman trees. The more
- *      common source values are represented by shorter bit sequences.
- *
- *      Each code tree is stored in a compressed form which is itself
- * a Huffman encoding of the lengths of all the code strings (in
- * ascending order by source values).  The actual code strings are
- * reconstructed from the lengths in the inflate process, as described
- * in the deflate specification.
- *
- *  REFERENCES
- *
- *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
- *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
- *
- *      Storer, James A.
- *          Data Compression:  Methods and Theory, pp. 49-50.
- *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
- *
- *      Sedgewick, R.
- *          Algorithms, p290.
- *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
- */
-
-/* From: trees.c,v 1.11 1996/07/24 13:41:06 me Exp $ */
-
-/* #include "deflate.h" */
-
-#include <linux/zutil.h>
-#include "defutil.h"
-
-#ifdef DEBUG_ZLIB
-#  include <ctype.h>
-#endif
-
-/* ===========================================================================
- * Constants
- */
-
-#define MAX_BL_BITS 7
-/* Bit length codes must not exceed MAX_BL_BITS bits */
-
-#define END_BLOCK 256
-/* end of block literal code */
-
-#define REP_3_6      16
-/* repeat previous bit length 3-6 times (2 bits of repeat count) */
-
-#define REPZ_3_10    17
-/* repeat a zero length 3-10 times  (3 bits of repeat count) */
-
-#define REPZ_11_138  18
-/* repeat a zero length 11-138 times  (7 bits of repeat count) */
-
-local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
-   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
-
-local const int extra_dbits[D_CODES] /* extra bits for each distance code */
-   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
-
-local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
-   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
-
-local const uch bl_order[BL_CODES]
-   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
-/* The lengths of the bit length codes are sent in order of decreasing
- * probability, to avoid transmitting the lengths for unused bit length codes.
- */
-
-#define Buf_size (8 * 2*sizeof(char))
-/* Number of bits used within bi_buf. (bi_buf might be implemented on
- * more than 16 bits on some systems.)
- */
-
-/* ===========================================================================
- * Local data. These are initialized only once.
- */
-
-local ct_data static_ltree[L_CODES+2];
-/* The static literal tree. Since the bit lengths are imposed, there is no
- * need for the L_CODES extra codes used during heap construction. However
- * The codes 286 and 287 are needed to build a canonical tree (see zlib_tr_init
- * below).
- */
-
-local ct_data static_dtree[D_CODES];
-/* The static distance tree. (Actually a trivial tree since all codes use
- * 5 bits.)
- */
-
-local uch dist_code[512];
-/* distance codes. The first 256 values correspond to the distances
- * 3 .. 258, the last 256 values correspond to the top 8 bits of
- * the 15 bit distances.
- */
-
-local uch length_code[MAX_MATCH-MIN_MATCH+1];
-/* length code for each normalized match length (0 == MIN_MATCH) */
-
-local int base_length[LENGTH_CODES];
-/* First normalized length for each code (0 = MIN_MATCH) */
-
-local int base_dist[D_CODES];
-/* First normalized distance for each code (0 = distance of 1) */
-
-struct static_tree_desc_s {
-    const ct_data *static_tree;  /* static tree or NULL */
-    const intf *extra_bits;      /* extra bits for each code or NULL */
-    int     extra_base;          /* base index for extra_bits */
-    int     elems;               /* max number of elements in the tree */
-    int     max_length;          /* max bit length for the codes */
-};
-
-local static_tree_desc  static_l_desc =
-{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
-
-local static_tree_desc  static_d_desc =
-{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
-
-local static_tree_desc  static_bl_desc =
-{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};
-
-/* ===========================================================================
- * Local (static) routines in this file.
- */
-
-local void tr_static_init OF((void));
-local void init_block     OF((deflate_state *s));
-local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
-local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
-local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
-local void build_tree     OF((deflate_state *s, tree_desc *desc));
-local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
-local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
-local int  build_bl_tree  OF((deflate_state *s));
-local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
-                              int blcodes));
-local void compress_block OF((deflate_state *s, ct_data *ltree,
-                              ct_data *dtree));
-local void set_data_type  OF((deflate_state *s));
-local unsigned bi_reverse OF((unsigned value, int length));
-local void bi_windup      OF((deflate_state *s));
-local void bi_flush       OF((deflate_state *s));
-local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
-                              int header));
-
-#ifndef DEBUG_ZLIB
-#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
-   /* Send a code of the given tree. c and tree must not have side effects */
-
-#else /* DEBUG_ZLIB */
-#  define send_code(s, c, tree) \
-     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
-       send_bits(s, tree[c].Code, tree[c].Len); }
-#endif
-
-#define d_code(dist) \
-   ((dist) < 256 ? dist_code[dist] : dist_code[256+((dist)>>7)])
-/* Mapping from a distance to a distance code. dist is the distance - 1 and
- * must not have side effects. dist_code[256] and dist_code[257] are never
- * used.
- */
-
-/* ===========================================================================
- * Send a value on a given number of bits.
- * IN assertion: length <= 16 and value fits in length bits.
- */
-#ifdef DEBUG_ZLIB
-local void send_bits      OF((deflate_state *s, int value, int length));
-
-local void send_bits(s, value, length)
-    deflate_state *s;
-    int value;  /* value to send */
-    int length; /* number of bits */
-{
-    Tracevv((stderr," l %2d v %4x ", length, value));
-    Assert(length > 0 && length <= 15, "invalid length");
-    s->bits_sent += (ulg)length;
-
-    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
-     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
-     * unused bits in value.
-     */
-    if (s->bi_valid > (int)Buf_size - length) {
-        s->bi_buf |= (value << s->bi_valid);
-        put_short(s, s->bi_buf);
-        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
-        s->bi_valid += length - Buf_size;
-    } else {
-        s->bi_buf |= value << s->bi_valid;
-        s->bi_valid += length;
-    }
-}
-#else /* !DEBUG_ZLIB */
-
-#define send_bits(s, value, length) \
-{ int len = length;\
-  if (s->bi_valid > (int)Buf_size - len) {\
-    int val = value;\
-    s->bi_buf |= (val << s->bi_valid);\
-    put_short(s, s->bi_buf);\
-    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
-    s->bi_valid += len - Buf_size;\
-  } else {\
-    s->bi_buf |= (value) << s->bi_valid;\
-    s->bi_valid += len;\
-  }\
-}
-#endif /* DEBUG_ZLIB */
-
-
-#define MAX(a,b) (a >= b ? a : b)
-/* the arguments must not have side effects */
-
-/* ===========================================================================
- * Initialize the various 'constant' tables. In a multi-threaded environment,
- * this function may be called by two threads concurrently, but this is
- * harmless since both invocations do exactly the same thing.
- */
-local void tr_static_init()
-{
-    static int static_init_done = 0;
-    int n;        /* iterates over tree elements */
-    int bits;     /* bit counter */
-    int length;   /* length value */
-    int code;     /* code value */
-    int dist;     /* distance index */
-    ush bl_count[MAX_BITS+1];
-    /* number of codes at each bit length for an optimal tree */
-
-    if (static_init_done) return;
-
-    /* Initialize the mapping length (0..255) -> length code (0..28) */
-    length = 0;
-    for (code = 0; code < LENGTH_CODES-1; code++) {
-        base_length[code] = length;
-        for (n = 0; n < (1<<extra_lbits[code]); n++) {
-            length_code[length++] = (uch)code;
-        }
-    }
-    Assert (length == 256, "tr_static_init: length != 256");
-    /* Note that the length 255 (match length 258) can be represented
-     * in two different ways: code 284 + 5 bits or code 285, so we
-     * overwrite length_code[255] to use the best encoding:
-     */
-    length_code[length-1] = (uch)code;
-
-    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
-    dist = 0;
-    for (code = 0 ; code < 16; code++) {
-        base_dist[code] = dist;
-        for (n = 0; n < (1<<extra_dbits[code]); n++) {
-            dist_code[dist++] = (uch)code;
-        }
-    }
-    Assert (dist == 256, "tr_static_init: dist != 256");
-    dist >>= 7; /* from now on, all distances are divided by 128 */
-    for ( ; code < D_CODES; code++) {
-        base_dist[code] = dist << 7;
-        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
-            dist_code[256 + dist++] = (uch)code;
-        }
-    }
-    Assert (dist == 256, "tr_static_init: 256+dist != 512");
-
-    /* Construct the codes of the static literal tree */
-    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
-    n = 0;
-    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
-    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
-    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
-    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
-    /* Codes 286 and 287 do not exist, but we must include them in the
-     * tree construction to get a canonical Huffman tree (longest code
-     * all ones)
-     */
-    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
-
-    /* The static distance tree is trivial: */
-    for (n = 0; n < D_CODES; n++) {
-        static_dtree[n].Len = 5;
-        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
-    }
-    static_init_done = 1;
-}
-
-/* ===========================================================================
- * Initialize the tree data structures for a new zlib stream.
- */
-void zlib_tr_init(s)
-    deflate_state *s;
-{
-    tr_static_init();
-
-    s->compressed_len = 0L;
-
-    s->l_desc.dyn_tree = s->dyn_ltree;
-    s->l_desc.stat_desc = &static_l_desc;
-
-    s->d_desc.dyn_tree = s->dyn_dtree;
-    s->d_desc.stat_desc = &static_d_desc;
-
-    s->bl_desc.dyn_tree = s->bl_tree;
-    s->bl_desc.stat_desc = &static_bl_desc;
-
-    s->bi_buf = 0;
-    s->bi_valid = 0;
-    s->last_eob_len = 8; /* enough lookahead for inflate */
-#ifdef DEBUG_ZLIB
-    s->bits_sent = 0L;
-#endif
-
-    /* Initialize the first block of the first file: */
-    init_block(s);
-}
-
-/* ===========================================================================
- * Initialize a new block.
- */
-local void init_block(s)
-    deflate_state *s;
-{
-    int n; /* iterates over tree elements */
-
-    /* Initialize the trees. */
-    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
-    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
-    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;
-
-    s->dyn_ltree[END_BLOCK].Freq = 1;
-    s->opt_len = s->static_len = 0L;
-    s->last_lit = s->matches = 0;
-}
-
-#define SMALLEST 1
-/* Index within the heap array of least frequent node in the Huffman tree */
-
-
-/* ===========================================================================
- * Remove the smallest element from the heap and recreate the heap with
- * one less element. Updates heap and heap_len.
- */
-#define pqremove(s, tree, top) \
-{\
-    top = s->heap[SMALLEST]; \
-    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
-    pqdownheap(s, tree, SMALLEST); \
-}
-
-/* ===========================================================================
- * Compares to subtrees, using the tree depth as tie breaker when
- * the subtrees have equal frequency. This minimizes the worst case length.
- */
-#define smaller(tree, n, m, depth) \
-   (tree[n].Freq < tree[m].Freq || \
-   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
-
-/* ===========================================================================
- * Restore the heap property by moving down the tree starting at node k,
- * exchanging a node with the smallest of its two sons if necessary, stopping
- * when the heap property is re-established (each father smaller than its
- * two sons).
- */
-local void pqdownheap(s, tree, k)
-    deflate_state *s;
-    ct_data *tree;  /* the tree to restore */
-    int k;               /* node to move down */
-{
-    int v = s->heap[k];
-    int j = k << 1;  /* left son of k */
-    while (j <= s->heap_len) {
-        /* Set j to the smallest of the two sons: */
-        if (j < s->heap_len &&
-            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
-            j++;
-        }
-        /* Exit if v is smaller than both sons */
-        if (smaller(tree, v, s->heap[j], s->depth)) break;
-
-        /* Exchange v with the smallest son */
-        s->heap[k] = s->heap[j];  k = j;
-
-        /* And continue down the tree, setting j to the left son of k */
-        j <<= 1;
-    }
-    s->heap[k] = v;
-}
-
-/* ===========================================================================
- * Compute the optimal bit lengths for a tree and update the total bit length
- * for the current block.
- * IN assertion: the fields freq and dad are set, heap[heap_max] and
- *    above are the tree nodes sorted by increasing frequency.
- * OUT assertions: the field len is set to the optimal bit length, the
- *     array bl_count contains the frequencies for each bit length.
- *     The length opt_len is updated; static_len is also updated if stree is
- *     not null.
- */
-local void gen_bitlen(s, desc)
-    deflate_state *s;
-    tree_desc *desc;    /* the tree descriptor */
-{
-    ct_data *tree        = desc->dyn_tree;
-    int max_code         = desc->max_code;
-    const ct_data *stree = desc->stat_desc->static_tree;
-    const intf *extra    = desc->stat_desc->extra_bits;
-    int base             = desc->stat_desc->extra_base;
-    int max_length       = desc->stat_desc->max_length;
-    int h;              /* heap index */
-    int n, m;           /* iterate over the tree elements */
-    int bits;           /* bit length */
-    int xbits;          /* extra bits */
-    ush f;              /* frequency */
-    int overflow = 0;   /* number of elements with bit length too large */
-
-    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
-
-    /* In a first pass, compute the optimal bit lengths (which may
-     * overflow in the case of the bit length tree).
-     */
-    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */
-
-    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
-        n = s->heap[h];
-        bits = tree[tree[n].Dad].Len + 1;
-        if (bits > max_length) bits = max_length, overflow++;
-        tree[n].Len = (ush)bits;
-        /* We overwrite tree[n].Dad which is no longer needed */
-
-        if (n > max_code) continue; /* not a leaf node */
-
-        s->bl_count[bits]++;
-        xbits = 0;
-        if (n >= base) xbits = extra[n-base];
-        f = tree[n].Freq;
-        s->opt_len += (ulg)f * (bits + xbits);
-        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
-    }
-    if (overflow == 0) return;
-
-    Trace((stderr,"\nbit length overflow\n"));
-    /* This happens for example on obj2 and pic of the Calgary corpus */
-
-    /* Find the first bit length which could increase: */
-    do {
-        bits = max_length-1;
-        while (s->bl_count[bits] == 0) bits--;
-        s->bl_count[bits]--;      /* move one leaf down the tree */
-        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
-        s->bl_count[max_length]--;
-        /* The brother of the overflow item also moves one step up,
-         * but this does not affect bl_count[max_length]
-         */
-        overflow -= 2;
-    } while (overflow > 0);
-
-    /* Now recompute all bit lengths, scanning in increasing frequency.
-     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
-     * lengths instead of fixing only the wrong ones. This idea is taken
-     * from 'ar' written by Haruhiko Okumura.)
-     */
-    for (bits = max_length; bits != 0; bits--) {
-        n = s->bl_count[bits];
-        while (n != 0) {
-            m = s->heap[--h];
-            if (m > max_code) continue;
-            if (tree[m].Len != (unsigned) bits) {
-                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
-                s->opt_len += ((long)bits - (long)tree[m].Len)
-                              *(long)tree[m].Freq;
-                tree[m].Len = (ush)bits;
-            }
-            n--;
-        }
-    }
-}
-
-/* ===========================================================================
- * Generate the codes for a given tree and bit counts (which need not be
- * optimal).
- * IN assertion: the array bl_count contains the bit length statistics for
- * the given tree and the field len is set for all tree elements.
- * OUT assertion: the field code is set for all tree elements of non
- *     zero code length.
- */
-local void gen_codes (tree, max_code, bl_count)
-    ct_data *tree;             /* the tree to decorate */
-    int max_code;              /* largest code with non zero frequency */
-    ushf *bl_count;            /* number of codes at each bit length */
-{
-    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
-    ush code = 0;              /* running code value */
-    int bits;                  /* bit index */
-    int n;                     /* code index */
-
-    /* The distribution counts are first used to generate the code values
-     * without bit reversal.
-     */
-    for (bits = 1; bits <= MAX_BITS; bits++) {
-        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
-    }
-    /* Check that the bit counts in bl_count are consistent. The last code
-     * must be all ones.
-     */
-    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
-            "inconsistent bit counts");
-    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
-
-    for (n = 0;  n <= max_code; n++) {
-        int len = tree[n].Len;
-        if (len == 0) continue;
-        /* Now reverse the bits */
-        tree[n].Code = bi_reverse(next_code[len]++, len);
-
-        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
-             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
-    }
-}
-
-/* ===========================================================================
- * Construct one Huffman tree and assigns the code bit strings and lengths.
- * Update the total bit length for the current block.
- * IN assertion: the field freq is set for all tree elements.
- * OUT assertions: the fields len and code are set to the optimal bit length
- *     and corresponding code. The length opt_len is updated; static_len is
- *     also updated if stree is not null. The field max_code is set.
- */
-local void build_tree(s, desc)
-    deflate_state *s;
-    tree_desc *desc; /* the tree descriptor */
-{
-    ct_data *tree         = desc->dyn_tree;
-    const ct_data *stree  = desc->stat_desc->static_tree;
-    int elems             = desc->stat_desc->elems;
-    int n, m;          /* iterate over heap elements */
-    int max_code = -1; /* largest code with non zero frequency */
-    int node;          /* new node being created */
-
-    /* Construct the initial heap, with least frequent element in
-     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
-     * heap[0] is not used.
-     */
-    s->heap_len = 0, s->heap_max = HEAP_SIZE;
-
-    for (n = 0; n < elems; n++) {
-        if (tree[n].Freq != 0) {
-            s->heap[++(s->heap_len)] = max_code = n;
-            s->depth[n] = 0;
-        } else {
-            tree[n].Len = 0;
-        }
-    }
-
-    /* The pkzip format requires that at least one distance code exists,
-     * and that at least one bit should be sent even if there is only one
-     * possible code. So to avoid special checks later on we force at least
-     * two codes of non zero frequency.
-     */
-    while (s->heap_len < 2) {
-        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
-        tree[node].Freq = 1;
-        s->depth[node] = 0;
-        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
-        /* node is 0 or 1 so it does not have extra bits */
-    }
-    desc->max_code = max_code;
-
-    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
-     * establish sub-heaps of increasing lengths:
-     */
-    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);
-
-    /* Construct the Huffman tree by repeatedly combining the least two
-     * frequent nodes.
-     */
-    node = elems;              /* next internal node of the tree */
-    do {
-        pqremove(s, tree, n);  /* n = node of least frequency */
-        m = s->heap[SMALLEST]; /* m = node of next least frequency */
-
-        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
-        s->heap[--(s->heap_max)] = m;
-
-        /* Create a new node father of n and m */
-        tree[node].Freq = tree[n].Freq + tree[m].Freq;
-        s->depth[node] = (uch) (MAX(s->depth[n], s->depth[m]) + 1);
-        tree[n].Dad = tree[m].Dad = (ush)node;
-#ifdef DUMP_BL_TREE
-        if (tree == s->bl_tree) {
-            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
-                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
-        }
-#endif
-        /* and insert the new node in the heap */
-        s->heap[SMALLEST] = node++;
-        pqdownheap(s, tree, SMALLEST);
-
-    } while (s->heap_len >= 2);
-
-    s->heap[--(s->heap_max)] = s->heap[SMALLEST];
-
-    /* At this point, the fields freq and dad are set. We can now
-     * generate the bit lengths.
-     */
-    gen_bitlen(s, (tree_desc *)desc);
-
-    /* The field len is now set, we can generate the bit codes */
-    gen_codes ((ct_data *)tree, max_code, s->bl_count);
-}
-
-/* ===========================================================================
- * Scan a literal or distance tree to determine the frequencies of the codes
- * in the bit length tree.
- */
-local void scan_tree (s, tree, max_code)
-    deflate_state *s;
-    ct_data *tree;   /* the tree to be scanned */
-    int max_code;    /* and its largest code of non zero frequency */
-{
-    int n;                     /* iterates over all tree elements */
-    int prevlen = -1;          /* last emitted length */
-    int curlen;                /* length of current code */
-    int nextlen = tree[0].Len; /* length of next code */
-    int count = 0;             /* repeat count of the current code */
-    int max_count = 7;         /* max repeat count */
-    int min_count = 4;         /* min repeat count */
-
-    if (nextlen == 0) max_count = 138, min_count = 3;
-    tree[max_code+1].Len = (ush)0xffff; /* guard */
-
-    for (n = 0; n <= max_code; n++) {
-        curlen = nextlen; nextlen = tree[n+1].Len;
-        if (++count < max_count && curlen == nextlen) {
-            continue;
-        } else if (count < min_count) {
-            s->bl_tree[curlen].Freq += count;
-        } else if (curlen != 0) {
-            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
-            s->bl_tree[REP_3_6].Freq++;
-        } else if (count <= 10) {
-            s->bl_tree[REPZ_3_10].Freq++;
-        } else {
-            s->bl_tree[REPZ_11_138].Freq++;
-        }
-        count = 0; prevlen = curlen;
-        if (nextlen == 0) {
-            max_count = 138, min_count = 3;
-        } else if (curlen == nextlen) {
-            max_count = 6, min_count = 3;
-        } else {
-            max_count = 7, min_count = 4;
-        }
-    }
-}
-
-/* ===========================================================================
- * Send a literal or distance tree in compressed form, using the codes in
- * bl_tree.
- */
-local void send_tree (s, tree, max_code)
-    deflate_state *s;
-    ct_data *tree; /* the tree to be scanned */
-    int max_code;       /* and its largest code of non zero frequency */
-{
-    int n;                     /* iterates over all tree elements */
-    int prevlen = -1;          /* last emitted length */
-    int curlen;                /* length of current code */
-    int nextlen = tree[0].Len; /* length of next code */
-    int count = 0;             /* repeat count of the current code */
-    int max_count = 7;         /* max repeat count */
-    int min_count = 4;         /* min repeat count */
-
-    /* tree[max_code+1].Len = -1; */  /* guard already set */
-    if (nextlen == 0) max_count = 138, min_count = 3;
-
-    for (n = 0; n <= max_code; n++) {
-        curlen = nextlen; nextlen = tree[n+1].Len;
-        if (++count < max_count && curlen == nextlen) {
-            continue;
-        } else if (count < min_count) {
-            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);
-
-        } else if (curlen != 0) {
-            if (curlen != prevlen) {
-                send_code(s, curlen, s->bl_tree); count--;
-            }
-            Assert(count >= 3 && count <= 6, " 3_6?");
-            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);
-
-        } else if (count <= 10) {
-            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);
-
-        } else {
-            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
-        }
-        count = 0; prevlen = curlen;
-        if (nextlen == 0) {
-            max_count = 138, min_count = 3;
-        } else if (curlen == nextlen) {
-            max_count = 6, min_count = 3;
-        } else {
-            max_count = 7, min_count = 4;
-        }
-    }
-}
-
-/* ===========================================================================
- * Construct the Huffman tree for the bit lengths and return the index in
- * bl_order of the last bit length code to send.
- */
-local int build_bl_tree(s)
-    deflate_state *s;
-{
-    int max_blindex;  /* index of last bit length code of non zero freq */
-
-    /* Determine the bit length frequencies for literal and distance trees */
-    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
-    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);
-
-    /* Build the bit length tree: */
-    build_tree(s, (tree_desc *)(&(s->bl_desc)));
-    /* opt_len now includes the length of the tree representations, except
-     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
-     */
-
-    /* Determine the number of bit length codes to send. The pkzip format
-     * requires that at least 4 bit length codes be sent. (appnote.txt says
-     * 3 but the actual value used is 4.)
-     */
-    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
-        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
-    }
-    /* Update opt_len to include the bit length tree and counts */
-    s->opt_len += 3*(max_blindex+1) + 5+5+4;
-    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
-            s->opt_len, s->static_len));
-
-    return max_blindex;
-}
-
-/* ===========================================================================
- * Send the header for a block using dynamic Huffman trees: the counts, the
- * lengths of the bit length codes, the literal tree and the distance tree.
- * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
- */
-local void send_all_trees(s, lcodes, dcodes, blcodes)
-    deflate_state *s;
-    int lcodes, dcodes, blcodes; /* number of codes for each tree */
-{
-    int rank;                    /* index in bl_order */
-
-    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
-    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
-            "too many codes");
-    Tracev((stderr, "\nbl counts: "));
-    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
-    send_bits(s, dcodes-1,   5);
-    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
-    for (rank = 0; rank < blcodes; rank++) {
-        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
-        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
-    }
-    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
-
-    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
-    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
-
-    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
-    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
-}
-
-/* ===========================================================================
- * Send a stored block
- */
-void zlib_tr_stored_block(s, buf, stored_len, eof)
-    deflate_state *s;
-    charf *buf;       /* input block */
-    ulg stored_len;   /* length of input block */
-    int eof;          /* true if this is the last block for a file */
-{
-    send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */
-    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
-    s->compressed_len += (stored_len + 4) << 3;
-
-    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
-}
-
-/* Send just the `stored block' type code without any length bytes or data.
- */
-void zlib_tr_stored_type_only(s)
-    deflate_state *s;
-{
-    send_bits(s, (STORED_BLOCK << 1), 3);
-    bi_windup(s);
-    s->compressed_len = (s->compressed_len + 3) & ~7L;
-}
-
-
-/* ===========================================================================
- * Send one empty static block to give enough lookahead for inflate.
- * This takes 10 bits, of which 7 may remain in the bit buffer.
- * The current inflate code requires 9 bits of lookahead. If the
- * last two codes for the previous block (real code plus EOB) were coded
- * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
- * the last real code. In this case we send two empty static blocks instead
- * of one. (There are no problems if the previous block is stored or fixed.)
- * To simplify the code, we assume the worst case of last real code encoded
- * on one bit only.
- */
-void zlib_tr_align(s)
-    deflate_state *s;
-{
-    send_bits(s, STATIC_TREES<<1, 3);
-    send_code(s, END_BLOCK, static_ltree);
-    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
-    bi_flush(s);
-    /* Of the 10 bits for the empty block, we have already sent
-     * (10 - bi_valid) bits. The lookahead for the last real code (before
-     * the EOB of the previous block) was thus at least one plus the length
-     * of the EOB plus what we have just sent of the empty static block.
-     */
-    if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {
-        send_bits(s, STATIC_TREES<<1, 3);
-        send_code(s, END_BLOCK, static_ltree);
-        s->compressed_len += 10L;
-        bi_flush(s);
-    }
-    s->last_eob_len = 7;
-}
-
-/* ===========================================================================
- * Determine the best encoding for the current block: dynamic trees, static
- * trees or store, and output the encoded block to the zip file. This function
- * returns the total compressed length for the file so far.
- */
-ulg zlib_tr_flush_block(s, buf, stored_len, eof)
-    deflate_state *s;
-    charf *buf;       /* input block, or NULL if too old */
-    ulg stored_len;   /* length of input block */
-    int eof;          /* true if this is the last block for a file */
-{
-    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
-    int max_blindex = 0;  /* index of last bit length code of non zero freq */
-
-    /* Build the Huffman trees unless a stored block is forced */
-    if (s->level > 0) {
-
-	 /* Check if the file is ascii or binary */
-	if (s->data_type == Z_UNKNOWN) set_data_type(s);
-
-	/* Construct the literal and distance trees */
-	build_tree(s, (tree_desc *)(&(s->l_desc)));
-	Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
-		s->static_len));
-
-	build_tree(s, (tree_desc *)(&(s->d_desc)));
-	Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
-		s->static_len));
-	/* At this point, opt_len and static_len are the total bit lengths of
-	 * the compressed block data, excluding the tree representations.
-	 */
-
-	/* Build the bit length tree for the above two trees, and get the index
-	 * in bl_order of the last bit length code to send.
-	 */
-	max_blindex = build_bl_tree(s);
-
-	/* Determine the best encoding. Compute first the block length in bytes*/
-	opt_lenb = (s->opt_len+3+7)>>3;
-	static_lenb = (s->static_len+3+7)>>3;
-
-	Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
-		opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
-		s->last_lit));
-
-	if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
-
-    } else {
-        Assert(buf != (char*)0, "lost buf");
-	opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
-    }
-
-    /* If compression failed and this is the first and last block,
-     * and if the .zip file can be seeked (to rewrite the local header),
-     * the whole file is transformed into a stored file:
-     */
-#ifdef STORED_FILE_OK
-#  ifdef FORCE_STORED_FILE
-    if (eof && s->compressed_len == 0L) { /* force stored file */
-#  else
-    if (stored_len <= opt_lenb && eof && s->compressed_len==0L && seekable()) {
-#  endif
-        /* Since LIT_BUFSIZE <= 2*WSIZE, the input data must be there: */
-        if (buf == (charf*)0) error ("block vanished");
-
-        copy_block(s, buf, (unsigned)stored_len, 0); /* without header */
-        s->compressed_len = stored_len << 3;
-        s->method = STORED;
-    } else
-#endif /* STORED_FILE_OK */
-
-#ifdef FORCE_STORED
-    if (buf != (char*)0) { /* force stored block */
-#else
-    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
-                       /* 4: two words for the lengths */
-#endif
-        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
-         * Otherwise we can't have processed more than WSIZE input bytes since
-         * the last block flush, because compression would have been
-         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
-         * transform a block into a stored block.
-         */
-        zlib_tr_stored_block(s, buf, stored_len, eof);
-
-#ifdef FORCE_STATIC
-    } else if (static_lenb >= 0) { /* force static trees */
-#else
-    } else if (static_lenb == opt_lenb) {
-#endif
-        send_bits(s, (STATIC_TREES<<1)+eof, 3);
-        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
-        s->compressed_len += 3 + s->static_len;
-    } else {
-        send_bits(s, (DYN_TREES<<1)+eof, 3);
-        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
-                       max_blindex+1);
-        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);
-        s->compressed_len += 3 + s->opt_len;
-    }
-    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
-    init_block(s);
-
-    if (eof) {
-        bi_windup(s);
-        s->compressed_len += 7;  /* align on byte boundary */
-    }
-    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
-           s->compressed_len-7*eof));
-
-    return s->compressed_len >> 3;
-}
-
-/* ===========================================================================
- * Save the match info and tally the frequency counts. Return true if
- * the current block must be flushed.
- */
-int zlib_tr_tally (s, dist, lc)
-    deflate_state *s;
-    unsigned dist;  /* distance of matched string */
-    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
-{
-    s->d_buf[s->last_lit] = (ush)dist;
-    s->l_buf[s->last_lit++] = (uch)lc;
-    if (dist == 0) {
-        /* lc is the unmatched char */
-        s->dyn_ltree[lc].Freq++;
-    } else {
-        s->matches++;
-        /* Here, lc is the match length - MIN_MATCH */
-        dist--;             /* dist = match distance - 1 */
-        Assert((ush)dist < (ush)MAX_DIST(s) &&
-               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
-               (ush)d_code(dist) < (ush)D_CODES,  "zlib_tr_tally: bad match");
-
-        s->dyn_ltree[length_code[lc]+LITERALS+1].Freq++;
-        s->dyn_dtree[d_code(dist)].Freq++;
-    }
-
-    /* Try to guess if it is profitable to stop the current block here */
-    if ((s->last_lit & 0xfff) == 0 && s->level > 2) {
-        /* Compute an upper bound for the compressed length */
-        ulg out_length = (ulg)s->last_lit*8L;
-        ulg in_length = (ulg)((long)s->strstart - s->block_start);
-        int dcode;
-        for (dcode = 0; dcode < D_CODES; dcode++) {
-            out_length += (ulg)s->dyn_dtree[dcode].Freq *
-                (5L+extra_dbits[dcode]);
-        }
-        out_length >>= 3;
-        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
-               s->last_lit, in_length, out_length,
-               100L - out_length*100L/in_length));
-        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
-    }
-    return (s->last_lit == s->lit_bufsize-1);
-    /* We avoid equality with lit_bufsize because of wraparound at 64K
-     * on 16 bit machines and because stored blocks are restricted to
-     * 64K-1 bytes.
-     */
-}
-
-/* ===========================================================================
- * Send the block data compressed using the given Huffman trees
- */
-local void compress_block(s, ltree, dtree)
-    deflate_state *s;
-    ct_data *ltree; /* literal tree */
-    ct_data *dtree; /* distance tree */
-{
-    unsigned dist;      /* distance of matched string */
-    int lc;             /* match length or unmatched char (if dist == 0) */
-    unsigned lx = 0;    /* running index in l_buf */
-    unsigned code;      /* the code to send */
-    int extra;          /* number of extra bits to send */
-
-    if (s->last_lit != 0) do {
-        dist = s->d_buf[lx];
-        lc = s->l_buf[lx++];
-        if (dist == 0) {
-            send_code(s, lc, ltree); /* send a literal byte */
-            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
-        } else {
-            /* Here, lc is the match length - MIN_MATCH */
-            code = length_code[lc];
-            send_code(s, code+LITERALS+1, ltree); /* send the length code */
-            extra = extra_lbits[code];
-            if (extra != 0) {
-                lc -= base_length[code];
-                send_bits(s, lc, extra);       /* send the extra length bits */
-            }
-            dist--; /* dist is now the match distance - 1 */
-            code = d_code(dist);
-            Assert (code < D_CODES, "bad d_code");
-
-            send_code(s, code, dtree);       /* send the distance code */
-            extra = extra_dbits[code];
-            if (extra != 0) {
-                dist -= base_dist[code];
-                send_bits(s, dist, extra);   /* send the extra distance bits */
-            }
-        } /* literal or match pair ? */
-
-        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
-        Assert(s->pending < s->lit_bufsize + 2*lx, "pendingBuf overflow");
-
-    } while (lx < s->last_lit);
-
-    send_code(s, END_BLOCK, ltree);
-    s->last_eob_len = ltree[END_BLOCK].Len;
-}
-
-/* ===========================================================================
- * Set the data type to ASCII or BINARY, using a crude approximation:
- * binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.
- * IN assertion: the fields freq of dyn_ltree are set and the total of all
- * frequencies does not exceed 64K (to fit in an int on 16 bit machines).
- */
-local void set_data_type(s)
-    deflate_state *s;
-{
-    int n = 0;
-    unsigned ascii_freq = 0;
-    unsigned bin_freq = 0;
-    while (n < 7)        bin_freq += s->dyn_ltree[n++].Freq;
-    while (n < 128)    ascii_freq += s->dyn_ltree[n++].Freq;
-    while (n < LITERALS) bin_freq += s->dyn_ltree[n++].Freq;
-    s->data_type = (Byte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);
-}
-
-/* ===========================================================================
- * Copy a stored block, storing first the length and its
- * one's complement if requested.
- */
-local void copy_block(s, buf, len, header)
-    deflate_state *s;
-    charf    *buf;    /* the input data */
-    unsigned len;     /* its length */
-    int      header;  /* true if block header must be written */
-{
-    bi_windup(s);        /* align on byte boundary */
-    s->last_eob_len = 8; /* enough lookahead for inflate */
-
-    if (header) {
-        put_short(s, (ush)len);   
-        put_short(s, (ush)~len);
-#ifdef DEBUG_ZLIB
-        s->bits_sent += 2*16;
-#endif
-    }
-#ifdef DEBUG_ZLIB
-    s->bits_sent += (ulg)len<<3;
-#endif
-    /* bundle up the put_byte(s, *buf++) calls */
-    memcpy(&s->pending_buf[s->pending], buf, len);
-    s->pending += len;
-}
-
diff -Nur linux/fs/jffs2/compressors/zlib_deflate/defutil.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_deflate/defutil.h
--- linux/fs/jffs2/compressors/zlib_deflate/defutil.h	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_deflate/defutil.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,335 +0,0 @@
-
-
-
-#define Assert(err, str) 
-#define Trace(dummy) 
-#define Tracev(dummy) 
-#define Tracecv(err, dummy) 
-#define Tracevv(dummy) 
-
-
-
-#define LENGTH_CODES 29
-/* number of length codes, not counting the special END_BLOCK code */
-
-#define LITERALS  256
-/* number of literal bytes 0..255 */
-
-#define L_CODES (LITERALS+1+LENGTH_CODES)
-/* number of Literal or Length codes, including the END_BLOCK code */
-
-#define D_CODES   30
-/* number of distance codes */
-
-#define BL_CODES  19
-/* number of codes used to transfer the bit lengths */
-
-#define HEAP_SIZE (2*L_CODES+1)
-/* maximum heap size */
-
-#define MAX_BITS 15
-/* All codes must not exceed MAX_BITS bits */
-
-#define INIT_STATE    42
-#define BUSY_STATE   113
-#define FINISH_STATE 666
-/* Stream status */
-
-
-/* Data structure describing a single value and its code string. */
-typedef struct ct_data_s {
-    union {
-        ush  freq;       /* frequency count */
-        ush  code;       /* bit string */
-    } fc;
-    union {
-        ush  dad;        /* father node in Huffman tree */
-        ush  len;        /* length of bit string */
-    } dl;
-} FAR ct_data;
-
-#define Freq fc.freq
-#define Code fc.code
-#define Dad  dl.dad
-#define Len  dl.len
-
-typedef struct static_tree_desc_s  static_tree_desc;
-
-typedef struct tree_desc_s {
-    ct_data *dyn_tree;           /* the dynamic tree */
-    int     max_code;            /* largest code with non zero frequency */
-    static_tree_desc *stat_desc; /* the corresponding static tree */
-} FAR tree_desc;
-
-typedef ush Pos;
-typedef Pos FAR Posf;
-typedef unsigned IPos;
-
-/* A Pos is an index in the character window. We use short instead of int to
- * save space in the various tables. IPos is used only for parameter passing.
- */
-
-typedef struct deflate_state {
-    z_streamp strm;      /* pointer back to this zlib stream */
-    int   status;        /* as the name implies */
-    Bytef *pending_buf;  /* output still pending */
-    ulg   pending_buf_size; /* size of pending_buf */
-    Bytef *pending_out;  /* next pending byte to output to the stream */
-    int   pending;       /* nb of bytes in the pending buffer */
-    int   noheader;      /* suppress zlib header and adler32 */
-    Byte  data_type;     /* UNKNOWN, BINARY or ASCII */
-    Byte  method;        /* STORED (for zip only) or DEFLATED */
-    int   last_flush;    /* value of flush param for previous deflate call */
-
-                /* used by deflate.c: */
-
-    uInt  w_size;        /* LZ77 window size (32K by default) */
-    uInt  w_bits;        /* log2(w_size)  (8..16) */
-    uInt  w_mask;        /* w_size - 1 */
-
-    Bytef *window;
-    /* Sliding window. Input bytes are read into the second half of the window,
-     * and move to the first half later to keep a dictionary of at least wSize
-     * bytes. With this organization, matches are limited to a distance of
-     * wSize-MAX_MATCH bytes, but this ensures that IO is always
-     * performed with a length multiple of the block size. Also, it limits
-     * the window size to 64K, which is quite useful on MSDOS.
-     * To do: use the user input buffer as sliding window.
-     */
-
-    ulg window_size;
-    /* Actual size of window: 2*wSize, except when the user input buffer
-     * is directly used as sliding window.
-     */
-
-    Posf *prev;
-    /* Link to older string with same hash index. To limit the size of this
-     * array to 64K, this link is maintained only for the last 32K strings.
-     * An index in this array is thus a window index modulo 32K.
-     */
-
-    Posf *head; /* Heads of the hash chains or NIL. */
-
-    uInt  ins_h;          /* hash index of string to be inserted */
-    uInt  hash_size;      /* number of elements in hash table */
-    uInt  hash_bits;      /* log2(hash_size) */
-    uInt  hash_mask;      /* hash_size-1 */
-
-    uInt  hash_shift;
-    /* Number of bits by which ins_h must be shifted at each input
-     * step. It must be such that after MIN_MATCH steps, the oldest
-     * byte no longer takes part in the hash key, that is:
-     *   hash_shift * MIN_MATCH >= hash_bits
-     */
-
-    long block_start;
-    /* Window position at the beginning of the current output block. Gets
-     * negative when the window is moved backwards.
-     */
-
-    uInt match_length;           /* length of best match */
-    IPos prev_match;             /* previous match */
-    int match_available;         /* set if previous match exists */
-    uInt strstart;               /* start of string to insert */
-    uInt match_start;            /* start of matching string */
-    uInt lookahead;              /* number of valid bytes ahead in window */
-
-    uInt prev_length;
-    /* Length of the best match at previous step. Matches not greater than this
-     * are discarded. This is used in the lazy match evaluation.
-     */
-
-    uInt max_chain_length;
-    /* To speed up deflation, hash chains are never searched beyond this
-     * length.  A higher limit improves compression ratio but degrades the
-     * speed.
-     */
-
-    uInt max_lazy_match;
-    /* Attempt to find a better match only when the current match is strictly
-     * smaller than this value. This mechanism is used only for compression
-     * levels >= 4.
-     */
-#   define max_insert_length  max_lazy_match
-    /* Insert new strings in the hash table only if the match length is not
-     * greater than this length. This saves time but degrades compression.
-     * max_insert_length is used only for compression levels <= 3.
-     */
-
-    int level;    /* compression level (1..9) */
-    int strategy; /* favor or force Huffman coding*/
-
-    uInt good_match;
-    /* Use a faster search when the previous match is longer than this */
-
-    int nice_match; /* Stop searching when current match exceeds this */
-
-                /* used by trees.c: */
-    /* Didn't use ct_data typedef below to supress compiler warning */
-    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
-    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
-    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
-
-    struct tree_desc_s l_desc;               /* desc. for literal tree */
-    struct tree_desc_s d_desc;               /* desc. for distance tree */
-    struct tree_desc_s bl_desc;              /* desc. for bit length tree */
-
-    ush bl_count[MAX_BITS+1];
-    /* number of codes at each bit length for an optimal tree */
-
-    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
-    int heap_len;               /* number of elements in the heap */
-    int heap_max;               /* element of largest frequency */
-    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
-     * The same heap array is used to build all trees.
-     */
-
-    uch depth[2*L_CODES+1];
-    /* Depth of each subtree used as tie breaker for trees of equal frequency
-     */
-
-    uchf *l_buf;          /* buffer for literals or lengths */
-
-    uInt  lit_bufsize;
-    /* Size of match buffer for literals/lengths.  There are 4 reasons for
-     * limiting lit_bufsize to 64K:
-     *   - frequencies can be kept in 16 bit counters
-     *   - if compression is not successful for the first block, all input
-     *     data is still in the window so we can still emit a stored block even
-     *     when input comes from standard input.  (This can also be done for
-     *     all blocks if lit_bufsize is not greater than 32K.)
-     *   - if compression is not successful for a file smaller than 64K, we can
-     *     even emit a stored file instead of a stored block (saving 5 bytes).
-     *     This is applicable only for zip (not gzip or zlib).
-     *   - creating new Huffman trees less frequently may not provide fast
-     *     adaptation to changes in the input data statistics. (Take for
-     *     example a binary file with poorly compressible code followed by
-     *     a highly compressible string table.) Smaller buffer sizes give
-     *     fast adaptation but have of course the overhead of transmitting
-     *     trees more frequently.
-     *   - I can't count above 4
-     */
-
-    uInt last_lit;      /* running index in l_buf */
-
-    ushf *d_buf;
-    /* Buffer for distances. To simplify the code, d_buf and l_buf have
-     * the same number of elements. To use different lengths, an extra flag
-     * array would be necessary.
-     */
-
-    ulg opt_len;        /* bit length of current block with optimal trees */
-    ulg static_len;     /* bit length of current block with static trees */
-    ulg compressed_len; /* total bit length of compressed file */
-    uInt matches;       /* number of string matches in current block */
-    int last_eob_len;   /* bit length of EOB code for last block */
-
-#ifdef DEBUG_ZLIB
-    ulg bits_sent;      /* bit length of the compressed data */
-#endif
-
-    ush bi_buf;
-    /* Output buffer. bits are inserted starting at the bottom (least
-     * significant bits).
-     */
-    int bi_valid;
-    /* Number of valid bits in bi_buf.  All bits above the last valid bit
-     * are always zero.
-     */
-
-} FAR deflate_state;
-
-typedef struct deflate_workspace {
-    /* State memory for the deflator */
-    deflate_state deflate_memory;
-    Byte window_memory[2 * (1 << MAX_WBITS)];
-    Pos prev_memory[1 << MAX_WBITS];
-    Pos head_memory[1 << (MAX_MEM_LEVEL + 7)];
-    char overlay_memory[(1 << (MAX_MEM_LEVEL + 6)) * (sizeof(ush)+2)];
-} deflate_workspace;
-
-/* Output a byte on the stream.
- * IN assertion: there is enough room in pending_buf.
- */
-#define put_byte(s, c) {s->pending_buf[s->pending++] = (c);}
-
-
-#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
-/* Minimum amount of lookahead, except at the end of the input file.
- * See deflate.c for comments about the MIN_MATCH+1.
- */
-
-#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
-/* In order to simplify the code, particularly on 16 bit machines, match
- * distances are limited to MAX_DIST instead of WSIZE.
- */
-
-        /* in trees.c */
-void zlib_tr_init         OF((deflate_state *s));
-int  zlib_tr_tally        OF((deflate_state *s, unsigned dist, unsigned lc));
-ulg  zlib_tr_flush_block  OF((deflate_state *s, charf *buf, ulg stored_len,
-			      int eof));
-void zlib_tr_align        OF((deflate_state *s));
-void zlib_tr_stored_block OF((deflate_state *s, charf *buf, ulg stored_len,
-			      int eof));
-void zlib_tr_stored_type_only OF((deflate_state *));
-
-
-/* ===========================================================================
- * Output a short LSB first on the stream.
- * IN assertion: there is enough room in pendingBuf.
- */
-#define put_short(s, w) { \
-    put_byte(s, (uch)((w) & 0xff)); \
-    put_byte(s, (uch)((ush)(w) >> 8)); \
-}
-
-/* ===========================================================================
- * Reverse the first len bits of a code, using straightforward code (a faster
- * method would use a table)
- * IN assertion: 1 <= len <= 15
- */
-static inline unsigned bi_reverse(unsigned code, /* the value to invert */
-				  int len)       /* its bit length */
-{
-    register unsigned res = 0;
-    do {
-        res |= code & 1;
-        code >>= 1, res <<= 1;
-    } while (--len > 0);
-    return res >> 1;
-}
-
-/* ===========================================================================
- * Flush the bit buffer, keeping at most 7 bits in it.
- */
-static inline void bi_flush(deflate_state *s)
-{
-    if (s->bi_valid == 16) {
-        put_short(s, s->bi_buf);
-        s->bi_buf = 0;
-        s->bi_valid = 0;
-    } else if (s->bi_valid >= 8) {
-        put_byte(s, (Byte)s->bi_buf);
-        s->bi_buf >>= 8;
-        s->bi_valid -= 8;
-    }
-}
-
-/* ===========================================================================
- * Flush the bit buffer and align the output on a byte boundary
- */
-static inline void bi_windup(deflate_state *s)
-{
-    if (s->bi_valid > 8) {
-        put_short(s, s->bi_buf);
-    } else if (s->bi_valid > 0) {
-        put_byte(s, (Byte)s->bi_buf);
-    }
-    s->bi_buf = 0;
-    s->bi_valid = 0;
-#ifdef DEBUG_ZLIB
-    s->bits_sent = (s->bits_sent+7) & ~7;
-#endif
-}
-
diff -Nur linux/fs/jffs2/compressors/zlib_inflate/Makefile /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/Makefile
--- linux/fs/jffs2/compressors/zlib_inflate/Makefile	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/Makefile	1970-01-01 07:00:00.000000000 +0700
@@ -1,24 +0,0 @@
-#
-# This is a modified version of zlib, which does all memory
-# allocation ahead of time.
-#
-# This is only the decompression, see zlib_deflate for the
-# the compression
-#
-# Decompression needs to be serialized for each memory
-# allocation.
-#
-# (The upsides of the simplification is that you can't get in
-# any nasty situations wrt memory management, and that the
-# uncompression can be done without blocking on allocation).
-#
-
-O_TARGET    := zlib_inflate.o
-
-export-objs := inflate_syms.o
-
-obj-y := infblock.o infcodes.o inffast.o inflate.o \
-	 inftrees.o infutil.o inflate_syms.o
-obj-m := $(O_TARGET)
-
-include $(TOPDIR)/Rules.make
diff -Nur linux/fs/jffs2/compressors/zlib_inflate/infblock.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/infblock.c
--- linux/fs/jffs2/compressors/zlib_inflate/infblock.c	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/infblock.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,355 +0,0 @@
-/* infblock.c -- interpret and process block types to last block
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h 
- */
-
-#include <linux/zutil.h>
-#include "infblock.h"
-#include "inftrees.h"
-#include "infcodes.h"
-#include "infutil.h"
-
-struct inflate_codes_state;
-
-/* simplify the use of the inflate_huft type with some defines */
-#define exop word.what.Exop
-#define bits word.what.Bits
-
-/* Table for deflate from PKZIP's appnote.txt. */
-local const uInt border[] = { /* Order of the bit length code lengths */
-        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-
-/*
-   Notes beyond the 1.93a appnote.txt:
-
-   1. Distance pointers never point before the beginning of the output
-      stream.
-   2. Distance pointers can point back across blocks, up to 32k away.
-   3. There is an implied maximum of 7 bits for the bit length table and
-      15 bits for the actual data.
-   4. If only one code exists, then it is encoded using one bit.  (Zero
-      would be more efficient, but perhaps a little confusing.)  If two
-      codes exist, they are coded using one bit each (0 and 1).
-   5. There is no way of sending zero distance codes--a dummy must be
-      sent if there are none.  (History: a pre 2.0 version of PKZIP would
-      store blocks with no distance codes, but this was discovered to be
-      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
-      zero distance codes, which is sent as one code of zero bits in
-      length.
-   6. There are up to 286 literal/length codes.  Code 256 represents the
-      end-of-block.  Note however that the static length tree defines
-      288 codes just to fill out the Huffman codes.  Codes 286 and 287
-      cannot be used though, since there is no length base or extra bits
-      defined for them.  Similarily, there are up to 30 distance codes.
-      However, static trees define 32 codes (all 5 bits) to fill out the
-      Huffman codes, but the last two had better not show up in the data.
-   7. Unzip can check dynamic Huffman blocks for complete code sets.
-      The exception is that a single code would not be complete (see #4).
-   8. The five bits following the block type is really the number of
-      literal codes sent minus 257.
-   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
-      (1+6+6).  Therefore, to output three times the length, you output
-      three codes (1+1+1), whereas to output four times the same length,
-      you only need two codes (1+3).  Hmm.
-  10. In the tree reconstruction algorithm, Code = Code + Increment
-      only if BitLength(i) is not zero.  (Pretty obvious.)
-  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
-  12. Note: length code 284 can represent 227-258, but length code 285
-      really is 258.  The last length deserves its own, short code
-      since it gets used a lot in very redundant files.  The length
-      258 is special since 258 - 3 (the min match length) is 255.
-  13. The literal/length and distance code bit lengths are read as a
-      single stream of lengths.  It is possible (and advantageous) for
-      a repeat code (16, 17, or 18) to go across the boundary between
-      the two sets of lengths.
- */
-
-
-void zlib_inflate_blocks_reset(s, z, c)
-inflate_blocks_statef *s;
-z_streamp z;
-uLongf *c;
-{
-  if (c != Z_NULL)
-    *c = s->check;
-  if (s->mode == CODES)
-    zlib_inflate_codes_free(s->sub.decode.codes, z);
-  s->mode = TYPE;
-  s->bitk = 0;
-  s->bitb = 0;
-  s->read = s->write = s->window;
-  if (s->checkfn != Z_NULL)
-    z->adler = s->check = (*s->checkfn)(0L, (const Bytef *)Z_NULL, 0);
-}
-
-inflate_blocks_statef *zlib_inflate_blocks_new(z, c, w)
-z_streamp z;
-check_func c;
-uInt w;
-{
-  inflate_blocks_statef *s;
-
-  s = &WS(z)->working_blocks_state;
-  s->hufts = WS(z)->working_hufts;
-  s->window = WS(z)->working_window;
-  s->end = s->window + w;
-  s->checkfn = c;
-  s->mode = TYPE;
-  zlib_inflate_blocks_reset(s, z, Z_NULL);
-  return s;
-}
-
-
-int zlib_inflate_blocks(s, z, r)
-inflate_blocks_statef *s;
-z_streamp z;
-int r;
-{
-  uInt t;               /* temporary storage */
-  uLong b;              /* bit buffer */
-  uInt k;               /* bits in bit buffer */
-  Bytef *p;             /* input data pointer */
-  uInt n;               /* bytes available there */
-  Bytef *q;             /* output window write pointer */
-  uInt m;               /* bytes to end of window or read pointer */
-
-  /* copy input/output information to locals (UPDATE macro restores) */
-  LOAD
-
-  /* process input based on current state */
-  while (1) switch (s->mode)
-  {
-    case TYPE:
-      NEEDBITS(3)
-      t = (uInt)b & 7;
-      s->last = t & 1;
-      switch (t >> 1)
-      {
-        case 0:                         /* stored */
-          DUMPBITS(3)
-          t = k & 7;                    /* go to byte boundary */
-          DUMPBITS(t)
-          s->mode = LENS;               /* get length of stored block */
-          break;
-        case 1:                         /* fixed */
-          {
-            uInt bl, bd;
-            inflate_huft *tl, *td;
-
-            zlib_inflate_trees_fixed(&bl, &bd, &tl, &td, z);
-            s->sub.decode.codes = zlib_inflate_codes_new(bl, bd, tl, td, z);
-            if (s->sub.decode.codes == Z_NULL)
-            {
-              r = Z_MEM_ERROR;
-              LEAVE
-            }
-          }
-          DUMPBITS(3)
-          s->mode = CODES;
-          break;
-        case 2:                         /* dynamic */
-          DUMPBITS(3)
-          s->mode = TABLE;
-          break;
-        case 3:                         /* illegal */
-          DUMPBITS(3)
-          s->mode = B_BAD;
-          z->msg = (char*)"invalid block type";
-          r = Z_DATA_ERROR;
-          LEAVE
-      }
-      break;
-    case LENS:
-      NEEDBITS(32)
-      if ((((~b) >> 16) & 0xffff) != (b & 0xffff))
-      {
-        s->mode = B_BAD;
-        z->msg = (char*)"invalid stored block lengths";
-        r = Z_DATA_ERROR;
-        LEAVE
-      }
-      s->sub.left = (uInt)b & 0xffff;
-      b = k = 0;                      /* dump bits */
-      s->mode = s->sub.left ? STORED : (s->last ? DRY : TYPE);
-      break;
-    case STORED:
-      if (n == 0)
-        LEAVE
-      NEEDOUT
-      t = s->sub.left;
-      if (t > n) t = n;
-      if (t > m) t = m;
-      memcpy(q, p, t);
-      p += t;  n -= t;
-      q += t;  m -= t;
-      if ((s->sub.left -= t) != 0)
-        break;
-      s->mode = s->last ? DRY : TYPE;
-      break;
-    case TABLE:
-      NEEDBITS(14)
-      s->sub.trees.table = t = (uInt)b & 0x3fff;
-#ifndef PKZIP_BUG_WORKAROUND
-      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
-      {
-        s->mode = B_BAD;
-        z->msg = (char*)"too many length or distance symbols";
-        r = Z_DATA_ERROR;
-        LEAVE
-      }
-#endif
-      {
-      	s->sub.trees.blens = WS(z)->working_blens;
-      }
-      DUMPBITS(14)
-      s->sub.trees.index = 0;
-      s->mode = BTREE;
-    case BTREE:
-      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))
-      {
-        NEEDBITS(3)
-        s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
-        DUMPBITS(3)
-      }
-      while (s->sub.trees.index < 19)
-        s->sub.trees.blens[border[s->sub.trees.index++]] = 0;
-      s->sub.trees.bb = 7;
-      t = zlib_inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,
-				  &s->sub.trees.tb, s->hufts, z);
-      if (t != Z_OK)
-      {
-        r = t;
-        if (r == Z_DATA_ERROR)
-          s->mode = B_BAD;
-        LEAVE
-      }
-      s->sub.trees.index = 0;
-      s->mode = DTREE;
-    case DTREE:
-      while (t = s->sub.trees.table,
-             s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))
-      {
-        inflate_huft *h;
-        uInt i, j, c;
-
-        t = s->sub.trees.bb;
-        NEEDBITS(t)
-        h = s->sub.trees.tb + ((uInt)b & zlib_inflate_mask[t]);
-        t = h->bits;
-        c = h->base;
-        if (c < 16)
-        {
-          DUMPBITS(t)
-          s->sub.trees.blens[s->sub.trees.index++] = c;
-        }
-        else /* c == 16..18 */
-        {
-          i = c == 18 ? 7 : c - 14;
-          j = c == 18 ? 11 : 3;
-          NEEDBITS(t + i)
-          DUMPBITS(t)
-          j += (uInt)b & zlib_inflate_mask[i];
-          DUMPBITS(i)
-          i = s->sub.trees.index;
-          t = s->sub.trees.table;
-          if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
-              (c == 16 && i < 1))
-          {
-            s->mode = B_BAD;
-            z->msg = (char*)"invalid bit length repeat";
-            r = Z_DATA_ERROR;
-            LEAVE
-          }
-          c = c == 16 ? s->sub.trees.blens[i - 1] : 0;
-          do {
-            s->sub.trees.blens[i++] = c;
-          } while (--j);
-          s->sub.trees.index = i;
-        }
-      }
-      s->sub.trees.tb = Z_NULL;
-      {
-        uInt bl, bd;
-        inflate_huft *tl, *td;
-        inflate_codes_statef *c;
-
-        bl = 9;         /* must be <= 9 for lookahead assumptions */
-        bd = 6;         /* must be <= 9 for lookahead assumptions */
-        t = s->sub.trees.table;
-        t = zlib_inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),
-				       s->sub.trees.blens, &bl, &bd, &tl, &td,
-				       s->hufts, z);
-        if (t != Z_OK)
-        {
-          if (t == (uInt)Z_DATA_ERROR)
-            s->mode = B_BAD;
-          r = t;
-          LEAVE
-        }
-        if ((c = zlib_inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
-        {
-          r = Z_MEM_ERROR;
-          LEAVE
-        }
-        s->sub.decode.codes = c;
-      }
-      s->mode = CODES;
-    case CODES:
-      UPDATE
-      if ((r = zlib_inflate_codes(s, z, r)) != Z_STREAM_END)
-        return zlib_inflate_flush(s, z, r);
-      r = Z_OK;
-      zlib_inflate_codes_free(s->sub.decode.codes, z);
-      LOAD
-      if (!s->last)
-      {
-        s->mode = TYPE;
-        break;
-      }
-      s->mode = DRY;
-    case DRY:
-      FLUSH
-      if (s->read != s->write)
-        LEAVE
-      s->mode = B_DONE;
-    case B_DONE:
-      r = Z_STREAM_END;
-      LEAVE
-    case B_BAD:
-      r = Z_DATA_ERROR;
-      LEAVE
-    default:
-      r = Z_STREAM_ERROR;
-      LEAVE
-  }
-}
-
-
-int zlib_inflate_blocks_free(s, z)
-inflate_blocks_statef *s;
-z_streamp z;
-{
-  zlib_inflate_blocks_reset(s, z, Z_NULL);
-  return Z_OK;
-}
-
-
-void zlib_inflate_set_dictionary(s, d, n)
-inflate_blocks_statef *s;
-const Bytef *d;
-uInt  n;
-{
-  memcpy(s->window, d, n);
-  s->read = s->write = s->window + n;
-}
-
-
-/* Returns true if inflate is currently at the end of a block generated
- * by Z_SYNC_FLUSH or Z_FULL_FLUSH. 
- * IN assertion: s != Z_NULL
- */
-int zlib_inflate_blocks_sync_point(s)
-inflate_blocks_statef *s;
-{
-  return s->mode == LENS;
-}
diff -Nur linux/fs/jffs2/compressors/zlib_inflate/infblock.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/infblock.h
--- linux/fs/jffs2/compressors/zlib_inflate/infblock.h	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/infblock.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,44 +0,0 @@
-/* infblock.h -- header to use infblock.c
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h 
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-#ifndef _INFBLOCK_H
-#define _INFBLOCK_H
-
-struct inflate_blocks_state;
-typedef struct inflate_blocks_state FAR inflate_blocks_statef;
-
-extern inflate_blocks_statef * zlib_inflate_blocks_new OF((
-    z_streamp z,
-    check_func c,               /* check function */
-    uInt w));                   /* window size */
-
-extern int zlib_inflate_blocks OF((
-    inflate_blocks_statef *,
-    z_streamp ,
-    int));                      /* initial return code */
-
-extern void zlib_inflate_blocks_reset OF((
-    inflate_blocks_statef *,
-    z_streamp ,
-    uLongf *));                  /* check value on output */
-
-extern int zlib_inflate_blocks_free OF((
-    inflate_blocks_statef *,
-    z_streamp));
-
-extern void zlib_inflate_set_dictionary OF((
-    inflate_blocks_statef *s,
-    const Bytef *d,  /* dictionary */
-    uInt  n));       /* dictionary length */
-
-extern int zlib_inflate_blocks_sync_point OF((
-    inflate_blocks_statef *s));
-
-#endif /* _INFBLOCK_H */
diff -Nur linux/fs/jffs2/compressors/zlib_inflate/infcodes.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/infcodes.c
--- linux/fs/jffs2/compressors/zlib_inflate/infcodes.c	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/infcodes.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,204 +0,0 @@
-/* infcodes.c -- process literals and length/distance pairs
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h 
- */
-
-#include <linux/zutil.h>
-#include "inftrees.h"
-#include "infblock.h"
-#include "infcodes.h"
-#include "infutil.h"
-#include "inffast.h"
-
-/* simplify the use of the inflate_huft type with some defines */
-#define exop word.what.Exop
-#define bits word.what.Bits
-
-inflate_codes_statef *zlib_inflate_codes_new(bl, bd, tl, td, z)
-uInt bl, bd;
-inflate_huft *tl;
-inflate_huft *td; /* need separate declaration for Borland C++ */
-z_streamp z;
-{
-  inflate_codes_statef *c;
-
-  c = &WS(z)->working_state;
-  {
-    c->mode = START;
-    c->lbits = (Byte)bl;
-    c->dbits = (Byte)bd;
-    c->ltree = tl;
-    c->dtree = td;
-  }
-  return c;
-}
-
-
-int zlib_inflate_codes(s, z, r)
-inflate_blocks_statef *s;
-z_streamp z;
-int r;
-{
-  uInt j;               /* temporary storage */
-  inflate_huft *t;      /* temporary pointer */
-  uInt e;               /* extra bits or operation */
-  uLong b;              /* bit buffer */
-  uInt k;               /* bits in bit buffer */
-  Bytef *p;             /* input data pointer */
-  uInt n;               /* bytes available there */
-  Bytef *q;             /* output window write pointer */
-  uInt m;               /* bytes to end of window or read pointer */
-  Bytef *f;             /* pointer to copy strings from */
-  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */
-
-  /* copy input/output information to locals (UPDATE macro restores) */
-  LOAD
-
-  /* process input and output based on current state */
-  while (1) switch (c->mode)
-  {             /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
-    case START:         /* x: set up for LEN */
-#ifndef SLOW
-      if (m >= 258 && n >= 10)
-      {
-        UPDATE
-        r = zlib_inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
-        LOAD
-        if (r != Z_OK)
-        {
-          c->mode = r == Z_STREAM_END ? WASH : BADCODE;
-          break;
-        }
-      }
-#endif /* !SLOW */
-      c->sub.code.need = c->lbits;
-      c->sub.code.tree = c->ltree;
-      c->mode = LEN;
-    case LEN:           /* i: get length/literal/eob next */
-      j = c->sub.code.need;
-      NEEDBITS(j)
-      t = c->sub.code.tree + ((uInt)b & zlib_inflate_mask[j]);
-      DUMPBITS(t->bits)
-      e = (uInt)(t->exop);
-      if (e == 0)               /* literal */
-      {
-        c->sub.lit = t->base;
-        c->mode = LIT;
-        break;
-      }
-      if (e & 16)               /* length */
-      {
-        c->sub.copy.get = e & 15;
-        c->len = t->base;
-        c->mode = LENEXT;
-        break;
-      }
-      if ((e & 64) == 0)        /* next table */
-      {
-        c->sub.code.need = e;
-        c->sub.code.tree = t + t->base;
-        break;
-      }
-      if (e & 32)               /* end of block */
-      {
-        c->mode = WASH;
-        break;
-      }
-      c->mode = BADCODE;        /* invalid code */
-      z->msg = (char*)"invalid literal/length code";
-      r = Z_DATA_ERROR;
-      LEAVE
-    case LENEXT:        /* i: getting length extra (have base) */
-      j = c->sub.copy.get;
-      NEEDBITS(j)
-      c->len += (uInt)b & zlib_inflate_mask[j];
-      DUMPBITS(j)
-      c->sub.code.need = c->dbits;
-      c->sub.code.tree = c->dtree;
-      c->mode = DIST;
-    case DIST:          /* i: get distance next */
-      j = c->sub.code.need;
-      NEEDBITS(j)
-      t = c->sub.code.tree + ((uInt)b & zlib_inflate_mask[j]);
-      DUMPBITS(t->bits)
-      e = (uInt)(t->exop);
-      if (e & 16)               /* distance */
-      {
-        c->sub.copy.get = e & 15;
-        c->sub.copy.dist = t->base;
-        c->mode = DISTEXT;
-        break;
-      }
-      if ((e & 64) == 0)        /* next table */
-      {
-        c->sub.code.need = e;
-        c->sub.code.tree = t + t->base;
-        break;
-      }
-      c->mode = BADCODE;        /* invalid code */
-      z->msg = (char*)"invalid distance code";
-      r = Z_DATA_ERROR;
-      LEAVE
-    case DISTEXT:       /* i: getting distance extra */
-      j = c->sub.copy.get;
-      NEEDBITS(j)
-      c->sub.copy.dist += (uInt)b & zlib_inflate_mask[j];
-      DUMPBITS(j)
-      c->mode = COPY;
-    case COPY:          /* o: copying bytes in window, waiting for space */
-#ifndef __TURBOC__ /* Turbo C bug for following expression */
-      f = (uInt)(q - s->window) < c->sub.copy.dist ?
-          s->end - (c->sub.copy.dist - (q - s->window)) :
-          q - c->sub.copy.dist;
-#else
-      f = q - c->sub.copy.dist;
-      if ((uInt)(q - s->window) < c->sub.copy.dist)
-        f = s->end - (c->sub.copy.dist - (uInt)(q - s->window));
-#endif
-      while (c->len)
-      {
-        NEEDOUT
-        OUTBYTE(*f++)
-        if (f == s->end)
-          f = s->window;
-        c->len--;
-      }
-      c->mode = START;
-      break;
-    case LIT:           /* o: got literal, waiting for output space */
-      NEEDOUT
-      OUTBYTE(c->sub.lit)
-      c->mode = START;
-      break;
-    case WASH:          /* o: got eob, possibly more output */
-      if (k > 7)        /* return unused byte, if any */
-      {
-        k -= 8;
-        n++;
-        p--;            /* can always return one */
-      }
-      FLUSH
-      if (s->read != s->write)
-        LEAVE
-      c->mode = END;
-    case END:
-      r = Z_STREAM_END;
-      LEAVE
-    case BADCODE:       /* x: got error */
-      r = Z_DATA_ERROR;
-      LEAVE
-    default:
-      r = Z_STREAM_ERROR;
-      LEAVE
-  }
-#ifdef NEED_DUMMY_RETURN
-  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
-#endif
-}
-
-
-void zlib_inflate_codes_free(c, z)
-inflate_codes_statef *c;
-z_streamp z;
-{
-}
diff -Nur linux/fs/jffs2/compressors/zlib_inflate/infcodes.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/infcodes.h
--- linux/fs/jffs2/compressors/zlib_inflate/infcodes.h	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/infcodes.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,33 +0,0 @@
-/* infcodes.h -- header to use infcodes.c
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h 
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-#ifndef _INFCODES_H
-#define _INFCODES_H
-
-#include "infblock.h"
-
-struct inflate_codes_state;
-typedef struct inflate_codes_state FAR inflate_codes_statef;
-
-extern inflate_codes_statef *zlib_inflate_codes_new OF((
-    uInt, uInt,
-    inflate_huft *, inflate_huft *,
-    z_streamp ));
-
-extern int zlib_inflate_codes OF((
-    inflate_blocks_statef *,
-    z_streamp ,
-    int));
-
-extern void zlib_inflate_codes_free OF((
-    inflate_codes_statef *,
-    z_streamp ));
-
-#endif /* _INFCODES_H */
diff -Nur linux/fs/jffs2/compressors/zlib_inflate/inffast.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/inffast.c
--- linux/fs/jffs2/compressors/zlib_inflate/inffast.c	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/inffast.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,161 +0,0 @@
-/* inffast.c -- process literals and length/distance pairs fast
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h 
- */
-
-#include <linux/zutil.h>
-#include "inftrees.h"
-#include "infblock.h"
-#include "infcodes.h"
-#include "infutil.h"
-#include "inffast.h"
-
-struct inflate_codes_state;
-
-/* simplify the use of the inflate_huft type with some defines */
-#define exop word.what.Exop
-#define bits word.what.Bits
-
-/* macros for bit input with no checking and for returning unused bytes */
-#define GRABBITS(j) {while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}
-#define UNGRAB {c=z->avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;}
-
-/* Called with number of bytes left to write in window at least 258
-   (the maximum string length) and number of input bytes available
-   at least ten.  The ten bytes are six bytes for the longest length/
-   distance pair plus four bytes for overloading the bit buffer. */
-
-int zlib_inflate_fast(bl, bd, tl, td, s, z)
-uInt bl, bd;
-inflate_huft *tl;
-inflate_huft *td; /* need separate declaration for Borland C++ */
-inflate_blocks_statef *s;
-z_streamp z;
-{
-  inflate_huft *t;      /* temporary pointer */
-  uInt e;               /* extra bits or operation */
-  uLong b;              /* bit buffer */
-  uInt k;               /* bits in bit buffer */
-  Bytef *p;             /* input data pointer */
-  uInt n;               /* bytes available there */
-  Bytef *q;             /* output window write pointer */
-  uInt m;               /* bytes to end of window or read pointer */
-  uInt ml;              /* mask for literal/length tree */
-  uInt md;              /* mask for distance tree */
-  uInt c;               /* bytes to copy */
-  uInt d;               /* distance back to copy from */
-  Bytef *r;             /* copy source pointer */
-
-  /* load input, output, bit values */
-  LOAD
-
-  /* initialize masks */
-  ml = zlib_inflate_mask[bl];
-  md = zlib_inflate_mask[bd];
-
-  /* do until not enough input or output space for fast loop */
-  do {                          /* assume called with m >= 258 && n >= 10 */
-    /* get literal/length code */
-    GRABBITS(20)                /* max bits for literal/length code */
-    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)
-    {
-      DUMPBITS(t->bits)
-      *q++ = (Byte)t->base;
-      m--;
-      continue;
-    }
-    do {
-      DUMPBITS(t->bits)
-      if (e & 16)
-      {
-        /* get extra bits for length */
-        e &= 15;
-        c = t->base + ((uInt)b & zlib_inflate_mask[e]);
-        DUMPBITS(e)
-
-        /* decode distance base of block to copy */
-        GRABBITS(15);           /* max bits for distance code */
-        e = (t = td + ((uInt)b & md))->exop;
-        do {
-          DUMPBITS(t->bits)
-          if (e & 16)
-          {
-            /* get extra bits to add to distance base */
-            e &= 15;
-            GRABBITS(e)         /* get extra bits (up to 13) */
-            d = t->base + ((uInt)b & zlib_inflate_mask[e]);
-            DUMPBITS(e)
-
-            /* do the copy */
-            m -= c;
-            if ((uInt)(q - s->window) >= d)     /* offset before dest */
-            {                                   /*  just copy */
-              r = q - d;
-              *q++ = *r++;  c--;        /* minimum count is three, */
-              *q++ = *r++;  c--;        /*  so unroll loop a little */
-            }
-            else                        /* else offset after destination */
-            {
-              e = d - (uInt)(q - s->window); /* bytes from offset to end */
-              r = s->end - e;           /* pointer to offset */
-              if (c > e)                /* if source crosses, */
-              {
-                c -= e;                 /* copy to end of window */
-                do {
-                  *q++ = *r++;
-                } while (--e);
-                r = s->window;          /* copy rest from start of window */
-              }
-            }
-            do {                        /* copy all or what's left */
-              *q++ = *r++;
-            } while (--c);
-            break;
-          }
-          else if ((e & 64) == 0)
-          {
-            t += t->base;
-            e = (t += ((uInt)b & zlib_inflate_mask[e]))->exop;
-          }
-          else
-          {
-            z->msg = (char*)"invalid distance code";
-            UNGRAB
-            UPDATE
-            return Z_DATA_ERROR;
-          }
-        } while (1);
-        break;
-      }
-      if ((e & 64) == 0)
-      {
-        t += t->base;
-        if ((e = (t += ((uInt)b & zlib_inflate_mask[e]))->exop) == 0)
-        {
-          DUMPBITS(t->bits)
-          *q++ = (Byte)t->base;
-          m--;
-          break;
-        }
-      }
-      else if (e & 32)
-      {
-        UNGRAB
-        UPDATE
-        return Z_STREAM_END;
-      }
-      else
-      {
-        z->msg = (char*)"invalid literal/length code";
-        UNGRAB
-        UPDATE
-        return Z_DATA_ERROR;
-      }
-    } while (1);
-  } while (m >= 258 && n >= 10);
-
-  /* not enough input or output--restore pointers and return */
-  UNGRAB
-  UPDATE
-  return Z_OK;
-}
diff -Nur linux/fs/jffs2/compressors/zlib_inflate/inffast.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/inffast.h
--- linux/fs/jffs2/compressors/zlib_inflate/inffast.h	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/inffast.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,17 +0,0 @@
-/* inffast.h -- header to use inffast.c
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h 
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-extern int zlib_inflate_fast OF((
-    uInt,
-    uInt,
-    inflate_huft *,
-    inflate_huft *,
-    inflate_blocks_statef *,
-    z_streamp ));
diff -Nur linux/fs/jffs2/compressors/zlib_inflate/inffixed.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/inffixed.h
--- linux/fs/jffs2/compressors/zlib_inflate/inffixed.h	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/inffixed.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,151 +0,0 @@
-/* inffixed.h -- table for decoding fixed codes
- * Generated automatically by the maketree.c program
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-local uInt fixed_bl = 9;
-local uInt fixed_bd = 5;
-local inflate_huft fixed_tl[] = {
-    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
-    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},192},
-    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},160},
-    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},224},
-    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},144},
-    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},208},
-    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},176},
-    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},240},
-    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
-    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},200},
-    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},168},
-    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},232},
-    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},152},
-    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},216},
-    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},184},
-    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},248},
-    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
-    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},196},
-    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},164},
-    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},228},
-    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},148},
-    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},212},
-    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},180},
-    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},244},
-    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
-    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},204},
-    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},172},
-    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},236},
-    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},156},
-    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},220},
-    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},188},
-    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},252},
-    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
-    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},194},
-    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},162},
-    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},226},
-    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},146},
-    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},210},
-    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},178},
-    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},242},
-    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
-    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},202},
-    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},170},
-    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},234},
-    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},154},
-    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},218},
-    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},186},
-    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},250},
-    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
-    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},198},
-    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},166},
-    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},230},
-    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},150},
-    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},214},
-    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},182},
-    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},246},
-    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
-    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},206},
-    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},174},
-    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},238},
-    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},158},
-    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},222},
-    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},190},
-    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},254},
-    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
-    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},193},
-    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},161},
-    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},225},
-    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},145},
-    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},209},
-    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},177},
-    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},241},
-    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
-    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},201},
-    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},169},
-    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},233},
-    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},153},
-    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},217},
-    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},185},
-    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},249},
-    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
-    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},197},
-    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},165},
-    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},229},
-    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},149},
-    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},213},
-    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},181},
-    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},245},
-    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
-    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},205},
-    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},173},
-    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},237},
-    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},157},
-    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},221},
-    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},189},
-    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},253},
-    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
-    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},195},
-    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},163},
-    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},227},
-    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},147},
-    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},211},
-    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},179},
-    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},243},
-    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
-    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},203},
-    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},171},
-    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},235},
-    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},155},
-    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},219},
-    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},187},
-    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},251},
-    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
-    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},199},
-    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},167},
-    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},231},
-    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},151},
-    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},215},
-    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},183},
-    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},247},
-    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
-    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},207},
-    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},175},
-    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},239},
-    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},159},
-    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},223},
-    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},191},
-    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},255}
-  };
-local inflate_huft fixed_td[] = {
-    {{{80,5}},1}, {{{87,5}},257}, {{{83,5}},17}, {{{91,5}},4097},
-    {{{81,5}},5}, {{{89,5}},1025}, {{{85,5}},65}, {{{93,5}},16385},
-    {{{80,5}},3}, {{{88,5}},513}, {{{84,5}},33}, {{{92,5}},8193},
-    {{{82,5}},9}, {{{90,5}},2049}, {{{86,5}},129}, {{{192,5}},24577},
-    {{{80,5}},2}, {{{87,5}},385}, {{{83,5}},25}, {{{91,5}},6145},
-    {{{81,5}},7}, {{{89,5}},1537}, {{{85,5}},97}, {{{93,5}},24577},
-    {{{80,5}},4}, {{{88,5}},769}, {{{84,5}},49}, {{{92,5}},12289},
-    {{{82,5}},13}, {{{90,5}},3073}, {{{86,5}},193}, {{{192,5}},24577}
-  };
diff -Nur linux/fs/jffs2/compressors/zlib_inflate/inflate.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/inflate.c
--- linux/fs/jffs2/compressors/zlib_inflate/inflate.c	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/inflate.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,382 +0,0 @@
-/* inflate.c -- zlib interface to inflate modules
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h 
- */
-
-#include <linux/module.h>
-#include <linux/zutil.h>
-#include "infblock.h"
-#include "infutil.h"
-
-int ZEXPORT zlib_inflate_workspacesize(void)
-{
-  return sizeof(struct inflate_workspace);
-}
-
-
-int ZEXPORT zlib_inflateReset(z)
-z_streamp z;
-{
-  if (z == Z_NULL || z->state == Z_NULL || z->workspace == Z_NULL)
-    return Z_STREAM_ERROR;
-  z->total_in = z->total_out = 0;
-  z->msg = Z_NULL;
-  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;
-  zlib_inflate_blocks_reset(z->state->blocks, z, Z_NULL);
-  return Z_OK;
-}
-
-
-int ZEXPORT zlib_inflateEnd(z)
-z_streamp z;
-{
-  if (z == Z_NULL || z->state == Z_NULL || z->workspace == Z_NULL)
-    return Z_STREAM_ERROR;
-  if (z->state->blocks != Z_NULL)
-    zlib_inflate_blocks_free(z->state->blocks, z);
-  z->state = Z_NULL;
-  return Z_OK;
-}
-
-
-int ZEXPORT zlib_inflateInit2_(z, w, version, stream_size)
-z_streamp z;
-int w;
-const char *version;
-int stream_size;
-{
-  if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
-      stream_size != sizeof(z_stream) || z->workspace == Z_NULL)
-      return Z_VERSION_ERROR;
-
-  /* initialize state */
-  if (z == Z_NULL)
-    return Z_STREAM_ERROR;
-  z->msg = Z_NULL;
-  z->state = &WS(z)->internal_state;
-  z->state->blocks = Z_NULL;
-
-  /* handle undocumented nowrap option (no zlib header or check) */
-  z->state->nowrap = 0;
-  if (w < 0)
-  {
-    w = - w;
-    z->state->nowrap = 1;
-  }
-
-  /* set window size */
-  if (w < 8 || w > 15)
-  {
-    zlib_inflateEnd(z);
-    return Z_STREAM_ERROR;
-  }
-  z->state->wbits = (uInt)w;
-
-  /* create inflate_blocks state */
-  if ((z->state->blocks =
-      zlib_inflate_blocks_new(z, z->state->nowrap ? Z_NULL : zlib_adler32, (uInt)1 << w))
-      == Z_NULL)
-  {
-    zlib_inflateEnd(z);
-    return Z_MEM_ERROR;
-  }
-
-  /* reset state */
-  zlib_inflateReset(z);
-  return Z_OK;
-}
-
-
-/*
- * At the end of a Deflate-compressed PPP packet, we expect to have seen
- * a `stored' block type value but not the (zero) length bytes.
- */
-static int zlib_inflate_packet_flush(inflate_blocks_statef *s)
-{
-    if (s->mode != LENS)
-	return Z_DATA_ERROR;
-    s->mode = TYPE;
-    return Z_OK;
-}
-
-
-int ZEXPORT zlib_inflateInit_(z, version, stream_size)
-z_streamp z;
-const char *version;
-int stream_size;
-{
-  return zlib_inflateInit2_(z, DEF_WBITS, version, stream_size);
-}
-
-#undef NEEDBYTE
-#undef NEXTBYTE
-#define NEEDBYTE {if(z->avail_in==0)goto empty;r=trv;}
-#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)
-
-int ZEXPORT zlib_inflate(z, f)
-z_streamp z;
-int f;
-{
-  int r, trv;
-  uInt b;
-
-  if (z == Z_NULL || z->state == Z_NULL || z->next_in == Z_NULL)
-    return Z_STREAM_ERROR;
-  trv = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
-  r = Z_BUF_ERROR;
-  while (1) switch (z->state->mode)
-  {
-    case METHOD:
-      NEEDBYTE
-      if (((z->state->sub.method = NEXTBYTE) & 0xf) != Z_DEFLATED)
-      {
-        z->state->mode = I_BAD;
-        z->msg = (char*)"unknown compression method";
-        z->state->sub.marker = 5;       /* can't try inflateSync */
-        break;
-      }
-      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)
-      {
-        z->state->mode = I_BAD;
-        z->msg = (char*)"invalid window size";
-        z->state->sub.marker = 5;       /* can't try inflateSync */
-        break;
-      }
-      z->state->mode = FLAG;
-    case FLAG:
-      NEEDBYTE
-      b = NEXTBYTE;
-      if (((z->state->sub.method << 8) + b) % 31)
-      {
-        z->state->mode = I_BAD;
-        z->msg = (char*)"incorrect header check";
-        z->state->sub.marker = 5;       /* can't try inflateSync */
-        break;
-      }
-      if (!(b & PRESET_DICT))
-      {
-        z->state->mode = BLOCKS;
-        break;
-      }
-      z->state->mode = DICT4;
-    case DICT4:
-      NEEDBYTE
-      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
-      z->state->mode = DICT3;
-    case DICT3:
-      NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
-      z->state->mode = DICT2;
-    case DICT2:
-      NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
-      z->state->mode = DICT1;
-    case DICT1:
-      NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE;
-      z->adler = z->state->sub.check.need;
-      z->state->mode = DICT0;
-      return Z_NEED_DICT;
-    case DICT0:
-      z->state->mode = I_BAD;
-      z->msg = (char*)"need dictionary";
-      z->state->sub.marker = 0;       /* can try inflateSync */
-      return Z_STREAM_ERROR;
-    case BLOCKS:
-      r = zlib_inflate_blocks(z->state->blocks, z, r);
-      if (f == Z_PACKET_FLUSH && z->avail_in == 0 && z->avail_out != 0)
-	  r = zlib_inflate_packet_flush(z->state->blocks);
-      if (r == Z_DATA_ERROR)
-      {
-        z->state->mode = I_BAD;
-        z->state->sub.marker = 0;       /* can try inflateSync */
-        break;
-      }
-      if (r == Z_OK)
-        r = trv;
-      if (r != Z_STREAM_END)
-        return r;
-      r = trv;
-      zlib_inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);
-      if (z->state->nowrap)
-      {
-        z->state->mode = I_DONE;
-        break;
-      }
-      z->state->mode = CHECK4;
-    case CHECK4:
-      NEEDBYTE
-      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
-      z->state->mode = CHECK3;
-    case CHECK3:
-      NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
-      z->state->mode = CHECK2;
-    case CHECK2:
-      NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
-      z->state->mode = CHECK1;
-    case CHECK1:
-      NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE;
-
-      if (z->state->sub.check.was != z->state->sub.check.need)
-      {
-        z->state->mode = I_BAD;
-        z->msg = (char*)"incorrect data check";
-        z->state->sub.marker = 5;       /* can't try inflateSync */
-        break;
-      }
-      z->state->mode = I_DONE;
-    case I_DONE:
-      return Z_STREAM_END;
-    case I_BAD:
-      return Z_DATA_ERROR;
-    default:
-      return Z_STREAM_ERROR;
-  }
- empty:
-  if (f != Z_PACKET_FLUSH)
-    return r;
-  z->state->mode = I_BAD;
-  z->msg = (char *)"need more for packet flush";
-  z->state->sub.marker = 0;       /* can try inflateSync */
-  return Z_DATA_ERROR;
-}
-
-
-int ZEXPORT zlib_inflateSync(z)
-z_streamp z;
-{
-  uInt n;       /* number of bytes to look at */
-  Bytef *p;     /* pointer to bytes */
-  uInt m;       /* number of marker bytes found in a row */
-  uLong r, w;   /* temporaries to save total_in and total_out */
-
-  /* set up */
-  if (z == Z_NULL || z->state == Z_NULL)
-    return Z_STREAM_ERROR;
-  if (z->state->mode != I_BAD)
-  {
-    z->state->mode = I_BAD;
-    z->state->sub.marker = 0;
-  }
-  if ((n = z->avail_in) == 0)
-    return Z_BUF_ERROR;
-  p = z->next_in;
-  m = z->state->sub.marker;
-
-  /* search */
-  while (n && m < 4)
-  {
-    static const Byte mark[4] = {0, 0, 0xff, 0xff};
-    if (*p == mark[m])
-      m++;
-    else if (*p)
-      m = 0;
-    else
-      m = 4 - m;
-    p++, n--;
-  }
-
-  /* restore */
-  z->total_in += p - z->next_in;
-  z->next_in = p;
-  z->avail_in = n;
-  z->state->sub.marker = m;
-
-  /* return no joy or set up to restart on a new block */
-  if (m != 4)
-    return Z_DATA_ERROR;
-  r = z->total_in;  w = z->total_out;
-  zlib_inflateReset(z);
-  z->total_in = r;  z->total_out = w;
-  z->state->mode = BLOCKS;
-  return Z_OK;
-}
-
-
-/* Returns true if inflate is currently at the end of a block generated
- * by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
- * implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH
- * but removes the length bytes of the resulting empty stored block. When
- * decompressing, PPP checks that at the end of input packet, inflate is
- * waiting for these length bytes.
- */
-int ZEXPORT zlib_inflateSyncPoint(z)
-z_streamp z;
-{
-  if (z == Z_NULL || z->state == Z_NULL || z->state->blocks == Z_NULL)
-    return Z_STREAM_ERROR;
-  return zlib_inflate_blocks_sync_point(z->state->blocks);
-}
-
-/*
- * This subroutine adds the data at next_in/avail_in to the output history
- * without performing any output.  The output buffer must be "caught up";
- * i.e. no pending output (hence s->read equals s->write), and the state must
- * be BLOCKS (i.e. we should be willing to see the start of a series of
- * BLOCKS).  On exit, the output will also be caught up, and the checksum
- * will have been updated if need be.
- */
-static int zlib_inflate_addhistory(inflate_blocks_statef *s,
-				      z_stream              *z)
-{
-    uLong b;              /* bit buffer */  /* NOT USED HERE */
-    uInt k;               /* bits in bit buffer */ /* NOT USED HERE */
-    uInt t;               /* temporary storage */
-    Bytef *p;             /* input data pointer */
-    uInt n;               /* bytes available there */
-    Bytef *q;             /* output window write pointer */
-    uInt m;               /* bytes to end of window or read pointer */
-
-    if (s->read != s->write)
-	return Z_STREAM_ERROR;
-    if (s->mode != TYPE)
-	return Z_DATA_ERROR;
-
-    /* we're ready to rock */
-    LOAD
-    /* while there is input ready, copy to output buffer, moving
-     * pointers as needed.
-     */
-    while (n) {
-	t = n;  /* how many to do */
-	/* is there room until end of buffer? */
-	if (t > m) t = m;
-	/* update check information */
-	if (s->checkfn != Z_NULL)
-	    s->check = (*s->checkfn)(s->check, q, t);
-	memcpy(q, p, t);
-	q += t;
-	p += t;
-	n -= t;
-	z->total_out += t;
-	s->read = q;    /* drag read pointer forward */
-/*      WWRAP  */ 	/* expand WWRAP macro by hand to handle s->read */
-	if (q == s->end) {
-	    s->read = q = s->window;
-	    m = WAVAIL;
-	}
-    }
-    UPDATE
-    return Z_OK;
-}
-
-
-/*
- * This subroutine adds the data at next_in/avail_in to the output history
- * without performing any output.  The output buffer must be "caught up";
- * i.e. no pending output (hence s->read equals s->write), and the state must
- * be BLOCKS (i.e. we should be willing to see the start of a series of
- * BLOCKS).  On exit, the output will also be caught up, and the checksum
- * will have been updated if need be.
- */
-
-int ZEXPORT zlib_inflateIncomp(z)
-z_stream *z;
-{
-    if (z->state->mode != BLOCKS)
-	return Z_DATA_ERROR;
-    return zlib_inflate_addhistory(z->state->blocks, z);
-}
diff -Nur linux/fs/jffs2/compressors/zlib_inflate/inflate_syms.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/inflate_syms.c
--- linux/fs/jffs2/compressors/zlib_inflate/inflate_syms.c	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/inflate_syms.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,22 +0,0 @@
-/*
- * linux/lib/zlib_inflate/inflate_syms.c
- *
- * Exported symbols for the inflate functionality.
- *
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-
-#include <linux/zlib.h>
-
-EXPORT_SYMBOL(zlib_inflate_workspacesize);
-EXPORT_SYMBOL(zlib_inflate);
-EXPORT_SYMBOL(zlib_inflateInit_);
-EXPORT_SYMBOL(zlib_inflateInit2_);
-EXPORT_SYMBOL(zlib_inflateEnd);
-EXPORT_SYMBOL(zlib_inflateSync);
-EXPORT_SYMBOL(zlib_inflateReset);
-EXPORT_SYMBOL(zlib_inflateSyncPoint);
-EXPORT_SYMBOL(zlib_inflateIncomp); 
-MODULE_LICENSE("GPL");
diff -Nur linux/fs/jffs2/compressors/zlib_inflate/inftrees.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/inftrees.c
--- linux/fs/jffs2/compressors/zlib_inflate/inftrees.c	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/inftrees.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,391 +0,0 @@
-/* inftrees.c -- generate Huffman trees for efficient decoding
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h 
- */
-
-#include <linux/zutil.h>
-#include "inftrees.h"
-#include "infutil.h"
-
-static const char inflate_copyright[] =
-   " inflate 1.1.3 Copyright 1995-1998 Mark Adler ";
-/*
-  If you use the zlib library in a product, an acknowledgment is welcome
-  in the documentation of your product. If for some reason you cannot
-  include such an acknowledgment, I would appreciate that you keep this
-  copyright string in the executable of your product.
- */
-struct internal_state;
-
-/* simplify the use of the inflate_huft type with some defines */
-#define exop word.what.Exop
-#define bits word.what.Bits
-
-
-local int huft_build OF((
-    uIntf *,            /* code lengths in bits */
-    uInt,               /* number of codes */
-    uInt,               /* number of "simple" codes */
-    const uIntf *,      /* list of base values for non-simple codes */
-    const uIntf *,      /* list of extra bits for non-simple codes */
-    inflate_huft * FAR*,/* result: starting table */
-    uIntf *,            /* maximum lookup bits (returns actual) */
-    inflate_huft *,     /* space for trees */
-    uInt *,             /* hufts used in space */
-    uIntf * ));         /* space for values */
-
-/* Tables for deflate from PKZIP's appnote.txt. */
-local const uInt cplens[31] = { /* Copy lengths for literal codes 257..285 */
-        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
-        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
-        /* see note #13 above about 258 */
-local const uInt cplext[31] = { /* Extra bits for literal codes 257..285 */
-        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
-        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112}; /* 112==invalid */
-local const uInt cpdist[30] = { /* Copy offsets for distance codes 0..29 */
-        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
-        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
-        8193, 12289, 16385, 24577};
-local const uInt cpdext[30] = { /* Extra bits for distance codes */
-        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
-        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
-        12, 12, 13, 13};
-
-/*
-   Huffman code decoding is performed using a multi-level table lookup.
-   The fastest way to decode is to simply build a lookup table whose
-   size is determined by the longest code.  However, the time it takes
-   to build this table can also be a factor if the data being decoded
-   is not very long.  The most common codes are necessarily the
-   shortest codes, so those codes dominate the decoding time, and hence
-   the speed.  The idea is you can have a shorter table that decodes the
-   shorter, more probable codes, and then point to subsidiary tables for
-   the longer codes.  The time it costs to decode the longer codes is
-   then traded against the time it takes to make longer tables.
-
-   This results of this trade are in the variables lbits and dbits
-   below.  lbits is the number of bits the first level table for literal/
-   length codes can decode in one step, and dbits is the same thing for
-   the distance codes.  Subsequent tables are also less than or equal to
-   those sizes.  These values may be adjusted either when all of the
-   codes are shorter than that, in which case the longest code length in
-   bits is used, or when the shortest code is *longer* than the requested
-   table size, in which case the length of the shortest code in bits is
-   used.
-
-   There are two different values for the two tables, since they code a
-   different number of possibilities each.  The literal/length table
-   codes 286 possible values, or in a flat code, a little over eight
-   bits.  The distance table codes 30 possible values, or a little less
-   than five bits, flat.  The optimum values for speed end up being
-   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
-   The optimum values may differ though from machine to machine, and
-   possibly even between compilers.  Your mileage may vary.
- */
-
-
-/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */
-#define BMAX 15         /* maximum bit length of any code */
-
-local int huft_build(b, n, s, d, e, t, m, hp, hn, v)
-uIntf *b;               /* code lengths in bits (all assumed <= BMAX) */
-uInt n;                 /* number of codes (assumed <= 288) */
-uInt s;                 /* number of simple-valued codes (0..s-1) */
-const uIntf *d;         /* list of base values for non-simple codes */
-const uIntf *e;         /* list of extra bits for non-simple codes */
-inflate_huft * FAR *t;  /* result: starting table */
-uIntf *m;               /* maximum lookup bits, returns actual */
-inflate_huft *hp;       /* space for trees */
-uInt *hn;               /* hufts used in space */
-uIntf *v;               /* working area: values in order of bit length */
-/* Given a list of code lengths and a maximum table size, make a set of
-   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
-   if the given code set is incomplete (the tables are still built in this
-   case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of
-   lengths), or Z_MEM_ERROR if not enough memory. */
-{
-
-  uInt a;                       /* counter for codes of length k */
-  uInt c[BMAX+1];               /* bit length count table */
-  uInt f;                       /* i repeats in table every f entries */
-  int g;                        /* maximum code length */
-  int h;                        /* table level */
-  register uInt i;              /* counter, current code */
-  register uInt j;              /* counter */
-  register int k;               /* number of bits in current code */
-  int l;                        /* bits per table (returned in m) */
-  uInt mask;                    /* (1 << w) - 1, to avoid cc -O bug on HP */
-  register uIntf *p;            /* pointer into c[], b[], or v[] */
-  inflate_huft *q;              /* points to current table */
-  struct inflate_huft_s r;      /* table entry for structure assignment */
-  inflate_huft *u[BMAX];        /* table stack */
-  register int w;               /* bits before this table == (l * h) */
-  uInt x[BMAX+1];               /* bit offsets, then code stack */
-  uIntf *xp;                    /* pointer into x */
-  int y;                        /* number of dummy codes added */
-  uInt z;                       /* number of entries in current table */
-
-
-  /* Generate counts for each bit length */
-  p = c;
-#define C0 *p++ = 0;
-#define C2 C0 C0 C0 C0
-#define C4 C2 C2 C2 C2
-  C4                            /* clear c[]--assume BMAX+1 is 16 */
-  p = b;  i = n;
-  do {
-    c[*p++]++;                  /* assume all entries <= BMAX */
-  } while (--i);
-  if (c[0] == n)                /* null input--all zero length codes */
-  {
-    *t = (inflate_huft *)Z_NULL;
-    *m = 0;
-    return Z_OK;
-  }
-
-
-  /* Find minimum and maximum length, bound *m by those */
-  l = *m;
-  for (j = 1; j <= BMAX; j++)
-    if (c[j])
-      break;
-  k = j;                        /* minimum code length */
-  if ((uInt)l < j)
-    l = j;
-  for (i = BMAX; i; i--)
-    if (c[i])
-      break;
-  g = i;                        /* maximum code length */
-  if ((uInt)l > i)
-    l = i;
-  *m = l;
-
-
-  /* Adjust last length count to fill out codes, if needed */
-  for (y = 1 << j; j < i; j++, y <<= 1)
-    if ((y -= c[j]) < 0)
-      return Z_DATA_ERROR;
-  if ((y -= c[i]) < 0)
-    return Z_DATA_ERROR;
-  c[i] += y;
-
-
-  /* Generate starting offsets into the value table for each length */
-  x[1] = j = 0;
-  p = c + 1;  xp = x + 2;
-  while (--i) {                 /* note that i == g from above */
-    *xp++ = (j += *p++);
-  }
-
-
-  /* Make a table of values in order of bit lengths */
-  p = b;  i = 0;
-  do {
-    if ((j = *p++) != 0)
-      v[x[j]++] = i;
-  } while (++i < n);
-  n = x[g];                     /* set n to length of v */
-
-
-  /* Generate the Huffman codes and for each, make the table entries */
-  x[0] = i = 0;                 /* first Huffman code is zero */
-  p = v;                        /* grab values in bit order */
-  h = -1;                       /* no tables yet--level -1 */
-  w = -l;                       /* bits decoded == (l * h) */
-  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
-  q = (inflate_huft *)Z_NULL;   /* ditto */
-  z = 0;                        /* ditto */
-
-  /* go through the bit lengths (k already is bits in shortest code) */
-  for (; k <= g; k++)
-  {
-    a = c[k];
-    while (a--)
-    {
-      /* here i is the Huffman code of length k bits for value *p */
-      /* make tables up to required level */
-      while (k > w + l)
-      {
-        h++;
-        w += l;                 /* previous table always l bits */
-
-        /* compute minimum size table less than or equal to l bits */
-        z = g - w;
-        z = z > (uInt)l ? l : z;        /* table size upper limit */
-        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
-        {                       /* too few codes for k-w bit table */
-          f -= a + 1;           /* deduct codes from patterns left */
-          xp = c + k;
-          if (j < z)
-            while (++j < z)     /* try smaller tables up to z bits */
-            {
-              if ((f <<= 1) <= *++xp)
-                break;          /* enough codes to use up j bits */
-              f -= *xp;         /* else deduct codes from patterns */
-            }
-        }
-        z = 1 << j;             /* table entries for j-bit table */
-
-        /* allocate new table */
-        if (*hn + z > MANY)     /* (note: doesn't matter for fixed) */
-          return Z_MEM_ERROR;   /* not enough memory */
-        u[h] = q = hp + *hn;
-        *hn += z;
-
-        /* connect to last table, if there is one */
-        if (h)
-        {
-          x[h] = i;             /* save pattern for backing up */
-          r.bits = (Byte)l;     /* bits to dump before this table */
-          r.exop = (Byte)j;     /* bits in this table */
-          j = i >> (w - l);
-          r.base = (uInt)(q - u[h-1] - j);   /* offset to this table */
-          u[h-1][j] = r;        /* connect to last table */
-        }
-        else
-          *t = q;               /* first table is returned result */
-      }
-
-      /* set up table entry in r */
-      r.bits = (Byte)(k - w);
-      if (p >= v + n)
-        r.exop = 128 + 64;      /* out of values--invalid code */
-      else if (*p < s)
-      {
-        r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */
-        r.base = *p++;          /* simple code is just the value */
-      }
-      else
-      {
-        r.exop = (Byte)(e[*p - s] + 16 + 64);/* non-simple--look up in lists */
-        r.base = d[*p++ - s];
-      }
-
-      /* fill code-like entries with r */
-      f = 1 << (k - w);
-      for (j = i >> w; j < z; j += f)
-        q[j] = r;
-
-      /* backwards increment the k-bit code i */
-      for (j = 1 << (k - 1); i & j; j >>= 1)
-        i ^= j;
-      i ^= j;
-
-      /* backup over finished tables */
-      mask = (1 << w) - 1;      /* needed on HP, cc -O bug */
-      while ((i & mask) != x[h])
-      {
-        h--;                    /* don't need to update q */
-        w -= l;
-        mask = (1 << w) - 1;
-      }
-    }
-  }
-
-
-  /* Return Z_BUF_ERROR if we were given an incomplete table */
-  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
-}
-
-
-int zlib_inflate_trees_bits(c, bb, tb, hp, z)
-uIntf *c;               /* 19 code lengths */
-uIntf *bb;              /* bits tree desired/actual depth */
-inflate_huft * FAR *tb; /* bits tree result */
-inflate_huft *hp;       /* space for trees */
-z_streamp z;            /* for messages */
-{
-  int r;
-  uInt hn = 0;          /* hufts used in space */
-  uIntf *v;             /* work area for huft_build */
-  
-  v = WS(z)->tree_work_area_1;
-  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL,
-                 tb, bb, hp, &hn, v);
-  if (r == Z_DATA_ERROR)
-    z->msg = (char*)"oversubscribed dynamic bit lengths tree";
-  else if (r == Z_BUF_ERROR || *bb == 0)
-  {
-    z->msg = (char*)"incomplete dynamic bit lengths tree";
-    r = Z_DATA_ERROR;
-  }
-  return r;
-}
-
-int zlib_inflate_trees_dynamic(nl, nd, c, bl, bd, tl, td, hp, z)
-uInt nl;                /* number of literal/length codes */
-uInt nd;                /* number of distance codes */
-uIntf *c;               /* that many (total) code lengths */
-uIntf *bl;              /* literal desired/actual bit depth */
-uIntf *bd;              /* distance desired/actual bit depth */
-inflate_huft * FAR *tl; /* literal/length tree result */
-inflate_huft * FAR *td; /* distance tree result */
-inflate_huft *hp;       /* space for trees */
-z_streamp z;            /* for messages */
-{
-  int r;
-  uInt hn = 0;          /* hufts used in space */
-  uIntf *v;             /* work area for huft_build */
-
-  /* allocate work area */
-  v = WS(z)->tree_work_area_2;
-
-  /* build literal/length tree */
-  r = huft_build(c, nl, 257, cplens, cplext, tl, bl, hp, &hn, v);
-  if (r != Z_OK || *bl == 0)
-  {
-    if (r == Z_DATA_ERROR)
-      z->msg = (char*)"oversubscribed literal/length tree";
-    else if (r != Z_MEM_ERROR)
-    {
-      z->msg = (char*)"incomplete literal/length tree";
-      r = Z_DATA_ERROR;
-    }
-    return r;
-  }
-
-  /* build distance tree */
-  r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, hp, &hn, v);
-  if (r != Z_OK || (*bd == 0 && nl > 257))
-  {
-    if (r == Z_DATA_ERROR)
-      z->msg = (char*)"oversubscribed distance tree";
-    else if (r == Z_BUF_ERROR) {
-#ifdef PKZIP_BUG_WORKAROUND
-      r = Z_OK;
-    }
-#else
-      z->msg = (char*)"incomplete distance tree";
-      r = Z_DATA_ERROR;
-    }
-    else if (r != Z_MEM_ERROR)
-    {
-      z->msg = (char*)"empty distance tree with lengths";
-      r = Z_DATA_ERROR;
-    }
-    return r;
-#endif
-  }
-
-  /* done */
-  return Z_OK;
-}
-
-
-/* build fixed tables only once--keep them here */
-#include "inffixed.h"
-
-
-int zlib_inflate_trees_fixed(bl, bd, tl, td, z)
-uIntf *bl;               /* literal desired/actual bit depth */
-uIntf *bd;               /* distance desired/actual bit depth */
-inflate_huft * FAR *tl;  /* literal/length tree result */
-inflate_huft * FAR *td;  /* distance tree result */
-z_streamp z;             /* for memory allocation */
-{
-  *bl = fixed_bl;
-  *bd = fixed_bd;
-  *tl = fixed_tl;
-  *td = fixed_td;
-  return Z_OK;
-}
diff -Nur linux/fs/jffs2/compressors/zlib_inflate/inftrees.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/inftrees.h
--- linux/fs/jffs2/compressors/zlib_inflate/inftrees.h	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/inftrees.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,63 +0,0 @@
-/* inftrees.h -- header to use inftrees.c
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h 
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* Huffman code lookup table entry--this entry is four bytes for machines
-   that have 16-bit pointers (e.g. PC's in the small or medium model). */
-
-#ifndef _INFTREES_H
-#define _INFTREES_H
-
-typedef struct inflate_huft_s FAR inflate_huft;
-
-struct inflate_huft_s {
-  union {
-    struct {
-      Byte Exop;        /* number of extra bits or operation */
-      Byte Bits;        /* number of bits in this code or subcode */
-    } what;
-    uInt pad;           /* pad structure to a power of 2 (4 bytes for */
-  } word;               /*  16-bit, 8 bytes for 32-bit int's) */
-  uInt base;            /* literal, length base, distance base,
-                           or table offset */
-};
-
-/* Maximum size of dynamic tree.  The maximum found in a long but non-
-   exhaustive search was 1004 huft structures (850 for length/literals
-   and 154 for distances, the latter actually the result of an
-   exhaustive search).  The actual maximum is not known, but the
-   value below is more than safe. */
-#define MANY 1440
-
-extern int zlib_inflate_trees_bits OF((
-    uIntf *,                    /* 19 code lengths */
-    uIntf *,                    /* bits tree desired/actual depth */
-    inflate_huft * FAR *,       /* bits tree result */
-    inflate_huft *,             /* space for trees */
-    z_streamp));                /* for messages */
-
-extern int zlib_inflate_trees_dynamic OF((
-    uInt,                       /* number of literal/length codes */
-    uInt,                       /* number of distance codes */
-    uIntf *,                    /* that many (total) code lengths */
-    uIntf *,                    /* literal desired/actual bit depth */
-    uIntf *,                    /* distance desired/actual bit depth */
-    inflate_huft * FAR *,       /* literal/length tree result */
-    inflate_huft * FAR *,       /* distance tree result */
-    inflate_huft *,             /* space for trees */
-    z_streamp));                /* for messages */
-
-extern int zlib_inflate_trees_fixed OF((
-    uIntf *,                    /* literal desired/actual bit depth */
-    uIntf *,                    /* distance desired/actual bit depth */
-    inflate_huft * FAR *,       /* literal/length tree result */
-    inflate_huft * FAR *,       /* distance tree result */
-    z_streamp));                /* for memory allocation */
-
-#endif /* _INFTREES_H */
diff -Nur linux/fs/jffs2/compressors/zlib_inflate/infutil.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/infutil.c
--- linux/fs/jffs2/compressors/zlib_inflate/infutil.c	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/infutil.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,87 +0,0 @@
-/* inflate_util.c -- data and routines common to blocks and codes
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h 
- */
-
-#include <linux/zutil.h>
-#include "infblock.h"
-#include "inftrees.h"
-#include "infcodes.h"
-#include "infutil.h"
-
-struct inflate_codes_state;
-
-/* And'ing with mask[n] masks the lower n bits */
-uInt zlib_inflate_mask[17] = {
-    0x0000,
-    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
-    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
-};
-
-
-/* copy as much as possible from the sliding window to the output area */
-int zlib_inflate_flush(s, z, r)
-inflate_blocks_statef *s;
-z_streamp z;
-int r;
-{
-  uInt n;
-  Bytef *p;
-  Bytef *q;
-
-  /* local copies of source and destination pointers */
-  p = z->next_out;
-  q = s->read;
-
-  /* compute number of bytes to copy as far as end of window */
-  n = (uInt)((q <= s->write ? s->write : s->end) - q);
-  if (n > z->avail_out) n = z->avail_out;
-  if (n && r == Z_BUF_ERROR) r = Z_OK;
-
-  /* update counters */
-  z->avail_out -= n;
-  z->total_out += n;
-
-  /* update check information */
-  if (s->checkfn != Z_NULL)
-    z->adler = s->check = (*s->checkfn)(s->check, q, n);
-
-  /* copy as far as end of window */
-  memcpy(p, q, n);
-  p += n;
-  q += n;
-
-  /* see if more to copy at beginning of window */
-  if (q == s->end)
-  {
-    /* wrap pointers */
-    q = s->window;
-    if (s->write == s->end)
-      s->write = s->window;
-
-    /* compute bytes to copy */
-    n = (uInt)(s->write - q);
-    if (n > z->avail_out) n = z->avail_out;
-    if (n && r == Z_BUF_ERROR) r = Z_OK;
-
-    /* update counters */
-    z->avail_out -= n;
-    z->total_out += n;
-
-    /* update check information */
-    if (s->checkfn != Z_NULL)
-      z->adler = s->check = (*s->checkfn)(s->check, q, n);
-
-    /* copy */
-    memcpy(p, q, n);
-    p += n;
-    q += n;
-  }
-
-  /* update pointers */
-  z->next_out = p;
-  s->read = q;
-
-  /* done */
-  return r;
-}
diff -Nur linux/fs/jffs2/compressors/zlib_inflate/infutil.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/infutil.h
--- linux/fs/jffs2/compressors/zlib_inflate/infutil.h	2003-05-13 16:19:12.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/compressors/zlib_inflate/infutil.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,197 +0,0 @@
-/* infutil.h -- types and macros common to blocks and codes
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h 
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-#ifndef _INFUTIL_H
-#define _INFUTIL_H
-
-#include <linux/zconf.h>
-#include "inftrees.h"
-#include "infcodes.h"
-
-typedef enum {
-      TYPE,     /* get type bits (3, including end bit) */
-      LENS,     /* get lengths for stored */
-      STORED,   /* processing stored block */
-      TABLE,    /* get table lengths */
-      BTREE,    /* get bit lengths tree for a dynamic block */
-      DTREE,    /* get length, distance trees for a dynamic block */
-      CODES,    /* processing fixed or dynamic block */
-      DRY,      /* output remaining window bytes */
-      B_DONE,   /* finished last block, done */
-      B_BAD}    /* got a data error--stuck here */
-inflate_block_mode;
-
-/* inflate blocks semi-private state */
-struct inflate_blocks_state {
-
-  /* mode */
-  inflate_block_mode  mode;     /* current inflate_block mode */
-
-  /* mode dependent information */
-  union {
-    uInt left;          /* if STORED, bytes left to copy */
-    struct {
-      uInt table;               /* table lengths (14 bits) */
-      uInt index;               /* index into blens (or border) */
-      uIntf *blens;             /* bit lengths of codes */
-      uInt bb;                  /* bit length tree depth */
-      inflate_huft *tb;         /* bit length decoding tree */
-    } trees;            /* if DTREE, decoding info for trees */
-    struct {
-      inflate_codes_statef 
-         *codes;
-    } decode;           /* if CODES, current state */
-  } sub;                /* submode */
-  uInt last;            /* true if this block is the last block */
-
-  /* mode independent information */
-  uInt bitk;            /* bits in bit buffer */
-  uLong bitb;           /* bit buffer */
-  inflate_huft *hufts;  /* single malloc for tree space */
-  Bytef *window;        /* sliding window */
-  Bytef *end;           /* one byte after sliding window */
-  Bytef *read;          /* window read pointer */
-  Bytef *write;         /* window write pointer */
-  check_func checkfn;   /* check function */
-  uLong check;          /* check on output */
-
-};
-
-
-/* defines for inflate input/output */
-/*   update pointers and return */
-#define UPDBITS {s->bitb=b;s->bitk=k;}
-#define UPDIN {z->avail_in=n;z->total_in+=p-z->next_in;z->next_in=p;}
-#define UPDOUT {s->write=q;}
-#define UPDATE {UPDBITS UPDIN UPDOUT}
-#define LEAVE {UPDATE return zlib_inflate_flush(s,z,r);}
-/*   get bytes and bits */
-#define LOADIN {p=z->next_in;n=z->avail_in;b=s->bitb;k=s->bitk;}
-#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}
-#define NEXTBYTE (n--,*p++)
-#define NEEDBITS(j) {while(k<(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)<<k;k+=8;}}
-#define DUMPBITS(j) {b>>=(j);k-=(j);}
-/*   output bytes */
-#define WAVAIL (uInt)(q<s->read?s->read-q-1:s->end-q)
-#define LOADOUT {q=s->write;m=(uInt)WAVAIL;}
-#define WRAP {if(q==s->end&&s->read!=s->window){q=s->window;m=(uInt)WAVAIL;}}
-#define FLUSH {UPDOUT r=zlib_inflate_flush(s,z,r); LOADOUT}
-#define NEEDOUT {if(m==0){WRAP if(m==0){FLUSH WRAP if(m==0) LEAVE}}r=Z_OK;}
-#define OUTBYTE(a) {*q++=(Byte)(a);m--;}
-/*   load local pointers */
-#define LOAD {LOADIN LOADOUT}
-
-/* masks for lower bits (size given to avoid silly warnings with Visual C++) */
-extern uInt zlib_inflate_mask[17];
-
-/* copy as much as possible from the sliding window to the output area */
-extern int zlib_inflate_flush OF((
-    inflate_blocks_statef *,
-    z_streamp ,
-    int));
-
-/* inflate private state */
-typedef enum {
-      METHOD,   /* waiting for method byte */
-      FLAG,     /* waiting for flag byte */
-      DICT4,    /* four dictionary check bytes to go */
-      DICT3,    /* three dictionary check bytes to go */
-      DICT2,    /* two dictionary check bytes to go */
-      DICT1,    /* one dictionary check byte to go */
-      DICT0,    /* waiting for inflateSetDictionary */
-      BLOCKS,   /* decompressing blocks */
-      CHECK4,   /* four check bytes to go */
-      CHECK3,   /* three check bytes to go */
-      CHECK2,   /* two check bytes to go */
-      CHECK1,   /* one check byte to go */
-      I_DONE,   /* finished check, done */
-      I_BAD}    /* got an error--stay here */
-inflate_mode;
-
-struct internal_state {
-
-  /* mode */
-  inflate_mode  mode;   /* current inflate mode */
-
-  /* mode dependent information */
-  union {
-    uInt method;        /* if FLAGS, method byte */
-    struct {
-      uLong was;                /* computed check value */
-      uLong need;               /* stream check value */
-    } check;            /* if CHECK, check values to compare */
-    uInt marker;        /* if BAD, inflateSync's marker bytes count */
-  } sub;        /* submode */
-
-  /* mode independent information */
-  int  nowrap;          /* flag for no wrapper */
-  uInt wbits;           /* log2(window size)  (8..15, defaults to 15) */
-  inflate_blocks_statef 
-    *blocks;            /* current inflate_blocks state */
-
-};
-
-/* inflate codes private state */
-typedef enum {        /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
-      START,    /* x: set up for LEN */
-      LEN,      /* i: get length/literal/eob next */
-      LENEXT,   /* i: getting length extra (have base) */
-      DIST,     /* i: get distance next */
-      DISTEXT,  /* i: getting distance extra */
-      COPY,     /* o: copying bytes in window, waiting for space */
-      LIT,      /* o: got literal, waiting for output space */
-      WASH,     /* o: got eob, possibly still output waiting */
-      END,      /* x: got eob and all data flushed */
-      BADCODE}  /* x: got error */
-inflate_codes_mode;
-
-struct inflate_codes_state {
-
-  /* mode */
-  inflate_codes_mode mode;      /* current inflate_codes mode */
-
-  /* mode dependent information */
-  uInt len;
-  union {
-    struct {
-      inflate_huft *tree;       /* pointer into tree */
-      uInt need;                /* bits needed */
-    } code;             /* if LEN or DIST, where in tree */
-    uInt lit;           /* if LIT, literal */
-    struct {
-      uInt get;                 /* bits to get for extra */
-      uInt dist;                /* distance back to copy from */
-    } copy;             /* if EXT or COPY, where and how much */
-  } sub;                /* submode */
-
-  /* mode independent information */
-  Byte lbits;           /* ltree bits decoded per branch */
-  Byte dbits;           /* dtree bits decoder per branch */
-  inflate_huft *ltree;          /* literal/length/eob tree */
-  inflate_huft *dtree;          /* distance tree */
-
-};
-
-/* memory allocation for inflation */
-
-struct inflate_workspace {
-	inflate_codes_statef working_state;
-	struct inflate_blocks_state working_blocks_state;
-	struct internal_state internal_state;
-	unsigned int tree_work_area_1[19];
-	unsigned int tree_work_area_2[288];
-	unsigned working_blens[258 + 0x1f + 0x1f];
-	inflate_huft working_hufts[MANY];
-	unsigned char working_window[1 << MAX_WBITS];
-};
-
-#define WS(z) ((struct inflate_workspace *)(z->workspace))
-
-#endif
diff -Nur linux/fs/jffs2/comprtest.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/comprtest.c
--- linux/fs/jffs2/comprtest.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/comprtest.c	2003-06-23 01:47:04.000000000 +0700
@@ -1,4 +1,4 @@
-/* $Id: comprtest.c,v 1.5 2002/01/03 15:20:44 dwmw2 Exp $ */
+/* $Id: comprtest.c,v 1.4 2001/02/21 14:03:20 dwmw2 Exp $ */
 
 #include <linux/kernel.h>
 #include <linux/string.h>
@@ -266,13 +266,13 @@
 static unsigned char decomprbuf[TESTDATA_LEN];
 
 int jffs2_decompress(unsigned char comprtype, unsigned char *cdata_in, 
-		     unsigned char *data_out, uint32_t cdatalen, uint32_t datalen);
+		     unsigned char *data_out, __u32 cdatalen, __u32 datalen);
 unsigned char jffs2_compress(unsigned char *data_in, unsigned char *cpage_out, 
-			     uint32_t *datalen, uint32_t *cdatalen);
+			     __u32 *datalen, __u32 *cdatalen);
 
 int init_module(void ) {
 	unsigned char comprtype;
-	uint32_t c, d;
+	__u32 c, d;
 	int ret;
 
 	printk("Original data: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
diff -Nur linux/fs/jffs2/crc32.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/crc32.c
--- linux/fs/jffs2/crc32.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/crc32.c	2003-06-23 01:47:04.000000000 +0700
@@ -37,11 +37,11 @@
  *      polynomial $edb88320
  */
 
-/* $Id: crc32.c,v 1.4 2002/01/03 15:20:44 dwmw2 Exp $ */
+/* $Id: crc32.c,v 1.3 2001/02/07 16:45:32 dwmw2 Exp $ */
 
 #include "crc32.h"
 
-const uint32_t crc32_table[256] = {
+const __u32 crc32_table[256] = {
 	0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
 	0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
 	0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
diff -Nur linux/fs/jffs2/crc32.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/crc32.h
--- linux/fs/jffs2/crc32.h	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/crc32.h	2003-06-23 01:47:04.000000000 +0700
@@ -1,16 +1,16 @@
 #ifndef CRC32_H
 #define CRC32_H
 
-/* $Id: crc32.h,v 1.4 2002/01/03 15:20:44 dwmw2 Exp $ */
+/* $Id: crc32.h,v 1.3 2001/02/26 14:44:37 dwmw2 Exp $ */
 
 #include <linux/types.h>
 
-extern const uint32_t crc32_table[256];
+extern const __u32 crc32_table[256];
 
 /* Return a 32-bit CRC of the contents of the buffer. */
 
-static inline uint32_t 
-crc32(uint32_t val, const void *ss, int len)
+static inline __u32 
+crc32(__u32 val, const void *ss, int len)
 {
 	const unsigned char *s = ss;
         while (--len >= 0)
diff -Nur linux/fs/jffs2/dir.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/dir.c
--- linux/fs/jffs2/dir.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/dir.c	2003-06-23 01:47:04.000000000 +0700
@@ -1,29 +1,49 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
+ * Copyright (C) 2001 Red Hat, Inc.
  *
  * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: dir.c,v 1.73 2002/08/26 15:00:51 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: dir.c,v 1.45.2.6 2002/06/20 23:54:48 dwmw2 Exp $
  *
- * ChangeLog:
- *     10-Dec-2002 Lineo Japan, Inc.  fix long filename bug
  */
 
 #include <linux/kernel.h>
 #include <linux/slab.h>
-#include <linux/sched.h>
 #include <linux/fs.h>
-#include "crc32.h"
 #include <linux/mtd/compatmac.h> /* For completion */
 #include <linux/jffs2.h>
 #include <linux/jffs2_fs_i.h>
 #include <linux/jffs2_fs_sb.h>
-#include <linux/time.h>
 #include "nodelist.h"
+#include "crc32.h"
 
 static int jffs2_readdir (struct file *, void *, filldir_t);
 
@@ -40,25 +60,25 @@
 
 struct file_operations jffs2_dir_operations =
 {
-	.read =		generic_read_dir,
-	.readdir =	jffs2_readdir,
-	.ioctl =	jffs2_ioctl,
-	.fsync =	jffs2_fsync
+	read:		generic_read_dir,
+	readdir:	jffs2_readdir,
+	ioctl:		jffs2_ioctl,
+	fsync:		jffs2_null_fsync
 };
 
 
 struct inode_operations jffs2_dir_inode_operations =
 {
-	.create =	jffs2_create,
-	.lookup =	jffs2_lookup,
-	.link =		jffs2_link,
-	.unlink =	jffs2_unlink,
-	.symlink =	jffs2_symlink,
-	.mkdir =	jffs2_mkdir,
-	.rmdir =	jffs2_rmdir,
-	.mknod =	jffs2_mknod,
-	.rename =	jffs2_rename,
-	.setattr =	jffs2_setattr,
+	create:		jffs2_create,
+	lookup:		jffs2_lookup,
+	link:		jffs2_link,
+	unlink:		jffs2_unlink,
+	symlink:	jffs2_symlink,
+	mkdir:		jffs2_mkdir,
+	rmdir:		jffs2_rmdir,
+	mknod:		jffs2_mknod,
+	rename:		jffs2_rename,
+	setattr:	jffs2_setattr,
 };
 
 /***********************************************************************/
@@ -73,14 +93,11 @@
 	struct jffs2_inode_info *dir_f;
 	struct jffs2_sb_info *c;
 	struct jffs2_full_dirent *fd = NULL, *fd_list;
-	uint32_t ino = 0;
+	__u32 ino = 0;
 	struct inode *inode = NULL;
 
 	D1(printk(KERN_DEBUG "jffs2_lookup()\n"));
 
-	if (target->d_name.len > JFFS2_MAX_NAME_LEN)
-		return ERR_PTR(-ENAMETOOLONG);
-
 	dir_f = JFFS2_INODE_INFO(dir_i);
 	c = JFFS2_SB_INFO(dir_i->i_sb);
 
@@ -136,9 +153,8 @@
 		offset++;
 	}
 	if (offset == 1) {
-		unsigned long pino = parent_ino(filp->f_dentry);
-		D1(printk(KERN_DEBUG "Dirent 1: \"..\", ino #%lu\n", pino));
-		if (filldir(dirent, "..", 2, 1, pino, DT_DIR) < 0)
+		D1(printk(KERN_DEBUG "Dirent 1: \"..\", ino #%lu\n", filp->f_dentry->d_parent->d_inode->i_ino));
+		if (filldir(dirent, "..", 2, 1, filp->f_dentry->d_parent->d_inode->i_ino, DT_DIR) < 0)
 			goto out;
 		offset++;
 	}
@@ -172,13 +188,18 @@
 
 /***********************************************************************/
 
-
 static int jffs2_create(struct inode *dir_i, struct dentry *dentry, int mode)
 {
-	struct jffs2_raw_inode *ri;
 	struct jffs2_inode_info *f, *dir_f;
 	struct jffs2_sb_info *c;
 	struct inode *inode;
+	struct jffs2_raw_inode *ri;
+	struct jffs2_raw_dirent *rd;
+	struct jffs2_full_dnode *fn;
+	struct jffs2_full_dirent *fd;
+	int namelen;
+	__u32 alloclen, phys_ofs;
+	__u32 writtenlen;
 	int ret;
 
 	ri = jffs2_alloc_raw_inode();
@@ -189,11 +210,23 @@
 
 	D1(printk(KERN_DEBUG "jffs2_create()\n"));
 
+	/* Try to reserve enough space for both node and dirent. 
+	 * Just the node will do for now, though 
+	 */
+	namelen = dentry->d_name.len;
+	ret = jffs2_reserve_space(c, sizeof(*ri), &phys_ofs, &alloclen, ALLOC_NORMAL);
+	D1(printk(KERN_DEBUG "jffs2_create(): reserved 0x%x bytes\n", alloclen));
+	if (ret) {
+		jffs2_free_raw_inode(ri);
+		return ret;
+	}
+
 	inode = jffs2_new_inode(dir_i, mode, ri);
 
 	if (IS_ERR(inode)) {
 		D1(printk(KERN_DEBUG "jffs2_new_inode() failed\n"));
 		jffs2_free_raw_inode(ri);
+		jffs2_complete_reservation(c);
 		return PTR_ERR(inode);
 	}
 
@@ -203,22 +236,93 @@
 	inode->i_mapping->nrpages = 0;
 
 	f = JFFS2_INODE_INFO(inode);
+
+	ri->data_crc = 0;
+	ri->node_crc = crc32(0, ri, sizeof(*ri)-8);
+
+	fn = jffs2_write_dnode(inode, ri, NULL, 0, phys_ofs, &writtenlen);
+	D1(printk(KERN_DEBUG "jffs2_create created file with mode 0x%x\n", ri->mode));
+	jffs2_free_raw_inode(ri);
+
+	if (IS_ERR(fn)) {
+		D1(printk(KERN_DEBUG "jffs2_write_dnode() failed\n"));
+		/* Eeek. Wave bye bye */
+		up(&f->sem);
+		jffs2_complete_reservation(c);
+		jffs2_clear_inode(inode);
+		return PTR_ERR(fn);
+	}
+	/* No data here. Only a metadata node, which will be 
+	   obsoleted by the first data write
+	*/
+	f->metadata = fn;
+
+	/* Work out where to put the dirent node now. */
+	writtenlen = PAD(writtenlen);
+	phys_ofs += writtenlen;
+	alloclen -= writtenlen;
+	up(&f->sem);
+
+	if (alloclen < sizeof(*rd)+namelen) {
+		/* Not enough space left in this chunk. Get some more */
+		jffs2_complete_reservation(c);
+		ret = jffs2_reserve_space(c, sizeof(*rd)+namelen, &phys_ofs, &alloclen, ALLOC_NORMAL);
+		
+		if (ret) {
+			/* Eep. */
+			D1(printk(KERN_DEBUG "jffs2_reserve_space() for dirent failed\n"));
+			jffs2_clear_inode(inode);
+			return ret;
+		}
+	}
+
+	rd = jffs2_alloc_raw_dirent();
+	if (!rd) {
+		/* Argh. Now we treat it like a normal delete */
+		jffs2_complete_reservation(c);
+		jffs2_clear_inode(inode);
+		return -ENOMEM;
+	}
+
 	dir_f = JFFS2_INODE_INFO(dir_i);
+	down(&dir_f->sem);
 
-	ret = jffs2_do_create(c, dir_f, f, ri, 
-			      dentry->d_name.name, dentry->d_name.len);
+	rd->magic = JFFS2_MAGIC_BITMASK;
+	rd->nodetype = JFFS2_NODETYPE_DIRENT;
+	rd->totlen = sizeof(*rd) + namelen;
+	rd->hdr_crc = crc32(0, rd, sizeof(struct jffs2_unknown_node)-4);
+
+	rd->pino = dir_i->i_ino;
+	rd->version = ++dir_f->highest_version;
+	rd->ino = inode->i_ino;
+	rd->mctime = CURRENT_TIME;
+	rd->nsize = namelen;
+	rd->type = DT_REG;
+	rd->node_crc = crc32(0, rd, sizeof(*rd)-8);
+	rd->name_crc = crc32(0, dentry->d_name.name, namelen);
 
-	if (ret) {
+	fd = jffs2_write_dirent(dir_i, rd, dentry->d_name.name, namelen, phys_ofs, &writtenlen);
+
+	jffs2_complete_reservation(c);
+	
+	if (IS_ERR(fd)) {
+		/* dirent failed to write. Delete the inode normally 
+		   as if it were the final unlink() */
+		jffs2_free_raw_dirent(rd);
+		up(&dir_f->sem);
 		jffs2_clear_inode(inode);
-		make_bad_inode(inode);
-		iput(inode);
-		jffs2_free_raw_inode(ri);
-		return ret;
+		return PTR_ERR(fd);
 	}
 
-	dir_i->i_mtime = dir_i->i_ctime = je32_to_cpu(ri->ctime);
+	dir_i->i_mtime = dir_i->i_ctime = rd->mctime;
+
+	jffs2_free_raw_dirent(rd);
+
+	/* Link the fd into the inode's list, obsoleting an old
+	   one if necessary. */
+	jffs2_add_fd_to_list(c, fd, &dir_f->dents);
+	up(&dir_f->sem);
 
-	jffs2_free_raw_inode(ri);
 	d_instantiate(dentry, inode);
 
 	D1(printk(KERN_DEBUG "jffs2_create: Created ino #%lu with mode %o, nlink %d(%d). nrpages %ld\n",
@@ -228,48 +332,168 @@
 
 /***********************************************************************/
 
-
-static int jffs2_unlink(struct inode *dir_i, struct dentry *dentry)
+static int jffs2_do_unlink(struct inode *dir_i, struct dentry *dentry, int rename)
 {
-	struct jffs2_sb_info *c = JFFS2_SB_INFO(dir_i->i_sb);
-	struct jffs2_inode_info *dir_f = JFFS2_INODE_INFO(dir_i);
-	struct jffs2_inode_info *dead_f = JFFS2_INODE_INFO(dentry->d_inode);
+	struct jffs2_inode_info *dir_f, *f;
+	struct jffs2_sb_info *c;
+	struct jffs2_raw_dirent *rd;
+	struct jffs2_full_dirent *fd;
+	__u32 alloclen, phys_ofs;
 	int ret;
 
-	ret = jffs2_do_unlink(c, dir_f, dentry->d_name.name, 
-			       dentry->d_name.len, dead_f);
-	if (dead_f->inocache)
-		dentry->d_inode->i_nlink = dead_f->inocache->nlink;
-	return ret;
+	c = JFFS2_SB_INFO(dir_i->i_sb);
+
+	rd = jffs2_alloc_raw_dirent();
+	if (!rd)
+		return -ENOMEM;
+
+	ret = jffs2_reserve_space(c, sizeof(*rd)+dentry->d_name.len, &phys_ofs, &alloclen, ALLOC_DELETION);
+	if (ret) {
+		jffs2_free_raw_dirent(rd);
+		return ret;
+	}
+
+	dir_f = JFFS2_INODE_INFO(dir_i);
+	down(&dir_f->sem);
+
+	/* Build a deletion node */
+	rd->magic = JFFS2_MAGIC_BITMASK;
+	rd->nodetype = JFFS2_NODETYPE_DIRENT;
+	rd->totlen = sizeof(*rd) + dentry->d_name.len;
+	rd->hdr_crc = crc32(0, rd, sizeof(struct jffs2_unknown_node)-4);
+
+	rd->pino = dir_i->i_ino;
+	rd->version = ++dir_f->highest_version;
+	rd->ino = 0;
+	rd->mctime = CURRENT_TIME;
+	rd->nsize = dentry->d_name.len;
+	rd->type = DT_UNKNOWN;
+	rd->node_crc = crc32(0, rd, sizeof(*rd)-8);
+	rd->name_crc = crc32(0, dentry->d_name.name, dentry->d_name.len);
+
+	fd = jffs2_write_dirent(dir_i, rd, dentry->d_name.name, dentry->d_name.len, phys_ofs, NULL);
+	
+	jffs2_complete_reservation(c);
+	jffs2_free_raw_dirent(rd);
+
+	if (IS_ERR(fd)) {
+		up(&dir_f->sem);
+		return PTR_ERR(fd);
+	}
+
+	/* File it. This will mark the old one obsolete. */
+	jffs2_add_fd_to_list(c, fd, &dir_f->dents);
+	up(&dir_f->sem);
+	
+	if (!rename) {
+		f = JFFS2_INODE_INFO(dentry->d_inode);
+		down(&f->sem);
+
+		while (f->dents) {
+			/* There can be only deleted ones */
+			fd = f->dents;
+			
+			f->dents = fd->next;
+			
+			if (fd->ino) {
+				printk(KERN_WARNING "Deleting inode #%u with active dentry \"%s\"->ino #%u\n",
+				       f->inocache->ino, fd->name, fd->ino);
+			} else {
+				D1(printk(KERN_DEBUG "Removing deletion dirent for \"%s\" from dir ino #%u\n", fd->name, f->inocache->ino));
+			}
+			jffs2_mark_node_obsolete(c, fd->raw);
+			jffs2_free_full_dirent(fd);
+		}
+
+		f->inocache->nlink--;
+		dentry->d_inode->i_nlink--;
+		up(&f->sem);
+	}
+
+	return 0;
 }
-/***********************************************************************/
 
+static int jffs2_unlink(struct inode *dir_i, struct dentry *dentry)
+{
+	return jffs2_do_unlink(dir_i, dentry, 0);
+}
+/***********************************************************************/
 
-static int jffs2_link (struct dentry *old_dentry, struct inode *dir_i, struct dentry *dentry)
+static int jffs2_do_link (struct dentry *old_dentry, struct inode *dir_i, struct dentry *dentry, int rename)
 {
-	struct jffs2_sb_info *c = JFFS2_SB_INFO(old_dentry->d_inode->i_sb);
-	struct jffs2_inode_info *f = JFFS2_INODE_INFO(old_dentry->d_inode);
-	struct jffs2_inode_info *dir_f = JFFS2_INODE_INFO(dir_i);
+	struct jffs2_inode_info *dir_f, *f;
+	struct jffs2_sb_info *c;
+	struct jffs2_raw_dirent *rd;
+	struct jffs2_full_dirent *fd;
+	__u32 alloclen, phys_ofs;
 	int ret;
-	uint8_t type;
 
-	/* Don't let people make hard links to bad inodes. */
-	if (!f->inocache)
-		return -EIO;
+	c = JFFS2_SB_INFO(dir_i->i_sb);
 
-	if (S_ISDIR(old_dentry->d_inode->i_mode))
-		return -EPERM;
+	rd = jffs2_alloc_raw_dirent();
+	if (!rd)
+		return -ENOMEM;
+
+	ret = jffs2_reserve_space(c, sizeof(*rd)+dentry->d_name.len, &phys_ofs, &alloclen, ALLOC_NORMAL);
+	if (ret) {
+		jffs2_free_raw_dirent(rd);
+		return ret;
+	}
+	
+	dir_f = JFFS2_INODE_INFO(dir_i);
+	down(&dir_f->sem);
 
-	/* XXX: This is ugly */
-	type = (old_dentry->d_inode->i_mode & S_IFMT) >> 12;
-	if (!type) type = DT_REG;
+	/* Build a deletion node */
+	rd->magic = JFFS2_MAGIC_BITMASK;
+	rd->nodetype = JFFS2_NODETYPE_DIRENT;
+	rd->totlen = sizeof(*rd) + dentry->d_name.len;
+	rd->hdr_crc = crc32(0, rd, sizeof(struct jffs2_unknown_node)-4);
+
+	rd->pino = dir_i->i_ino;
+	rd->version = ++dir_f->highest_version;
+	rd->ino = old_dentry->d_inode->i_ino;
+	rd->mctime = CURRENT_TIME;
+	rd->nsize = dentry->d_name.len;
 
-	ret = jffs2_do_link(c, dir_f, f->inocache->ino, type, dentry->d_name.name, dentry->d_name.len);
+	/* XXX: This is ugly. */
+	rd->type = (old_dentry->d_inode->i_mode & S_IFMT) >> 12;
+	if (!rd->type) rd->type = DT_REG;
 
-	if (!ret) {
+	rd->node_crc = crc32(0, rd, sizeof(*rd)-8);
+	rd->name_crc = crc32(0, dentry->d_name.name, dentry->d_name.len);
+
+	fd = jffs2_write_dirent(dir_i, rd, dentry->d_name.name, dentry->d_name.len, phys_ofs, NULL);
+	
+	jffs2_complete_reservation(c);
+	jffs2_free_raw_dirent(rd);
+
+	if (IS_ERR(fd)) {
+		up(&dir_f->sem);
+		return PTR_ERR(fd);
+	}
+
+	/* File it. This will mark the old one obsolete. */
+	jffs2_add_fd_to_list(c, fd, &dir_f->dents);
+	up(&dir_f->sem);
+
+	if (!rename) {
+		f = JFFS2_INODE_INFO(old_dentry->d_inode);
 		down(&f->sem);
 		old_dentry->d_inode->i_nlink = ++f->inocache->nlink;
 		up(&f->sem);
+	}
+	return 0;
+}
+
+static int jffs2_link (struct dentry *old_dentry, struct inode *dir_i, struct dentry *dentry)
+{
+	int ret;
+
+	if (S_ISDIR(old_dentry->d_inode->i_mode))
+		return -EPERM;
+
+	ret = jffs2_do_link(old_dentry, dir_i, dentry, 0);
+	if (!ret) {
 		d_instantiate(dentry, old_dentry->d_inode);
 		atomic_inc(&old_dentry->d_inode->i_count);
 	}
@@ -288,13 +512,10 @@
 	struct jffs2_full_dnode *fn;
 	struct jffs2_full_dirent *fd;
 	int namelen;
-	uint32_t alloclen, phys_ofs;
-	uint32_t writtenlen;
+	__u32 alloclen, phys_ofs;
+	__u32 writtenlen;
 	int ret;
 
-	if ((strlen(target)+1) > dir_i->i_sb->s_blocksize)
-		return -ENAMETOOLONG;
-
 	/* FIXME: If you care. We'd need to use frags for the target
 	   if it grows much more than this */
 	if (strlen(target) > 254)
@@ -330,16 +551,15 @@
 
 	f = JFFS2_INODE_INFO(inode);
 
-	inode->i_size = strlen(target);
-	ri->isize = ri->dsize = ri->csize = cpu_to_je32(inode->i_size);
-	ri->totlen = cpu_to_je32(sizeof(*ri) + inode->i_size);
-	ri->hdr_crc = cpu_to_je32(crc32(0, ri, sizeof(struct jffs2_unknown_node)-4));
+	inode->i_size = ri->isize = ri->dsize = ri->csize = strlen(target);
+	ri->totlen = sizeof(*ri) + ri->dsize;
+	ri->hdr_crc = crc32(0, ri, sizeof(struct jffs2_unknown_node)-4);
 
 	ri->compr = JFFS2_COMPR_NONE;
-	ri->data_crc = cpu_to_je32(crc32(0, target, strlen(target)));
-	ri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));
+	ri->data_crc = crc32(0, target, strlen(target));
+	ri->node_crc = crc32(0, ri, sizeof(*ri)-8);
 	
-	fn = jffs2_write_dnode(c, f, ri, target, strlen(target), phys_ofs, &writtenlen);
+	fn = jffs2_write_dnode(inode, ri, target, strlen(target), phys_ofs, &writtenlen);
 
 	jffs2_free_raw_inode(ri);
 
@@ -383,42 +603,41 @@
 	dir_f = JFFS2_INODE_INFO(dir_i);
 	down(&dir_f->sem);
 
-	rd->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
-	rd->nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);
-	rd->totlen = cpu_to_je32(sizeof(*rd) + namelen);
-	rd->hdr_crc = cpu_to_je32(crc32(0, rd, sizeof(struct jffs2_unknown_node)-4));
-
-	rd->pino = cpu_to_je32(dir_i->i_ino);
-	rd->version = cpu_to_je32(++dir_f->highest_version);
-	rd->ino = cpu_to_je32(inode->i_ino);
-	rd->mctime = cpu_to_je32(CURRENT_TIME);
+	rd->magic = JFFS2_MAGIC_BITMASK;
+	rd->nodetype = JFFS2_NODETYPE_DIRENT;
+	rd->totlen = sizeof(*rd) + namelen;
+	rd->hdr_crc = crc32(0, rd, sizeof(struct jffs2_unknown_node)-4);
+
+	rd->pino = dir_i->i_ino;
+	rd->version = ++dir_f->highest_version;
+	rd->ino = inode->i_ino;
+	rd->mctime = CURRENT_TIME;
 	rd->nsize = namelen;
 	rd->type = DT_LNK;
-	rd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));
-	rd->name_crc = cpu_to_je32(crc32(0, dentry->d_name.name, namelen));
-
-	fd = jffs2_write_dirent(c, dir_f, rd, dentry->d_name.name, namelen, phys_ofs, &writtenlen);
+	rd->node_crc = crc32(0, rd, sizeof(*rd)-8);
+	rd->name_crc = crc32(0, dentry->d_name.name, namelen);
 
+	fd = jffs2_write_dirent(dir_i, rd, dentry->d_name.name, namelen, phys_ofs, &writtenlen);
+	
+	jffs2_complete_reservation(c);
+	
 	if (IS_ERR(fd)) {
 		/* dirent failed to write. Delete the inode normally 
 		   as if it were the final unlink() */
-		jffs2_complete_reservation(c);
 		jffs2_free_raw_dirent(rd);
 		up(&dir_f->sem);
 		jffs2_clear_inode(inode);
 		return PTR_ERR(fd);
 	}
 
-	dir_i->i_mtime = dir_i->i_ctime = je32_to_cpu(rd->mctime);
+	dir_i->i_mtime = dir_i->i_ctime = rd->mctime;
 
 	jffs2_free_raw_dirent(rd);
 
 	/* Link the fd into the inode's list, obsoleting an old
 	   one if necessary. */
 	jffs2_add_fd_to_list(c, fd, &dir_f->dents);
-
 	up(&dir_f->sem);
-	jffs2_complete_reservation(c);
 
 	d_instantiate(dentry, inode);
 	return 0;
@@ -435,8 +654,8 @@
 	struct jffs2_full_dnode *fn;
 	struct jffs2_full_dirent *fd;
 	int namelen;
-	uint32_t alloclen, phys_ofs;
-	uint32_t writtenlen;
+	__u32 alloclen, phys_ofs;
+	__u32 writtenlen;
 	int ret;
 
 	mode |= S_IFDIR;
@@ -468,15 +687,13 @@
 
 	inode->i_op = &jffs2_dir_inode_operations;
 	inode->i_fop = &jffs2_dir_operations;
-	/* Directories get nlink 2 at start */
-	inode->i_nlink = 2;
 
 	f = JFFS2_INODE_INFO(inode);
 
-	ri->data_crc = cpu_to_je32(0);
-	ri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));
+	ri->data_crc = 0;
+	ri->node_crc = crc32(0, ri, sizeof(*ri)-8);
 	
-	fn = jffs2_write_dnode(c, f, ri, NULL, 0, phys_ofs, &writtenlen);
+	fn = jffs2_write_dnode(inode, ri, NULL, 0, phys_ofs, &writtenlen);
 
 	jffs2_free_raw_inode(ri);
 
@@ -520,43 +737,41 @@
 	dir_f = JFFS2_INODE_INFO(dir_i);
 	down(&dir_f->sem);
 
-	rd->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
-	rd->nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);
-	rd->totlen = cpu_to_je32(sizeof(*rd) + namelen);
-	rd->hdr_crc = cpu_to_je32(crc32(0, rd, sizeof(struct jffs2_unknown_node)-4));
-
-	rd->pino = cpu_to_je32(dir_i->i_ino);
-	rd->version = cpu_to_je32(++dir_f->highest_version);
-	rd->ino = cpu_to_je32(inode->i_ino);
-	rd->mctime = cpu_to_je32(CURRENT_TIME);
+	rd->magic = JFFS2_MAGIC_BITMASK;
+	rd->nodetype = JFFS2_NODETYPE_DIRENT;
+	rd->totlen = sizeof(*rd) + namelen;
+	rd->hdr_crc = crc32(0, rd, sizeof(struct jffs2_unknown_node)-4);
+
+	rd->pino = dir_i->i_ino;
+	rd->version = ++dir_f->highest_version;
+	rd->ino = inode->i_ino;
+	rd->mctime = CURRENT_TIME;
 	rd->nsize = namelen;
 	rd->type = DT_DIR;
-	rd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));
-	rd->name_crc = cpu_to_je32(crc32(0, dentry->d_name.name, namelen));
+	rd->node_crc = crc32(0, rd, sizeof(*rd)-8);
+	rd->name_crc = crc32(0, dentry->d_name.name, namelen);
 
-	fd = jffs2_write_dirent(c, dir_f, rd, dentry->d_name.name, namelen, phys_ofs, &writtenlen);
+	fd = jffs2_write_dirent(dir_i, rd, dentry->d_name.name, namelen, phys_ofs, &writtenlen);
+	
+	jffs2_complete_reservation(c);
 	
 	if (IS_ERR(fd)) {
 		/* dirent failed to write. Delete the inode normally 
 		   as if it were the final unlink() */
-		jffs2_complete_reservation(c);
 		jffs2_free_raw_dirent(rd);
 		up(&dir_f->sem);
 		jffs2_clear_inode(inode);
 		return PTR_ERR(fd);
 	}
 
-	dir_i->i_mtime = dir_i->i_ctime = je32_to_cpu(rd->mctime);
-	dir_i->i_nlink++;
+	dir_i->i_mtime = dir_i->i_ctime = rd->mctime;
 
 	jffs2_free_raw_dirent(rd);
 
 	/* Link the fd into the inode's list, obsoleting an old
 	   one if necessary. */
 	jffs2_add_fd_to_list(c, fd, &dir_f->dents);
-
 	up(&dir_f->sem);
-	jffs2_complete_reservation(c);
 
 	d_instantiate(dentry, inode);
 	return 0;
@@ -566,16 +781,12 @@
 {
 	struct jffs2_inode_info *f = JFFS2_INODE_INFO(dentry->d_inode);
 	struct jffs2_full_dirent *fd;
-	int ret;
 
 	for (fd = f->dents ; fd; fd = fd->next) {
 		if (fd->ino)
 			return -ENOTEMPTY;
 	}
-	ret = jffs2_unlink(dir_i, dentry);
-	if (!ret)
-		dir_i->i_nlink--;
-	return ret;
+	return jffs2_unlink(dir_i, dentry);
 }
 
 static int jffs2_mknod (struct inode *dir_i, struct dentry *dentry, int mode, int rdev)
@@ -590,8 +801,8 @@
 	int namelen;
 	unsigned short dev;
 	int devlen = 0;
-	uint32_t alloclen, phys_ofs;
-	uint32_t writtenlen;
+	__u32 alloclen, phys_ofs;
+	__u32 writtenlen;
 	int ret;
 
 	ri = jffs2_alloc_raw_inode();
@@ -601,7 +812,7 @@
 	c = JFFS2_SB_INFO(dir_i->i_sb);
 	
 	if (S_ISBLK(mode) || S_ISCHR(mode)) {
-		dev = (MAJOR(rdev) << 8) | MINOR(rdev);
+		dev = (MAJOR(to_kdev_t(rdev)) << 8) | MINOR(to_kdev_t(rdev));
 		devlen = sizeof(dev);
 	}
 	
@@ -628,15 +839,15 @@
 
 	f = JFFS2_INODE_INFO(inode);
 
-	ri->dsize = ri->csize = cpu_to_je32(devlen);
-	ri->totlen = cpu_to_je32(sizeof(*ri) + devlen);
-	ri->hdr_crc = cpu_to_je32(crc32(0, ri, sizeof(struct jffs2_unknown_node)-4));
+	ri->dsize = ri->csize = devlen;
+	ri->totlen = sizeof(*ri) + ri->csize;
+	ri->hdr_crc = crc32(0, ri, sizeof(struct jffs2_unknown_node)-4);
 
 	ri->compr = JFFS2_COMPR_NONE;
-	ri->data_crc = cpu_to_je32(crc32(0, &dev, devlen));
-	ri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));
+	ri->data_crc = crc32(0, &dev, devlen);
+	ri->node_crc = crc32(0, ri, sizeof(*ri)-8);
 	
-	fn = jffs2_write_dnode(c, f, ri, (char *)&dev, devlen, phys_ofs, &writtenlen);
+	fn = jffs2_write_dnode(inode, ri, (char *)&dev, devlen, phys_ofs, &writtenlen);
 
 	jffs2_free_raw_inode(ri);
 
@@ -680,45 +891,44 @@
 	dir_f = JFFS2_INODE_INFO(dir_i);
 	down(&dir_f->sem);
 
-	rd->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
-	rd->nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);
-	rd->totlen = cpu_to_je32(sizeof(*rd) + namelen);
-	rd->hdr_crc = cpu_to_je32(crc32(0, rd, sizeof(struct jffs2_unknown_node)-4));
-
-	rd->pino = cpu_to_je32(dir_i->i_ino);
-	rd->version = cpu_to_je32(++dir_f->highest_version);
-	rd->ino = cpu_to_je32(inode->i_ino);
-	rd->mctime = cpu_to_je32(CURRENT_TIME);
+	rd->magic = JFFS2_MAGIC_BITMASK;
+	rd->nodetype = JFFS2_NODETYPE_DIRENT;
+	rd->totlen = sizeof(*rd) + namelen;
+	rd->hdr_crc = crc32(0, rd, sizeof(struct jffs2_unknown_node)-4);
+
+	rd->pino = dir_i->i_ino;
+	rd->version = ++dir_f->highest_version;
+	rd->ino = inode->i_ino;
+	rd->mctime = CURRENT_TIME;
 	rd->nsize = namelen;
 
 	/* XXX: This is ugly. */
 	rd->type = (mode & S_IFMT) >> 12;
 
-	rd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));
-	rd->name_crc = cpu_to_je32(crc32(0, dentry->d_name.name, namelen));
+	rd->node_crc = crc32(0, rd, sizeof(*rd)-8);
+	rd->name_crc = crc32(0, dentry->d_name.name, namelen);
 
-	fd = jffs2_write_dirent(c, dir_f, rd, dentry->d_name.name, namelen, phys_ofs, &writtenlen);
+	fd = jffs2_write_dirent(dir_i, rd, dentry->d_name.name, namelen, phys_ofs, &writtenlen);
+	
+	jffs2_complete_reservation(c);
 	
 	if (IS_ERR(fd)) {
 		/* dirent failed to write. Delete the inode normally 
 		   as if it were the final unlink() */
-		jffs2_complete_reservation(c);
 		jffs2_free_raw_dirent(rd);
 		up(&dir_f->sem);
 		jffs2_clear_inode(inode);
 		return PTR_ERR(fd);
 	}
 
-	dir_i->i_mtime = dir_i->i_ctime = je32_to_cpu(rd->mctime);
+	dir_i->i_mtime = dir_i->i_ctime = rd->mctime;
 
 	jffs2_free_raw_dirent(rd);
 
 	/* Link the fd into the inode's list, obsoleting an old
 	   one if necessary. */
 	jffs2_add_fd_to_list(c, fd, &dir_f->dents);
-
 	up(&dir_f->sem);
-	jffs2_complete_reservation(c);
 
 	d_instantiate(dentry, inode);
 
@@ -729,9 +939,7 @@
                         struct inode *new_dir_i, struct dentry *new_dentry)
 {
 	int ret;
-	struct jffs2_sb_info *c = JFFS2_SB_INFO(old_dir_i->i_sb);
 	struct jffs2_inode_info *victim_f = NULL;
-	uint8_t type;
 
 	/* The VFS will check for us and prevent trying to rename a 
 	 * file over a directory and vice versa, but if it's a directory,
@@ -760,15 +968,7 @@
 	*/
 
 	/* Make a hard link */
-	
-	/* XXX: This is ugly */
-	type = (old_dentry->d_inode->i_mode & S_IFMT) >> 12;
-	if (!type) type = DT_REG;
-
-	ret = jffs2_do_link(c, JFFS2_INODE_INFO(new_dir_i), 
-			    old_dentry->d_inode->i_ino, type,
-			    new_dentry->d_name.name, new_dentry->d_name.len);
-
+	ret = jffs2_do_link(old_dentry, new_dir_i, new_dentry, 1);
 	if (ret)
 		return ret;
 
@@ -784,36 +984,21 @@
 		}
 	}
 
-	/* If it was a directory we moved, and there was no victim, 
-	   increase i_nlink on its new parent */
-	if (S_ISDIR(old_dentry->d_inode->i_mode) && !victim_f)
-		new_dir_i->i_nlink++;
-
 	/* Unlink the original */
-	ret = jffs2_do_unlink(c, JFFS2_INODE_INFO(old_dir_i), 
-		      old_dentry->d_name.name, old_dentry->d_name.len, NULL);
-
-	/* We don't touch inode->i_nlink */
-
+	ret = jffs2_do_unlink(old_dir_i, old_dentry, 1);
+	
 	if (ret) {
 		/* Oh shit. We really ought to make a single node which can do both atomically */
 		struct jffs2_inode_info *f = JFFS2_INODE_INFO(old_dentry->d_inode);
 		down(&f->sem);
-		old_dentry->d_inode->i_nlink++;
-		if (f->inocache)
-			f->inocache->nlink++;
+		old_dentry->d_inode->i_nlink = f->inocache->nlink++;
 		up(&f->sem);
-
+		       
 		printk(KERN_NOTICE "jffs2_rename(): Link succeeded, unlink failed (err %d). You now have a hard link\n", ret);
 		/* Might as well let the VFS know */
 		d_instantiate(new_dentry, old_dentry->d_inode);
 		atomic_inc(&old_dentry->d_inode->i_count);
-		return ret;
 	}
-
-	if (S_ISDIR(old_dentry->d_inode->i_mode))
-		old_dir_i->i_nlink--;
-
-	return 0;
+	return ret;
 }
 
diff -Nur linux/fs/jffs2/ecos/ChangeLog /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/ChangeLog
--- linux/fs/jffs2/ecos/ChangeLog	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/ChangeLog	1970-01-01 07:00:00.000000000 +0700
@@ -1,198 +0,0 @@
-2002-05-20  Jonathan Larmour  <jlarmour@redhat.com>
-
-	* src/LICENCE: New file. Contains license for JFFS2, now GPL+exception.
-	* src/background.c: Point at LICENSE file instead of existing text.
-	* src/build.c: Ditto.
-	* src/compr.c: Ditto.
-	* src/compr_rtime.c: Ditto.
-	* src/compr_rubin.c: Ditto.
-	* src/compr_zlib.c: Ditto.
-	* src/dir-ecos.c: Ditto.
-	* src/erase.c: Ditto.
-	* src/file-ecos.c: Ditto.
-	* src/gc.c: Ditto.
-	* src/jffs2.h: Ditto.
-	* src/list.h: Ditto.
-	* src/malloc-ecos.c: Ditto.
-	* src/nodelist.c: Ditto.
-	* src/nodelist.h: Ditto.
-	* src/nodemgmt.c: Ditto.
-	* src/os-ecos.h: Ditto.
-	* src/pushpull.h: Ditto.
-	* src/read.c: Ditto.
-	* src/readinode.c: Ditto.
-	* src/scan.c: Ditto.
-	* src/write.c: Ditto.
-
-2002-01-28  David Woodhouse  <dwmw2@cambridge.redhat.com>
-
-	* src/super-ecos.c: Removed.
-	* src/jffs2.c: Merge jffs2_write_super() and jffs2_put_super() into
-	the routines from which	they were called, put jffs2_read_super()
-	in as a static function with a view to doing same RSN.
-	* src/jffs2port.h: Remove prototypes of functions that died.
-	* cdl/jffs2.cdl: Remove super-ecos.c
-	* src/dir-ecos.c src/write.c: Increase highest_version _before_
-	assigning to new node, not after.
-	
-2002-01-27  David Woodhouse  <dwmw2@cambridge.redhat.com>
-
-	* src/read.c (jffs2_read_inode_range): Deal correctly with
-	non-page-aligned read requests. We have to deal with the 
-	case where we want to read from somewhere other than the
-	beginning of a frag. 
-	* src/jffs2.c (jffs2_fo_read): Use jffs2_read_inode_range
-	instead of jffs2_readpage.
-
-2002-01-25  Jonathan Larmour  <jlarmour@redhat.com>
-
-	* cdl/jffs2.cdl: We want CYGPKG_IO_FILEIO_INODE.
-	* src/dir-ecos.c (jffs2_symlink): Remove. eCos doesn't support symlinks.
-	(jffs2_mknod): Similar.
-	(jffs2_mkdir): Don't call d_instantiate - its a nop.
-	(jffs2_rename): Ditto.
-	* src/file-ecos.c (jffs2_commit_write): Don't set blocks.
-	* src/jffs2.c (jffs2_flash_writev): Rewrite to only write aligned
-	quantities to flash.
-	* src/jffs2port.h: Lots of decrufting.
-	* src/os-ecos.h: Ditto (a bit).
-	* src/readinode.c (jffs2_read_inode): Don't set blocks/blksize in inode.
-	* src/write.c (jffs2_new_inode): Ditto when __ECOS.
-	(jffs2_write_dnode): don't call writev with extra vectors
-	unnecessarily.
-	* src/super-ecos.c (jffs2_statfs): Remove - unused.
-
-2002-01-25  David Woodhouse  <dwmw2@cambridge.redhat.com>
-
-	* src/super-ecos.c: Cruftectomy.
-	* src/compr*.[ch] src/pushpull.h: Namespace cleanups merged from
-	mainstream sources. Bit push functions made inline.
-	* src/pushpull.c: Removed.
-	* cdl/jffs2.c: Remove reference to pushpull.c
-	* src/file-ecos.c: Cruftectomy. Lots of unused stuff here.
-	* src/jffs2.c src/jffs2port.h: Remove some functions from jffs2.c
-	which are no longer used, move some others to jffs2port.h as
-	inline functions so they don't pollute the namespace.
-
-2002-01-24  Jonathan Larmour  <jlarmour@redhat.com>
-
-	* tests/fileio1.c: Check in listdir that the number of dirents is
-	correct, taking into account existing files in case it's live.
-
-	* src/dir-ecos.c (jffs2_readdir): move to....
-
-	* src/jffs2.c (jffs2_fo_dirread): here. And fix the return code
-	in the process so it now works.
-	(filldir): Make inline and simpler.
-	* src/jffs2port.h: remove filldir related stuff.
-
-2002-01-24  David Woodhouse  <dwmw2@cambridge.redhat.com>
-
-	* src/dir-ecos.c: Cruftectomy. Remove most of the stuff that was
-	commented out. Remove jffs2_do_{create,link,unlink} to write.c
-	* src/write.c: Add jffs2_do_{create,link,unlink} as in mainline.
-	* src/nodelist.h: Prototypes for the above.
-	* src/jffs2port.h: Don't include <pkgconf/kernel.h>. 
-	
-2002-01-23  Jonathan Larmour  <jlarmour@redhat.com>
-
-	* src/jffs2.c (jffs2_mount): Allow multiple FSs, and integration
-	with flash block device.
-	(jffs2_flash_read): Use flash block device.
-	(jffs2_flash_erase): Ditto.
-	(jffs2_flash_write): Ditto.
-	(do_flash_init): Remove - now done by block device layer
-	* src/list.h: Remove and reimplement from scratch to avoid GPL.
-	* src/os-ecos.h: Keep flash block dev handle in superblock.
-	eCos does support obsoleting as it isn't NAND only.
-	* src/dir-ecos.c (jffs2_readdir): Return correct value on success.
-	Merge in changes mutatis mutandis from between v1.49 and v1.51 of
-	dir.c in main repository.
-	* cdl/jffs2.cdl: CYGPKG_MEMALLOC more accurately CYGINT_ISO_MALLOC.
-	Only jffs2.c needs to be in libextras.a
-	Requires Flash block devices as an alternative for hardcoding
-	the sector size, flash size and base address.
-	* src/super-ecos.c (jffs2_read_super): Use flash block device for
-	sector and flash sizes.
-	* tests/fileio1.c: mount using block device (defined by CDL).
-	No need to init here - done by flash block device layer.
-	
-2002-01-21  David Woodhouse  <dwmw2@cambridge.redhat.com>
-
-	* src/read.c: Obtain inode lock around reading symlink target.
-	* src/dir-ecos.c: Fix the long-standing up() without down() in
-	jffs2_readdir() when only the '.' and '..' entries are read, from
-	v1.52 of master dir.c. Merge copyright date change from v1.50 - note
-	that the portability cleanups from v1.51 aren't yet merged.
-	* src/os-ecos.h: Add jffs2_can_mark_obsolete() and the macros
-	for getting at generic inode fields from a struct jffs2_inode_info*
-	* src/nodemgmt.c: Remove an #ifndef __ECOS and use 
-	jffs2_can_mark_obsolete() instead.
-	* src/jffs2port.h: up() is cyg_drv_mutex_unlock() not _release()
-	* src/gc.c: Merge portability cleanups - get rid of a lot of
-	references to 'struct inode'. Also include the attempt at NAND
-	support in jffs2_garbage_collect_deletion_dirent().
-	
-2002-01-11  David Woodhouse  <dwmw2@cambridge.redhat.com>
-
-	* src/jffs2port.h: Switch semaphore emulation to cyg_drv_mutex_t,
-	remove some kernel includes which seem gratuitous.
-	* cdl/jffs2.cdl: Require CYGPKG_MEMALLOC
-	* src/compr_zlib.c src/compr.c: Merge changes from mainline code
-	to make mkfs.jffs2 compile again.
-	
-2002-01-10  David Woodhouse  <dwmw2@cambridge.redhat.com>
-
-	* src/jffs2.c: The 'mode' arg passed to jffs2_open() shouldn't
-	have been called 'mode'. It's 'oflags'. You have to make up a 
-	mode for the newly-created file yourself.
-	* src/nodelist.h src/read.c: Fix jffs2_getlink() so it takes
-	portable arguments, not a dentry. Move it to read.c and symlink.c
-	becomes obsolete.
-	* src/symlink-ecos.c: Removed.
-	* cdl/jffs2.cdl: Remove symlink-ecos.c
-
-2002-01-09  David Woodhouse  <dwmw2@cambridge.redhat.com>
-
-	* Import updated JFFS2 sources into eCos tree.
-
-2000-08-28  Dominic Ostrowski (dominic.ostrowski@3glab.com)
-
-        * started on port of JFFS2 using ramfs as a template
-	
-//===========================================================================
-//####ECOSGPLCOPYRIGHTBEGIN####
-// -------------------------------------------
-// This file is part of eCos, the Embedded Configurable Operating System.
-// Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
-//
-// eCos is free software; you can redistribute it and/or modify it under
-// the terms of the GNU General Public License as published by the Free
-// Software Foundation; either version 2 or (at your option) any later version.
-//
-// eCos is distributed in the hope that it will be useful, but WITHOUT ANY
-// WARRANTY; without even the implied warranty of MERCHANTABILITY or
-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-// for more details.
-//
-// You should have received a copy of the GNU General Public License along
-// with eCos; if not, write to the Free Software Foundation, Inc.,
-// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
-//
-// As a special exception, if other files instantiate templates or use macros
-// or inline functions from this file, or you compile this file and link it
-// with other works to produce a work based on this file, this file does not
-// by itself cause the resulting work to be covered by the GNU General Public
-// License. However the source code for this file must still be made available
-// in accordance with section (3) of the GNU General Public License.
-//
-// This exception does not invalidate any other reasons why a work based on
-// this file might be covered by the GNU General Public License.
-//
-// Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
-// at http://sources.redhat.com/ecos/ecos-license/
-// -------------------------------------------
-//####ECOSGPLCOPYRIGHTEND####
-//===========================================================================
-	
-
diff -Nur linux/fs/jffs2/ecos/cdl/jffs2.cdl /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/cdl/jffs2.cdl
--- linux/fs/jffs2/ecos/cdl/jffs2.cdl	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/cdl/jffs2.cdl	1970-01-01 07:00:00.000000000 +0700
@@ -1,119 +0,0 @@
-# ====================================================================
-#
-#      jffs2.cdl
-#
-#      JFFS2 Filesystem configuration data
-#
-# ====================================================================
-#####ECOSGPLCOPYRIGHTBEGIN####
-## -------------------------------------------
-## This file is part of eCos, the Embedded Configurable Operating System.
-## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
-##
-## eCos is free software; you can redistribute it and/or modify it under
-## the terms of the GNU General Public License as published by the Free
-## Software Foundation; either version 2 or (at your option) any later version.
-##
-## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
-## WARRANTY; without even the implied warranty of MERCHANTABILITY or
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-## for more details.
-##
-## You should have received a copy of the GNU General Public License along
-## with eCos; if not, write to the Free Software Foundation, Inc.,
-## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
-##
-## As a special exception, if other files instantiate templates or use macros
-## or inline functions from this file, or you compile this file and link it
-## with other works to produce a work based on this file, this file does not
-## by itself cause the resulting work to be covered by the GNU General Public
-## License. However the source code for this file must still be made available
-## in accordance with section (3) of the GNU General Public License.
-##
-## This exception does not invalidate any other reasons why a work based on
-## this file might be covered by the GNU General Public License.
-##
-## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
-## at http://sources.redhat.com/ecos/ecos-license/
-## -------------------------------------------
-#####ECOSGPLCOPYRIGHTEND####
-# ====================================================================
-######DESCRIPTIONBEGIN####
-#
-# Author(s):      David Woodhouse, Dominic Ostrowski
-# Original data:  ported from JFFS2 by David Woodhouse
-# Contributors:   dominic.ostrowski@3glab.com
-# Date:           2000-08-28
-#
-#####DESCRIPTIONEND####
-#
-# ====================================================================
-
-cdl_package CYGPKG_FS_JFFS2 {
-    display        "JFFS2 filesystem"
-    doc            doc/index.html
-    include_dir    cyg/jffs2
-
-    requires       CYGPKG_IO_FILEIO
-    requires       CYGPKG_IO_FLASH
-    requires       CYGPKG_COMPRESS_ZLIB
-    requires       CYGINT_ISO_MALLOC
-
-    requires       CYGPKG_ISOINFRA
-    requires       CYGPKG_ERROR
-    requires       CYGINT_ISO_ERRNO
-    requires       CYGINT_ISO_ERRNO_CODES
-    requires       CYGPKG_IO_FLASH_BLOCK_DEVICE
-    requires       CYGPKG_IO_FILEIO_INODE
-
-    compile        -library=libextras.a fs-ecos.c
-    compile        build.c scan.c malloc-ecos.c nodelist.c crc32.c nodemgmt.c readinode.c erase.c dir-ecos.c write.c gc.c read.c compr.c compr_zlib.c compr_rtime.c compr_rubin.c file-ecos.c
-
-    cdl_option CYGPKG_FS_JFFS2_CFLAGS_ADD {
-	display "Additional compiler flags"
-	flavor  data
-	no_define
-	# We add -D__ECOS to trigger eCos-specific code in places.
-	# We add -Werror because I find it useful.
-	default_value { "-D__ECOS -Werror" }
-	description   "
-	    This option modifies the set of compiler flags for
-            building the JFFS2 package.
-            These flags are used in addition
-            to the set of global flags."
-        }
-
-    cdl_option CYGPKG_FS_JFFS2_CFLAGS_REMOVE {
-	display "Suppressed compiler flags"
-	flavor  data
-	no_define
-	# We remove -Wpointer-arith so that some of the hacky Linux-compat code 
-	# (in file.c) compiled. We can probably remove it when that's replaced
-	# properly.
-	default_value { "-Wpointer-arith" }
-	description   "
-	    This option modifies the set of compiler flags for
-            building the JFFS2 package. These flags are removed from
-            the set of global flags if present."
-        }
-
-    # ----------------------------------------------------------------
-    # Tests
-
-    cdl_option CYGPKG_FS_JFFS2_TESTS {
-	display "JFFS2 FS tests"
-	flavor  data
-	no_define
-	calculated { "tests/fileio1.c" }
-            description   "
-                This option specifies the set of tests for the JFFS2 FS package."
-        }
-    
-}
-
-# End of jffs2.cdl
-
-
-
-
-
diff -Nur linux/fs/jffs2/ecos/doc/readme.txt /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/doc/readme.txt
--- linux/fs/jffs2/ecos/doc/readme.txt	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/doc/readme.txt	1970-01-01 07:00:00.000000000 +0700
@@ -1,27 +0,0 @@
-This package is a port of the JFFS2 flash filing system to eCos. It has been
-developed on the Compaq Ipaq, and has not been tested on any other device.
-
-This code is subject to the original licensing terms, and additionally it 
-should be noted that this code is still in an early stage of development. 
-
-As this code will write to flash directly, caution should be exercised in
-its use. It may cause areas of the flash chips essential to the operation of
-the device to become corrupted.
-
-
-Minor modifications are necessary to the the eCos flash drivers 
-
-io/flash/current/src/flash.c
-
-devs/flash/intel/strata/current/src/flash_program_buf.c
-
-to allow byte aligned rather than word aligned writes, and to ensure overwriting an existing
-word is successful (these are supplied in jffs2/current/src).
-
-
-Two test files are included fileio1.c (which performs the same tests as used for eCos RamFS),
-and romfileio1.c (tests as eCos RomFS).
-
-romfileio1.c requires that a jffs2 filesystem image jffs2.img is present at the desired mount point.
-This image was prepared on Linux with the tools originating with JFFS2 source from
-www.infradead.org
\ No newline at end of file
diff -Nur linux/fs/jffs2/ecos/src/dir-ecos.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/src/dir-ecos.c
--- linux/fs/jffs2/ecos/src/dir-ecos.c	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/src/dir-ecos.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,332 +0,0 @@
-/*
- * JFFS2 -- Journalling Flash File System, Version 2.
- *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
- *
- * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
- *
- * For licensing information, see the file 'LICENCE' in this directory.
- *
- * $Id: dir-ecos.c,v 1.1 2002/07/11 10:55:30 dwmw2 Exp $
- *
- */
-
-#include "nodelist.h"
-#include "crc32.h"
-
-/***********************************************************************/
-
-
-/* We keep the dirent list sorted in increasing order of name hash,
-   and we use the same hash function as the dentries. Makes this 
-   nice and simple
-*/
-struct inode *jffs2_lookup(struct inode *dir_i, struct qstr *d_name)
-{
-	struct jffs2_inode_info *dir_f;
-	struct jffs2_sb_info *c;
-	struct jffs2_full_dirent *fd = NULL, *fd_list;
-	uint32_t ino = 0;
-	struct inode *inode = NULL;
-
-	D1(printk(KERN_DEBUG "jffs2_lookup()\n"));
-
-	dir_f = JFFS2_INODE_INFO(dir_i);
-	c = JFFS2_SB_INFO(dir_i->i_sb);
-
-	down(&dir_f->sem);
-
-	/* NB: The 2.2 backport will need to explicitly check for '.' and '..' here */
-	for (fd_list = dir_f->dents; fd_list && fd_list->nhash <= d_name->hash; fd_list = fd_list->next) {
-		if (fd_list->nhash == d_name->hash && 
-		    (!fd || fd_list->version > fd->version) &&
-		    strlen(fd_list->name) == d_name->len &&
-		    !strncmp(fd_list->name, d_name->name, d_name->len)) {
-			fd = fd_list;
-		}
-	}
-	if (fd)
-		ino = fd->ino;
-	up(&dir_f->sem);
-	if (ino) {
-		inode = iget(dir_i->i_sb, ino);
-		if (!inode) {
-			printk(KERN_WARNING "iget() failed for ino #%u\n", ino);
-			return (ERR_PTR(-EIO));
-		}
-	}
-
-	return inode;
-}
-
-/***********************************************************************/
-
-
-
-int jffs2_create(struct inode *dir_i, struct qstr *d_name, int mode,
-                 struct inode **new_i)
-{
-	struct jffs2_raw_inode *ri;
-	struct jffs2_inode_info *f, *dir_f;
-	struct jffs2_sb_info *c;
-	struct inode *inode;
-	int ret;
-
-	ri = jffs2_alloc_raw_inode();
-	if (!ri)
-		return -ENOMEM;
-	
-	c = JFFS2_SB_INFO(dir_i->i_sb);
-
-	D1(printk(KERN_DEBUG "jffs2_create()\n"));
-
-	inode = jffs2_new_inode(dir_i, mode, ri);
-
-	if (IS_ERR(inode)) {
-		D1(printk(KERN_DEBUG "jffs2_new_inode() failed\n"));
-		jffs2_free_raw_inode(ri);
-		return PTR_ERR(inode);
-	}
-
-	f = JFFS2_INODE_INFO(inode);
-	dir_f = JFFS2_INODE_INFO(dir_i);
-
-	ret = jffs2_do_create(c, dir_f, f, ri, 
-			      d_name->name, d_name->len);
-
-	if (ret) {
-		jffs2_clear_inode(inode);
-		make_bad_inode(inode);
-		iput(inode);
-		jffs2_free_raw_inode(ri);
-		return ret;
-	}
-
-	jffs2_free_raw_inode(ri);
-
-	D1(printk(KERN_DEBUG "jffs2_create: Created ino #%lu with mode %o, nlink %d(%d)\n",
-		  inode->i_ino, inode->i_mode, inode->i_nlink, f->inocache->nlink));
-        *new_i = inode;
-	return 0;
-}
-
-/***********************************************************************/
-
-
-int jffs2_unlink(struct inode *dir_i, struct inode *d_inode, struct qstr *d_name)
-{
-	struct jffs2_sb_info *c = JFFS2_SB_INFO(dir_i->i_sb);
-	struct jffs2_inode_info *dir_f = JFFS2_INODE_INFO(dir_i);
-	struct jffs2_inode_info *dead_f = JFFS2_INODE_INFO(d_inode);
-	int ret;
-
-	ret = jffs2_do_unlink(c, dir_f, d_name->name, 
-			       d_name->len, dead_f);
-	d_inode->i_nlink = dead_f->inocache->nlink;
-	return ret;
-}
-/***********************************************************************/
-
-
-int jffs2_link (struct inode *old_d_inode, struct inode *dir_i, struct qstr *d_name)
-{
-	struct jffs2_sb_info *c = JFFS2_SB_INFO(old_d_inode->i_sb);
-	struct jffs2_inode_info *f = JFFS2_INODE_INFO(old_d_inode);
-	struct jffs2_inode_info *dir_f = JFFS2_INODE_INFO(dir_i);
-	int ret;
-
-	/* XXX: This is ugly */
-	uint8_t type = (old_d_inode->i_mode & S_IFMT) >> 12;
-	if (!type) type = DT_REG;
-
-	ret = jffs2_do_link(c, dir_f, f->inocache->ino, type, d_name->name, d_name->len);
-
-	if (!ret) {
-		down(&f->sem);
-		old_d_inode->i_nlink = ++f->inocache->nlink;
-		up(&f->sem);
-	}
-	return ret;
-}
-
-int jffs2_mkdir (struct inode *dir_i, struct qstr *d_name, int mode, struct inode **new_i)
-{
-	struct jffs2_inode_info *f, *dir_f;
-	struct jffs2_sb_info *c;
-	struct inode *inode;
-	struct jffs2_raw_inode *ri;
-	struct jffs2_raw_dirent *rd;
-	struct jffs2_full_dnode *fn;
-	struct jffs2_full_dirent *fd;
-	int namelen;
-	uint32_t alloclen, phys_ofs;
-	uint32_t writtenlen;
-	int ret;
-
-	mode |= S_IFDIR;
-
-	ri = jffs2_alloc_raw_inode();
-	if (!ri)
-		return -ENOMEM;
-	
-	c = JFFS2_SB_INFO(dir_i->i_sb);
-
-	/* Try to reserve enough space for both node and dirent. 
-	 * Just the node will do for now, though 
-	 */
-	namelen = d_name->len;
-	ret = jffs2_reserve_space(c, sizeof(*ri), &phys_ofs, &alloclen, ALLOC_NORMAL);
-
-	if (ret) {
-		jffs2_free_raw_inode(ri);
-		return ret;
-	}
-
-	inode = jffs2_new_inode(dir_i, mode, ri);
-
-	if (IS_ERR(inode)) {
-		jffs2_free_raw_inode(ri);
-		jffs2_complete_reservation(c);
-		return PTR_ERR(inode);
-	}
-
-	f = JFFS2_INODE_INFO(inode);
-
-	ri->data_crc = 0;
-	ri->node_crc = crc32(0, ri, sizeof(*ri)-8);
-	
-	fn = jffs2_write_dnode(c, f, ri, NULL, 0, phys_ofs, &writtenlen);
-
-	jffs2_free_raw_inode(ri);
-
-	if (IS_ERR(fn)) {
-		/* Eeek. Wave bye bye */
-		up(&f->sem);
-		jffs2_complete_reservation(c);
-		jffs2_clear_inode(inode);
-		return PTR_ERR(fn);
-	}
-	/* No data here. Only a metadata node, which will be 
-	   obsoleted by the first data write
-	*/
-	f->metadata = fn;
-	up(&f->sem);
-
-	/* Work out where to put the dirent node now. */
-	writtenlen = PAD(writtenlen);
-	phys_ofs += writtenlen;
-	alloclen -= writtenlen;
-
-	if (alloclen < sizeof(*rd)+namelen) {
-		/* Not enough space left in this chunk. Get some more */
-		jffs2_complete_reservation(c);
-		ret = jffs2_reserve_space(c, sizeof(*rd)+namelen, &phys_ofs, &alloclen, ALLOC_NORMAL);
-		if (ret) {
-			/* Eep. */
-			jffs2_clear_inode(inode);
-			return ret;
-		}
-	}
-	
-	rd = jffs2_alloc_raw_dirent();
-	if (!rd) {
-		/* Argh. Now we treat it like a normal delete */
-		jffs2_complete_reservation(c);
-		jffs2_clear_inode(inode);
-		return -ENOMEM;
-	}
-
-	dir_f = JFFS2_INODE_INFO(dir_i);
-	down(&dir_f->sem);
-
-	rd->magic = JFFS2_MAGIC_BITMASK;
-	rd->nodetype = JFFS2_NODETYPE_DIRENT;
-	rd->totlen = sizeof(*rd) + namelen;
-	rd->hdr_crc = crc32(0, rd, sizeof(struct jffs2_unknown_node)-4);
-
-	rd->pino = dir_i->i_ino;
-	rd->version = ++dir_f->highest_version;
-	rd->ino = inode->i_ino;
-	rd->mctime = CURRENT_TIME;
-	rd->nsize = namelen;
-	rd->type = DT_DIR;
-	rd->node_crc = crc32(0, rd, sizeof(*rd)-8);
-	rd->name_crc = crc32(0, d_name->name, namelen);
-
-	fd = jffs2_write_dirent(c, dir_f, rd, d_name->name, namelen, phys_ofs, &writtenlen);
-	
-	jffs2_complete_reservation(c);
-	jffs2_free_raw_dirent(rd);
-	
-	if (IS_ERR(fd)) {
-		/* dirent failed to write. Delete the inode normally 
-		   as if it were the final unlink() */
-		up(&dir_f->sem);
-		jffs2_clear_inode(inode);
-		return PTR_ERR(fd);
-	}
-
-	/* Link the fd into the inode's list, obsoleting an old
-	   one if necessary. */
-	jffs2_add_fd_to_list(c, fd, &dir_f->dents);
-	up(&dir_f->sem);
-
-	*new_i = inode;
-	return 0;
-}
-
-int jffs2_rmdir (struct inode *dir_i, struct inode *d_inode, struct qstr *d_name)
-{
-	struct jffs2_inode_info *f = JFFS2_INODE_INFO(d_inode);
-	struct jffs2_full_dirent *fd;
-
-	for (fd = f->dents ; fd; fd = fd->next) {
-		if (fd->ino)
-			return EPERM; //-ENOTEMPTY;
-	}
-	return jffs2_unlink(dir_i, d_inode, d_name);
-}
-
-int jffs2_rename (struct inode *old_dir_i, struct inode *d_inode, struct qstr *old_d_name,
-                        struct inode *new_dir_i, struct qstr *new_d_name)
-{
-	int ret;
-	struct jffs2_sb_info *c = JFFS2_SB_INFO(old_dir_i->i_sb);
-	uint8_t type;
-
-	/* XXX: We probably ought to alloc enough space for
-	   both nodes at the same time. Writing the new link, 
-	   then getting -ENOSPC, is quite bad :)
-	*/
-
-	/* Make a hard link */
-	
-	/* XXX: This is ugly */
-	type = (d_inode->i_mode & S_IFMT) >> 12;
-	if (!type) type = DT_REG;
-
-	ret = jffs2_do_link(c, JFFS2_INODE_INFO(new_dir_i), 
-			    d_inode->i_ino, type,
-			    new_d_name->name, new_d_name->len);
-
-	if (ret)
-		return ret;
-
-	/* Unlink the original */
-	ret = jffs2_do_unlink(c, JFFS2_INODE_INFO(old_dir_i), 
-		      old_d_name->name, old_d_name->len, NULL);
-
-	/* We don't touch inode->i_nlink */
-
-	if (ret) {
-		/* Oh shit. We really ought to make a single node which can do both atomically */
-		struct jffs2_inode_info *f = JFFS2_INODE_INFO(d_inode);
-		down(&f->sem);
-		d_inode->i_nlink = f->inocache->nlink++;
-		up(&f->sem);
-
-               printk(KERN_NOTICE "jffs2_rename(): Link succeeded, unlink failed (err %d). You now have a hard link\n", ret);
-	}
-	return ret;
-}
-
diff -Nur linux/fs/jffs2/ecos/src/file-ecos.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/src/file-ecos.c
--- linux/fs/jffs2/ecos/src/file-ecos.c	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/src/file-ecos.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,217 +0,0 @@
-/*
- * JFFS2 -- Journalling Flash File System, Version 2.
- *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
- *
- * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
- *
- * For licensing information, see the file 'LICENCE' in this directory.
- *
- * $Id: file-ecos.c,v 1.1 2002/07/11 10:55:30 dwmw2 Exp $
- *
- */
-
-//#include <linux/kernel.h>
-//#include <linux/mtd/compatmac.h> /* for min() */
-//#include <linux/slab.h>
-//#include <linux/fs.h>
-//#include <linux/pagemap.h>
-#include "jffs2.h"
-#include "nodelist.h"
-#include "crc32.h"
-
-int jffs2_do_readpage_nolock (struct inode *inode, struct page *pg)
-{
-	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
-	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
-	unsigned char *pg_buf;
-	int ret;
-
-	D1(printk(KERN_DEBUG "jffs2_do_readpage_nolock(): ino #%lu, page at offset 0x%lx\n", inode->i_ino, pg->index << PAGE_CACHE_SHIFT));
-
-	if (!PageLocked(pg))
-                PAGE_BUG(pg);
-
-	pg_buf = (char *)kmap(pg);
-	/* FIXME: Can kmap fail? */
-
-	ret = jffs2_read_inode_range(c, f, pg_buf, pg->index << PAGE_CACHE_SHIFT, PAGE_CACHE_SIZE);
-
-	if (ret) {
-		ClearPageUptodate(pg);
-		SetPageError(pg);
-	} else {
-		SetPageUptodate(pg);
-		ClearPageError(pg);
-	}
-
-	flush_dcache_page(pg);
-	kunmap(pg);
-
-	D1(printk(KERN_DEBUG "readpage finished\n"));
-	return 0;
-}
-
-int jffs2_do_readpage_unlock(struct inode *inode, struct page *pg)
-{
-	int ret = jffs2_do_readpage_nolock(inode, pg);
-	UnlockPage(pg);
-	return ret;
-}
-
-
-//int jffs2_readpage (struct file *filp, struct page *pg)
-int jffs2_readpage (struct inode *d_inode, struct page *pg)
-{
-	//	struct jffs2_inode_info *f = JFFS2_INODE_INFO(d_inode);
-	int ret;
-	
-	//	down(&f->sem);
-	ret = jffs2_do_readpage_unlock(d_inode, pg);
-	//	up(&f->sem);
-	return ret;
-}
-
-//int jffs2_prepare_write (struct file *filp, struct page *pg, unsigned start, unsigned end)
-int jffs2_prepare_write (struct inode *d_inode, struct page *pg, unsigned start, unsigned end)
-{
-	struct inode *inode = d_inode;
-	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
-	uint32_t pageofs = pg->index << PAGE_CACHE_SHIFT;
-	int ret = 0;
-
-	down(&f->sem);
-	//D1(printk(KERN_DEBUG "jffs2_prepare_write() nrpages %ld\n", inode->i_mapping->nrpages));
-	D1(printk(KERN_DEBUG "jffs2_prepare_write()\n"));
-
-	if (pageofs > inode->i_size) {
-		/* Make new hole frag from old EOF to new page */
-		struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
-		struct jffs2_raw_inode ri;
-		struct jffs2_full_dnode *fn;
-		uint32_t phys_ofs, alloc_len;
-		
-		D1(printk(KERN_DEBUG "Writing new hole frag 0x%x-0x%x between current EOF and new page\n",
-			  (unsigned int)inode->i_size, pageofs));
-
-		ret = jffs2_reserve_space(c, sizeof(ri), &phys_ofs, &alloc_len, ALLOC_NORMAL);
-		if (ret) {
-			up(&f->sem);
-			return ret;
-		}
-		memset(&ri, 0, sizeof(ri));
-
-		ri.magic = JFFS2_MAGIC_BITMASK;
-		ri.nodetype = JFFS2_NODETYPE_INODE;
-		ri.totlen = sizeof(ri);
-		ri.hdr_crc = crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4);
-
-		ri.ino = f->inocache->ino;
-		ri.version = ++f->highest_version;
-		ri.mode = inode->i_mode;
-		ri.uid = inode->i_uid;
-		ri.gid = inode->i_gid;
-		ri.isize = max((uint32_t)inode->i_size, pageofs);
-		ri.atime = ri.ctime = ri.mtime = CURRENT_TIME;
-		ri.offset = inode->i_size;
-		ri.dsize = pageofs - inode->i_size;
-		ri.csize = 0;
-		ri.compr = JFFS2_COMPR_ZERO;
-		ri.node_crc = crc32(0, &ri, sizeof(ri)-8);
-		ri.data_crc = 0;
-		
-		fn = jffs2_write_dnode(c, f, &ri, NULL, 0, phys_ofs, NULL);
-		jffs2_complete_reservation(c);
-		if (IS_ERR(fn)) {
-			ret = PTR_ERR(fn);
-			up(&f->sem);
-			return ret;
-		}
-		ret = jffs2_add_full_dnode_to_inode(c, f, fn);
-		if (f->metadata) {
-			jffs2_mark_node_obsolete(c, f->metadata->raw);
-			jffs2_free_full_dnode(f->metadata);
-			f->metadata = NULL;
-		}
-		if (ret) {
-			D1(printk(KERN_DEBUG "Eep. add_full_dnode_to_inode() failed in prepare_write, returned %d\n", ret));
-			jffs2_mark_node_obsolete(c, fn->raw);
-			jffs2_free_full_dnode(fn);
-			up(&f->sem);
-			return ret;
-		}
-		inode->i_size = pageofs;
-	}
-	
-
-	/* Read in the page if it wasn't already present */
-        // eCos has no concept of uptodate and by default always reads pages afresh
-	if (!Page_Uptodate(pg) && (start || end < PAGE_SIZE))
-		ret = jffs2_do_readpage_nolock(inode, pg);
-	//D1(printk(KERN_DEBUG "end prepare_write(). nrpages %ld\n", inode->i_mapping->nrpages));
-	D1(printk(KERN_DEBUG "end prepare_write()\n"));
-	up(&f->sem);
-	return ret;
-}
-
-//int jffs2_commit_write (struct file *filp, struct page *pg, unsigned start, unsigned end)
-int jffs2_commit_write (struct inode *d_inode, struct page *pg, unsigned start, unsigned end)
-{
-	/* Actually commit the write from the page cache page we're looking at.
-	 * For now, we write the full page out each time. It sucks, but it's simple
-	 */
-	struct inode *inode = d_inode;
-	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
-	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
-	struct jffs2_raw_inode *ri;
-	int ret = 0;
-	uint32_t writtenlen = 0;
-
-	D1(printk(KERN_DEBUG "jffs2_commit_write(): ino #%lu, page at 0x%lx, range %d-%d\n",
-		  inode->i_ino, pg->index << PAGE_CACHE_SHIFT, start, end));
-
-
-	ri = jffs2_alloc_raw_inode();
-	if (!ri) {
-		D1(printk(KERN_DEBUG "jffs2_commit_write(): Allocation of raw inode failed\n"));
-		return -ENOMEM;
-	}
-
-	/* Set the fields that the generic jffs2_write_inode_range() code can't find */
-	ri->ino = inode->i_ino;
-	ri->mode = inode->i_mode;
-	ri->uid = inode->i_uid;
-	ri->gid = inode->i_gid;
-	ri->isize = (uint32_t)inode->i_size;
-	ri->atime = ri->ctime = ri->mtime = CURRENT_TIME;
-
-	/* We rely on the fact that generic_file_write() currently kmaps the page for us. */
-	ret = jffs2_write_inode_range(c, f, ri, page_address(pg) + start,
-				      (pg->index << PAGE_CACHE_SHIFT) + start, end - start, &writtenlen);
-
-	if (ret) {
-		/* There was an error writing. */
-		SetPageError(pg);
-	}
-
-	if (writtenlen) {
-		if (inode->i_size < (pg->index << PAGE_CACHE_SHIFT) + start + writtenlen) {
-			inode->i_size = (pg->index << PAGE_CACHE_SHIFT) + start + writtenlen;
-			inode->i_ctime = inode->i_mtime = ri->ctime;
-		}
-	}
-
-	jffs2_free_raw_inode(ri);
-
-	if (start+writtenlen < end) {
-		/* generic_file_write has written more to the page cache than we've
-		   actually written to the medium. Mark the page !Uptodate so that 
-		   it gets reread */
-		D1(printk(KERN_DEBUG "jffs2_commit_write(): Not all bytes written. Marking page !uptodate\n"));
-		SetPageError(pg);
-		ClearPageUptodate(pg);
-	}
-
-	D1(printk(KERN_DEBUG "jffs2_commit_write() returning %d\n",writtenlen?writtenlen:ret));
-	return writtenlen?writtenlen:ret;
-}
diff -Nur linux/fs/jffs2/ecos/src/fs-ecos.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/src/fs-ecos.c
--- linux/fs/jffs2/ecos/src/fs-ecos.c	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/src/fs-ecos.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,1923 +0,0 @@
-/*
- * JFFS2 -- Journalling Flash File System, Version 2.
- *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
- *
- * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
- *
- * For licensing information, see the file 'LICENCE' in this directory.
- *
- * $Id: fs-ecos.c,v 1.1 2002/07/11 10:55:30 dwmw2 Exp $
- *
- */
-
-#include "jffs2port.h"
-#include "jffs2.h"
-#include "jffs2_fs_sb.h"
-#include "jffs2_fs_i.h"
-#include "nodelist.h"
-
-#include <errno.h>
-#include <string.h>
-#include <cyg/io/io.h>
-#include <cyg/io/config_keys.h>
-#include <cyg/io/flash.h>
-
-//==========================================================================
-// Forward definitions
-
-// Filesystem operations
-static int jffs2_mount    ( cyg_fstab_entry *fste, cyg_mtab_entry *mte );
-static int jffs2_umount   ( cyg_mtab_entry *mte );
-static int jffs2_open     ( cyg_mtab_entry *mte, cyg_dir dir, const char *name,
-                             int mode,  cyg_file *fte );
-static int jffs2_ops_unlink   ( cyg_mtab_entry *mte, cyg_dir dir, const char *name );
-static int jffs2_ops_mkdir    ( cyg_mtab_entry *mte, cyg_dir dir, const char *name );
-static int jffs2_ops_rmdir    ( cyg_mtab_entry *mte, cyg_dir dir, const char *name );
-static int jffs2_ops_rename   ( cyg_mtab_entry *mte, cyg_dir dir1, const char *name1,
-                             cyg_dir dir2, const char *name2 );
-static int jffs2_ops_link     ( cyg_mtab_entry *mte, cyg_dir dir1, const char *name1,
-                             cyg_dir dir2, const char *name2, int type );
-static int jffs2_opendir  ( cyg_mtab_entry *mte, cyg_dir dir, const char *name,
-                             cyg_file *fte );
-static int jffs2_chdir    ( cyg_mtab_entry *mte, cyg_dir dir, const char *name,
-                             cyg_dir *dir_out );
-static int jffs2_stat     ( cyg_mtab_entry *mte, cyg_dir dir, const char *name,
-                             struct stat *buf);
-static int jffs2_getinfo  ( cyg_mtab_entry *mte, cyg_dir dir, const char *name,
-                             int key, void *buf, int len );
-static int jffs2_setinfo  ( cyg_mtab_entry *mte, cyg_dir dir, const char *name,
-                             int key, void *buf, int len );
-
-// File operations
-static int jffs2_fo_read      (struct CYG_FILE_TAG *fp, struct CYG_UIO_TAG *uio);
-static int jffs2_fo_write     (struct CYG_FILE_TAG *fp, struct CYG_UIO_TAG *uio);
-static int jffs2_fo_lseek     (struct CYG_FILE_TAG *fp, off_t *pos, int whence );
-static int jffs2_fo_ioctl     (struct CYG_FILE_TAG *fp, CYG_ADDRWORD com,
-                                CYG_ADDRWORD data);
-static int jffs2_fo_fsync     (struct CYG_FILE_TAG *fp, int mode );        
-static int jffs2_fo_close     (struct CYG_FILE_TAG *fp);
-static int jffs2_fo_fstat     (struct CYG_FILE_TAG *fp, struct stat *buf );
-static int jffs2_fo_getinfo   (struct CYG_FILE_TAG *fp, int key, void *buf, int len );
-static int jffs2_fo_setinfo   (struct CYG_FILE_TAG *fp, int key, void *buf, int len );
-
-// Directory operations
-static int jffs2_fo_dirread      (struct CYG_FILE_TAG *fp, struct CYG_UIO_TAG *uio);
-static int jffs2_fo_dirlseek     (struct CYG_FILE_TAG *fp, off_t *pos, int whence );
-
-
-//==========================================================================
-// Filesystem table entries
-
-// -------------------------------------------------------------------------
-// Fstab entry.
-// This defines the entry in the filesystem table.
-// For simplicity we use _FILESYSTEM synchronization for all accesses since
-// we should never block in any filesystem operations.
-
-FSTAB_ENTRY( jffs2_fste, "jffs2", 0,
-             CYG_SYNCMODE_FILE_FILESYSTEM|CYG_SYNCMODE_IO_FILESYSTEM,
-             jffs2_mount,
-             jffs2_umount,
-             jffs2_open,
-             jffs2_ops_unlink,
-             jffs2_ops_mkdir,
-             jffs2_ops_rmdir,
-             jffs2_ops_rename,
-             jffs2_ops_link,
-             jffs2_opendir,
-             jffs2_chdir,
-             jffs2_stat,
-             jffs2_getinfo,
-             jffs2_setinfo);
-
-// -------------------------------------------------------------------------
-// File operations.
-// This set of file operations are used for normal open files.
-
-static cyg_fileops jffs2_fileops =
-{
-    jffs2_fo_read,
-    jffs2_fo_write,
-    jffs2_fo_lseek,
-    jffs2_fo_ioctl,
-    cyg_fileio_seltrue,
-    jffs2_fo_fsync,
-    jffs2_fo_close,
-    jffs2_fo_fstat,
-    jffs2_fo_getinfo,
-    jffs2_fo_setinfo
-};
-
-// -------------------------------------------------------------------------
-// Directory file operations.
-// This set of operations are used for open directories. Most entries
-// point to error-returning stub functions. Only the read, lseek and
-// close entries are functional.
-
-static cyg_fileops jffs2_dirops =
-{
-    jffs2_fo_dirread,
-    (cyg_fileop_write *)cyg_fileio_enosys,
-    jffs2_fo_dirlseek,
-    (cyg_fileop_ioctl *)cyg_fileio_enosys,
-    cyg_fileio_seltrue,
-    (cyg_fileop_fsync *)cyg_fileio_enosys,
-    jffs2_fo_close,
-    (cyg_fileop_fstat *)cyg_fileio_enosys,
-    (cyg_fileop_getinfo *)cyg_fileio_enosys,
-    (cyg_fileop_setinfo *)cyg_fileio_enosys
-};
-
-
-//==========================================================================
-// STATIC VARIABLES !!!
-
-static char read_write_buffer[PAGE_CACHE_SIZE]; //avoids malloc when user may be under memory pressure
-static char gc_buffer[PAGE_CACHE_SIZE]; //avoids malloc when user may be under memory pressure
-
-//==========================================================================
-// Directory operations
-
-struct jffs2_dirsearch
-{
-    struct inode        *dir;           // directory to search
-    const char          *path;          // path to follow
-    struct inode        *node;          // Node found
-    const char          *name;          // last name fragment used
-    int                 namelen;        // name fragment length
-    cyg_bool            last;           // last name in path?
-};
-
-typedef struct jffs2_dirsearch jffs2_dirsearch;
-
-//==========================================================================
-// Ref count and nlink management
-
-// -------------------------------------------------------------------------
-// dec_refcnt()
-// Decrment the reference count on an inode. If this makes the ref count
-// zero, then this inode can be freed.
-
-static int dec_refcnt( struct inode *node )
-{
-    int err = ENOERR;
-    node->i_count--;
-
-    // In JFFS2 inode's are temporary in ram structures that are free'd when the usage i_count drops to 0
-    // The i_nlink however is managed by JFFS2 and is unrelated to usage
-    if( node->i_count == 0)
-    {
-        // This inode is not in use, so delete it.
-        iput(node);
-    }
-
-    return err;
-}
-
-// FIXME: This seems like real cruft. Wouldn't it be better just to do the
-// right thing?
-static void icache_evict(struct inode *root_i, struct inode *i) {
-    struct inode *cached_inode;
-    struct inode *next_inode;
-    
-    D2(printf("icache_evict\n"));
-    // If this is an absolute search path from the root,
-    // remove all cached inodes with i_count of zero (these are only 
-    // held where needed for dotdot filepaths)
-    if(i == root_i) {
-        for(cached_inode = root_i; cached_inode != NULL; cached_inode = next_inode) {
-            next_inode = cached_inode->i_cache_next;
-            if (cached_inode->i_count == 0) {
-                cached_inode->i_cache_prev->i_cache_next = cached_inode->i_cache_next; // Prveious entry points ahead of us
-                if (cached_inode->i_cache_next != NULL)
-                    cached_inode->i_cache_next->i_cache_prev = cached_inode->i_cache_prev; // Next entry points behind us
-                jffs2_clear_inode(cached_inode);
-                D2(printf("free icache_evict inode %x $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n", cached_inode));
-                free(cached_inode);
-            }
-        }
-    }
-}
-
-//==========================================================================
-// Directory search
-
-// -------------------------------------------------------------------------
-// init_dirsearch()
-// Initialize a dirsearch object to start a search
-
-static void init_dirsearch( jffs2_dirsearch *ds,
-                            struct inode *dir,
-                            const char *name)
-{
-    D2(printf("init_dirsearch name = %s\n", name));
-    D2(printf("init_dirsearch dir = %x\n", dir));
-    ds->dir      = dir;
-    ds->path     = name;
-    ds->node     = dir;
-    ds->name     = name;
-    ds->namelen  = 0;
-    ds->last     = false;    
-}
-
-
-// -------------------------------------------------------------------------
-// find_entry()
-// Search a single directory for the next name in a path and update the
-// dirsearch object appropriately.
-
-static int find_entry( jffs2_dirsearch *ds )
-{
-    unsigned long hash;
-    struct qstr this;
-    unsigned int c;
-    const char * hashname;
-
-    struct inode *dir = ds->dir;
-    const char *name = ds->path;
-    const char *n = name;
-    char namelen = 0;
-    struct inode *d;
-    
-    D2(printf("find_entry\n"));
-
-    // check that we really have a directory
-    if( !S_ISDIR(dir->i_mode) )
-        return ENOTDIR;
-
-    // Isolate the next element of the path name. 
-    while( *n != '\0' && *n != '/' )
-        n++, namelen++;
-
-    // If we terminated on a NUL, set last flag.
-    if( *n == '\0' ) 
-        ds->last = true;
-
-    // update name in dirsearch object
-    ds->name = name;
-    ds->namelen = namelen;
-    
-    if (name[0] == '.') switch (namelen) {
-        default:
-            break;
-        case 2:
-            // Dot followed by not Dot, treat as any other name	
-            if (name[1] != '.')
-                break;
-            // Dot Dot 
-            // Move back up the search path
-            D2(printf("find_entry found ..\n"));
-            ds->node = ds->dir->i_parent;
-            if(ds->dir->i_count == 0) {
-                iput(ds->dir); // This inode may be evicted
-                ds->dir = NULL;
-            }
-            return ENOERR;
-        case 1:
-            // Dot is consumed
-            D2(printf("find_entry found .\n"));
-            ds->node = ds->dir;
-            return ENOERR;
-    }
-
-    // Here we have the name and its length set up.
-    // Search the directory for a matching entry
-
-    hashname = name;
-    this.name = hashname;
-    c = *(const unsigned char *)hashname;
-
-    hash = init_name_hash();
-    do {
-        hashname++;
-        hash = partial_name_hash(c, hash);
-        c = *(const unsigned char *)hashname;
-    } while (c && (c != '/'));
-    this.len = hashname - (const char *) this.name;
-    this.hash = end_name_hash(hash);
-
-    D2(printf("find_entry for name = %s\n", ds->path));
-    d = jffs2_lookup(dir, &this);
-    D2(printf("find_entry got dir = %x\n", d));
-
-    if( d == NULL )
-        return ENOENT;
-
-    // The back path for dotdot to follow
-    d->i_parent = dir; 
-    // pass back the node we have found
-    ds->node = d;
-
-    return ENOERR;
-
-}
-
-// -------------------------------------------------------------------------
-// jffs2_find()
-// Main interface to directory search code. This is used in all file
-// level operations to locate the object named by the pathname.
-
-static int jffs2_find( jffs2_dirsearch *d )
-{
-    int err;
-
-    D2(printf("jffs2_find for path =%s\n", d->path));
-    // Short circuit empty paths
-    if( *(d->path) == '\0' )
-        return ENOERR;
-
-    // iterate down directory tree until we find the object
-    // we want.
-    for(;;)
-    {
-        err = find_entry( d );
-
-        if( err != ENOERR )
-            return err;
-
-        if( d->last )
-            return ENOERR;
-
-        // every inode traversed in the find is temporary and should be free'd
-        //iput(d->dir);
-
-        // Update dirsearch object to search next directory.
-        d->dir = d->node;
-        d->path += d->namelen;
-        if( *(d->path) == '/' ) d->path++; // skip dirname separators
-    }
-}
-
-//==========================================================================
-// Pathconf support
-// This function provides support for pathconf() and fpathconf().
-
-static int jffs2_pathconf( struct inode *node, struct cyg_pathconf_info *info )
-{
-    int err = ENOERR;
-    D2(printf("jffs2_pathconf\n"));
-    
-    switch( info->name )
-    {
-    case _PC_LINK_MAX:
-        info->value = LINK_MAX;
-        break;
-        
-    case _PC_MAX_CANON:
-        info->value = -1;       // not supported
-        err = EINVAL;
-        break;
-        
-    case _PC_MAX_INPUT:
-        info->value = -1;       // not supported
-        err = EINVAL;        
-        break;
-        
-    case _PC_NAME_MAX:
-        info->value = NAME_MAX;
-        break;
-        
-    case _PC_PATH_MAX:
-        info->value = PATH_MAX;
-        break;        
-
-    case _PC_PIPE_BUF:
-        info->value = -1;       // not supported
-        err = EINVAL;        
-        break;        
-
-        
-    case _PC_ASYNC_IO:
-        info->value = -1;       // not supported
-        err = EINVAL;        
-        break;
-        
-    case _PC_CHOWN_RESTRICTED:
-        info->value = -1;       // not supported
-        err = EINVAL;
-        break;
-        
-    case _PC_NO_TRUNC:
-        info->value = 0;
-        break;
-        
-    case _PC_PRIO_IO:
-        info->value = 0;
-        break;
-        
-    case _PC_SYNC_IO:
-        info->value = 0;
-        break;
-        
-    case _PC_VDISABLE:
-        info->value = -1;       // not supported
-        err = EINVAL;        
-        break;
-        
-    default:
-        err = EINVAL;
-        break;
-    }
-
-    return err;
-}
-
-//==========================================================================
-// Filesystem operations
-
-// -------------------------------------------------------------------------
-// jffs2_mount()
-// Process a mount request. This mainly creates a root for the
-// filesystem.
-static int jffs2_read_super(struct super_block *sb)
-{
-	struct jffs2_sb_info *c;
-	struct inode *root_i;
-        Cyg_ErrNo err;
-        cyg_uint32 len;
-        cyg_io_flash_getconfig_devsize_t ds;
-        cyg_io_flash_getconfig_blocksize_t bs;
-
-	D1(printk(KERN_DEBUG "jffs2: read_super\n"));
-
-	c = JFFS2_SB_INFO(sb);
-	memset(c, 0, sizeof(*c));
-        
-        len = sizeof(ds);
-        err = cyg_io_get_config( sb->s_dev,
-                                 CYG_IO_GET_CONFIG_FLASH_DEVSIZE,
-                                 &ds, &len );
-        if ( err != ENOERR ) {
-            D1(printf("jffs2: cyg_io_get_config failed to get dev size: %d\n",
-                      err));
-            return err;
-        }
-        len = sizeof(bs);
-        bs.offset = 0;
-        err = cyg_io_get_config( sb->s_dev,
-                                 CYG_IO_GET_CONFIG_FLASH_BLOCKSIZE,
-                                 &bs, &len );
-        if ( err != ENOERR ) {
-            D1(printf("jffs2: cyg_io_get_config failed to get block size: %d\n",
-                      err));
-            return err;
-        }
-        
-        c->sector_size = bs.block_size;
-        c->flash_size = ds.dev_size;
-
-	err = jffs2_do_mount_fs(c);
-	if (err)
-		return -err;
-
-	D1(printk(KERN_DEBUG "jffs2_read_super(): Getting root inode\n"));
-	root_i = iget(sb, 1);
-	if (is_bad_inode(root_i)) {
-		D1(printk(KERN_WARNING "get root inode failed\n"));
-		err = EIO;
-		goto out_nodes;
-	}
-
-	D1(printk(KERN_DEBUG "jffs2_read_super(): d_alloc_root()\n"));
-	sb->s_root = d_alloc_root(root_i);
-	if (!sb->s_root) {
-		err = ENOMEM;
-		goto out_root_i;
-	}
-	sb->s_blocksize = PAGE_CACHE_SIZE;
-	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
-	sb->s_magic = JFFS2_SUPER_MAGIC;
-
-	return 0;
-
- out_root_i:
-	iput(root_i);
- out_nodes:
-	jffs2_free_ino_caches(c);
-	jffs2_free_raw_node_refs(c);
-	free(c->blocks);
-
-	return err;
-}
-
-static int jffs2_mount    ( cyg_fstab_entry *fste, cyg_mtab_entry *mte )
-{
-    extern cyg_mtab_entry mtab[], mtab_end;
-    struct super_block *jffs2_sb = NULL;
-    struct jffs2_sb_info *c;
-    cyg_mtab_entry *m;
-    cyg_io_handle_t t;
-    Cyg_ErrNo err;
-
-    D2(printf("jffs2_mount\n"));
-
-    err = cyg_io_lookup( mte->devname, &t );
-    if( err != ENOERR )
-        return -err;
-
-    // Iterate through the mount table to see if we're mounted
-    // FIXME: this should be done better - perhaps if the superblock
-    // can be stored as an inode in the icache.
-    for( m = &mtab[0]; m != &mtab_end; m++ )
-    {
-        // stop if there are more than the configured maximum
-        if( m-&mtab[0] >= CYGNUM_FILEIO_MTAB_MAX )
-        {
-            m = &mtab_end;
-            break;
-        }
-        if ( m->valid && strcmp( m->fsname, "jffs2" ) == 0 &&
-            strcmp( m->devname, mte->devname) == 0 ) {
-            jffs2_sb = (struct super_block *)m->data;
-        }
-    }
-
-    if ( jffs2_sb == NULL) {
-        jffs2_sb = malloc(sizeof(struct super_block));
-
-        if(jffs2_sb == NULL)
-            return ENOSPC;
-
-	c = JFFS2_SB_INFO(jffs2_sb);
-        memset(jffs2_sb, 0, sizeof(struct super_block));
-        jffs2_sb->s_dev = t;
-
-	err = jffs2_read_super(jffs2_sb);
-
-	if (err) {
-            free(jffs2_sb);
-            return err;
-        }
-
-        jffs2_sb->s_root->i_parent = jffs2_sb->s_root; // points to itself, no dotdot paths above mountpoint
-        jffs2_sb->s_root->i_cache_prev = NULL; // root inode, so always null
-        jffs2_sb->s_root->i_cache_next = NULL;
-        jffs2_sb->s_root->i_count = 1; // Ensures the root inode is always in ram until umount
-    
-        D2(printf("jffs2_mount erasing pending blocks\n"));
-	jffs2_erase_pending_blocks(c);
-	jffs2_mark_erased_blocks(c);
-    }
-    mte->data = (CYG_ADDRWORD)jffs2_sb;
-
-    jffs2_sb->s_mount_count++;
-    mte->root = (cyg_dir)jffs2_sb->s_root;
-    D2(printf("jffs2_mounted superblock at %x\n", mte->root));
-
-    return ENOERR;
-}
-
-// -------------------------------------------------------------------------
-// jffs2_umount()
-// Unmount the filesystem. 
-
-static int jffs2_umount   ( cyg_mtab_entry *mte )
-{
-    struct inode *root = (struct inode *)mte->root;
-    struct super_block *jffs2_sb = root->i_sb;
-    struct jffs2_sb_info *c = JFFS2_SB_INFO(jffs2_sb);
-
-    D2(printf("jffs2_umount\n"));
-
-    // Decrement the mount count
-    jffs2_sb->s_mount_count--;
-
-    // Only really umount if this is the only mount
-    if (jffs2_sb->s_mount_count == 0) {
-
-        // Check for open/inuse root or any cached inodes
-//if( root->i_count != 1 || root->i_cache_next != NULL) // root icount was set to 1 on mount
-        if( root->i_cache_next != NULL) // root icount was set to 1 on mount
-            return EBUSY;
-
-        dec_refcnt(root); // Time to free the root inode
-
-        //Clear root inode
-        //root_i = NULL;
-
-        // Clean up the super block and root inode
-	jffs2_free_ino_caches(c);
-	jffs2_free_raw_node_refs(c);
-	free(c->blocks);
-
-        // Clear root pointer
-        mte->root = CYG_DIR_NULL;
-    
-        mte->fs->data = 0; // fstab entry, visible to all mounts. No current mount
-        // That's all folks.
-        D2(printf("jffs2_umount No current mounts\n"));
-    }
-        
-    return ENOERR;
-}
-
-// -------------------------------------------------------------------------
-// jffs2_open()
-// Open a file for reading or writing.
-
-static int jffs2_open     ( cyg_mtab_entry *mte, cyg_dir dir, const char *name,
-                             int mode,  cyg_file *file )
-{
-
-    jffs2_dirsearch ds;
-    struct inode *node = NULL;
-    int err;
-
-    D2(printf("jffs2_open\n"));
-
-    icache_evict((struct inode *)mte->root, (struct inode *)dir);
-
-    init_dirsearch( &ds, (struct inode *)dir, name );
-    
-    err = jffs2_find( &ds );
-
-    if( err == ENOENT )
-    {
-        if( ds.last && (mode & O_CREAT) )
-        {
-            unsigned long hash;
-            struct qstr this;
-            unsigned int c;
-            const char * hashname;
-
-            // No node there, if the O_CREAT bit is set then we must
-            // create a new one. The dir and name fields of the dirsearch
-            // object will have been updated so we know where to put it.
-
-            hashname = ds.name;
-            this.name = hashname;
-            c = *(const unsigned char *)hashname;
-
-            hash = init_name_hash();
-            do {
-                hashname++;
-                hash = partial_name_hash(c, hash);
-                c = *(const unsigned char *)hashname;
-            } while (c && (c != '/'));
-            this.len = hashname - (const char *) this.name;
-            this.hash = end_name_hash(hash);
-
-            err = jffs2_create(ds.dir, &this, 0644, &node);
-
-            if( err != 0 )
-            {
-                //Possible orphaned inode on the flash - but will be gc'd
-                return err;
-            }
-        
-            err = ENOERR;
-        }
-    }
-    else if( err == ENOERR )
-    {
-        // The node exists. If the O_CREAT and O_EXCL bits are set, we
-        // must fail the open.
-        
-        if( (mode & (O_CREAT|O_EXCL)) == (O_CREAT|O_EXCL) )
-            err = EEXIST;
-        else node = ds.node;
-    }
-    
-    if( err == ENOERR && (mode & O_TRUNC ) )
-    {
-        // If the O_TRUNC bit is set we must clean out the file data.
-
-        node->i_size = 0;
-
-        // Update file times
-        node->i_ctime =
-        node->i_mtime = cyg_timestamp();
-    }
-
-    if( err != ENOERR ) return err;
-
-    // Check that we actually have a file here
-    if( S_ISDIR(node->i_mode) ) return EISDIR;
-
-    node->i_count++;       // Count successful open
-    
-    // Initialize the file object
-    
-    file->f_flag        |= mode & CYG_FILE_MODE_MASK;
-    file->f_type        = CYG_FILE_TYPE_FILE;
-    file->f_ops         = &jffs2_fileops;
-    file->f_offset      = (mode&O_APPEND) ? node->i_size : 0;
-    file->f_data        = (CYG_ADDRWORD)node;  
-    file->f_xops        = 0;
-
-    return ENOERR;
-}
-
-// -------------------------------------------------------------------------
-// jffs2_ops_unlink()
-// Remove a file link from its directory.
-
-static int jffs2_ops_unlink   ( cyg_mtab_entry *mte, cyg_dir dir, const char *name )
-{
-    unsigned long hash;
-    struct qstr this;
-    unsigned int c;
-    const char * hashname;
-    jffs2_dirsearch ds;
-    int err;
-
-    D2(printf("jffs2_ops_unlink\n"));
-
-    icache_evict((struct inode *)mte->root, (struct inode *)dir);
-
-    init_dirsearch( &ds, (struct inode *)dir, name );
-    
-    err = jffs2_find( &ds );
-
-    if( err != ENOERR ) return err;
-
-    // Cannot unlink directories, use rmdir() instead
-    if( S_ISDIR(ds.node->i_mode) )
-        return EPERM;
-
-    // Delete it from its directory
-
-    hashname = ds.name;
-    this.name = hashname;
-    c = *(const unsigned char *)hashname;
-
-    hash = init_name_hash();
-    do {
-        hashname++;
-        hash = partial_name_hash(c, hash);
-        c = *(const unsigned char *)hashname;
-    } while (c && (c != '/'));
-    this.len = hashname - (const char *) this.name;
-    this.hash = end_name_hash(hash);
-
-    err = jffs2_unlink(ds.dir, ds.node, &this);
-    
-    return err;
-}
-
-// -------------------------------------------------------------------------
-// jffs2_ops_mkdir()
-// Create a new directory.
-
-static int jffs2_ops_mkdir    ( cyg_mtab_entry *mte, cyg_dir dir, const char *name )
-{
-    jffs2_dirsearch ds;
-    struct inode *node = NULL;
-    int err;
-
-    D2(printf("jffs2_ops_mkdir\n"));
-
-    icache_evict((struct inode *)mte->root, (struct inode *)dir);
-
-    init_dirsearch( &ds, (struct inode *)dir, name );
-    
-    err = jffs2_find( &ds );
-
-    if( err == ENOENT )
-    {
-        if( ds.last )
-        {
-            unsigned long hash;
-            struct qstr this;
-            unsigned int c;
-            const char * hashname;
-            // The entry does not exist, and it is the last element in
-            // the pathname, so we can create it here.
-
-            hashname = ds.name;
-            this.name = hashname;
-            c = *(const unsigned char *)hashname;
-
-            hash = init_name_hash();
-            do {
-                hashname++;
-                hash = partial_name_hash(c, hash);
-                c = *(const unsigned char *)hashname;
-            } while (c && (c != '/'));
-            this.len = hashname - (const char *) this.name;
-            this.hash = end_name_hash(hash);
-
-            err = jffs2_mkdir(ds.dir, &this, 0, &node);
-
-            if( err != 0 )
-                return ENOSPC;
-
-        }
-        // If this was not the last element, then and intermediate
-        // directory does not exist.
-    }
-    else
-    {
-        // If there we no error, something already exists with that
-        // name, so we cannot create another one.
-        
-        if( err == ENOERR )
-            err = EEXIST;
-    }
-
-    return err;
-}
-
-// -------------------------------------------------------------------------
-// jffs2_ops_rmdir()
-// Remove a directory.
-
-static int jffs2_ops_rmdir    ( cyg_mtab_entry *mte, cyg_dir dir, const char *name )
-{
-    unsigned long hash;
-    struct qstr this;
-    unsigned int c;
-    const char * hashname;
-    jffs2_dirsearch ds;
-    int err;
-
-    D2(printf("jffs2_ops_rmdir\n"));
-
-    icache_evict((struct inode *)mte->root, (struct inode *)dir);
-
-    init_dirsearch( &ds, (struct inode *)dir, name );
-    
-    err = jffs2_find( &ds );
-
-    if( err != ENOERR ) return err;
-
-    // Check that this is actually a directory.
-    if( !S_ISDIR(ds.node->i_mode) )
-        return EPERM;
-
-    // Delete the entry. 
-    hashname = ds.name;
-    this.name = hashname;
-    c = *(const unsigned char *)hashname;
-
-    hash = init_name_hash();
-    do {
-        hashname++;
-        hash = partial_name_hash(c, hash);
-        c = *(const unsigned char *)hashname;
-    } while (c && (c != '/'));
-    this.len = hashname - (const char *) this.name;
-    this.hash = end_name_hash(hash);
-
-    err = jffs2_rmdir(ds.dir, ds.node, &this);
-    
-    return err;
-
-    return ENOERR;
-}
-
-// -------------------------------------------------------------------------
-// jffs2_ops_rename()
-// Rename a file/dir.
-
-static int jffs2_ops_rename   ( cyg_mtab_entry *mte, cyg_dir dir1, const char *name1,
-                             cyg_dir dir2, const char *name2 )
-{
-    unsigned long hash;
-    struct qstr this1,this2;
-    unsigned int c;
-    const char * hashname;
-    jffs2_dirsearch ds1, ds2;
-    int err;
-
-    D2(printf("jffs2_ops_rename\n"));
-
-    init_dirsearch( &ds1, (struct inode *)dir1, name1 );
-    
-    err = jffs2_find( &ds1 );
-
-    if( err != ENOERR ) return err;
-
-    init_dirsearch( &ds2, (struct inode *)dir2, name2 );
-    
-    err = jffs2_find( &ds2 );
-
-    // Allow through renames to non-existent objects.
-    if( ds2.last && err == ENOENT )
-        ds2.node = NULL, err = ENOERR;
-    
-    if( err != ENOERR ) return err;
-
-    // Null rename, just return
-    if( ds1.node == ds2.node )
-        return ENOERR;
-
-    hashname = ds1.name;
-    this1.name = hashname;
-    c = *(const unsigned char *)hashname;
-
-    hash = init_name_hash();
-    do {
-        hashname++;
-        hash = partial_name_hash(c, hash);
-        c = *(const unsigned char *)hashname;
-    } while (c && (c != '/'));
-    this1.len = hashname - (const char *) this1.name;
-    this1.hash = end_name_hash(hash);
-
-    hashname = ds2.name;
-    this2.name = hashname;
-    c = *(const unsigned char *)hashname;
-
-    hash = init_name_hash();
-    do {
-        hashname++;
-        hash = partial_name_hash(c, hash);
-        c = *(const unsigned char *)hashname;
-    } while (c && (c != '/'));
-    this2.len = hashname - (const char *) this2.name;
-    this2.hash = end_name_hash(hash);
-
-    // First deal with any entry that is at the destination
-    if( ds2.node )
-    {
-        // Check that we are renaming like-for-like
-
-        if( !S_ISDIR(ds1.node->i_mode) && S_ISDIR(ds2.node->i_mode) )
-            return EISDIR;
-
-        if( S_ISDIR(ds1.node->i_mode) && !S_ISDIR(ds2.node->i_mode) )
-            return ENOTDIR;
-
-        // Now delete the destination directory entry
-        
-        err = jffs2_unlink(ds2.dir, ds2.node, &this2);
-    
-        if( err != 0 ) return err;
-
-    }
-
-    // Now we know that there is no clashing node at the destination,
-    // make a new direntry at the destination and delete the old entry
-    // at the source.
-
-    err  = jffs2_rename(ds1.dir, ds1.node, &this1, ds2.dir, &this2);
-
-    // Update directory times
-    if( err == 0 )
-        ds1.dir->i_ctime =
-        ds1.dir->i_mtime =
-        ds2.dir->i_ctime =
-        ds2.dir->i_mtime = cyg_timestamp();
-            
-    return err;
-}
-
-// -------------------------------------------------------------------------
-// jffs2_ops_link()
-// Make a new directory entry for a file.
-
-static int jffs2_ops_link     ( cyg_mtab_entry *mte, cyg_dir dir1, const char *name1,
-                             cyg_dir dir2, const char *name2, int type )
-{
-    unsigned long hash;
-    struct qstr this;
-    unsigned int c;
-    const char * hashname;
-    jffs2_dirsearch ds1, ds2;
-    int err;
-
-    D2(printf("jffs2_ops_link\n"));
-
-    // Only do hard links for now in this filesystem
-    if( type != CYG_FSLINK_HARD )
-        return EINVAL;
-    
-    init_dirsearch( &ds1, (struct inode *)dir1, name1 );
-    
-    err = jffs2_find( &ds1 );
-
-    if( err != ENOERR ) return err;
-
-    init_dirsearch( &ds2, (struct inode *)dir2, name2 );
-    
-    err = jffs2_find( &ds2 );
-
-    // Don't allow links to existing objects
-    if( err == ENOERR ) return EEXIST;
-    
-    // Allow through links to non-existing terminal objects
-    if( ds2.last && err == ENOENT )
-        ds2.node = NULL, err = ENOERR;
-
-    if( err != ENOERR ) return err;
-    
-    // Now we know that there is no existing node at the destination,
-    // make a new direntry at the destination.
-
-    hashname = ds2.name;
-    this.name = hashname;
-    c = *(const unsigned char *)hashname;
-
-    hash = init_name_hash();
-    do {
-        hashname++;
-        hash = partial_name_hash(c, hash);
-        c = *(const unsigned char *)hashname;
-    } while (c && (c != '/'));
-    this.len = hashname - (const char *) this.name;
-    this.hash = end_name_hash(hash);
-
-    err = jffs2_link(ds2.dir, ds1.node, &this);
-
-    if( err == 0 )
-        ds1.node->i_ctime =
-        ds2.dir->i_ctime =
-        ds2.dir->i_mtime = cyg_timestamp();
-            
-    return err;
-}
-
-// -------------------------------------------------------------------------
-// jffs2_opendir()
-// Open a directory for reading.
-
-static int jffs2_opendir  ( cyg_mtab_entry *mte, cyg_dir dir, const char *name,
-                             cyg_file *file )
-{
-    jffs2_dirsearch ds;
-    int err;
-
-    D2(printf("jffs2_opendir\n"));
-
-    icache_evict((struct inode *)mte->root, (struct inode *)dir);
-
-    init_dirsearch( &ds, (struct inode *)dir, name );
-    
-    err = jffs2_find( &ds );
-
-    if( err != ENOERR ) return err;
-
-    // check it is really a directory.
-    if( !S_ISDIR(ds.node->i_mode) ) return ENOTDIR;
-
-    ds.node->i_count++;       // Count successful open
-    
-    // Initialize the file object, setting the f_ops field to a
-    // special set of file ops.
-    
-    file->f_type        = CYG_FILE_TYPE_FILE;
-    file->f_ops         = &jffs2_dirops;
-    file->f_offset      = 0;
-    file->f_data        = (CYG_ADDRWORD)ds.node;
-    file->f_xops        = 0;
-
-        
-    return ENOERR;
-
-}
-
-// -------------------------------------------------------------------------
-// jffs2_chdir()
-// Change directory support.
-
-static int jffs2_chdir    ( cyg_mtab_entry *mte, cyg_dir dir, const char *name,
-                             cyg_dir *dir_out )
-{
-    D2(printf("jffs2_chdir\n"));
-
-    if( dir_out != NULL )
-    {
-        // This is a request to get a new directory pointer in
-        // *dir_out.
-
-        jffs2_dirsearch ds;
-        int err;
-
-        icache_evict((struct inode *)mte->root, (struct inode *)dir);
-
-        init_dirsearch( &ds, (struct inode *)dir, name );
-    
-        err = jffs2_find( &ds );
-
-        if( err != ENOERR ) return err;
-
-        // check it is a directory
-        if( !S_ISDIR(ds.node->i_mode) )
-            return ENOTDIR;
-        
-        // Increment ref count to keep this directory in existance
-        // while it is the current cdir.
-        ds.node->i_count++;
-
-        // Pass it out
-        *dir_out = (cyg_dir)ds.node;
-    }
-    else
-    {
-        // If no output dir is required, this means that the mte and
-        // dir arguments are the current cdir setting and we should
-        // forget this fact.
-
-        struct inode *node = (struct inode *)dir;
-
-        // Just decrement directory reference count.
-        dec_refcnt( node );
-    }
-        
-    return ENOERR;
-}
-
-// -------------------------------------------------------------------------
-// jffs2_stat()
-// Get struct stat info for named object.
-
-static int jffs2_stat     ( cyg_mtab_entry *mte, cyg_dir dir, const char *name,
-                             struct stat *buf)
-{
-    jffs2_dirsearch ds;
-    int err;
-
-    D2(printf("jffs2_stat\n"));
-
-    icache_evict((struct inode *)mte->root, (struct inode *)dir);
-
-    init_dirsearch( &ds, (struct inode *)dir, name );
-    
-    err = jffs2_find( &ds );
-
-    if( err != ENOERR ) return err;
-
-    // Fill in the status
-    buf->st_mode        = ds.node->i_mode;
-    buf->st_ino         = (ino_t)ds.node;
-    buf->st_dev         = 0;
-    buf->st_nlink       = ds.node->i_nlink;
-    buf->st_uid         = 0;
-    buf->st_gid         = 0;
-    buf->st_size        = ds.node->i_size;
-    buf->st_atime       = ds.node->i_atime;
-    buf->st_mtime       = ds.node->i_mtime;
-    buf->st_ctime       = ds.node->i_ctime;
-    
-    return err;
-
-    return ENOERR;
-}
-
-// -------------------------------------------------------------------------
-// jffs2_getinfo()
-// Getinfo. Currently only support pathconf().
-
-static int jffs2_getinfo  ( cyg_mtab_entry *mte, cyg_dir dir, const char *name,
-                             int key, void *buf, int len )
-{
-    jffs2_dirsearch ds;
-    int err;
-
-    D2(printf("jffs2_getinfo\n"));
-
-    icache_evict((struct inode *)mte->root, (struct inode *)dir);
-
-    init_dirsearch( &ds, (struct inode *)dir, name );
-    
-    err = jffs2_find( &ds );
-
-    if( err != ENOERR ) return err;
-
-    switch( key )
-    {
-    case FS_INFO_CONF:
-        err = jffs2_pathconf( ds.node, (struct cyg_pathconf_info *)buf );
-        break;
-        
-    default:
-        err = EINVAL;
-    }
-    return err;
-
-    return ENOERR;
-}
-
-// -------------------------------------------------------------------------
-// jffs2_setinfo()
-// Setinfo. Nothing to support here at present.
-
-static int jffs2_setinfo  ( cyg_mtab_entry *mte, cyg_dir dir, const char *name,
-                             int key, void *buf, int len )
-{
-    // No setinfo keys supported at present
-    
-    D2(printf("jffs2_setinfo\n"));
-
-    return EINVAL;
-}
-
-
-//==========================================================================
-// File operations
-
-// -------------------------------------------------------------------------
-// jffs2_fo_read()
-// Read data from the file.
-
-static int jffs2_fo_read      (struct CYG_FILE_TAG *fp, struct CYG_UIO_TAG *uio)
-{
-    struct inode *inode = (struct inode *)fp->f_data;
-    struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
-    struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
-    int i;
-    ssize_t resid = uio->uio_resid;
-    off_t pos = fp->f_offset;
-
-    down(&f->sem);
-
-    // Loop over the io vectors until there are none left
-    for( i = 0; i < uio->uio_iovcnt && pos < inode->i_size; i++ )
-    {
-	int ret;
-        cyg_iovec *iov = &uio->uio_iov[i];
-        off_t len = min(iov->iov_len, inode->i_size - pos);
-
-        D2(printf("jffs2_fo_read inode size %d\n", inode->i_size));
-
-	ret = jffs2_read_inode_range(c, f, (unsigned char *)iov->iov_base, 
-				     pos, len);
-	if (ret) {
-		D1(printf("jffs2_fo_read(): read_inode_range failed %d\n",
-			  ret));
-		uio->uio_resid = resid;
-		up(&f->sem);
-		return -ret;
-	}
-	resid -= len;
-	pos += len;
-    }
-
-    // We successfully read some data, update the node's access time
-    // and update the file offset and transfer residue.
-    
-    inode->i_atime = cyg_timestamp();
-
-    uio->uio_resid = resid;
-    fp->f_offset = pos;
-
-    up(&f->sem);
-    
-    return ENOERR;
-}
-
-// -------------------------------------------------------------------------
-// jffs2_fo_write()
-// Write data to file.
-
-static int jffs2_fo_write     (struct CYG_FILE_TAG *fp, struct CYG_UIO_TAG *uio)
-{
-    struct page write_page;
-    off_t page_start_pos;
-    struct inode *node = (struct inode *)fp->f_data;
-    off_t pos = fp->f_offset;
-    ssize_t resid = uio->uio_resid;    
-    int i;
-
-    memset(&read_write_buffer, 0, PAGE_CACHE_SIZE);
-    write_page.virtual = &read_write_buffer;
-
-    // If the APPEND mode bit was supplied, force all writes to
-    // the end of the file.
-    if( fp->f_flag & CYG_FAPPEND )
-        pos = fp->f_offset = node->i_size;
-    
-    // Check that pos is within current file size, or at the very end.
-    if( pos < 0 || pos > node->i_size )
-        return EINVAL;
-
-    // Now loop over the iovecs until they are all done, or
-    // we get an error.
-    for( i = 0; i < uio->uio_iovcnt; i++ )
-    {
-        cyg_iovec *iov = &uio->uio_iov[i];
-        char *buf = (char *)iov->iov_base;
-        off_t len = iov->iov_len;
-
-        // loop over the vector writing it to the file until it has
-        // all been done.
-        while( len > 0 )
-        {
-            //cyg_uint8 *fbuf;
-            //size_t bsize;
-            size_t writtenlen;
-            off_t l = len;
-            int err;
-            
-            write_page.index = 0;
-
-            page_start_pos = pos;
-            while(page_start_pos >= (PAGE_CACHE_SIZE)) {
-                write_page.index++;
-                page_start_pos -= PAGE_CACHE_SIZE;
-            }
-
-            if( l > PAGE_CACHE_SIZE - page_start_pos)
-                l = PAGE_CACHE_SIZE - page_start_pos;
-
-            D2(printf("jffs2_fo_write write_page.index %d\n", write_page.index));
-            D2(printf("jffs2_fo_write page_start_pos %d\n", page_start_pos));
-            D2(printf("jffs2_fo_write transfer size %d\n", l));
-
-            err = jffs2_prepare_write(node, &write_page, page_start_pos, page_start_pos + l);
-
-            if( err != 0 )
-                return err;
-            
-            // copy data in
-            memcpy(&read_write_buffer[page_start_pos], buf, l);
-
-            writtenlen = jffs2_commit_write(node, &write_page, page_start_pos, page_start_pos + l);
-           
-            if( writtenlen != l )
-                return ENOSPC;
-            
-            // Update working vars
-            len -= l;
-            buf += l;
-            pos += l;
-            resid -= l;
-        }
-    }
-
-    // We wrote some data successfully, update the modified and access
-    // times of the node, increase its size appropriately, and update
-    // the file offset and transfer residue.
-    node->i_mtime =
-    node->i_ctime = cyg_timestamp();
-    if( pos > node->i_size )
-        node->i_size = pos;    
-
-    uio->uio_resid = resid;
-    fp->f_offset = pos;
-    
-    return ENOERR;
-}
-
-// -------------------------------------------------------------------------
-// jffs2_fo_lseek()
-// Seek to a new file position.
-
-static int jffs2_fo_lseek     (struct CYG_FILE_TAG *fp, off_t *apos, int whence )
-{
-    struct inode *node = (struct inode *)fp->f_data;
-    off_t pos = *apos;
-
-    D2(printf("jffs2_fo_lseek\n"));
-
-    switch( whence )
-    {
-    case SEEK_SET:
-        // Pos is already where we want to be.
-        break;
-
-    case SEEK_CUR:
-        // Add pos to current offset.
-        pos += fp->f_offset;
-        break;
-
-    case SEEK_END:
-        // Add pos to file size.
-        pos += node->i_size;
-        break;
-
-    default:
-        return EINVAL;
-    }
-    
-    // Check that pos is still within current file size, or at the
-    // very end.
-    if( pos < 0 || pos > node->i_size )
-        return EINVAL;
-
-    // All OK, set fp offset and return new position.
-    *apos = fp->f_offset = pos;
-    
-    return ENOERR;
-}
-
-// -------------------------------------------------------------------------
-// jffs2_fo_ioctl()
-// Handle ioctls. Currently none are defined.
-
-static int jffs2_fo_ioctl     (struct CYG_FILE_TAG *fp, CYG_ADDRWORD com,
-                                CYG_ADDRWORD data)
-{
-    // No Ioctls currenly defined.
-
-    D2(printf("jffs2_fo_ioctl\n"));
-
-    return EINVAL;
-}
-
-// -------------------------------------------------------------------------
-// jffs2_fo_fsync().
-// Force the file out to data storage.
-
-static int jffs2_fo_fsync     (struct CYG_FILE_TAG *fp, int mode )
-{
-    // Data is always permanently where it belongs, nothing to do
-    // here.
-  
-    D2(printf("jffs2_fo_fsync\n"));
-
-    return ENOERR;
-}
-
-// -------------------------------------------------------------------------
-// jffs2_fo_close()
-// Close a file. We just decrement the refcnt and let it go away if
-// that is all that is keeping it here.
-
-static int jffs2_fo_close     (struct CYG_FILE_TAG *fp)
-{
-    struct inode *node = (struct inode *)fp->f_data;
-
-    D2(printf("jffs2_fo_close\n"));
-
-    dec_refcnt( node );
-
-    fp->f_data = 0;     // zero data pointer
-    
-    return ENOERR;
-}
-
-// -------------------------------------------------------------------------
-//jffs2_fo_fstat()
-// Get file status.
-
-static int jffs2_fo_fstat     (struct CYG_FILE_TAG *fp, struct stat *buf )
-{
-    struct inode *node = (struct inode *)fp->f_data;
-
-    D2(printf("jffs2_fo_fstat\n"));
-
-    // Fill in the status
-    buf->st_mode        = node->i_mode;
-    buf->st_ino         = (ino_t)node;
-    buf->st_dev         = 0;
-    buf->st_nlink       = node->i_nlink;
-    buf->st_uid         = 0;
-    buf->st_gid         = 0;
-    buf->st_size        = node->i_size;
-    buf->st_atime       = node->i_atime;
-    buf->st_mtime       = node->i_mtime;
-    buf->st_ctime       = node->i_ctime;
-    
-    return ENOERR;
-}
-
-// -------------------------------------------------------------------------
-// jffs2_fo_getinfo()
-// Get info. Currently only supports fpathconf().
-
-static int jffs2_fo_getinfo   (struct CYG_FILE_TAG *fp, int key, void *buf, int len )
-{
-    struct inode *node = (struct inode *)fp->f_data;    
-    int err;
-
-    D2(printf("jffs2_fo_getinfo\n"));
-
-    switch( key )
-    {
-    case FS_INFO_CONF:
-        err = jffs2_pathconf( node, (struct cyg_pathconf_info *)buf );
-        break;
-        
-    default:
-        err = EINVAL;
-    }
-    return err;
-
-    return ENOERR;
-}
-
-// -------------------------------------------------------------------------
-// jffs2_fo_setinfo()
-// Set info. Nothing supported here.
-
-static int jffs2_fo_setinfo   (struct CYG_FILE_TAG *fp, int key, void *buf, int len )
-{
-    // No setinfo key supported at present
-    
-    D2(printf("jffs2_fo_setinfo\n"));
-
-    return ENOERR;
-}
-
-
-//==========================================================================
-// Directory operations
-
-// -------------------------------------------------------------------------
-// jffs2_fo_dirread()
-// Read a single directory entry from a file.
-
-static __inline void
-filldir(char *nbuf, int nlen, const char * name, int namlen)
-{
-    int len = nlen < namlen ? nlen : namlen;
-    memcpy(nbuf, name, len);
-    nbuf[len] = '\0';
-}
-
-static int jffs2_fo_dirread      (struct CYG_FILE_TAG *fp, struct CYG_UIO_TAG *uio)
-{
-    struct inode *d_inode = (struct inode *)fp->f_data;
-    struct dirent *ent = (struct dirent *)uio->uio_iov[0].iov_base;
-    char *nbuf = ent->d_name;
-    int nlen = sizeof(ent->d_name)-1;
-    off_t len = uio->uio_iov[0].iov_len;
-	struct jffs2_inode_info *f;
-	struct jffs2_sb_info *c;
-	struct inode *inode = d_inode;
-	struct jffs2_full_dirent *fd;
-	unsigned long offset, curofs;
-	int found = 1;
-
-    if( len < sizeof(struct dirent) )
-        return EINVAL;
-
-	D1(printk(KERN_DEBUG "jffs2_readdir() for dir_i #%lu\n", d_inode->i_ino));
-
-	f = JFFS2_INODE_INFO(inode);
-	c = JFFS2_SB_INFO(inode->i_sb);
-
-	offset = fp->f_offset;
-
-	if (offset == 0) {
-		D1(printk(KERN_DEBUG "Dirent 0: \".\", ino #%lu\n", inode->i_ino));
-		filldir(nbuf, nlen, ".", 1);
-        goto out;
-	}
-	if (offset == 1) {
-		filldir(nbuf, nlen, "..", 2);
-        goto out;
-	}
-
-	curofs=1;
-	down(&f->sem);
-	for (fd = f->dents; fd; fd = fd->next) {
-
-		curofs++;
-		/* First loop: curofs = 2; offset = 2 */
-		if (curofs < offset) {
-			D2(printk(KERN_DEBUG "Skipping dirent: \"%s\", ino #%u, type %d, because curofs %ld < offset %ld\n", 
-				  fd->name, fd->ino, fd->type, curofs, offset));
-			continue;
-		}
-		if (!fd->ino) {
-			D2(printk(KERN_DEBUG "Skipping deletion dirent \"%s\"\n", fd->name));
-			offset++;
-			continue;
-		}
-		D2(printk(KERN_DEBUG "Dirent %ld: \"%s\", ino #%u, type %d\n", offset, fd->name, fd->ino, fd->type));
-		filldir(nbuf, nlen, fd->name, strlen(fd->name));
-        goto out_sem;
-	}
-	/* Reached the end of the directory */
-	found = 0;
- out_sem:
-	up(&f->sem);
- out:
-    fp->f_offset = ++offset;
-    if (found) {
-        uio->uio_resid -= sizeof(struct dirent);
-    }
-	return ENOERR;
-}
-
-// -------------------------------------------------------------------------
-// jffs2_fo_dirlseek()
-// Seek directory to start.
-
-static int jffs2_fo_dirlseek     (struct CYG_FILE_TAG *fp, off_t *pos, int whence )
-{
-    // Only allow SEEK_SET to zero
-    
-    D2(printf("jffs2_fo_dirlseek\n"));
-
-    if( whence != SEEK_SET || *pos != 0)
-        return EINVAL;
-
-    *pos = fp->f_offset = 0;
-    
-    return ENOERR;
-}
-
-
-//==========================================================================
-// 
-// Called by JFFS2
-// ===============
-// 
-//
-//==========================================================================
-
-
-struct page *read_cache_page(unsigned long index,
-				int (*filler)(void *,struct page*),
-				void *data)
-{
-        // Only called in gc.c jffs2_garbage_collect_dnode
-        // but gets a real page for the specified inode
-
-	int err;
-	struct page *gc_page = malloc(sizeof(struct page));
-
-printf("read_cache_page\n");
-        memset(&gc_buffer, 0, PAGE_CACHE_SIZE);
-
-        if(gc_page != NULL) {
-            gc_page->virtual = &gc_buffer;
-            gc_page->index = index;
-
-	    err = filler(data, gc_page);
-	    if (err < 0) {
-                free(gc_page);
-                gc_page = NULL;
-	    }
-        }
-
-	return gc_page;
-}
-
-void page_cache_release(struct page * pg) {
-
-        // Only called in gc.c jffs2_garbage_collect_dnode
-        // but should free the page malloc'd by read_cache_page
-
-printf("page_cache_release\n");
-        free(pg);
-}
-
-struct inode * new_inode(struct super_block *sb) {
-
-        // Only called in write.c jffs2_new_inode
-        // Always adds itself to inode cache
-
-        struct inode * inode;
-        struct inode * cached_inode;
-
-	inode = malloc(sizeof(struct inode));
-	if (inode == NULL)
-                return 0;
-
-        D2(printf("malloc new_inode %x ####################################\n", inode));
-
-        memset(inode, 0, sizeof(struct inode));
-        inode->i_sb = sb;
-        inode->i_ino = 1;
-	inode->i_count = 0;//1; // Let ecos manage the open count
-
-        inode->i_nlink = 1; // Let JFFS2 manage the link count
-        inode->i_size = 0;
-
-        inode->i_cache_next = NULL; // Newest inode, about to be cached
-
-        // Add to the icache
-        for(cached_inode = sb->s_root; cached_inode != NULL; cached_inode = cached_inode->i_cache_next) {
-            if (cached_inode->i_cache_next == NULL) {
-                cached_inode->i_cache_next = inode; // Current last in cache points to newcomer
-                inode->i_cache_prev = cached_inode; // Newcomer points back to last
-                break;
-            }
-        }
-
-	return inode;
-}
-
-struct inode * iget(struct super_block *sb, cyg_uint32 ino) {
-
-        // Substitute for iget drops straight through to reading the 
-        // inode from disk if it is not in the inode cache
-
-        // Called in super.c jffs2_read_super, dir.c jffs2_lookup,
-        // and gc.c jffs2_garbage_collect_pass
-
-        // Must first check for cached inode 
-        // If this fails let new_inode create one
-
-	struct inode * inode;
-
-        D2(printf("iget\n"));
-
-        // Check for this inode in the cache
-        for(inode = sb->s_root; inode != NULL; inode = inode->i_cache_next) {
-            if (inode->i_ino == ino)
-                return inode;
-        }
-        inode = NULL;
-
-        // Not cached, so malloc it
-        inode = new_inode(sb);
-	if (inode == NULL)
-                return 0;
-
-        inode->i_ino = ino;
-        jffs2_read_inode(inode);
-	
-	return inode;
-}
-
-void iput(struct inode * i) {
-
-        // Called in dec_refcnt, jffs2_find 
-        // (and jffs2_open and jffs2_ops_mkdir?)
-        // super.c jffs2_read_super,
-        // and gc.c jffs2_garbage_collect_pass
-
-        struct inode *cached_inode;
-
-        D2(printf("free iput inode %x $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n", i));
-	if (i && i->i_count) {
-		/* Added by dwmw2. iget/iput in Linux track the use count,
-		 don't just unconditionally free it */
-		printf("iput called for used inode\n");
-		return;
-	}
-        if (i != NULL) {
-            // Remove from the icache
-            for(cached_inode = i->i_sb->s_root; cached_inode != NULL; cached_inode = cached_inode->i_cache_next) {
-                if (cached_inode == i) {
-                    cached_inode->i_cache_prev->i_cache_next = cached_inode->i_cache_next; // Prveious entry points ahead of us
-                    if (cached_inode->i_cache_next != NULL)
-                        cached_inode->i_cache_next->i_cache_prev = cached_inode->i_cache_prev; // Next entry points behind us
-                    break;
-                }
-            }
-            // inode has been seperated from the cache
-            jffs2_clear_inode(i);
-            free(i);
-        }
-}
-
-static int return_EIO(void)
-{
-	return -EIO;
-}
-
-#define EIO_ERROR ((void *) (return_EIO))
-
-void make_bad_inode(struct inode * inode) {
-
-        // In readinode.c JFFS2 checks whether the inode has appropriate
-        // content for its marked type
-
-        D2(printf("make_bad_inode\n"));
-
-	inode->i_mode = S_IFREG;
-	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
-	inode->i_op = EIO_ERROR;	
-	inode->i_fop = EIO_ERROR;	
-}
-
-int is_bad_inode(struct inode * inode) {
-
-        // Called in super.c jffs2_read_super,
-        // and gc.c jffs2_garbage_collect_pass
-
-        D2(printf("is_bad_inode\n"));
-
-	return (inode->i_op == EIO_ERROR);	
-        /*if(i == NULL)
-                return 1;
-        return 0;*/
-}
-
-cyg_bool jffs2_flash_read(struct jffs2_sb_info *c, cyg_uint32 read_buffer_offset, const size_t size, size_t * return_size, char * write_buffer) {
-    Cyg_ErrNo err;
-    cyg_uint32 len = size;
-    struct super_block *sb = OFNI_BS_2SFFJ( c );
-
-        //D2(printf("FLASH READ\n"));
-        //D2(printf("read address = %x\n", CYGNUM_FS_JFFS2_BASE_ADDRESS + read_buffer_offset));
-        //D2(printf("write address = %x\n", write_buffer));
-        //D2(printf("size = %x\n", size));
-    err = cyg_io_bread( sb->s_dev, write_buffer, &len, read_buffer_offset );
-    
-	*return_size = (size_t)len;
-    return ( err != ENOERR );
-}
-
-cyg_bool jffs2_flash_write(struct jffs2_sb_info *c, cyg_uint32 write_buffer_offset, const size_t size, size_t * return_size, char * read_buffer) {
-
-    Cyg_ErrNo err;
-    cyg_uint32 len = size;
-    struct super_block *sb = OFNI_BS_2SFFJ( c );
-    
-    //    D2(printf("FLASH WRITE ENABLED!!!\n"));
-    //    D2(printf("write address = %x\n", CYGNUM_FS_JFFS2_BASE_ADDRESS + write_buffer_offset));
-    //    D2(printf("read address = %x\n", read_buffer));
-    //    D2(printf("size = %x\n", size));
-
-    err = cyg_io_bwrite( sb->s_dev, read_buffer, &len, write_buffer_offset );
-    *return_size = (size_t)len;
-
-    return ( err != ENOERR );
-}
-
-int
-jffs2_flash_writev(struct jffs2_sb_info *c, const struct iovec *vecs,
-                   unsigned long count, loff_t to, size_t *retlen)
-{
-	unsigned long i;
-	size_t totlen = 0, thislen;
-	int ret = 0;
-    
-	for (i=0; i<count; i++) {
-        // writes need to be aligned but the data we're passed may not be
-        // Observation suggests most unaligned writes are small, so we
-        // optimize for that case.
-
-        if ( ((vecs[i].iov_len & (sizeof(int)-1))) ||
-             (((unsigned long)vecs[i].iov_base & (sizeof(unsigned long)-1))) )
-        {
-            // are there iov's after this one? Or is it so much we'd need
-            // to do multiple writes anyway?
-            if ( (i+1)<count || vecs[i].iov_len > 256 )
-            {
-                // cop out and malloc
-                unsigned long j;
-                ssize_t sizetomalloc=0, totvecsize=0;
-                char *cbuf, *cbufptr;
-
-                for (j=i;j<count; j++)
-                    totvecsize += vecs[j].iov_len;
-                
-                // pad up in case unaligned
-                sizetomalloc = totvecsize + sizeof(int)-1;
-                sizetomalloc &= ~(sizeof(int)-1);
-                cbuf = (char *)malloc( sizetomalloc );
-                // malloc returns aligned memory
-                if (!cbuf)
-                {
-                    ret = -ENOMEM;
-                    goto writev_out;
-                }
-                cbufptr = cbuf;
-                for (j=i;j<count; j++)
-                {
-                    memcpy( cbufptr, vecs[j].iov_base, vecs[j].iov_len );
-                    cbufptr += vecs[j].iov_len;
-                }
-                ret = jffs2_flash_write(c, to, sizetomalloc, &thislen, cbuf );
-                if ( thislen > totvecsize ) // in case it was aligned up
-                    thislen = totvecsize;
-                totlen += thislen;
-                free(cbuf);
-                goto writev_out;
-            }
-            else
-            {
-                // otherwise optimize for the common case
-                int buf[256/sizeof(int)]; // int, so int aligned
-                size_t lentowrite;
-                    
-                lentowrite = vecs[i].iov_len;
-                // pad up in case its unaligned
-                lentowrite += sizeof(int)-1;
-                lentowrite &= ~(sizeof(int)-1);
-                memcpy( buf, vecs[i].iov_base, lentowrite );
-                    
-                ret = jffs2_flash_write(c, to, lentowrite, &thislen,
-                                        (char *)&buf );
-                if ( thislen > vecs[i].iov_len )
-                    thislen = vecs[i].iov_len;
-            } // else
-        }
-        else
-            ret = jffs2_flash_write(c, to, vecs[i].iov_len, &thislen,
-                                    vecs[i].iov_base);
-		totlen += thislen;
-		if (ret || thislen != vecs[i].iov_len)
-			break;
-		to += vecs[i].iov_len;
-	}
-writev_out:
-	if (retlen)
-		*retlen = totlen;
-
-	return ret;
-}
-
-cyg_bool jffs2_flash_erase(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb) {
-    cyg_io_flash_getconfig_erase_t e;
-    void *err_addr;
-    Cyg_ErrNo err;
-    cyg_uint32 len = sizeof(e);
-    struct super_block *sb = OFNI_BS_2SFFJ( c );
-
-    e.offset = jeb->offset;
-    e.len = c->sector_size;
-    e.err_address = &err_addr;
-
-    //        D2(printf("FLASH ERASE ENABLED!!!\n"));
-    //        D2(printf("erase address = %x\n", CYGNUM_FS_JFFS2_BASE_ADDRESS + jeb->offset));
-    //        D2(printf("size = %x\n", c->sector_size));
-
-    err = cyg_io_get_config( sb->s_dev, CYG_IO_GET_CONFIG_FLASH_ERASE,
-                             &e, &len );
-
-    return ( err != ENOERR || e.flasherr != 0 );
-}
-
-// -------------------------------------------------------------------------
-// EOF jffs2.c
diff -Nur linux/fs/jffs2/ecos/src/jffs2port.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/src/jffs2port.h
--- linux/fs/jffs2/ecos/src/jffs2port.h	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/src/jffs2port.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,342 +0,0 @@
-#ifndef __LINUX_JFFS2PORT_H__
-#define __LINUX_JFFS2PORT_H__
-
-/* $Id: jffs2port.h,v 1.1 2002/07/11 10:55:30 dwmw2 Exp $ */
-
-#include <pkgconf/system.h>
-#include <pkgconf/hal.h>
-//#include <pkgconf/kernel.h>
-#include <pkgconf/io_fileio.h>
-//#include <pkgconf/fs_ram.h>
-
-#include <cyg/infra/cyg_trac.h>        // tracing macros
-#include <cyg/infra/cyg_ass.h>         // assertion macros
-
-#include <unistd.h>
-#include <sys/types.h>
-#include <fcntl.h>
-#include <sys/stat.h>
-#include <errno.h>
-#include <dirent.h>
-
-#include <stdlib.h>
-#include <string.h>
-
-#include <cyg/fileio/fileio.h>
-
-#include <cyg/hal/drv_api.h>
-#include <cyg/infra/diag.h>
-
-#include <cyg/io/flash.h>
-
-#include <pkgconf/fs_jffs2.h>
-
-#include "list.h"
-
-// ARM related constants
-#define PAGE_SHIFT 0xC
-#define PAGE_SIZE  (0x1 << PAGE_SHIFT)
-#define PAGE_CACHE_SHIFT        PAGE_SHIFT
-#define PAGE_CACHE_SIZE         PAGE_SIZE
-
-//#define BITS_PER_LONG 32
-
-// Linux types
-#define printf diag_printf
-#define printk diag_printf
-#define BUG() diag_printf("BUG()\n")
-
-#define uint8_t cyg_uint8
-#define uint16_t cyg_uint16
-#define uint32_t cyg_uint32
-#define loff_t off_t
-
-#define min(x,y) (x<y?x:y)
-#define max(x,y) (x<y?y:x)
-#define min_t(t, x,y) ((t)x<(t)y?(t)x:(t)y)
-
-#define atomic_t int
-#define atomic_inc(atom) (*atom)++
-#define atomic_dec(atom) (*atom)--
-#define atomic_read(atom) (*atom)
-
-#define kmalloc(a,b) malloc(a)
-#define kfree(a) free(a)
-
-#define PageLocked(pg) 1
-#define Page_Uptodate(pg) 0
-#define UnlockPage(pg) 
-#define PAGE_BUG(pg) BUG()
-#define ClearPageUptodate(pg)
-#define SetPageError(pg)
-#define ClearPageError(pg)
-#define SetPageUptodate(pg)
-
-#define jiffies 100
-
-#define ERR_PTR(err) (void*)(err)
-#define PTR_ERR(err) (cyg_int32)(err)
-#define IS_ERR(err) (err==NULL)
-
-#define CURRENT_TIME cyg_timestamp()
-
-//#define spinlock_t cyg_spinlock_t
-typedef struct { } spinlock_t;
-#define SPIN_LOCK_UNLOCKED (spinlock_t) { }
-#define spin_lock_init(lock) do{} while (0)
-#define spin_lock(lock) do{} while (0)
-#define spin_unlock(lock) do{} while (0)
-#define spin_lock_bh(lock) do{} while (0)
-#define spin_unlock_bh(lock) do{} while (0)
-
-struct semaphore {
-	cyg_drv_mutex_t x;
-};
-
-#define init_MUTEX(sem) cyg_drv_mutex_init((cyg_drv_mutex_t *)sem)
-#define init_MUTEX_LOCKED(sem) do { cyg_drv_mutex_init((cyg_drv_mutex_t *)sem); cyg_drv_mutex_lock((cyg_drv_mutex_t *)sem); } while(0)
-#define down(sem) cyg_drv_mutex_lock((cyg_drv_mutex_t *)sem)
-#define down_interruptible(sem) ({ cyg_drv_mutex_lock((cyg_drv_mutex_t *)sem), 0; })
-#define up(sem) cyg_drv_mutex_unlock((cyg_drv_mutex_t *)sem)
-
-#define wait_queue_head_t cyg_uint32
-#define init_waitqueue_head(wait) do{} while (0)
-#define add_wait_queue(wait,new_wait) do{} while (0)
-#define remove_wait_queue(wait,old_wait) do{} while (0)
-#define DECLARE_WAITQUEUE(wait,current) do{} while (0)
-
-#define	KERN_EMERG              "<0>" // system is unusable
-#define	KERN_ALERT              "<1>" // action must be taken immediately
-#define	KERN_CRIT               "<2>" // critical conditions
-#define	KERN_ERR                "<3>" // error conditions
-#define	KERN_WARNING            "<4>" // warning conditions
-#define	KERN_NOTICE             "<5>" // normal but significant condition
-#define	KERN_INFO               "<6>" // informational
-#define	KERN_DEBUG              "<7>" // debug-level messages
-
-// Structures used by VFS
-
-typedef unsigned short kdev_t;
-
-struct qstr {
-	const unsigned char * name;
-	unsigned int len;
-	unsigned int hash;
-};
-
-#define DNAME_INLINE_LEN 16
-
-struct dentry {
-	atomic_t d_count;
-	unsigned int d_flags;
-	struct inode  * d_inode;	/* Where the name belongs to - NULL is negative */
-	struct dentry * d_parent;	/* parent directory */
-	struct list_head d_hash;	/* lookup hash list */
-	struct list_head d_child;	/* child of parent list */
-	struct list_head d_subdirs;	/* our children */
-	struct list_head d_alias;	/* inode alias list */
-	struct qstr d_name;
-	struct dentry_operations  *d_op;
-	struct super_block * d_sb;	/* The root of the dentry tree */
-	unsigned char d_iname[DNAME_INLINE_LEN]; /* small names */
-};
-
-struct file {
-	struct dentry		*f_dentry;
-	unsigned int 		f_flags;
-	mode_t			    f_mode;
-	loff_t			    f_pos;
-	unsigned long 		f_reada, f_ramax, f_raend, f_ralen, f_rawin;
-};
-
-#define ATTR_MODE	1
-#define ATTR_UID	2
-#define ATTR_GID	4
-#define ATTR_SIZE	8
-#define ATTR_ATIME	16
-#define ATTR_MTIME	32
-#define ATTR_CTIME	64
-#define ATTR_ATIME_SET	128
-#define ATTR_MTIME_SET	256
-#define ATTR_FORCE	512	/* Not a change, but a change it */
-#define ATTR_ATTR_FLAG	1024
-
-typedef unsigned short umode_t;
-
-struct iattr {
-        unsigned int ia_valid;
-	umode_t		ia_mode;
-	uid_t		ia_uid;
-	gid_t		ia_gid;
-	loff_t		ia_size;
-	time_t		ia_atime;
-	time_t		ia_mtime;
-	time_t		ia_ctime;
-};
-
-struct page {
-	unsigned long index;
-	void *virtual;
-};
-
-struct nameidata {
-	struct dentry *dentry;
-	struct qstr last;
-	unsigned int flags;
-	int last_type;
-};
-
-struct file_operations {
-	//struct module *owner;
-	//loff_t (*llseek) (struct file *, loff_t, int);
-	ssize_t (*read) (struct file *, char *, size_t, loff_t *);
-	//ssize_t (*write) (struct file *, const char *, size_t, loff_t *);
-	int (*readdir) (struct file *, char *, int);
-	//unsigned int (*poll) (struct file *, struct poll_table_struct *);
-	int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);
-	//int (*mmap) (struct file *, struct vm_area_struct *);
-	//int (*open) (struct inode *, struct file *);
-	//int (*flush) (struct file *);
-	//int (*release) (struct inode *, struct file *);
-	int (*fsync) (struct file *, struct dentry *, int datasync);
-	//int (*fasync) (int, struct file *, int);
-	//int (*lock) (struct file *, int, struct file_lock *);
-	//ssize_t (*readv) (struct file *, const struct iovec *, unsigned long, loff_t *);
-	//ssize_t (*writev) (struct file *, const struct iovec *, unsigned long, loff_t *);
-};
-
-struct inode_operations {
-	int (*create) (struct inode *,struct dentry *,int);
-	struct dentry * (*lookup) (struct inode *,struct dentry *);
-	int (*link) (struct dentry *,struct inode *,struct dentry *);
-	int (*unlink) (struct inode *,struct dentry *);
-	int (*symlink) (struct inode *,struct dentry *,const char *);
-	int (*mkdir) (struct inode *,struct dentry *,int);
-	int (*rmdir) (struct inode *,struct dentry *);
-	int (*mknod) (struct inode *,struct dentry *,int,int);
-	int (*rename) (struct inode *, struct dentry *,
-			struct inode *, struct dentry *);
-	int (*readlink) (struct dentry *, char *,int);
-	int (*follow_link) (struct dentry *, struct nameidata *);
-	//void (*truncate) (struct inode *);
-	int (*permission) (struct inode *, int);
-	//int (*revalidate) (struct dentry *);
-	int (*setattr) (struct dentry *, struct iattr *);
-	//int (*getattr) (struct dentry *, struct iattr *);
-};
-
-/*
- * File types
- */
-#define DT_UNKNOWN	0
-#define DT_DIR		4
-#define DT_REG		8
-
-struct iovec {
-        void *iov_base;
-        ssize_t iov_len; 
-};
-
-// FIXME: we must provide some translation so that Linux-created jffs2
-// partitions can be read on eCos and vice versa
-
-#define S_IFMT 0xF9 // Quick fix for clash on ecos / linux mode bits
-#define S_IFDIR __stat_mode_DIR
-#define S_IFREG __stat_mode_REG
-#define S_IFBLK __stat_mode_BLK
-#define S_IFCHR __stat_mode_CHR
-#define S_IFLNK 0x101
-#define S_IFSOCK 0x102
-#define S_IFIFO __stat_mode_FIFO
-#define S_IRUGO 0x103
-#define S_IXUGO 0x104
-#define S_IRWXUGO 0x105
-
-
-// called by JFFS2
-
-#define to_kdev_t(rdev) (rdev)
-#define MAJOR(rdev) (rdev)>>8
-#define MINOR(rdev) (rdev)
-
-#define page_address(page)	((page)->virtual)
-
-static __inline__ void * kmap(struct page * page) {
-	return page_address(page);
-}
-
-#define kunmap(page) do { } while (0)
-
-//struct page * read_cache_page(cyg_uint32 start, void * f, struct inode * i);
-struct page *read_cache_page(unsigned long index, int (*filler)(void *,struct page*), void *data);
-void page_cache_release(struct page * pg);
-
-struct inode * new_inode(struct super_block *sb);
-struct inode * iget(struct super_block *sb, cyg_uint32 ino);
-void iput(struct inode * i);
-void make_bad_inode(struct inode * inode);
-int is_bad_inode(struct inode * inode);
-
-#define insert_inode_hash(inode) do { } while (0)
-
-#define d_alloc_root(root_inode) root_inode
-
-#define flush_dcache_page(page) do { } while (0)
-
-struct jffs2_sb_info;
-struct jffs2_eraseblock;
-
-cyg_bool jffs2_flash_read(struct jffs2_sb_info *c, cyg_uint32 read_buffer_offset, const size_t size, size_t * return_size, char * write_buffer);
-cyg_bool jffs2_flash_write(struct jffs2_sb_info *c, cyg_uint32 write_buffer_offset, const size_t size, size_t * return_size, char * read_buffer);
-int jffs2_flash_writev(struct jffs2_sb_info *c, const struct iovec *vecs, unsigned long count, loff_t to, size_t *retlen);
-cyg_bool jffs2_flash_erase(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);
-
-static inline void wake_up(wait_queue_head_t *erase_wait)
-{ /* Only used for waking up threads blocks on erases. Not used in eCos */ }
-
-// calls to JFFS2
-
-// dir-ecos.c
-struct inode *jffs2_lookup(struct inode *dir_i, struct qstr *name);
-int jffs2_readdir (struct inode *d_inode, unsigned long f_pos, char *nbuf, int nlen);
-int jffs2_create(struct inode *dir_i, struct qstr *d_name, int mode, struct inode **new_i);
-int jffs2_mkdir (struct inode *dir_i, struct qstr *d_name, int mode, struct inode **new_i);
-int jffs2_link (struct inode *old_d_inode, struct inode *dir_i, struct qstr *d_name);
-int jffs2_unlink(struct inode *dir_i, struct inode *d_inode, struct qstr *d_name);
-int jffs2_rmdir (struct inode *dir_i, struct inode *d_inode, struct qstr *d_name);
-int jffs2_rename (struct inode *old_dir_i, struct inode *d_inode, struct qstr *old_d_name,
-                        struct inode *new_dir_i, struct qstr *new_d_name);
-
-#define init_name_hash()		0
-static inline unsigned long partial_name_hash(unsigned long c, unsigned long prevhash)
-{
-	prevhash = (prevhash << 4) | (prevhash >> (8*sizeof(unsigned long)-4));
-	return prevhash ^ c;
-}
-
-static inline unsigned long end_name_hash(unsigned long hash)
-{
-	if (sizeof(hash) > sizeof(unsigned int))
-		hash += hash >> 4*sizeof(hash);
-	return (unsigned int) hash;
-}
-
-static inline unsigned int full_name_hash(const unsigned char * name, unsigned int len) {
-
-	unsigned long hash = init_name_hash();
-	while (len--)
-		hash = partial_name_hash(*name++, hash);
-	return end_name_hash(hash);
-}
-
-#endif /* __LINUX_JFFS2PORT_H__ */
-
-
-
-
-
-
-
-
-
-
diff -Nur linux/fs/jffs2/ecos/src/list.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/src/list.h
--- linux/fs/jffs2/ecos/src/list.h	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/src/list.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,96 +0,0 @@
-/*
- * JFFS2 -- Journalling Flash File System, Version 2.
- *
- * Copyright (C) 2002 Red Hat, Inc.
- *
- * Created by Jonathan Larmour <jlarmour@redhat.com>
- * 
- * For licensing information, see the file 'LICENCE' in this directory.
- *
- * $Id: list.h,v 1.1 2002/07/11 10:55:30 dwmw2 Exp $
- *
- */
-
-#ifndef CYGONCE_FS_JFFS2_LIST_H
-#define CYGONCE_FS_JFFS2_LIST_H
-
-
-/* -----------------------------------------------------------------------*/
-
-/* Doubly linked list implementation to replace the GPL'd one used in
-   the Linux kernel. */
-
-#include <stddef.h>
-#include <cyg/infra/cyg_type.h>
-
-/* TYPES */
-
-struct list_head {
-    struct list_head *next;
-    struct list_head *prev;
-};
-
-/* MACROS */
-
-#define INIT_LIST_HEAD( _list_ )              \
-CYG_MACRO_START                               \
-(_list_)->next = (_list_)->prev = (_list_);   \
-CYG_MACRO_END
-
-/* FUNCTIONS */
-
-/* Insert an entry _after_ the specified entry */
-static __inline__ void
-list_add( struct list_head *newent, struct list_head *afterthisent )
-{
-    struct list_head *next = afterthisent->next;
-    newent->next = next;
-    newent->prev = afterthisent;
-    afterthisent->next = newent;
-    next->prev = newent;
-} /* list_add() */
-
-/* Insert an entry _before_ the specified entry */
-static __inline__ void
-list_add_tail( struct list_head *newent, struct list_head *beforethisent )
-{
-    struct list_head *prev = beforethisent->prev;
-    newent->prev = prev;
-    newent->next = beforethisent;
-    beforethisent->prev = newent;
-    prev->next = newent;
-} /* list_add_tail() */
-
-/* Delete the specified entry */
-static __inline__ void
-list_del( struct list_head *ent )
-{
-    ent->prev->next = ent->next;
-    ent->next->prev = ent->prev;
-} /* list_del() */
-
-/* Is this list empty? */
-static __inline__ int
-list_empty( struct list_head *list )
-{
-    return ( list->next == list );
-} /* list_empty() */
-
-/* list_entry - Assuming you have a struct of type _type_ that contains a
-   list which has the name _member_ in that struct type, then given the
-   address of that list in the struct, _list_, this returns the address
-   of the container structure */
-
-#define list_entry( _list_, _type_, _member_ ) \
-    ((_type_ *)((char *)(_list_)-(char *)(offsetof(_type_,_member_))))
-
-/* list_for_each - using _ent_, iterate through list _list_ */
-
-#define list_for_each( _ent_, _list_ )   \
-    for ( (_ent_) = (_list_)->next;      \
-    (_ent_) != (_list_);                 \
-    (_ent_) = (_ent_)->next )
-
-/* -----------------------------------------------------------------------*/
-#endif /* #ifndef CYGONCE_FS_JFFS2_LIST_H */
-/* EOF list.h */
diff -Nur linux/fs/jffs2/ecos/src/malloc-ecos.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/src/malloc-ecos.c
--- linux/fs/jffs2/ecos/src/malloc-ecos.c	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/src/malloc-ecos.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,98 +0,0 @@
-/*
- * JFFS2 -- Journalling Flash File System, Version 2.
- *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
- *
- * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
- *
- * For licensing information, see the file 'LICENCE' in this directory.
- *
- * $Id: malloc-ecos.c,v 1.1 2002/07/11 10:55:30 dwmw2 Exp $
- *
- */
-
-#include "nodelist.h"
-
-struct jffs2_full_dirent *jffs2_alloc_full_dirent(int namesize)
-{
-	return malloc(sizeof(struct jffs2_full_dirent) + namesize);
-}
-
-void jffs2_free_full_dirent(struct jffs2_full_dirent *x)
-{
-	free(x);
-}
-
-struct jffs2_full_dnode *jffs2_alloc_full_dnode(void)
-{
-	return malloc(sizeof(struct jffs2_full_dnode));
-}
-
-void jffs2_free_full_dnode(struct jffs2_full_dnode *x)
-{
-	free(x);
-}
-
-struct jffs2_raw_dirent *jffs2_alloc_raw_dirent(void)
-{
-	return malloc(sizeof(struct jffs2_raw_dirent));
-}
-
-void jffs2_free_raw_dirent(struct jffs2_raw_dirent *x)
-{
-	free(x);
-}
-
-struct jffs2_raw_inode *jffs2_alloc_raw_inode(void)
-{
-	return malloc(sizeof(struct jffs2_raw_inode));
-}
-
-void jffs2_free_raw_inode(struct jffs2_raw_inode *x)
-{
-	free(x);
-}
-
-struct jffs2_tmp_dnode_info *jffs2_alloc_tmp_dnode_info(void)
-{
-	return malloc(sizeof(struct jffs2_tmp_dnode_info));
-}
-
-void jffs2_free_tmp_dnode_info(struct jffs2_tmp_dnode_info *x)
-{
-	free(x);
-}
-
-struct jffs2_raw_node_ref *jffs2_alloc_raw_node_ref(void)
-{
-	return malloc(sizeof(struct jffs2_raw_node_ref));
-}
-
-void jffs2_free_raw_node_ref(struct jffs2_raw_node_ref *x)
-{
-	free(x);
-}
-
-struct jffs2_node_frag *jffs2_alloc_node_frag(void)
-{
-	return malloc(sizeof(struct jffs2_node_frag));
-}
-
-void jffs2_free_node_frag(struct jffs2_node_frag *x)
-{
-	free(x);
-}
-
-struct jffs2_inode_cache *jffs2_alloc_inode_cache(void)
-{
-	struct jffs2_inode_cache *ret = malloc(sizeof(struct jffs2_inode_cache));
-	D1(printk(KERN_DEBUG "Allocated inocache at %p\n", ret));
-	return ret;
-}
-
-void jffs2_free_inode_cache(struct jffs2_inode_cache *x)
-{
-	D1(printk(KERN_DEBUG "Freeing inocache at %p\n", x));
-	free(x);
-}
-
diff -Nur linux/fs/jffs2/ecos/src/os-ecos.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/src/os-ecos.h
--- linux/fs/jffs2/ecos/src/os-ecos.h	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/src/os-ecos.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,135 +0,0 @@
-/*
- * JFFS2 -- Journalling Flash File System, Version 2.
- *
- * Copyright (C) 2002 Red Hat, Inc.
- *
- * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
- *
- * For licensing information, see the file 'LICENCE' in this directory.
- *
- * $Id: os-ecos.h,v 1.1 2002/07/11 10:55:30 dwmw2 Exp $
- *
- */
-
-#ifndef __JFFS2_OS_ECOS_H__
-#define __JFFS2_OS_ECOS_H__
-
-#include <cyg/io/io.h>
-
-#define CONFIG_JFFS2_FS_DEBUG 0
-
- /* Read-only operation not currently implemented on eCos */
-#define jffs2_is_readonly(c) (0)
-
-/* NAND flash not currently supported on eCos */
-#define jffs2_can_mark_obsolete(c) (1)
-
-#define JFFS2_INODE_INFO(i) (&(i)->jffs2_i)
-#define OFNI_EDONI_2SFFJ(f)  ((struct inode *) ( ((char *)f) - ((char *)(&((struct inode *)NULL)->jffs2_i)) ) )
- 
-#define JFFS2_F_I_SIZE(f) (OFNI_EDONI_2SFFJ(f)->i_size)
-#define JFFS2_F_I_MODE(f) (OFNI_EDONI_2SFFJ(f)->i_mode)
-#define JFFS2_F_I_UID(f) (OFNI_EDONI_2SFFJ(f)->i_uid)
-#define JFFS2_F_I_GID(f) (OFNI_EDONI_2SFFJ(f)->i_gid)
-#define JFFS2_F_I_CTIME(f) (OFNI_EDONI_2SFFJ(f)->i_ctime)
-#define JFFS2_F_I_MTIME(f) (OFNI_EDONI_2SFFJ(f)->i_mtime)
-#define JFFS2_F_I_ATIME(f) (OFNI_EDONI_2SFFJ(f)->i_atime)
-
-/* FIXME: eCos doesn't hav a concept of device major/minor numbers */
-#define JFFS2_F_I_RDEV_MIN(f) (MINOR(to_kdev_t(OFNI_EDONI_2SFFJ(f)->i_rdev)))
-#define JFFS2_F_I_RDEV_MAJ(f) (MAJOR(to_kdev_t(OFNI_EDONI_2SFFJ(f)->i_rdev)))
-
-struct inode {
-	//struct list_head	i_hash;
-	//struct list_head	i_list;
-	struct list_head	i_dentry;
-
-	cyg_uint32		i_ino;
-	atomic_t		i_count;
-	//kdev_t			i_dev;
-	mode_t			i_mode;
-	nlink_t			i_nlink;
-	uid_t			i_uid;
-	gid_t			i_gid;
-	kdev_t			i_rdev;
-	off_t			i_size;
-	time_t			i_atime;
-	time_t			i_mtime;
-	time_t			i_ctime;
-	unsigned long		i_blksize;
-	unsigned long		i_blocks;
-	//unsigned long		i_version;
-	//struct semaphore	i_sem;
-	//struct semaphore	i_zombie;
-	struct inode_operations	*i_op;
-	struct file_operations	*i_fop;	// former ->i_op->default_file_ops 
-	struct super_block	*i_sb;
-	//wait_queue_head_t	i_wait;
-	//struct file_lock	*i_flock;
-	//struct address_space	*i_mapping;
-	//struct address_space	i_data;	
-	//struct dquot		*i_dquot[MAXQUOTAS];
-	//struct pipe_inode_info	*i_pipe;
-	//struct block_device	*i_bdev;
-
-	//unsigned long		i_state;
-
-	unsigned int		i_flags;
-	//unsigned char		i_sock;
-
-	atomic_t		i_writecount;
-	//unsigned int		i_attr_flags;
-	//uint32_t			i_generation;
-	struct jffs2_inode_info	jffs2_i;
-
-        struct inode *i_parent;
-
-        struct inode *i_cache_prev;
-        struct inode *i_cache_next;
-};
-
-#define JFFS2_SB_INFO(sb) (&(sb)->jffs2_sb)
-
-#define OFNI_BS_2SFFJ(c)  ((struct super_block *) ( ((char *)c) - ((char *)(&((struct super_block *)NULL)->jffs2_sb)) ) )
-
-struct super_block {
-	unsigned long		s_blocksize;
-	unsigned char		s_blocksize_bits;
-	unsigned char		s_dirt;
-	//struct super_operations	*s_op;
-	unsigned long		s_flags;
-	unsigned long		s_magic;
-	//struct dentry		*s_root;
-	struct inode		*s_root;
-	struct jffs2_sb_info jffs2_sb;
-        unsigned long       s_mount_count;
-    cyg_io_handle_t     s_dev;
-};
-
-/* background.c */
-static inline void jffs2_garbage_collect_trigger(struct jffs2_sb_info *c)
-{
-	/* We don't have a GC thread in eCos (yet) */
-}
-
-/* dir.c */
-extern struct file_operations jffs2_dir_operations;
-extern struct inode_operations jffs2_dir_inode_operations;
-
-/* file.c */
-extern struct file_operations jffs2_file_operations;
-extern struct inode_operations jffs2_file_inode_operations;
-extern struct address_space_operations jffs2_file_address_operations;
-int jffs2_null_fsync(struct file *, struct dentry *, int);
-int jffs2_setattr (struct dentry *dentry, struct iattr *iattr);
-int jffs2_do_readpage_nolock (struct inode *inode, struct page *pg);
-int jffs2_do_readpage_unlock (struct inode *inode, struct page *pg);
-//int jffs2_readpage (struct file *, struct page *);
-int jffs2_readpage (struct inode *d_inode, struct page *pg);
-//int jffs2_prepare_write (struct file *, struct page *, unsigned, unsigned);
-int jffs2_prepare_write (struct inode *d_inode, struct page *pg, unsigned start, unsigned end);
-//int jffs2_commit_write (struct file *, struct page *, unsigned, unsigned);
-int jffs2_commit_write (struct inode *d_inode, struct page *pg, unsigned start, unsigned end);
-
-
-#endif /* __JFFS2_OS_ECOS_H__ */
diff -Nur linux/fs/jffs2/ecos/tests/fileio1.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/tests/fileio1.c
--- linux/fs/jffs2/ecos/tests/fileio1.c	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/tests/fileio1.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,660 +0,0 @@
-//==========================================================================
-//
-//      fileio1.c
-//
-//      Test fileio system
-//
-//==========================================================================
-//####COPYRIGHTBEGIN####
-//                                                                          
-// -------------------------------------------                              
-// The contents of this file are subject to the Red Hat eCos Public License 
-// Version 1.1 (the "License"); you may not use this file except in         
-// compliance with the License.  You may obtain a copy of the License at    
-// http://www.redhat.com/                                                   
-//                                                                          
-// Software distributed under the License is distributed on an "AS IS"      
-// basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See the 
-// License for the specific language governing rights and limitations under 
-// the License.                                                             
-//                                                                          
-// The Original Code is eCos - Embedded Configurable Operating System,      
-// released September 30, 1998.                                             
-//                                                                          
-// The Initial Developer of the Original Code is Red Hat.                   
-// Portions created by Red Hat are                                          
-// Copyright (C) 1998, 1999, 2000 Red Hat, Inc.                             
-// All Rights Reserved.                                                     
-// -------------------------------------------                              
-//                                                                          
-//####COPYRIGHTEND####
-//==========================================================================
-//#####DESCRIPTIONBEGIN####
-//
-// Author(s):           nickg
-// Contributors:        nickg
-// Date:                2000-05-25
-// Purpose:             Test fileio system
-// Description:         This test uses the testfs to check out the initialization
-//                      and basic operation of the fileio system
-//                      
-//                      
-//                      
-//                      
-//                      
-//              
-//
-//####DESCRIPTIONEND####
-//
-//==========================================================================
-
-#include <pkgconf/hal.h>
-#include <pkgconf/kernel.h>
-#include <pkgconf/io_fileio.h>
-
-#include <cyg/kernel/ktypes.h>         // base kernel types
-#include <cyg/infra/cyg_trac.h>        // tracing macros
-#include <cyg/infra/cyg_ass.h>         // assertion macros
-#include <cyg/io/flash.h>
-
-#include <unistd.h>
-#include <fcntl.h>
-#include <sys/stat.h>
-#include <errno.h>
-#include <string.h>
-#include <dirent.h>
-
-#include <cyg/fileio/fileio.h>
-
-#include <cyg/infra/testcase.h>
-#include <cyg/infra/diag.h>            // HAL polled output
-
-#include <pkgconf/fs_jffs2.h>	// Address of JFFS2
-
-//==========================================================================
-
-#if 0
-MTAB_ENTRY( jffs2_mte1,
-                   "/",
-                   "jffs2",
-                   CYGDAT_IO_FLASH_BLOCK_DEVICE_NAME_1,
-                   0);
-#endif
-
-//==========================================================================
-
-#define SHOW_RESULT( _fn, _res ) \
-diag_printf("<FAIL>: " #_fn "() returned %d %s\n", _res, _res<0?strerror(errno):"");
-
-//==========================================================================
-
-#define IOSIZE  100
-
-#define LONGNAME1       "long_file_name_that_should_take_up_more_than_one_directory_entry_1"
-#define LONGNAME2       "long_file_name_that_should_take_up_more_than_one_directory_entry_2"
-
-
-//==========================================================================
-
-#ifndef CYGPKG_LIBC_STRING
-
-char *strcat( char *s1, const char *s2 )
-{
-    char *s = s1;
-    while( *s1 ) s1++;
-    while( (*s1++ = *s2++) != 0);
-    return s;
-}
-
-#endif
-
-//==========================================================================
-
-static void listdir( char *name, int statp, int numexpected, int *numgot )
-{
-    int err;
-    DIR *dirp;
-    int num=0;
-    
-    diag_printf("<INFO>: reading directory %s\n",name);
-    
-    dirp = opendir( name );
-    if( dirp == NULL ) SHOW_RESULT( opendir, -1 );
-
-    for(;;)
-    {
-        struct dirent *entry = readdir( dirp );
-        
-        if( entry == NULL )
-            break;
-        num++;
-        diag_printf("<INFO>: entry %14s",entry->d_name);
-        if( statp )
-        {
-            char fullname[PATH_MAX];
-            struct stat sbuf;
-
-            if( name[0] )
-            {
-                strcpy(fullname, name );
-                if( !(name[0] == '/' && name[1] == 0 ) )
-                    strcat(fullname, "/" );
-            }
-            else fullname[0] = 0;
-            
-            strcat(fullname, entry->d_name );
-            
-            err = stat( fullname, &sbuf );
-            if( err < 0 )
-            {
-                if( errno == ENOSYS )
-                    diag_printf(" <no status available>");
-                else SHOW_RESULT( stat, err );
-            }
-            else
-            {
-                diag_printf(" [mode %08x ino %08x nlink %d size %d]",
-                            sbuf.st_mode,sbuf.st_ino,sbuf.st_nlink,sbuf.st_size);
-            }
-        }
-
-        diag_printf("\n");
-    }
-
-    err = closedir( dirp );
-    if( err < 0 ) SHOW_RESULT( stat, err );
-    if (numexpected >= 0 && num != numexpected)
-        CYG_TEST_FAIL("Wrong number of dir entries\n");
-    if ( numgot != NULL )
-        *numgot = num;
-}
-
-//==========================================================================
-
-static void createfile( char *name, size_t size )
-{
-    char buf[IOSIZE];
-    int fd;
-    ssize_t wrote;
-    int i;
-    int err;
-
-    diag_printf("<INFO>: create file %s size %d\n",name,size);
-
-    err = access( name, F_OK );
-    if( err < 0 && errno != EACCES ) SHOW_RESULT( access, err );
-    
-    for( i = 0; i < IOSIZE; i++ ) buf[i] = i%256;
- 
-    fd = open( name, O_WRONLY|O_CREAT );
-    if( fd < 0 ) SHOW_RESULT( open, fd );
-
-    while( size > 0 )
-    {
-        ssize_t len = size;
-        if ( len > IOSIZE ) len = IOSIZE;
-        
-        wrote = write( fd, buf, len );
-        if( wrote != len ) SHOW_RESULT( write, wrote );        
-
-        size -= wrote;
-    }
-
-    err = close( fd );
-    if( err < 0 ) SHOW_RESULT( close, err );
-}
-
-//==========================================================================
-
-#if 0
-static void maxfile( char *name )
-{
-    char buf[IOSIZE];
-    int fd;
-    ssize_t wrote;
-    int i;
-    int err;
-    size_t size = 0;
-    
-    diag_printf("<INFO>: create maximal file %s\n",name);
-
-    err = access( name, F_OK );
-    if( err < 0 && errno != EACCES ) SHOW_RESULT( access, err );
-    
-    for( i = 0; i < IOSIZE; i++ ) buf[i] = i%256;
- 
-    fd = open( name, O_WRONLY|O_CREAT );
-    if( fd < 0 ) SHOW_RESULT( open, fd );
-
-    do
-    {
-        wrote = write( fd, buf, IOSIZE );
-        if( wrote < 0 ) SHOW_RESULT( write, wrote );        
-
-        size += wrote;
-        
-    } while( wrote == IOSIZE );
-
-    diag_printf("<INFO>: file size == %d\n",size);
-
-    err = close( fd );
-    if( err < 0 ) SHOW_RESULT( close, err );
-}
-#endif
-
-//==========================================================================
-
-static void checkfile( char *name )
-{
-    char buf[IOSIZE];
-    int fd;
-    ssize_t done;
-    int i;
-    int err;
-    off_t pos = 0;
-
-    diag_printf("<INFO>: check file %s\n",name);
-    
-    err = access( name, F_OK );
-    if( err != 0 ) SHOW_RESULT( access, err );
-
-    fd = open( name, O_RDONLY );
-    if( fd < 0 ) SHOW_RESULT( open, fd );
-
-    for(;;)
-    {
-        done = read( fd, buf, IOSIZE );
-        if( done < 0 ) SHOW_RESULT( read, done );
-
-        if( done == 0 ) break;
-
-        for( i = 0; i < done; i++ )
-            if( buf[i] != i%256 )
-            {
-                diag_printf("buf[%d+%d](%02x) != %02x\n",pos,i,buf[i],i%256);
-                CYG_TEST_FAIL("Data read not equal to data written\n");
-            }
-        
-        pos += done;
-    }
-
-    err = close( fd );
-    if( err < 0 ) SHOW_RESULT( close, err );
-}
-
-//==========================================================================
-
-static void copyfile( char *name2, char *name1 )
-{
-
-    int err;
-    char buf[IOSIZE];
-    int fd1, fd2;
-    ssize_t done, wrote;
-
-    diag_printf("<INFO>: copy file %s -> %s\n",name2,name1);
-
-    err = access( name1, F_OK );
-    if( err < 0 && errno != EACCES ) SHOW_RESULT( access, err );
-
-    err = access( name2, F_OK );
-    if( err != 0 ) SHOW_RESULT( access, err );
-    
-    fd1 = open( name1, O_WRONLY|O_CREAT );
-    if( fd1 < 0 ) SHOW_RESULT( open, fd1 );
-
-    fd2 = open( name2, O_RDONLY );
-    if( fd2 < 0 ) SHOW_RESULT( open, fd2 );
-    
-    for(;;)
-    {
-        done = read( fd2, buf, IOSIZE );
-        if( done < 0 ) SHOW_RESULT( read, done );
-
-        if( done == 0 ) break;
-
-        wrote = write( fd1, buf, done );
-        if( wrote != done ) SHOW_RESULT( write, wrote );
-
-        if( wrote != done ) break;
-    }
-
-    err = close( fd1 );
-    if( err < 0 ) SHOW_RESULT( close, err );
-
-    err = close( fd2 );
-    if( err < 0 ) SHOW_RESULT( close, err );
-    
-}
-
-//==========================================================================
-
-static void comparefiles( char *name2, char *name1 )
-{
-    int err;
-    char buf1[IOSIZE];
-    char buf2[IOSIZE];
-    int fd1, fd2;
-    ssize_t done1, done2;
-    int i;
-
-    diag_printf("<INFO>: compare files %s == %s\n",name2,name1);
-
-    err = access( name1, F_OK );
-    if( err != 0 ) SHOW_RESULT( access, err );
-
-    err = access( name1, F_OK );
-    if( err != 0 ) SHOW_RESULT( access, err );
-    
-    fd1 = open( name1, O_RDONLY );
-    if( fd1 < 0 ) SHOW_RESULT( open, fd1 );
-
-    fd2 = open( name2, O_RDONLY );
-    if( fd2 < 0 ) SHOW_RESULT( open, fd2 );
-    
-    for(;;)
-    {
-        done1 = read( fd1, buf1, IOSIZE );
-        if( done1 < 0 ) SHOW_RESULT( read, done1 );
-
-        done2 = read( fd2, buf2, IOSIZE );
-        if( done2 < 0 ) SHOW_RESULT( read, done2 );
-
-        if( done1 != done2 )
-            diag_printf("Files different sizes\n");
-        
-        if( done1 == 0 ) break;
-
-        for( i = 0; i < done1; i++ )
-            if( buf1[i] != buf2[i] )
-            {
-                diag_printf("buf1[%d](%02x) != buf1[%d](%02x)\n",i,buf1[i],i,buf2[i]);
-                CYG_TEST_FAIL("Data in files not equal\n");
-            }
-    }
-
-    err = close( fd1 );
-    if( err < 0 ) SHOW_RESULT( close, err );
-
-    err = close( fd2 );
-    if( err < 0 ) SHOW_RESULT( close, err );
-    
-}
-
-//==========================================================================
-
-void checkcwd( const char *cwd )
-{
-    static char cwdbuf[PATH_MAX];
-    char *ret;
-
-    ret = getcwd( cwdbuf, sizeof(cwdbuf));
-    if( ret == NULL ) SHOW_RESULT( getcwd, ret );    
-
-    if( strcmp( cwdbuf, cwd ) != 0 )
-    {
-        diag_printf( "cwdbuf %s cwd %s\n",cwdbuf, cwd );
-        CYG_TEST_FAIL( "Current directory mismatch");
-    }
-}
-
-//==========================================================================
-// main
-
-int main( int argc, char **argv )
-{
-    int err;
-    //int i;
-    int existingdirents=-1;
-
-    CYG_TEST_INIT();
-
-    // --------------------------------------------------------------
-
-    err = mount( CYGDAT_IO_FLASH_BLOCK_DEVICE_NAME_1, "/", "jffs2" );
-    if( err < 0 ) SHOW_RESULT( mount, err );    
-
-    err = chdir( "/" );
-    if( err < 0 ) SHOW_RESULT( chdir, err );
-
-    checkcwd( "/" );
-    
-    listdir( "/", true, -1, &existingdirents );
-    if ( existingdirents < 2 )
-        CYG_TEST_FAIL("Not enough dir entries\n");
-
-    // --------------------------------------------------------------
-
-    createfile( "/foo", 202 );
-    checkfile( "foo" );
-    copyfile( "foo", "fee");
-    checkfile( "fee" );
-    comparefiles( "foo", "/fee" );
-    diag_printf("<INFO>: mkdir bar\n");
-    err = mkdir( "/bar", 0 );
-    if( err < 0 ) SHOW_RESULT( mkdir, err );
-
-    listdir( "/" , true, existingdirents+3, NULL );
-
-    copyfile( "fee", "/bar/fum" );
-    checkfile( "bar/fum" );
-    comparefiles( "/fee", "bar/fum" );
-
-    diag_printf("<INFO>: cd bar\n");
-    err = chdir( "bar" );
-    if( err < 0 ) SHOW_RESULT( chdir, err );
-
-    checkcwd( "/bar" );
-    
-    diag_printf("<INFO>: rename /foo bundy\n");    
-    err = rename( "/foo", "bundy" );
-    if( err < 0 ) SHOW_RESULT( rename, err );
-    
-    listdir( "/", true, existingdirents+2, NULL );
-    listdir( "" , true, 4, NULL );
-
-    checkfile( "/bar/bundy" );
-    comparefiles("/fee", "bundy" );
-
-    // --------------------------------------------------------------
-
-    createfile( LONGNAME1, 123 );
-    checkfile( LONGNAME1 );
-    copyfile( LONGNAME1, LONGNAME2 );
-
-    listdir( "", false, 6, NULL );
-    
-    diag_printf("<INFO>: unlink " LONGNAME1 "\n");    
-    err = unlink( LONGNAME1 );
-    if( err < 0 ) SHOW_RESULT( unlink, err );
-
-    diag_printf("<INFO>: unlink " LONGNAME2 "\n");    
-    err = unlink( LONGNAME2 );
-    if( err < 0 ) SHOW_RESULT( unlink, err );
-    
-    
-    // --------------------------------------------------------------
-
-    diag_printf("<INFO>: unlink fee\n");    
-    err = unlink( "/fee" );
-    if( err < 0 ) SHOW_RESULT( unlink, err );
-
-    diag_printf("<INFO>: unlink fum\n");        
-    err = unlink( "fum" );
-    if( err < 0 ) SHOW_RESULT( unlink, err );
-
-    diag_printf("<INFO>: unlink /bar/bundy\n");        
-    err = unlink( "/bar/bundy" );
-    if( err < 0 ) SHOW_RESULT( unlink, err );
-
-    diag_printf("<INFO>: cd /\n");        
-    err = chdir( "/" );
-    if( err < 0 ) SHOW_RESULT( chdir, err );
-
-    checkcwd( "/" );
-    
-    diag_printf("<INFO>: rmdir /bar\n");        
-    err = rmdir( "/bar" );
-    if( err < 0 ) SHOW_RESULT( rmdir, err );
-    
-    listdir( "/", false, existingdirents, NULL );
-
-    // --------------------------------------------------------------
-
-    diag_printf("<INFO>: mount /jffs2 \n");
-    err = mount( CYGDAT_IO_FLASH_BLOCK_DEVICE_NAME_1, "/jffs2", "jffs2" );
-    if( err < 0 ) SHOW_RESULT( mount, err );    
-
-    createfile( "/jffs2/tinky", 456 );
-    copyfile( "/jffs2/tinky", "/jffs2/laalaa" );
-    checkfile( "/jffs2/tinky");
-    checkfile( "/jffs2/laalaa");
-    comparefiles( "/jffs2/tinky", "/jffs2/laalaa" );
-
-    diag_printf("<INFO>: cd /jffs2\n");    
-    err = chdir( "/jffs2" );
-    if( err < 0 ) SHOW_RESULT( chdir, err );
-
-    checkcwd( "/jffs2" );
-        
-    diag_printf("<INFO>: mkdir noonoo\n");    
-    err = mkdir( "noonoo", 0 );
-    if( err < 0 ) SHOW_RESULT( mkdir, err );
-
-    listdir( "." , true, existingdirents+3, NULL);
-
-    diag_printf("<INFO>: cd noonoo\n");
-    err = chdir( "noonoo" );
-    if( err < 0 ) SHOW_RESULT( chdir, err );
-
-    checkcwd( "/jffs2/noonoo" );
-    
-    createfile( "tinky", 678 );
-    checkfile( "tinky" );
-
-    createfile( "dipsy", 3456 );
-    checkfile( "dipsy" );
-    copyfile( "dipsy", "po" );
-    checkfile( "po" );
-    comparefiles( "dipsy", "po" );
-
-
-    /*for(i=0;i<2048;i++) {
-        diag_printf("<INFO>: churningchurningchurning................................ITERATION = %d\n", i);    
-        createfile( "churningchurningchurning", 4096 );
-        diag_printf("<INFO>: unlink churningchurningchurning\n");    
-        err = unlink( "churningchurningchurning" );
-        if( err < 0 ) SHOW_RESULT( unlink, err );
-    }*/
-
-
-    listdir( ".", true, 5, NULL );
-    listdir( "", true, 5, NULL );
-    listdir( "..", true, existingdirents+3, NULL );
-
-    // --------------------------------------------------------------
-
-    diag_printf("<INFO>: unlink tinky\n");    
-    err = unlink( "tinky" );
-    if( err < 0 ) SHOW_RESULT( unlink, err );
-
-    diag_printf("<INFO>: unlink dipsy\n");    
-    err = unlink( "dipsy" );
-    if( err < 0 ) SHOW_RESULT( unlink, err );
-
-    diag_printf("<INFO>: unlink po\n");    
-    err = unlink( "po" );
-    if( err < 0 ) SHOW_RESULT( unlink, err );
-
-    diag_printf("<INFO>: cd ..\n"); 
-    err = chdir( ".." );
-    if( err < 0 ) SHOW_RESULT( chdir, err );
-    checkcwd( "/jffs2" );
-    
-    diag_printf("<INFO>: rmdir noonoo\n"); 
-    err = rmdir( "noonoo" );
-    if( err < 0 ) SHOW_RESULT( rmdir, err );
-
-    // --------------------------------------------------------------
-
-    err = mkdir( "x", 0 );
-    if( err < 0 ) SHOW_RESULT( mkdir, err );
-    
-    err = mkdir( "x/y", 0 );
-    if( err < 0 ) SHOW_RESULT( mkdir, err );
-    
-    err = mkdir( "x/y/z", 0 );
-    if( err < 0 ) SHOW_RESULT( mkdir, err );
-
-    err = mkdir( "x/y/z/w", 0 );
-    if( err < 0 ) SHOW_RESULT( mkdir, err );
-    
-    diag_printf("<INFO>: cd /jffs2/x/y/z/w\n");
-    err = chdir( "/jffs2/x/y/z/w" );
-    if( err < 0 ) SHOW_RESULT( chdir, err );
-    checkcwd( "/jffs2/x/y/z/w" );
-
-    diag_printf("<INFO>: cd ..\n");
-    err = chdir( ".." );
-    if( err < 0 ) SHOW_RESULT( chdir, err );
-    checkcwd( "/jffs2/x/y/z" );
-    
-    diag_printf("<INFO>: cd .\n");
-    err = chdir( "." );
-    if( err < 0 ) SHOW_RESULT( chdir, err );
-    checkcwd( "/jffs2/x/y/z" );
-
-    diag_printf("<INFO>: cd ../../y\n");
-    err = chdir( "../../y" );
-    if( err < 0 ) SHOW_RESULT( chdir, err );
-    checkcwd( "/jffs2/x/y" );
-
-    diag_printf("<INFO>: cd ../..\n");
-    err = chdir( "../.." );
-    if( err < 0 ) SHOW_RESULT( chdir, err );
-    checkcwd( "/jffs2" );
-
-    diag_printf("<INFO>: rmdir x/y/z/w\n"); 
-    err = rmdir( "x/y/z/w" );
-    if( err < 0 ) SHOW_RESULT( rmdir, err );
-
-    diag_printf("<INFO>: rmdir x/y/z\n"); 
-    err = rmdir( "x/y/z" );
-    if( err < 0 ) SHOW_RESULT( rmdir, err );
-
-    diag_printf("<INFO>: rmdir x/y\n"); 
-    err = rmdir( "x/y" );
-    if( err < 0 ) SHOW_RESULT( rmdir, err );
-
-    diag_printf("<INFO>: rmdir x\n"); 
-    err = rmdir( "x" );
-    if( err < 0 ) SHOW_RESULT( rmdir, err );
-    
-    // --------------------------------------------------------------
-    
-    diag_printf("<INFO>: unlink tinky\n");    
-    err = unlink( "tinky" );
-    if( err < 0 ) SHOW_RESULT( unlink, err );
-
-    diag_printf("<INFO>: unlink laalaa\n");    
-    err = unlink( "laalaa" );
-    if( err < 0 ) SHOW_RESULT( unlink, err );
-
-    diag_printf("<INFO>: cd /\n");    
-    err = chdir( "/" );
-    if( err < 0 ) SHOW_RESULT( chdir, err );
-    checkcwd( "/" );
-    
-    diag_printf("<INFO>: umount /jffs2\n");    
-    err = umount( "/jffs2" );
-    if( err < 0 ) SHOW_RESULT( umount, err );    
-    
-    diag_printf("<INFO>: umount /\n");    
-    err = umount( "/" );
-    if( err < 0 ) SHOW_RESULT( umount, err );    
-    
-    CYG_TEST_PASS_FINISH("fileio1");
-}
-
-// -------------------------------------------------------------------------
-// EOF fileio1.c
diff -Nur linux/fs/jffs2/ecos/tests/romfileio1.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/tests/romfileio1.c
--- linux/fs/jffs2/ecos/tests/romfileio1.c	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ecos/tests/romfileio1.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,359 +0,0 @@
-//==========================================================================
-//
-//      fileio1.c
-//
-//      Test fileio system
-//
-//==========================================================================
-//####COPYRIGHTBEGIN####
-//                                                                          
-// -------------------------------------------                              
-// The contents of this file are subject to the Red Hat eCos Public License 
-// Version 1.1 (the "License"); you may not use this file except in         
-// compliance with the License.  You may obtain a copy of the License at    
-// http://www.redhat.com/                                                   
-//                                                                          
-// Software distributed under the License is distributed on an "AS IS"      
-// basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See the 
-// License for the specific language governing rights and limitations under 
-// the License.                                                             
-//                                                                          
-// The Original Code is eCos - Embedded Configurable Operating System,      
-// released September 30, 1998.                                             
-//                                                                          
-// The Initial Developer of the Original Code is Red Hat.                   
-// Portions created by Red Hat are                                          
-// Copyright (C) 1998, 1999, 2000, 2001 Red Hat, Inc.                       
-// All Rights Reserved.                                                     
-// -------------------------------------------                              
-//                                                                          
-//####COPYRIGHTEND####
-//==========================================================================
-//#####DESCRIPTIONBEGIN####
-//
-// Author(s):           nickg
-// Contributors:        nickg, richard.panton@3glab.com
-// Date:                2000-05-25
-// Purpose:             Test fileio system
-// Description:         This test uses the testfs to check out the initialization
-//                      and basic operation of the fileio system
-//
-//####DESCRIPTIONEND####
-//
-//==========================================================================
-
-#include <pkgconf/hal.h>
-#include <pkgconf/kernel.h>
-#include <pkgconf/io_fileio.h>
-
-#include <cyg/kernel/ktypes.h>         // base kernel types
-#include <cyg/infra/cyg_trac.h>        // tracing macros
-#include <cyg/infra/cyg_ass.h>         // assertion macros
-
-#include <unistd.h>
-#include <fcntl.h>
-#include <sys/stat.h>
-#include <errno.h>
-#include <string.h>
-#include <dirent.h>
-
-#include <cyg/fileio/fileio.h>
-
-#include <cyg/infra/testcase.h>
-#include <cyg/infra/diag.h>            // HAL polled output
-
-#include <pkgconf/fs_jffs2.h>	// Address of JFFS2
-
-//==========================================================================
-
-/* MTAB_ENTRY( jffs2_mte1,
-                   "/",
-                   "jffs2",
-                   "",
-                   (CYG_ADDRWORD) CYGNUM_FS_JFFS2_BASE_ADDRESS ); */
-
-
-//==========================================================================
-
-#define SHOW_RESULT( _fn, _res ) \
-diag_printf("<FAIL>: " #_fn "() returned %d %s\n", _res, _res<0?strerror(errno):"");
-
-#define CHKFAIL_TYPE( _fn, _res, _type ) { \
-if ( _res != -1 ) \
-    diag_printf("<FAIL>: " #_fn "() returned %d (expected -1)\n", _res); \
-else if ( errno != _type ) \
-    diag_printf("<FAIL>: " #_fn "() failed with errno %d (%s),\n    expected %d (%s)\n", errno, strerror(errno), _type, strerror(_type) ); \
-}
-
-//==========================================================================
-
-#define IOSIZE  100
-
-#define LONGNAME1       "long_file_name_that_should_take_up_more_than_one_directory_entry_1"
-#define LONGNAME2       "long_file_name_that_should_take_up_more_than_one_directory_entry_2"
-
-
-//==========================================================================
-
-#ifndef CYGPKG_LIBC_STRING
-
-char *strcat( char *s1, const char *s2 )
-{
-    char *s = s1;
-    while( *s1 ) s1++;
-    while( (*s1++ = *s2++) != 0);
-    return s;
-}
-
-#endif
-
-//==========================================================================
-
-static void listdir( char *name, int statp )
-{
-    int err;
-    DIR *dirp;
-    
-    diag_printf("<INFO>: reading directory %s\n",name);
-    
-    dirp = opendir( name );
-    if( dirp == NULL ) SHOW_RESULT( opendir, -1 );
-
-    for(;;)
-    {
-        struct dirent *entry = readdir( dirp );
-        
-        if( entry == NULL )
-            break;
-
-        diag_printf("<INFO>: entry %14s",entry->d_name);
-        if( statp )
-        {
-            char fullname[PATH_MAX];
-            struct stat sbuf;
-
-            if( name[0] )
-            {
-                strcpy(fullname, name );
-                if( !(name[0] == '/' && name[1] == 0 ) )
-                    strcat(fullname, "/" );
-            }
-            else fullname[0] = 0;
-            
-            strcat(fullname, entry->d_name );
-            
-            err = stat( fullname, &sbuf );
-            if( err < 0 )
-            {
-                if( errno == ENOSYS )
-                    diag_printf(" <no status available>");
-                else SHOW_RESULT( stat, err );
-            }
-            else
-            {
-                diag_printf(" [mode %08x ino %08x nlink %d size %d]",
-                            sbuf.st_mode,sbuf.st_ino,sbuf.st_nlink,sbuf.st_size);
-            }
-        }
-
-        diag_printf("\n");
-    }
-
-    err = closedir( dirp );
-    if( err < 0 ) SHOW_RESULT( stat, err );
-}
-
-//==========================================================================
-
-static void copyfile( char *name2, char *name1 )
-{
-
-    int err;
-    char buf[IOSIZE];
-    int fd1, fd2;
-    ssize_t done, wrote;
-
-    diag_printf("<INFO>: copy file %s -> %s\n",name2,name1);
-
-    err = access( name1, F_OK );
-    if( err < 0 && errno != EACCES ) SHOW_RESULT( access, err );
-
-    err = access( name2, F_OK );
-    if( err != 0 ) SHOW_RESULT( access, err );
-    
-    fd1 = open( name1, O_WRONLY|O_CREAT );
-    if( fd1 < 0 ) SHOW_RESULT( open, fd1 );
-
-    fd2 = open( name2, O_RDONLY );
-    if( fd2 < 0 ) SHOW_RESULT( open, fd2 );
-    
-    for(;;)
-    {
-        done = read( fd2, buf, IOSIZE );
-        if( done < 0 ) SHOW_RESULT( read, done );
-
-        if( done == 0 ) break;
-
-        wrote = write( fd1, buf, done );
-        if( wrote != done ) SHOW_RESULT( write, wrote );
-
-        if( wrote != done ) break;
-    }
-
-    err = close( fd1 );
-    if( err < 0 ) SHOW_RESULT( close, err );
-
-    err = close( fd2 );
-    if( err < 0 ) SHOW_RESULT( close, err );
-    
-}
-
-//==========================================================================
-
-static void comparefiles( char *name2, char *name1 )
-{
-    int err;
-    char buf1[IOSIZE];
-    char buf2[IOSIZE];
-    int fd1, fd2;
-    ssize_t done1, done2;
-    int i;
-
-    diag_printf("<INFO>: compare files %s == %s\n",name2,name1);
-
-    err = access( name1, F_OK );
-    if( err != 0 ) SHOW_RESULT( access, err );
-
-    err = access( name1, F_OK );
-    if( err != 0 ) SHOW_RESULT( access, err );
-    
-    fd1 = open( name1, O_RDONLY );
-    if( fd1 < 0 ) SHOW_RESULT( open, fd1 );
-
-    fd2 = open( name2, O_RDONLY );
-    if( fd2 < 0 ) SHOW_RESULT( open, fd2 );
-    
-    for(;;)
-    {
-        done1 = read( fd1, buf1, IOSIZE );
-        if( done1 < 0 ) SHOW_RESULT( read, done1 );
-
-        done2 = read( fd2, buf2, IOSIZE );
-        if( done2 < 0 ) SHOW_RESULT( read, done2 );
-
-        if( done1 != done2 )
-            diag_printf("Files different sizes\n");
-        
-        if( done1 == 0 ) break;
-
-        for( i = 0; i < done1; i++ )
-            if( buf1[i] != buf2[i] )
-            {
-                diag_printf("buf1[%d](%02x) != buf1[%d](%02x)\n",i,buf1[i],i,buf2[i]);
-                CYG_TEST_FAIL("Data in files not equal\n");
-            }
-    }
-
-    err = close( fd1 );
-    if( err < 0 ) SHOW_RESULT( close, err );
-
-    err = close( fd2 );
-    if( err < 0 ) SHOW_RESULT( close, err );
-    
-}
-
-//==========================================================================
-// main
-
-int main( int argc, char **argv )
-{
-    int err;
-    char address[16];
-
-    CYG_TEST_INIT();
-
-    // --------------------------------------------------------------
-
-    err = mount( "", "/", "jffs2" );
-
-    diag_printf("<INFO>: JFFS2 root follows\n");
-    diag_printf("<INFO>: Note that dev cannot be stat()ed\n");
-    listdir( "/", true );
-
-    diag_printf("<INFO>: cd /etc\n" );
-    err = chdir( "/etc" );
-    if ( err < 0 ) SHOW_RESULT( chdir, err );
-
-    diag_printf("<INFO>: JFFS2 list of '' follows\n");
-    listdir( "", true );
-
-    diag_printf("<INFO>: JFFS2 list of /etc follows\n");
-    listdir( "/etc", true );
-
-    //diag_printf("<INFO>: JFFS2 list of . follows\n");
-    //listdir( ".", true );
-    
-    err = mount( "", "/var", "ramfs" );
-    if( err < 0 ) SHOW_RESULT( mount, err );    
-
-    copyfile( "/etc/passwd", "/var/passwd_copy" );
-
-    comparefiles( "/etc/passwd", "/var/passwd_copy" );
-    
-    diag_printf("<INFO>: JFFS2 list of / follows\n");
-    diag_printf("<INFO>: Note that /var now gives stat() info for RAMFS\n");
-    listdir( "/", true );
-
-    diag_printf("<INFO>: Mount JFFS2 again onto /mnt\n");
-    //sprintf( address, "%p", (void*)CYGNUM_FS_JFFS2_BASE_ADDRESS );
-    err = mount( "", "/mnt", "jffs2" );
-    if( err < 0 ) SHOW_RESULT( mount, err );    
-
-    comparefiles( "/etc/passwd", "/mnt/etc/passwd" );
-
-
-    err = mkdir( "/foo", 0 );
-    CHKFAIL_TYPE( mkdir, err, EROFS );
-
-    err = rename( "/var", "/tmp" );	// RAMFS is mounted here
-    CHKFAIL_TYPE( rename, err, EXDEV );
-
-    err = rename( "/var/passwd_copy", "/mnt/etc/passwd_copy" );
-    CHKFAIL_TYPE( rename, err, EXDEV );
-
-    err = rename( "/etc", "/tmp" );
-    CHKFAIL_TYPE( rename, err, EROFS );
-
-    diag_printf("<INFO>: cd /etc\n");
-    err = chdir( "/etc" );
-    if( err < 0 ) SHOW_RESULT( chdir, err );
-
-    err = chdir( "/mnt/etc" );
-    if( err < 0 ) SHOW_RESULT( chdir, err );
-
-    //listdir( ".", true );
-
-    diag_printf("<INFO>: unlink /tmp\n");        
-    err = unlink( "/tmp" );
-    CHKFAIL_TYPE( unlink, err, EROFS );
-
-    diag_printf("<INFO>: mount random area\n");
-    //sprintf(address, "%p", (void*)(CYGNUM_FS_JFFS2_BASE_ADDRESS + 0x20000));
-    err = mount( "", "/tmp", "jffs2" );
-    SHOW_RESULT( mount, err );
-
-    err = umount( "/mnt" );
-    if( err < 0 ) SHOW_RESULT( umount, err );    
-
-    err = umount( "/var" );
-    if( err < 0 ) SHOW_RESULT( umount, err );    
-
-    err = umount( "/" );
-    if( err < 0 ) SHOW_RESULT( umount, err );    
-
-
-    CYG_TEST_PASS_FINISH("fileio1");
-}
-
-// -------------------------------------------------------------------------
-// EOF fileio1.c
diff -Nur linux/fs/jffs2/erase.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/erase.c
--- linux/fs/jffs2/erase.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/erase.c	2003-06-23 01:47:04.000000000 +0700
@@ -1,30 +1,46 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
+ * Copyright (C) 2001 Red Hat, Inc.
  *
  * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: erase.c,v 1.42 2002/09/06 14:12:44 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
  *
- * ChangeLog:
- *     29-Oct-2002 Lineo Japan, Inc.  add member struct jffs2_sb_info#nr_bad_blocks
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
  *
- * ChangeLog:
- *     29-Oct-2002 Lineo Japan, Inc.  add member struct jffs2_sb_info#nr_bad_blocks
- *     24-Nov-2002 SHARP  add erasing_dirty_size
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: erase.c,v 1.24 2001/12/06 16:38:38 dwmw2 Exp $
  *
  */
-
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/mtd/mtd.h>
+#include <linux/jffs2.h>
 #include <linux/interrupt.h>
-#include <linux/compiler.h>
-#include "crc32.h"
 #include "nodelist.h"
+#include "crc32.h"
 
 struct erase_priv_struct {
 	struct jffs2_eraseblock *jeb;
@@ -32,13 +48,12 @@
 };
       
 static void jffs2_erase_callback(struct erase_info *);
-static void jffs2_erase_succeeded(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);
 static void jffs2_free_all_node_refs(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);
 
 void jffs2_erase_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)
 {
-	int ret;
 	struct erase_info *instr;
+	int ret;
 
 	instr = kmalloc(sizeof(struct erase_info) + sizeof(struct erase_priv_struct), GFP_KERNEL);
 	if (!instr) {
@@ -62,16 +77,10 @@
 	((struct erase_priv_struct *)instr->priv)->jeb = jeb;
 	((struct erase_priv_struct *)instr->priv)->c = c;
 
-	/* NAND , read out the fail counter, if possible */
-	if (!jffs2_can_mark_obsolete(c)) 
-		jffs2_nand_read_failcnt(c,jeb);
-		
 	ret = c->mtd->erase(c->mtd, instr);
-	if (!ret)
+	if (!ret) {
 		return;
-
-	kfree(instr);
-
+	}
 	if (ret == -ENOMEM || ret == -EAGAIN) {
 		/* Erase failed immediately. Refile it on the list */
 		D1(printk(KERN_DEBUG "Erase at 0x%08x failed: %d. Refiling on erase_pending_list\n", jeb->offset, ret));
@@ -80,6 +89,7 @@
 		list_add(&jeb->list, &c->erase_pending_list);
 		c->erasing_size -= c->sector_size;
 		spin_unlock_bh(&c->erase_completion_lock);
+		kfree(instr);
 		return;
 	}
 
@@ -87,24 +97,21 @@
 		printk(KERN_WARNING "Erase at 0x%08x failed immediately: -EROFS. Is the sector locked?\n", jeb->offset);
 	else
 		printk(KERN_WARNING "Erase at 0x%08x failed immediately: errno %d\n", jeb->offset, ret);
-
 	spin_lock_bh(&c->erase_completion_lock);
 	list_del(&jeb->list);
 	list_add(&jeb->list, &c->bad_list);
 	c->nr_erasing_blocks--;
-	c->nr_bad_blocks++;
 	c->bad_size += c->sector_size;
 	c->erasing_size -= c->sector_size;
 	spin_unlock_bh(&c->erase_completion_lock);
 	wake_up(&c->erase_wait);
+	kfree(instr);
 }
 
 void jffs2_erase_pending_blocks(struct jffs2_sb_info *c)
 {
 	struct jffs2_eraseblock *jeb;
 
-	down(&c->erase_free_sem);
-
 	spin_lock_bh(&c->erase_completion_lock);
 	while (!list_empty(&c->erase_pending_list)) {
 
@@ -117,64 +124,45 @@
 		c->free_size -= jeb->free_size;
 		c->used_size -= jeb->used_size;
 		c->dirty_size -= jeb->dirty_size;
-		if(c->erasing_dirty_size >= jeb->dirty_size)
-			c->erasing_dirty_size -= jeb->dirty_size;
-		else
-			c->erasing_dirty_size = 0;
 		jeb->used_size = jeb->dirty_size = jeb->free_size = 0;
 		jffs2_free_all_node_refs(c, jeb);
 		list_add(&jeb->list, &c->erasing_list);
 		spin_unlock_bh(&c->erase_completion_lock);
 		
 		jffs2_erase_block(c, jeb);
-
 		/* Be nice */
-		cond_resched();
-
+		if (current->need_resched)
+			schedule();
 		spin_lock_bh(&c->erase_completion_lock);
 	}
 	spin_unlock_bh(&c->erase_completion_lock);
 	D1(printk(KERN_DEBUG "jffs2_erase_pending_blocks completed\n"));
-
-	up(&c->erase_free_sem);
 }
 
 
-static void jffs2_erase_succeeded(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)
-{
-	D1(printk(KERN_DEBUG "Erase completed successfully at 0x%08x\n", jeb->offset));
-	spin_lock(&c->erase_completion_lock);
-	list_del(&jeb->list);
-	list_add_tail(&jeb->list, &c->erase_complete_list);
-	spin_unlock(&c->erase_completion_lock);
-}
-
-
-static inline void jffs2_erase_failed(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)
-{
-	 spin_lock(&c->erase_completion_lock);
-	 c->erasing_size -= c->sector_size;
-	 c->bad_size += c->sector_size;
-	 list_del(&jeb->list);
-	 list_add(&jeb->list, &c->bad_list);
-	 c->nr_erasing_blocks--;
-	 c->nr_bad_blocks++;
-	 spin_unlock(&c->erase_completion_lock);
-	 wake_up(&c->erase_wait);
-}	 
-
 static void jffs2_erase_callback(struct erase_info *instr)
 {
 	struct erase_priv_struct *priv = (void *)instr->priv;
 
 	if(instr->state != MTD_ERASE_DONE) {
 		printk(KERN_WARNING "Erase at 0x%08x finished, but state != MTD_ERASE_DONE. State is 0x%x instead.\n", instr->addr, instr->state);
-		jffs2_erase_failed(priv->c, priv->jeb);
+		spin_lock(&priv->c->erase_completion_lock);
+		priv->c->erasing_size -= priv->c->sector_size;
+		priv->c->bad_size += priv->c->sector_size;
+		list_del(&priv->jeb->list);
+		list_add(&priv->jeb->list, &priv->c->bad_list);
+		priv->c->nr_erasing_blocks--;
+		spin_unlock(&priv->c->erase_completion_lock);
+		wake_up(&priv->c->erase_wait);
 	} else {
-		jffs2_erase_succeeded(priv->c, priv->jeb);
+		D1(printk(KERN_DEBUG "Erase completed successfully at 0x%08x\n", instr->addr));
+		spin_lock(&priv->c->erase_completion_lock);
+		list_del(&priv->jeb->list);
+		list_add_tail(&priv->jeb->list, &priv->c->erase_complete_list);
+		spin_unlock(&priv->c->erase_completion_lock);
 	}	
 	/* Make sure someone picks up the block off the erase_complete list */
-//	OFNI_BS_2SFFJ(priv->c)->s_dirt = 1;
+	OFNI_BS_2SFFJ(priv->c)->s_dirt = 1;
 	kfree(instr);
 }
 
@@ -233,7 +221,7 @@
 		this = ic->nodes;
 	   
 		while(this) {
-			printk( "0x%08x(%d)->", ref_offset(this), ref_flags(this));
+			printk( "0x%08x(%d)->", this->flash_offset & ~3, this->flash_offset &3);
 			if (++i == 5) {
 				printk("\n" KERN_DEBUG);
 				i=0;
@@ -275,40 +263,42 @@
 
 void jffs2_mark_erased_blocks(struct jffs2_sb_info *c)
 {
+	static struct jffs2_unknown_node marker = {JFFS2_MAGIC_BITMASK, JFFS2_NODETYPE_CLEANMARKER, sizeof(struct jffs2_unknown_node)};
 	struct jffs2_eraseblock *jeb;
-	struct jffs2_raw_node_ref *marker_ref = NULL;
+	struct jffs2_raw_node_ref *marker_ref;
 	unsigned char *ebuf;
-	size_t retlen;
+	ssize_t retlen;
 	int ret;
 
+	marker.hdr_crc = crc32(0, &marker, sizeof(struct jffs2_unknown_node)-4);
+
 	spin_lock_bh(&c->erase_completion_lock);
 	while (!list_empty(&c->erase_complete_list)) {
 		jeb = list_entry(c->erase_complete_list.next, struct jffs2_eraseblock, list);
 		list_del(&jeb->list);
 		spin_unlock_bh(&c->erase_completion_lock);
 
-		if (!jffs2_cleanmarker_oob(c)) {
-			marker_ref = jffs2_alloc_raw_node_ref();
-			if (!marker_ref) {
-				printk(KERN_WARNING "Failed to allocate raw node ref for clean marker\n");
-				/* Come back later */
-				jffs2_erase_pending_trigger(c);
-				return;
-			}
+		marker_ref = jffs2_alloc_raw_node_ref();
+		if (!marker_ref) {
+			printk(KERN_WARNING "Failed to allocate raw node ref for clean marker\n");
+			/* Come back later */
+			jffs2_erase_pending_trigger(c);
+			return;
 		}
+
 		ebuf = kmalloc(PAGE_SIZE, GFP_KERNEL);
 		if (!ebuf) {
 			printk(KERN_WARNING "Failed to allocate page buffer for verifying erase at 0x%08x. Assuming it worked\n", jeb->offset);
 		} else {
-			uint32_t ofs = jeb->offset;
+			__u32 ofs = jeb->offset;
 
 			D1(printk(KERN_DEBUG "Verifying erase at 0x%08x\n", jeb->offset));
 			while(ofs < jeb->offset + c->sector_size) {
-				uint32_t readlen = min((uint32_t)PAGE_SIZE, jeb->offset + c->sector_size - ofs);
+				__u32 readlen = min((__u32)PAGE_SIZE, jeb->offset + c->sector_size - ofs);
 				int i;
 
-				ret = jffs2_flash_read(c, ofs, readlen, &retlen, ebuf);
-				if (ret) {
+				ret = c->mtd->read(c->mtd, ofs, readlen, &retlen, ebuf);
+				if (ret < 0) {
 					printk(KERN_WARNING "Read of newly-erased block at 0x%08x failed: %d. Putting on bad_list\n", ofs, ret);
 					goto bad;
 				}
@@ -322,10 +312,7 @@
 					if (datum + 1) {
 						printk(KERN_WARNING "Newly-erased block contained word 0x%lx at offset 0x%08x\n", datum, ofs + i);
 					bad: 
-						if (!jffs2_cleanmarker_oob(c))
-							jffs2_free_raw_node_ref(marker_ref);
-						else 
-							jffs2_write_nand_badblock( c ,jeb );
+						jffs2_free_raw_node_ref(marker_ref);
 						kfree(ebuf);
 					bad2:
 						spin_lock_bh(&c->erase_completion_lock);
@@ -334,64 +321,40 @@
 
 						list_add_tail(&jeb->list, &c->bad_list);
 						c->nr_erasing_blocks--;
-						c->nr_bad_blocks++;
 						spin_unlock_bh(&c->erase_completion_lock);
 						wake_up(&c->erase_wait);
 						return;
 					}
 				}
 				ofs += readlen;
-				cond_resched();
 			}
 			kfree(ebuf);
 		}
 					
 		/* Write the erase complete marker */	
 		D1(printk(KERN_DEBUG "Writing erased marker to block at 0x%08x\n", jeb->offset));
-		if (jffs2_cleanmarker_oob(c)) {
-
-			if (jffs2_write_nand_cleanmarker(c, jeb))
-				goto bad2;
-			
-			jeb->first_node = jeb->last_node = NULL;
-			
-			jeb->free_size = c->sector_size;
-			jeb->used_size = 0;
-			jeb->dirty_size = 0;
-			jeb->wasted_size = 0;
-		} else {
-			struct jffs2_unknown_node marker = {
-				.magic =	cpu_to_je16(JFFS2_MAGIC_BITMASK),
-				.nodetype =	cpu_to_je16(JFFS2_NODETYPE_CLEANMARKER),
-				.totlen =	cpu_to_je32(c->cleanmarker_size)
-			};
-
-			marker.hdr_crc = cpu_to_je32(crc32(0, &marker, je32_to_cpu(marker.totlen) - 4));
-
-			ret = jffs2_flash_write(c, jeb->offset, je32_to_cpu(marker.totlen), &retlen, (char *)&marker);
-			if (ret) {
-				printk(KERN_WARNING "Write clean marker to block at 0x%08x failed: %d\n",
-				       jeb->offset, ret);
-				goto bad2;
-			}
-			if (retlen != je32_to_cpu(marker.totlen)) {
-				printk(KERN_WARNING "Short write to newly-erased block at 0x%08x: Wanted %d, got %d\n",
-				       jeb->offset, je32_to_cpu(marker.totlen), retlen);
-				goto bad2;
-			}
-			
-			marker_ref->next_in_ino = NULL;
-			marker_ref->next_phys = NULL;
-			marker_ref->flash_offset = jeb->offset;
-			marker_ref->totlen = PAD(je32_to_cpu(marker.totlen));
-			
-			jeb->first_node = jeb->last_node = marker_ref;
-			
-			jeb->free_size = c->sector_size - marker_ref->totlen;
-			jeb->used_size = marker_ref->totlen;
-			jeb->dirty_size = 0;
-			jeb->wasted_size = 0;
+		ret = c->mtd->write(c->mtd, jeb->offset, sizeof(marker), &retlen, (char *)&marker);
+		if (ret) {
+			printk(KERN_WARNING "Write clean marker to block at 0x%08x failed: %d\n",
+			       jeb->offset, ret);
+			goto bad2;
 		}
+		if (retlen != sizeof(marker)) {
+			printk(KERN_WARNING "Short write to newly-erased block at 0x%08x: Wanted %d, got %d\n",
+			       jeb->offset, sizeof(marker), retlen);
+			goto bad2;
+		}
+
+		marker_ref->next_in_ino = NULL;
+		marker_ref->next_phys = NULL;
+		marker_ref->flash_offset = jeb->offset;
+		marker_ref->totlen = PAD(sizeof(marker));
+
+		jeb->first_node = jeb->last_node = marker_ref;
+
+		jeb->free_size = c->sector_size - marker_ref->totlen;
+		jeb->used_size = marker_ref->totlen;
+		jeb->dirty_size = 0;
 
 		spin_lock_bh(&c->erase_completion_lock);
 		c->erasing_size -= c->sector_size;
diff -Nur linux/fs/jffs2/file.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/file.c
--- linux/fs/jffs2/file.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/file.c	2003-06-23 01:47:04.000000000 +0700
@@ -1,18 +1,37 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
+ * Copyright (C) 2001 Red Hat, Inc.
  *
  * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: file.c,v 1.79 2002/10/07 12:41:16 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
  *
- * ChangeLog:
- *     28-Nov-2002 Lineo Japan, Inc.  fix deadlock between f->sem and c->alloc_sem
- *     19-Nov-2002 Lineo Japan, Inc.  add counter of fragtree elements
- *     18-Nov-2002 Lineo Japan, Inc.  add dynamic construction of fragtree
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: file.c,v 1.58.2.1 2002/02/23 14:25:36 dwmw2 Exp $
  *
  */
 
@@ -20,67 +39,44 @@
 #include <linux/mtd/compatmac.h> /* for min() */
 #include <linux/slab.h>
 #include <linux/fs.h>
-#include <linux/time.h>
 #include <linux/pagemap.h>
-#include "crc32.h"
 #include <linux/jffs2.h>
 #include "nodelist.h"
+#include "crc32.h"
 
 extern int generic_file_open(struct inode *, struct file *) __attribute__((weak));
 extern loff_t generic_file_llseek(struct file *file, loff_t offset, int origin) __attribute__((weak));
 
 
-int jffs2_fsync(struct file *filp, struct dentry *dentry, int datasync)
+int jffs2_null_fsync(struct file *filp, struct dentry *dentry, int datasync)
 {
-	struct inode *inode = dentry->d_inode;
-	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
-	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
-	if (!c->wbuf || !c->wbuf_len)
-		return 0;
-
-	/* flush write buffer and update c->nextblock */
-	
-	/* FIXME NAND */
-	/* At the moment we flush the buffer, to make sure
-	 * that every thing is on the flash.
-	 * maybe we have to think about it to find a smarter
-	 * solution.
-	 */
-	down(&c->alloc_sem);
-	down(&f->sem);
-	jffs2_flush_wbuf(c,2);
-	up(&f->sem);
-	up(&c->alloc_sem);
-			
-	return 0;	
+	/* Move along. Nothing to see here */
+	return 0;
 }
 
 struct file_operations jffs2_file_operations =
 {
-	.llseek =	generic_file_llseek,
-	.open =		generic_file_open,
-	.read =		generic_file_read,
-	.write =	generic_file_write,
-	.ioctl =	jffs2_ioctl,
-	.mmap =		generic_file_mmap,
-	.fsync =	jffs2_fsync,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,29)
-	.sendfile =	generic_file_sendfile
-#endif
+	llseek:		generic_file_llseek,
+	open:		generic_file_open,
+	read:		generic_file_read,
+	write:		generic_file_write,
+	ioctl:		jffs2_ioctl,
+	mmap:		generic_file_mmap,
+	fsync:		jffs2_null_fsync
 };
 
 /* jffs2_file_inode_operations */
 
 struct inode_operations jffs2_file_inode_operations =
 {
-	.setattr =	jffs2_setattr
+	setattr:	jffs2_setattr
 };
 
 struct address_space_operations jffs2_file_address_operations =
 {
-	.readpage =	jffs2_readpage,
-	.prepare_write =jffs2_prepare_write,
-	.commit_write =	jffs2_commit_write
+	readpage:	jffs2_readpage,
+	prepare_write:	jffs2_prepare_write,
+	commit_write:	jffs2_commit_write
 };
 
 int jffs2_setattr (struct dentry *dentry, struct iattr *iattr)
@@ -94,7 +90,7 @@
 	unsigned char *mdata = NULL;
 	int mdatalen = 0;
 	unsigned int ivalid;
-	uint32_t phys_ofs, alloclen;
+	__u32 phys_ofs, alloclen;
 	int ret;
 	D1(printk(KERN_DEBUG "jffs2_setattr(): ino #%lu\n", inode->i_ino));
 	ret = inode_change_ok(inode, iattr);
@@ -108,8 +104,8 @@
 	   it out again with the appropriate data attached */
 	if (S_ISBLK(inode->i_mode) || S_ISCHR(inode->i_mode)) {
 		/* For these, we don't actually need to read the old node */
-		dev =  (major(dentry->d_inode->i_rdev) << 8) | 
-			minor(dentry->d_inode->i_rdev);
+		dev =  (MAJOR(to_kdev_t(dentry->d_inode->i_rdev)) << 8) | 
+			MINOR(to_kdev_t(dentry->d_inode->i_rdev));
 		mdata = (char *)&dev;
 		mdatalen = sizeof(dev);
 		D1(printk(KERN_DEBUG "jffs2_setattr(): Writing %d bytes of kdev_t\n", mdatalen));
@@ -126,17 +122,6 @@
 		D1(printk(KERN_DEBUG "jffs2_setattr(): Writing %d bytes of symlink target\n", mdatalen));
 	}
 
-	ivalid = iattr->ia_valid;
-
-	if (ivalid & ATTR_SIZE && inode->i_size != iattr->ia_size) {
-		ret = jffs2_construct_fragtree_if_missing(c, f);
-		if (ret) {
-			if (S_ISLNK(inode->i_mode))
-				kfree(mdata);
-			return ret;
-		}
-	}
-
 	ri = jffs2_alloc_raw_inode();
 	if (!ri) {
 		if (S_ISLNK(inode->i_mode))
@@ -147,82 +132,79 @@
 	ret = jffs2_reserve_space(c, sizeof(*ri) + mdatalen, &phys_ofs, &alloclen, ALLOC_NORMAL);
 	if (ret) {
 		jffs2_free_raw_inode(ri);
-		if (S_ISLNK(inode->i_mode & S_IFMT))
+		if (S_ISLNK(inode->i_mode))
 			 kfree(mdata);
 		return ret;
 	}
 	down(&f->sem);
+        ivalid = iattr->ia_valid;
 	
-	ri->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
-	ri->nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);
-	ri->totlen = cpu_to_je32(sizeof(*ri) + mdatalen);
-	ri->hdr_crc = cpu_to_je32(crc32(0, ri, sizeof(struct jffs2_unknown_node)-4));
-
-	ri->ino = cpu_to_je32(inode->i_ino);
-	ri->version = cpu_to_je32(++f->highest_version);
-
-	ri->uid = cpu_to_je16((ivalid & ATTR_UID)?iattr->ia_uid:inode->i_uid);
-	ri->gid = cpu_to_je16((ivalid & ATTR_GID)?iattr->ia_gid:inode->i_gid);
-
-	if (ivalid & ATTR_MODE)
-		if (iattr->ia_mode & S_ISGID &&
-		    !in_group_p(je16_to_cpu(ri->gid)) && !capable(CAP_FSETID))
-			ri->mode = cpu_to_je32(iattr->ia_mode & ~S_ISGID);
-		else 
-			ri->mode = cpu_to_je32(iattr->ia_mode);
-	else
-		ri->mode = cpu_to_je32(inode->i_mode);
-
-
-	ri->isize = cpu_to_je32((ivalid & ATTR_SIZE)?iattr->ia_size:inode->i_size);
-	ri->atime = cpu_to_je32((ivalid & ATTR_ATIME)?iattr->ia_atime:inode->i_atime);
-	ri->mtime = cpu_to_je32((ivalid & ATTR_MTIME)?iattr->ia_mtime:inode->i_mtime);
-	ri->ctime = cpu_to_je32((ivalid & ATTR_CTIME)?iattr->ia_ctime:inode->i_ctime);
+	ri->magic = JFFS2_MAGIC_BITMASK;
+	ri->nodetype = JFFS2_NODETYPE_INODE;
+	ri->totlen = sizeof(*ri) + mdatalen;
+	ri->hdr_crc = crc32(0, ri, sizeof(struct jffs2_unknown_node)-4);
+
+	ri->ino = inode->i_ino;
+	ri->version = ++f->highest_version;
+
+	ri->mode = (ivalid & ATTR_MODE)?iattr->ia_mode:inode->i_mode;
+	ri->uid = (ivalid & ATTR_UID)?iattr->ia_uid:inode->i_uid;
+	ri->gid = (ivalid & ATTR_GID)?iattr->ia_gid:inode->i_gid;
+
+	if (ivalid & ATTR_MODE && ri->mode & S_ISGID &&
+	    !in_group_p(ri->gid) && !capable(CAP_FSETID))
+		ri->mode &= ~S_ISGID;
+
+	ri->isize = (ivalid & ATTR_SIZE)?iattr->ia_size:inode->i_size;
+	ri->atime = (ivalid & ATTR_ATIME)?iattr->ia_atime:inode->i_atime;
+	ri->mtime = (ivalid & ATTR_MTIME)?iattr->ia_mtime:inode->i_mtime;
+	ri->ctime = (ivalid & ATTR_CTIME)?iattr->ia_ctime:inode->i_ctime;
 
-	ri->offset = cpu_to_je32(0);
-	ri->csize = ri->dsize = cpu_to_je32(mdatalen);
+	ri->offset = 0;
+	ri->csize = ri->dsize = mdatalen;
 	ri->compr = JFFS2_COMPR_NONE;
-	if (ivalid & ATTR_SIZE && inode->i_size < iattr->ia_size) {
+	if (inode->i_size < ri->isize) {
 		/* It's an extension. Make it a hole node */
 		ri->compr = JFFS2_COMPR_ZERO;
-		ri->dsize = cpu_to_je32(iattr->ia_size - inode->i_size);
-		ri->offset = cpu_to_je32(inode->i_size);
+		ri->dsize = ri->isize - inode->i_size;
+		ri->offset = inode->i_size;
 	}
-	ri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));
+	ri->node_crc = crc32(0, ri, sizeof(*ri)-8);
 	if (mdatalen)
-		ri->data_crc = cpu_to_je32(crc32(0, mdata, mdatalen));
+		ri->data_crc = crc32(0, mdata, mdatalen);
 	else
-		ri->data_crc = cpu_to_je32(0);
+		ri->data_crc = 0;
 
-	new_metadata = jffs2_write_dnode(c, f, ri, mdata, mdatalen, phys_ofs, NULL);
+	new_metadata = jffs2_write_dnode(inode, ri, mdata, mdatalen, phys_ofs, NULL);
 	if (S_ISLNK(inode->i_mode))
 		kfree(mdata);
+
+	jffs2_complete_reservation(c);
 	
 	if (IS_ERR(new_metadata)) {
-		jffs2_complete_reservation(c);
 		jffs2_free_raw_inode(ri);
 		up(&f->sem);
 		return PTR_ERR(new_metadata);
 	}
 	/* It worked. Update the inode */
-	inode->i_atime = je32_to_cpu(ri->atime);
-	inode->i_ctime = je32_to_cpu(ri->ctime);
-	inode->i_mtime = je32_to_cpu(ri->mtime);
-	inode->i_mode = je32_to_cpu(ri->mode);
-	inode->i_uid = je16_to_cpu(ri->uid);
-	inode->i_gid = je16_to_cpu(ri->gid);
+	inode->i_atime = ri->atime;
+	inode->i_ctime = ri->ctime;
+	inode->i_mtime = ri->mtime;
+	inode->i_mode = ri->mode;
+	inode->i_uid = ri->uid;
+	inode->i_gid = ri->gid;
 
 
 	old_metadata = f->metadata;
 
-	if (ivalid & ATTR_SIZE && inode->i_size > iattr->ia_size) {
-		vmtruncate(inode, iattr->ia_size);
-		jffs2_truncate_fraglist (c, f, iattr->ia_size);
+	if (inode->i_size > ri->isize) {
+		vmtruncate(inode, ri->isize);
+		jffs2_truncate_fraglist (c, &f->fraglist, ri->isize);
 	}
 
-	if (ivalid & ATTR_SIZE && inode->i_size < iattr->ia_size) {
+	if (inode->i_size < ri->isize) {
 		jffs2_add_full_dnode_to_inode(c, f, new_metadata);
-		inode->i_size = iattr->ia_size;
+		inode->i_size = ri->isize;
 		f->metadata = NULL;
 	} else {
 		f->metadata = new_metadata;
@@ -232,10 +214,7 @@
 		jffs2_free_full_dnode(old_metadata);
 	}
 	jffs2_free_raw_inode(ri);
-
 	up(&f->sem);
-	jffs2_complete_reservation(c);
-
 	return 0;
 }
 
@@ -243,30 +222,85 @@
 {
 	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
 	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
+	struct jffs2_node_frag *frag = f->fraglist;
+	__u32 offset = pg->index << PAGE_CACHE_SHIFT;
+	__u32 end = offset + PAGE_CACHE_SIZE;
 	unsigned char *pg_buf;
 	int ret;
 
-	D1(printk(KERN_DEBUG "jffs2_do_readpage_nolock(): ino #%lu, page at offset 0x%lx\n", inode->i_ino, pg->index << PAGE_CACHE_SHIFT));
+	D1(printk(KERN_DEBUG "jffs2_do_readpage_nolock(): ino #%lu, page at offset 0x%x\n", inode->i_ino, offset));
 
 	if (!PageLocked(pg))
                 PAGE_BUG(pg);
 
-	pg_buf = kmap(pg);
-	/* FIXME: Can kmap fail? */
+	while(frag && frag->ofs + frag->size  <= offset) {
+		//		D1(printk(KERN_DEBUG "skipping frag %d-%d; before the region we care about\n", frag->ofs, frag->ofs + frag->size));
+		frag = frag->next;
+	}
 
-	ret = jffs2_read_inode_range(c, f, pg_buf, pg->index << PAGE_CACHE_SHIFT, PAGE_CACHE_SIZE);
+	pg_buf = kmap(pg);
 
-	if (ret) {
-		ClearPageUptodate(pg);
-		SetPageError(pg);
-	} else {
-		SetPageUptodate(pg);
-		ClearPageError(pg);
-	}
+	/* XXX FIXME: Where a single physical node actually shows up in two
+	   frags, we read it twice. Don't do that. */
+	/* Now we're pointing at the first frag which overlaps our page */
+	while(offset < end) {
+		D2(printk(KERN_DEBUG "jffs2_readpage: offset %d, end %d\n", offset, end));
+		if (!frag || frag->ofs > offset) {
+			__u32 holesize = end - offset;
+			if (frag) {
+				D1(printk(KERN_NOTICE "Eep. Hole in ino %ld fraglist. frag->ofs = 0x%08x, offset = 0x%08x\n", inode->i_ino, frag->ofs, offset));
+				holesize = min(holesize, frag->ofs - offset);
+				D1(jffs2_print_frag_list(f));
+			}
+			D1(printk(KERN_DEBUG "Filling non-frag hole from %d-%d\n", offset, offset+holesize));
+			memset(pg_buf, 0, holesize);
+			pg_buf += holesize;
+			offset += holesize;
+			continue;
+		} else if (frag->ofs < offset && (offset & (PAGE_CACHE_SIZE-1)) != 0) {
+			D1(printk(KERN_NOTICE "Eep. Overlap in ino #%ld fraglist. frag->ofs = 0x%08x, offset = 0x%08x\n",
+				  inode->i_ino, frag->ofs, offset));
+			D1(jffs2_print_frag_list(f));
+			memset(pg_buf, 0, end - offset);
+			ClearPageUptodate(pg);
+			SetPageError(pg);
+			kunmap(pg);
+			return -EIO;
+		} else if (!frag->node) {
+			__u32 holeend = min(end, frag->ofs + frag->size);
+			D1(printk(KERN_DEBUG "Filling frag hole from %d-%d (frag 0x%x 0x%x)\n", offset, holeend, frag->ofs, frag->ofs + frag->size));
+			memset(pg_buf, 0, holeend - offset);
+			pg_buf += holeend - offset;
+			offset = holeend;
+			frag = frag->next;
+			continue;
+		} else {
+			__u32 readlen;
+			readlen = min(frag->size, end - offset);
+			D1(printk(KERN_DEBUG "Reading %d-%d from node at 0x%x\n", frag->ofs, frag->ofs+readlen, frag->node->raw->flash_offset & ~3));
+			ret = jffs2_read_dnode(c, frag->node, pg_buf, frag->ofs - frag->node->ofs, readlen);
+			D2(printk(KERN_DEBUG "node read done\n"));
+			if (ret) {
+				D1(printk(KERN_DEBUG"jffs2_readpage error %d\n",ret));
+				memset(pg_buf, 0, frag->size);
+				ClearPageUptodate(pg);
+				SetPageError(pg);
+				kunmap(pg);
+				return ret;
+			}
+		}
+		pg_buf += frag->size;
+		offset += frag->size;
+		frag = frag->next;
+		D2(printk(KERN_DEBUG "node read was OK. Looping\n"));
+	}
+	D2(printk(KERN_DEBUG "readpage finishing\n"));
+	SetPageUptodate(pg);
+	ClearPageError(pg);
 
 	flush_dcache_page(pg);
-	kunmap(pg);
 
+	kunmap(pg);
 	D1(printk(KERN_DEBUG "readpage finished\n"));
 	return 0;
 }
@@ -274,76 +308,72 @@
 int jffs2_do_readpage_unlock(struct inode *inode, struct page *pg)
 {
 	int ret = jffs2_do_readpage_nolock(inode, pg);
-	unlock_page(pg);
+	UnlockPage(pg);
 	return ret;
 }
 
 
 int jffs2_readpage (struct file *filp, struct page *pg)
 {
-	struct jffs2_inode_info *f = JFFS2_INODE_INFO(pg->mapping->host);
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(filp->f_dentry->d_inode);
 	int ret;
 	
 	down(&f->sem);
-	ret = jffs2_do_readpage_unlock(pg->mapping->host, pg);
+	ret = jffs2_do_readpage_unlock(filp->f_dentry->d_inode, pg);
 	up(&f->sem);
 	return ret;
 }
 
 int jffs2_prepare_write (struct file *filp, struct page *pg, unsigned start, unsigned end)
 {
-	struct inode *inode = pg->mapping->host;
+	struct inode *inode = filp->f_dentry->d_inode;
 	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
-	uint32_t pageofs = pg->index << PAGE_CACHE_SHIFT;
+	__u32 pageofs = pg->index << PAGE_CACHE_SHIFT;
 	int ret = 0;
-	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
 
-	D1(printk(KERN_DEBUG "jffs2_prepare_write()\n"));
-
-	ret = jffs2_construct_fragtree_if_missing(c, f);
-	if (ret)
-		return ret;
+	down(&f->sem);
+	D1(printk(KERN_DEBUG "jffs2_prepare_write() nrpages %ld\n", inode->i_mapping->nrpages));
 
 	if (pageofs > inode->i_size) {
 		/* Make new hole frag from old EOF to new page */
+		struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
 		struct jffs2_raw_inode ri;
 		struct jffs2_full_dnode *fn;
-		uint32_t phys_ofs, alloc_len;
+		__u32 phys_ofs, alloc_len;
 		
 		D1(printk(KERN_DEBUG "Writing new hole frag 0x%x-0x%x between current EOF and new page\n",
 			  (unsigned int)inode->i_size, pageofs));
 
 		ret = jffs2_reserve_space(c, sizeof(ri), &phys_ofs, &alloc_len, ALLOC_NORMAL);
-		if (ret)
+		if (ret) {
+			up(&f->sem);
 			return ret;
-
-		down(&f->sem);
+		}
 		memset(&ri, 0, sizeof(ri));
 
-		ri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
-		ri.nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);
-		ri.totlen = cpu_to_je32(sizeof(ri));
-		ri.hdr_crc = cpu_to_je32(crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4));
-
-		ri.ino = cpu_to_je32(f->inocache->ino);
-		ri.version = cpu_to_je32(++f->highest_version);
-		ri.mode = cpu_to_je32(inode->i_mode);
-		ri.uid = cpu_to_je16(inode->i_uid);
-		ri.gid = cpu_to_je16(inode->i_gid);
-		ri.isize = cpu_to_je32(max((uint32_t)inode->i_size, pageofs));
-		ri.atime = ri.ctime = ri.mtime = cpu_to_je32(CURRENT_TIME);
-		ri.offset = cpu_to_je32(inode->i_size);
-		ri.dsize = cpu_to_je32(pageofs - inode->i_size);
-		ri.csize = cpu_to_je32(0);
+		ri.magic = JFFS2_MAGIC_BITMASK;
+		ri.nodetype = JFFS2_NODETYPE_INODE;
+		ri.totlen = sizeof(ri);
+		ri.hdr_crc = crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4);
+
+		ri.ino = f->inocache->ino;
+		ri.version = ++f->highest_version;
+		ri.mode = inode->i_mode;
+		ri.uid = inode->i_uid;
+		ri.gid = inode->i_gid;
+		ri.isize = max((__u32)inode->i_size, pageofs);
+		ri.atime = ri.ctime = ri.mtime = CURRENT_TIME;
+		ri.offset = inode->i_size;
+		ri.dsize = pageofs - inode->i_size;
+		ri.csize = 0;
 		ri.compr = JFFS2_COMPR_ZERO;
-		ri.node_crc = cpu_to_je32(crc32(0, &ri, sizeof(ri)-8));
-		ri.data_crc = cpu_to_je32(0);
+		ri.node_crc = crc32(0, &ri, sizeof(ri)-8);
+		ri.data_crc = 0;
 		
-		fn = jffs2_write_dnode(c, f, &ri, NULL, 0, phys_ofs, NULL);
-
+		fn = jffs2_write_dnode(inode, &ri, NULL, 0, phys_ofs, NULL);
+		jffs2_complete_reservation(c);
 		if (IS_ERR(fn)) {
 			ret = PTR_ERR(fn);
-			jffs2_complete_reservation(c);
 			up(&f->sem);
 			return ret;
 		}
@@ -357,23 +387,18 @@
 			D1(printk(KERN_DEBUG "Eep. add_full_dnode_to_inode() failed in prepare_write, returned %d\n", ret));
 			jffs2_mark_node_obsolete(c, fn->raw);
 			jffs2_free_full_dnode(fn);
-			jffs2_complete_reservation(c);
 			up(&f->sem);
 			return ret;
 		}
-		jffs2_complete_reservation(c);
 		inode->i_size = pageofs;
-		up(&f->sem);
 	}
 	
 
-	/* Read in the page if it wasn't already present, unless it's a whole page */
-	if (!PageUptodate(pg) && (start || end < PAGE_CACHE_SIZE)) {
-		down(&f->sem);
+	/* Read in the page if it wasn't already present */
+	if (!Page_Uptodate(pg) && (start || end < PAGE_SIZE))
 		ret = jffs2_do_readpage_nolock(inode, pg);
-		up(&f->sem);
-	}
-	D1(printk(KERN_DEBUG "end prepare_write(). pg->flags %lx\n", pg->flags));
+	D1(printk(KERN_DEBUG "end prepare_write(). nrpages %ld\n", inode->i_mapping->nrpages));
+	up(&f->sem);
 	return ret;
 }
 
@@ -382,60 +407,122 @@
 	/* Actually commit the write from the page cache page we're looking at.
 	 * For now, we write the full page out each time. It sucks, but it's simple
 	 */
-	struct inode *inode = pg->mapping->host;
+	struct inode *inode = filp->f_dentry->d_inode;
 	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
 	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
+	__u32 newsize = max_t(__u32, filp->f_dentry->d_inode->i_size, (pg->index << PAGE_CACHE_SHIFT) + end);
+	__u32 file_ofs = (pg->index << PAGE_CACHE_SHIFT);
+	__u32 writelen = min((__u32)PAGE_CACHE_SIZE, newsize - file_ofs);
 	struct jffs2_raw_inode *ri;
 	int ret = 0;
-	uint32_t writtenlen = 0;
-
-	D1(printk(KERN_DEBUG "jffs2_commit_write(): ino #%lu, page at 0x%lx, range %d-%d, flags %lx\n",
-		  inode->i_ino, pg->index << PAGE_CACHE_SHIFT, start, end, pg->flags));
+	ssize_t writtenlen = 0;
 
-	if (!start && end == PAGE_CACHE_SIZE) {
-		/* We need to avoid deadlock with page_cache_read() in
-		   jffs2_garbage_collect_pass(). So we have to mark the
-		   page up to date, to prevent page_cache_read() from 
-		   trying to re-lock it. */
-		SetPageUptodate(pg);
-	}
+	D1(printk(KERN_DEBUG "jffs2_commit_write(): ino #%lu, page at 0x%lx, range %d-%d, nrpages %ld\n", inode->i_ino, pg->index << PAGE_CACHE_SHIFT, start, end, filp->f_dentry->d_inode->i_mapping->nrpages));
 
 	ri = jffs2_alloc_raw_inode();
-
-	if (!ri) {
-		D1(printk(KERN_DEBUG "jffs2_commit_write(): Allocation of raw inode failed\n"));
+	if (!ri)
 		return -ENOMEM;
-	}
 
-	/* Set the fields that the generic jffs2_write_inode_range() code can't find */
-	ri->ino = cpu_to_je32(inode->i_ino);
-	ri->mode = cpu_to_je32(inode->i_mode);
-	ri->uid = cpu_to_je16(inode->i_uid);
-	ri->gid = cpu_to_je16(inode->i_gid);
-	ri->isize = cpu_to_je32((uint32_t)inode->i_size);
-	ri->atime = ri->ctime = ri->mtime = cpu_to_je32(CURRENT_TIME);
-
-	/* We rely on the fact that generic_file_write() currently kmaps the page for us. */
-	ret = jffs2_write_inode_range(c, f, ri, page_address(pg) + start,
-				      (pg->index << PAGE_CACHE_SHIFT) + start, end - start, &writtenlen);
+	while(writelen) {
+		struct jffs2_full_dnode *fn;
+		unsigned char *comprbuf = NULL;
+		unsigned char comprtype = JFFS2_COMPR_NONE;
+		__u32 phys_ofs, alloclen;
+		__u32 datalen, cdatalen;
 
-	if (ret) {
-		/* There was an error writing. */
-		SetPageError(pg);
-	}
+		D2(printk(KERN_DEBUG "jffs2_commit_write() loop: 0x%x to write to 0x%x\n", writelen, file_ofs));
+
+		ret = jffs2_reserve_space(c, sizeof(*ri) + JFFS2_MIN_DATA_LEN, &phys_ofs, &alloclen, ALLOC_NORMAL);
+		if (ret) {
+			SetPageError(pg);
+			D1(printk(KERN_DEBUG "jffs2_reserve_space returned %d\n", ret));
+			break;
+		}
+		down(&f->sem);
+		datalen = writelen;
+		cdatalen = min(alloclen - sizeof(*ri), writelen);
 
-	if (writtenlen) {
-		if (inode->i_size < (pg->index << PAGE_CACHE_SHIFT) + start + writtenlen) {
-			inode->i_size = (pg->index << PAGE_CACHE_SHIFT) + start + writtenlen;
-			inode->i_blocks = (inode->i_size + 511) >> 9;
-			
-			inode->i_ctime = inode->i_mtime = je32_to_cpu(ri->ctime);
+		comprbuf = kmalloc(cdatalen, GFP_KERNEL);
+		if (comprbuf) {
+			comprtype = jffs2_compress(page_address(pg)+ (file_ofs & (PAGE_CACHE_SIZE-1)), comprbuf, &datalen, &cdatalen);
 		}
+		if (comprtype == JFFS2_COMPR_NONE) {
+			/* Either compression failed, or the allocation of comprbuf failed */
+			if (comprbuf)
+				kfree(comprbuf);
+			comprbuf = page_address(pg) + (file_ofs & (PAGE_CACHE_SIZE -1));
+			datalen = cdatalen;
+		}
+		/* Now comprbuf points to the data to be written, be it compressed or not.
+		   comprtype holds the compression type, and comprtype == JFFS2_COMPR_NONE means
+		   that the comprbuf doesn't need to be kfree()d. 
+		*/
+
+		ri->magic = JFFS2_MAGIC_BITMASK;
+		ri->nodetype = JFFS2_NODETYPE_INODE;
+		ri->totlen = sizeof(*ri) + cdatalen;
+		ri->hdr_crc = crc32(0, ri, sizeof(struct jffs2_unknown_node)-4);
+
+		ri->ino = inode->i_ino;
+		ri->version = ++f->highest_version;
+		ri->mode = inode->i_mode;
+		ri->uid = inode->i_uid;
+		ri->gid = inode->i_gid;
+		ri->isize = max((__u32)inode->i_size, file_ofs + datalen);
+		ri->atime = ri->ctime = ri->mtime = CURRENT_TIME;
+		ri->offset = file_ofs;
+		ri->csize = cdatalen;
+		ri->dsize = datalen;
+		ri->compr = comprtype;
+		ri->node_crc = crc32(0, ri, sizeof(*ri)-8);
+		ri->data_crc = crc32(0, comprbuf, cdatalen);
+
+		fn = jffs2_write_dnode(inode, ri, comprbuf, cdatalen, phys_ofs, NULL);
+
+		jffs2_complete_reservation(c);
+
+		if (comprtype != JFFS2_COMPR_NONE)
+			kfree(comprbuf);
+
+		if (IS_ERR(fn)) {
+			ret = PTR_ERR(fn);
+			up(&f->sem);
+			SetPageError(pg);
+			break;
+		}
+		ret = jffs2_add_full_dnode_to_inode(c, f, fn);
+		if (f->metadata) {
+			jffs2_mark_node_obsolete(c, f->metadata->raw);
+			jffs2_free_full_dnode(f->metadata);
+			f->metadata = NULL;
+		}
+		up(&f->sem);
+		if (ret) {
+			/* Eep */
+			D1(printk(KERN_DEBUG "Eep. add_full_dnode_to_inode() failed in commit_write, returned %d\n", ret));
+			jffs2_mark_node_obsolete(c, fn->raw);
+			jffs2_free_full_dnode(fn);
+			SetPageError(pg);
+			break;
+		}
+		inode->i_size = ri->isize;
+		inode->i_blocks = (inode->i_size + 511) >> 9;
+		inode->i_ctime = inode->i_mtime = ri->ctime;
+		if (!datalen) {
+			printk(KERN_WARNING "Eep. We didn't actually write any bloody data\n");
+			ret = -EIO;
+			SetPageError(pg);
+			break;
+		}
+		D1(printk(KERN_DEBUG "increasing writtenlen by %d\n", datalen));
+		writtenlen += datalen;
+		file_ofs += datalen;
+		writelen -= datalen;
 	}
 
 	jffs2_free_raw_inode(ri);
 
-	if (start+writtenlen < end) {
+	if (writtenlen < end) {
 		/* generic_file_write has written more to the page cache than we've
 		   actually written to the medium. Mark the page !Uptodate so that 
 		   it gets reread */
@@ -443,7 +530,13 @@
 		SetPageError(pg);
 		ClearPageUptodate(pg);
 	}
+	if (writtenlen <= start) {
+		/* We didn't even get to the start of the affected part */
+		ret = ret?ret:-ENOSPC;
+		D1(printk(KERN_DEBUG "jffs2_commit_write(): Only %x bytes written to page. start (%x) not reached, returning %d\n", writtenlen, start, ret));
+	}
+	writtenlen = min(end-start, writtenlen-start);
 
-	D1(printk(KERN_DEBUG "jffs2_commit_write() returning %d\n",writtenlen?writtenlen:ret));
+	D1(printk(KERN_DEBUG "jffs2_commit_write() returning %d. nrpages is %ld\n",writtenlen?writtenlen:ret, inode->i_mapping->nrpages));
 	return writtenlen?writtenlen:ret;
 }
diff -Nur linux/fs/jffs2/fs.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/fs.c
--- linux/fs/jffs2/fs.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/fs.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,412 +0,0 @@
-/*
- * JFFS2 -- Journalling Flash File System, Version 2.
- *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
- *
- * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
- *
- * For licensing information, see the file 'LICENCE' in this directory.
- *
- * $Id: fs.c,v 1.17 2002/08/21 10:42:12 dwmw2 Exp $
- *
- * ChangeLog:
- *     19-Nov-2002 Lineo Japan, Inc.  add function jffs2_get_nr_inodes()
- *     09-Nov-2002 Lineo Japan, Inc.  add code to do avail = 0 when cannot reserve space
- *     01-Nov-2002 Lineo Japan, Inc.  involve nr_bad_blocks in USED calc.
- *
- * ChangeLog:
- *     19-Nov-2002 Lineo Japan, Inc.  add function jffs2_get_nr_inodes()
- *     24-Nov-2002 SHARP  modify storage-avail calculation, and add erasing_dirty_size
- *     09-Nov-2002 Lineo Japan, Inc.  add code to do avail = 0 when cannot reserve space
- *     01-Nov-2002 Lineo Japan, Inc.  involve nr_bad_blocks in USED calc.
- *
- */
-
-#include <linux/config.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/fs.h>
-#include <linux/list.h>
-#include <linux/interrupt.h>
-#include <linux/mtd/mtd.h>
-#include <linux/pagemap.h>
-#include <linux/slab.h>
-#include "nodelist.h"
-
-int jffs2_statfs(struct super_block *sb, struct statfs *buf)
-{
-	struct jffs2_sb_info *c = JFFS2_SB_INFO(sb);
-	unsigned long avail, avail_dirty;
-	uint32_t dirty_now, erasing_dirty_now, nonerasing_dirty_now, next_free;
-	int32_t avail_blocks;
-	int reserved_blocks = JFFS2_RESERVED_BLOCKS_WRITE + JFFS2_RESERVED_BLOCKS_ROOT;
-
-	buf->f_type = JFFS2_SUPER_MAGIC;
-	buf->f_bsize = 1 << PAGE_SHIFT;
-	buf->f_blocks = c->flash_size >> PAGE_SHIFT;
-	buf->f_files = 0;
-	buf->f_ffree = 0;
-	buf->f_namelen = JFFS2_MAX_NAME_LEN;
-
-	spin_lock_bh(&c->erase_completion_lock);
-
-	dirty_now = c->dirty_size;
-	erasing_dirty_now = c->erasing_dirty_size;
-	if (dirty_now < erasing_dirty_now)
-		erasing_dirty_now = dirty_now;
-	nonerasing_dirty_now = dirty_now - erasing_dirty_now;
-	avail_blocks = NR_AVAIL_BLOCKS(c);
-	next_free = (c->nextblock) ? (c->nextblock->free_size) : 0;
-
-	if (nonerasing_dirty_now >= JFFS2_RESERVED_BLOCKS_DIRTY * c->sector_size){
-		avail_dirty = nonerasing_dirty_now - JFFS2_RESERVED_BLOCKS_DIRTY * c->sector_size;
-	}else{
-		avail_dirty = 0;
-	}
-
-	if (avail_blocks * c->sector_size + next_free + avail_dirty >= reserved_blocks * c->sector_size){
-		avail = avail_blocks * c->sector_size + next_free + avail_dirty - reserved_blocks * c->sector_size;
-	}else{
-		avail = 0;
-	}
-
-	if (avail > 0){
-		if (avail_blocks < reserved_blocks &&
-			(c->cont_gc_count >= JFFS2_MAX_CONT_GC ||
-			 avail_blocks <=  1 + JFFS2_RESERVED_BLOCKS_ROOT ||
-			 dirty_now < c->sector_size ||
-			 nonerasing_dirty_now / c->sector_size < JFFS2_RESERVED_BLOCKS_DIRTY ||
-			 avail_blocks + nonerasing_dirty_now / c->sector_size - JFFS2_RESERVED_BLOCKS_DIRTY < reserved_blocks)){
-			avail = 0;
-		}
-	}
-
-	buf->f_bavail = buf->f_bfree = avail >> PAGE_SHIFT;
-
-	D1(jffs2_dump_block_lists(c));
-
-	spin_unlock_bh(&c->erase_completion_lock);
-
-	return 0;
-}
-
-
-#ifdef CONFIG_JFFS2_DYNFRAGTREE
-
-static unsigned long jffs2_nr_inodes; /* the number of inode objects */
-static inline void inc_nr_inodes(void) { jffs2_nr_inodes++; }
-static inline void dec_nr_inodes(void) { jffs2_nr_inodes--; }
-unsigned long jffs2_get_nr_inodes(void) { return jffs2_nr_inodes; }
-
-#else
-
-static inline void inc_nr_inodes(void) { }
-static inline void dec_nr_inodes(void) { }
-unsigned long jffs2_get_nr_inodes(void) { return 0; }
-
-#endif
-
-
-void jffs2_clear_inode (struct inode *inode)
-{
-	/* We can forget about this inode for now - drop all 
-	 *  the nodelists associated with it, etc.
-	 */
-	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
-	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
-	
-	D1(printk(KERN_DEBUG "jffs2_clear_inode(): ino #%lu mode %o\n", inode->i_ino, inode->i_mode));
-
-	jffs2_do_clear_inode(c, f);
-
-	dec_nr_inodes();
-}
-
-void jffs2_read_inode (struct inode *inode)
-{
-	struct jffs2_inode_info *f;
-	struct jffs2_sb_info *c;
-	struct jffs2_raw_inode latest_node;
-	int ret;
-
-	D1(printk(KERN_DEBUG "jffs2_read_inode(): inode->i_ino == %lu\n", inode->i_ino));
-
-	f = JFFS2_INODE_INFO(inode);
-	c = JFFS2_SB_INFO(inode->i_sb);
-
-	jffs2_init_inode_info(f);
-	
-	ret = jffs2_do_read_inode(c, f, inode->i_ino, &latest_node);
-
-	if (ret) {
-		make_bad_inode(inode);
-		up(&f->sem);
-		return;
-	}
-	inode->i_mode = je32_to_cpu(latest_node.mode);
-	inode->i_uid = je16_to_cpu(latest_node.uid);
-	inode->i_gid = je16_to_cpu(latest_node.gid);
-	inode->i_size = je32_to_cpu(latest_node.isize);
-	inode->i_atime = je32_to_cpu(latest_node.atime);
-	inode->i_mtime = je32_to_cpu(latest_node.mtime);
-	inode->i_ctime = je32_to_cpu(latest_node.ctime);
-
-	inode->i_nlink = f->inocache->nlink;
-
-	inode->i_blksize = PAGE_SIZE;
-	inode->i_blocks = (inode->i_size + 511) >> 9;
-	
-	switch (inode->i_mode & S_IFMT) {
-		unsigned short rdev;
-
-	case S_IFLNK:
-		inode->i_op = &jffs2_symlink_inode_operations;
-		break;
-		
-	case S_IFDIR:
-	{
-		struct jffs2_full_dirent *fd;
-
-		for (fd=f->dents; fd; fd = fd->next) {
-			if (fd->type == DT_DIR && fd->ino)
-				inode->i_nlink++;
-		}
-		/* and '..' */
-		inode->i_nlink++;
-		/* Root dir gets i_nlink 3 for some reason */
-		if (inode->i_ino == 1)
-			inode->i_nlink++;
-
-		inode->i_op = &jffs2_dir_inode_operations;
-		inode->i_fop = &jffs2_dir_operations;
-		break;
-	}
-	case S_IFREG:
-		inode->i_op = &jffs2_file_inode_operations;
-		inode->i_fop = &jffs2_file_operations;
-		inode->i_mapping->a_ops = &jffs2_file_address_operations;
-		inode->i_mapping->nrpages = 0;
-		break;
-
-	case S_IFBLK:
-	case S_IFCHR:
-		/* Read the device numbers from the media */
-		D1(printk(KERN_DEBUG "Reading device numbers from flash\n"));
-		if (jffs2_read_dnode(c, f->metadata, (char *)&rdev, 0, sizeof(rdev)) < 0) {
-			/* Eep */
-			printk(KERN_NOTICE "Read device numbers for inode %lu failed\n", (unsigned long)inode->i_ino);
-			up(&f->sem);
-			jffs2_do_clear_inode(c, f);
-			make_bad_inode(inode);
-			return;
-		}			
-
-	case S_IFSOCK:
-	case S_IFIFO:
-		inode->i_op = &jffs2_file_inode_operations;
-		init_special_inode(inode, inode->i_mode, kdev_t_to_nr(mk_kdev(rdev>>8, rdev&0xff)));
-		break;
-
-	default:
-		printk(KERN_WARNING "jffs2_read_inode(): Bogus imode %o for ino %lu\n", inode->i_mode, (unsigned long)inode->i_ino);
-	}
-
-	up(&f->sem);
-
-	inc_nr_inodes();
-
-	D1(printk(KERN_DEBUG "jffs2_read_inode() returning\n"));
-}
-
-
-int jffs2_remount_fs (struct super_block *sb, int *flags, char *data)
-{
-	struct jffs2_sb_info *c = JFFS2_SB_INFO(sb);
-
-	if (c->flags & JFFS2_SB_FLAG_RO && !(sb->s_flags & MS_RDONLY))
-		return -EROFS;
-
-	/* We stop if it was running, then restart if it needs to.
-	   This also catches the case where it was stopped and this
-	   is just a remount to restart it */
-	if (!(sb->s_flags & MS_RDONLY))
-		jffs2_stop_garbage_collect_thread(c);
-
-	if (!(*flags & MS_RDONLY))
-		jffs2_start_garbage_collect_thread(c);
-	
-	sb->s_flags = (sb->s_flags & ~MS_RDONLY)|(*flags & MS_RDONLY);
-
-	return 0;
-}
-
-void jffs2_write_super (struct super_block *sb)
-{
-	struct jffs2_sb_info *c = JFFS2_SB_INFO(sb);
-	sb->s_dirt = 0;
-
-	if (sb->s_flags & MS_RDONLY)
-		return;
-
-	D1(printk(KERN_DEBUG "jffs2_write_super()\n"));
-	jffs2_garbage_collect_trigger(c);
-	jffs2_erase_pending_blocks(c);
-	jffs2_mark_erased_blocks(c);
-}
-
-
-/* jffs2_new_inode: allocate a new inode and inocache, add it to the hash,
-   fill in the raw_inode while you're at it. */
-struct inode *jffs2_new_inode (struct inode *dir_i, int mode, struct jffs2_raw_inode *ri)
-{
-	struct inode *inode;
-	struct super_block *sb = dir_i->i_sb;
-	struct jffs2_sb_info *c;
-	struct jffs2_inode_info *f;
-	int ret;
-
-	D1(printk(KERN_DEBUG "jffs2_new_inode(): dir_i %ld, mode 0x%x\n", dir_i->i_ino, mode));
-
-	c = JFFS2_SB_INFO(sb);
-	
-	inode = new_inode(sb);
-	
-	if (!inode)
-		return ERR_PTR(-ENOMEM);
-
-	f = JFFS2_INODE_INFO(inode);
-	jffs2_init_inode_info(f);
-
-	memset(ri, 0, sizeof(*ri));
-	/* Set OS-specific defaults for new inodes */
-	ri->uid = cpu_to_je16(current->fsuid);
-
-	if (dir_i->i_mode & S_ISGID) {
-		ri->gid = cpu_to_je16(dir_i->i_gid);
-		if (S_ISDIR(mode))
-			mode |= S_ISGID;
-	} else {
-		ri->gid = cpu_to_je16(current->fsgid);
-	}
-	ri->mode =  cpu_to_je32(mode);
-	ret = jffs2_do_new_inode (c, f, mode, ri);
-	if (ret) {
-		make_bad_inode(inode);
-		iput(inode);
-		return ERR_PTR(ret);
-	}
-	inode->i_nlink = 1;
-	inode->i_ino = je32_to_cpu(ri->ino);
-	inode->i_mode = je32_to_cpu(ri->mode);
-	inode->i_gid = je16_to_cpu(ri->gid);
-	inode->i_uid = je16_to_cpu(ri->uid);
-	inode->i_atime = inode->i_ctime = inode->i_mtime = CURRENT_TIME;
-	ri->atime = ri->mtime = ri->ctime = cpu_to_je32(inode->i_mtime);
-
-	inode->i_blksize = PAGE_SIZE;
-	inode->i_blocks = 0;
-	inode->i_size = 0;
-
-	insert_inode_hash(inode);
-
-	inc_nr_inodes();
-
-	return inode;
-}
-
-
-int jffs2_do_fill_super(struct super_block *sb, void *data, int silent)
-{
-	struct jffs2_sb_info *c;
-	struct inode *root_i;
-	int ret;
-
-	c = JFFS2_SB_INFO(sb);
-
-	c->sector_size = c->mtd->erasesize;
-	c->flash_size = c->mtd->size;
-
-#if 0
-	if (c->sector_size < 0x10000) {
-		printk(KERN_INFO "jffs2: Erase block size too small (%dKiB). Using 64KiB instead\n",
-		       c->sector_size / 1024);
-		c->sector_size = 0x10000;
-	}
-#endif
-	if (c->flash_size < 5*c->sector_size) {
-		printk(KERN_ERR "jffs2: Too few erase blocks (%d)\n",
-		       c->flash_size / c->sector_size);
-		return -EINVAL;
-	}
-
-	c->cleanmarker_size = sizeof(struct jffs2_unknown_node);
-	/* Jvrn -- stick alignment for weird 8-byte-page flash here */
-
-	if (jffs2_cleanmarker_oob(c)) {
-		/* Cleanmarker is out-of-band, so inline size zero */
-		c->cleanmarker_size = 0;
-	}
-
-	if (c->mtd->type == MTD_NANDFLASH) {
-		/* Initialise write buffer */
-		c->wbuf_pagesize = c->mtd->oobblock;
-		c->wbuf_ofs = 0xFFFFFFFF;
-		c->wbuf = kmalloc(c->wbuf_pagesize, GFP_KERNEL);
-		if (!c->wbuf)
-			return -ENOMEM;
-
-		/* Initialize process for timed wbuf flush */
-		INIT_TQUEUE(&c->wbuf_task,(void*) jffs2_wbuf_process, (void *)c);
-		/* Initialize timer for timed wbuf flush */
-		init_timer(&c->wbuf_timer);
-		c->wbuf_timer.function = jffs2_wbuf_timeout;
-		c->wbuf_timer.data = (unsigned long) c;
-	}
-
-	c->inocache_list = kmalloc(INOCACHE_HASHSIZE * sizeof(struct jffs2_inode_cache *), GFP_KERNEL);
-	if (!c->inocache_list) {
-		ret = -ENOMEM;
-		goto out_wbuf;
-	}
-	memset(c->inocache_list, 0, INOCACHE_HASHSIZE * sizeof(struct jffs2_inode_cache *));
-
-	if ((ret = jffs2_do_mount_fs(c)))
-		goto out_inohash;
-
-	ret = -EINVAL;
-
-	D1(printk(KERN_DEBUG "jffs2_do_fill_super(): Getting root inode\n"));
-	root_i = iget(sb, 1);
-	if (is_bad_inode(root_i)) {
-		D1(printk(KERN_WARNING "get root inode failed\n"));
-		goto out_nodes;
-	}
-
-	D1(printk(KERN_DEBUG "jffs2_do_fill_super(): d_alloc_root()\n"));
-	sb->s_root = d_alloc_root(root_i);
-	if (!sb->s_root)
-		goto out_root_i;
-
-#if LINUX_VERSION_CODE >= 0x20403
-	sb->s_maxbytes = 0xFFFFFFFF;
-#endif
-	sb->s_blocksize = PAGE_CACHE_SIZE;
-	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
-	sb->s_magic = JFFS2_SUPER_MAGIC;
-	if (!(sb->s_flags & MS_RDONLY))
-		jffs2_start_garbage_collect_thread(c);
-	return 0;
-
- out_root_i:
-	iput(root_i);
- out_nodes:
-	jffs2_free_ino_caches(c);
-	jffs2_free_raw_node_refs(c);
-	kfree(c->blocks);
- out_inohash:
-	kfree(c->inocache_list);
- out_wbuf:
-	if (c->wbuf)
-		kfree(c->wbuf);
-	return ret;
-}
diff -Nur linux/fs/jffs2/gc.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/gc.c
--- linux/fs/jffs2/gc.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/gc.c	2003-06-23 01:47:04.000000000 +0700
@@ -1,224 +1,88 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
+ * Copyright (C) 2001 Red Hat, Inc.
  *
  * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: gc.c,v 1.84 2002/09/06 16:46:29 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
  *
- * ChangeLog:
- *     03-Dec-2002 Lineo Japan, Inc.  add LockPage
- *     30-Nov-2002 Lineo Japan, Inc.  fix deadlock between lock_page and f->sem
- *     27-Nov-2002 Lineo Japan, Inc.  add effective-gc mode
- *     25-Nov-2002 Lineo Japan, Inc.  remove warning message when there is
- *       no gcblock
- *     23-Nov-2002 Lineo Japan, Inc.  correct JFFS2_RESERVED_BLOCKS_GCMERGE
- *       condition expression in connection with NR_AVAIL_BLOCKS()
- *				      take max dirty size from c->dirty_list
- *				      return -ENOSPC when find_gc_block
- *       returns NULL
- *				      don't take gcblock from clean_list
- *       when NR_AVAIL_BLOCKS < JFFS2_RESERVED_BLOCKS_CLEAN
- *     18-Nov-2002 Lineo Japan, Inc.  add dynamic construction of fragtree
- *     15-Nov-2002 Lineo Japan, Inc.  add nodemerge facility
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
  *
- * ChangeLog:
- *     05-Dec-2002 SHARP  adjust gcblock selection
- *     03-Dec-2002 Lineo Japan, Inc.  add LockPage
- *     30-Nov-2002 Lineo Japan, Inc.  fix deadlock between lock_page and f->sem
- *     27-Nov-2002 Lineo Japan, Inc.  add effective-gc mode
- *     25-Nov-2002 Lineo Japan, Inc.  remove warning message when there is
- *       no gcblock
- *     24-Nov-2002 SHARP  add erasing_dirty_size
- *     23-Nov-2002 Lineo Japan, Inc.  correct JFFS2_RESERVED_BLOCKS_GCMERGE
- *       condition expression in connection with NR_AVAIL_BLOCKS()
- *				      take max dirty size from c->dirty_list
- *				      return -ENOSPC when find_gc_block
- *       returns NULL
- *				      don't take gcblock from clean_list
- *       when NR_AVAIL_BLOCKS < JFFS2_RESERVED_BLOCKS_CLEAN
- *     18-Nov-2002 Lineo Japan, Inc.  add dynamic construction of fragtree
- *     15-Nov-2002 Lineo Japan, Inc.  add nodemerge facility
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: gc.c,v 1.52.2.4 2002/05/15 12:51:23 dwmw2 Exp $
  *
  */
 
 #include <linux/kernel.h>
 #include <linux/mtd/mtd.h>
 #include <linux/slab.h>
+#include <linux/jffs2.h>
+#include <linux/sched.h>
 #include <linux/interrupt.h>
 #include <linux/pagemap.h>
-#include "crc32.h"
-#include <linux/compiler.h>
 #include "nodelist.h"
+#include "crc32.h"
 
 static int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, 
-					struct jffs2_inode_info *f, struct jffs2_full_dnode *fd);
+					struct inode *inode, struct jffs2_full_dnode *fd);
 static int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, 
-					struct jffs2_inode_info *f, struct jffs2_full_dirent *fd);
+					struct inode *inode, struct jffs2_full_dirent *fd);
 static int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, 
-					struct jffs2_inode_info *f, struct jffs2_full_dirent *fd);
+					struct inode *inode, struct jffs2_full_dirent *fd);
 static int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
-				      struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,
-				      uint32_t start, uint32_t end);
+				      struct inode *indeo, struct jffs2_full_dnode *fn,
+				      __u32 start, __u32 end);
 static int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
-				       struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,
-				       uint32_t start, uint32_t end);
-
-static struct list_head *jffs2_find_effective_block(struct list_head *head, uint32_t desire_size, uint32_t *found_size)
-{
-	struct list_head *this, *ret = NULL;
-	*found_size = 0;
-	list_for_each(this, head) {
-		struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
-		if (desire_size <= jeb->dirty_size) {
-			*found_size = jeb->dirty_size;
-			return this->prev;
-		}
-		if (*found_size < jeb->dirty_size) {
-			*found_size = jeb->dirty_size;
-			ret = this;
-		}
-	}
-	return ret ? ret->prev : NULL;
-}
-
-static struct list_head *larger_dirty_block(struct jffs2_sb_info *c, struct list_head *head, int effective_only)
-{
-	uint32_t effective_size, found_size;
-	uint32_t dirty_now, erasing_dirty_now, nonerasing_dirty_now;
-	struct list_head *ret = NULL;
-
-	if(effective_only){
-		dirty_now = c->dirty_size;
-		erasing_dirty_now = c->erasing_dirty_size;
-		nonerasing_dirty_now = ((dirty_now >= erasing_dirty_now) ? (dirty_now - erasing_dirty_now) : 0);
-
-		if(nonerasing_dirty_now >= GC_EFFECTIVE_TOTAL_DIRTY_SIZE_LL(c)){
-			effective_size = GC_EFFECTIVE_BLOCK_DIRTY_SIZE_LL;
-		}else
-		if(nonerasing_dirty_now >= GC_EFFECTIVE_TOTAL_DIRTY_SIZE_L(c)){
-			effective_size = GC_EFFECTIVE_BLOCK_DIRTY_SIZE_L;
-		}else
-		if(nonerasing_dirty_now >= GC_EFFECTIVE_TOTAL_DIRTY_SIZE(c)){
-			effective_size = GC_EFFECTIVE_BLOCK_DIRTY_SIZE;
-		}else{
-			return NULL;
-		}
-
-		ret = jffs2_find_effective_block(head, effective_size, &found_size);
-		if(found_size < GC_EFFECTIVE_BLOCK_DIRTY_SIZE){
-			return NULL;
-		}
-	}else{
-		ret = jffs2_find_effective_block(head, GC_EFFECTIVE_BLOCK_DIRTY_SIZE, &found_size);
-	}
-
-	return ret;
-}
-
-struct list_head *jffs2_get_dirty_block(struct list_head *head)
-{
-	struct list_head *this;
-	list_for_each(this, head) {
-		struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
-		if (ISDIRTY(jeb->dirty_size)) {
-			return this->prev;
-		}
-	}
-	return NULL;
-}
+				       struct inode *inode, struct jffs2_full_dnode *fn,
+				       __u32 start, __u32 end);
 
 /* Called with erase_completion_lock held */
-static struct jffs2_eraseblock *jffs2_find_gc_block(struct jffs2_sb_info *c, int effective_only)
+static struct jffs2_eraseblock *jffs2_find_gc_block(struct jffs2_sb_info *c)
 {
 	struct jffs2_eraseblock *ret;
 	struct list_head *nextlist = NULL;
-	int n = jiffies % 128;
-	int reserved_blocks = JFFS2_RESERVED_BLOCKS_CLEAN;
 
 	/* Pick an eraseblock to garbage collect next. This is where we'll
 	   put the clever wear-levelling algorithms. Eventually.  */
-	/* We possibly want to favour the dirtier blocks more when the
-	   number of free blocks is low. */
-#ifdef CONFIG_JFFS2_NODEMERGE
-	if (nextlist == NULL && !list_empty(&c->nodemerge_list) &&
-		NR_AVAIL_BLOCKS(c) >= reserved_blocks) {
-		nextlist = &c->nodemerge_list;
-		c->flags |= JFFS2_SB_FLAG_GCING_A_BLOCK;
-	}
-#ifdef CONFIG_ARCH_SHARP_SL
-	if (nextlist == NULL && !list_empty(&c->very_dirty_list)) {
-		nextlist = &c->very_dirty_list;
-		c->flags |= JFFS2_SB_FLAG_GCING_A_BLOCK;
-	}
-#endif
-	if (nextlist == NULL && !list_empty(&c->nodemerge_list)) {
-		if(NR_AVAIL_BLOCKS(c) >= reserved_blocks) {
-			nextlist = &c->nodemerge_list;
-		}else{
-			nextlist = jffs2_get_dirty_block(&c->nodemerge_list);
-		}
-		if(nextlist != NULL){
-			c->flags |= JFFS2_SB_FLAG_GCING_A_BLOCK;
-		}
-	}
-#endif
-	if (nextlist == NULL && !list_empty(&c->bad_used_list) && c->nr_free_blocks > JFFS2_RESERVED_BLOCKS_GCBAD) {
+	if (!list_empty(&c->bad_used_list) && c->nr_free_blocks > JFFS2_RESERVED_BLOCKS_GCBAD) {
 		D1(printk(KERN_DEBUG "Picking block from bad_used_list to GC next\n"));
 		nextlist = &c->bad_used_list;
-	}
-	if (nextlist == NULL && n < 50 && !list_empty(&c->erasable_list)) {
-		/* Note that most of them will have gone directly to be erased. 
-		   So don't favour the erasable_list _too_ much. */
-		D1(printk(KERN_DEBUG "Picking block from erasable_list to GC next\n"));
-		nextlist = &c->erasable_list;
-	}
-#if !defined(CONFIG_JFFS2_NODEMERGE) || !defined(CONFIG_ARCH_SHARP_SL)
-	if (nextlist == NULL && n < 110 && !list_empty(&c->very_dirty_list)) {
-		/* Most of the time, pick one off the very_dirty list */
-		D1(printk(KERN_DEBUG "Picking block from very_dirty_list to GC next\n"));
-		nextlist = &c->very_dirty_list;
-	}
-#endif
-	if (nextlist == NULL && n < 126 && !list_empty(&c->dirty_list)) {
+	} else if (jiffies % 100 && !list_empty(&c->dirty_list)) {
+		/* Most of the time, pick one off the dirty list */
 		D1(printk(KERN_DEBUG "Picking block from dirty_list to GC next\n"));
-		nextlist = larger_dirty_block(c, &c->dirty_list, effective_only);
-	}
-	if (!effective_only && nextlist == NULL &&
-	    NR_AVAIL_BLOCKS(c) >= reserved_blocks && !list_empty(&c->clean_list)) {
+		nextlist = &c->dirty_list;
+	} else if (!list_empty(&c->clean_list)) {
 		D1(printk(KERN_DEBUG "Picking block from clean_list to GC next\n"));
 		nextlist = &c->clean_list;
-	}
-	if (nextlist == NULL && !list_empty(&c->dirty_list)) {
+	} else if (!list_empty(&c->dirty_list)) {
 		D1(printk(KERN_DEBUG "Picking block from dirty_list to GC next (clean_list was empty)\n"));
-		nextlist = larger_dirty_block(c, &c->dirty_list, effective_only);
-	}
-	if (nextlist == NULL && !list_empty(&c->very_dirty_list)) {
-		D1(printk(KERN_DEBUG "Picking block from very_dirty_list to GC next (clean_list and dirty_list were empty)\n"));
-		nextlist = &c->very_dirty_list;
-	}
-	if (nextlist == NULL && !list_empty(&c->erasable_list)) {
-		D1(printk(KERN_DEBUG "Picking block from erasable_list to GC next (clean_list and {very_,}dirty_list were empty)\n"));
-		nextlist = &c->erasable_list;
-	}
-#ifdef CONFIG_JFFS2_NODEMERGE
-	if (nextlist == NULL && !list_empty(&c->nodemerge_list)) {
-		if(NR_AVAIL_BLOCKS(c) >= reserved_blocks) {
-			nextlist = &c->nodemerge_list;
-		}else{
-			nextlist = jffs2_get_dirty_block(&c->nodemerge_list);
-		}
-		if(nextlist != NULL){
-			c->flags |= JFFS2_SB_FLAG_GCING_A_BLOCK;
-		}
-	}
-#endif
-	if (nextlist == NULL) {
-		/* Eep. All were empty */
-//		printk(KERN_NOTICE "jffs2: No clean, dirty _or_ erasable blocks to GC from! Where are they all?\n");
+
+		nextlist = &c->dirty_list;
+	} else {
+		/* Eep. Both were empty */
+		printk(KERN_NOTICE "jffs2: No clean _or_ dirty blocks to GC from! Where are they all?\n");
 		return NULL;
 	}
 
@@ -230,45 +94,53 @@
 		printk(KERN_WARNING "Eep. ret->gc_node for block at 0x%08x is NULL\n", ret->offset);
 		BUG();
 	}
-	
-	/* Have we accidentally picked a clean block with wasted space ? */
-	if (ret->wasted_size) {
-		D1(printk(KERN_DEBUG "Converting wasted_size %08x to dirty_size\n", ret->wasted_size));
-		ret->dirty_size += ret->wasted_size;
-		c->wasted_size -= ret->wasted_size;
-		c->dirty_size += ret->wasted_size;
-		ret->wasted_size = 0;
-	}
-
-	D1(jffs2_dump_block_lists(c));
 	return ret;
 }
 
-static inline int jffs2_do_garbage_collect_pass(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)
+/* jffs2_garbage_collect_pass
+ * Make a single attempt to progress GC. Move one node, and possibly
+ * start erasing one eraseblock.
+ */
+int jffs2_garbage_collect_pass(struct jffs2_sb_info *c)
 {
+	struct jffs2_eraseblock *jeb;
 	struct jffs2_inode_info *f;
 	struct jffs2_raw_node_ref *raw;
 	struct jffs2_node_frag *frag;
 	struct jffs2_full_dnode *fn = NULL;
 	struct jffs2_full_dirent *fd;
-	uint32_t start = 0, end = 0, nrfrags = 0;
-	uint32_t inum;
+	__u32 start = 0, end = 0, nrfrags = 0;
+	__u32 inum;
 	struct inode *inode;
 	int ret = 0;
 
-	D1(printk(KERN_DEBUG "GC from block %08x, used_size %08x, dirty_size %08x, free_size %08x\n", jeb->offset, jeb->used_size, jeb->dirty_size, jeb->free_size));
-	D1(if (c->nextblock)
-	   printk(KERN_DEBUG "Nextblock at  %08x, used_size %08x, dirty_size %08x, wasted_size %08x, free_size %08x\n", c->nextblock->offset, c->nextblock->used_size, c->nextblock->dirty_size, c->nextblock->wasted_size, c->nextblock->free_size));
+	if (down_interruptible(&c->alloc_sem))
+		return -EINTR;
 
-	if (!jeb->used_size) {
+	spin_lock_bh(&c->erase_completion_lock);
+
+	/* First, work out which block we're garbage-collecting */
+	jeb = c->gcblock;
+
+	if (!jeb)
+		jeb = jffs2_find_gc_block(c);
+
+	if (!jeb) {
+		printk(KERN_NOTICE "jffs2: Couldn't find erase block to garbage collect!\n");
+		spin_unlock_bh(&c->erase_completion_lock);
 		up(&c->alloc_sem);
-		goto eraseit;
+		return -EIO;
 	}
 
+	D1(printk(KERN_DEBUG "garbage collect from block at phys 0x%08x\n", jeb->offset));
+
+	if (!jeb->used_size)
+		goto eraseit;
+
 	raw = jeb->gc_node;
 			
-	while(ref_obsolete(raw)) {
-		D1(printk(KERN_DEBUG "Node at 0x%08x is obsolete... skipping\n", ref_offset(raw)));
+	while(raw->flash_offset & 1) {
+		D1(printk(KERN_DEBUG "Node at 0x%08x is obsolete... skipping\n", raw->flash_offset &~3));
 		jeb->gc_node = raw = raw->next_phys;
 		if (!raw) {
 			printk(KERN_WARNING "eep. End of raw list while still supposedly nodes to GC\n");
@@ -279,14 +151,11 @@
 			BUG();
 		}
 	}
-	D1(printk(KERN_DEBUG "Going to garbage collect node at 0x%08x\n", ref_offset(raw)));
+	D1(printk(KERN_DEBUG "Going to garbage collect node at 0x%08x\n", raw->flash_offset &~3));
 	if (!raw->next_in_ino) {
 		/* Inode-less node. Clean marker, snapshot or something like that */
-		/* FIXME: If it's something that needs to be copied, including something
-		   we don't grok that has JFFS2_NODETYPE_RWCOMPAT_COPY, we should do so */
 		spin_unlock_bh(&c->erase_completion_lock);
 		jffs2_mark_node_obsolete(c, raw);
-		up(&c->alloc_sem);
 		goto eraseit_lock;
 	}
 						     
@@ -295,24 +164,23 @@
 
 	spin_unlock_bh(&c->erase_completion_lock);
 
-	D1(printk(KERN_DEBUG "jffs2_garbage_collect_pass collecting from block @0x%08x. Node @0x%08x, ino #%u\n", jeb->offset, ref_offset(raw), inum));
+	D1(printk(KERN_DEBUG "jffs2_garbage_collect_pass collecting from block @0x%08x. Node @0x%08x, ino #%u\n", jeb->offset, raw->flash_offset&~3, inum));
 
 	inode = iget(OFNI_BS_2SFFJ(c), inum);
 	if (is_bad_inode(inode)) {
 		printk(KERN_NOTICE "Eep. read_inode() failed for ino #%u\n", inum);
 		/* NB. This will happen again. We need to do something appropriate here. */
-		up(&c->alloc_sem);
 		iput(inode);
+		up(&c->alloc_sem);
 		return -EIO;
 	}
 
 	f = JFFS2_INODE_INFO(inode);
 	down(&f->sem);
-
 	/* Now we have the lock for this inode. Check that it's still the one at the head
 	   of the list. */
 
-	if (ref_obsolete(raw)) {
+	if (raw->flash_offset & 1) {
 		D1(printk(KERN_DEBUG "node to be GC'd was obsoleted in the meantime.\n"));
 		/* They'll call again */
 		goto upnout;
@@ -320,35 +188,14 @@
 	/* OK. Looks safe. And nobody can get us now because we have the semaphore. Move the block */
 	if (f->metadata && f->metadata->raw == raw) {
 		fn = f->metadata;
-		ret = jffs2_garbage_collect_metadata(c, jeb, f, fn);
-		goto upnout;
-	}
-
-	ret = jffs2_construct_fragtree_nolock_if_missing(c, f);
-	if (ret) {
-		printk(KERN_NOTICE "construct_fragtree failed for ino #%u\n", inum);
+		ret = jffs2_garbage_collect_metadata(c, jeb, inode, fn);
 		goto upnout;
 	}
-
-	/* FIXME. Read node and do lookup? */
-	for (frag = frag_first(&f->fragtree); frag; frag = frag_next(frag)) {
+	
+	for (frag = f->fraglist; frag; frag = frag->next) {
 		if (frag->node && frag->node->raw == raw) {
 			fn = frag->node;
 			end = frag->ofs + frag->size;
-#if 0 /* Temporary debugging sanity checks, till we're ready to _trust_ the REF_PRISTINE flag stuff */ 
-			if (!nrfrags && ref_flags(fn->raw) == REF_PRISTINE) {
-				if (fn->frags > 1)
-					printk(KERN_WARNING "REF_PRISTINE node at 0x%08x had %d frags. Tell dwmw2\n", ref_offset(raw), fn->frags);
-
-				if (frag->ofs & (PAGE_CACHE_SIZE-1) && frag_prev(frag) && frag_prev(frag)->node)
-					printk(KERN_WARNING "REF_PRISTINE node at 0x%08x had a previous non-hole frag in the same page. Tell dwmw2\n",
-					       ref_offset(raw));
-
-				if ((frag->ofs+frag->size) & (PAGE_CACHE_SIZE-1) && frag_next(frag) && frag_next(frag)->node)
-					printk(KERN_WARNING "REF_PRISTINE node at 0x%08x (%08x-%08x) had a following non-hole frag in the same page. Tell dwmw2\n",
-					       ref_offset(raw), frag->ofs, frag->ofs+frag->size);
-			}
-#endif
 			if (!nrfrags++)
 				start = frag->ofs;
 			if (nrfrags == frag->node->frags)
@@ -359,10 +206,10 @@
 		/* We found a datanode. Do the GC */
 		if((start >> PAGE_CACHE_SHIFT) < ((end-1) >> PAGE_CACHE_SHIFT)) {
 			/* It crosses a page boundary. Therefore, it must be a hole. */
-			ret = jffs2_garbage_collect_hole(c, jeb, f, fn, start, end);
+			ret = jffs2_garbage_collect_hole(c, jeb, inode, fn, start, end);
 		} else {
 			/* It could still be a hole. But we GC the page this way anyway */
-			ret = jffs2_garbage_collect_dnode(c, jeb, f, fn, start, end);
+			ret = jffs2_garbage_collect_dnode(c, jeb, inode, fn, start, end);
 		}
 		goto upnout;
 	}
@@ -374,13 +221,12 @@
 	}
 
 	if (fd && fd->ino) {
-		ret = jffs2_garbage_collect_dirent(c, jeb, f, fd);
+		ret = jffs2_garbage_collect_dirent(c, jeb, inode, fd);
 	} else if (fd) {
-		ret = jffs2_garbage_collect_deletion_dirent(c, jeb, f, fd);
+		ret = jffs2_garbage_collect_deletion_dirent(c, jeb, inode, fd);
 	} else {
-		printk(KERN_WARNING "Raw node at 0x%08x wasn't in node lists for ino #%u\n",
-		       ref_offset(raw), f->inocache->ino);
-		if (ref_obsolete(raw)) {
+		printk(KERN_WARNING "Raw node at 0x%08x wasn't in node lists for ino #%lu\n", raw->flash_offset&~3, inode->i_ino);
+		if (raw->flash_offset & 1) {
 			printk(KERN_WARNING "But it's obsolete so we don't mind too much\n");
 		} else {
 			ret = -EIO;
@@ -388,7 +234,6 @@
 	}
  upnout:
 	up(&f->sem);
-	up(&c->alloc_sem);
 	iput(inode);
 
  eraseit_lock:
@@ -400,71 +245,35 @@
 		D1(printk(KERN_DEBUG "Block at 0x%08x completely obsoleted by GC. Moving to erase_pending_list\n", c->gcblock->offset));
 		/* We're GC'ing an empty block? */
 		list_add_tail(&c->gcblock->list, &c->erase_pending_list);
-		c->erasing_dirty_size += c->gcblock->dirty_size;
 		c->gcblock = NULL;
-		c->flags &= ~JFFS2_SB_FLAG_GCING_A_BLOCK;
 		c->nr_erasing_blocks++;
 		jffs2_erase_pending_trigger(c);
 	}
 	spin_unlock_bh(&c->erase_completion_lock);
+	up(&c->alloc_sem);
 
 	return ret;
 }
 
-/* jffs2_garbage_collect_pass
- * Make a single attempt to progress GC. Move one node, and possibly
- * start erasing one eraseblock.
- */
-int jffs2_garbage_collect_pass(struct jffs2_sb_info *c, jffs2_gcmode_t gcmode)
-{
-	struct jffs2_eraseblock *jeb;
-	int ret;
-
-	if (down_interruptible(&c->alloc_sem))
-		return -EINTR;
-
-	spin_lock_bh(&c->erase_completion_lock);
-
-	/* First, work out which block we're garbage-collecting */
-	jeb = c->gcblock;
-
-	if (!jeb)
-		jeb = jffs2_find_gc_block(c, gcmode == GCMODE_EFFECTIVE);
-
-	if (!jeb) {
-//		printk(KERN_NOTICE "jffs2: Couldn't find erase block to garbage collect!\n");
-		spin_unlock_bh(&c->erase_completion_lock);
-		up(&c->alloc_sem);
-		return (gcmode == GCMODE_EFFECTIVE) ? 0 : -ENOSPC;
-	}
-
-	ret = jffs2_do_garbage_collect_pass(c, jeb);
-	if (gcmode == GCMODE_EFFECTIVE)
-		return (ret == 0) ? 1 : ret;
-	else
-		return ret;
-}
-
 static int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, 
-					struct jffs2_inode_info *f, struct jffs2_full_dnode *fn)
+					struct inode *inode, struct jffs2_full_dnode *fn)
 {
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
 	struct jffs2_full_dnode *new_fn;
 	struct jffs2_raw_inode ri;
 	unsigned short dev;
 	char *mdata = NULL, mdatalen = 0;
-	uint32_t alloclen, phys_ofs;
+	__u32 alloclen, phys_ofs;
 	int ret;
 
-	if (S_ISBLK(JFFS2_F_I_MODE(f)) ||
-	    S_ISCHR(JFFS2_F_I_MODE(f)) ) {
+	if (S_ISBLK(inode->i_mode) || S_ISCHR(inode->i_mode)) {
 		/* For these, we don't actually need to read the old node */
-		/* FIXME: for minor or major > 255. */
-		dev =  ((JFFS2_F_I_RDEV_MAJ(f) << 8) | 
-			JFFS2_F_I_RDEV_MIN(f));
+		dev =  (MAJOR(to_kdev_t(inode->i_rdev)) << 8) | 
+			MINOR(to_kdev_t(inode->i_rdev));
 		mdata = (char *)&dev;
 		mdatalen = sizeof(dev);
 		D1(printk(KERN_DEBUG "jffs2_garbage_collect_metadata(): Writing %d bytes of kdev_t\n", mdatalen));
-	} else if (S_ISLNK(JFFS2_F_I_MODE(f))) {
+	} else if (S_ISLNK(inode->i_mode)) {
 		mdatalen = fn->size;
 		mdata = kmalloc(fn->size, GFP_KERNEL);
 		if (!mdata) {
@@ -489,28 +298,28 @@
 	}
 	
 	memset(&ri, 0, sizeof(ri));
-	ri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
-	ri.nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);
-	ri.totlen = cpu_to_je32(sizeof(ri) + mdatalen);
-	ri.hdr_crc = cpu_to_je32(crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4));
-
-	ri.ino = cpu_to_je32(f->inocache->ino);
-	ri.version = cpu_to_je32(++f->highest_version);
-	ri.mode = cpu_to_je32(JFFS2_F_I_MODE(f));
-	ri.uid = cpu_to_je16(JFFS2_F_I_UID(f));
-	ri.gid = cpu_to_je16(JFFS2_F_I_GID(f));
-	ri.isize = cpu_to_je32(JFFS2_F_I_SIZE(f));
-	ri.atime = cpu_to_je32(JFFS2_F_I_ATIME(f));
-	ri.ctime = cpu_to_je32(JFFS2_F_I_CTIME(f));
-	ri.mtime = cpu_to_je32(JFFS2_F_I_MTIME(f));
-	ri.offset = cpu_to_je32(0);
-	ri.csize = cpu_to_je32(mdatalen);
-	ri.dsize = cpu_to_je32(mdatalen);
+	ri.magic = JFFS2_MAGIC_BITMASK;
+	ri.nodetype = JFFS2_NODETYPE_INODE;
+	ri.totlen = sizeof(ri) + mdatalen;
+	ri.hdr_crc = crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4);
+
+	ri.ino = inode->i_ino;
+	ri.version = ++f->highest_version;
+	ri.mode = inode->i_mode;
+	ri.uid = inode->i_uid;
+	ri.gid = inode->i_gid;
+	ri.isize = inode->i_size;
+	ri.atime = inode->i_atime;
+	ri.ctime = inode->i_ctime;
+	ri.mtime = inode->i_mtime;
+	ri.offset = 0;
+	ri.csize = mdatalen;
+	ri.dsize = mdatalen;
 	ri.compr = JFFS2_COMPR_NONE;
-	ri.node_crc = cpu_to_je32(crc32(0, &ri, sizeof(ri)-8));
-	ri.data_crc = cpu_to_je32(crc32(0, mdata, mdatalen));
+	ri.node_crc = crc32(0, &ri, sizeof(ri)-8);
+	ri.data_crc = crc32(0, mdata, mdatalen);
 
-	new_fn = jffs2_write_dnode(c, f, &ri, mdata, mdatalen, phys_ofs, NULL);
+	new_fn = jffs2_write_dnode(inode, &ri, mdata, mdatalen, phys_ofs, NULL);
 
 	if (IS_ERR(new_fn)) {
 		printk(KERN_WARNING "Error writing new dnode: %ld\n", PTR_ERR(new_fn));
@@ -521,32 +330,33 @@
 	jffs2_free_full_dnode(fn);
 	f->metadata = new_fn;
  out:
-	if (S_ISLNK(JFFS2_F_I_MODE(f)))
+	if (S_ISLNK(inode->i_mode))
 		kfree(mdata);
 	return ret;
 }
 
 static int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, 
-					struct jffs2_inode_info *f, struct jffs2_full_dirent *fd)
+					struct inode *inode, struct jffs2_full_dirent *fd)
 {
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
 	struct jffs2_full_dirent *new_fd;
 	struct jffs2_raw_dirent rd;
-	uint32_t alloclen, phys_ofs;
+	__u32 alloclen, phys_ofs;
 	int ret;
 
-	rd.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
-	rd.nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);
+	rd.magic = JFFS2_MAGIC_BITMASK;
+	rd.nodetype = JFFS2_NODETYPE_DIRENT;
 	rd.nsize = strlen(fd->name);
-	rd.totlen = cpu_to_je32(sizeof(rd) + rd.nsize);
-	rd.hdr_crc = cpu_to_je32(crc32(0, &rd, sizeof(struct jffs2_unknown_node)-4));
+	rd.totlen = sizeof(rd) + rd.nsize;
+	rd.hdr_crc = crc32(0, &rd, sizeof(struct jffs2_unknown_node)-4);
 
-	rd.pino = cpu_to_je32(f->inocache->ino);
-	rd.version = cpu_to_je32(++f->highest_version);
-	rd.ino = cpu_to_je32(fd->ino);
-	rd.mctime = cpu_to_je32(max(JFFS2_F_I_MTIME(f), JFFS2_F_I_CTIME(f)));
+	rd.pino = inode->i_ino;
+	rd.version = ++f->highest_version;
+	rd.ino = fd->ino;
+	rd.mctime = max(inode->i_mtime, inode->i_ctime);
 	rd.type = fd->type;
-	rd.node_crc = cpu_to_je32(crc32(0, &rd, sizeof(rd)-8));
-	rd.name_crc = cpu_to_je32(crc32(0, fd->name, rd.nsize));
+	rd.node_crc = crc32(0, &rd, sizeof(rd)-8);
+	rd.name_crc = crc32(0, fd->name, rd.nsize);
 	
 	ret = jffs2_reserve_space_gc(c, sizeof(rd)+rd.nsize, &phys_ofs, &alloclen);
 	if (ret) {
@@ -554,7 +364,7 @@
 		       sizeof(rd)+rd.nsize, ret);
 		return ret;
 	}
-	new_fd = jffs2_write_dirent(c, f, &rd, fd->name, rd.nsize, phys_ofs, NULL);
+	new_fd = jffs2_write_dirent(inode, &rd, fd->name, rd.nsize, phys_ofs, NULL);
 
 	if (IS_ERR(new_fd)) {
 		printk(KERN_WARNING "jffs2_write_dirent in garbage_collect_dirent failed: %ld\n", PTR_ERR(new_fd));
@@ -565,119 +375,19 @@
 }
 
 static int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, 
-					struct jffs2_inode_info *f, struct jffs2_full_dirent *fd)
+					struct inode *inode, struct jffs2_full_dirent *fd)
 {
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
 	struct jffs2_full_dirent **fdp = &f->dents;
 	int found = 0;
 
-	/* On a medium where we can't actually mark nodes obsolete
-	   pernamently, such as NAND flash, we need to work out
-	   whether this deletion dirent is still needed to actively
-	   delete a 'real' dirent with the same name that's still
-	   somewhere else on the flash. */
-	if (!jffs2_can_mark_obsolete(c)) {
-		struct jffs2_raw_dirent rd;
-		struct jffs2_raw_node_ref *raw;
-		int ret;
-		size_t retlen;
-		int name_len = strlen(fd->name);
-		uint32_t name_crc = crc32(0, fd->name, name_len);
-		char *namebuf = NULL;
-
-		/* Prevent the erase code from nicking the obsolete node refs while
-		   we're looking at them. I really don't like this extra lock but
-		   can't see any alternative. Suggestions on a postcard to... */
-		down(&c->erase_free_sem);
-
-		for (raw = f->inocache->nodes; raw != (void *)f->inocache; raw = raw->next_in_ino) {
-			/* We only care about obsolete ones */
-			if (!(ref_obsolete(raw)))
-				continue;
-
-			/* Doesn't matter if there's one in the same erase block. We're going to 
-			   delete it too at the same time. */
-			if ((raw->flash_offset & ~(c->sector_size-1)) ==
-			    (fd->raw->flash_offset & ~(c->sector_size-1)))
-				continue;
-
-			/* This is an obsolete node belonging to the same directory */
-			ret = jffs2_flash_read(c, ref_offset(raw), sizeof(struct jffs2_unknown_node), &retlen, (char *)&rd);
-			if (ret) {
-				printk(KERN_WARNING "jffs2_g_c_deletion_dirent(): Read error (%d) reading header from obsolete node at %08x\n", ret, ref_offset(raw));
-				/* If we can't read it, we don't need to continue to obsolete it. Continue */
-				continue;
-			}
-			if (retlen != sizeof(struct jffs2_unknown_node)) {
-				printk(KERN_WARNING "jffs2_g_c_deletion_dirent(): Short read (%d not %d) reading header from obsolete node at %08x\n",
-				       retlen, sizeof(struct jffs2_unknown_node), ref_offset(raw));
-				continue;
-			}
-			if (je16_to_cpu(rd.nodetype) != JFFS2_NODETYPE_DIRENT ||
-			    PAD(je32_to_cpu(rd.totlen)) != PAD(sizeof(rd) + name_len))
-				continue;
-
-			/* OK, it's a dirent node, it's the right length. We have to take a 
-			   closer look at it... */
-			ret = jffs2_flash_read(c, ref_offset(raw), sizeof(rd), &retlen, (char *)&rd);
-			if (ret) {
-				printk(KERN_WARNING "jffs2_g_c_deletion_dirent(): Read error (%d) reading from obsolete node at %08x\n", ret, ref_offset(raw));
-				/* If we can't read it, we don't need to continune to obsolete it. Continue */
-				continue;
-			}
-			if (retlen != sizeof(rd)) {
-				printk(KERN_WARNING "jffs2_g_c_deletion_dirent(): Short read (%d not %d) reading from obsolete node at %08x\n",
-				       retlen, sizeof(rd), ref_offset(raw));
-				continue;
-			}
-
-			/* If the name CRC doesn't match, skip */
-			if (je32_to_cpu(rd.name_crc) != name_crc)
-				continue;
-			/* If the name length doesn't match, or it's another deletion dirent, skip */
-			if (rd.nsize != name_len || !je32_to_cpu(rd.ino))
-				continue;
-
-			/* OK, check the actual name now */
-			if (!namebuf) {
-				namebuf = kmalloc(name_len + 1, GFP_KERNEL);
-				if (!namebuf) {
-					up(&c->erase_free_sem);
-					return -ENOMEM;
-				}
-			}
-			/* We read the extra byte before it so it's a word-aligned read */
-			ret = jffs2_flash_read(c, (ref_offset(raw))+sizeof(rd)-1, name_len+1, &retlen, namebuf);
-			if (ret) {
-				printk(KERN_WARNING "jffs2_g_c_deletion_dirent(): Read error (%d) reading name from obsolete node at %08x\n", ret, ref_offset(raw));
-				/* If we can't read it, we don't need to continune to obsolete it. Continue */
-				continue;
-			}
-			if (retlen != name_len+1) {
-				printk(KERN_WARNING "jffs2_g_c_deletion_dirent(): Short read (%d not %d) reading name from obsolete node at %08x\n",
-				       retlen, name_len+1, ref_offset(raw));
-				continue;
-			}
-			if (memcmp(namebuf+1, fd->name, name_len))
-				continue;
-
-			/* OK. The name really does match. There really is still an older node on
-			   the flash which our deletion dirent obsoletes. So we have to write out
-			   a new deletion dirent to replace it */
-			
-			if (namebuf)
-				kfree(namebuf);
-
-			up(&c->erase_free_sem);
-			return jffs2_garbage_collect_dirent(c, jeb, f, fd);
-		}
-
-		up(&c->erase_free_sem);
-
-		if (namebuf) 
-			kfree(namebuf);
-	}
-
-	/* No need for it any more. Just mark it obsolete and remove it from the list */
+	/* FIXME: When we run on NAND flash, we need to work out whether
+	   this deletion dirent is still needed to actively delete a
+	   'real' dirent with the same name that's still somewhere else
+	   on the flash. For now, we know that we've actually obliterated
+	   all the older dirents when they became obsolete, so we didn't
+	   really need to write the deletion to flash in the first place.
+	*/
 	while (*fdp) {
 		if ((*fdp) == fd) {
 			found = 1;
@@ -687,7 +397,7 @@
 		fdp = &(*fdp)->next;
 	}
 	if (!found) {
-		printk(KERN_WARNING "Deletion dirent \"%s\" not found in list for ino #%u\n", fd->name, f->inocache->ino);
+		printk(KERN_WARNING "Deletion dirent \"%s\" not found in list for ino #%lu\n", fd->name, inode->i_ino);
 	}
 	jffs2_mark_node_obsolete(c, fd->raw);
 	jffs2_free_full_dirent(fd);
@@ -695,81 +405,79 @@
 }
 
 static int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
-				      struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,
-				      uint32_t start, uint32_t end)
+				      struct inode *inode, struct jffs2_full_dnode *fn,
+				      __u32 start, __u32 end)
 {
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
 	struct jffs2_raw_inode ri;
 	struct jffs2_node_frag *frag;
 	struct jffs2_full_dnode *new_fn;
-	uint32_t alloclen, phys_ofs;
+	__u32 alloclen, phys_ofs;
 	int ret;
 
-	D1(printk(KERN_DEBUG "Writing replacement hole node for ino #%u from offset 0x%x to 0x%x\n",
-		  f->inocache->ino, start, end));
+	D1(printk(KERN_DEBUG "Writing replacement hole node for ino #%lu from offset 0x%x to 0x%x\n",
+		  inode->i_ino, start, end));
 	
 	memset(&ri, 0, sizeof(ri));
 
 	if(fn->frags > 1) {
 		size_t readlen;
-		uint32_t crc;
+		__u32 crc;
 		/* It's partially obsoleted by a later write. So we have to 
 		   write it out again with the _same_ version as before */
-		ret = jffs2_flash_read(c, ref_offset(fn->raw), sizeof(ri), &readlen, (char *)&ri);
+		ret = c->mtd->read(c->mtd, fn->raw->flash_offset & ~3, sizeof(ri), &readlen, (char *)&ri);
 		if (readlen != sizeof(ri) || ret) {
-			printk(KERN_WARNING "Node read failed in jffs2_garbage_collect_hole. Ret %d, retlen %d. Data will be lost by writing new hole node\n", ret, readlen);
+			printk(KERN_WARNING "Node read failed in jffs2_garbage_collect_hole. Ret %d, retlen %d. Data will be lost by writing new hold node\n", ret, readlen);
 			goto fill;
 		}
-		if (je16_to_cpu(ri.nodetype) != JFFS2_NODETYPE_INODE) {
+		if (ri.nodetype != JFFS2_NODETYPE_INODE) {
 			printk(KERN_WARNING "jffs2_garbage_collect_hole: Node at 0x%08x had node type 0x%04x instead of JFFS2_NODETYPE_INODE(0x%04x)\n",
-			       ref_offset(fn->raw),
-			       je16_to_cpu(ri.nodetype), JFFS2_NODETYPE_INODE);
+			       fn->raw->flash_offset & ~3, ri.nodetype, JFFS2_NODETYPE_INODE);
 			return -EIO;
 		}
-		if (je32_to_cpu(ri.totlen) != sizeof(ri)) {
+		if (ri.totlen != sizeof(ri)) {
 			printk(KERN_WARNING "jffs2_garbage_collect_hole: Node at 0x%08x had totlen 0x%x instead of expected 0x%x\n",
-			       ref_offset(fn->raw),
-			       je32_to_cpu(ri.totlen), sizeof(ri));
+			       fn->raw->flash_offset & ~3, ri.totlen, sizeof(ri));
 			return -EIO;
 		}
 		crc = crc32(0, &ri, sizeof(ri)-8);
-		if (crc != je32_to_cpu(ri.node_crc)) {
+		if (crc != ri.node_crc) {
 			printk(KERN_WARNING "jffs2_garbage_collect_hole: Node at 0x%08x had CRC 0x%08x which doesn't match calculated CRC 0x%08x\n",
-			       ref_offset(fn->raw), 
-			       je32_to_cpu(ri.node_crc), crc);
+			       fn->raw->flash_offset & ~3, ri.node_crc, crc);
 			/* FIXME: We could possibly deal with this by writing new holes for each frag */
-			printk(KERN_WARNING "Data in the range 0x%08x to 0x%08x of inode #%u will be lost\n", 
-			       start, end, f->inocache->ino);
+			printk(KERN_WARNING "Data in the range 0x%08x to 0x%08x of inode #%lu will be lost\n", 
+			       start, end, inode->i_ino);
 			goto fill;
 		}
 		if (ri.compr != JFFS2_COMPR_ZERO) {
-			printk(KERN_WARNING "jffs2_garbage_collect_hole: Node 0x%08x wasn't a hole node!\n", ref_offset(fn->raw));
-			printk(KERN_WARNING "Data in the range 0x%08x to 0x%08x of inode #%u will be lost\n", 
-			       start, end, f->inocache->ino);
+			printk(KERN_WARNING "jffs2_garbage_collect_hole: Node 0x%08x wasn't a hole node!\n", fn->raw->flash_offset & ~3);
+			printk(KERN_WARNING "Data in the range 0x%08x to 0x%08x of inode #%lu will be lost\n", 
+			       start, end, inode->i_ino);
 			goto fill;
 		}
 	} else {
 	fill:
-		ri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
-		ri.nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);
-		ri.totlen = cpu_to_je32(sizeof(ri));
-		ri.hdr_crc = cpu_to_je32(crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4));
-
-		ri.ino = cpu_to_je32(f->inocache->ino);
-		ri.version = cpu_to_je32(++f->highest_version);
-		ri.offset = cpu_to_je32(start);
-		ri.dsize = cpu_to_je32(end - start);
-		ri.csize = cpu_to_je32(0);
+		ri.magic = JFFS2_MAGIC_BITMASK;
+		ri.nodetype = JFFS2_NODETYPE_INODE;
+		ri.totlen = sizeof(ri);
+		ri.hdr_crc = crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4);
+
+		ri.ino = inode->i_ino;
+		ri.version = ++f->highest_version;
+		ri.offset = start;
+		ri.dsize = end - start;
+		ri.csize = 0;
 		ri.compr = JFFS2_COMPR_ZERO;
 	}
-	ri.mode = cpu_to_je32(JFFS2_F_I_MODE(f));
-	ri.uid = cpu_to_je16(JFFS2_F_I_UID(f));
-	ri.gid = cpu_to_je16(JFFS2_F_I_GID(f));
-	ri.isize = cpu_to_je32(JFFS2_F_I_SIZE(f));
-	ri.atime = cpu_to_je32(JFFS2_F_I_ATIME(f));
-	ri.ctime = cpu_to_je32(JFFS2_F_I_CTIME(f));
-	ri.mtime = cpu_to_je32(JFFS2_F_I_MTIME(f));
-	ri.data_crc = cpu_to_je32(0);
-	ri.node_crc = cpu_to_je32(crc32(0, &ri, sizeof(ri)-8));
+	ri.mode = inode->i_mode;
+	ri.uid = inode->i_uid;
+	ri.gid = inode->i_gid;
+	ri.isize = inode->i_size;
+	ri.atime = inode->i_atime;
+	ri.ctime = inode->i_ctime;
+	ri.mtime = inode->i_mtime;
+	ri.data_crc = 0;
+	ri.node_crc = crc32(0, &ri, sizeof(ri)-8);
 
 	ret = jffs2_reserve_space_gc(c, sizeof(ri), &phys_ofs, &alloclen);
 	if (ret) {
@@ -777,13 +485,13 @@
 		       sizeof(ri), ret);
 		return ret;
 	}
-	new_fn = jffs2_write_dnode(c, f, &ri, NULL, 0, phys_ofs, NULL);
+	new_fn = jffs2_write_dnode(inode, &ri, NULL, 0, phys_ofs, NULL);
 
 	if (IS_ERR(new_fn)) {
 		printk(KERN_WARNING "Error writing new hole node: %ld\n", PTR_ERR(new_fn));
 		return PTR_ERR(new_fn);
 	}
-	if (je32_to_cpu(ri.version) == f->highest_version) {
+	if (ri.version == f->highest_version) {
 		jffs2_add_full_dnode_to_inode(c, f, new_fn);
 		if (f->metadata) {
 			jffs2_mark_node_obsolete(c, f->metadata->raw);
@@ -799,14 +507,12 @@
 	 * number as before. (Except in case of error -- see 'goto fill;' 
 	 * above.)
 	 */
-	D1(if(unlikely(fn->frags <= 1)) {
+	D1(if(fn->frags <= 1) {
 		printk(KERN_WARNING "jffs2_garbage_collect_hole: Replacing fn with %d frag(s) but new ver %d != highest_version %d of ino #%d\n",
-		       fn->frags, je32_to_cpu(ri.version), f->highest_version,
-		       je32_to_cpu(ri.ino));
+		       fn->frags, ri.version, f->highest_version, ri.ino);
 	});
 
-	for (frag = jffs2_lookup_node_frag(&f->fragtree, fn->ofs); 
-	     frag; frag = frag_next(frag)) {
+	for (frag = f->fraglist; frag; frag = frag->next) {
 		if (frag->ofs > fn->size + fn->ofs)
 			break;
 		if (frag->node == fn) {
@@ -831,26 +537,27 @@
 }
 
 static int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
-				       struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,
-				       uint32_t start, uint32_t end)
+				       struct inode *inode, struct jffs2_full_dnode *fn,
+				       __u32 start, __u32 end)
 {
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
 	struct jffs2_full_dnode *new_fn;
 	struct jffs2_raw_inode ri;
-	uint32_t alloclen, phys_ofs, offset, orig_end;	
+	__u32 alloclen, phys_ofs, offset, orig_end;	
 	int ret = 0;
 	unsigned char *comprbuf = NULL, *writebuf;
 	struct page *pg;
 	unsigned char *pg_ptr;
-	int reserved_blocks_root = capable(CAP_SYS_ADMIN) ? 0 : JFFS2_RESERVED_BLOCKS_ROOT;
-	/* FIXME: */ struct inode *inode = OFNI_EDONI_2SFFJ(f);
+
 
 	memset(&ri, 0, sizeof(ri));
 
-	D1(printk(KERN_DEBUG "Writing replacement dnode for ino #%u from offset 0x%x to 0x%x\n",
-		  f->inocache->ino, start, end));
+	D1(printk(KERN_DEBUG "Writing replacement dnode for ino #%lu from offset 0x%x to 0x%x\n",
+		  inode->i_ino, start, end));
 
 	orig_end = end;
 
+
 	/* If we're looking at the last node in the block we're
 	   garbage-collecting, we allow ourselves to merge as if the
 	   block was already erasing. We're likely to be GC'ing a
@@ -862,11 +569,11 @@
 	   the GC would churn and churn, and just leave dirty blocks in
 	   it's wake.
 	*/
-	if(NR_AVAIL_BLOCKS(c) > JFFS2_RESERVED_BLOCKS_GCMERGE + reserved_blocks_root - (fn->raw->next_phys?0:1)) {
+	if(c->nr_free_blocks + c->nr_erasing_blocks > JFFS2_RESERVED_BLOCKS_GCMERGE - (fn->raw->next_phys?0:1)) {
 		/* Shitloads of space */
 		/* FIXME: Integrate this properly with GC calculations */
 		start &= ~(PAGE_CACHE_SIZE-1);
-		end = min_t(uint32_t, start + PAGE_CACHE_SIZE, JFFS2_F_I_SIZE(f));
+		end = min_t(__u32, start + PAGE_CACHE_SIZE, inode->i_size);
 		D1(printk(KERN_DEBUG "Plenty of free space, so expanding to write from offset 0x%x to 0x%x\n",
 			  start, end));
 		if (end < orig_end) {
@@ -882,28 +589,19 @@
 	 *    page OK. We'll actually write it out again in commit_write, which is a little
 	 *    suboptimal, but at least we're correct.
 	 */
-	pg = find_get_page(inode->i_mapping, start >> PAGE_CACHE_SHIFT);
-	if (pg) {
-		if (PageLocked(pg)) {
-			page_cache_release(pg);
-			return 0;
-		}
-		page_cache_release(pg);
-	}
-	pg = read_cache_page(inode->i_mapping, start >> PAGE_CACHE_SHIFT, (void *)jffs2_do_readpage_nolock, inode);
+	pg = read_cache_page(inode->i_mapping, start >> PAGE_CACHE_SHIFT, (void *)jffs2_do_readpage_unlock, inode);
 
 	if (IS_ERR(pg)) {
 		printk(KERN_WARNING "read_cache_page() returned error: %ld\n", PTR_ERR(pg));
 		return PTR_ERR(pg);
 	}
-	LockPage(pg);
 	pg_ptr = (char *)kmap(pg);
 	comprbuf = kmalloc(end - start, GFP_KERNEL);
 
 	offset = start;
 	while(offset < orig_end) {
-		uint32_t datalen;
-		uint32_t cdatalen;
+		__u32 datalen;
+		__u32 cdatalen;
 		char comprtype = JFFS2_COMPR_NONE;
 
 		ret = jffs2_reserve_space_gc(c, sizeof(ri) + JFFS2_MIN_DATA_LEN, &phys_ofs, &alloclen);
@@ -926,28 +624,28 @@
 		} else {
 			datalen = cdatalen;
 		}
-		ri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
-		ri.nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);
-		ri.totlen = cpu_to_je32(sizeof(ri) + cdatalen);
-		ri.hdr_crc = cpu_to_je32(crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4));
-
-		ri.ino = cpu_to_je32(f->inocache->ino);
-		ri.version = cpu_to_je32(++f->highest_version);
-		ri.mode = cpu_to_je32(JFFS2_F_I_MODE(f));
-		ri.uid = cpu_to_je16(JFFS2_F_I_UID(f));
-		ri.gid = cpu_to_je16(JFFS2_F_I_GID(f));
-		ri.isize = cpu_to_je32(JFFS2_F_I_SIZE(f));
-		ri.atime = cpu_to_je32(JFFS2_F_I_ATIME(f));
-		ri.ctime = cpu_to_je32(JFFS2_F_I_CTIME(f));
-		ri.mtime = cpu_to_je32(JFFS2_F_I_MTIME(f));
-		ri.offset = cpu_to_je32(offset);
-		ri.csize = cpu_to_je32(cdatalen);
-		ri.dsize = cpu_to_je32(datalen);
+		ri.magic = JFFS2_MAGIC_BITMASK;
+		ri.nodetype = JFFS2_NODETYPE_INODE;
+		ri.totlen = sizeof(ri) + cdatalen;
+		ri.hdr_crc = crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4);
+
+		ri.ino = inode->i_ino;
+		ri.version = ++f->highest_version;
+		ri.mode = inode->i_mode;
+		ri.uid = inode->i_uid;
+		ri.gid = inode->i_gid;
+		ri.isize = inode->i_size;
+		ri.atime = inode->i_atime;
+		ri.ctime = inode->i_ctime;
+		ri.mtime = inode->i_mtime;
+		ri.offset = offset;
+		ri.csize = cdatalen;
+		ri.dsize = datalen;
 		ri.compr = comprtype;
-		ri.node_crc = cpu_to_je32(crc32(0, &ri, sizeof(ri)-8));
-		ri.data_crc = cpu_to_je32(crc32(0, writebuf, cdatalen));
+		ri.node_crc = crc32(0, &ri, sizeof(ri)-8);
+		ri.data_crc = crc32(0, writebuf, cdatalen);
 	
-		new_fn = jffs2_write_dnode(c, f, &ri, writebuf, cdatalen, phys_ofs, NULL);
+		new_fn = jffs2_write_dnode(inode, &ri, writebuf, cdatalen, phys_ofs, NULL);
 
 		if (IS_ERR(new_fn)) {
 			printk(KERN_WARNING "Error writing new dnode: %ld\n", PTR_ERR(new_fn));
@@ -965,15 +663,9 @@
 	if (comprbuf) kfree(comprbuf);
 
 	kunmap(pg);
-	unlock_page(pg);
 	/* XXX: Does the page get freed automatically? */
 	/* AAA: Judging by the unmount getting stuck in __wait_on_page, nope. */
 	page_cache_release(pg);
 	return ret;
 }
 
-/*
- * Local variables:
- *   c-basic-offset: 8
- * End:
- */
diff -Nur linux/fs/jffs2/ioctl.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ioctl.c
--- linux/fs/jffs2/ioctl.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/ioctl.c	2003-06-23 01:47:04.000000000 +0700
@@ -5,9 +5,33 @@
  *
  * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: ioctl.c,v 1.6 2002/05/20 14:56:38 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: ioctl.c,v 1.5 2001/03/15 15:38:24 dwmw2 Exp $
  *
  */
 
diff -Nur linux/fs/jffs2/jffs2_proc.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/jffs2_proc.c
--- linux/fs/jffs2/jffs2_proc.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/jffs2_proc.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,837 +0,0 @@
-/*
- * fs/jffs2/jffs2_proc.c
- *
- * Copyright (C) 2002 Lineo Japan, Inc.
- *
- * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.
- *
- * $Id: jffs2_proc.c,v 1.13 2002/12/19 02:42:45 yamade Exp $
- *
- * Derived from fs/jffs/jffs_proc.c
- *
- * JFFS -- Journaling Flash File System, Linux implementation.
- *
- * Copyright (C) 2000  Axis Communications AB.
- *
- * Created by Simon Kagstrom <simonk@axis.com>.
- *
- * This is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- *  Overview:
- *   This file defines JFFS partition entries in the proc file system.
- *
- *  TODO:
- *   Create some more proc files for different kinds of info, i.e. statistics
- *   about written and read bytes, number of calls to different routines,
- *   reports about failures.
- *
- * ChangLog:
- *     05-Dec-2002 SHARP  add proc-files
- */
-
-#include <linux/errno.h>
-#include <linux/fs.h>
-#include <linux/jffs.h>
-#include <linux/slab.h>
-#include <linux/proc_fs.h>
-#include <linux/sched.h>
-#include <linux/types.h>
-#include <linux/ctype.h>
-#include "jffs2_proc.h"
-#include "nodelist.h"
-#include "nodemerge.h"
-
-/*
- * Structure for a JFFS2 partition in the system
- */
-struct jffs2_partition_dir {
-    struct jffs2_sb_info *c;
-    struct proc_dir_entry *part_root;
-    struct proc_dir_entry *part_partition_size;
-    struct proc_dir_entry *part_sector_size;
-    struct proc_dir_entry *part_used_size;
-    struct proc_dir_entry *part_dirty_size;
-    struct proc_dir_entry *part_free_size;
-    struct proc_dir_entry *part_wasted_size;
-    struct proc_dir_entry *part_erasing_size;
-    struct proc_dir_entry *part_free_blocks;
-    struct proc_dir_entry *part_erasing_blocks;
-    struct proc_dir_entry *part_gcing_blocks;
-    struct proc_dir_entry *part_bad_blocks;
-    struct proc_dir_entry *part_cont_gc_count;
-    struct proc_dir_entry *part_reserved_blocks_write;
-    struct proc_dir_entry *part_reserved_blocks_root;
-    struct proc_dir_entry *part_reserved_blocks_bad;
-    struct proc_dir_entry *part_reliable_free_size;
-    struct proc_dir_entry *part_reliable_free_blocks;
-    struct proc_dir_entry *part_nonerasing_dirty_size;
-    struct proc_dir_entry *part_effective_gc_count;
-    struct proc_dir_entry *part_dump_block_lists;
-    struct proc_dir_entry *part_nodemerge;
-    struct jffs2_partition_dir *next;
-};
-
-/*
- * Structure for top-level entry in '/proc/fs' directory
- */
-struct proc_dir_entry *jffs2_proc_root;
-
-/*
- * Linked list of 'jffs2_partition_dirs' to help us track
- * the mounted JFFS2 partitions in the system
- */
-static struct jffs2_partition_dir *jffs2_part_dirs = 0;
-
-/*
- * Read functions for entries
- */
-static int jffs2_proc_partition_size_read(char *page, char **start, off_t off,
-					  int count, int *eof, void *data);
-static int jffs2_proc_sector_size_read(char *page, char **start, off_t off,
-				       int count, int *eof, void *data);
-static int jffs2_proc_used_size_read(char *page, char **start, off_t off,
-				     int count, int *eof, void *data);
-static int jffs2_proc_dirty_size_read(char *page, char **start, off_t off,
-				      int count, int *eof, void *data);
-static int jffs2_proc_free_size_read(char *page, char **start, off_t off,
-				     int count, int *eof, void *data);
-static int jffs2_proc_wasted_size_read(char *page, char **start, off_t off,
-				       int count, int *eof, void *data);
-static int jffs2_proc_erasing_size_read(char *page, char **start, off_t off,
-					int count, int *eof, void *data);
-static int jffs2_proc_free_blocks_read(char *page, char **start, off_t off,
-				       int count, int *eof, void *data);
-static int jffs2_proc_erasing_blocks_read(char *page, char **start, off_t off,
-					  int count, int *eof, void *data);
-static int jffs2_proc_gcing_blocks_read(char *page, char **start, off_t off,
-					  int count, int *eof, void *data);
-static int jffs2_proc_bad_blocks_read(char *page, char **start, off_t off,
-				      int count, int *eof, void *data);
-static int jffs2_proc_cont_gc_count_read(char *page, char **start, off_t off,
-					 int count, int *eof, void *data);
-static int jffs2_proc_reserved_blocks_write_read(char *page, char **start, off_t off,
-						 int count, int *eof, void *data);
-static int jffs2_proc_reserved_blocks_root_read(char *page, char **start, off_t off,
-						int count, int *eof, void *data);
-static int jffs2_proc_reserved_blocks_bad_read(char *page, char **start, off_t off,
-					       int count, int *eof, void *data);
-static int jffs2_proc_reliable_free_size_read(char *page, char **start, off_t off,
-					      int count, int *eof, void *data);
-static int jffs2_proc_reliable_free_blocks_read(char *page, char **start, off_t off,
-					      int count, int *eof, void *data);
-static int jffs2_proc_nonerasing_dirty_size_read(char *page, char **start, off_t off,
-					      int count, int *eof, void *data);
-static int jffs2_proc_effective_gc_count_read(char *page, char **start, off_t off,
-					      int count, int *eof, void *data);
-static int jffs2_proc_dump_block_lists_read(char *page, char **start, off_t off,
-					      int count, int *eof, void *data);
-static int jffs2_proc_nodemerge_write(struct file *file, const char *buffer,
-				      unsigned long count, void *data);
-
-
-/*
- * Register a JFFS2 partition directory (called upon mount)
- */
-int
-jffs2_register_jffs2_proc_dir(kdev_t dev, struct jffs2_sb_info *c)
-{
-    struct jffs2_partition_dir *part_dir;
-    struct proc_dir_entry *part_root = 0;
-    struct proc_dir_entry *part_partition_size = 0;
-    struct proc_dir_entry *part_sector_size = 0;
-    struct proc_dir_entry *part_used_size = 0;
-    struct proc_dir_entry *part_dirty_size = 0;
-    struct proc_dir_entry *part_free_size = 0;
-    struct proc_dir_entry *part_wasted_size = 0;
-    struct proc_dir_entry *part_erasing_size = 0;
-    struct proc_dir_entry *part_free_blocks = 0;
-    struct proc_dir_entry *part_erasing_blocks = 0;
-    struct proc_dir_entry *part_gcing_blocks = 0;
-    struct proc_dir_entry *part_bad_blocks = 0;
-    struct proc_dir_entry *part_cont_gc_count = 0;
-    struct proc_dir_entry *part_reserved_blocks_write = 0;
-    struct proc_dir_entry *part_reserved_blocks_root = 0;
-    struct proc_dir_entry *part_reserved_blocks_bad = 0;
-    struct proc_dir_entry *part_reliable_free_size = 0;
-    struct proc_dir_entry *part_reliable_free_blocks = 0;
-    struct proc_dir_entry *part_nonerasing_dirty_size = 0;
-    struct proc_dir_entry *part_effective_gc_count = 0;
-    struct proc_dir_entry *part_dump_block_lists = 0;
-    struct proc_dir_entry *part_nodemerge = 0;
-
-    /* Allocate structure for local JFFS2 partition table */
-    if (!(part_dir = (struct jffs2_partition_dir *)
-	  kmalloc (sizeof (struct jffs2_partition_dir), GFP_KERNEL))) {
-	return -ENOMEM;
-    }
-
-    /* Create entry for this partition */
-    part_root = proc_mkdir(kdevname(dev), jffs2_proc_root);
-    if (! part_root) {
-	kfree(part_dir);
-	return -ENOMEM;
-    }
-
-    /* Create entry for 'info' file */
-    part_partition_size = create_proc_read_entry("partition_size", 0, part_root,
-						 jffs2_proc_partition_size_read, c);
-    part_sector_size = create_proc_read_entry("sector_size", 0, part_root, 
-					      jffs2_proc_sector_size_read, c);
-    part_used_size = create_proc_read_entry("used_size", 0, part_root,
-					    jffs2_proc_used_size_read, c);
-    part_dirty_size = create_proc_read_entry("dirty_size", 0, part_root,
-					     jffs2_proc_dirty_size_read, c);
-    part_free_size = create_proc_read_entry("free_size", 0, part_root,
-					    jffs2_proc_free_size_read, c);
-    part_wasted_size = create_proc_read_entry("wasted_size", 0, part_root,
-					      jffs2_proc_wasted_size_read, c);
-    part_erasing_size = create_proc_read_entry("erasing_size", 0, part_root,
-					       jffs2_proc_erasing_size_read, c);
-    part_free_blocks = create_proc_read_entry("free_blocks", 0, part_root,
-					      jffs2_proc_free_blocks_read, c);
-    part_erasing_blocks = create_proc_read_entry("erasing_blocks", 0, part_root,
-						 jffs2_proc_erasing_blocks_read, c);
-    part_gcing_blocks = create_proc_read_entry("gcing_blocks", 0, part_root,
-						 jffs2_proc_gcing_blocks_read, c);
-    part_bad_blocks = create_proc_read_entry("bad_blocks", 0, part_root,
-					     jffs2_proc_bad_blocks_read, c);
-    part_cont_gc_count = create_proc_read_entry("cont_gc_count", 0, part_root,
-						jffs2_proc_cont_gc_count_read, c);
-    part_reserved_blocks_write = create_proc_read_entry("reserved_blocks_write", 0, part_root,
-							jffs2_proc_reserved_blocks_write_read, c);
-    part_reserved_blocks_root = create_proc_read_entry("reserved_blocks_root", 0, part_root,
-						jffs2_proc_reserved_blocks_root_read, c);
-    part_reserved_blocks_bad = create_proc_read_entry("reserved_blocks_bad", 0, part_root,
-						      jffs2_proc_reserved_blocks_bad_read, c);
-    part_reliable_free_size = create_proc_read_entry("reliable_free_size", 0, part_root,
-						      jffs2_proc_reliable_free_size_read, c);
-    part_reliable_free_blocks = create_proc_read_entry("reliable_free_blocks", 0, part_root,
-						      jffs2_proc_reliable_free_blocks_read, c);
-    part_nonerasing_dirty_size = create_proc_read_entry("nonerasing_dirty_size", 0, part_root,
-						      jffs2_proc_nonerasing_dirty_size_read, c);
-    part_effective_gc_count = create_proc_read_entry("effective_gc_count", 0, part_root,
-						     jffs2_proc_effective_gc_count_read, c);
-    part_dump_block_lists = create_proc_read_entry(".dump_block_lists", 0, part_root,
-						     jffs2_proc_dump_block_lists_read, c);
-    part_nodemerge = create_proc_entry(".nodemerge", 0222, part_root);
-    if (! part_partition_size || ! part_sector_size || ! part_used_size ||
-	! part_dirty_size || ! part_free_size || ! part_wasted_size ||
-	! part_erasing_size || ! part_free_blocks ||
-	! part_erasing_blocks || ! part_gcing_blocks ||
-	! part_bad_blocks || ! part_cont_gc_count || ! part_reserved_blocks_write ||
-	! part_reserved_blocks_root || ! part_reserved_blocks_bad ||
-	! part_reliable_free_size || ! part_reliable_free_blocks ||
-	! part_nonerasing_dirty_size || ! part_effective_gc_count ||
-	! part_dump_block_lists || ! part_nodemerge) {
-	if (part_partition_size)
-	    remove_proc_entry(part_partition_size->name, part_root);
-	if (part_sector_size)
-	    remove_proc_entry(part_sector_size->name, part_root);
-	if (part_used_size)
-	    remove_proc_entry(part_used_size->name, part_root);
-	if (part_dirty_size)
-	    remove_proc_entry(part_dirty_size->name, part_root);
-	if (part_free_size)
-	    remove_proc_entry(part_free_size->name, part_root);
-	if (part_wasted_size)
-	    remove_proc_entry(part_wasted_size->name, part_root);
-	if (part_erasing_size)
-	    remove_proc_entry(part_erasing_size->name, part_root);
-	if (part_free_blocks)
-	    remove_proc_entry(part_free_blocks->name, part_root);
-	if (part_erasing_blocks)
-	    remove_proc_entry(part_erasing_blocks->name, part_root);
-	if (part_gcing_blocks)
-	    remove_proc_entry(part_gcing_blocks->name, part_root);
-	if (part_bad_blocks)
-	    remove_proc_entry(part_bad_blocks->name, part_root);
-	if (part_cont_gc_count)
-	    remove_proc_entry(part_cont_gc_count->name, part_root);
-	if (part_reserved_blocks_write)
-	    remove_proc_entry(part_reserved_blocks_write->name, part_root);
-	if (part_reserved_blocks_root)
-	    remove_proc_entry(part_reserved_blocks_root->name, part_root);
-	if (part_reserved_blocks_bad)
-	    remove_proc_entry(part_reserved_blocks_bad->name, part_root);
-	if (part_reliable_free_size)
-	    remove_proc_entry(part_reliable_free_size->name, part_root);
-	if (part_reliable_free_blocks)
-	    remove_proc_entry(part_reliable_free_blocks->name, part_root);
-	if (part_nonerasing_dirty_size)
-	    remove_proc_entry(part_nonerasing_dirty_size->name, part_root);
-	if (part_effective_gc_count)
-	    remove_proc_entry(part_effective_gc_count->name, part_root);
-	if (part_dump_block_lists)
-	    remove_proc_entry(part_dump_block_lists->name, part_root);
-	if (part_nodemerge)
-	    remove_proc_entry(part_nodemerge->name, part_root);
-	kfree(part_dir);
-	return -ENOMEM;
-    }
-    part_nodemerge->write_proc = jffs2_proc_nodemerge_write;
-    part_nodemerge->data = c;
-
-    /* Fill in structure for table and insert in the list */
-    part_dir->c = c;
-    part_dir->part_root = part_root;
-    part_dir->part_partition_size = part_partition_size;
-    part_dir->part_sector_size = part_sector_size;
-    part_dir->part_used_size = part_used_size;
-    part_dir->part_dirty_size = part_dirty_size;
-    part_dir->part_free_size = part_free_size;
-    part_dir->part_wasted_size = part_wasted_size;
-    part_dir->part_erasing_size = part_erasing_size;
-    part_dir->part_free_blocks = part_free_blocks;
-    part_dir->part_erasing_blocks = part_erasing_blocks;
-    part_dir->part_gcing_blocks = part_gcing_blocks;
-    part_dir->part_bad_blocks = part_bad_blocks;
-    part_dir->part_cont_gc_count = part_cont_gc_count;
-    part_dir->part_reserved_blocks_write = part_reserved_blocks_write;
-    part_dir->part_reserved_blocks_root = part_reserved_blocks_root;
-    part_dir->part_reserved_blocks_bad = part_reserved_blocks_bad;
-    part_dir->part_reliable_free_size = part_reliable_free_size;
-    part_dir->part_reliable_free_blocks = part_reliable_free_blocks;
-    part_dir->part_nonerasing_dirty_size = part_nonerasing_dirty_size;
-    part_dir->part_effective_gc_count = part_effective_gc_count;
-    part_dir->part_dump_block_lists = part_dump_block_lists;
-    part_dir->part_nodemerge = part_nodemerge;
-    part_dir->next = jffs2_part_dirs;
-    jffs2_part_dirs = part_dir;
-
-    /* Return happy */
-    return 0;
-}
-
-
-/*
- * Unregister a JFFS2 partition directory (called at umount)
- */
-int
-jffs2_unregister_jffs2_proc_dir(struct jffs2_sb_info *c)
-{
-    struct jffs2_partition_dir *part_dir = jffs2_part_dirs;
-    struct jffs2_partition_dir *prev_part_dir = 0;
-
-    while (part_dir) {
-	if (part_dir->c == c) {
-	    struct proc_dir_entry *part_root = part_dir->part_root;
-
-	    /* Remove entries for partition */
-	    remove_proc_entry(part_dir->part_partition_size->name, part_root);
-	    remove_proc_entry(part_dir->part_sector_size->name, part_root);
-	    remove_proc_entry(part_dir->part_used_size->name, part_root);
-	    remove_proc_entry(part_dir->part_dirty_size->name, part_root);
-	    remove_proc_entry(part_dir->part_free_size->name, part_root);
-	    remove_proc_entry(part_dir->part_wasted_size->name, part_root);
-	    remove_proc_entry(part_dir->part_erasing_size->name, part_root);
-	    remove_proc_entry(part_dir->part_free_blocks->name, part_root);
-	    remove_proc_entry(part_dir->part_erasing_blocks->name, part_root);
-	    remove_proc_entry(part_dir->part_gcing_blocks->name, part_root);
-	    remove_proc_entry(part_dir->part_bad_blocks->name, part_root);
-	    remove_proc_entry(part_dir->part_cont_gc_count->name, part_root);
-	    remove_proc_entry(part_dir->part_reserved_blocks_write->name, part_root);
-	    remove_proc_entry(part_dir->part_reserved_blocks_root->name, part_root);
-	    remove_proc_entry(part_dir->part_reserved_blocks_bad->name, part_root);
-	    remove_proc_entry(part_dir->part_reliable_free_size->name, part_root);
-	    remove_proc_entry(part_dir->part_reliable_free_blocks->name, part_root);
-	    remove_proc_entry(part_dir->part_nonerasing_dirty_size->name, part_root);
-	    remove_proc_entry(part_dir->part_effective_gc_count->name, part_root);
-	    remove_proc_entry(part_dir->part_dump_block_lists->name, part_root);
-	    remove_proc_entry(part_dir->part_nodemerge->name, part_root);
-	    remove_proc_entry(part_root->name, jffs2_proc_root);
-
-	    /* Remove entry from list */
-	    if (prev_part_dir)
-		prev_part_dir->next = part_dir->next;
-	    else
-		jffs2_part_dirs = part_dir->next;
-
-	    /* Free memory for entry */
-	    kfree(part_dir);
-
-	    /* Return happy */
-	    return 0;
-	}
-
-	/* Move to next entry */
-	prev_part_dir = part_dir;
-	part_dir = part_dir->next;
-    }
-
-    /* Return unhappy */
-    return -1;
-}
-
-
-static int
-jffs2_proc_partition_size_read(char *page, char **start, off_t off,
-			       int count, int *eof, void *data)
-{
-    struct jffs2_sb_info *c = (struct jffs2_sb_info *) data;
-    int len = sprintf(page, "%u\n", c->flash_size);
-    *eof = 1;
-    return len;
-}
-
-
-static int
-jffs2_proc_sector_size_read(char *page, char **start, off_t off,
-			    int count, int *eof, void *data)
-{
-    struct jffs2_sb_info *c = (struct jffs2_sb_info *) data;
-    int len = sprintf(page, "%u\n", c->sector_size);
-    *eof = 1;
-    return len;
-}
-
-
-static int
-jffs2_proc_used_size_read(char *page, char **start, off_t off,
-			  int count, int *eof, void *data)
-{
-    struct jffs2_sb_info *c = (struct jffs2_sb_info *) data;
-    int len = sprintf(page, "%u\n", c->used_size);
-    *eof = 1;
-    return len;
-}
-
-
-static int
-jffs2_proc_dirty_size_read(char *page, char **start, off_t off,
-			   int count, int *eof, void *data)
-{
-    struct jffs2_sb_info *c = (struct jffs2_sb_info *) data;
-    int len = sprintf(page, "%u\n", c->dirty_size);
-    *eof = 1;
-    return len;
-}
-
-
-static int
-jffs2_proc_free_size_read(char *page, char **start, off_t off,
-			  int count, int *eof, void *data)
-{
-    struct jffs2_sb_info *c = (struct jffs2_sb_info *) data;
-    int len = sprintf(page, "%u\n", c->free_size);
-    *eof = 1;
-    return len;
-}
-
-
-static int
-jffs2_proc_wasted_size_read(char *page, char **start, off_t off,
-			    int count, int *eof, void *data)
-{
-    struct jffs2_sb_info *c = (struct jffs2_sb_info *) data;
-    int len = sprintf(page, "%u\n", c->wasted_size);
-    *eof = 1;
-    return len;
-}
-
-
-static int
-jffs2_proc_erasing_size_read(char *page, char **start, off_t off,
-			     int count, int *eof, void *data)
-{
-    struct jffs2_sb_info *c = (struct jffs2_sb_info *) data;
-    int len = sprintf(page, "%u\n", c->erasing_size);
-    *eof = 1;
-    return len;
-}
-
-
-static int
-jffs2_proc_free_blocks_read(char *page, char **start, off_t off,
-			    int count, int *eof, void *data)
-{
-    struct jffs2_sb_info *c = (struct jffs2_sb_info *) data;
-    int len = sprintf(page, "%u\n", c->nr_free_blocks);
-    *eof = 1;
-    return len;
-}
-
-
-static int
-jffs2_proc_erasing_blocks_read(char *page, char **start, off_t off,
-			       int count, int *eof, void *data)
-{
-    struct jffs2_sb_info *c = (struct jffs2_sb_info *) data;
-    int len = sprintf(page, "%u\n", c->nr_erasing_blocks);
-    *eof = 1;
-    return len;
-}
-
-
-static int
-jffs2_proc_gcing_blocks_read(char *page, char **start, off_t off,
-			       int count, int *eof, void *data)
-{
-    struct jffs2_sb_info *c = (struct jffs2_sb_info *) data;
-    int len;
-    int gcing_blocks, very_dirty_blocks, nodemerge_dirty_blocks;
-
-    if (down_interruptible(&c->alloc_sem)){
-	len = sprintf(page, "%u\n", 0);
-	*eof = 1;
-	return len;
-    }
-    spin_lock_bh(&c->erase_completion_lock);
-
-    if (list_empty(&c->very_dirty_list)) {
-	very_dirty_blocks = 0;
-    } else {
-	struct list_head *this;
-	int	numblocks = 0;
-
-	list_for_each(this, &c->very_dirty_list) {
-	    struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
-	    numblocks ++;
-	}
-	very_dirty_blocks = numblocks;
-    }
-
-    if (list_empty(&c->nodemerge_list)) {
-	nodemerge_dirty_blocks = 0;
-    } else {
-	struct list_head *this;
-	int	numblocks = 0;
-
-	list_for_each(this, &c->nodemerge_list) {
-	    struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
-	    if (ISDIRTY(jeb->dirty_size)) {
-		numblocks ++;
-	    }
-	}
-	nodemerge_dirty_blocks = numblocks;
-    }
-
-    spin_unlock_bh(&c->erase_completion_lock);
-    up(&c->alloc_sem);
-
-    gcing_blocks = very_dirty_blocks + nodemerge_dirty_blocks;
-
-    len = sprintf(page, "%u\n", gcing_blocks);
-    *eof = 1;
-    return len;
-}
-
-
-static int
-jffs2_proc_bad_blocks_read(char *page, char **start, off_t off,
-			   int count, int *eof, void *data)
-{
-    struct jffs2_sb_info *c = (struct jffs2_sb_info *) data;
-    int len = sprintf(page, "%u\n", c->nr_bad_blocks);
-    *eof = 1;
-    return len;
-}
-
-
-static int
-jffs2_proc_cont_gc_count_read(char *page, char **start, off_t off,
-			      int count, int *eof, void *data)
-{
-    struct jffs2_sb_info *c = (struct jffs2_sb_info *) data;
-    int len = sprintf(page, "%u\n", c->cont_gc_count);
-    *eof = 1;
-    return len;
-}
-
-
-static int
-jffs2_proc_reserved_blocks_write_read(char *page, char **start, off_t off,
-				      int count, int *eof, void *data)
-{
-    int len = sprintf(page, "%d\n", JFFS2_RESERVED_BLOCKS_WRITE);
-    *eof = 1;
-    return len;
-}
-
-
-static int
-jffs2_proc_reserved_blocks_root_read(char *page, char **start, off_t off,
-				     int count, int *eof, void *data)
-{
-    int len = sprintf(page, "%d\n", JFFS2_RESERVED_BLOCKS_ROOT);
-    *eof = 1;
-    return len;
-}
-
-
-static int
-jffs2_proc_reserved_blocks_bad_read(char *page, char **start, off_t off,
-				    int count, int *eof, void *data)
-{
-    int len = sprintf(page, "%d\n", JFFS2_RESERVED_BLOCKS_BAD);
-    *eof = 1;
-    return len;
-}
-
-
-static int
-jffs2_proc_reliable_free_size_read(char *page, char **start, off_t off,
-				    int count, int *eof, void *data)
-{
-    struct jffs2_sb_info *c = (struct jffs2_sb_info *) data;
-    int len;
-    unsigned long avail;
-    uint32_t next_free;
-    int32_t avail_blocks;
-    int reserved_blocks = JFFS2_RESERVED_BLOCKS_WRITE + JFFS2_RESERVED_BLOCKS_ROOT;
-
-    spin_lock_bh(&c->erase_completion_lock);
-
-    avail_blocks = NR_AVAIL_BLOCKS(c);
-    next_free = (c->nextblock) ? (c->nextblock->free_size) : 0;
-
-    if (avail_blocks >= reserved_blocks){
-	avail = avail_blocks * c->sector_size + next_free - reserved_blocks * c->sector_size;
-    }else{
-	avail = 0;
-    }
-
-    spin_unlock_bh(&c->erase_completion_lock);
-
-    len = sprintf(page, "%lu\n", avail);
-    *eof = 1;
-    return len;
-}
-
-
-static int
-jffs2_proc_reliable_free_blocks_read(char *page, char **start, off_t off,
-				    int count, int *eof, void *data)
-{
-    struct jffs2_sb_info *c = (struct jffs2_sb_info *) data;
-    int len;
-    unsigned long avail;
-    int32_t avail_blocks;
-    int reserved_blocks = JFFS2_RESERVED_BLOCKS_WRITE + JFFS2_RESERVED_BLOCKS_ROOT;
-
-    avail_blocks = NR_AVAIL_BLOCKS(c);
-    if (avail_blocks >= reserved_blocks){
-	avail = avail_blocks - reserved_blocks;
-    }else{
-	avail = 0;
-    }
-
-    len = sprintf(page, "%lu\n", avail);
-    *eof = 1;
-    return len;
-}
-
-
-static int
-jffs2_proc_nonerasing_dirty_size_read(char *page, char **start, off_t off,
-				   int count, int *eof, void *data)
-{
-    struct jffs2_sb_info *c = (struct jffs2_sb_info *) data;
-    int len;
-    uint32_t dirty_now, erasing_dirty_now, nonerasing_dirty_now;
-
-    spin_lock_bh(&c->erase_completion_lock);
-
-    dirty_now = c->dirty_size;
-    erasing_dirty_now = c->erasing_dirty_size;
-    if (dirty_now < erasing_dirty_now)
-	erasing_dirty_now = dirty_now;
-    nonerasing_dirty_now = dirty_now - erasing_dirty_now;
-
-    spin_unlock_bh(&c->erase_completion_lock);
-
-    len = sprintf(page, "%lu\n", nonerasing_dirty_now);
-    *eof = 1;
-    return len;
-}
-
-
-static int
-jffs2_proc_effective_gc_count_read(char *page, char **start, off_t off,
-				   int count, int *eof, void *data)
-{
-    struct jffs2_sb_info *c = (struct jffs2_sb_info *) data;
-    int len = sprintf(page, "%u\n", c->effective_gc_count);
-    *eof = 1;
-    return len;
-}
-
-
-static int
-jffs2_proc_dump_block_lists_read(char *page, char **start, off_t off,
-				   int count, int *eof, void *data)
-{
-    struct jffs2_sb_info *c = (struct jffs2_sb_info *) data;
-    int len = 0, tlen;
-
-    if (down_interruptible(&c->alloc_sem)){
-	len = sprintf(page, "down(alloc_sem) failed.\n");
-	*eof = 1;
-	return len;
-    }
-    spin_lock_bh(&c->erase_completion_lock);
-
-    if (list_empty(&c->clean_list)) {
-	tlen = sprintf(page + len, "clean_list: blocks=(0)\n");
-	len += tlen;
-    } else {
-	struct list_head *this;
-	int	numblocks = 0;
-	unsigned long dirty = 0;
-
-	list_for_each(this, &c->clean_list) {
-	    struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
-	    numblocks ++;
-	    dirty += jeb->dirty_size;
-	}
-	tlen = sprintf(page + len, "clean_list: blocks=(%d) dirty=(%lu,%lu)\n", numblocks, dirty, dirty / numblocks);
-	len += tlen;
-    }
-
-    if (list_empty(&c->very_dirty_list)) {
-	tlen = sprintf(page + len, "very_dirty_list: blocks=(0)\n");
-	len += tlen;
-    } else {
-	struct list_head *this;
-	int	numblocks = 0;
-	unsigned long dirty = 0;
-
-	list_for_each(this, &c->very_dirty_list) {
-	    struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
-	    numblocks ++;
-	    dirty += jeb->dirty_size;
-	}
-	tlen = sprintf(page + len, "very_dirty_list: blocks=(%d) dirty=(%lu,%lu)\n", numblocks, dirty, dirty / numblocks);
-	len += tlen;
-    }
-
-    if (list_empty(&c->dirty_list)) {
-	tlen = sprintf(page + len, "dirty_list: blocks=(0)\n");
-	len += tlen;
-    } else {
-	struct list_head *this;
-	int	numblocks0 = 0, numblocks1 = 0, numblocks2 = 0, numblocks3 = 0;
-	unsigned long dirty0 = 0, dirty1 = 0, dirty2 = 0, dirty3 = 0;
-
-	list_for_each(this, &c->dirty_list) {
-	    struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
-	    if(jeb->dirty_size >= GC_EFFECTIVE_BLOCK_DIRTY_SIZE_LL){
-		numblocks3 ++;
-		dirty3 += jeb->dirty_size;
-	    }else if(jeb->dirty_size >= GC_EFFECTIVE_BLOCK_DIRTY_SIZE_L){
-		numblocks2 ++;
-		dirty2 += jeb->dirty_size;
-	    }else if(jeb->dirty_size >= GC_EFFECTIVE_BLOCK_DIRTY_SIZE){
-		numblocks1 ++;
-		dirty1 += jeb->dirty_size;
-	    }else{
-		numblocks0 ++;
-		dirty0 += jeb->dirty_size;
-	    }
-	}
-	tlen = sprintf(page + len, "dirty_list: blocks=(%d) dirty=(%lu,%lu)\n",
-		       numblocks0 + numblocks1 + numblocks2 + numblocks3,
-		       dirty0 + dirty1 + dirty2 + dirty3,
-		       (dirty0 + dirty1 + dirty2 + dirty3) / (numblocks0 + numblocks1 + numblocks2 + numblocks3));
-	len += tlen;
-	tlen = sprintf(page + len, "dirty_list[3]: blocks=(%d) dirty=(%lu,%lu)\n", numblocks3, dirty3,
-		       (numblocks3 == 0) ? 0 : (dirty3 / numblocks3));
-	len += tlen;
-	tlen = sprintf(page + len, "dirty_list[2]: blocks=(%d) dirty=(%lu,%lu)\n", numblocks2, dirty2,
-		       (numblocks2 == 0) ? 0 : (dirty2 / numblocks2));
-	len += tlen;
-	tlen = sprintf(page + len, "dirty_list[1]: blocks=(%d) dirty=(%lu,%lu)\n", numblocks1, dirty1,
-		       (numblocks1 == 0) ? 0 : (dirty1 / numblocks1));
-	len += tlen;
-	tlen = sprintf(page + len, "dirty_list[0]: blocks=(%d) dirty=(%lu,%lu)\n", numblocks0, dirty0,
-		       (numblocks0 == 0) ? 0 : (dirty0 / numblocks0));
-	len += tlen;
-    }
-
-    if (list_empty(&c->nodemerge_list)) {
-	tlen = sprintf(page + len, "nodemerge_list: blocks=(0)\n");
-	len += tlen;
-    } else {
-	struct list_head *this;
-	int	numblocks = 0;
-	unsigned long dirty = 0;
-
-	list_for_each(this, &c->nodemerge_list) {
-	    struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
-	    numblocks ++;
-	    dirty += jeb->dirty_size;
-	}
-	tlen = sprintf(page + len, "nodemerge_list: blocks=(%d) dirty=(%lu,%lu)\n", numblocks, dirty, dirty / numblocks);
-	len += tlen;
-    }
-
-    spin_unlock_bh(&c->erase_completion_lock);
-    up(&c->alloc_sem);
-
-    *eof = 1;
-    return len;
-}
-
-
-static unsigned long
-atoul(const char* p)
-{
-    unsigned long n = 0;
-
-    while (p && ! isdigit(*p))
-	p++;
-    while (p && isdigit(*p)) {
-	n = n * 10 + *p - '0';
-	p++;
-    }
-    return n;
-}
-
-
-static int
-jffs2_proc_nodemerge_write(struct file *file, const char *buffer, unsigned long count,
-			   void *data)
-{
-    extern void jffs2_shrink_inode(struct inode *);
-
-    struct jffs2_sb_info *c = (struct jffs2_sb_info *)data;
-    char str[16];
-    unsigned long ino = 0;
-    unsigned long len = (sizeof str < count) ? sizeof str : count;
-    struct inode *inode;
-    struct jffs2_inode_info *f;
-
-    memset(str, '\0', sizeof str);
-    if (copy_from_user(str, buffer, len))
-	return -EFAULT;
-
-    ino = atoul(str);
-    printk(KERN_DEBUG "nodemerge: start ino=%d\n", ino);
-    if (ino > c->highest_ino)
-	return -EINVAL;
-
-    inode = iget(OFNI_BS_2SFFJ(c), ino);
-    if (is_bad_inode(inode)) {
-	printk(KERN_NOTICE "iget() failed\n");
-	iput(inode);
-	return -EIO;
-    }
-
-    f = JFFS2_INODE_INFO(inode);
-    if (down_interruptible(&f->sem)) {
-	printk(KERN_NOTICE "nodemerge: down_interruptible failed\n");
-	iput(inode);
-	return -ERESTARTSYS;
-    }
-    jffs2_construct_fragtree_nolock_if_missing(c, f);
-    jffs2_merge_nodes(c, f, inode->i_size, JFFS2_FRAGS_NR_NODES_THRESHOLD_FORCE);
-    up(&f->sem);
-
-    iput(inode);
-
-    printk(KERN_DEBUG "nodemerge: end ino=%d\n", ino);
-    return count;
-}
diff -Nur linux/fs/jffs2/jffs2_proc.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/jffs2_proc.h
--- linux/fs/jffs2/jffs2_proc.h	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/jffs2_proc.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,37 +0,0 @@
-/*
- * fs/jffs2/jffs2_proc.h
- *
- * Copyright (C) 2002 Lineo Japan, Inc.
- *
- * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.
- *
- * $Id: jffs2_proc.h,v 1.1.1.1 2002/12/19 01:52:04 yamade Exp $
- *
- * Derived from fs/jffs/jffs_proc.h
- *
- * JFFS -- Journaling Flash File System, Linux implementation.
- *
- * Copyright (C) 2000  Axis Communications AB.
- *
- * Created by Simon Kagstrom <simonk@axis.com>.
- *
- * This is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-/* jffs2_proc.h defines a structure for inclusion in the proc-file system.  */
-#ifndef __LINUX_JFFS2_PROC_H__
-#define __LINUX_JFFS2_PROC_H__
-
-#include <linux/proc_fs.h>
-
-/* The proc_dir_entry for jffs2 (defined in jffs2_proc.c).  */
-extern struct proc_dir_entry *jffs2_proc_root;
-
-int jffs2_register_jffs2_proc_dir(kdev_t dev, struct jffs2_sb_info *c);
-int jffs2_unregister_jffs2_proc_dir(struct jffs2_sb_info *c);
-
-#endif /* __LINUX_JFFS2_PROC_H__ */
diff -Nur linux/fs/jffs2/malloc.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/malloc.c
--- linux/fs/jffs2/malloc.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/malloc.c	2003-06-23 01:47:04.000000000 +0700
@@ -1,13 +1,37 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
+ * Copyright (C) 2001 Red Hat, Inc.
  *
  * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: malloc.c,v 1.22 2002/05/20 14:56:38 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: malloc.c,v 1.16 2001/03/15 15:38:24 dwmw2 Exp $
  *
  */
 
@@ -33,47 +57,57 @@
 static kmem_cache_t *node_frag_slab;
 static kmem_cache_t *inode_cache_slab;
 
+void jffs2_free_tmp_dnode_info_list(struct jffs2_tmp_dnode_info *tn)
+{
+	struct jffs2_tmp_dnode_info *next;
+
+	while (tn) {
+		next = tn;
+		tn = tn->next;
+		jffs2_free_full_dnode(next->fn);
+		jffs2_free_tmp_dnode_info(next);
+	}
+}
+
+void jffs2_free_full_dirent_list(struct jffs2_full_dirent *fd)
+{
+	struct jffs2_full_dirent *next;
+
+	while (fd) {
+		next = fd->next;
+		jffs2_free_full_dirent(fd);
+		fd = next;
+	}
+}
+
 int __init jffs2_create_slab_caches(void)
 {
-	full_dnode_slab = kmem_cache_create("jffs2_full_dnode", 
-					    sizeof(struct jffs2_full_dnode),
-					    0, JFFS2_SLAB_POISON, NULL, NULL);
+	full_dnode_slab = kmem_cache_create("jffs2_full_dnode", sizeof(struct jffs2_full_dnode), 0, JFFS2_SLAB_POISON, NULL, NULL);
 	if (!full_dnode_slab)
 		goto err;
 
-	raw_dirent_slab = kmem_cache_create("jffs2_raw_dirent",
-					    sizeof(struct jffs2_raw_dirent),
-					    0, JFFS2_SLAB_POISON, NULL, NULL);
+	raw_dirent_slab = kmem_cache_create("jffs2_raw_dirent", sizeof(struct jffs2_raw_dirent), 0, JFFS2_SLAB_POISON, NULL, NULL);
 	if (!raw_dirent_slab)
 		goto err;
 
-	raw_inode_slab = kmem_cache_create("jffs2_raw_inode",
-					   sizeof(struct jffs2_raw_inode),
-					   0, JFFS2_SLAB_POISON, NULL, NULL);
+	raw_inode_slab = kmem_cache_create("jffs2_raw_inode", sizeof(struct jffs2_raw_inode), 0, JFFS2_SLAB_POISON, NULL, NULL);
 	if (!raw_inode_slab)
 		goto err;
 
-	tmp_dnode_info_slab = kmem_cache_create("jffs2_tmp_dnode",
-						sizeof(struct jffs2_tmp_dnode_info),
-						0, JFFS2_SLAB_POISON, NULL, NULL);
+	tmp_dnode_info_slab = kmem_cache_create("jffs2_tmp_dnode", sizeof(struct jffs2_tmp_dnode_info), 0, JFFS2_SLAB_POISON, NULL, NULL);
 	if (!tmp_dnode_info_slab)
 		goto err;
 
-	raw_node_ref_slab = kmem_cache_create("jffs2_raw_node_ref",
-					      sizeof(struct jffs2_raw_node_ref),
-					      0, JFFS2_SLAB_POISON, NULL, NULL);
+	raw_node_ref_slab = kmem_cache_create("jffs2_raw_node_ref", sizeof(struct jffs2_raw_node_ref), 0, JFFS2_SLAB_POISON, NULL, NULL);
 	if (!raw_node_ref_slab)
 		goto err;
 
-	node_frag_slab = kmem_cache_create("jffs2_node_frag",
-					   sizeof(struct jffs2_node_frag),
-					   0, JFFS2_SLAB_POISON, NULL, NULL);
+	node_frag_slab = kmem_cache_create("jffs2_node_frag", sizeof(struct jffs2_node_frag), 0, JFFS2_SLAB_POISON, NULL, NULL);
 	if (!node_frag_slab)
 		goto err;
 
-	inode_cache_slab = kmem_cache_create("jffs2_inode_cache",
-					     sizeof(struct jffs2_inode_cache),
-					     0, JFFS2_SLAB_POISON, NULL, NULL);
+	inode_cache_slab = kmem_cache_create("jffs2_inode_cache", sizeof(struct jffs2_inode_cache), 0, JFFS2_SLAB_POISON, NULL, NULL);
+
 	if (inode_cache_slab)
 		return 0;
  err:
@@ -97,6 +131,7 @@
 		kmem_cache_destroy(node_frag_slab);
 	if(inode_cache_slab)
 		kmem_cache_destroy(inode_cache_slab);
+
 }
 
 struct jffs2_full_dirent *jffs2_alloc_full_dirent(int namesize)
diff -Nur linux/fs/jffs2/nodelist.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/nodelist.c
--- linux/fs/jffs2/nodelist.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/nodelist.c	2003-06-23 01:47:04.000000000 +0700
@@ -5,22 +5,40 @@
  *
  * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: nodelist.c,v 1.61 2002/09/06 16:46:29 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
  *
- * ChangeLog:
- *     19-Nov-2002 Lineo Japan, Inc.  add function jffs2_shrink_inode()
- *				      add counter of fragtree elements
- *     18-Nov-2002 Lineo Japan, Inc.  add dynamic construction of fragtree
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: nodelist.c,v 1.30.2.4 2002/05/10 18:30:33 dwmw2 Exp $
  *
  */
 
 #include <linux/kernel.h>
+#include <linux/jffs2.h>
 #include <linux/fs.h>
 #include <linux/mtd/mtd.h>
-#include <linux/interrupt.h>
-#include <linux/rbtree.h>
 #include "nodelist.h"
 
 void jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list)
@@ -71,37 +89,13 @@
         *prev = tn;
 }
 
-static void jffs2_free_tmp_dnode_info_list(struct jffs2_tmp_dnode_info *tn)
-{
-	struct jffs2_tmp_dnode_info *next;
-
-	while (tn) {
-		next = tn;
-		tn = tn->next;
-		jffs2_free_full_dnode(next->fn);
-		jffs2_free_tmp_dnode_info(next);
-	}
-}
-
-static void jffs2_free_full_dirent_list(struct jffs2_full_dirent *fd)
-{
-	struct jffs2_full_dirent *next;
-
-	while (fd) {
-		next = fd->next;
-		jffs2_free_full_dirent(fd);
-		fd = next;
-	}
-}
-
-
 /* Get tmp_dnode_info and full_dirent for all non-obsolete nodes associated
    with this ino, returning the former in order of version */
 
 int jffs2_get_inode_nodes(struct jffs2_sb_info *c, ino_t ino, struct jffs2_inode_info *f,
 			  struct jffs2_tmp_dnode_info **tnp, struct jffs2_full_dirent **fdp,
-			  uint32_t *highest_version, uint32_t *latest_mctime,
-			  uint32_t *mctime_ver)
+			  __u32 *highest_version, __u32 *latest_mctime,
+			  __u32 *mctime_ver)
 {
 	struct jffs2_raw_node_ref *ref = f->inocache->nodes;
 	struct jffs2_tmp_dnode_info *tn, *ret_tn = NULL;
@@ -117,24 +111,16 @@
 	if (!f->inocache->nodes) {
 		printk(KERN_WARNING "Eep. no nodes for ino #%lu\n", ino);
 	}
-
-	spin_lock_bh(&c->erase_completion_lock);
-
 	for (ref = f->inocache->nodes; ref && ref->next_in_ino; ref = ref->next_in_ino) {
 		/* Work out whether it's a data node or a dirent node */
-		if (ref_obsolete(ref)) {
+		if (ref->flash_offset & 1) {
 			/* FIXME: On NAND flash we may need to read these */
-			D1(printk(KERN_DEBUG "node at 0x%08x is obsoleted. Ignoring.\n", ref_offset(ref)));
+			D1(printk(KERN_DEBUG "node at 0x%08x is obsoleted. Ignoring.\n", ref->flash_offset &~3));
 			continue;
 		}
-		/* We can hold a pointer to a non-obsolete node without the spinlock,
-		   but _obsolete_ nodes may disappear at any time, if the block
-		   they're in gets erased */
-		spin_unlock_bh(&c->erase_completion_lock);
-
-		err = jffs2_flash_read(c, (ref_offset(ref)), min(ref->totlen, sizeof(node)), &retlen, (void *)&node);
+		err = c->mtd->read(c->mtd, (ref->flash_offset & ~3), min(ref->totlen, sizeof(node)), &retlen, (void *)&node);
 		if (err) {
-			printk(KERN_WARNING "error %d reading node at 0x%08x in get_inode_nodes()\n", err, ref_offset(ref));
+			printk(KERN_WARNING "error %d reading node at 0x%08x in get_inode_nodes()\n", err, (ref->flash_offset) & ~3);
 			goto free_out;
 		}
 			
@@ -146,21 +132,19 @@
 			goto free_out;
 		}
 			
-		switch (je16_to_cpu(node.u.nodetype)) {
+		switch (node.u.nodetype) {
 		case JFFS2_NODETYPE_DIRENT:
-			D1(printk(KERN_DEBUG "Node at %08x is a dirent node\n", ref_offset(ref)));
+			D1(printk(KERN_DEBUG "Node at %08x is a dirent node\n", ref->flash_offset &~3));
 			if (retlen < sizeof(node.d)) {
 				printk(KERN_WARNING "short read in get_inode_nodes()\n");
 				err = -EIO;
 				goto free_out;
 			}
-			if (je32_to_cpu(node.d.version) > *highest_version)
-				*highest_version = je32_to_cpu(node.d.version);
-			if (ref_obsolete(ref)) {
-				/* Obsoleted. This cannot happen, surely? dwmw2 20020308 */
-				printk(KERN_ERR "Dirent node at 0x%08x became obsolete while we weren't looking\n",
-				       ref_offset(ref));
-				BUG();
+			if (node.d.version > *highest_version)
+				*highest_version = node.d.version;
+			if (ref->flash_offset & 1) {
+				/* Obsoleted */
+				continue;
 			}
 			fd = jffs2_alloc_full_dirent(node.d.nsize+1);
 			if (!fd) {
@@ -169,21 +153,21 @@
 			}
 			memset(fd,0,sizeof(struct jffs2_full_dirent) + node.d.nsize+1);
 			fd->raw = ref;
-			fd->version = je32_to_cpu(node.d.version);
-			fd->ino = je32_to_cpu(node.d.ino);
+			fd->version = node.d.version;
+			fd->ino = node.d.ino;
 			fd->type = node.d.type;
 
 			/* Pick out the mctime of the latest dirent */
 			if(fd->version > *mctime_ver) {
 				*mctime_ver = fd->version;
-				*latest_mctime = je32_to_cpu(node.d.mctime);
+				*latest_mctime = node.d.mctime;
 			}
 
 			/* memcpy as much of the name as possible from the raw
 			   dirent we've already read from the flash
 			*/
 			if (retlen > sizeof(struct jffs2_raw_dirent))
-				memcpy(&fd->name[0], &node.d.name[0], min((uint32_t)node.d.nsize, (retlen-sizeof(struct jffs2_raw_dirent))));
+				memcpy(&fd->name[0], &node.d.name[0], min((__u32)node.d.nsize, (retlen-sizeof(struct jffs2_raw_dirent))));
 				
 			/* Do we need to copy any more of the name directly
 			   from the flash?
@@ -191,7 +175,7 @@
 			if (node.d.nsize + sizeof(struct jffs2_raw_dirent) > retlen) {
 				int already = retlen - sizeof(struct jffs2_raw_dirent);
 					
-				err = jffs2_flash_read(c, (ref_offset(ref)) + retlen, 
+				err = c->mtd->read(c->mtd, (ref->flash_offset & ~3) + retlen, 
 						   node.d.nsize - already, &retlen, &fd->name[already]);
 				if (!err && retlen != node.d.nsize - already)
 					err = -EIO;
@@ -212,21 +196,20 @@
 			break;
 
 		case JFFS2_NODETYPE_INODE:
-			D1(printk(KERN_DEBUG "Node at %08x is a data node\n", ref_offset(ref)));
+			D1(printk(KERN_DEBUG "Node at %08x is a data node\n", ref->flash_offset &~3));
 			if (retlen < sizeof(node.i)) {
 				printk(KERN_WARNING "read too short for dnode\n");
 				err = -EIO;
 				goto free_out;
 			}
-			if (je32_to_cpu(node.i.version) > *highest_version)
-				*highest_version = je32_to_cpu(node.i.version);
-			D1(printk(KERN_DEBUG "version %d, highest_version now %d\n", je32_to_cpu(node.i.version), *highest_version));
-
-			if (ref_obsolete(ref)) {
-				/* Obsoleted. This cannot happen, surely? dwmw2 20020308 */
-				printk(KERN_ERR "Inode node at 0x%08x became obsolete while we weren't looking\n",
-				       ref_offset(ref));
-				BUG();
+			if (node.d.version > *highest_version)
+				*highest_version = node.i.version;
+			D1(printk(KERN_DEBUG "version %d, highest_version now %d\n", node.d.version, *highest_version));
+
+			if (ref->flash_offset & 1) {
+				D1(printk(KERN_DEBUG "obsoleted\n"));
+				/* Obsoleted */
+				continue;
 			}
 			tn = jffs2_alloc_tmp_dnode_info();
 			if (!tn) {
@@ -242,41 +225,36 @@
 				jffs2_free_tmp_dnode_info(tn);
 				goto free_out;
 			}
-			tn->version = je32_to_cpu(node.i.version);
-			tn->fn->ofs = je32_to_cpu(node.i.offset);
+			tn->version = node.i.version;
+			tn->fn->ofs = node.i.offset;
 			/* There was a bug where we wrote hole nodes out with
 			   csize/dsize swapped. Deal with it */
-			if (node.i.compr == JFFS2_COMPR_ZERO && !je32_to_cpu(node.i.dsize) && je32_to_cpu(node.i.csize))
-				tn->fn->size = je32_to_cpu(node.i.csize);
+			if (node.i.compr == JFFS2_COMPR_ZERO && !node.i.dsize && node.i.csize)
+				tn->fn->size = node.i.csize;
 			else // normal case...
-				tn->fn->size = je32_to_cpu(node.i.dsize);
+				tn->fn->size = node.i.dsize;
 			tn->fn->raw = ref;
-			D1(printk(KERN_DEBUG "dnode @%08x: ver %u, offset %04x, dsize %04x\n",
-				  ref_offset(ref), je32_to_cpu(node.i.version),
-				  je32_to_cpu(node.i.offset), je32_to_cpu(node.i.dsize)));
+			D1(printk(KERN_DEBUG "dnode @%08x: ver %u, offset %04x, dsize %04x\n", ref->flash_offset &~3, node.i.version, node.i.offset, node.i.dsize));
 			jffs2_add_tn_to_list(tn, &ret_tn);
 			break;
 
 		default:
-			switch(je16_to_cpu(node.u.nodetype) & JFFS2_COMPAT_MASK) {
+			switch(node.u.nodetype & JFFS2_COMPAT_MASK) {
 			case JFFS2_FEATURE_INCOMPAT:
-				printk(KERN_NOTICE "Unknown INCOMPAT nodetype %04X at %08X\n", je16_to_cpu(node.u.nodetype), ref_offset(ref));
+				printk(KERN_NOTICE "Unknown INCOMPAT nodetype %04X at %08X\n", node.u.nodetype, ref->flash_offset & ~3);
 				break;
 			case JFFS2_FEATURE_ROCOMPAT:
-				printk(KERN_NOTICE "Unknown ROCOMPAT nodetype %04X at %08X\n", je16_to_cpu(node.u.nodetype), ref_offset(ref));
+				printk(KERN_NOTICE "Unknown ROCOMPAT nodetype %04X at %08X\n", node.u.nodetype, ref->flash_offset & ~3);
 				break;
 			case JFFS2_FEATURE_RWCOMPAT_COPY:
-				printk(KERN_NOTICE "Unknown RWCOMPAT_COPY nodetype %04X at %08X\n", je16_to_cpu(node.u.nodetype), ref_offset(ref));
+				printk(KERN_NOTICE "Unknown RWCOMPAT_COPY nodetype %04X at %08X\n", node.u.nodetype, ref->flash_offset & ~3);
 				break;
 			case JFFS2_FEATURE_RWCOMPAT_DELETE:
-				printk(KERN_NOTICE "Unknown RWCOMPAT_DELETE nodetype %04X at %08X\n", je16_to_cpu(node.u.nodetype), ref_offset(ref));
+				printk(KERN_NOTICE "Unknown RWCOMPAT_DELETE nodetype %04X at %08X\n", node.u.nodetype, ref->flash_offset & ~3);
 				break;
 			}
 		}
-		spin_lock_bh(&c->erase_completion_lock);
-
 	}
-	spin_unlock_bh(&c->erase_completion_lock);
 	*tnp = ret_tn;
 	*fdp = ret_fd;
 
@@ -294,17 +272,16 @@
 
 	D2(printk(KERN_DEBUG "jffs2_get_ino_cache(): ino %u\n", ino));
 	spin_lock (&c->inocache_lock);
-
 	ret = c->inocache_list[ino % INOCACHE_HASHSIZE];
 	while (ret && ret->ino < ino) {
 		ret = ret->next;
 	}
-	
-	if (ret && ret->ino != ino)
-		ret = NULL;
 
 	spin_unlock(&c->inocache_lock);
 
+	if (ret && ret->ino != ino)
+		ret = NULL;
+
 	D2(printk(KERN_DEBUG "jffs2_get_ino_cache found %p for ino %u\n", ret, ino));
 	return ret;
 }
@@ -322,7 +299,6 @@
 	}
 	new->next = *prev;
 	*prev = new;
-
 	spin_unlock(&c->inocache_lock);
 }
 
@@ -340,7 +316,6 @@
 	if ((*prev) == old) {
 		*prev = old->next;
 	}
-
 	spin_unlock(&c->inocache_lock);
 }
 
@@ -377,271 +352,3 @@
 	}
 }
 	
-struct jffs2_node_frag *jffs2_lookup_node_frag(rb_root_t *fragtree, uint32_t offset)
-{
-	/* The common case in lookup is that there will be a node 
-	   which precisely matches. So we go looking for that first */
-	rb_node_t *next;
-	struct jffs2_node_frag *prev = NULL;
-	struct jffs2_node_frag *frag = NULL;
-
-	D2(printk(KERN_DEBUG "jffs2_lookup_node_frag(%p, %d)\n", fragtree, offset));
-
-	next = fragtree->rb_node;
-
-	while(next) {
-		frag = rb_entry(next, struct jffs2_node_frag, rb);
-
-		D2(printk(KERN_DEBUG "Considering frag %d-%d (%p). left %p, right %p\n",
-			  frag->ofs, frag->ofs+frag->size, frag, frag->rb.rb_left, frag->rb.rb_right));
-		if (frag->ofs + frag->size <= offset) {
-			D2(printk(KERN_DEBUG "Going right from frag %d-%d, before the region we care about\n",
-				  frag->ofs, frag->ofs+frag->size));
-			/* Remember the closest smaller match on the way down */
-			if (!prev || frag->ofs > prev->ofs)
-				prev = frag;
-			next = frag->rb.rb_right;
-		} else if (frag->ofs > offset) {
-			D2(printk(KERN_DEBUG "Going left from frag %d-%d, after the region we care about\n",
-				  frag->ofs, frag->ofs+frag->size));
-			next = frag->rb.rb_left;
-		} else {
-			D2(printk(KERN_DEBUG "Returning frag %d,%d, matched\n",
-				  frag->ofs, frag->ofs+frag->size));
-			return frag;
-		}
-	}
-
-	/* Exact match not found. Go back up looking at each parent,
-	   and return the closest smaller one */
-
-	if (prev)
-		D2(printk(KERN_DEBUG "No match. Returning frag %d,%d, closest previous\n",
-			  prev->ofs, prev->ofs+prev->size));
-	else 
-		D2(printk(KERN_DEBUG "Returning NULL, empty fragtree\n"));
-	
-	return prev;
-}
-
-/* Pass 'c' argument to indicate that nodes should be marked obsolete as
-   they're killed. */
-void jffs2_kill_fragtree(rb_root_t *root, struct jffs2_sb_info *c)
-{
-	struct jffs2_node_frag *frag;
-	struct jffs2_node_frag *parent;
-
-	if (!root->rb_node)
-		return;
-
-	frag = (rb_entry(root->rb_node, struct jffs2_node_frag, rb));
-
-	while(frag) {
-		if (frag->rb.rb_left) {
-			D2(printk(KERN_DEBUG "Going left from frag (%p) %d-%d\n", 
-				  frag, frag->ofs, frag->ofs+frag->size));
-			frag = frag_left(frag);
-			continue;
-		}
-		if (frag->rb.rb_right) {
-			D2(printk(KERN_DEBUG "Going right from frag (%p) %d-%d\n", 
-				  frag, frag->ofs, frag->ofs+frag->size));
-			frag = frag_right(frag);
-			continue;
-		}
-
-		D2(printk(KERN_DEBUG "jffs2_kill_fragtree: frag at 0x%x-0x%x: node %p, frags %d--\n",
-			  frag->ofs, frag->ofs+frag->size, frag->node,
-			  frag->node?frag->node->frags:0));
-			
-		if (frag->node && !(--frag->node->frags)) {
-			/* Not a hole, and it's the final remaining frag 
-			   of this node. Free the node */
-			if (c)
-				jffs2_mark_node_obsolete(c, frag->node->raw);
-			
-			jffs2_free_full_dnode(frag->node);
-		}
-		parent = frag_parent(frag);
-		if (parent) {
-			if (frag_left(parent) == frag)
-				parent->rb.rb_left = NULL;
-			else 
-				parent->rb.rb_right = NULL;
-		}
-
-		jffs2_free_node_frag(frag);
-		frag = parent;
-	}
-}
-
-void jffs2_fragtree_insert(struct jffs2_node_frag *newfrag, struct jffs2_node_frag *base)
-{
-	rb_node_t *parent = &base->rb;
-	rb_node_t **link = &parent;
-
-	D2(printk(KERN_DEBUG "jffs2_fragtree_insert(%p; %d-%d, %p)\n", newfrag, 
-		  newfrag->ofs, newfrag->ofs+newfrag->size, base));
-
-	while (*link) {
-		parent = *link;
-		base = rb_entry(parent, struct jffs2_node_frag, rb);
-	
-		D2(printk(KERN_DEBUG "fragtree_insert considering frag at 0x%x\n", base->ofs));
-		if (newfrag->ofs > base->ofs)
-			link = &base->rb.rb_right;
-		else if (newfrag->ofs < base->ofs)
-			link = &base->rb.rb_left;
-		else {
-			printk(KERN_CRIT "Duplicate frag at %08x (%p,%p)\n", newfrag->ofs, newfrag, base);
-			BUG();
-		}
-	}
-
-	rb_link_node(&newfrag->rb, &base->rb, link);
-}
-
-rb_node_t *rb_next(rb_node_t *node)
-{
-	/* If we have a right-hand child, go down and then left as far
-	   as we can. */
-	if (node->rb_right) {
-		node = node->rb_right; 
-		while (node->rb_left)
-			node=node->rb_left;
-		return node;
-	}
-
-	/* No right-hand children.  Everything down and left is
-	   smaller than us, so any 'next' node must be in the general
-	   direction of our parent. Go up the tree; any time the
-	   ancestor is a right-hand child of its parent, keep going
-	   up. First time it's a left-hand child of its parent, said
-	   parent is our 'next' node. */
-	while (node->rb_parent && node == node->rb_parent->rb_right)
-		node = node->rb_parent;
-
-	return node->rb_parent;
-}
-
-rb_node_t *rb_prev(rb_node_t *node)
-{
-	if (node->rb_left) {
-		node = node->rb_left; 
-		while (node->rb_right)
-			node=node->rb_right;
-		return node;
-	}
-	while (node->rb_parent && node == node->rb_parent->rb_left)
-		node = node->rb_parent;
-
-	return node->rb_parent;
-}
-
-void rb_replace_node(rb_node_t *victim, rb_node_t *new, rb_root_t *root)
-{
-	rb_node_t *parent = victim->rb_parent;
-
-	/* Set the surrounding nodes to point to the replacement */
-	if (parent) {
-		if (victim == parent->rb_left)
-			parent->rb_left = new;
-		else
-			parent->rb_right = new;
-	} else {
-		root->rb_node = new;
-	}
-	if (victim->rb_left)
-		victim->rb_left->rb_parent = new;
-	if (victim->rb_right)
-		victim->rb_right->rb_parent = new;
-
-	/* Copy the pointers/colour from the victim to the replacement */
-	*new = *victim;
-}
-
-#ifdef CONFIG_JFFS2_DYNFRAGTREE
-int jffs2_construct_fragtree(struct jffs2_sb_info *c, struct jffs2_inode_info *f)
-{
-	struct jffs2_tmp_dnode_info *tn_list;
-	struct jffs2_full_dirent *dummy_fd_list;
-	uint32_t dummy_mctime, dummy_ver, highest_version;
-	int ret;
-
-	if (! f->inocache) {
-		printk(KERN_WARNING "%s: ino %lu: f->inocache is NULL\n",
-		       __func__, OFNI_EDONI_2SFFJ(f)->i_ino);
-		return -ENOENT;
-	}
-
-	if (frag_first(&f->fragtree)) {
-		printk(KERN_NOTICE "%s: f->fragtree already exists\n", __func__);
-		return 0;
-	}
-
-	highest_version = f->highest_version;
-	ret = jffs2_get_inode_nodes(c, f->inocache->ino, f, &tn_list, &dummy_fd_list,
-				    &highest_version, &dummy_mctime, &dummy_ver);
-	if (ret) {
-		printk(KERN_CRIT "%s for ino %u returned %d\n",
-		       __func__, f->inocache->ino, ret);
-		return ret;
-	}
-
-	if (f->highest_version != highest_version) {
-		printk(KERN_NOTICE "%s: f->highest_version:%u != %u\n",
-		       __func__, f->highest_version, highest_version);
-		f->highest_version = highest_version;
-	}
-
-	if (dummy_fd_list) {
-		printk(KERN_NOTICE "%s for directory ino #%u\n",
-		       __func__, f->inocache->ino);
-		return 0;
-	}
-
-	while (tn_list) {
-		struct jffs2_tmp_dnode_info *tn;
-		struct jffs2_full_dnode *fn;
-
-		tn = tn_list;
-		fn = tn->fn;
-		if (fn->size)
-			jffs2_add_full_dnode_to_inode(c, f, fn);
-		tn_list = tn->next;
-		jffs2_free_tmp_dnode_info(tn);
-	}
-
-	return 0;
-}
-
-void jffs2_shrink_inode(struct inode *inode)
-{
-	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
-
-	if (S_ISREG(inode->i_mode)) {
-		jffs2_kill_fragtree(&f->fragtree, NULL);
-		CLEAR_NR_FRAGS(f);
-		f->fragtree = RB_ROOT;
-	}
-}
-
-uint32_t jffs2_get_nr_frags(struct inode *inode)
-{
-	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
-	return f->nr_frags;
-}
-
-int jffs2_frags_exists(struct inode *inode)
-{
-	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
-	return f->fragtree.rb_node != NULL;
-}
-
-#endif
-
-/*
- * Local variables:
- *   c-basic-offset: 8
- * End:
- */
diff -Nur linux/fs/jffs2/nodelist.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/nodelist.h
--- linux/fs/jffs2/nodelist.h	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/nodelist.h	2003-06-23 01:47:04.000000000 +0700
@@ -1,46 +1,45 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
+ * Copyright (C) 2001 Red Hat, Inc.
  *
  * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: nodelist.h,v 1.83 2002/09/06 16:46:29 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
  *
- * ChangeLog:
- *     27-Nov-2002 Lineo Japan, Inc.  add effective-gc mode
- *     23-Nov-2002 Lineo Japan, Inc.  add JFFS2_RESERVED_BLOCKS_DIRTY
- *				      add JFFS2_RESERVED_BLOCKS_CLEAN
- *     19-Nov-2002 Lineo Japan, Inc.  add counter of fragtree elements
- *     18-Nov-2002 Lineo Japan, Inc.  add dynamic construction of fragtree
- *     11-Nov-2002 Lineo Japan, Inc.  add JFFS2_RESERVED_BLOCKS_ROOT
- *     29-Oct-2002 Lineo Japan, Inc.  add JFFS2_RESERVED_BLOCKS_BAD and JFFS2_MAX_CONT_GC
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
  *
- * ChangeLog:
- *     05-Dec-2002 SHARP  adjust REVERVED_BLOCKS values for storage-full
- *     27-Nov-2002 Lineo Japan, Inc.  add effective-gc mode
- *     23-Nov-2002 Lineo Japan, Inc.  add JFFS2_RESERVED_BLOCKS_DIRTY
- *				      add JFFS2_RESERVED_BLOCKS_CLEAN
- *     19-Nov-2002 Lineo Japan, Inc.  add counter of fragtree elements
- *     18-Nov-2002 Lineo Japan, Inc.  add dynamic construction of fragtree
- *     11-Nov-2002 Lineo Japan, Inc.  add JFFS2_RESERVED_BLOCKS_ROOT
- *     29-Oct-2002 Lineo Japan, Inc.  add JFFS2_RESERVED_BLOCKS_BAD and JFFS2_MAX_CONT_GC
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: nodelist.h,v 1.46.2.2 2002/05/27 09:27:50 dwmw2 Exp $
  *
  */
 
-#ifndef __JFFS2_NODELIST_H__
-#define __JFFS2_NODELIST_H__
-
 #include <linux/config.h>
 #include <linux/fs.h>
 
-#include <linux/mtd/compatmac.h> /* For min/max in older kernels */
-#include <linux/jffs2.h>
 #include <linux/jffs2_fs_sb.h>
 #include <linux/jffs2_fs_i.h>
-#include "os-linux.h"
 
 #ifndef CONFIG_JFFS2_FS_DEBUG
 #define CONFIG_JFFS2_FS_DEBUG 2
@@ -72,22 +71,16 @@
 		for this inode instead. The inode_cache will have NULL in the first
 		word so you know when you've got there :) */
 	struct jffs2_raw_node_ref *next_phys;
-	uint32_t flash_offset;
-	uint32_t totlen;
+	//	__u32 ino;
+	__u32 flash_offset;
+	__u32 totlen;
+//	__u16 nodetype;
 	
         /* flash_offset & 3 always has to be zero, because nodes are
 	   always aligned at 4 bytes. So we have a couple of extra bits
 	   to play with. So we set the least significant bit to 1 to
 	   signify that the node is obsoleted by later nodes.
 	*/
-#define REF_UNCHECKED	0	/* We haven't yet checked the CRC or built its inode */
-#define REF_OBSOLETE	1	/* Obsolete, can be completely ignored */
-#define REF_PRISTINE	2	/* Completely clean. GC without looking */
-#define REF_NORMAL	3	/* Possibly overlapped. Read the page and write again on GC */
-#define ref_flags(ref)		((ref)->flash_offset & 3)
-#define ref_offset(ref)		((ref)->flash_offset & ~3)
-#define ref_obsolete(ref)	(((ref)->flash_offset & 3) == REF_OBSOLETE)
-#define mark_ref_normal(ref)    do { (ref)->flash_offset = ref_offset(ref) | REF_NORMAL; } while(0)
 };
 
 /* 
@@ -114,18 +107,13 @@
 		chain. */
 	struct jffs2_inode_cache *next;
 	struct jffs2_raw_node_ref *nodes;
-	uint32_t ino;
+	__u32 ino;
 	int nlink;
 };
 
-#define INOCACHE_HASHSIZE 128
-
 struct jffs2_scan_info {
 	struct jffs2_full_dirent *dents;
 	struct jffs2_tmp_dnode_info *tmpnodes;
-	/* Latest i_size info */
-	uint32_t version;
-	uint32_t isize;
 };
 /*
   Larger representation of a raw node, kept in-core only when the 
@@ -135,9 +123,9 @@
 struct jffs2_full_dnode
 {
 	struct jffs2_raw_node_ref *raw;
-	uint32_t ofs; /* Don't really need this, but optimisation */
-	uint32_t size;
-	uint32_t frags; /* Number of fragments which currently refer
+	__u32 ofs; /* Don't really need this, but optimisation */
+	__u32 size;
+	__u32 frags; /* Number of fragments which currently refer
 			to this node. When this reaches zero, 
 			the node is obsolete.
 		     */
@@ -152,15 +140,15 @@
 {
 	struct jffs2_tmp_dnode_info *next;
 	struct jffs2_full_dnode *fn;
-	uint32_t version;
+	__u32 version;
 };       
 
 struct jffs2_full_dirent
 {
 	struct jffs2_raw_node_ref *raw;
 	struct jffs2_full_dirent *next;
-	uint32_t version;
-	uint32_t ino; /* == zero for unlink */
+	__u32 version;
+	__u32 ino; /* == zero for unlink */
 	unsigned int nhash;
 	unsigned char type;
 	unsigned char name[0];
@@ -171,22 +159,21 @@
 */
 struct jffs2_node_frag
 {
-	rb_node_t rb;
+	struct jffs2_node_frag *next;
 	struct jffs2_full_dnode *node; /* NULL for holes */
-	uint32_t size;
-	uint32_t ofs; /* Don't really need this, but optimisation */
+	__u32 size;
+	__u32 ofs; /* Don't really need this, but optimisation */
 };
 
 struct jffs2_eraseblock
 {
 	struct list_head list;
 	int bad_count;
-	uint32_t offset;		/* of this block in the MTD */
+	__u32 offset;		/* of this block in the MTD */
 
-	uint32_t used_size;
-	uint32_t dirty_size;
-	uint32_t wasted_size;
-	uint32_t free_size;	/* Note that sector_size - free_size
+	__u32 used_size;
+	__u32 dirty_size;
+	__u32 free_size;	/* Note that sector_size - free_size
 				   is the address of the first free space */
 	struct jffs2_raw_node_ref *first_node;
 	struct jffs2_raw_node_ref *last_node;
@@ -203,25 +190,25 @@
 };
 
 #define ACCT_SANITY_CHECK(c, jeb) do { \
-	if (jeb->used_size + jeb->dirty_size + jeb->free_size +jeb->wasted_size != c->sector_size) { \
+	if (jeb->used_size + jeb->dirty_size + jeb->free_size != c->sector_size) { \
 		printk(KERN_NOTICE "Eeep. Space accounting for block at 0x%08x is screwed\n", jeb->offset); \
-		printk(KERN_NOTICE "free 0x%08x + dirty 0x%08x + used %08x + wasted %08x != total %08x\n", \
-		jeb->free_size, jeb->dirty_size, jeb->used_size, jeb->wasted_size, c->sector_size); \
+		printk(KERN_NOTICE "free 0x%08x + dirty 0x%08x + used %08x != total %08x\n", \
+		jeb->free_size, jeb->dirty_size, jeb->used_size, c->sector_size); \
 		BUG(); \
 	} \
-	if (c->used_size + c->dirty_size + c->free_size + c->erasing_size + c->bad_size + c->wasted_size != c->flash_size) { \
+	if (c->used_size + c->dirty_size + c->free_size + c->erasing_size + c->bad_size != c->flash_size) { \
 		printk(KERN_NOTICE "Eeep. Space accounting superblock info is screwed\n"); \
-		printk(KERN_NOTICE "free 0x%08x + dirty 0x%08x + used %08x + erasing %08x + bad %08x + wasted %08x != total %08x\n", \
-		c->free_size, c->dirty_size, c->used_size, c->erasing_size, c->bad_size, c->wasted_size, c->flash_size); \
+		printk(KERN_NOTICE "free 0x%08x + dirty 0x%08x + used %08x + erasing %08x + bad %08x != total %08x\n", \
+		c->free_size, c->dirty_size, c->used_size, c->erasing_size, c->bad_size, c->flash_size); \
 		BUG(); \
 	} \
 } while(0)
 
 #define ACCT_PARANOIA_CHECK(jeb) do { \
-		uint32_t my_used_size = 0; \
+		__u32 my_used_size = 0; \
 		struct jffs2_raw_node_ref *ref2 = jeb->first_node; \
 		while (ref2) { \
-			if (!ref_obsolete(ref2)) \
+			if (!(ref2->flash_offset & 1)) \
 				my_used_size += ref2->totlen; \
 			ref2 = ref2->next_phys; \
 		} \
@@ -238,44 +225,13 @@
 #define JFFS2_RESERVED_BLOCKS_BASE 3						/* Number of free blocks there must be before we... */
 #define JFFS2_RESERVED_BLOCKS_WRITE (JFFS2_RESERVED_BLOCKS_BASE + 2)		/* ... allow a normal filesystem write */
 #define JFFS2_RESERVED_BLOCKS_DELETION (JFFS2_RESERVED_BLOCKS_BASE + 1)		/* ... allow a normal filesystem deletion */
-#define JFFS2_RESERVED_BLOCKS_GCTRIGGER 39					/* ... wake up the GC thread */
+#define JFFS2_RESERVED_BLOCKS_GCTRIGGER (JFFS2_RESERVED_BLOCKS_BASE + 3)	/* ... wake up the GC thread */
 #define JFFS2_RESERVED_BLOCKS_GCBAD (JFFS2_RESERVED_BLOCKS_BASE + 1)		/* ... pick a block from the bad_list to GC */
 #define JFFS2_RESERVED_BLOCKS_GCMERGE (JFFS2_RESERVED_BLOCKS_BASE)		/* ... merge pages when garbage collecting */
-#define JFFS2_RESERVED_BLOCKS_BAD 24
-#define JFFS2_RESERVED_BLOCKS_ROOT 5
-#define JFFS2_RESERVED_BLOCKS_DIRTY 24
-#define JFFS2_RESERVED_BLOCKS_CLEAN 12
-#if JFFS2_RESERVED_BLOCKS_CLEAN < JFFS2_RESERVED_BLOCKS_WRITE + JFFS2_RESERVED_BLOCKS_ROOT
-#error assure that JFFS2_RESERVED_BLOCKS_CLEAN >= JFFS2_RESERVED_BLOCKS_WRITE + JFFS2_RESERVED_BLOCKS_ROOT
-#endif
-#if JFFS2_RESERVED_BLOCKS_GCTRIGGER <= JFFS2_RESERVED_BLOCKS_WRITE + JFFS2_RESERVED_BLOCKS_ROOT + JFFS2_RESERVED_BLOCKS_DIRTY
-#error assure that JFFS2_RESERVED_BLOCKS_GCTRIGGER > JFFS2_RESERVED_BLOCKS_WRITE + JFFS2_RESERVED_BLOCKS_ROOT + JFFS2_RESERVED_BLOCKS_DIRTY
-#endif
-#define JFFS2_MAX_CONT_GC 3000
-
-#define NR_AVAIL_BLOCKS(c) ((c)->nr_free_blocks + (c)->nr_erasing_blocks - max(0, JFFS2_RESERVED_BLOCKS_BAD - (c)->nr_bad_blocks))
 
-/* How much dirty space before it goes on the very_dirty_list */
-#define VERYDIRTY(c, size) ((size) >= ((c)->sector_size / 2))
-
-/* check if dirty space is more than 255 Byte */
-#define ISDIRTY(size) ((size) >  sizeof (struct jffs2_raw_inode) + JFFS2_MIN_DATA_LEN) 
-
-/* node merge threshold */
-#define JFFS2_FRAGS_NR_NODES_THRESHOLD_NORMAL	 4
-#define JFFS2_FRAGS_NR_NODES_THRESHOLD_FORCE	 1
 
 #define PAD(x) (((x)+3)&~3)
 
-typedef enum { GCMODE_NORMAL, GCMODE_EFFECTIVE, } jffs2_gcmode_t;
-
-#define GC_EFFECTIVE_BLOCK_DIRTY_SIZE		(1*1024)
-#define GC_EFFECTIVE_BLOCK_DIRTY_SIZE_L		(2*1024)
-#define GC_EFFECTIVE_BLOCK_DIRTY_SIZE_LL	(4*1024)
-#define GC_EFFECTIVE_TOTAL_DIRTY_SIZE(c)	(JFFS2_RESERVED_BLOCKS_DIRTY * (c)->sector_size)
-#define GC_EFFECTIVE_TOTAL_DIRTY_SIZE_L(c)	(JFFS2_RESERVED_BLOCKS_DIRTY * (c)->sector_size * 2)
-#define GC_EFFECTIVE_TOTAL_DIRTY_SIZE_LL(c)	(JFFS2_RESERVED_BLOCKS_DIRTY * (c)->sector_size * 4)
-
 static inline int jffs2_raw_ref_to_inum(struct jffs2_raw_node_ref *raw)
 {
 	while(raw->next_in_ino) {
@@ -285,111 +241,43 @@
 	return ((struct jffs2_inode_cache *)raw)->ino;
 }
 
-static inline struct jffs2_node_frag *frag_first(rb_root_t *root)
-{
-	rb_node_t *node = root->rb_node;
-
-	if (!node)
-		return NULL;
-	while(node->rb_left)
-		node = node->rb_left;
-	return rb_entry(node, struct jffs2_node_frag, rb);
-}
-#define rb_parent(rb) ((rb)->rb_parent)
-#define frag_next(frag) rb_entry(rb_next(&(frag)->rb), struct jffs2_node_frag, rb)
-#define frag_prev(frag) rb_entry(rb_prev(&(frag)->rb), struct jffs2_node_frag, rb)
-#define frag_parent(frag) rb_entry(rb_parent(&(frag)->rb), struct jffs2_node_frag, rb)
-#define frag_left(frag) rb_entry((frag)->rb.rb_left, struct jffs2_node_frag, rb)
-#define frag_right(frag) rb_entry((frag)->rb.rb_right, struct jffs2_node_frag, rb)
-#define frag_erase(frag, list) rb_erase(&frag->rb, list);
-
 /* nodelist.c */
 D1(void jffs2_print_frag_list(struct jffs2_inode_info *f));
 void jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list);
 void jffs2_add_tn_to_list(struct jffs2_tmp_dnode_info *tn, struct jffs2_tmp_dnode_info **list);
 int jffs2_get_inode_nodes(struct jffs2_sb_info *c, ino_t ino, struct jffs2_inode_info *f,
 			  struct jffs2_tmp_dnode_info **tnp, struct jffs2_full_dirent **fdp,
-			  uint32_t *highest_version, uint32_t *latest_mctime,
-			  uint32_t *mctime_ver);
+			  __u32 *highest_version, __u32 *latest_mctime,
+			  __u32 *mctime_ver);
 struct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, int ino);
 void jffs2_add_ino_cache (struct jffs2_sb_info *c, struct jffs2_inode_cache *new);
 void jffs2_del_ino_cache(struct jffs2_sb_info *c, struct jffs2_inode_cache *old);
 void jffs2_free_ino_caches(struct jffs2_sb_info *c);
 void jffs2_free_raw_node_refs(struct jffs2_sb_info *c);
-struct jffs2_node_frag *jffs2_lookup_node_frag(rb_root_t *fragtree, uint32_t offset);
-void jffs2_kill_fragtree(rb_root_t *root, struct jffs2_sb_info *c_delete);
-void jffs2_fragtree_insert(struct jffs2_node_frag *newfrag, struct jffs2_node_frag *base);
-rb_node_t *rb_next(rb_node_t *);
-rb_node_t *rb_prev(rb_node_t *);
-void rb_replace_node(rb_node_t *victim, rb_node_t *new, rb_root_t *root);
 
 /* nodemgmt.c */
-int jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize, uint32_t *ofs, uint32_t *len, int prio);
-int jffs2_reserve_space_gc(struct jffs2_sb_info *c, uint32_t minsize, uint32_t *ofs, uint32_t *len);
-int jffs2_add_physical_node_ref(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *new);
+int jffs2_reserve_space(struct jffs2_sb_info *c, __u32 minsize, __u32 *ofs, __u32 *len, int prio);
+int jffs2_reserve_space_gc(struct jffs2_sb_info *c, __u32 minsize, __u32 *ofs, __u32 *len);
+int jffs2_add_physical_node_ref(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *new, __u32 len, int dirty);
 void jffs2_complete_reservation(struct jffs2_sb_info *c);
 void jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *raw);
-void jffs2_dump_block_lists(struct jffs2_sb_info *c);
 
 /* write.c */
-int jffs2_do_new_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, uint32_t mode, struct jffs2_raw_inode *ri);
-struct jffs2_full_dnode *jffs2_write_dnode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_raw_inode *ri, const unsigned char *data, uint32_t datalen, uint32_t flash_ofs,  uint32_t *writelen);
-struct jffs2_full_dirent *jffs2_write_dirent(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_raw_dirent *rd, const unsigned char *name, uint32_t namelen, uint32_t flash_ofs,  uint32_t *writelen);
-int jffs2_write_inode_range(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
-			    struct jffs2_raw_inode *ri, unsigned char *buf, 
-			    uint32_t offset, uint32_t writelen, uint32_t *retlen);
-int jffs2_do_create(struct jffs2_sb_info *c, struct jffs2_inode_info *dir_f, struct jffs2_inode_info *f, struct jffs2_raw_inode *ri, const char *name, int namelen);
-int jffs2_do_unlink(struct jffs2_sb_info *c, struct jffs2_inode_info *dir_f, const char *name, int namelen, struct jffs2_inode_info *dead_f);
-int jffs2_do_link (struct jffs2_sb_info *c, struct jffs2_inode_info *dir_f, uint32_t ino, uint8_t type, const char *name, int namelen);
-
+struct inode *jffs2_new_inode (struct inode *dir_i, int mode, struct jffs2_raw_inode *ri);
+struct jffs2_full_dnode *jffs2_write_dnode(struct inode *inode, struct jffs2_raw_inode *ri, const unsigned char *data, __u32 datalen, __u32 flash_ofs,  __u32 *writelen);
+struct jffs2_full_dirent *jffs2_write_dirent(struct inode *inode, struct jffs2_raw_dirent *rd, const unsigned char *name, __u32 namelen, __u32 flash_ofs,  __u32 *writelen);
 
 /* readinode.c */
-int jffs2_truncate_fraglist_1 (struct jffs2_sb_info *c, rb_root_t *list, uint32_t size);
-#ifdef CONFIG_JFFS2_DYNFRAGTREE
-static inline void jffs2_truncate_fraglist (struct jffs2_sb_info *c, struct jffs2_inode_info *f, uint32_t size)
-{
-	f->nr_frags -= jffs2_truncate_fraglist_1(c, &f->fragtree, size);
-}
-int jffs2_add_full_dnode_to_fraglist_1(struct jffs2_sb_info *c, rb_root_t *list, struct jffs2_full_dnode *fn, int* added_frags);
-static inline int jffs2_add_full_dnode_to_fraglist(struct jffs2_sb_info *c, rb_root_t *list, struct jffs2_full_dnode *fn)
-{
-	int dummy = 0;
-	return jffs2_add_full_dnode_to_fraglist_1(c, list, fn, &dummy);
-}
-
-#define ADDED_FRAGS_INC() ((*added_frags)++)
-#define ADDED_FRAGS_DEC() ((*added_frags)--)
-#define CLEAR_NR_FRAGS(f) ((f)->nr_frags = 0)
-
-static inline void jffs2_check_nr_frags(struct jffs2_inode_info *f)
-{
-    struct jffs2_node_frag *frag;
-    uint32_t count = 0;
-    for (frag = frag_first(&f->fragtree); frag; frag = frag_next(frag))
-	count++;
-    if (count != f->nr_frags) {
-	printk("ino #%lu: nr_frags:%u != %u\n", OFNI_EDONI_2SFFJ(f)->i_ino, f->nr_frags, count);
-    }
-    else
-	printk("ino #%lu: nr_frags:%u\n", OFNI_EDONI_2SFFJ(f)->i_ino, f->nr_frags);
-}
-#else
-static inline void jffs2_truncate_fraglist (struct jffs2_sb_info *c, struct jffs2_inode_info *f, uint32_t size)
-{
-	jffs2_truncate_fraglist_1(c, &f->fragtree, size);
-}
-int jffs2_add_full_dnode_to_fraglist(struct jffs2_sb_info *c, rb_root_t *list, struct jffs2_full_dnode *fn);
-
-#define ADDED_FRAGS_INC()
-#define ADDED_FRAGS_DEC()
-#define CLEAR_NR_FRAGS(f)
-#endif
+void jffs2_truncate_fraglist (struct jffs2_sb_info *c, struct jffs2_node_frag **list, __u32 size);
+int jffs2_add_full_dnode_to_fraglist(struct jffs2_sb_info *c, struct jffs2_node_frag **list, struct jffs2_full_dnode *fn);
 int jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_full_dnode *fn);
-int jffs2_do_read_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, 
-			uint32_t ino, struct jffs2_raw_inode *latest_node);
-void jffs2_do_clear_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f);
+void jffs2_read_inode (struct inode *);
+void jffs2_clear_inode (struct inode *);
 
 /* malloc.c */
+void jffs2_free_tmp_dnode_info_list(struct jffs2_tmp_dnode_info *tn);
+void jffs2_free_full_dirent_list(struct jffs2_full_dirent *fd);
+
 int jffs2_create_slab_caches(void);
 void jffs2_destroy_slab_caches(void);
 
@@ -411,85 +299,52 @@
 void jffs2_free_inode_cache(struct jffs2_inode_cache *);
 
 /* gc.c */
-int jffs2_garbage_collect_pass(struct jffs2_sb_info *c, jffs2_gcmode_t);
+int jffs2_garbage_collect_pass(struct jffs2_sb_info *c);
+
+/* background.c */
+int jffs2_start_garbage_collect_thread(struct jffs2_sb_info *c);
+void jffs2_stop_garbage_collect_thread(struct jffs2_sb_info *c);
+void jffs2_garbage_collect_trigger(struct jffs2_sb_info *c);
+
+/* dir.c */
+extern struct file_operations jffs2_dir_operations;
+extern struct inode_operations jffs2_dir_inode_operations;
+
+/* file.c */
+extern struct file_operations jffs2_file_operations;
+extern struct inode_operations jffs2_file_inode_operations;
+extern struct address_space_operations jffs2_file_address_operations;
+int jffs2_null_fsync(struct file *, struct dentry *, int);
+int jffs2_setattr (struct dentry *dentry, struct iattr *iattr);
+int jffs2_do_readpage_nolock (struct inode *inode, struct page *pg);
+int jffs2_do_readpage_unlock (struct inode *inode, struct page *pg);
+int jffs2_readpage (struct file *, struct page *);
+int jffs2_prepare_write (struct file *, struct page *, unsigned, unsigned);
+int jffs2_commit_write (struct file *, struct page *, unsigned, unsigned);
+
+/* ioctl.c */
+int jffs2_ioctl(struct inode *, struct file *, unsigned int, unsigned long);
 
 /* read.c */
 int jffs2_read_dnode(struct jffs2_sb_info *c, struct jffs2_full_dnode *fd, unsigned char *buf, int ofs, int len);
-int jffs2_read_inode_range(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
-			   unsigned char *buf, uint32_t offset, uint32_t len);
-char *jffs2_getlink(struct jffs2_sb_info *c, struct jffs2_inode_info *f);
-
 
 /* compr.c */
 unsigned char jffs2_compress(unsigned char *data_in, unsigned char *cpage_out, 
-			     uint32_t *datalen, uint32_t *cdatalen);
+			     __u32 *datalen, __u32 *cdatalen);
 int jffs2_decompress(unsigned char comprtype, unsigned char *cdata_in, 
-		     unsigned char *data_out, uint32_t cdatalen, uint32_t datalen);
+		     unsigned char *data_out, __u32 cdatalen, __u32 datalen);
 
 /* scan.c */
 int jffs2_scan_medium(struct jffs2_sb_info *c);
-void jffs2_rotate_lists(struct jffs2_sb_info *c);
 
 /* build.c */
-int jffs2_do_mount_fs(struct jffs2_sb_info *c);
+int jffs2_build_filesystem(struct jffs2_sb_info *c);
+
+/* symlink.c */
+extern struct inode_operations jffs2_symlink_inode_operations;
 
 /* erase.c */
 void jffs2_erase_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);
 void jffs2_erase_pending_blocks(struct jffs2_sb_info *c);
 void jffs2_mark_erased_blocks(struct jffs2_sb_info *c);
 void jffs2_erase_pending_trigger(struct jffs2_sb_info *c);
-
-#ifdef CONFIG_JFFS2_FS_NAND
-/* wbuf.c */
-int jffs2_flush_wbuf(struct jffs2_sb_info *c, int pad);
-int jffs2_check_nand_cleanmarker(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);
-int jffs2_write_nand_cleanmarker(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);
-int jffs2_nand_read_failcnt(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);
-#endif
-
-/* compr_zlib.c */
-int jffs2_zlib_init(void);
-void jffs2_zlib_exit(void);
-
-/* dynamic construction of fragtree */
-#ifdef CONFIG_JFFS2_DYNFRAGTREE
-int jffs2_construct_fragtree(struct jffs2_sb_info*, struct jffs2_inode_info*);
-static inline int jffs2_construct_fragtree_nolock_if_missing(struct jffs2_sb_info* c,
-							     struct jffs2_inode_info* f)
-{
-	if (S_ISREG(OFNI_EDONI_2SFFJ(f)->i_mode) && ! frag_first(&f->fragtree))
-		return jffs2_construct_fragtree(c, f);
-	else
-		return 0;
-}
-
-static inline int jffs2_construct_fragtree_if_missing(struct jffs2_sb_info* c,
-						      struct jffs2_inode_info* f)
-{
-	if (S_ISREG(OFNI_EDONI_2SFFJ(f)->i_mode) && ! frag_first(&f->fragtree)) {
-		int ret;
-
-		down(&f->sem);
-		ret = jffs2_construct_fragtree(c, f);
-		up(&f->sem);
-
-		return ret;
-	}
-	else
-		return 0;
-}
-#else
-static inline int jffs2_construct_fragtree_nolock_if_missing(struct jffs2_sb_info* c,
-							     struct jffs2_inode_info* f)
-{
-	return 0;
-}
-
-static inline int jffs2_construct_fragtree_if_missing(struct jffs2_sb_info* c,
-						      struct jffs2_inode_info* f)
-{
-	return 0;
-}
-#endif
-
-#endif /* __JFFS2_NODELIST_H__ */
diff -Nur linux/fs/jffs2/nodemerge.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/nodemerge.c
--- linux/fs/jffs2/nodemerge.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/nodemerge.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,118 +0,0 @@
-/*
- * fs/jffs2/nodemerge.c
- *
- * Copyright (C) 2002 Lineo Japan, Inc.
- *
- * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.
- *
- * $Id: nodemerge.c,v 1.4 2002/12/19 02:42:45 yamade Exp $
- *
- * ChangLog:
- *     05-Dec-2002 SHARP  nodemerge-thershold is changable
- */
-
-#include <linux/kernel.h>
-#include <linux/fs.h>
-#include <linux/rbtree.h>
-#include <linux/pagemap.h>
-#include <linux/jffs2_fs_i.h>
-#include "nodelist.h"
-#include "nodemerge.h"
-
-/*
- * return number of jffs2_node_frags for specified page.
- */
-static int
-jffs2_count_node_frags(rb_root_t* fragtree,
-		       unsigned long page_index)
-{
-    struct jffs2_node_frag* frag;
-    uint32_t offset = page_index << PAGE_CACHE_SHIFT;
-    uint32_t next_offset = (page_index + 1) << PAGE_CACHE_SHIFT;
-    int count = 0;
-
-    for (frag = jffs2_lookup_node_frag(fragtree, offset);
-	 frag && frag->ofs < offset; frag = frag_next(frag))
-	;
-    while (frag && frag->ofs < next_offset) {
-	count++;
-	frag = frag_next(frag);
-    }
-
-    return count;
-}
-
-
-static uint32_t
-frag_totlen(const struct jffs2_node_frag* frag)
-{
-    return frag->node ? frag->node->raw->totlen : 0;
-}
-
-
-/*
- * return most dirty block in the page.
- */
-static struct jffs2_eraseblock*
-jffs2_most_dirty_block_in_page(const struct jffs2_sb_info* c,
-			       rb_root_t* fragtree,
-			       unsigned long page_index)
-{
-    struct jffs2_node_frag* frag;
-    uint32_t offset = page_index << PAGE_CACHE_SHIFT;
-    uint32_t next_offset = (page_index + 1) << PAGE_CACHE_SHIFT;
-    struct jffs2_eraseblock* ret_jeb = 0;
-    uint32_t dirty_size = 0;
-    
-    for (frag = jffs2_lookup_node_frag(fragtree, offset);
-	 frag && frag->ofs < next_offset; frag = frag_next(frag)) {
-	struct jffs2_eraseblock* jeb;
-
-	if (! frag->node)
-	    continue;
-
-	jeb = &c->blocks[frag->node->raw->flash_offset / c->sector_size];
-	if (jeb == c->gcblock)	/* this page is been gcing */
-	    return NULL;
-	else if (jeb != c->nextblock && 
-		 jeb->wasted_size + jeb->dirty_size + frag_totlen(frag) > dirty_size) {
-	    ret_jeb = jeb;
-	    dirty_size = jeb->wasted_size + jeb->dirty_size;
-	}
-    }
-    return ret_jeb;
-}
-
-
-/*
- * Must be called with the f->sem held.
- */
-void
-jffs2_merge_nodes(struct jffs2_sb_info* c,
-		  struct jffs2_inode_info* f,
-		  uint32_t size, int frags_threshold)
-{
-    unsigned long i;
-    unsigned long nr_pages = (size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
-
-    for (i = 0; i < nr_pages; i++) {
-	struct jffs2_eraseblock* jeb;
-
-	if (jffs2_count_node_frags(&f->fragtree, i) <= frags_threshold)
-	    continue;
-
-	jeb = jffs2_most_dirty_block_in_page(c, &f->fragtree, i);
-	if (! jeb)
-	    continue;
-
-	/* must do erase_completion_lock, because jeb may be linked to
-	 * the free_list */
-	spin_lock_bh(&c->erase_completion_lock);
-	list_del(&jeb->list);
-	list_add_tail(&jeb->list, &c->nodemerge_list);
-	spin_unlock_bh(&c->erase_completion_lock);
-    }
-
-    jffs2_garbage_collect_trigger(c);
-}
diff -Nur linux/fs/jffs2/nodemerge.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/nodemerge.h
--- linux/fs/jffs2/nodemerge.h	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/nodemerge.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,24 +0,0 @@
-/*
- * fs/jffs2/nodemerge.h
- *
- * Copyright (C) 2002 Lineo Japan, Inc.
- *
- * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.
- *
- * $Id: nodemerge.h,v 1.3 2002/12/19 02:42:45 yamade Exp $
- *
- * ChangLog:
- *     05-Dec-2002 SHARP  nodemerge-thershold is changable
- */
-
-#ifndef __JFFS2_NODEMERGE_H__
-#define __JFFS2_NODEMERGE_H__
-
-#ifdef CONFIG_JFFS2_NODEMERGE
-void jffs2_merge_nodes(struct jffs2_sb_info*, struct jffs2_inode_info*, uint32_t, int);
-#else
-static inline void jffs2_merge_nodes(struct jffs2_sb_info* c, struct jffs2_inode_info* f, uint32_t size, int frags_threshold) { }
-#endif
-
-#endif
diff -Nur linux/fs/jffs2/nodemgmt.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/nodemgmt.c
--- linux/fs/jffs2/nodemgmt.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/nodemgmt.c	2003-06-23 01:47:04.000000000 +0700
@@ -1,37 +1,43 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
+ * Copyright (C) 2001 Red Hat, Inc.
  *
  * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: nodemgmt.c,v 1.77 2002/09/06 16:46:29 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
  *
- * ChangeLog:
- *     27-Nov-2002 Lineo Japan, Inc.  add effective-gc mode
- *     15-Nov-2002 Lineo Japan, Inc.  add nodemerge facility
- *     11-Nov-2002 Lineo Japan, Inc.  add reserved blocks for superuser
- *     29-Oct-2002 Lineo Japan, Inc.  add reserved blocks for badblocks
- *				      add c->cont_gc_count
- *     24-Oct-2002 Lineo Japan, Inc.  separate jffs2_reserve_space into
- *       *_normal and *_deletion
- *
- * ChangeLog:
- *     27-Nov-2002 Lineo Japan, Inc.  add effective-gc mode
- *     24-Nov-2002 SHARP  modify storage-full conditions, and add erasing_dirty_size
- *     15-Nov-2002 Lineo Japan, Inc.  add nodemerge facility
- *     11-Nov-2002 Lineo Japan, Inc.  add reserved blocks for superuser
- *     29-Oct-2002 Lineo Japan, Inc.  add reserved blocks for badblocks
- *				      add c->cont_gc_count
- *     24-Oct-2002 Lineo Japan, Inc.  separate jffs2_reserve_space into
- *       *_normal and *_deletion
+ * $Id: nodemgmt.c,v 1.45.2.1 2002/02/23 14:13:34 dwmw2 Exp $
  *
  */
 
 #include <linux/kernel.h>
 #include <linux/slab.h>
+#include <linux/jffs2.h>
 #include <linux/mtd/mtd.h>
 #include <linux/interrupt.h>
 #include "nodelist.h"
@@ -56,134 +62,17 @@
  *	for the requested allocation.
  */
 
-static int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize, uint32_t *ofs, uint32_t *len);
+static int jffs2_do_reserve_space(struct jffs2_sb_info *c,  __u32 minsize, __u32 *ofs, __u32 *len);
 
-static inline int jffs2_reserve_space_normal(struct jffs2_sb_info *c, uint32_t minsize, uint32_t *ofs, uint32_t *len)
+int jffs2_reserve_space(struct jffs2_sb_info *c, __u32 minsize, __u32 *ofs, __u32 *len, int prio)
 {
-	int ret;
-	int reserved_blocks_root = capable(CAP_SYS_ADMIN) ? 0 : JFFS2_RESERVED_BLOCKS_ROOT;
-	int reserved_blocks = JFFS2_RESERVED_BLOCKS_WRITE + reserved_blocks_root;
-	uint32_t dirty_now, erasing_dirty_now, nonerasing_dirty_now;
-	int32_t avail_blocks, avail_blocks_old;
-
-	avail_blocks_old = -1;
-
-	do {
-		while(NR_AVAIL_BLOCKS(c) < reserved_blocks) {
-			up(&c->alloc_sem);
-
-			dirty_now = c->dirty_size;
-			erasing_dirty_now = c->erasing_dirty_size;
-			nonerasing_dirty_now = ((dirty_now >= erasing_dirty_now) ? (dirty_now - erasing_dirty_now) : 0);
-			avail_blocks = NR_AVAIL_BLOCKS(c);
-
-			if (avail_blocks_old != avail_blocks){
-				//printk(KERN_DEBUG "jffs2-normal-log: TIME=%d, NR_AVAIL_BLOCKS=%d, avail_blocks_old=%d, cont_gc_count=%d, dirty_size=%d, free_size=%d, erasing_size=%d, erasing_dirty_size=%d\n", jiffies, avail_blocks, avail_blocks_old, c->cont_gc_count, dirty_now, c->free_size, c->erasing_size, erasing_dirty_now);
-				avail_blocks_old = avail_blocks;
-			}
-
-			if (c->cont_gc_count >= JFFS2_MAX_CONT_GC ||
-				avail_blocks <=  1 + reserved_blocks_root ||
-				dirty_now < c->sector_size ||
-				nonerasing_dirty_now / c->sector_size < JFFS2_RESERVED_BLOCKS_DIRTY ||
-				avail_blocks + nonerasing_dirty_now / c->sector_size - JFFS2_RESERVED_BLOCKS_DIRTY < reserved_blocks){
-
-				D1(printk(KERN_DEBUG "jffs2-normal-err: TIME=%lu, NR_AVAIL_BLOCKS=%d, avail_blocks_old=%d, cont_gc_count=%d, dirty_size=%d, free_size=%d, erasing_size=%d, erasing_dirty_size=%d\n", jiffies, avail_blocks, avail_blocks_old, c->cont_gc_count, dirty_now, c->free_size, c->erasing_size, erasing_dirty_now));
-				spin_unlock_bh(&c->erase_completion_lock);
-				return -ENOSPC;
-			}
-			c->cont_gc_count++;
-			
-			D1(printk(KERN_DEBUG "Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\n",
-				  c->nr_free_blocks, c->nr_erasing_blocks, c->free_size, c->dirty_size, c->wasted_size, c->used_size, c->erasing_size, c->bad_size,
-				  c->free_size + c->dirty_size + c->wasted_size + c->used_size + c->erasing_size + c->bad_size, c->flash_size));
-			spin_unlock_bh(&c->erase_completion_lock);
-			
-			ret = jffs2_garbage_collect_pass(c, GCMODE_NORMAL);
-			if (ret)
-				return ret;
-
-			cond_resched();
-
-			if (signal_pending(current))
-				return -EINTR;
-
-			down(&c->alloc_sem);
-			spin_lock_bh(&c->erase_completion_lock);
-		}
-		c->cont_gc_count = 0;
-
-		ret = jffs2_do_reserve_space(c, minsize, ofs, len);
-		if (ret) {
-			D1(printk(KERN_DEBUG "jffs2_do_reserve_space: ret is %d\n", ret));
-		}
-	} while (ret == -EAGAIN);
-	spin_unlock_bh(&c->erase_completion_lock);
-	if (ret)
-		up(&c->alloc_sem);
-	return ret;
-}
-
-static inline int jffs2_reserve_space_deletion(struct jffs2_sb_info *c, uint32_t minsize, uint32_t *ofs, uint32_t *len)
-{
-	for (;;) {
-		int ret;
-
-		c->cont_gc_count = 0;
-		ret = jffs2_do_reserve_space(c, minsize, ofs, len);
-		if (ret) {
-			D1(printk(KERN_DEBUG "jffs2_do_reserve_space: ret is %d\n", ret));
-		}
-
-		if (ret == -ENOSPC) {
-			up(&c->alloc_sem);
-
-			if ((c->nr_free_blocks + c->nr_erasing_blocks == 0 &&
-			     c->nextblock == NULL && list_empty(&c->erasable_list)) ||
-			    c->dirty_size < c->sector_size) {
-				D1(printk(KERN_DEBUG "jffs2-deletion-err: TIME=%lu, NR_AVAIL_BLOCKS=%d, dirty_size=%d, free_size=%d, erasing_size=%d, erasing_dirty_size=%d\n", jiffies, NR_AVAIL_BLOCKS(c), c->dirty_size, c->free_size, c->erasing_size, c->erasing_dirty_size));
-				spin_unlock_bh(&c->erase_completion_lock);
-				return -ENOSPC;
-			}
-			spin_unlock_bh(&c->erase_completion_lock);
-
-			D1(printk(KERN_DEBUG "Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\n",
-				  c->nr_free_blocks, c->nr_erasing_blocks, c->free_size, c->dirty_size, c->wasted_size, c->used_size, c->erasing_size, c->bad_size,
-				  c->free_size + c->dirty_size + c->wasted_size + c->used_size + c->erasing_size + c->bad_size, c->flash_size));
-			ret = jffs2_garbage_collect_pass(c, GCMODE_NORMAL);
-			if (ret)
-				return ret;
-
-			cond_resched();
-
-			if (signal_pending(current))
-				return -EINTR;
-
-			down(&c->alloc_sem);
-			spin_lock_bh(&c->erase_completion_lock);
-		}
-		else if (ret != -EAGAIN) {
-			spin_unlock_bh(&c->erase_completion_lock);
-			if (ret)
-				up(&c->alloc_sem);
-			return ret;
-		}
-	}
-}
-
-int jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize, uint32_t *ofs, uint32_t *len, int prio)
-{
-#if 0
 	int ret = -EAGAIN;
 	int blocksneeded = JFFS2_RESERVED_BLOCKS_WRITE;
-#endif
 	/* align it */
 	minsize = PAD(minsize);
 
-#if 0
 	if (prio == ALLOC_DELETION)
 		blocksneeded = JFFS2_RESERVED_BLOCKS_DELETION;
-#endif
 
 	D1(printk(KERN_DEBUG "jffs2_reserve_space(): Requested 0x%x bytes\n", minsize));
 	down(&c->alloc_sem);
@@ -193,29 +82,27 @@
 	spin_lock_bh(&c->erase_completion_lock);
 
 	/* this needs a little more thought */
-#if 0
 	while(ret == -EAGAIN) {
 		while(c->nr_free_blocks + c->nr_erasing_blocks < blocksneeded) {
 			int ret;
 
 			up(&c->alloc_sem);
-			
 			if (c->dirty_size < c->sector_size) {
-				D1(printk(KERN_DEBUG "dirty size 0x%08x < sector size 0x%08x, returning -ENOSPC\n", c->dirty_size, c->sector_size));
+				D1(printk(KERN_DEBUG "Short on space, but total dirty size 0x%08x < sector size 0x%08x, so -ENOSPC\n", c->dirty_size, c->sector_size));
 				spin_unlock_bh(&c->erase_completion_lock);
 				return -ENOSPC;
 			}
-			
-			D1(printk(KERN_DEBUG "Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\n",
-				  c->nr_free_blocks, c->nr_erasing_blocks, c->free_size, c->dirty_size, c->wasted_size, c->used_size, c->erasing_size, c->bad_size,
-				  c->free_size + c->dirty_size + c->wasted_size + c->used_size + c->erasing_size + c->bad_size, c->flash_size));
+			D1(printk(KERN_DEBUG "Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\n",
+				  c->nr_free_blocks, c->nr_erasing_blocks, c->free_size, c->dirty_size, c->used_size, c->erasing_size, c->bad_size,
+				  c->free_size + c->dirty_size + c->used_size + c->erasing_size + c->bad_size, c->flash_size));
 			spin_unlock_bh(&c->erase_completion_lock);
 			
 			ret = jffs2_garbage_collect_pass(c);
 			if (ret)
 				return ret;
 
-			cond_resched();
+			if (current->need_resched)
+				schedule();
 
 			if (signal_pending(current))
 				return -EINTR;
@@ -233,23 +120,9 @@
 	if (ret)
 		up(&c->alloc_sem);
 	return ret;
-#else
-	switch (prio) {
-	case ALLOC_NORMAL:
-		return jffs2_reserve_space_normal(c, minsize, ofs, len);
-
-	case ALLOC_DELETION:
-		return jffs2_reserve_space_deletion(c, minsize, ofs, len);
-
-	default:
-		printk("%s: prio = %d not supported\n", __func__, prio);
-		BUG();
-		return -EIO;
-	}
-#endif
 }
 
-int jffs2_reserve_space_gc(struct jffs2_sb_info *c, uint32_t minsize, uint32_t *ofs, uint32_t *len)
+int jffs2_reserve_space_gc(struct jffs2_sb_info *c, __u32 minsize, __u32 *ofs, __u32 *len)
 {
 	int ret = -EAGAIN;
 	minsize = PAD(minsize);
@@ -268,46 +141,20 @@
 }
 
 /* Called with alloc sem _and_ erase_completion_lock */
-static int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize, uint32_t *ofs, uint32_t *len)
+static int jffs2_do_reserve_space(struct jffs2_sb_info *c,  __u32 minsize, __u32 *ofs, __u32 *len)
 {
 	struct jffs2_eraseblock *jeb = c->nextblock;
 	
  restart:
 	if (jeb && minsize > jeb->free_size) {
 		/* Skip the end of this block and file it as having some dirty space */
-		/* If there's a pending write to it, flush now */
-		if (c->wbuf_len) {
-			spin_unlock_bh(&c->erase_completion_lock);
-			D1(printk(KERN_DEBUG "jffs2_do_reserve_space: Flushing write buffer\n"));			    
-			jffs2_flush_wbuf(c, 1);
-			spin_lock_bh(&c->erase_completion_lock);
-			/* We know nobody's going to have changed nextblock. Just continue */
-		}
-		c->wasted_size += jeb->free_size;
+		c->dirty_size += jeb->free_size;
 		c->free_size -= jeb->free_size;
-		jeb->wasted_size += jeb->free_size;
+		jeb->dirty_size += jeb->free_size;
 		jeb->free_size = 0;
-		
-		/* Check, if we have a dirty block now, or if it was dirty already */
-		if (ISDIRTY (jeb->wasted_size + jeb->dirty_size)) {
-			c->dirty_size += jeb->wasted_size;
-			c->wasted_size -= jeb->wasted_size;
-			jeb->dirty_size += jeb->wasted_size;
-			jeb->wasted_size = 0;
-			if (VERYDIRTY(c, jeb->dirty_size)) {
-				D1(printk(KERN_DEBUG "Adding full erase block at 0x%08x to very_dirty_list (free 0x%08x, dirty 0x%08x, used 0x%08x\n",
-				  jeb->offset, jeb->free_size, jeb->dirty_size, jeb->used_size));
-				list_add_tail(&jeb->list, &c->very_dirty_list);
-			} else {
-				D1(printk(KERN_DEBUG "Adding full erase block at 0x%08x to dirty_list (free 0x%08x, dirty 0x%08x, used 0x%08x\n",
-				  jeb->offset, jeb->free_size, jeb->dirty_size, jeb->used_size));
-				list_add_tail(&jeb->list, &c->dirty_list);
-			}
-		} else { 
-			D1(printk(KERN_DEBUG "Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\n",
+		D1(printk(KERN_DEBUG "Adding full erase block at 0x%08x to dirty_list (free 0x%08x, dirty 0x%08x, used 0x%08x\n",
 			  jeb->offset, jeb->free_size, jeb->dirty_size, jeb->used_size));
-			list_add_tail(&jeb->list, &c->clean_list);
-		}
+		list_add_tail(&jeb->list, &c->dirty_list);
 		c->nextblock = jeb = NULL;
 	}
 	
@@ -319,47 +166,20 @@
 
 			DECLARE_WAITQUEUE(wait, current);
 			
-			if (!c->nr_erasing_blocks && 
-			    !list_empty(&c->erasable_list)) {
-				struct jffs2_eraseblock *ejeb;
-
-				ejeb = list_entry(c->erasable_list.next, struct jffs2_eraseblock, list);
-				list_del(&ejeb->list);
-				list_add_tail(&ejeb->list, &c->erase_pending_list);
-				c->erasing_dirty_size += ejeb->dirty_size;
-				c->nr_erasing_blocks++;
-				jffs2_erase_pending_trigger(c);
-				D1(printk(KERN_DEBUG "jffs2_do_reserve_space: Triggering erase of erasable block at 0x%08x\n",
-					  ejeb->offset));
-			}
-
-			if (!c->nr_erasing_blocks && 
-			    !list_empty(&c->erasable_pending_wbuf_list)) {
-				D1(printk(KERN_DEBUG "jffs2_do_reserve_space: Flushing write buffer\n"));
-				/* c->nextblock is NULL, no update to c->nextblock allowed */			    
-				spin_unlock_bh(&c->erase_completion_lock);
-				jffs2_flush_wbuf(c, 1);
-				spin_lock_bh(&c->erase_completion_lock);
-				/* Have another go. It'll be on the erasable_list now */
-				return -EAGAIN;
-			}
-
 			if (!c->nr_erasing_blocks) {
+//			if (list_empty(&c->erasing_list) && list_empty(&c->erase_pending_list) && list_empty(c->erase_complete_list)) {
 				/* Ouch. We're in GC, or we wouldn't have got here.
 				   And there's no space left. At all. */
-				printk(KERN_CRIT "Argh. No free space left for GC. nr_erasing_blocks is %d. nr_free_blocks is %d. (erasableempty: %s, erasingempty: %s, erasependingempty: %s)\n", 
-				       c->nr_erasing_blocks, c->nr_free_blocks, list_empty(&c->erasable_list)?"yes":"no", 
-				       list_empty(&c->erasing_list)?"yes":"no", list_empty(&c->erase_pending_list)?"yes":"no");
-				printk(KERN_DEBUG "jffs2-doreserve-err: TIME=%lu, NR_AVAIL_BLOCKS=%d, dirty_size=%d, free_size=%d, erasing_size=%d, erasing_dirty_size=%d\n", jiffies, NR_AVAIL_BLOCKS(c), c->dirty_size, c->free_size, c->erasing_size, c->erasing_dirty_size);
+				printk(KERN_CRIT "Argh. No free space left for GC. nr_erasing_blocks is %d. nr_free_blocks is %d. (erasingempty: %s, erasependingempty: %s)\n", 
+				       c->nr_erasing_blocks, c->nr_free_blocks, list_empty(&c->erasing_list)?"yes":"no", list_empty(&c->erase_pending_list)?"yes":"no");
 				return -ENOSPC;
 			}
 			/* Make sure this can't deadlock. Someone has to start the erases
 			   of erase_pending blocks */
 			set_current_state(TASK_INTERRUPTIBLE);
 			add_wait_queue(&c->erase_wait, &wait);
-			D1(printk(KERN_DEBUG "Waiting for erases to complete. erasing_blocks is %d. (erasableempty: %s, erasingempty: %s, erasependingempty: %s)\n", 
-				  c->nr_erasing_blocks, list_empty(&c->erasable_list)?"yes":"no",
-				  list_empty(&c->erasing_list)?"yes":"no", list_empty(&c->erase_pending_list)?"yes":"no"));
+			D1(printk(KERN_DEBUG "Waiting for erases to complete. erasing_blocks is %d. (erasingempty: %s, erasependingempty: %s)\n", 
+				  c->nr_erasing_blocks, list_empty(&c->erasing_list)?"yes":"no", list_empty(&c->erase_pending_list)?"yes":"no"));
 			if (!list_empty(&c->erase_pending_list)) {
 				D1(printk(KERN_DEBUG "Triggering pending erases\n"));
 				jffs2_erase_pending_trigger(c);
@@ -381,8 +201,7 @@
 		list_del(next);
 		c->nextblock = jeb = list_entry(next, struct jffs2_eraseblock, list);
 		c->nr_free_blocks--;
-
-		if (jeb->free_size != c->sector_size - c->cleanmarker_size) {
+		if (jeb->free_size != c->sector_size - sizeof(struct jffs2_unknown_node)) {
 			printk(KERN_WARNING "Eep. Block 0x%08x taken from free_list had free_size of 0x%08x!!\n", jeb->offset, jeb->free_size);
 			goto restart;
 		}
@@ -391,20 +210,6 @@
 	   enough space */
 	*ofs = jeb->offset + (c->sector_size - jeb->free_size);
 	*len = jeb->free_size;
-
-	if (jeb->used_size == PAD(sizeof(struct jffs2_unknown_node)) &&
-	    !jeb->first_node->next_in_ino) {
-		/* Only node in it beforehand was a CLEANMARKER node (we think). 
-		   So mark it obsolete now that there's going to be another node
-		   in the block. This will reduce used_size to zero but We've 
-		   already set c->nextblock so that jffs2_mark_node_obsolete()
-		   won't try to refile it to the dirty_list.
-		*/
-		spin_unlock_bh(&c->erase_completion_lock);
-		jffs2_mark_node_obsolete(c, jeb->first_node);
-		spin_lock_bh(&c->erase_completion_lock);
-	}
-
 	D1(printk(KERN_DEBUG "jffs2_do_reserve_space(): Giving 0x%x bytes at 0x%x\n", *len, *ofs));
 	return 0;
 }
@@ -412,9 +217,9 @@
 /**
  *	jffs2_add_physical_node_ref - add a physical node reference to the list
  *	@c: superblock info
- *	@new: new node reference to add
+ *	@ofs: physical location of this physical node
  *	@len: length of this physical node
- *	@dirty: dirty flag for new node
+ *	@ino: inode number with which this physical node is associated
  *
  *	Should only be used to report nodes for which space has been allocated 
  *	by jffs2_reserve_space.
@@ -422,57 +227,48 @@
  *	Must be called with the alloc_sem held.
  */
  
-int jffs2_add_physical_node_ref(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *new)
+int jffs2_add_physical_node_ref(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *new, __u32 len, int dirty)
 {
 	struct jffs2_eraseblock *jeb;
-	uint32_t len = new->totlen;
 
-	jeb = &c->blocks[new->flash_offset / c->sector_size];
-	D1(printk(KERN_DEBUG "jffs2_add_physical_node_ref(): Node at 0x%x, size 0x%x\n", ref_offset(new), len));
+	len = PAD(len);
+	jeb = &c->blocks[(new->flash_offset & ~3) / c->sector_size];
+	D1(printk(KERN_DEBUG "jffs2_add_physical_node_ref(): Node at 0x%x, size 0x%x\n", new->flash_offset & ~3, len));
 #if 1
-	if (jeb != c->nextblock || (ref_offset(new)) != jeb->offset + (c->sector_size - jeb->free_size)) {
+	if (jeb != c->nextblock || (new->flash_offset & ~3) != jeb->offset + (c->sector_size - jeb->free_size)) {
 		printk(KERN_WARNING "argh. node added in wrong place\n");
 		jffs2_free_raw_node_ref(new);
 		return -EINVAL;
 	}
 #endif
-	spin_lock_bh(&c->erase_completion_lock);
-
 	if (!jeb->first_node)
 		jeb->first_node = new;
 	if (jeb->last_node)
 		jeb->last_node->next_phys = new;
 	jeb->last_node = new;
 
+	spin_lock_bh(&c->erase_completion_lock);
 	jeb->free_size -= len;
 	c->free_size -= len;
-	if (ref_obsolete(new)) {
+	if (dirty) {
+		new->flash_offset |= 1;
 		jeb->dirty_size += len;
 		c->dirty_size += len;
 	} else {
 		jeb->used_size += len;
 		c->used_size += len;
 	}
-
+	spin_unlock_bh(&c->erase_completion_lock);
 	if (!jeb->free_size && !jeb->dirty_size) {
 		/* If it lives on the dirty_list, jffs2_reserve_space will put it there */
 		D1(printk(KERN_DEBUG "Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\n",
 			  jeb->offset, jeb->free_size, jeb->dirty_size, jeb->used_size));
-		if (c->wbuf_len) {
-			/* Flush the last write in the block if it's outstanding */
-			spin_unlock_bh(&c->erase_completion_lock);
-			jffs2_flush_wbuf(c, 1);
-			spin_lock_bh(&c->erase_completion_lock);
-		}
-
 		list_add_tail(&jeb->list, &c->clean_list);
 		c->nextblock = NULL;
 	}
 	ACCT_SANITY_CHECK(c,jeb);
 	ACCT_PARANOIA_CHECK(jeb);
 
-	spin_unlock_bh(&c->erase_completion_lock);
-
 	return 0;
 }
 
@@ -490,14 +286,14 @@
 	int blocknr;
 	struct jffs2_unknown_node n;
 	int ret;
-	size_t retlen;
+	ssize_t retlen;
 
 	if(!ref) {
 		printk(KERN_NOTICE "EEEEEK. jffs2_mark_node_obsolete called with NULL node\n");
 		return;
 	}
-	if (ref_obsolete(ref)) {
-		D1(printk(KERN_DEBUG "jffs2_mark_node_obsolete called with already obsolete node at 0x%08x\n", ref_offset(ref)));
+	if (ref->flash_offset & 1) {
+		D1(printk(KERN_DEBUG "jffs2_mark_node_obsolete called with already obsolete node at 0x%08x\n", ref->flash_offset &~3));
 		return;
 	}
 	blocknr = ref->flash_offset / c->sector_size;
@@ -514,18 +310,10 @@
 
 	spin_lock_bh(&c->erase_completion_lock);
 	jeb->used_size -= ref->totlen;
+	jeb->dirty_size += ref->totlen;
 	c->used_size -= ref->totlen;
-
-	if ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + ref->totlen)) && jeb != c->nextblock) {
-		jeb->dirty_size += ref->totlen + jeb->wasted_size;
-		c->dirty_size += ref->totlen + jeb->wasted_size;
-		c->wasted_size -= jeb->wasted_size;
-		jeb->wasted_size = 0;
-	} else {
-		jeb->wasted_size += ref->totlen;
-		c->wasted_size += ref->totlen;	
-	}
-	ref->flash_offset = ref_offset(ref) | REF_OBSOLETE;
+	c->dirty_size += ref->totlen;
+	ref->flash_offset |= 1;
 	
 	ACCT_SANITY_CHECK(c, jeb);
 
@@ -540,281 +328,65 @@
 		spin_unlock_bh(&c->erase_completion_lock);
 		return;
 	}
-
 	if (jeb == c->nextblock) {
 		D2(printk(KERN_DEBUG "Not moving nextblock 0x%08x to dirty/erase_pending list\n", jeb->offset));
+	} else if (jeb == c->gcblock) {
+		D2(printk(KERN_DEBUG "Not moving gcblock 0x%08x to dirty/erase_pending list\n", jeb->offset));
+#if 0 /* We no longer do this here. It can screw the wear levelling. If you have a lot of static
+	 data and a few blocks free, and you just create new files and keep deleting/overwriting
+	 them, then you'd keep erasing and reusing those blocks without ever moving stuff around.
+	 So we leave completely obsoleted blocks on the dirty_list and let the GC delete them 
+	 when it finds them there. That way, we still get the 'once in a while, take a clean block'
+	 to spread out the flash usage */
 	} else if (!jeb->used_size) {
-		if (jeb == c->gcblock) {
-			D1(printk(KERN_DEBUG "gcblock at 0x%08x completely dirtied. Clearing gcblock...\n", jeb->offset));
-			c->gcblock = NULL;
-			c->flags &= ~JFFS2_SB_FLAG_GCING_A_BLOCK;
-		} else {
-			D1(printk(KERN_DEBUG "Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\n", jeb->offset));
-			list_del(&jeb->list);
-		}
-		if (c->wbuf_len) {
-			D1(printk(KERN_DEBUG "...and adding to erasable_pending_wbuf_list\n"));
-			list_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);
-
-			/* We've changed the rules slightly. After
-			   writing a node you now mustn't drop the
-			   alloc_sem before you've finished all the
-			   list management - this is so that when we
-			   get here, we know that no other nodes have
-			   been written, and the above check on wbuf
-			   is valid - wbuf_len is nonzero IFF the node
-			   which obsoletes this node is still in the
-			   wbuf.
-
-			   So we BUG() if that new rule is broken, to
-			   make sure we catch it and fix it.
-			*/
-			if (!down_trylock(&c->alloc_sem)) {
-				up(&c->alloc_sem);
-				printk(KERN_CRIT "jffs2_mark_node_obsolete() called with wbuf active but alloc_sem not locked!\n");
-				BUG();
-			}
-		} else {
-			if (jiffies & 127) {
-				/* Most of the time, we just erase it immediately. Otherwise we
-				   spend ages scanning it on mount, etc. */
-				D1(printk(KERN_DEBUG "...and adding to erase_pending_list\n"));
-				list_add_tail(&jeb->list, &c->erase_pending_list);
-				c->erasing_dirty_size += jeb->dirty_size;
-				c->nr_erasing_blocks++;
-				jffs2_erase_pending_trigger(c);
-			} else {
-				/* Sometimes, however, we leave it elsewhere so it doesn't get
-				   immediately reused, and we spread the load a bit. */
-				D1(printk(KERN_DEBUG "...and adding to erasable_list\n"));
-				list_add_tail(&jeb->list, &c->erasable_list);
-			}				
-		}
+		D1(printk(KERN_DEBUG "Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\n", jeb->offset));
+		list_del(&jeb->list);
+		D1(printk(KERN_DEBUG "...and adding to erase_pending_list\n"));
+		list_add_tail(&jeb->list, &c->erase_pending_list);
+		c->nr_erasing_blocks++;
+		jffs2_erase_pending_trigger(c);
+		//		OFNI_BS_2SFFJ(c)->s_dirt = 1;
 		D1(printk(KERN_DEBUG "Done OK\n"));
-	} else if (jeb == c->gcblock) {
-		D2(printk(KERN_DEBUG "Not moving gcblock 0x%08x to dirty_list\n", jeb->offset));
-	} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - ref->totlen)) {
+#endif
+	} else if (jeb->dirty_size == ref->totlen) {
 		D1(printk(KERN_DEBUG "Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\n", jeb->offset));
 		list_del(&jeb->list);
 		D1(printk(KERN_DEBUG "...and adding to dirty_list\n"));
 		list_add_tail(&jeb->list, &c->dirty_list);
-	} else if (VERYDIRTY(c, jeb->dirty_size) &&
-		   !VERYDIRTY(c, jeb->dirty_size - ref->totlen)) {
-		D1(printk(KERN_DEBUG "Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\n", jeb->offset));
-		list_del(&jeb->list);
-		D1(printk(KERN_DEBUG "...and adding to very_dirty_list\n"));
-		list_add_tail(&jeb->list, &c->very_dirty_list);
-	} else {
-		D1(printk(KERN_DEBUG "Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\n",
-			  jeb->offset, jeb->free_size, jeb->dirty_size, jeb->used_size)); 
-	}			  	
-
+	}
 	spin_unlock_bh(&c->erase_completion_lock);
 
-	if (!jffs2_can_mark_obsolete(c))
+	if (c->mtd->type != MTD_NORFLASH && c->mtd->type != MTD_RAM)
 		return;
-	if (jffs2_is_readonly(c))
+	if (OFNI_BS_2SFFJ(c)->s_flags & MS_RDONLY)
 		return;
 
-	D1(printk(KERN_DEBUG "obliterating obsoleted node at 0x%08x\n", ref_offset(ref)));
-	ret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);
+	D1(printk(KERN_DEBUG "obliterating obsoleted node at 0x%08x\n", ref->flash_offset &~3));
+	ret = c->mtd->read(c->mtd, ref->flash_offset &~3, sizeof(n), &retlen, (char *)&n);
 	if (ret) {
-		printk(KERN_WARNING "Read error reading from obsoleted node at 0x%08x: %d\n", ref_offset(ref), ret);
+		printk(KERN_WARNING "Read error reading from obsoleted node at 0x%08x: %d\n", ref->flash_offset &~3, ret);
 		return;
 	}
 	if (retlen != sizeof(n)) {
-		printk(KERN_WARNING "Short read from obsoleted node at 0x%08x: %d\n", ref_offset(ref), retlen);
+		printk(KERN_WARNING "Short read from obsoleted node at 0x%08x: %d\n", ref->flash_offset &~3, retlen);
 		return;
 	}
-	if (PAD(je32_to_cpu(n.totlen)) != PAD(ref->totlen)) {
-		printk(KERN_WARNING "Node totlen on flash (0x%08x) != totlen in node ref (0x%08x)\n", je32_to_cpu(n.totlen), ref->totlen);
+	if (PAD(n.totlen) != PAD(ref->totlen)) {
+		printk(KERN_WARNING "Node totlen on flash (0x%08x) != totlen in node ref (0x%08x)\n", n.totlen, ref->totlen);
 		return;
 	}
-	if (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {
-		D1(printk(KERN_DEBUG "Node at 0x%08x was already marked obsolete (nodetype 0x%04x\n", ref_offset(ref), je16_to_cpu(n.nodetype)));
+	if (!(n.nodetype & JFFS2_NODE_ACCURATE)) {
+		D1(printk(KERN_DEBUG "Node at 0x%08x was already marked obsolete (nodetype 0x%04x\n", ref->flash_offset &~3, n.nodetype));
 		return;
 	}
-	/* XXX FIXME: This is ugly now */
-	n.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);
-	ret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);
+	n.nodetype &= ~JFFS2_NODE_ACCURATE;
+	ret = c->mtd->write(c->mtd, ref->flash_offset&~3, sizeof(n), &retlen, (char *)&n);
 	if (ret) {
-		printk(KERN_WARNING "Write error in obliterating obsoleted node at 0x%08x: %d\n", ref_offset(ref), ret);
+		printk(KERN_WARNING "Write error in obliterating obsoleted node at 0x%08x: %d\n", ref->flash_offset &~3, ret);
 		return;
 	}
 	if (retlen != sizeof(n)) {
-		printk(KERN_WARNING "Short write in obliterating obsoleted node at 0x%08x: %d\n", ref_offset(ref), retlen);
+		printk(KERN_WARNING "Short write in obliterating obsoleted node at 0x%08x: %d\n", ref->flash_offset &~3, retlen);
 		return;
 	}
 }
-
-#if CONFIG_JFFS2_FS_DEBUG > 0
-void jffs2_dump_block_lists(struct jffs2_sb_info *c)
-{
-
-
-	printk(KERN_DEBUG "jffs2_dump_block_lists:\n");
-	printk(KERN_DEBUG "flash_size: %08x\n", c->flash_size);
-	printk(KERN_DEBUG "used_size: %08x\n", c->used_size);
-	printk(KERN_DEBUG "dirty_size: %08x\n", c->dirty_size);
-	printk(KERN_DEBUG "wasted_size: %08x\n", c->wasted_size);
-	printk(KERN_DEBUG "free_size: %08x\n", c->free_size);
-	printk(KERN_DEBUG "erasing_size: %08x\n", c->erasing_size);
-	printk(KERN_DEBUG "bad_size: %08x\n", c->bad_size);
-	printk(KERN_DEBUG "sector_size: %08x\n", c->sector_size);
-	printk(KERN_DEBUG "jffs2_reserved_blocks size: %08x\n",c->sector_size * JFFS2_RESERVED_BLOCKS_WRITE);
-
-	if (c->nextblock) {
-		printk(KERN_DEBUG "nextblock: %08x (used %08x, dirty %08x, wasted %08x, free %08x)\n", c->nextblock->offset, c->nextblock->used_size, c->nextblock->dirty_size, c->nextblock->wasted_size, c->nextblock->free_size);
-	} else {
-		printk(KERN_DEBUG "nextblock: NULL\n");
-	}
-	if (c->gcblock) {
-		printk(KERN_DEBUG "gcblock: %08x (used %08x, dirty %08x, wasted %08x, free %08x)\n", c->gcblock->offset, c->gcblock->used_size, c->gcblock->dirty_size, c->gcblock->wasted_size, c->gcblock->free_size);
-	} else {
-		printk(KERN_DEBUG "gcblock: NULL\n");
-	}
-	if (list_empty(&c->clean_list)) {
-		printk(KERN_DEBUG "clean_list: empty\n");
-	} else {
-		struct list_head *this;
-		int	numblocks = 0;
-		uint32_t dirty = 0;
-
-		list_for_each(this, &c->clean_list) {
-			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
-			numblocks ++;
-			dirty += jeb->wasted_size;
-#if 0
-			printk(KERN_DEBUG "clean_list: %08x (used %08x, dirty %08x, wasted %08x, free %08x)\n", jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size, jeb->free_size);
-#endif
-		}
-		printk (KERN_DEBUG "clean_list contains %d blocks with total wasted size %u, average wasted size: %u\n", numblocks, dirty, dirty / numblocks);
-	}
-	if (list_empty(&c->very_dirty_list)) {
-		printk(KERN_DEBUG "very_dirty_list: empty\n");
-	} else {
-		struct list_head *this;
-		int	numblocks = 0;
-		uint32_t dirty = 0;
-
-		list_for_each(this, &c->very_dirty_list) {
-			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
-			numblocks ++;
-			dirty += jeb->dirty_size;
-			printk(KERN_DEBUG "very_dirty_list: %08x (used %08x, dirty %08x, wasted %08x, free %08x)\n", jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size, jeb->free_size);
-		}
-		printk (KERN_DEBUG "Contains %d blocks with total dirty size %u, average dirty size: %u\n", numblocks, dirty, dirty / numblocks);
-	}
-	if (list_empty(&c->dirty_list)) {
-		printk(KERN_DEBUG "dirty_list: empty\n");
-	} else {
-		struct list_head *this;
-		int	numblocks = 0;
-		uint32_t dirty = 0;
-
-		list_for_each(this, &c->dirty_list) {
-			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
-			numblocks ++;
-			dirty += jeb->dirty_size;
-			printk(KERN_DEBUG "dirty_list: %08x (used %08x, dirty %08x, wasted %08x, free %08x)\n", jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size, jeb->free_size);
-		}
-		printk (KERN_DEBUG "Contains %d blocks with total dirty size %u, average dirty size: %u\n", numblocks, dirty, dirty / numblocks);
-	}
-	if (list_empty(&c->erasable_list)) {
-		printk(KERN_DEBUG "erasable_list: empty\n");
-	} else {
-		struct list_head *this;
-
-		list_for_each(this, &c->erasable_list) {
-			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
-			printk(KERN_DEBUG "erasable_list: %08x (used %08x, dirty %08x, wasted %08x, free %08x)\n", jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size, jeb->free_size);
-		}
-	}
-	if (list_empty(&c->erasing_list)) {
-		printk(KERN_DEBUG "erasing_list: empty\n");
-	} else {
-		struct list_head *this;
-
-		list_for_each(this, &c->erasing_list) {
-			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
-			printk(KERN_DEBUG "erasing_list: %08x (used %08x, dirty %08x, wasted %08x, free %08x)\n", jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size, jeb->free_size);
-		}
-	}
-	if (list_empty(&c->erase_pending_list)) {
-		printk(KERN_DEBUG "erase_pending_list: empty\n");
-	} else {
-		struct list_head *this;
-
-		list_for_each(this, &c->erase_pending_list) {
-			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
-			printk(KERN_DEBUG "erase_pending_list: %08x (used %08x, dirty %08x, wasted %08x, free %08x)\n", jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size, jeb->free_size);
-		}
-	}
-	if (list_empty(&c->erasable_pending_wbuf_list)) {
-		printk(KERN_DEBUG "erasable_pending_wbuf_list: empty\n");
-	} else {
-		struct list_head *this;
-
-		list_for_each(this, &c->erasable_pending_wbuf_list) {
-			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
-			printk(KERN_DEBUG "erase_pending_wbuf_list: %08x (used %08x, dirty %08x, wasted %08x, free %08x)\n", jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size, jeb->free_size);
-		}
-	}
-	if (list_empty(&c->free_list)) {
-		printk(KERN_DEBUG "free_list: empty\n");
-	} else {
-		struct list_head *this;
-#if 1
-		int i = 0;
-#endif
-
-		list_for_each(this, &c->free_list) {
-			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
-#if 0
-			printk(KERN_DEBUG "free_list: %08x (used %08x, dirty %08x, wasted %08x, free %08x)\n", jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size, jeb->free_size);
-#else
-			i++;
-#endif
-		}
-#if 1
-		printk(KERN_DEBUG "free_list: %u\n", i);
-#endif
-	}
-	if (list_empty(&c->bad_list)) {
-		printk(KERN_DEBUG "bad_list: empty\n");
-	} else {
-		struct list_head *this;
-
-		list_for_each(this, &c->bad_list) {
-			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
-			printk(KERN_DEBUG "bad_list: %08x (used %08x, dirty %08x, wasted %08x, free %08x)\n", jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size, jeb->free_size);
-		}
-	}
-	if (list_empty(&c->bad_used_list)) {
-		printk(KERN_DEBUG "bad_used_list: empty\n");
-	} else {
-		struct list_head *this;
-
-		list_for_each(this, &c->bad_used_list) {
-			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
-			printk(KERN_DEBUG "bad_used_list: %08x (used %08x, dirty %08x, wasted %08x, free %08x)\n", jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size, jeb->free_size);
-		}
-	}
-	if (list_empty(&c->nodemerge_list)) {
-		printk(KERN_DEBUG "nodemerge_list: empty\n");
-	} else {
-		struct list_head *this;
-
-		list_for_each(this, &c->nodemerge_list) {
-			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
-			printk(KERN_DEBUG "nodemereg_list: %08x (used %08x, dirty %08x, wasted %08x, free %08x)\n", jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size, jeb->free_size);
-		}
-	}
-}
-#endif /* CONFIG_JFFS2_FS_DEBUG */
-
-/*
- * Local variables:
- *   c-basic-offset: 8
- * End:
- */
diff -Nur linux/fs/jffs2/os-linux.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/os-linux.h
--- linux/fs/jffs2/os-linux.h	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/os-linux.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,155 +0,0 @@
-/*
- * JFFS2 -- Journalling Flash File System, Version 2.
- *
- * Copyright (C) 2002 Red Hat, Inc.
- *
- * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
- *
- * For licensing information, see the file 'LICENCE' in this directory.
- *
- * $Id: os-linux.h,v 1.19 2002/05/20 14:56:38 dwmw2 Exp $
- *
- * ChangeLog:
- *     19-Nov-2002 Lineo Japan, Inc.  add counter of fragtree elements
- */
-
-#ifndef __JFFS2_OS_LINUX_H__
-#define __JFFS2_OS_LINUX_H__
-#include <linux/version.h>
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,2)
-#define JFFS2_INODE_INFO(i) (list_entry(i, struct jffs2_inode_info, vfs_inode))
-#define OFNI_EDONI_2SFFJ(f)  (&(f)->vfs_inode)
-#define JFFS2_SB_INFO(sb) (sb->u.generic_sbp)
-#define OFNI_BS_2SFFJ(c)  ((struct super_block *)c->os_priv)
-#elif defined(JFFS2_OUT_OF_KERNEL)
-#define JFFS2_INODE_INFO(i) ((struct jffs2_inode_info *) &(i)->u)
-#define OFNI_EDONI_2SFFJ(f)  ((struct inode *) ( ((char *)f) - ((char *)(&((struct inode *)NULL)->u)) ) )
-#define JFFS2_SB_INFO(sb) ((struct jffs2_sb_info *) &(sb)->u)
-#define OFNI_BS_2SFFJ(c)  ((struct super_block *) ( ((char *)c) - ((char *)(&((struct super_block *)NULL)->u)) ) )
-#else
-#define JFFS2_INODE_INFO(i) (&i->u.jffs2_i)
-#define OFNI_EDONI_2SFFJ(f)  ((struct inode *) ( ((char *)f) - ((char *)(&((struct inode *)NULL)->u)) ) )
-#define JFFS2_SB_INFO(sb) (&sb->u.jffs2_sb)
-#define OFNI_BS_2SFFJ(c)  ((struct super_block *) ( ((char *)c) - ((char *)(&((struct super_block *)NULL)->u)) ) )
-#endif
-
-
-#define JFFS2_F_I_SIZE(f) (OFNI_EDONI_2SFFJ(f)->i_size)
-#define JFFS2_F_I_MODE(f) (OFNI_EDONI_2SFFJ(f)->i_mode)
-#define JFFS2_F_I_UID(f) (OFNI_EDONI_2SFFJ(f)->i_uid)
-#define JFFS2_F_I_GID(f) (OFNI_EDONI_2SFFJ(f)->i_gid)
-#define JFFS2_F_I_CTIME(f) (OFNI_EDONI_2SFFJ(f)->i_ctime)
-#define JFFS2_F_I_MTIME(f) (OFNI_EDONI_2SFFJ(f)->i_mtime)
-#define JFFS2_F_I_ATIME(f) (OFNI_EDONI_2SFFJ(f)->i_atime)
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,1)
-#define JFFS2_F_I_RDEV_MIN(f) (minor(OFNI_EDONI_2SFFJ(f)->i_rdev))
-#define JFFS2_F_I_RDEV_MAJ(f) (major(OFNI_EDONI_2SFFJ(f)->i_rdev))
-#else
-#define JFFS2_F_I_RDEV_MIN(f) (MINOR(to_kdev_t(OFNI_EDONI_2SFFJ(f)->i_rdev)))
-#define JFFS2_F_I_RDEV_MAJ(f) (MAJOR(to_kdev_t(OFNI_EDONI_2SFFJ(f)->i_rdev)))
-#endif
-
-static inline void jffs2_init_inode_info(struct jffs2_inode_info *f)
-{
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,2)
-	f->highest_version = 0;
-	f->fraglist = NULL;
-	f->metadata = NULL;
-	f->dents = NULL;
-	f->flags = 0;
-	f->usercompr = 0;
-#ifdef CONFIG_JFFS2_DYNFRAGTREE
-	f->nr_frags = 0;
-#endif
-#else
-	memset(f, 0, sizeof(*f));
-	init_MUTEX_LOCKED(&f->sem);
-#endif
-}
-
-#define jffs2_is_readonly(c) (OFNI_BS_2SFFJ(c)->s_flags & MS_RDONLY)
-
-#ifndef CONFIG_JFFS2_FS_NAND
-#define jffs2_can_mark_obsolete(c) (1)
-#define jffs2_cleanmarker_oob(c) (0)
-#define jffs2_write_nand_cleanmarker(c,jeb) (-EIO)
-
-#define jffs2_flash_write(c, ofs, len, retlen, buf) ((c)->mtd->write((c)->mtd, ofs, len, retlen, buf))
-#define jffs2_flash_read(c, ofs, len, retlen, buf) ((c)->mtd->read((c)->mtd, ofs, len, retlen, buf))
-#define jffs2_flush_wbuf(c, flag) do { ; } while(0)
-#define jffs2_nand_read_failcnt(c,jeb) do { ; } while(0)
-#define jffs2_write_nand_badblock(c,jeb) do { ; } while(0)
-#define jffs2_flash_writev jffs2_flash_direct_writev
-#define jffs2_wbuf_timeout NULL
-#define jffs2_wbuf_process NULL
-
-#else /* NAND support present */
-
-#define jffs2_can_mark_obsolete(c) (c->mtd->type == MTD_NORFLASH || c->mtd->type == MTD_RAM)
-#define jffs2_cleanmarker_oob(c) (c->mtd->type == MTD_NANDFLASH)
-
-#define jffs2_flash_write_oob(c, ofs, len, retlen, buf) ((c)->mtd->write_oob((c)->mtd, ofs, len, retlen, buf))
-#define jffs2_flash_read_oob(c, ofs, len, retlen, buf) ((c)->mtd->read_oob((c)->mtd, ofs, len, retlen, buf))
-
-
-/* wbuf.c */
-int jffs2_flash_writev(struct jffs2_sb_info *c, const struct iovec *vecs, unsigned long count, loff_t to, size_t *retlen);
-int jffs2_flash_write(struct jffs2_sb_info *c, loff_t ofs, size_t len, size_t *retlen, const u_char *buf);
-int jffs2_flash_read(struct jffs2_sb_info *c, loff_t ofs, size_t len, size_t *retlen, u_char *buf);
-int jffs2_check_oob_empty(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,int mode);
-int jffs2_check_nand_cleanmarker(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);
-int jffs2_write_nand_cleanmarker(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);
-int jffs2_write_nand_badblock(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);
-void jffs2_wbuf_timeout(unsigned long data);
-void jffs2_wbuf_process(void *data);
-#endif /* NAND */
-
-/* background.c */
-int jffs2_start_garbage_collect_thread(struct jffs2_sb_info *c);
-void jffs2_stop_garbage_collect_thread(struct jffs2_sb_info *c);
-void jffs2_garbage_collect_trigger(struct jffs2_sb_info *c);
-
-/* dir.c */
-extern struct file_operations jffs2_dir_operations;
-extern struct inode_operations jffs2_dir_inode_operations;
-
-/* file.c */
-extern struct file_operations jffs2_file_operations;
-extern struct inode_operations jffs2_file_inode_operations;
-extern struct address_space_operations jffs2_file_address_operations;
-int jffs2_fsync(struct file *, struct dentry *, int);
-int jffs2_setattr (struct dentry *dentry, struct iattr *iattr);
-int jffs2_do_readpage_nolock (struct inode *inode, struct page *pg);
-int jffs2_do_readpage_unlock (struct inode *inode, struct page *pg);
-int jffs2_readpage (struct file *, struct page *);
-int jffs2_prepare_write (struct file *, struct page *, unsigned, unsigned);
-int jffs2_commit_write (struct file *, struct page *, unsigned, unsigned);
-
-/* ioctl.c */
-int jffs2_ioctl(struct inode *, struct file *, unsigned int, unsigned long);
-
-/* symlink.c */
-extern struct inode_operations jffs2_symlink_inode_operations;
-
-/* fs.c */
-void jffs2_read_inode (struct inode *);
-void jffs2_clear_inode (struct inode *);
-struct inode *jffs2_new_inode (struct inode *dir_i, int mode,
-			       struct jffs2_raw_inode *ri);
-int jffs2_statfs (struct super_block *, struct statfs *);
-void jffs2_write_super (struct super_block *);
-int jffs2_remount_fs (struct super_block *, int *, char *);
-int jffs2_do_fill_super(struct super_block *sb, void *data, int silent);
-
-/* writev.c */
-int jffs2_flash_direct_writev(struct jffs2_sb_info *c, const struct iovec *vecs, 
-		       unsigned long count, loff_t to, size_t *retlen);
-
-/* super.c */
-
-
-#endif /* __JFFS2_OS_LINUX_H__ */
-
-
diff -Nur linux/fs/jffs2/pushpull.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/pushpull.c
--- linux/fs/jffs2/pushpull.c	1970-01-01 07:00:00.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/pushpull.c	2003-06-23 01:47:04.000000000 +0700
@@ -0,0 +1,71 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
+ *
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
+ *
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: pushpull.c,v 1.7 2001/09/23 10:04:15 rmk Exp $
+ *
+ */
+
+#include <linux/string.h>
+#include "pushpull.h"
+#include <linux/errno.h>
+
+void init_pushpull(struct pushpull *pp, char *buf, unsigned buflen, unsigned ofs, unsigned reserve)
+{
+	pp->buf = buf;
+	pp->buflen = buflen;
+	pp->ofs = ofs;
+	pp->reserve = reserve;
+}
+     
+
+int pushbit(struct pushpull *pp, int bit, int use_reserved)
+{
+	if (pp->ofs >= pp->buflen - (use_reserved?0:pp->reserve)) {
+		return -ENOSPC;
+	}
+
+	if (bit) {
+		pp->buf[pp->ofs >> 3] |= (1<<(7-(pp->ofs &7)));
+	}
+	else {
+		pp->buf[pp->ofs >> 3] &= ~(1<<(7-(pp->ofs &7)));
+	}
+	pp->ofs++;
+
+	return 0;
+}
+
+int pushedbits(struct pushpull *pp)
+{
+	return pp->ofs;
+}
diff -Nur linux/fs/jffs2/pushpull.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/pushpull.h
--- linux/fs/jffs2/pushpull.h	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/pushpull.h	2003-06-23 01:47:04.000000000 +0700
@@ -1,21 +1,42 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
+ * Copyright (C) 2001 Red Hat, Inc.
  *
  * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: pushpull.h,v 1.8 2002/05/20 14:56:38 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: pushpull.h,v 1.5 2001/09/23 10:04:15 rmk Exp $
  *
  */
 
 #ifndef __PUSHPULL_H__
 #define __PUSHPULL_H__
-
-#include <linux/errno.h>
-
 struct pushpull {
 	unsigned char *buf;
 	unsigned int buflen;
@@ -23,36 +44,9 @@
 	unsigned int reserve;
 };
 
-
-static inline void init_pushpull(struct pushpull *pp, char *buf, unsigned buflen, unsigned ofs, unsigned reserve)
-{
-	pp->buf = buf;
-	pp->buflen = buflen;
-	pp->ofs = ofs;
-	pp->reserve = reserve;
-}
-
-static inline int pushbit(struct pushpull *pp, int bit, int use_reserved)
-{
-	if (pp->ofs >= pp->buflen - (use_reserved?0:pp->reserve)) {
-		return -ENOSPC;
-	}
-
-	if (bit) {
-		pp->buf[pp->ofs >> 3] |= (1<<(7-(pp->ofs &7)));
-	}
-	else {
-		pp->buf[pp->ofs >> 3] &= ~(1<<(7-(pp->ofs &7)));
-	}
-	pp->ofs++;
-
-	return 0;
-}
-
-static inline int pushedbits(struct pushpull *pp)
-{
-	return pp->ofs;
-}
+void init_pushpull(struct pushpull *, char *, unsigned, unsigned, unsigned);
+int pushbit(struct pushpull *pp, int bit, int use_reserved);
+int pushedbits(struct pushpull *pp);
 
 static inline int pullbit(struct pushpull *pp)
 {
diff -Nur linux/fs/jffs2/read.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/read.c
--- linux/fs/jffs2/read.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/read.c	2003-06-23 01:47:04.000000000 +0700
@@ -1,31 +1,52 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
+ * Copyright (C) 2001 Red Hat, Inc.
  *
  * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: read.c,v 1.27 2002/09/06 14:12:44 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
  *
- * ChangeLog:
- *     18-Nov-2002 Lineo Japan, Inc.  add dynamic construction of fragtree
+ * $Id: read.c,v 1.13.2.1 2002/02/01 23:32:33 dwmw2 Exp $
  *
  */
 
 #include <linux/kernel.h>
 #include <linux/slab.h>
-#include "crc32.h"
-#include <linux/pagemap.h>
+#include <linux/jffs2.h>
 #include <linux/mtd/mtd.h>
 #include "nodelist.h"
+#include "crc32.h"
 
 int jffs2_read_dnode(struct jffs2_sb_info *c, struct jffs2_full_dnode *fd, unsigned char *buf, int ofs, int len)
 {
 	struct jffs2_raw_inode *ri;
 	size_t readlen;
-	uint32_t crc;
+	__u32 crc;
 	unsigned char *decomprbuf = NULL;
 	unsigned char *readbuf = NULL;
 	int ret = 0;
@@ -34,41 +55,35 @@
 	if (!ri)
 		return -ENOMEM;
 
-	ret = jffs2_flash_read(c, ref_offset(fd->raw), sizeof(*ri), &readlen, (char *)ri);
+	ret = c->mtd->read(c->mtd, fd->raw->flash_offset & ~3, sizeof(*ri), &readlen, (char *)ri);
 	if (ret) {
 		jffs2_free_raw_inode(ri);
-		printk(KERN_WARNING "Error reading node from 0x%08x: %d\n", ref_offset(fd->raw), ret);
+		printk(KERN_WARNING "Error reading node from 0x%08x: %d\n", fd->raw->flash_offset & ~3, ret);
 		return ret;
 	}
 	if (readlen != sizeof(*ri)) {
 		jffs2_free_raw_inode(ri);
 		printk(KERN_WARNING "Short read from 0x%08x: wanted 0x%x bytes, got 0x%x\n", 
-		       ref_offset(fd->raw), sizeof(*ri), readlen);
+		       fd->raw->flash_offset & ~3, sizeof(*ri), readlen);
 		return -EIO;
 	}
 	crc = crc32(0, ri, sizeof(*ri)-8);
 
-	D1(printk(KERN_DEBUG "Node read from %08x: node_crc %08x, calculated CRC %08x. dsize %x, csize %x, offset %x, buf %p\n",
-		  ref_offset(fd->raw), je32_to_cpu(ri->node_crc),
-		  crc, je32_to_cpu(ri->dsize), je32_to_cpu(ri->csize),
-		  je32_to_cpu(ri->offset), buf));
-	if (crc != je32_to_cpu(ri->node_crc)) {
-		printk(KERN_WARNING "Node CRC %08x != calculated CRC %08x for node at %08x\n",
-		       je32_to_cpu(ri->node_crc), crc, ref_offset(fd->raw));
+	D1(printk(KERN_DEBUG "Node read from %08x: node_crc %08x, calculated CRC %08x. dsize %x, csize %x, offset %x, buf %p\n", fd->raw->flash_offset & ~3, ri->node_crc, crc, ri->dsize, ri->csize, ri->offset, buf));
+	if (crc != ri->node_crc) {
+		printk(KERN_WARNING "Node CRC %08x != calculated CRC %08x for node at %08x\n", ri->node_crc, crc, fd->raw->flash_offset & ~3);
 		ret = -EIO;
 		goto out_ri;
 	}
 	/* There was a bug where we wrote hole nodes out with csize/dsize
 	   swapped. Deal with it */
-	if (ri->compr == JFFS2_COMPR_ZERO && !je32_to_cpu(ri->dsize) && 
-	    je32_to_cpu(ri->csize)) {
+	if (ri->compr == JFFS2_COMPR_ZERO && !ri->dsize && ri->csize) {
 		ri->dsize = ri->csize;
-		ri->csize = cpu_to_je32(0);
+		ri->csize = 0;
 	}
 
-	D1(if(ofs + len > je32_to_cpu(ri->dsize)) {
-		printk(KERN_WARNING "jffs2_read_dnode() asked for %d bytes at %d from %d-byte node\n",
-		       len, ofs, je32_to_cpu(ri->dsize));
+	D1(if(ofs + len > ri->dsize) {
+		printk(KERN_WARNING "jffs2_read_dnode() asked for %d bytes at %d from %d-byte node\n", len, ofs, ri->dsize);
 		ret = -EINVAL;
 		goto out_ri;
 	});
@@ -85,18 +100,18 @@
 	   Reading partial node and it's uncompressed - read into readbuf, check CRC, and copy 
 	   Reading partial node and it's compressed - read into readbuf, check checksum, decompress to decomprbuf and copy
 	*/
-	if (ri->compr == JFFS2_COMPR_NONE && len == je32_to_cpu(ri->dsize)) {
+	if (ri->compr == JFFS2_COMPR_NONE && len == ri->dsize) {
 		readbuf = buf;
 	} else {
-		readbuf = kmalloc(je32_to_cpu(ri->csize), GFP_KERNEL);
+		readbuf = kmalloc(ri->csize, GFP_KERNEL);
 		if (!readbuf) {
 			ret = -ENOMEM;
 			goto out_ri;
 		}
 	}
 	if (ri->compr != JFFS2_COMPR_NONE) {
-		if (len < je32_to_cpu(ri->dsize)) {
-			decomprbuf = kmalloc(je32_to_cpu(ri->dsize), GFP_KERNEL);
+		if (len < ri->dsize) {
+			decomprbuf = kmalloc(ri->dsize, GFP_KERNEL);
 			if (!decomprbuf) {
 				ret = -ENOMEM;
 				goto out_readbuf;
@@ -108,34 +123,31 @@
 		decomprbuf = readbuf;
 	}
 
-	D2(printk(KERN_DEBUG "Read %d bytes to %p\n", je32_to_cpu(ri->csize),
-		  readbuf));
-	ret = jffs2_flash_read(c, (ref_offset(fd->raw)) + sizeof(*ri),
-			       je32_to_cpu(ri->csize), &readlen, readbuf);
+	D2(printk(KERN_DEBUG "Read %d bytes to %p\n", ri->csize, readbuf));
+	ret = c->mtd->read(c->mtd, (fd->raw->flash_offset &~3) + sizeof(*ri), ri->csize, &readlen, readbuf);
 
-	if (!ret && readlen != je32_to_cpu(ri->csize))
+	if (!ret && readlen != ri->csize)
 		ret = -EIO;
 	if (ret)
 		goto out_decomprbuf;
 
-	crc = crc32(0, readbuf, je32_to_cpu(ri->csize));
-	if (crc != je32_to_cpu(ri->data_crc)) {
-		printk(KERN_WARNING "Data CRC %08x != calculated CRC %08x for node at %08x\n",
-		       je32_to_cpu(ri->data_crc), crc, ref_offset(fd->raw));
+	crc = crc32(0, readbuf, ri->csize);
+	if (crc != ri->data_crc) {
+		printk(KERN_WARNING "Data CRC %08x != calculated CRC %08x for node at %08x\n", ri->data_crc, crc, fd->raw->flash_offset & ~3);
 		ret = -EIO;
 		goto out_decomprbuf;
 	}
 	D2(printk(KERN_DEBUG "Data CRC matches calculated CRC %08x\n", crc));
 	if (ri->compr != JFFS2_COMPR_NONE) {
-		D2(printk(KERN_DEBUG "Decompress %d bytes from %p to %d bytes at %p\n", ri->csize, readbuf, je32_to_cpu(ri->dsize), decomprbuf)); 
-		ret = jffs2_decompress(ri->compr, readbuf, decomprbuf, je32_to_cpu(ri->csize), je32_to_cpu(ri->dsize));
+		D2(printk(KERN_DEBUG "Decompress %d bytes from %p to %d bytes at %p\n", ri->csize, readbuf, ri->dsize, decomprbuf)); 
+		ret = jffs2_decompress(ri->compr, readbuf, decomprbuf, ri->csize, ri->dsize);
 		if (ret) {
 			printk(KERN_WARNING "Error: jffs2_decompress returned %d\n", ret);
 			goto out_decomprbuf;
 		}
 	}
 
-	if (len < je32_to_cpu(ri->dsize)) {
+	if (len < ri->dsize) {
 		memcpy(buf, decomprbuf+ofs, len);
 	}
  out_decomprbuf:
@@ -149,103 +161,3 @@
 
 	return ret;
 }
-
-int jffs2_read_inode_range(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
-			   unsigned char *buf, uint32_t offset, uint32_t len)
-{
-	uint32_t end = offset + len;
-	struct jffs2_node_frag *frag;
-	int ret;
-
-	D1(printk(KERN_DEBUG "jffs2_read_inode_range: ino #%u, range 0x%08x-0x%08x\n",
-		  f->inocache->ino, offset, offset+len));
-
-	ret = jffs2_construct_fragtree_nolock_if_missing(c, f);
-	if (ret) {
-		memset(buf, 0, len);
-		return ret;
-	}
-
-	frag = jffs2_lookup_node_frag(&f->fragtree, offset);
-
-	/* XXX FIXME: Where a single physical node actually shows up in two
-	   frags, we read it twice. Don't do that. */
-	/* Now we're pointing at the first frag which overlaps our page */
-	while(offset < end) {
-		D2(printk(KERN_DEBUG "jffs2_read_inode_range: offset %d, end %d\n", offset, end));
-		if (!frag || frag->ofs > offset) {
-			uint32_t holesize = end - offset;
-			if (frag) {
-				D1(printk(KERN_NOTICE "Eep. Hole in ino #%u fraglist. frag->ofs = 0x%08x, offset = 0x%08x\n", f->inocache->ino, frag->ofs, offset));
-				holesize = min(holesize, frag->ofs - offset);
-				D1(jffs2_print_frag_list(f));
-			}
-			D1(printk(KERN_DEBUG "Filling non-frag hole from %d-%d\n", offset, offset+holesize));
-			memset(buf, 0, holesize);
-			buf += holesize;
-			offset += holesize;
-			continue;
-		} else if (frag->ofs < offset && (offset & (PAGE_CACHE_SIZE-1)) != 0) {
-			D1(printk(KERN_NOTICE "Eep. Overlap in ino #%u fraglist. frag->ofs = 0x%08x, offset = 0x%08x\n",
-				  f->inocache->ino, frag->ofs, offset));
-			D1(jffs2_print_frag_list(f));
-			memset(buf, 0, end - offset);
-			return -EIO;
-		} else if (!frag->node) {
-			uint32_t holeend = min(end, frag->ofs + frag->size);
-			D1(printk(KERN_DEBUG "Filling frag hole from %d-%d (frag 0x%x 0x%x)\n", offset, holeend, frag->ofs, frag->ofs + frag->size));
-			memset(buf, 0, holeend - offset);
-			buf += holeend - offset;
-			offset = holeend;
-			frag = frag_next(frag);
-			continue;
-		} else {
-			uint32_t readlen;
-			readlen = min(frag->size, end - offset);
-			D1(printk(KERN_DEBUG "Reading %d-%d from node at 0x%x\n", frag->ofs, frag->ofs+readlen, ref_offset(frag->node->raw)));
-			ret = jffs2_read_dnode(c, frag->node, buf, frag->ofs - frag->node->ofs, readlen);
-			D2(printk(KERN_DEBUG "node read done\n"));
-			if (ret) {
-				D1(printk(KERN_DEBUG"jffs2_read_inode_range error %d\n",ret));
-				memset(buf, 0, frag->size);
-				return ret;
-			}
-		}
-		buf += frag->size;
-		offset += frag->size;
-		frag = frag_next(frag);
-		D2(printk(KERN_DEBUG "node read was OK. Looping\n"));
-	}
-	return 0;
-}
-
-/* Core function to read symlink target. */
-char *jffs2_getlink(struct jffs2_sb_info *c, struct jffs2_inode_info *f)
-{
-	char *buf;
-	int ret;
-
-	down(&f->sem);
-
-	if (!f->metadata) {
-		printk(KERN_NOTICE "No metadata for symlink inode #%u\n", f->inocache->ino);
-		up(&f->sem);
-		return ERR_PTR(-EINVAL);
-	}
-	buf = kmalloc(f->metadata->size+1, GFP_USER);
-	if (!buf) {
-		up(&f->sem);
-		return ERR_PTR(-ENOMEM);
-	}
-	buf[f->metadata->size]=0;
-
-	ret = jffs2_read_dnode(c, f->metadata, buf, 0, f->metadata->size);
-
-	up(&f->sem);
-
-	if (ret) {
-		kfree(buf);
-		return ERR_PTR(ret);
-	}
-	return buf;
-}
diff -Nur linux/fs/jffs2/readinode.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/readinode.c
--- linux/fs/jffs2/readinode.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/readinode.c	2003-06-23 01:47:04.000000000 +0700
@@ -1,88 +1,75 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
+ * Copyright (C) 2001 Red Hat, Inc.
  *
  * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: readinode.c,v 1.90 2002/09/06 16:46:29 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
  *
- * ChangeLog:
- *   19-Nov-2002 Lineo Japan, Inc.  add counter of fragtree elements
- *   18-Nov-2002 Lineo Japan, Inc.  add dynamic construction of fragtree
- *   15-Nov-2002 Lineo Japan, Inc.  add nodemerge facility
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
  *
- * ChangeLog:
- *   05-Dec-2002 SHARP  nodemerge-thershold is changable
- *   19-Nov-2002 Lineo Japan, Inc.  add counter of fragtree elements
- *   18-Nov-2002 Lineo Japan, Inc.  add dynamic construction of fragtree
- *   15-Nov-2002 Lineo Japan, Inc.  add nodemerge facility
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: readinode.c,v 1.58.2.5 2002/03/05 22:40:03 dwmw2 Exp $
  *
  */
 
+/* Given an inode, probably with existing list of fragments, add the new node
+ * to the fragment list.
+ */
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/fs.h>
-#include "crc32.h"
-#include <linux/pagemap.h>
 #include <linux/mtd/mtd.h>
-#include <linux/interrupt.h>
+#include <linux/jffs2.h>
 #include "nodelist.h"
-#include "nodemerge.h"
+#include "crc32.h"
 
 
-D1(static void jffs2_print_fragtree(rb_root_t *list, int permitbug)
+D1(void jffs2_print_frag_list(struct jffs2_inode_info *f)
 {
-	struct jffs2_node_frag *this = frag_first(list);
-	uint32_t lastofs = 0;
-	int buggy = 0;
+	struct jffs2_node_frag *this = f->fraglist;
 
 	while(this) {
 		if (this->node)
-			printk(KERN_DEBUG "frag %04x-%04x: 0x%08x on flash (*%p). left (%p), right (%p), parent (%p)\n", this->ofs, this->ofs+this->size, ref_offset(this->node->raw), this, frag_left(this), frag_right(this), frag_parent(this));
+			printk(KERN_DEBUG "frag %04x-%04x: 0x%08x on flash (*%p->%p)\n", this->ofs, this->ofs+this->size, this->node->raw->flash_offset &~3, this, this->next);
 		else 
-			printk(KERN_DEBUG "frag %04x-%04x: hole (*%p). left (%p} right (%p), parent (%p)\n", this->ofs, this->ofs+this->size, this, frag_left(this), frag_right(this), frag_parent(this));
-		if (this->ofs != lastofs)
-			buggy = 1;
-		lastofs = this->ofs+this->size;
-		this = frag_next(this);
-	}
-	if (buggy && !permitbug) {
-		printk(KERN_CRIT "Frag tree got a hole in it\n");
-		BUG();
+			printk(KERN_DEBUG "frag %04x-%04x: hole (*%p->%p)\n", this->ofs, this->ofs+this->size, this, this->next);
+		this = this->next;
 	}
-})
-
-D1(void jffs2_print_frag_list(struct jffs2_inode_info *f)
-{
-	jffs2_print_fragtree(&f->fragtree, 0);
-
 	if (f->metadata) {
-		printk(KERN_DEBUG "metadata at 0x%08x\n", ref_offset(f->metadata->raw));
+		printk(KERN_DEBUG "metadata at 0x%08x\n", f->metadata->raw->flash_offset &~3);
 	}
 })
 
 
-/* Given an inode, probably with existing list of fragments, add the new node
- * to the fragment list.
- */
 int jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_full_dnode *fn)
 {
 	int ret;
-
 	D1(printk(KERN_DEBUG "jffs2_add_full_dnode_to_inode(ino #%u, f %p, fn %p)\n", f->inocache->ino, f, fn));
 
-#ifdef CONFIG_JFFS2_DYNFRAGTREE
-	{
-		int added_frags = 0;
-		ret = jffs2_add_full_dnode_to_fraglist_1(c, &f->fragtree, fn, &added_frags);
-		if (! ret) f->nr_frags += added_frags;
-	}
-#else
-	ret = jffs2_add_full_dnode_to_fraglist(c, &f->fragtree, fn);
-#endif
+	ret = jffs2_add_full_dnode_to_fraglist(c, &f->fraglist, fn);
 
 	D2(jffs2_print_frag_list(f));
 	return ret;
@@ -95,14 +82,13 @@
 		if (!this->node->frags) {
 			/* The node has no valid frags left. It's totally obsoleted */
 			D2(printk(KERN_DEBUG "Marking old node @0x%08x (0x%04x-0x%04x) obsolete\n",
-				  ref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size));
+				  this->node->raw->flash_offset &~3, this->node->ofs, this->node->ofs+this->node->size));
 			jffs2_mark_node_obsolete(c, this->node->raw);
 			jffs2_free_full_dnode(this->node);
 		} else {
-			D2(printk(KERN_DEBUG "Marking old node @0x%08x (0x%04x-0x%04x) REF_NORMAL. frags is %d\n",
-				  ref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size,
+			D2(printk(KERN_DEBUG "Not marking old node @0x%08x (0x%04x-0x%04x) obsolete. frags is %d\n",
+				  this->node->raw->flash_offset &~3, this->node->ofs, this->node->ofs+this->node->size,
 				  this->node->frags));
-			mark_ref_normal(this->node->raw);
 		}
 		
 	}
@@ -110,28 +96,27 @@
 }
 
 /* Doesn't set inode->i_size */
-#ifdef CONFIG_JFFS2_DYNFRAGTREE
-int jffs2_add_full_dnode_to_fraglist_1(struct jffs2_sb_info *c, rb_root_t *list, struct jffs2_full_dnode *fn, int* added_frags)
-#else
-int jffs2_add_full_dnode_to_fraglist(struct jffs2_sb_info *c, rb_root_t *list, struct jffs2_full_dnode *fn)
-#endif
+int jffs2_add_full_dnode_to_fraglist(struct jffs2_sb_info *c, struct jffs2_node_frag **list, struct jffs2_full_dnode *fn)
 {
-	struct jffs2_node_frag *this;
-	struct jffs2_node_frag *newfrag;
-	uint32_t lastend;
+	
+	struct jffs2_node_frag *this, **prev, *old;
+	struct jffs2_node_frag *newfrag, *newfrag2;
+	__u32 lastend = 0;
+
 
 	newfrag = jffs2_alloc_node_frag();
 	if (!newfrag) {
 		return -ENOMEM;
 	}
 
-	if (!fn->raw) {
-		printk(KERN_WARNING "dwmw2 is stupid. j_a_f_d_t_f should never happen with ->raw == NULL\n");
-		BUG();
-	}
-
-	D2(printk(KERN_DEBUG "adding node %04x-%04x @0x%08x on flash, newfrag *%p\n", fn->ofs, fn->ofs+fn->size, ref_offset(fn->raw), newfrag));
+	D2(if (fn->raw)
+		printk(KERN_DEBUG "adding node %04x-%04x @0x%08x on flash, newfrag *%p\n", fn->ofs, fn->ofs+fn->size, fn->raw->flash_offset &~3, newfrag);
+	else
+		printk(KERN_DEBUG "adding hole node %04x-%04x on flash, newfrag *%p\n", fn->ofs, fn->ofs+fn->size, newfrag));
 	
+	prev = list;
+	this = *list;
+
 	if (!fn->size) {
 		jffs2_free_node_frag(newfrag);
 		return 0;
@@ -141,33 +126,21 @@
 	newfrag->size = fn->size;
 	newfrag->node = fn;
 	newfrag->node->frags = 1;
+	newfrag->next = (void *)0xdeadbeef;
 
 	/* Skip all the nodes which are completed before this one starts */
-	this = jffs2_lookup_node_frag(list, fn->ofs);
-
-	if (this) {
-		D2(printk(KERN_DEBUG "j_a_f_d_t_f: Lookup gave frag 0x%04x-0x%04x; phys 0x%08x (*%p)\n",
-			  this->ofs, this->ofs+this->size, this->node?(ref_offset(this->node->raw)):0xffffffff, this));
+	while(this && fn->ofs >= this->ofs+this->size) {
 		lastend = this->ofs + this->size;
-	} else {
-		D2(printk(KERN_DEBUG "j_a_f_d_t_f: Lookup gave no frag\n"));
-		lastend = 0;
+
+		D2(printk(KERN_DEBUG "j_a_f_d_t_f: skipping frag 0x%04x-0x%04x; phys 0x%08x (*%p->%p)\n", 
+			  this->ofs, this->ofs+this->size, this->node?(this->node->raw->flash_offset &~3):0xffffffff, this, this->next));
+		prev = &this->next;
+		this = this->next;
 	}
-			  
+
 	/* See if we ran off the end of the list */
-	if (lastend <= newfrag->ofs) {
+	if (!this) {
 		/* We did */
-
-		/* Check if 'this' node was on the same page as the new node.
-		   If so, both 'this' and the new node get marked REF_NORMAL so
-		   the GC can take a look.
-		*/
-		if ((lastend-1) >> PAGE_CACHE_SHIFT == newfrag->ofs >> PAGE_CACHE_SHIFT) {
-			if (this->node)
-				mark_ref_normal(this->node->raw);
-			mark_ref_normal(fn->raw);
-		}
-
 		if (lastend < fn->ofs) {
 			/* ... and we need to put a hole in before the new node */
 			struct jffs2_node_frag *holefrag = jffs2_alloc_node_frag();
@@ -175,223 +148,154 @@
 				return -ENOMEM;
 			holefrag->ofs = lastend;
 			holefrag->size = fn->ofs - lastend;
+			holefrag->next = NULL;
 			holefrag->node = NULL;
-			if (this) {
-				/* By definition, the 'this' node has no right-hand child, 
-				   because there are no frags with offset greater than it.
-				   So that's where we want to put the hole */
-				D2(printk(KERN_DEBUG "Adding hole frag (%p) on right of node at (%p)\n", holefrag, this));
-				rb_link_node(&holefrag->rb, &this->rb, &this->rb.rb_right);
-			} else {
-				D2(printk(KERN_DEBUG "Adding hole frag (%p) at root of tree\n", holefrag));
-				rb_link_node(&holefrag->rb, NULL, &list->rb_node);
-			}
-			rb_insert_color(&holefrag->rb, list);
-			ADDED_FRAGS_INC();
-			this = holefrag;
-		}
-		if (this) {
-			/* By definition, the 'this' node has no right-hand child, 
-			   because there are no frags with offset greater than it.
-			   So that's where we want to put the hole */
-			D2(printk(KERN_DEBUG "Adding new frag (%p) on right of node at (%p)\n", newfrag, this));
-			rb_link_node(&newfrag->rb, &this->rb, &this->rb.rb_right);			
-		} else {
-			D2(printk(KERN_DEBUG "Adding new frag (%p) at root of tree\n", newfrag));
-			rb_link_node(&newfrag->rb, NULL, &list->rb_node);
+			*prev = holefrag;
+			prev = &holefrag->next;
 		}
-		rb_insert_color(&newfrag->rb, list);
-		ADDED_FRAGS_INC();
+		newfrag->next = NULL;
+		*prev = newfrag;
 		return 0;
 	}
 
-	D2(printk(KERN_DEBUG "j_a_f_d_t_f: dealing with frag 0x%04x-0x%04x; phys 0x%08x (*%p)\n", 
-		  this->ofs, this->ofs+this->size, this->node?(ref_offset(this->node->raw)):0xffffffff, this));
+	D2(printk(KERN_DEBUG "j_a_f_d_t_f: dealing with frag 0x%04x-0x%04x; phys 0x%08x (*%p->%p)\n", 
+		  this->ofs, this->ofs+this->size, this->node?(this->node->raw->flash_offset &~3):0xffffffff, this, this->next));
 
-	/* OK. 'this' is pointing at the first frag that newfrag->ofs at least partially obsoletes,
-	 * - i.e. newfrag->ofs < this->ofs+this->size && newfrag->ofs >= this->ofs  
+	/* OK. 'this' is pointing at the first frag that fn->ofs at least partially obsoletes,
+	 * - i.e. fn->ofs < this->ofs+this->size && fn->ofs >= this->ofs  
 	 */
-	if (newfrag->ofs > this->ofs) {
+	if (fn->ofs > this->ofs) {
 		/* This node isn't completely obsoleted. The start of it remains valid */
-
-		/* Mark the new node and the partially covered node REF_NORMAL -- let 
-		   the GC take a look at them */
-		mark_ref_normal(fn->raw);
-		if (this->node)
-			mark_ref_normal(this->node->raw);
-
-		if (this->ofs + this->size > newfrag->ofs + newfrag->size) {
+		if (this->ofs + this->size > fn->ofs + fn->size) {
 			/* The new node splits 'this' frag into two */
-			struct jffs2_node_frag *newfrag2 = jffs2_alloc_node_frag();
+			newfrag2 = jffs2_alloc_node_frag();
 			if (!newfrag2) {
 				jffs2_free_node_frag(newfrag);
 				return -ENOMEM;
 			}
-			D2(printk(KERN_DEBUG "split old frag 0x%04x-0x%04x -->", this->ofs, this->ofs+this->size);
+			D1(printk(KERN_DEBUG "split old frag 0x%04x-0x%04x -->", this->ofs, this->ofs+this->size);
 			if (this->node)
-				printk("phys 0x%08x\n", ref_offset(this->node->raw));
+				printk("phys 0x%08x\n", this->node->raw->flash_offset &~3);
 			else 
 				printk("hole\n");
 			   )
-			
-			/* New second frag pointing to this's node */
-			newfrag2->ofs = newfrag->ofs + newfrag->size;
+			newfrag2->ofs = fn->ofs + fn->size;
 			newfrag2->size = (this->ofs+this->size) - newfrag2->ofs;
+			newfrag2->next = this->next;
 			newfrag2->node = this->node;
 			if (this->node)
 				this->node->frags++;
-
-			/* Adjust size of original 'this' */
+			newfrag->next = newfrag2;
+			this->next = newfrag;
 			this->size = newfrag->ofs - this->ofs;
-
-			/* Now, we know there's no node with offset
-			   greater than this->ofs but smaller than
-			   newfrag2->ofs or newfrag->ofs, for obvious
-			   reasons. So we can do a tree insert from
-			   'this' to insert newfrag, and a tree insert
-			   from newfrag to insert newfrag2. */
-			jffs2_fragtree_insert(newfrag, this);
-			rb_insert_color(&newfrag->rb, list);
-			ADDED_FRAGS_INC();
-			
-			jffs2_fragtree_insert(newfrag2, newfrag);
-			rb_insert_color(&newfrag2->rb, list);
-			ADDED_FRAGS_INC();
-			
 			return 0;
 		}
 		/* New node just reduces 'this' frag in size, doesn't split it */
-		this->size = newfrag->ofs - this->ofs;
-
-		/* Again, we know it lives down here in the tree */
-		jffs2_fragtree_insert(newfrag, this);
-		rb_insert_color(&newfrag->rb, list);
-		ADDED_FRAGS_INC();
+		this->size = fn->ofs - this->ofs;
+		newfrag->next = this->next;
+		this->next = newfrag;
+		this = newfrag->next;
 	} else {
-		/* New frag starts at the same point as 'this' used to. Replace 
-		   it in the tree without doing a delete and insertion */
-		D2(printk(KERN_DEBUG "Inserting newfrag (*%p),%d-%d in before 'this' (*%p),%d-%d\n",
-			  newfrag, newfrag->ofs, newfrag->ofs+newfrag->size,
-			  this, this->ofs, this->ofs+this->size));
-	
-		rb_replace_node(&this->rb, &newfrag->rb, list);
-		
-		if (newfrag->ofs + newfrag->size >= this->ofs+this->size) {
-			D2(printk("Obsoleting node frag %p (%x-%x)\n", this, this->ofs, this->ofs+this->size));
-			jffs2_obsolete_node_frag(c, this);
-		} else {
-			this->ofs += newfrag->size;
-			this->size -= newfrag->size;
-
-			jffs2_fragtree_insert(this, newfrag);
-			rb_insert_color(&this->rb, list);
-			ADDED_FRAGS_INC();
-			return 0;
-		}
+		D2(printk(KERN_DEBUG "Inserting newfrag (*%p) in before 'this' (*%p)\n", newfrag, this));
+		*prev = newfrag;
+	        newfrag->next = this;
 	}
-	/* OK, now we have newfrag added in the correct place in the tree, but
-	   frag_next(newfrag) may be a fragment which is overlapped by it 
+	/* OK, now we have newfrag added in the correct place in the list, but
+	   newfrag->next points to a fragment which may be overlapping it
 	*/
-	while ((this = frag_next(newfrag)) && newfrag->ofs + newfrag->size >= this->ofs + this->size) {
-		/* 'this' frag is obsoleted completely. */
-		D2(printk("Obsoleting node frag %p (%x-%x) and removing from tree\n", this, this->ofs, this->ofs+this->size));
-		rb_erase(&this->rb, list);
-		jffs2_obsolete_node_frag(c, this);
-		ADDED_FRAGS_DEC();
+	while (this && newfrag->ofs + newfrag->size >= this->ofs + this->size) {
+		/* 'this' frag is obsoleted. */
+		old = this;
+		this = old->next;
+		jffs2_obsolete_node_frag(c, old);
 	}
 	/* Now we're pointing at the first frag which isn't totally obsoleted by 
 	   the new frag */
+	newfrag->next = this;
 
 	if (!this || newfrag->ofs + newfrag->size == this->ofs) {
 		return 0;
 	}
-	/* Still some overlap but we don't need to move it in the tree */
+	/* Still some overlap */
 	this->size = (this->ofs + this->size) - (newfrag->ofs + newfrag->size);
 	this->ofs = newfrag->ofs + newfrag->size;
-
-	/* And mark them REF_NORMAL so the GC takes a look at them */
-	if (this->node)
-		mark_ref_normal(this->node->raw);
-	mark_ref_normal(fn->raw);
-
 	return 0;
 }
 
-int jffs2_truncate_fraglist_1 (struct jffs2_sb_info *c, rb_root_t *list, uint32_t size)
+void jffs2_truncate_fraglist (struct jffs2_sb_info *c, struct jffs2_node_frag **list, __u32 size)
 {
-	struct jffs2_node_frag *frag = jffs2_lookup_node_frag(list, size);
-	int count = 0;
-
 	D1(printk(KERN_DEBUG "Truncating fraglist to 0x%08x bytes\n", size));
 
-	/* We know frag->ofs <= size. That's what lookup does for us */
-	if (frag && frag->ofs != size) {
-		if (frag->ofs+frag->size >= size) {
-			D1(printk(KERN_DEBUG "Truncating frag 0x%08x-0x%08x\n", frag->ofs, frag->ofs+frag->size));
-			frag->size = size - frag->ofs;
-		}
-		frag = frag_next(frag);
-	}
-	while (frag && frag->ofs >= size) {
-		struct jffs2_node_frag *next = frag_next(frag);
-
-		D1(printk(KERN_DEBUG "Removing frag 0x%08x-0x%08x\n", frag->ofs, frag->ofs+frag->size));
-		frag_erase(frag, list);
-		jffs2_obsolete_node_frag(c, frag);
-#ifdef CONFIG_JFFS2_DYNFRAGTREE
-		count++;
-#endif
-		frag = next;
+	while (*list) {
+		if ((*list)->ofs >= size) {
+			struct jffs2_node_frag *this = *list;
+			*list = this->next;
+			D1(printk(KERN_DEBUG "Removing frag 0x%08x-0x%08x\n", this->ofs, this->ofs+this->size));
+			jffs2_obsolete_node_frag(c, this);
+			continue;
+		} else if ((*list)->ofs + (*list)->size > size) {
+			D1(printk(KERN_DEBUG "Truncating frag 0x%08x-0x%08x\n", (*list)->ofs, (*list)->ofs + (*list)->size));
+			(*list)->size = size - (*list)->ofs;
+		}
+		list = &(*list)->next;
 	}
-
-	return count;
 }
 
 /* Scan the list of all nodes present for this ino, build map of versions, etc. */
 
-int jffs2_do_read_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, 
-			uint32_t ino, struct jffs2_raw_inode *latest_node)
+void jffs2_read_inode (struct inode *inode)
 {
 	struct jffs2_tmp_dnode_info *tn_list, *tn;
 	struct jffs2_full_dirent *fd_list;
+	struct jffs2_inode_info *f;
 	struct jffs2_full_dnode *fn = NULL;
-	uint32_t crc;
-	uint32_t latest_mctime, mctime_ver;
-	uint32_t mdata_ver = 0;
-	size_t retlen;
+	struct jffs2_sb_info *c;
+	struct jffs2_raw_inode latest_node;
+	__u32 latest_mctime, mctime_ver;
+	__u32 mdata_ver = 0;
 	int ret;
+	ssize_t retlen;
 
-	D2(printk(KERN_DEBUG "jffs2_do_read_inode(): getting inocache\n"));
+	D1(printk(KERN_DEBUG "jffs2_read_inode(): inode->i_ino == %lu\n", inode->i_ino));
 
-	f->inocache = jffs2_get_ino_cache(c, ino);
+	f = JFFS2_INODE_INFO(inode);
+	c = JFFS2_SB_INFO(inode->i_sb);
 
-	D2(printk(KERN_DEBUG "jffs2_do_read_inode(): Got inocache at %p\n", f->inocache));
+	memset(f, 0, sizeof(*f));
+	D2(printk(KERN_DEBUG "getting inocache\n"));
+	init_MUTEX(&f->sem);
+	f->inocache = jffs2_get_ino_cache(c, inode->i_ino);
+	D2(printk(KERN_DEBUG "jffs2_read_inode(): Got inocache at %p\n", f->inocache));
 
-	if (!f->inocache && ino == 1) {
+	if (!f->inocache && inode->i_ino == 1) {
 		/* Special case - no root inode on medium */
 		f->inocache = jffs2_alloc_inode_cache();
 		if (!f->inocache) {
-			printk(KERN_CRIT "jffs2_do_read_inode(): Cannot allocate inocache for root inode\n");
-			return -ENOMEM;
+			printk(KERN_CRIT "jffs2_read_inode(): Cannot allocate inocache for root inode\n");
+			make_bad_inode(inode);
+			return;
 		}
-		D1(printk(KERN_DEBUG "jffs2_do_read_inode(): Creating inocache for root inode\n"));
+		D1(printk(KERN_DEBUG "jffs2_read_inode(): Creating inocache for root inode\n"));
 		memset(f->inocache, 0, sizeof(struct jffs2_inode_cache));
 		f->inocache->ino = f->inocache->nlink = 1;
 		f->inocache->nodes = (struct jffs2_raw_node_ref *)f->inocache;
 		jffs2_add_ino_cache(c, f->inocache);
 	}
 	if (!f->inocache) {
-		printk(KERN_WARNING "jffs2_do_read_inode() on nonexistent ino %u\n", ino);
-		return -ENOENT;
+		printk(KERN_WARNING "jffs2_read_inode() on nonexistent ino %lu\n", (unsigned long)inode->i_ino);
+		make_bad_inode(inode);
+		return;
 	}
-	D1(printk(KERN_DEBUG "jffs2_do_read_inode(): ino #%u nlink is %d\n", ino, f->inocache->nlink));
+	D1(printk(KERN_DEBUG "jffs2_read_inode(): ino #%lu nlink is %d\n", (unsigned long)inode->i_ino, f->inocache->nlink));
+	inode->i_nlink = f->inocache->nlink;
 
 	/* Grab all nodes relevant to this ino */
-	ret = jffs2_get_inode_nodes(c, ino, f, &tn_list, &fd_list, &f->highest_version, &latest_mctime, &mctime_ver);
+	ret = jffs2_get_inode_nodes(c, inode->i_ino, f, &tn_list, &fd_list, &f->highest_version, &latest_mctime, &mctime_ver);
 
 	if (ret) {
-		printk(KERN_CRIT "jffs2_get_inode_nodes() for ino %u returned %d\n", ino, ret);
-		return ret;
+		printk(KERN_CRIT "jffs2_get_inode_nodes() for ino %lu returned %d\n", inode->i_ino, ret);
+		make_bad_inode(inode);
+		return;
 	}
 	f->dents = fd_list;
 
@@ -401,7 +305,7 @@
 		fn = tn->fn;
 
 		if (f->metadata && tn->version > mdata_ver) {
-			D1(printk(KERN_DEBUG "Obsoleting old metadata at 0x%08x\n", ref_offset(f->metadata->raw)));
+			D1(printk(KERN_DEBUG "Obsoleting old metadata at 0x%08x\n", f->metadata->raw->flash_offset &~3));
 			jffs2_mark_node_obsolete(c, f->metadata->raw);
 			jffs2_free_full_dnode(f->metadata);
 			f->metadata = NULL;
@@ -413,7 +317,7 @@
 			jffs2_add_full_dnode_to_inode(c, f, fn);
 		} else {
 			/* Zero-sized node at end of version list. Just a metadata update */
-			D1(printk(KERN_DEBUG "metadata @%08x: ver %d\n", ref_offset(fn->raw), tn->version));
+			D1(printk(KERN_DEBUG "metadata @%08x: ver %d\n", fn->raw->flash_offset &~3, tn->version));
 			f->metadata = fn;
 			mdata_ver = tn->version;
 		}
@@ -422,137 +326,175 @@
 	}
 	if (!fn) {
 		/* No data nodes for this inode. */
-		if (ino != 1) {
-			printk(KERN_WARNING "jffs2_do_read_inode(): No data nodes found for ino #%u\n", ino);
+		if (inode->i_ino != 1) {
+			printk(KERN_WARNING "jffs2_read_inode(): No data nodes found for ino #%lu\n", inode->i_ino);
 			if (!fd_list) {
-				return -EIO;
+				make_bad_inode(inode);
+				return;
 			}
-			printk(KERN_WARNING "jffs2_do_read_inode(): But it has children so we fake some modes for it\n");
+			printk(KERN_WARNING "jffs2_read_inode(): But it has children so we fake some modes for it\n");
 		}
-		latest_node->mode = cpu_to_je32(S_IFDIR|S_IRUGO|S_IWUSR|S_IXUGO);
-		latest_node->version = cpu_to_je32(0);
-		latest_node->atime = latest_node->ctime = latest_node->mtime = cpu_to_je32(0);
-		latest_node->isize = cpu_to_je32(0);
-		latest_node->gid = cpu_to_je16(0);
-		latest_node->uid = cpu_to_je16(0);
-		return 0;
-	}
+		inode->i_mode = S_IFDIR | S_IRUGO | S_IWUSR | S_IXUGO;
+		latest_node.version = 0;
+		inode->i_atime = inode->i_ctime = inode->i_mtime = CURRENT_TIME;
+		inode->i_nlink = f->inocache->nlink;
+		inode->i_size = 0;
+	} else {
+		__u32 crc;
 
-	ret = jffs2_flash_read(c, ref_offset(fn->raw), sizeof(*latest_node), &retlen, (void *)latest_node);
-	if (ret || retlen != sizeof(*latest_node)) {
-		printk(KERN_NOTICE "MTD read in jffs2_do_read_inode() failed: Returned %d, %ld of %d bytes read\n",
-		       ret, (long)retlen, sizeof(*latest_node));
-		/* FIXME: If this fails, there seems to be a memory leak. Find it. */
-		up(&f->sem);
-		jffs2_do_clear_inode(c, f);
-		return ret?ret:-EIO;
-	}
-
-	crc = crc32(0, latest_node, sizeof(*latest_node)-8);
-	if (crc != je32_to_cpu(latest_node->node_crc)) {
-		printk(KERN_NOTICE "CRC failed for read_inode of inode %u at physical location 0x%x\n", ino, ref_offset(fn->raw));
-		up(&f->sem);
-		jffs2_do_clear_inode(c, f);
-		return -EIO;
-	}
+		ret = c->mtd->read(c->mtd, fn->raw->flash_offset & ~3, sizeof(latest_node), &retlen, (void *)&latest_node);
+		if (ret || retlen != sizeof(latest_node)) {
+			printk(KERN_NOTICE "MTD read in jffs2_read_inode() failed: Returned %d, %ld of %d bytes read\n",
+			       ret, (long)retlen, sizeof(latest_node));
+			jffs2_clear_inode(inode);
+			make_bad_inode(inode);
+			return;
+		}
+
+		crc = crc32(0, &latest_node, sizeof(latest_node)-8);
+		if (crc != latest_node.node_crc) {
+			printk(KERN_NOTICE "CRC failed for read_inode of inode %ld at physical location 0x%x\n", inode->i_ino, fn->raw->flash_offset & ~3);
+			jffs2_clear_inode(inode);
+			make_bad_inode(inode);
+			return;
+		}
+
+		inode->i_mode = latest_node.mode;
+		inode->i_uid = latest_node.uid;
+		inode->i_gid = latest_node.gid;
+		inode->i_size = latest_node.isize;
+		if (S_ISREG(inode->i_mode))
+			jffs2_truncate_fraglist(c, &f->fraglist, latest_node.isize);
+		inode->i_atime = latest_node.atime;
+		inode->i_mtime = latest_node.mtime;
+		inode->i_ctime = latest_node.ctime;
+	}
+
+	/* OK, now the special cases. Certain inode types should
+	   have only one data node, and it's kept as the metadata
+	   node */
+	if (S_ISBLK(inode->i_mode) || S_ISCHR(inode->i_mode) ||
+	    S_ISLNK(inode->i_mode)) {
+		if (f->metadata) {
+			printk(KERN_WARNING "Argh. Special inode #%lu with mode 0%o had metadata node\n", inode->i_ino, inode->i_mode);
+			jffs2_clear_inode(inode);
+			make_bad_inode(inode);
+			return;
+		}
+		if (!f->fraglist) {
+			printk(KERN_WARNING "Argh. Special inode #%lu with mode 0%o has no fragments\n", inode->i_ino, inode->i_mode);
+			jffs2_clear_inode(inode);
+			make_bad_inode(inode);
+			return;
+		}
+		/* ASSERT: f->fraglist != NULL */
+		if (f->fraglist->next) {
+			printk(KERN_WARNING "Argh. Special inode #%lu with mode 0%o had more than one node\n", inode->i_ino, inode->i_mode);
+			/* FIXME: Deal with it - check crc32, check for duplicate node, check times and discard the older one */
+			jffs2_clear_inode(inode);
+			make_bad_inode(inode);
+			return;
+		}
+		/* OK. We're happy */
+		f->metadata = f->fraglist->node;
+		jffs2_free_node_frag(f->fraglist);
+		f->fraglist = NULL;
+	}			
+	    
+	inode->i_blksize = PAGE_SIZE;
+	inode->i_blocks = (inode->i_size + 511) >> 9;
+	
+	switch (inode->i_mode & S_IFMT) {
+		unsigned short rdev;
 
-	switch(je32_to_cpu(latest_node->mode) & S_IFMT) {
+	case S_IFLNK:
+		inode->i_op = &jffs2_symlink_inode_operations;
+		/* Hack to work around broken isize in old symlink code.
+		   Remove this when dwmw2 comes to his senses and stops
+		   symlinks from being an entirely gratuitous special
+		   case. */
+		if (!inode->i_size)
+			inode->i_size = latest_node.dsize;
+		break;
+		
 	case S_IFDIR:
-		if (mctime_ver > je32_to_cpu(latest_node->version)) {
+		if (mctime_ver > latest_node.version) {
 			/* The times in the latest_node are actually older than
 			   mctime in the latest dirent. Cheat. */
-			latest_node->ctime = latest_node->mtime = cpu_to_je32(latest_mctime);
+			inode->i_mtime = inode->i_ctime = inode->i_atime = 
+				latest_mctime;
 		}
+		inode->i_op = &jffs2_dir_inode_operations;
+		inode->i_fop = &jffs2_dir_operations;
 		break;
 
-			
 	case S_IFREG:
-		/* If it was a regular file, truncate it to the latest node's isize */
-		jffs2_truncate_fraglist(c, f, je32_to_cpu(latest_node->isize));
-		jffs2_merge_nodes(c, f, je32_to_cpu(latest_node->isize), JFFS2_FRAGS_NR_NODES_THRESHOLD_NORMAL);
+		inode->i_op = &jffs2_file_inode_operations;
+		inode->i_fop = &jffs2_file_operations;
+		inode->i_mapping->a_ops = &jffs2_file_address_operations;
+		inode->i_mapping->nrpages = 0;
 		break;
 
-	case S_IFLNK:
-		/* Hack to work around broken isize in old symlink code.
-		   Remove this when dwmw2 comes to his senses and stops
-		   symlinks from being an entirely gratuitous special
-		   case. */
-		if (!je32_to_cpu(latest_node->isize))
-			latest_node->isize = latest_node->dsize;
-		/* fall through... */
-
 	case S_IFBLK:
 	case S_IFCHR:
-		/* Xertain inode types should have only one data node, and it's
-		   kept as the metadata node */
-		if (f->metadata) {
-			printk(KERN_WARNING "Argh. Special inode #%u with mode 0%o had metadata node\n", ino, je32_to_cpu(latest_node->mode));
-			up(&f->sem);
-			jffs2_do_clear_inode(c, f);
-			return -EIO;
-		}
-		if (!frag_first(&f->fragtree)) {
-			printk(KERN_WARNING "Argh. Special inode #%u with mode 0%o has no fragments\n", ino, je32_to_cpu(latest_node->mode));
-			up(&f->sem);
-			jffs2_do_clear_inode(c, f);
-			return -EIO;
-		}
-		/* ASSERT: f->fraglist != NULL */
-		if (frag_next(frag_first(&f->fragtree))) {
-			printk(KERN_WARNING "Argh. Special inode #%u with mode 0%o had more than one node\n", ino, je32_to_cpu(latest_node->mode));
-			/* FIXME: Deal with it - check crc32, check for duplicate node, check times and discard the older one */
-			up(&f->sem);
-			jffs2_do_clear_inode(c, f);
-			return -EIO;
-		}
-		/* OK. We're happy */
-		f->metadata = frag_first(&f->fragtree)->node;
-		jffs2_free_node_frag(frag_first(&f->fragtree));
-		f->fragtree = RB_ROOT;
+		/* Read the device numbers from the media */
+		D1(printk(KERN_DEBUG "Reading device numbers from flash\n"));
+		if (jffs2_read_dnode(c, f->metadata, (char *)&rdev, 0, sizeof(rdev)) < 0) {
+			/* Eep */
+			printk(KERN_NOTICE "Read device numbers for inode %lu failed\n", (unsigned long)inode->i_ino);
+			jffs2_clear_inode(inode);
+			make_bad_inode(inode);
+			return;
+		}			
+
+	case S_IFSOCK:
+	case S_IFIFO:
+		inode->i_op = &jffs2_file_inode_operations;
+		init_special_inode(inode, inode->i_mode, kdev_t_to_nr(MKDEV(rdev>>8, rdev&0xff)));
 		break;
-	}
 
-	return 0;
+	default:
+		printk(KERN_WARNING "jffs2_read_inode(): Bogus imode %o for ino %lu", inode->i_mode, (unsigned long)inode->i_ino);
+	}
+	D1(printk(KERN_DEBUG "jffs2_read_inode() returning\n"));
 }
 
-void jffs2_do_clear_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f)
+void jffs2_clear_inode (struct inode *inode)
 {
+	/* We can forget about this inode for now - drop all 
+	 *  the nodelists associated with it, etc.
+	 */
+	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
+	struct jffs2_node_frag *frag, *frags;
 	struct jffs2_full_dirent *fd, *fds;
-	/* I don't think we care about the potential race due to reading this
-	   without f->sem. It can never get undeleted. */
-	int deleted = f->inocache && !f->inocache->nlink;
-
-	/* If it's a deleted inode, grab the alloc_sem. This prevents
-	   jffs2_garbage_collect_pass() from deciding that it wants to
-	   garbage collect one of the nodes we're just about to mark 
-	   obsolete -- by the time we drop alloc_sem and return, all
-	   the nodes are marked obsolete, and jffs2_g_c_pass() won't
-	   call iget() for the inode in question.
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
 
-	   We also do this to keep the (maybe temporary) BUG() in 
-	   jffs2_mark_node_obsolete() from triggering. 
-	*/
-	if(deleted)
-		down(&c->alloc_sem);
+	D1(printk(KERN_DEBUG "jffs2_clear_inode(): ino #%lu mode %o\n", inode->i_ino, inode->i_mode));
 
 	down(&f->sem);
 
+	frags = f->fraglist;
+	fds = f->dents;
 	if (f->metadata) {
-		if (deleted)
+		if (!f->inocache->nlink)
 			jffs2_mark_node_obsolete(c, f->metadata->raw);
 		jffs2_free_full_dnode(f->metadata);
 	}
 
-	if (deleted) {
-		if (jffs2_construct_fragtree_nolock_if_missing(c, f))
-			printk(KERN_WARNING "%s: ino #%lu cannot clear\n", __func__,
-			       OFNI_EDONI_2SFFJ(f)->i_ino);
-	}
-	jffs2_kill_fragtree(&f->fragtree, deleted?c:NULL);
-	CLEAR_NR_FRAGS(f);
-
-	fds = f->dents;
+	while (frags) {
+		frag = frags;
+		frags = frag->next;
+		D2(printk(KERN_DEBUG "jffs2_clear_inode: frag at 0x%x-0x%x: node %p, frags %d--\n", frag->ofs, frag->ofs+frag->size, frag->node, frag->node?frag->node->frags:0));
+
+		if (frag->node && !(--frag->node->frags)) {
+			/* Not a hole, and it's the final remaining frag of this node. Free the node */
+			if (!f->inocache->nlink)
+				jffs2_mark_node_obsolete(c, frag->node->raw);
 
+			jffs2_free_full_dnode(frag->node);
+		}
+		jffs2_free_node_frag(frag);
+	}
 	while(fds) {
 		fd = fds;
 		fds = fd->next;
@@ -560,7 +502,5 @@
 	}
 
 	up(&f->sem);
+};
 
-	if(deleted)
-		up(&c->alloc_sem);
-}
diff -Nur linux/fs/jffs2/scan.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/scan.c
--- linux/fs/jffs2/scan.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/scan.c	2003-06-23 01:47:04.000000000 +0700
@@ -1,28 +1,47 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
+ * Copyright (C) 2001 Red Hat, Inc.
  *
  * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: scan.c,v 1.91 2002/09/09 07:47:53 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: scan.c,v 1.51.2.2 2002/02/23 13:34:31 dwmw2 Exp $
  *
- * ChangeLog:
- *     29-Oct-2002 Lineo Japan, Inc.  add member struct jffs2_sb_info#nr_bad_blocks
- *     01-Oct-2002 Lineo Japan, Inc.  remove double reads from NAND flash
- *     13-Sep-2002 Lineo Japan, Inc.  remove warning message for NAND flash
  */
 #include <linux/kernel.h>
 #include <linux/slab.h>
+#include <linux/jffs2.h>
 #include <linux/mtd/mtd.h>
 #include <linux/pagemap.h>
-#include <linux/compiler.h>
-#include "crc32.h"
 #include "nodelist.h"
+#include "crc32.h"
 
-#define EMPTY_SCAN_SIZE 1024
 
 #define DIRTY_SPACE(x) do { typeof(x) _x = (x); \
 		c->free_size -= _x; c->dirty_size += _x; \
@@ -44,76 +63,39 @@
 } while(0)
 
 static uint32_t pseudo_random;
+static void jffs2_rotate_lists(struct jffs2_sb_info *c);
 
-static int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
-				  unsigned char *buf, uint32_t buf_size);
+static int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);
 
 /* These helper functions _must_ increase ofs and also do the dirty/used space accounting. 
  * Returning an error will abort the mount - bad checksums etc. should just mark the space
  * as dirty.
  */
-static int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, 
-				 struct jffs2_raw_inode *ri, uint32_t ofs);
-static int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
-				 struct jffs2_raw_dirent *rd, uint32_t ofs);
-
-#define BLK_STATE_ALLFF		0
-#define BLK_STATE_CLEAN		1
-#define BLK_STATE_PARTDIRTY	2
-#define BLK_STATE_CLEANMARKER	3
-#define BLK_STATE_ALLDIRTY	4
-#define BLK_STATE_BADBLOCK	5
+static int jffs2_scan_empty(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, __u32 *ofs, int *noise);
+static int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, __u32 *ofs);
+static int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, __u32 *ofs);
+
 
 int jffs2_scan_medium(struct jffs2_sb_info *c)
 {
 	int i, ret;
-	uint32_t empty_blocks = 0;
-	unsigned char *flashbuf = NULL;
-	uint32_t buf_size = 0;
-	size_t pointlen;
+	__u32 empty_blocks = 0;
 
 	if (!c->blocks) {
 		printk(KERN_WARNING "EEEK! c->blocks is NULL!\n");
 		return -EINVAL;
 	}
-	if (c->mtd->point) {
-		ret = c->mtd->point (c->mtd, 0, c->mtd->size, &pointlen, &flashbuf);
-		if (!ret && pointlen < c->mtd->size) {
-			/* Don't muck about if it won't let us point to the whole flash */
-			D1(printk(KERN_DEBUG "MTD point returned len too short: 0x%x\n", pointlen));
-			c->mtd->unpoint(c->mtd, flashbuf);
-			flashbuf = NULL;
-		}
-		if (ret)
-			D1(printk(KERN_DEBUG "MTD point failed %d\n", ret));
-	}
-	if (!flashbuf) {
-		/* For NAND it's quicker to read a whole eraseblock at a time,
-		   apparently */
-		if (jffs2_cleanmarker_oob(c))
-			buf_size = c->sector_size;
-		else
-			buf_size = PAGE_SIZE;
-
-		D1(printk(KERN_DEBUG "Allocating readbuf of %d bytes\n", buf_size));
-		flashbuf = kmalloc(buf_size, GFP_KERNEL);
-		if (!flashbuf)
-			return -ENOMEM;
-	}
-
 	for (i=0; i<c->nr_blocks; i++) {
 		struct jffs2_eraseblock *jeb = &c->blocks[i];
 
-		ret = jffs2_scan_eraseblock(c, jeb, buf_size?flashbuf:(flashbuf+jeb->offset), buf_size);
-
+		ret = jffs2_scan_eraseblock(c, jeb);
 		if (ret < 0)
-			goto scan_medium_exit;
+			return ret;
 
 		ACCT_PARANOIA_CHECK(jeb);
 
 		/* Now decide which list to put it on */
-		switch(ret) {
-		case BLK_STATE_ALLFF:
+		if (ret == 1) {
 			/* 
 			 * Empty block.   Since we can't be sure it 
 			 * was entirely erased, we just queue it for erase
@@ -121,13 +103,10 @@
 			 * is complete.  Meanwhile we still count it as empty
 			 * for later checks.
 			 */
-			empty_blocks++;
 			list_add(&jeb->list, &c->erase_pending_list);
-			c->erasing_dirty_size += jeb->dirty_size;
+			empty_blocks++;
 			c->nr_erasing_blocks++;
-			break;
-
-		case BLK_STATE_CLEANMARKER:
+		} else if (jeb->used_size == PAD(sizeof(struct jffs2_unknown_node)) && !jeb->first_node->next_in_ino) {
 			/* Only a CLEANMARKER node is valid */
 			if (!jeb->dirty_size) {
 				/* It's actually free */
@@ -137,17 +116,12 @@
 				/* Dirt */
 				D1(printk(KERN_DEBUG "Adding all-dirty block at 0x%08x to erase_pending_list\n", jeb->offset));
 				list_add(&jeb->list, &c->erase_pending_list);
-				c->erasing_dirty_size += jeb->dirty_size;
 				c->nr_erasing_blocks++;
 			}
-			break;
-
-		case BLK_STATE_CLEAN:
+		} else if (jeb->used_size > c->sector_size - (2*sizeof(struct jffs2_raw_inode))) {
                         /* Full (or almost full) of clean data. Clean list */
                         list_add(&jeb->list, &c->clean_list);
-			break;
-
-		case BLK_STATE_PARTDIRTY:
+                } else if (jeb->used_size) {
                         /* Some data, but not full. Dirty list. */
                         /* Except that we want to remember the block with most free space,
                            and stick it in the 'nextblock' position to start writing to it.
@@ -155,212 +129,60 @@
                            not the one with most free space.
                         */
                         if (jeb->free_size > 2*sizeof(struct jffs2_raw_inode) && 
-			    (jffs2_can_mark_obsolete(c) || jeb->free_size > c->wbuf_pagesize) &&
-			    (!c->nextblock || c->nextblock->free_size < jeb->free_size)) {
+                                (!c->nextblock || c->nextblock->free_size < jeb->free_size)) {
                                 /* Better candidate for the next writes to go to */
-                                if (c->nextblock) {
-					c->nextblock->dirty_size += c->nextblock->free_size + c->nextblock->wasted_size;
-					c->dirty_size += c->nextblock->free_size + c->nextblock->wasted_size;
-					c->free_size -= c->nextblock->free_size;
-					c->wasted_size -= c->nextblock->wasted_size;
-					c->nextblock->free_size = c->nextblock->wasted_size = 0;
-					if (VERYDIRTY(c, c->nextblock->dirty_size)) {
-						list_add(&c->nextblock->list, &c->very_dirty_list);
-					} else {
-						list_add(&c->nextblock->list, &c->dirty_list);
-					}
-				}
+                                if (c->nextblock)
+                                        list_add(&c->nextblock->list, &c->dirty_list);
                                 c->nextblock = jeb;
                         } else {
-				jeb->dirty_size += jeb->free_size + jeb->wasted_size;
-				c->dirty_size += jeb->free_size + jeb->wasted_size;
-				c->free_size -= jeb->free_size;
-				c->wasted_size -= jeb->wasted_size;
-				jeb->free_size = jeb->wasted_size = 0;
-				if (VERYDIRTY(c, jeb->dirty_size)) {
-					list_add(&jeb->list, &c->very_dirty_list);
-				} else {
-					list_add(&jeb->list, &c->dirty_list);
-				}
+                                list_add(&jeb->list, &c->dirty_list);
                         }
-			break;
-
-		case BLK_STATE_ALLDIRTY:
+		} else {
 			/* Nothing valid - not even a clean marker. Needs erasing. */
                         /* For now we just put it on the erasing list. We'll start the erases later */
-			D1(printk(KERN_NOTICE "JFFS2: Erase block at 0x%08x is not formatted. It will be erased\n", jeb->offset));
+			printk(KERN_NOTICE "JFFS2: Erase block at 0x%08x is not formatted. It will be erased\n", jeb->offset);
                         list_add(&jeb->list, &c->erase_pending_list);
-			c->erasing_dirty_size += jeb->dirty_size;
 			c->nr_erasing_blocks++;
-			break;
-			
-		case BLK_STATE_BADBLOCK:
-			D1(printk(KERN_NOTICE "JFFS2: Block at 0x%08x is bad\n", jeb->offset));
-                        list_add(&jeb->list, &c->bad_list);
-			c->bad_size += c->sector_size;
-			c->free_size -= c->sector_size;
-			c->nr_bad_blocks++;
-			break;
-		default:
-			printk(KERN_WARNING "jffs2_scan_medium(): unknown block state\n");
-			BUG();	
 		}
 	}
+	/* Rotate the lists by some number to ensure wear levelling */
+	jffs2_rotate_lists(c);
 
-	ret = 0;
-	
-	/* Nextblock dirty is always seen as wasted, because we cannot recycle it now */
-	if (c->nextblock && (c->nextblock->dirty_size)) {
-		c->nextblock->wasted_size += c->nextblock->dirty_size;
-		c->wasted_size += c->nextblock->dirty_size;
-		c->dirty_size -= c->nextblock->dirty_size;
-		c->nextblock->dirty_size = 0;
-	}
-
-	if (!jffs2_can_mark_obsolete(c) && c->nextblock && (c->nextblock->free_size & (c->wbuf_pagesize-1))) {
-		/* If we're going to start writing into a block which already 
-		   contains data, and the end of the data isn't page-aligned,
-		   skip a little and align it. */
-
-		uint32_t skip = c->nextblock->free_size & (c->wbuf_pagesize-1);
-
-		D1(printk(KERN_DEBUG "jffs2_scan_medium(): Skipping %d bytes in nextblock to ensure page alignment\n",
-			  skip));
-		c->nextblock->wasted_size += skip;
-		c->wasted_size += skip;
-
-		c->nextblock->free_size -= skip;
-		c->free_size -= skip;
-	}
 	if (c->nr_erasing_blocks) {
-		if ( !c->used_size && ((empty_blocks+c->nr_bad_blocks)!= c->nr_blocks || c->nr_bad_blocks == c->nr_blocks) ) {
+		if (!c->used_size && empty_blocks != c->nr_blocks) {
 			printk(KERN_NOTICE "Cowardly refusing to erase blocks on filesystem with no valid JFFS2 nodes\n");
-			printk(KERN_NOTICE "empty_blocks %d, bad_blocks %d, c->nr_blocks %d\n",empty_blocks,c->nr_bad_blocks,c->nr_blocks);
-			ret = -EIO;
-			goto scan_medium_exit;
+			return -EIO;
 		}
 		jffs2_erase_pending_trigger(c);
 	}
-
-  scan_medium_exit:
-	if (buf_size)
-		kfree(flashbuf);
-	else 
-		c->mtd->unpoint(c->mtd, flashbuf);
-
-	return ret;
-}
-
-static int jffs2_fill_scan_buf (struct jffs2_sb_info *c, unsigned char *buf,
-				uint32_t ofs, uint32_t len)
-{
-	int ret;
-	size_t retlen;
-
-	ret = jffs2_flash_read(c, ofs, len, &retlen, buf);
-	if (ret) {
-		D1(printk(KERN_WARNING "mtd->read(0x%x bytes from 0x%x) returned %d\n", len, ofs, ret));
-		return ret;
-	}
-	if (retlen < len) {
-		D1(printk(KERN_WARNING "Read at 0x%x gave only 0x%x bytes\n", ofs, retlen));
-		return -EIO;
-	}
-	D2(printk(KERN_DEBUG "Read 0x%x bytes from 0x%08x into buf\n", len, ofs));
-	D2(printk(KERN_DEBUG "000: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
-		  buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7], buf[8], buf[9], buf[10], buf[11], buf[12], buf[13], buf[14], buf[15]));
 	return 0;
 }
 
-static int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
-				  unsigned char *buf, uint32_t buf_size)
-{
-	struct jffs2_unknown_node *node;
-	struct jffs2_unknown_node crcnode;
-	uint32_t ofs, prevofs;
-	uint32_t hdr_crc, buf_ofs, buf_len;
+static int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb) {
+	struct jffs2_unknown_node node;
+	__u32 ofs, prevofs;
+	__u32 hdr_crc, nodetype;
 	int err;
 	int noise = 0;
-	int wasempty = 0;
-	uint32_t empty_start = 0;
-#ifdef CONFIG_JFFS2_FS_NAND
-	int cleanmarkerfound = 0;
-#endif
 
 	ofs = jeb->offset;
 	prevofs = jeb->offset - 1;
 
 	D1(printk(KERN_DEBUG "jffs2_scan_eraseblock(): Scanning block at 0x%x\n", ofs));
 
-#ifdef CONFIG_JFFS2_FS_NAND
-	if (jffs2_cleanmarker_oob(c)) {
-		int ret = jffs2_check_nand_cleanmarker(c, jeb);
-		D2(printk(KERN_NOTICE "jffs_check_nand_cleanmarker returned %d\n",ret));
-		/* Even if it's not found, we still scan to see
-		   if the block is empty. We use this information
-		   to decide whether to erase it or not. */
-		switch (ret) {
-		case 0:		cleanmarkerfound = 1; break;
-		case 1: 	break;
-		case 2: 	return BLK_STATE_BADBLOCK;
-		case 3:		return BLK_STATE_ALLDIRTY; /* Block has failed to erase min. once */
-		default: 	return ret;
-		}
-	}
-#endif
-	buf_ofs = jeb->offset;
-
-	if (!buf_size) {
-		buf_len = c->sector_size;
-	} else {
-		buf_len = EMPTY_SCAN_SIZE;
-		err = jffs2_fill_scan_buf(c, buf, buf_ofs, buf_len);
-		if (err)
-			return err;
-	}
-	
-	/* We temporarily use 'ofs' as a pointer into the buffer/jeb */
-	ofs = 0;
-
-	/* Scan only 4KiB of 0xFF before declaring it's empty */
-	while(ofs < EMPTY_SCAN_SIZE && *(uint32_t *)(&buf[ofs]) == 0xFFFFFFFF)
-		ofs += 4;
-
-	if (ofs == EMPTY_SCAN_SIZE) {
-#ifdef CONFIG_JFFS2_FS_NAND
-		if (jffs2_cleanmarker_oob(c)) {
-			/* scan oob, take care of cleanmarker */
-			int ret = jffs2_check_oob_empty(c, jeb, cleanmarkerfound);
-			D2(printk(KERN_NOTICE "jffs2_check_oob_empty returned %d\n",ret));
-			switch (ret) {
-			case 0:		return cleanmarkerfound ? BLK_STATE_CLEANMARKER : BLK_STATE_ALLFF;
-			case 1: 	return BLK_STATE_ALLDIRTY;
-			case 2: 	return BLK_STATE_BADBLOCK; /* case 2/3 are paranoia checks */
-			case 3:		return BLK_STATE_ALLDIRTY; /* Block has failed to erase min. once */
-			default: 	return ret;
-			}
-		}
-#endif
+	err = jffs2_scan_empty(c, jeb, &ofs, &noise);
+	if (err) return err;
+	if (ofs == jeb->offset + c->sector_size) {
 		D1(printk(KERN_DEBUG "Block at 0x%08x is empty (erased)\n", jeb->offset));
-		return BLK_STATE_ALLFF;	/* OK to erase if all blocks are like this */
-	}
-	if (ofs) {
-		D1(printk(KERN_DEBUG "Free space at %08x ends at %08x\n", jeb->offset,
-			  jeb->offset + ofs));
-		DIRTY_SPACE(ofs);
+		return 1;	/* special return code */
 	}
-
-	/* Now ofs is a complete physical flash offset as it always was... */
-	ofs += jeb->offset;
-
+	
 	noise = 10;
 
 	while(ofs < jeb->offset + c->sector_size) {
-
+		ssize_t retlen;
 		ACCT_PARANOIA_CHECK(jeb);
-
-		cond_resched();
-
+		
 		if (ofs & 3) {
 			printk(KERN_WARNING "Eep. ofs 0x%08x not word-aligned!\n", ofs);
 			ofs = (ofs+3)&~3;
@@ -373,187 +195,93 @@
 			continue;
 		}
 		prevofs = ofs;
-
-		if (jeb->offset + c->sector_size < ofs + sizeof(*node)) {
-			D1(printk(KERN_DEBUG "Fewer than %d bytes left to end of block. (%x+%x<%x+%x) Not reading\n", sizeof(struct jffs2_unknown_node),
-				  jeb->offset, c->sector_size, ofs, sizeof(*node)));
+		
+		if (jeb->offset + c->sector_size < ofs + sizeof(node)) {
+			D1(printk(KERN_DEBUG "Fewer than %d bytes left to end of block. Not reading\n", sizeof(struct jffs2_unknown_node)));
 			DIRTY_SPACE((jeb->offset + c->sector_size)-ofs);
 			break;
 		}
 
-		if (buf_ofs + buf_len < ofs + sizeof(*node)) {
-			buf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);
-			D1(printk(KERN_DEBUG "Fewer than %d bytes (node header) left to end of buf. Reading 0x%x at 0x%08x\n",
-				  sizeof(struct jffs2_unknown_node), buf_len, ofs));
-			err = jffs2_fill_scan_buf(c, buf, ofs, buf_len);
-			if (err)
-				return err;
-			buf_ofs = ofs;
-		}
-
-		node = (struct jffs2_unknown_node *)&buf[ofs-buf_ofs];
-
-		if (*(uint32_t *)(&buf[ofs-buf_ofs]) == 0xffffffff) {
-			uint32_t inbuf_ofs = ofs - buf_ofs + 4;
-			uint32_t scanend;
-
-			empty_start = ofs;
-			ofs += 4;
-
-			/* If scanning empty space after only a cleanmarker, don't
-			   bother scanning the whole block */
-			if (unlikely(empty_start == jeb->offset + c->cleanmarker_size &&
-				     jeb->offset + EMPTY_SCAN_SIZE < buf_ofs + buf_len))
-				scanend = jeb->offset + EMPTY_SCAN_SIZE - buf_ofs;
-			else
-				scanend = buf_len;
-
-			D1(printk(KERN_DEBUG "Found empty flash at 0x%08x\n", ofs));
-			while (inbuf_ofs < scanend) {
-				if (*(uint32_t *)(&buf[inbuf_ofs]) != 0xffffffff)
-					goto emptyends;
-
-				inbuf_ofs+=4;
-				ofs += 4;
-			}
-			/* Ran off end. */
-			D1(printk(KERN_DEBUG "Empty flash ends normally at 0x%08x\n", ofs));
-
-			if (buf_ofs == jeb->offset && jeb->used_size == PAD(c->cleanmarker_size) && 
-			    !jeb->first_node->next_in_ino && !jeb->dirty_size)
-				return BLK_STATE_CLEANMARKER;
-			wasempty = 1;
+		err = c->mtd->read(c->mtd, ofs, sizeof(node), &retlen, (char *)&node);
+		
+		if (err) {
+			D1(printk(KERN_WARNING "mtd->read(0x%x bytes from 0x%x) returned %d\n", sizeof(node), ofs, err));
+			return err;
+		}
+		if (retlen < sizeof(node)) {
+			D1(printk(KERN_WARNING "Read at 0x%x gave only 0x%x bytes\n", ofs, retlen));
+			DIRTY_SPACE(retlen);
+			ofs += retlen;
 			continue;
-		} else if (wasempty) {
-		emptyends:
-			if (! (c->mtd->type == MTD_NANDFLASH &&
-			       (ofs - empty_start) < c->mtd->oobblock &&
-			       (ofs % c->mtd->oobblock) == 0))
-				printk(KERN_WARNING "Empty flash at 0x%08x ends at 0x%08x\n", empty_start, ofs);
-			DIRTY_SPACE(ofs-empty_start);
-			wasempty = 0;
+		}
+
+		if (node.magic == JFFS2_EMPTY_BITMASK && node.nodetype == JFFS2_EMPTY_BITMASK) {
+			D1(printk(KERN_DEBUG "Found empty flash at 0x%x\n", ofs));
+			err = jffs2_scan_empty(c, jeb, &ofs, &noise);
+			if (err) return err;
 			continue;
 		}
 
-		if (ofs == jeb->offset && je16_to_cpu(node->magic) == KSAMTIB_CIGAM_2SFFJ) {
+		if (ofs == jeb->offset && node.magic == KSAMTIB_CIGAM_2SFFJ) {
 			printk(KERN_WARNING "Magic bitmask is backwards at offset 0x%08x. Wrong endian filesystem?\n", ofs);
 			DIRTY_SPACE(4);
 			ofs += 4;
 			continue;
 		}
-		if (je16_to_cpu(node->magic) == JFFS2_DIRTY_BITMASK) {
+		if (node.magic == JFFS2_DIRTY_BITMASK) {
 			D1(printk(KERN_DEBUG "Empty bitmask at 0x%08x\n", ofs));
 			DIRTY_SPACE(4);
 			ofs += 4;
 			continue;
 		}
-		if (je16_to_cpu(node->magic) == JFFS2_OLD_MAGIC_BITMASK) {
+		if (node.magic == JFFS2_OLD_MAGIC_BITMASK) {
 			printk(KERN_WARNING "Old JFFS2 bitmask found at 0x%08x\n", ofs);
 			printk(KERN_WARNING "You cannot use older JFFS2 filesystems with newer kernels\n");
 			DIRTY_SPACE(4);
 			ofs += 4;
 			continue;
 		}
-		if (je16_to_cpu(node->magic) != JFFS2_MAGIC_BITMASK) {
+		if (node.magic != JFFS2_MAGIC_BITMASK) {
 			/* OK. We're out of possibilities. Whinge and move on */
-			noisy_printk(&noise, "jffs2_scan_eraseblock(): Magic bitmask 0x%04x not found at 0x%08x: 0x%04x instead\n", 
-				     JFFS2_MAGIC_BITMASK, ofs, 
-				     je16_to_cpu(node->magic));
+			noisy_printk(&noise, "jffs2_scan_eraseblock(): Magic bitmask 0x%04x not found at 0x%08x: 0x%04x instead\n", JFFS2_MAGIC_BITMASK, ofs, node.magic);
 			DIRTY_SPACE(4);
 			ofs += 4;
 			continue;
 		}
 		/* We seem to have a node of sorts. Check the CRC */
-		crcnode.magic = node->magic;
-		crcnode.nodetype = cpu_to_je16( je16_to_cpu(node->nodetype) | JFFS2_NODE_ACCURATE);
-		crcnode.totlen = node->totlen;
-		hdr_crc = crc32(0, &crcnode, sizeof(crcnode)-4);
-
-		if (hdr_crc != je32_to_cpu(node->hdr_crc)) {
+		nodetype = node.nodetype;
+		node.nodetype |= JFFS2_NODE_ACCURATE;
+		hdr_crc = crc32(0, &node, sizeof(node)-4);
+		node.nodetype = nodetype;
+		if (hdr_crc != node.hdr_crc) {
 			noisy_printk(&noise, "jffs2_scan_eraseblock(): Node at 0x%08x {0x%04x, 0x%04x, 0x%08x) has invalid CRC 0x%08x (calculated 0x%08x)\n",
-				     ofs, je16_to_cpu(node->magic),
-				     je16_to_cpu(node->nodetype), 
-				     je32_to_cpu(node->totlen),
-				     je32_to_cpu(node->hdr_crc),
-				     hdr_crc);
+				     ofs, node.magic, node.nodetype, node.totlen, node.hdr_crc, hdr_crc);
 			DIRTY_SPACE(4);
 			ofs += 4;
 			continue;
 		}
 
-		if (ofs + je32_to_cpu(node->totlen) > 
-		    jeb->offset + c->sector_size) {
-			/* Eep. Node goes over the end of the erase block. */
-			printk(KERN_WARNING "Node at 0x%08x with length 0x%08x would run over the end of the erase block\n",
-			       ofs, je32_to_cpu(node->totlen));
-			printk(KERN_WARNING "Perhaps the file system was created with the wrong erase size?\n");
-			DIRTY_SPACE(4);
-			ofs += 4;
-			continue;
-		}
-
-		if (!(je16_to_cpu(node->nodetype) & JFFS2_NODE_ACCURATE)) {
-			/* Wheee. This is an obsoleted node */
-			D2(printk(KERN_DEBUG "Node at 0x%08x is obsolete. Skipping\n", ofs));
-			DIRTY_SPACE(PAD(je32_to_cpu(node->totlen)));
-			ofs += PAD(je32_to_cpu(node->totlen));
-			continue;
-		}
-
-		switch(je16_to_cpu(node->nodetype)) {
+		switch(node.nodetype | JFFS2_NODE_ACCURATE) {
 		case JFFS2_NODETYPE_INODE:
-			if (buf_ofs + buf_len < ofs + sizeof(struct jffs2_raw_inode)) {
-				buf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);
-				D1(printk(KERN_DEBUG "Fewer than %d bytes (inode node) left to end of buf. Reading 0x%x at 0x%08x\n",
-					  sizeof(struct jffs2_raw_inode), buf_len, ofs));
-				err = jffs2_fill_scan_buf(c, buf, ofs, buf_len);
-				if (err)
-					return err;
-				buf_ofs = ofs;
-				node = (void *)buf;
-			}
-			if (buf_ofs + buf_len < ofs + sizeof(struct jffs2_raw_inode) + je32_to_cpu(((struct jffs2_raw_inode*)node)->csize)) {
-				buf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);
-				D1(printk(KERN_DEBUG "Fewer than %d bytes (inode node) left to end of buf. Reading 0x%x at 0x%08x\n",
-					  sizeof(struct jffs2_raw_inode) + je32_to_cpu(((struct jffs2_raw_inode*)node)->csize), buf_len, ofs));
-				err = jffs2_fill_scan_buf(c, buf, ofs, buf_len);
-				if (err)
-					return err;
-				buf_ofs = ofs;
-				node = (void *)buf;
-			}
-			err = jffs2_scan_inode_node(c, jeb, (void *)node, ofs);
+			err = jffs2_scan_inode_node(c, jeb, &ofs);
 			if (err) return err;
-			ofs += PAD(je32_to_cpu(node->totlen));
 			break;
 			
 		case JFFS2_NODETYPE_DIRENT:
-			if (buf_ofs + buf_len < ofs + je32_to_cpu(node->totlen)) {
-				buf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);
-				D1(printk(KERN_DEBUG "Fewer than %d bytes (dirent node) left to end of buf. Reading 0x%x at 0x%08x\n",
-					  je32_to_cpu(node->totlen), buf_len, ofs));
-				err = jffs2_fill_scan_buf(c, buf, ofs, buf_len);
-				if (err)
-					return err;
-				buf_ofs = ofs;
-				node = (void *)buf;
-			}
-			err = jffs2_scan_dirent_node(c, jeb, (void *)node, ofs);
+			err = jffs2_scan_dirent_node(c, jeb, &ofs);
 			if (err) return err;
-			ofs += PAD(je32_to_cpu(node->totlen));
 			break;
 
 		case JFFS2_NODETYPE_CLEANMARKER:
-			D1(printk(KERN_DEBUG "CLEANMARKER node found at 0x%08x\n", ofs));
-			if (je32_to_cpu(node->totlen) != c->cleanmarker_size) {
+			if (node.totlen != sizeof(struct jffs2_unknown_node)) {
 				printk(KERN_NOTICE "CLEANMARKER node found at 0x%08x has totlen 0x%x != normal 0x%x\n", 
-				       ofs, je32_to_cpu(node->totlen), c->cleanmarker_size);
+				       ofs, node.totlen, sizeof(struct jffs2_unknown_node));
 				DIRTY_SPACE(PAD(sizeof(struct jffs2_unknown_node)));
-				ofs += PAD(sizeof(struct jffs2_unknown_node));
 			} else if (jeb->first_node) {
 				printk(KERN_NOTICE "CLEANMARKER node found at 0x%08x, not first node in block (0x%08x)\n", ofs, jeb->offset);
 				DIRTY_SPACE(PAD(sizeof(struct jffs2_unknown_node)));
 				ofs += PAD(sizeof(struct jffs2_unknown_node));
+				continue;
 			} else {
 				struct jffs2_raw_node_ref *marker_ref = jffs2_alloc_raw_node_ref();
 				if (!marker_ref) {
@@ -563,78 +291,97 @@
 				marker_ref->next_in_ino = NULL;
 				marker_ref->next_phys = NULL;
 				marker_ref->flash_offset = ofs;
-				marker_ref->totlen = c->cleanmarker_size;
+				marker_ref->totlen = sizeof(struct jffs2_unknown_node);
 				jeb->first_node = jeb->last_node = marker_ref;
 			     
-				USED_SPACE(PAD(c->cleanmarker_size));
-				ofs += PAD(c->cleanmarker_size);
+				USED_SPACE(PAD(sizeof(struct jffs2_unknown_node)));
 			}
-			break;
-
-		case JFFS2_NODETYPE_PADDING:
-			DIRTY_SPACE(PAD(je32_to_cpu(node->totlen)));
-			ofs += PAD(je32_to_cpu(node->totlen));
+			ofs += PAD(sizeof(struct jffs2_unknown_node));
 			break;
 
 		default:
-			switch (je16_to_cpu(node->nodetype) & JFFS2_COMPAT_MASK) {
+			switch (node.nodetype & JFFS2_COMPAT_MASK) {
 			case JFFS2_FEATURE_ROCOMPAT:
-				printk(KERN_NOTICE "Read-only compatible feature node (0x%04x) found at offset 0x%08x\n", je16_to_cpu(node->nodetype), ofs);
+				printk(KERN_NOTICE "Read-only compatible feature node (0x%04x) found at offset 0x%08x\n", node.nodetype, ofs);
 			        c->flags |= JFFS2_SB_FLAG_RO;
-				if (!(jffs2_is_readonly(c)))
+				if (!(OFNI_BS_2SFFJ(c)->s_flags & MS_RDONLY))
 					return -EROFS;
-				DIRTY_SPACE(PAD(je32_to_cpu(node->totlen)));
-				ofs += PAD(je32_to_cpu(node->totlen));
-				break;
+				DIRTY_SPACE(PAD(node.totlen));
+				ofs += PAD(node.totlen);
+				continue;
 
 			case JFFS2_FEATURE_INCOMPAT:
-				printk(KERN_NOTICE "Incompatible feature node (0x%04x) found at offset 0x%08x\n", je16_to_cpu(node->nodetype), ofs);
+				printk(KERN_NOTICE "Incompatible feature node (0x%04x) found at offset 0x%08x\n", node.nodetype, ofs);
 				return -EINVAL;
 
 			case JFFS2_FEATURE_RWCOMPAT_DELETE:
-				D1(printk(KERN_NOTICE "Unknown but compatible feature node (0x%04x) found at offset 0x%08x\n", je16_to_cpu(node->nodetype), ofs));
-				DIRTY_SPACE(PAD(je32_to_cpu(node->totlen)));
-				ofs += PAD(je32_to_cpu(node->totlen));
+				printk(KERN_NOTICE "Unknown but compatible feature node (0x%04x) found at offset 0x%08x\n", node.nodetype, ofs);
+				DIRTY_SPACE(PAD(node.totlen));
+				ofs += PAD(node.totlen);
 				break;
 
 			case JFFS2_FEATURE_RWCOMPAT_COPY:
-				D1(printk(KERN_NOTICE "Unknown but compatible feature node (0x%04x) found at offset 0x%08x\n", je16_to_cpu(node->nodetype), ofs));
-				USED_SPACE(PAD(je32_to_cpu(node->totlen)));
-				ofs += PAD(je32_to_cpu(node->totlen));
+				printk(KERN_NOTICE "Unknown but compatible feature node (0x%04x) found at offset 0x%08x\n", node.nodetype, ofs);
+				USED_SPACE(PAD(node.totlen));
+				ofs += PAD(node.totlen);
 				break;
 			}
 		}
 	}
-
-
 	D1(printk(KERN_DEBUG "Block at 0x%08x: free 0x%08x, dirty 0x%08x, used 0x%08x\n", jeb->offset, 
 		  jeb->free_size, jeb->dirty_size, jeb->used_size));
+	return 0;
+}
 
-	/* mark_node_obsolete can add to wasted !! */
-	if (jeb->wasted_size) {
-		jeb->dirty_size += jeb->wasted_size;
-		c->dirty_size += jeb->wasted_size;
-		c->wasted_size -= jeb->wasted_size;
-		jeb->wasted_size = 0;
-	}
-
-	if (jeb->used_size == PAD(c->cleanmarker_size) && 
-	    !jeb->first_node->next_in_ino && !jeb->dirty_size)
-		return BLK_STATE_CLEANMARKER;
-	/* move blocks with max 4 byte dirty space to cleanlist */	
-	else if (!ISDIRTY(c->sector_size - jeb->used_size)) {
-		c->dirty_size -= jeb->dirty_size;
-		c->wasted_size += jeb->dirty_size; 
-		jeb->wasted_size += jeb->dirty_size;
-		jeb->dirty_size = 0;
-		return BLK_STATE_CLEAN;
-	} else if (jeb->used_size)
-		return BLK_STATE_PARTDIRTY;
-	else
-		return BLK_STATE_ALLDIRTY;
+/* We're pointing at the first empty word on the flash. Scan and account for the whole dirty region */
+static int jffs2_scan_empty(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, __u32 *startofs, int *noise)
+{
+	__u32 *buf;
+	__u32 scanlen = (jeb->offset + c->sector_size) - *startofs;
+	__u32 curofs = *startofs;
+	
+	buf = kmalloc(min((__u32)PAGE_SIZE, scanlen), GFP_KERNEL);
+	if (!buf) {
+		printk(KERN_WARNING "Scan buffer allocation failed\n");
+		return -ENOMEM;
+	}
+	while(scanlen) {
+		ssize_t retlen;
+		int ret, i;
+		
+		ret = c->mtd->read(c->mtd, curofs, min((__u32)PAGE_SIZE, scanlen), &retlen, (char *)buf);
+		if(ret) {
+			D1(printk(KERN_WARNING "jffs2_scan_empty(): Read 0x%x bytes at 0x%08x returned %d\n", min((__u32)PAGE_SIZE, scanlen), curofs, ret));
+			kfree(buf);
+			return ret;
+		}
+		if (retlen < 4) {
+			D1(printk(KERN_WARNING "Eep. too few bytes read in scan_empty()\n"));
+			kfree(buf);
+			return -EIO;
+		}
+		for (i=0; i<(retlen / 4); i++) {
+			if (buf[i] != 0xffffffff) {
+				curofs += i*4;
+
+				noisy_printk(noise, "jffs2_scan_empty(): Empty block at 0x%08x ends at 0x%08x (with 0x%08x)! Marking dirty\n", *startofs, curofs, buf[i]);
+				DIRTY_SPACE(curofs - (*startofs));
+				*startofs = curofs;
+				kfree(buf);
+				return 0;
+			}
+		}
+		scanlen -= retlen&~3;
+		curofs += retlen&~3;
+	}
+
+	D1(printk(KERN_DEBUG "Empty flash detected from 0x%08x to 0x%08x\n", *startofs, curofs));
+	kfree(buf);
+	*startofs = curofs;
+	return 0;
 }
 
-static struct jffs2_inode_cache *jffs2_scan_make_ino_cache(struct jffs2_sb_info *c, uint32_t ino)
+static struct jffs2_inode_cache *jffs2_scan_make_ino_cache(struct jffs2_sb_info *c, __u32 ino)
 {
 	struct jffs2_inode_cache *ic;
 
@@ -663,63 +410,82 @@
 	return ic;
 }
 
-static int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, 
-				 struct jffs2_raw_inode *ri, uint32_t ofs)
+static int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, __u32 *ofs)
 {
 	struct jffs2_raw_node_ref *raw;
 	struct jffs2_full_dnode *fn;
 	struct jffs2_tmp_dnode_info *tn, **tn_list;
 	struct jffs2_inode_cache *ic;
-	uint32_t dsize, csize;
-	uint32_t crc;
+	struct jffs2_raw_inode ri;
+	__u32 crc;
+	__u16 oldnodetype;
+	int ret;
+	ssize_t retlen;
+
+	D1(printk(KERN_DEBUG "jffs2_scan_inode_node(): Node at 0x%08x\n", *ofs));
 
-	D1(printk(KERN_DEBUG "jffs2_scan_inode_node(): Node at 0x%08x\n", ofs));
+	ret = c->mtd->read(c->mtd, *ofs, sizeof(ri), &retlen, (char *)&ri);
+	if (ret) {
+		printk(KERN_NOTICE "jffs2_scan_inode_node(): Read error at 0x%08x: %d\n", *ofs, ret);
+		return ret;
+	}
+	if (retlen != sizeof(ri)) {
+		printk(KERN_NOTICE "Short read: 0x%x bytes at 0x%08x instead of requested %x\n", 
+		       retlen, *ofs, sizeof(ri));
+		return -EIO;
+	}
 
-	/* FIXME: Actually we don't need to do all this here. We can just make a raw_node_ref for it,
-	   and file it against ri->inode. We don't even need to check the CRC. If the CRC is valid,
-	   all was well, if the CRC was _invalid_, we're gonna drop it when we find out anyway, so
-	   it doesn't matter which inode it was filed against. Of course we have to go through and
-	   do the CRC checks for each inode some time later, but we don't have to hold up the mount
-	   for it.
-
-	   Hmm, perhaps we'd want to do the CRC check if there's not already an inocache for the inode
-	   we think it belongs to, to prevent us from ending up creating an inocache for ino #0xFFFFFFFF
-	   if that's what we see on the flash.
-	*/
-	   
-
-	/* We don't get here unless the node is still valid, so we don't have to
-	   mask in the ACCURATE bit any more. */
-	crc = crc32(0, ri, sizeof(*ri)-8);
+	/* We sort of assume that the node was accurate when it was 
+	   first written to the medium :) */
+	oldnodetype = ri.nodetype;
+	ri.nodetype |= JFFS2_NODE_ACCURATE;
+	crc = crc32(0, &ri, sizeof(ri)-8);
+	ri.nodetype = oldnodetype;
 
-	if(crc != je32_to_cpu(ri->node_crc)) {
+	if(crc != ri.node_crc) {
 		printk(KERN_NOTICE "jffs2_scan_inode_node(): CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\n",
-		       ofs, je32_to_cpu(ri->node_crc), crc);
-		/* We believe totlen because the CRC on the node _header_ was OK, just the node itself failed. */
-		DIRTY_SPACE(PAD(je32_to_cpu(ri->totlen)));
+		       *ofs, ri.node_crc, crc);
+		/* FIXME: Why do we believe totlen? */
+		DIRTY_SPACE(4);
+		*ofs += 4;
 		return 0;
 	}
 	/* There was a bug where we wrote hole nodes out with csize/dsize
 	   swapped. Deal with it */
-	if (unlikely(ri->compr == JFFS2_COMPR_ZERO && !je32_to_cpu(ri->dsize) && je32_to_cpu(ri->csize))) {
-		dsize = je32_to_cpu(ri->csize);
-		csize = 0;
-	} else {
-		csize = je32_to_cpu(ri->csize);
-		dsize = je32_to_cpu(ri->dsize);
+	if (ri.compr == JFFS2_COMPR_ZERO && !ri.dsize && ri.csize) {
+		ri.dsize = ri.csize;
+		ri.csize = 0;
 	}
 
-	if (csize) {
+	if (ri.csize) {
 		/* Check data CRC too */
 		unsigned char *dbuf;
-		uint32_t crc;
+		__u32 crc;
 
-		dbuf = (unsigned char*)ri + sizeof *ri;
-		crc = crc32(0, dbuf, csize);
-		if (crc != je32_to_cpu(ri->data_crc)) {
+		dbuf = kmalloc(PAGE_CACHE_SIZE, GFP_KERNEL);
+		if (!dbuf) {
+			printk(KERN_NOTICE "jffs2_scan_inode_node(): allocation of temporary data buffer for CRC check failed\n");
+			return -ENOMEM;
+		}
+		ret = c->mtd->read(c->mtd, *ofs+sizeof(ri), ri.csize, &retlen, dbuf);
+		if (ret) {
+			printk(KERN_NOTICE "jffs2_scan_inode_node(): Read error at 0x%08x: %d\n", *ofs+sizeof(ri), ret);
+			kfree(dbuf);
+			return ret;
+		}
+		if (retlen != ri.csize) {
+			printk(KERN_NOTICE "Short read: 0x%x bytes at 0x%08x instead of requested %x\n", 
+			       retlen, *ofs+ sizeof(ri), ri.csize);
+			kfree(dbuf);
+			return -EIO;
+		}
+		crc = crc32(0, dbuf, ri.csize);
+		kfree(dbuf);
+		if (crc != ri.data_crc) {
 			printk(KERN_NOTICE "jffs2_scan_inode_node(): Data CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\n",
-			       ofs, je32_to_cpu(ri->data_crc), crc);
-			DIRTY_SPACE(PAD(je32_to_cpu(ri->totlen)));
+			       *ofs, ri.data_crc, crc);
+			DIRTY_SPACE(PAD(ri.totlen));
+			*ofs += PAD(ri.totlen);
 			return 0;
 		}
 	}
@@ -741,7 +507,7 @@
 		jffs2_free_raw_node_ref(raw);
 		return -ENOMEM;
 	}
-	ic = jffs2_scan_make_ino_cache(c, je32_to_cpu(ri->ino));
+	ic = jffs2_scan_make_ino_cache(c, ri.ino);
 	if (!ic) {
 		jffs2_free_full_dnode(fn);
 		jffs2_free_tmp_dnode_info(tn);
@@ -750,12 +516,8 @@
 	}
 
 	/* Build the data structures and file them for later */
-	if (dsize == PAGE_CACHE_SIZE)
-		raw->flash_offset = ofs | REF_PRISTINE;
-	else
-		raw->flash_offset = ofs | REF_NORMAL;
-
-	raw->totlen = PAD(je32_to_cpu(ri->totlen));
+	raw->flash_offset = *ofs;
+	raw->totlen = PAD(ri.totlen);
 	raw->next_phys = NULL;
 	raw->next_in_ino = ic->nodes;
 	ic->nodes = raw;
@@ -766,118 +528,134 @@
 	jeb->last_node = raw;
 
 	D1(printk(KERN_DEBUG "Node is ino #%u, version %d. Range 0x%x-0x%x\n", 
-		  je32_to_cpu(ri->ino), je32_to_cpu(ri->version),
-		  je32_to_cpu(ri->offset),
-		  je32_to_cpu(ri->offset)+dsize));
+		  ri.ino, ri.version, ri.offset, ri.offset+ri.dsize));
 
-	pseudo_random += je32_to_cpu(ri->version);
+	pseudo_random += ri.version;
 
 	for (tn_list = &ic->scan->tmpnodes; *tn_list; tn_list = &((*tn_list)->next)) {
-		if ((*tn_list)->version < je32_to_cpu(ri->version))
+		if ((*tn_list)->version < ri.version)
 			continue;
-		if ((*tn_list)->version > je32_to_cpu(ri->version)) 
+		if ((*tn_list)->version > ri.version) 
 			break;
 		/* Wheee. We've found another instance of the same version number.
 		   We should obsolete one of them. 
 		*/
-		D1(printk(KERN_DEBUG "Duplicate version %d found in ino #%u. Previous one is at 0x%08x\n",
-			  je32_to_cpu(ri->version), ic->ino,
-			  ref_offset((*tn_list)->fn->raw)));
+		D1(printk(KERN_DEBUG "Duplicate version %d found in ino #%u. Previous one is at 0x%08x\n", ri.version, ic->ino, (*tn_list)->fn->raw->flash_offset &~3));
 		if (!jeb->used_size) {
 			D1(printk(KERN_DEBUG "No valid nodes yet found in this eraseblock 0x%08x, so obsoleting the new instance at 0x%08x\n", 
-				  jeb->offset, ref_offset(raw)));
-			jffs2_free_full_dnode(fn);
-			jffs2_free_tmp_dnode_info(tn);
-			raw->flash_offset |= REF_OBSOLETE;
-			DIRTY_SPACE(PAD(je32_to_cpu(ri->totlen)));
+				  jeb->offset, raw->flash_offset & ~3));
+			ri.nodetype &= ~JFFS2_NODE_ACCURATE;
 			/* Perhaps we could also mark it as such on the medium. Maybe later */
-			return 0;
 		}
 		break;
 	}
 
-	/* Only do fraglist truncation in pass1 for S_IFREG inodes */
-	if (S_ISREG(je32_to_cpu(ri->mode)) && ic->scan->version < je32_to_cpu(ri->version)) {
-		ic->scan->version = je32_to_cpu(ri->version);
-		ic->scan->isize = je32_to_cpu(ri->isize);
-	}
-
-	memset(fn,0,sizeof(*fn));
-
-	fn->ofs = je32_to_cpu(ri->offset);
-	fn->size = dsize;
-	fn->frags = 0;
-	fn->raw = raw;
-
-	tn->next = NULL;
-	tn->fn = fn;
-	tn->version = je32_to_cpu(ri->version);
-
-	USED_SPACE(PAD(je32_to_cpu(ri->totlen)));
-
-	/* No need to scan from the beginning of the list again. 
-	   We can start from tn_list instead (Thanks Jocke) */
-	jffs2_add_tn_to_list(tn, tn_list);
-
-	/* Make sure the one we just added is the _last_ in the list
-	   with this version number, so the older ones get obsoleted */
-	while (tn->next && tn->next->version == tn->version) {
-
-		D1(printk(KERN_DEBUG "Shifting new node at 0x%08x after other node at 0x%08x for version %d in list\n",
-			  ref_offset(fn->raw), 
-			  ref_offset(tn->next->fn->raw),
-			  je32_to_cpu(ri->version)));
-
-		if(tn->fn != fn)
-			BUG();
-		tn->fn = tn->next->fn;
-		tn->next->fn = fn;
-		tn = tn->next;
-	}
+	if (ri.nodetype & JFFS2_NODE_ACCURATE) {
+		memset(fn,0,sizeof(*fn));
 
+		fn->ofs = ri.offset;
+		fn->size = ri.dsize;
+		fn->frags = 0;
+		fn->raw = raw;
+
+		tn->next = NULL;
+		tn->fn = fn;
+		tn->version = ri.version;
+
+		USED_SPACE(PAD(ri.totlen));
+		jffs2_add_tn_to_list(tn, &ic->scan->tmpnodes);
+		/* Make sure the one we just added is the _last_ in the list
+		   with this version number, so the older ones get obsoleted */
+		while (tn->next && tn->next->version == tn->version) {
+
+			D1(printk(KERN_DEBUG "Shifting new node at 0x%08x after other node at 0x%08x for version %d in list\n",
+				  fn->raw->flash_offset&~3, tn->next->fn->raw->flash_offset &~3, ri.version));
+
+			if(tn->fn != fn)
+				BUG();
+			tn->fn = tn->next->fn;
+			tn->next->fn = fn;
+			tn = tn->next;
+		}
+	} else {
+		jffs2_free_full_dnode(fn);
+		jffs2_free_tmp_dnode_info(tn);
+		raw->flash_offset |= 1;
+		DIRTY_SPACE(PAD(ri.totlen));
+	}		
+	*ofs += PAD(ri.totlen);
 	return 0;
 }
 
-static int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, 
-				  struct jffs2_raw_dirent *rd, uint32_t ofs)
+static int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, __u32 *ofs)
 {
 	struct jffs2_raw_node_ref *raw;
 	struct jffs2_full_dirent *fd;
 	struct jffs2_inode_cache *ic;
-	uint32_t crc;
+	struct jffs2_raw_dirent rd;
+	__u16 oldnodetype;
+	int ret;
+	__u32 crc;
+	ssize_t retlen;
 
-	D1(printk(KERN_DEBUG "jffs2_scan_dirent_node(): Node at 0x%08x\n", ofs));
+	D1(printk(KERN_DEBUG "jffs2_scan_dirent_node(): Node at 0x%08x\n", *ofs));
+
+	ret = c->mtd->read(c->mtd, *ofs, sizeof(rd), &retlen, (char *)&rd);
+	if (ret) {
+		printk(KERN_NOTICE "jffs2_scan_dirent_node(): Read error at 0x%08x: %d\n", *ofs, ret);
+		return ret;
+	}
+	if (retlen != sizeof(rd)) {
+		printk(KERN_NOTICE "Short read: 0x%x bytes at 0x%08x instead of requested %x\n", 
+		       retlen, *ofs, sizeof(rd));
+		return -EIO;
+	}
 
-	/* We don't get here unless the node is still valid, so we don't have to
-	   mask in the ACCURATE bit any more. */
-	crc = crc32(0, rd, sizeof(*rd)-8);
+	/* We sort of assume that the node was accurate when it was 
+	   first written to the medium :) */
+	oldnodetype = rd.nodetype;
+	rd.nodetype |= JFFS2_NODE_ACCURATE;
+	crc = crc32(0, &rd, sizeof(rd)-8);
+	rd.nodetype = oldnodetype;
 
-	if (crc != je32_to_cpu(rd->node_crc)) {
+	if (crc != rd.node_crc) {
 		printk(KERN_NOTICE "jffs2_scan_dirent_node(): Node CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\n",
-		       ofs, je32_to_cpu(rd->node_crc), crc);
-		/* We believe totlen because the CRC on the node _header_ was OK, just the node itself failed. */
-		DIRTY_SPACE(PAD(je32_to_cpu(rd->totlen)));
+		       *ofs, rd.node_crc, crc);
+		/* FIXME: Why do we believe totlen? */
+		DIRTY_SPACE(4);
+		*ofs += 4;
 		return 0;
 	}
 
-	pseudo_random += je32_to_cpu(rd->version);
+	pseudo_random += rd.version;
 
-	fd = jffs2_alloc_full_dirent(rd->nsize+1);
+	fd = jffs2_alloc_full_dirent(rd.nsize+1);
 	if (!fd) {
 		return -ENOMEM;
+}
+	ret = c->mtd->read(c->mtd, *ofs + sizeof(rd), rd.nsize, &retlen, &fd->name[0]);
+	if (ret) {
+		jffs2_free_full_dirent(fd);
+		printk(KERN_NOTICE "jffs2_scan_dirent_node(): Read error at 0x%08x: %d\n", 
+		       *ofs + sizeof(rd), ret);
+		return ret;
 	}
-	memcpy(&fd->name, rd->name, rd->nsize);
-	fd->name[rd->nsize] = 0;
-
-	crc = crc32(0, fd->name, rd->nsize);
-	if (crc != je32_to_cpu(rd->name_crc)) {
+	if (retlen != rd.nsize) {
+		jffs2_free_full_dirent(fd);
+		printk(KERN_NOTICE "Short read: 0x%x bytes at 0x%08x instead of requested %x\n", 
+		       retlen, *ofs + sizeof(rd), rd.nsize);
+		return -EIO;
+	}
+	crc = crc32(0, fd->name, rd.nsize);
+	if (crc != rd.name_crc) {
 		printk(KERN_NOTICE "jffs2_scan_dirent_node(): Name CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\n",
-		       ofs, je32_to_cpu(rd->name_crc), crc);	
-		D1(printk(KERN_NOTICE "Name for which CRC failed is (now) '%s', ino #%d\n", fd->name, je32_to_cpu(rd->ino)));
+		       *ofs, rd.name_crc, crc);	
+		fd->name[rd.nsize]=0;
+		D1(printk(KERN_NOTICE "Name for which CRC failed is (now) '%s', ino #%d\n", fd->name, rd.ino));
 		jffs2_free_full_dirent(fd);
 		/* FIXME: Why do we believe totlen? */
-		/* We believe totlen because the CRC on the node _header_ was OK, just the name failed. */
-		DIRTY_SPACE(PAD(je32_to_cpu(rd->totlen)));
+		DIRTY_SPACE(PAD(rd.totlen));
+		*ofs += PAD(rd.totlen);
 		return 0;
 	}
 	raw = jffs2_alloc_raw_node_ref();
@@ -886,15 +664,15 @@
 		printk(KERN_NOTICE "jffs2_scan_dirent_node(): allocation of node reference failed\n");
 		return -ENOMEM;
 	}
-	ic = jffs2_scan_make_ino_cache(c, je32_to_cpu(rd->pino));
+	ic = jffs2_scan_make_ino_cache(c, rd.pino);
 	if (!ic) {
 		jffs2_free_full_dirent(fd);
 		jffs2_free_raw_node_ref(raw);
 		return -ENOMEM;
 	}
 	
-	raw->totlen = PAD(je32_to_cpu(rd->totlen));
-	raw->flash_offset = ofs;
+	raw->totlen = PAD(rd.totlen);
+	raw->flash_offset = *ofs;
 	raw->next_phys = NULL;
 	raw->next_in_ino = ic->nodes;
 	ic->nodes = raw;
@@ -904,15 +682,24 @@
 		jeb->last_node->next_phys = raw;
 	jeb->last_node = raw;
 
-	fd->raw = raw;
-	fd->next = NULL;
-	fd->version = je32_to_cpu(rd->version);
-	fd->ino = je32_to_cpu(rd->ino);
-	fd->nhash = full_name_hash(fd->name, rd->nsize);
-	fd->type = rd->type;
-	USED_SPACE(PAD(je32_to_cpu(rd->totlen)));
-	jffs2_add_fd_to_list(c, fd, &ic->scan->dents);
+	if (rd.nodetype & JFFS2_NODE_ACCURATE) {
+		fd->raw = raw;
+		fd->next = NULL;
+		fd->version = rd.version;
+		fd->ino = rd.ino;
+		fd->name[rd.nsize]=0;
+		fd->nhash = full_name_hash(fd->name, rd.nsize);
+		fd->type = rd.type;
+
+		USED_SPACE(PAD(rd.totlen));
+		jffs2_add_fd_to_list(c, fd, &ic->scan->dents);
+	} else {
+		raw->flash_offset |= 1;
+		jffs2_free_full_dirent(fd);
 
+		DIRTY_SPACE(PAD(rd.totlen));
+	} 
+	*ofs += PAD(rd.totlen);
 	return 0;
 }
 
@@ -934,96 +721,26 @@
 	struct list_head *n = head->next;
 
 	list_del(head);
-	while(count--) {
+	while(count--)
 		n = n->next;
-	}
 	list_add(head, n);
 }
 
-void jffs2_rotate_lists(struct jffs2_sb_info *c)
+static void jffs2_rotate_lists(struct jffs2_sb_info *c)
 {
 	uint32_t x;
-	uint32_t rotateby;
 
 	x = count_list(&c->clean_list);
-	if (x) {
-		rotateby = pseudo_random % x;
-		D1(printk(KERN_DEBUG "Rotating clean_list by %d\n", rotateby));
-
-		rotate_list((&c->clean_list), rotateby);
-
-		D1(printk(KERN_DEBUG "Erase block at front of clean_list is at %08x\n",
-			  list_entry(c->clean_list.next, struct jffs2_eraseblock, list)->offset));
-	} else {
-		D1(printk(KERN_DEBUG "Not rotating empty clean_list\n"));
-	}
-
-	x = count_list(&c->very_dirty_list);
-	if (x) {
-		rotateby = pseudo_random % x;
-		D1(printk(KERN_DEBUG "Rotating very_dirty_list by %d\n", rotateby));
-
-		rotate_list((&c->very_dirty_list), rotateby);
-
-		D1(printk(KERN_DEBUG "Erase block at front of very_dirty_list is at %08x\n",
-			  list_entry(c->very_dirty_list.next, struct jffs2_eraseblock, list)->offset));
-	} else {
-		D1(printk(KERN_DEBUG "Not rotating empty very_dirty_list\n"));
-	}
+	if (x)
+		rotate_list((&c->clean_list), pseudo_random % x);
 
 	x = count_list(&c->dirty_list);
-	if (x) {
-		rotateby = pseudo_random % x;
-		D1(printk(KERN_DEBUG "Rotating dirty_list by %d\n", rotateby));
+	if (x)
+		rotate_list((&c->dirty_list), pseudo_random % x);
 
-		rotate_list((&c->dirty_list), rotateby);
+	if (c->nr_erasing_blocks)
+		rotate_list((&c->erase_pending_list), pseudo_random % c->nr_erasing_blocks);
 
-		D1(printk(KERN_DEBUG "Erase block at front of dirty_list is at %08x\n",
-			  list_entry(c->dirty_list.next, struct jffs2_eraseblock, list)->offset));
-	} else {
-		D1(printk(KERN_DEBUG "Not rotating empty dirty_list\n"));
-	}
-
-	x = count_list(&c->erasable_list);
-	if (x) {
-		rotateby = pseudo_random % x;
-		D1(printk(KERN_DEBUG "Rotating erasable_list by %d\n", rotateby));
-
-		rotate_list((&c->erasable_list), rotateby);
-
-		D1(printk(KERN_DEBUG "Erase block at front of erasable_list is at %08x\n",
-			  list_entry(c->erasable_list.next, struct jffs2_eraseblock, list)->offset));
-	} else {
-		D1(printk(KERN_DEBUG "Not rotating empty erasable_list\n"));
-	}
-
-	if (c->nr_erasing_blocks) {
-		rotateby = pseudo_random % c->nr_erasing_blocks;
-		D1(printk(KERN_DEBUG "Rotating erase_pending_list by %d\n", rotateby));
-
-		rotate_list((&c->erase_pending_list), rotateby);
-
-		D1(printk(KERN_DEBUG "Erase block at front of erase_pending_list is at %08x\n",
-			  list_entry(c->erase_pending_list.next, struct jffs2_eraseblock, list)->offset));
-	} else {
-		D1(printk(KERN_DEBUG "Not rotating empty erase_pending_list\n"));
-	}
-
-	if (c->nr_free_blocks) {
-		rotateby = pseudo_random % c->nr_free_blocks;
-		D1(printk(KERN_DEBUG "Rotating free_list by %d\n", rotateby));
-
-		rotate_list((&c->free_list), rotateby);
-
-		D1(printk(KERN_DEBUG "Erase block at front of free_list is at %08x\n",
-			  list_entry(c->free_list.next, struct jffs2_eraseblock, list)->offset));
-	} else {
-		D1(printk(KERN_DEBUG "Not rotating empty free_list\n"));
-	}
+	if (c->nr_free_blocks) /* Not that it should ever be zero */
+		rotate_list((&c->free_list), pseudo_random % c->nr_free_blocks);
 }
-
-/*
- * Local variables:
- *   c-basic-offset: 8
- * End:
- */
diff -Nur linux/fs/jffs2/super-v24.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/super-v24.c
--- linux/fs/jffs2/super-v24.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/super-v24.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,183 +0,0 @@
-/*
- * JFFS2 -- Journalling Flash File System, Version 2.
- *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
- *
- * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
- *
- * For licensing information, see the file 'LICENCE' in this directory.
- *
- * $Id: super-v24.c,v 1.63 2002/05/20 14:56:39 dwmw2 Exp $
- *
- * ChangeLog:
- *     08-Nov-2002 Lineo Japan, Inc.  add /proc/fs/jffs2 files for JFFS2 information
- *
- */
-
-#include <linux/config.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/version.h>
-#include <linux/slab.h>
-#include <linux/init.h>
-#include <linux/list.h>
-#include <linux/fs.h>
-#include <linux/jffs2.h>
-#include <linux/pagemap.h>
-#include <linux/mtd/mtd.h>
-#include <linux/interrupt.h>
-#include "nodelist.h"
-#ifdef CONFIG_JFFS2_PROC_FS
-#include "jffs2_proc.h"
-#endif
-
-#ifndef MTD_BLOCK_MAJOR
-#define MTD_BLOCK_MAJOR 31
-#endif
-
-void jffs2_put_super (struct super_block *);
-
-static struct super_operations jffs2_super_operations =
-{
-	read_inode:	jffs2_read_inode,
-	put_super:	jffs2_put_super,
-	write_super:	jffs2_write_super,
-	statfs:		jffs2_statfs,
-	remount_fs:	jffs2_remount_fs,
-	clear_inode:	jffs2_clear_inode
-};
-
-
-static struct super_block *jffs2_read_super(struct super_block *sb, void *data, int silent)
-{
-	struct jffs2_sb_info *c;
-	int ret;
-
-	D1(printk(KERN_DEBUG "jffs2: read_super for device %s\n", kdevname(sb->s_dev)));
-
-	if (major(sb->s_dev) != MTD_BLOCK_MAJOR) {
-		if (!silent)
-			printk(KERN_DEBUG "jffs2: attempt to mount non-MTD device %s\n", kdevname(sb->s_dev));
-		return NULL;
-	}
-
-	c = JFFS2_SB_INFO(sb);
-	memset(c, 0, sizeof(*c));
-
-	sb->s_op = &jffs2_super_operations;
-
-	c->mtd = get_mtd_device(NULL, minor(sb->s_dev));
-	if (!c->mtd) {
-		D1(printk(KERN_DEBUG "jffs2: MTD device #%u doesn't appear to exist\n", minor(sb->s_dev)));
-		return NULL;
-	}
-
-	ret = jffs2_do_fill_super(sb, data, silent);
-	if (ret) {
-		put_mtd_device(c->mtd);
-		return NULL;
-	}
-
-#ifdef CONFIG_JFFS2_PROC_FS
-	if (jffs2_register_jffs2_proc_dir(sb->s_dev, c) < 0) {
-		printk(KERN_WARNING "JFFS2: Failed to register "
-			"proc file system for device %s.\n",
-			kdevname(sb->s_dev));
-	}
-#endif
-
-	return sb;
-}
-
-void jffs2_put_super (struct super_block *sb)
-{
-	struct jffs2_sb_info *c = JFFS2_SB_INFO(sb);
-
-	D2(printk(KERN_DEBUG "jffs2: jffs2_put_super()\n"));
-
-#ifdef CONFIG_JFFS2_PROC_FS
-	jffs2_unregister_jffs2_proc_dir(c);
-#endif
-
-	if (!(sb->s_flags & MS_RDONLY))
-		jffs2_stop_garbage_collect_thread(c);
-	down(&c->alloc_sem);
-	jffs2_flush_wbuf(c, 1);
-	up(&c->alloc_sem);
-	jffs2_free_ino_caches(c);
-	jffs2_free_raw_node_refs(c);
-	kfree(c->blocks);
-	if (c->mtd->sync)
-		c->mtd->sync(c->mtd);
-	put_mtd_device(c->mtd);
-	
-	D1(printk(KERN_DEBUG "jffs2_put_super returning\n"));
-}
-
-static DECLARE_FSTYPE_DEV(jffs2_fs_type, "jffs2", jffs2_read_super);
-
-static int __init init_jffs2_fs(void)
-{
-	int ret;
-
-	printk(KERN_NOTICE "JFFS2 version 2.1. (C) 2001, 2002 Red Hat, Inc., designed by Axis Communications AB.\n");
-
-#ifdef JFFS2_OUT_OF_KERNEL
-	/* sanity checks. Could we do these at compile time? */
-	if (sizeof(struct jffs2_sb_info) > sizeof (((struct super_block *)NULL)->u)) {
-		printk(KERN_ERR "JFFS2 error: struct jffs2_sb_info (%d bytes) doesn't fit in the super_block union (%d bytes)\n", 
-		       sizeof(struct jffs2_sb_info), sizeof (((struct super_block *)NULL)->u));
-		return -EIO;
-	}
-
-	if (sizeof(struct jffs2_inode_info) > sizeof (((struct inode *)NULL)->u)) {
-		printk(KERN_ERR "JFFS2 error: struct jffs2_inode_info (%d bytes) doesn't fit in the inode union (%d bytes)\n", 
-		       sizeof(struct jffs2_inode_info), sizeof (((struct inode *)NULL)->u));
-		return -EIO;
-	}
-#endif
-	ret = jffs2_zlib_init();
-	if (ret) {
-		printk(KERN_ERR "JFFS2 error: Failed to initialise zlib workspaces\n");
-		goto out;
-	}
-	ret = jffs2_create_slab_caches();
-	if (ret) {
-		printk(KERN_ERR "JFFS2 error: Failed to initialise slab caches\n");
-		goto out_zlib;
-	}
-	ret = register_filesystem(&jffs2_fs_type);
-	if (ret) {
-		printk(KERN_ERR "JFFS2 error: Failed to register filesystem\n");
-		goto out_slab;
-	}
-
-#ifdef CONFIG_JFFS2_PROC_FS
-	jffs2_proc_root = proc_mkdir("jffs2", proc_root_fs);
-#endif
-
-	return 0;
-
- out_slab:
-	jffs2_destroy_slab_caches();
- out_zlib:
-	jffs2_zlib_exit();
- out:
-
-	return ret;
-}
-
-static void __exit exit_jffs2_fs(void)
-{
-	jffs2_destroy_slab_caches();
-	jffs2_zlib_exit();
-	unregister_filesystem(&jffs2_fs_type);
-}
-
-module_init(init_jffs2_fs);
-module_exit(exit_jffs2_fs);
-
-MODULE_DESCRIPTION("The Journalling Flash File System, v2");
-MODULE_AUTHOR("Red Hat, Inc.");
-MODULE_LICENSE("GPL"); // Actually dual-licensed, but it doesn't matter for 
-		       // the sake of this tag. It's Free Software.
diff -Nur linux/fs/jffs2/super.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/super.c
--- linux/fs/jffs2/super.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/super.c	2003-06-23 01:47:04.000000000 +0700
@@ -1,13 +1,37 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
+ * Copyright (C) 2001 Red Hat, Inc.
  *
  * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: super.c,v 1.73 2002/07/23 17:00:45 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: super.c,v 1.48.2.2 2002/03/12 15:36:43 dwmw2 Exp $
  *
  */
 
@@ -23,233 +47,244 @@
 #include <linux/pagemap.h>
 #include <linux/mtd/mtd.h>
 #include <linux/interrupt.h>
-#include <linux/ctype.h>
-#include <linux/namei.h>
 #include "nodelist.h"
 
-void jffs2_put_super (struct super_block *);
-
-
-static kmem_cache_t *jffs2_inode_cachep;
-
-static struct inode *jffs2_alloc_inode(struct super_block *sb)
-{
-	struct jffs2_inode_info *ei;
-	ei = (struct jffs2_inode_info *)kmem_cache_alloc(jffs2_inode_cachep, SLAB_KERNEL);
-	if (!ei)
-		return NULL;
-	return &ei->vfs_inode;
-}
-
-static void jffs2_destroy_inode(struct inode *inode)
-{
-	kmem_cache_free(jffs2_inode_cachep, JFFS2_INODE_INFO(inode));
-}
+#ifndef MTD_BLOCK_MAJOR
+#define MTD_BLOCK_MAJOR 31
+#endif
 
-static void jffs2_i_init_once(void * foo, kmem_cache_t * cachep, unsigned long flags)
-{
-	struct jffs2_inode_info *ei = (struct jffs2_inode_info *) foo;
-
-	if ((flags & (SLAB_CTOR_VERIFY|SLAB_CTOR_CONSTRUCTOR)) ==
-	    SLAB_CTOR_CONSTRUCTOR) {
-		init_MUTEX(&ei->sem);
-		inode_init_once(&ei->vfs_inode);
-	}
-}
+extern void jffs2_read_inode (struct inode *);
+void jffs2_put_super (struct super_block *);
+void jffs2_write_super (struct super_block *);
+static int jffs2_statfs (struct super_block *, struct statfs *);
+int jffs2_remount_fs (struct super_block *, int *, char *);
+extern void jffs2_clear_inode (struct inode *);
 
 static struct super_operations jffs2_super_operations =
 {
-	.alloc_inode =	jffs2_alloc_inode,
-	.destroy_inode =jffs2_destroy_inode,
-	.read_inode =	jffs2_read_inode,
-	.put_super =	jffs2_put_super,
-	.write_super =	jffs2_write_super,
-	.statfs =	jffs2_statfs,
-	.remount_fs =	jffs2_remount_fs,
-	.clear_inode =	jffs2_clear_inode
+	read_inode:	jffs2_read_inode,
+//	delete_inode:	jffs2_delete_inode,
+	put_super:	jffs2_put_super,
+	write_super:	jffs2_write_super,
+	statfs:		jffs2_statfs,
+	remount_fs:	jffs2_remount_fs,
+	clear_inode:	jffs2_clear_inode
 };
 
-static int jffs2_sb_compare(struct super_block *sb, void *data)
+static int jffs2_statfs(struct super_block *sb, struct statfs *buf)
 {
-	struct jffs2_sb_info *p = data;
 	struct jffs2_sb_info *c = JFFS2_SB_INFO(sb);
+	unsigned long avail;
+
+	buf->f_type = JFFS2_SUPER_MAGIC;
+	buf->f_bsize = 1 << PAGE_SHIFT;
+	buf->f_blocks = c->flash_size >> PAGE_SHIFT;
+	buf->f_files = 0;
+	buf->f_ffree = 0;
+	buf->f_namelen = JFFS2_MAX_NAME_LEN;
+
+	spin_lock_bh(&c->erase_completion_lock);
+
+	avail = c->dirty_size + c->free_size;
+	if (avail > c->sector_size * JFFS2_RESERVED_BLOCKS_WRITE)
+		avail -= c->sector_size * JFFS2_RESERVED_BLOCKS_WRITE;
+	else
+		avail = 0;
+
+	buf->f_bavail = buf->f_bfree = avail >> PAGE_SHIFT;
+
+#if CONFIG_JFFS2_FS_DEBUG > 0
+	printk(KERN_DEBUG "STATFS:\n");
+	printk(KERN_DEBUG "flash_size: %08x\n", c->flash_size);
+	printk(KERN_DEBUG "used_size: %08x\n", c->used_size);
+	printk(KERN_DEBUG "dirty_size: %08x\n", c->dirty_size);
+	printk(KERN_DEBUG "free_size: %08x\n", c->free_size);
+	printk(KERN_DEBUG "erasing_size: %08x\n", c->erasing_size);
+	printk(KERN_DEBUG "bad_size: %08x\n", c->bad_size);
+	printk(KERN_DEBUG "sector_size: %08x\n", c->sector_size);
 
-	/* The superblocks are considered to be equivalent if the underlying MTD
-	   device is the same one */
-	if (c->mtd == p->mtd) {
-		D1(printk(KERN_DEBUG "jffs2_sb_compare: match on device %d (\"%s\")\n", p->mtd->index, p->mtd->name));
-		return 1;
+	if (c->nextblock) {
+		printk(KERN_DEBUG "nextblock: 0x%08x\n", c->nextblock->offset);
 	} else {
-		D1(printk(KERN_DEBUG "jffs2_sb_compare: No match, device %d (\"%s\"), device %d (\"%s\")\n",
-			  c->mtd->index, c->mtd->name, p->mtd->index, p->mtd->name));
-		return 0;
+		printk(KERN_DEBUG "nextblock: NULL\n");
 	}
-}
-
-static int jffs2_sb_set(struct super_block *sb, void *data)
-{
-	struct jffs2_sb_info *p = data;
-
-	/* For persistence of NFS exports etc. we use the same s_dev
-	   each time we mount the device, don't just use an anonymous
-	   device */
-	sb->u.generic_sbp = p;
-	p->os_priv = sb;
-	sb->s_dev = MKDEV(MTD_BLOCK_MAJOR, p->mtd->index);
-
-	return 0;
-}
-
-static struct super_block *jffs2_get_sb_mtd(struct file_system_type *fs_type,
-					      int flags, char *dev_name, 
-					      void *data, struct mtd_info *mtd)
-{
-	struct super_block *sb;
-	struct jffs2_sb_info *c;
-	int ret;
-
-	c = kmalloc(sizeof(*c), GFP_KERNEL);
-	if (!c)
-		return ERR_PTR(-ENOMEM);
-	memset(c, 0, sizeof(*c));
-	c->mtd = mtd;
+	if (c->gcblock) {
+		printk(KERN_DEBUG "gcblock: 0x%08x\n", c->gcblock->offset);
+	} else {
+		printk(KERN_DEBUG "gcblock: NULL\n");
+	}
+	if (list_empty(&c->clean_list)) {
+		printk(KERN_DEBUG "clean_list: empty\n");
+	} else {
+		struct list_head *this;
 
-	sb = sget(fs_type, jffs2_sb_compare, jffs2_sb_set, c);
+		list_for_each(this, &c->clean_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+			printk(KERN_DEBUG "clean_list: %08x\n", jeb->offset);
+		}
+	}
+	if (list_empty(&c->dirty_list)) {
+		printk(KERN_DEBUG "dirty_list: empty\n");
+	} else {
+		struct list_head *this;
 
-	if (IS_ERR(sb))
-		goto out_put;
+		list_for_each(this, &c->dirty_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+			printk(KERN_DEBUG "dirty_list: %08x\n", jeb->offset);
+		}
+	}
+	if (list_empty(&c->erasing_list)) {
+		printk(KERN_DEBUG "erasing_list: empty\n");
+	} else {
+		struct list_head *this;
 
-	if (sb->s_root) {
-		/* New mountpoint for JFFS2 which is already mounted */
-		D1(printk(KERN_DEBUG "jffs2_get_sb_mtd(): Device %d (\"%s\") is already mounted\n",
-			  mtd->index, mtd->name));
-		goto out_put;
+		list_for_each(this, &c->erasing_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+			printk(KERN_DEBUG "erasing_list: %08x\n", jeb->offset);
+		}
 	}
+	if (list_empty(&c->erase_pending_list)) {
+		printk(KERN_DEBUG "erase_pending_list: empty\n");
+	} else {
+		struct list_head *this;
 
-	D1(printk(KERN_DEBUG "jffs2_get_sb_mtd(): New superblock for device %d (\"%s\")\n",
-		  mtd->index, mtd->name));
+		list_for_each(this, &c->erase_pending_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+			printk(KERN_DEBUG "erase_pending_list: %08x\n", jeb->offset);
+		}
+	}
+	if (list_empty(&c->free_list)) {
+		printk(KERN_DEBUG "free_list: empty\n");
+	} else {
+		struct list_head *this;
 
-	sb->s_op = &jffs2_super_operations;
+		list_for_each(this, &c->free_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+			printk(KERN_DEBUG "free_list: %08x\n", jeb->offset);
+		}
+	}
+	if (list_empty(&c->bad_list)) {
+		printk(KERN_DEBUG "bad_list: empty\n");
+	} else {
+		struct list_head *this;
 
-	ret = jffs2_do_fill_super(sb, data, (flags&MS_VERBOSE)?1:0);
+		list_for_each(this, &c->bad_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+			printk(KERN_DEBUG "bad_list: %08x\n", jeb->offset);
+		}
+	}
+	if (list_empty(&c->bad_used_list)) {
+		printk(KERN_DEBUG "bad_used_list: empty\n");
+	} else {
+		struct list_head *this;
 
-	if (ret) {
-		/* Failure case... */
-		up_write(&sb->s_umount);
-		deactivate_super(sb);
-		sb = ERR_PTR(ret);
-		goto out_put1;
+		list_for_each(this, &c->bad_used_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+			printk(KERN_DEBUG "bad_used_list: %08x\n", jeb->offset);
+		}
 	}
+#endif /* CONFIG_JFFS2_FS_DEBUG */
 
-	sb->s_flags |= MS_ACTIVE;
-	return sb;
+	spin_unlock_bh(&c->erase_completion_lock);
 
- out_put:
-	kfree(c);
- out_put1:
-	put_mtd_device(mtd);
 
-	return sb;
+	return 0;
 }
 
-static struct super_block *jffs2_get_sb_mtdnr(struct file_system_type *fs_type,
-					      int flags, char *dev_name, 
-					      void *data, int mtdnr)
+static struct super_block *jffs2_read_super(struct super_block *sb, void *data, int silent)
 {
-	struct mtd_info *mtd;
-
-	mtd = get_mtd_device(NULL, mtdnr);
-	if (!mtd) {
-		D1(printk(KERN_DEBUG "jffs2: MTD device #%u doesn't appear to exist\n", mtdnr));
-		return ERR_PTR(-EINVAL);
-	}
+	struct jffs2_sb_info *c;
+	struct inode *root_i;
+	int i;
 
-	return jffs2_get_sb_mtd(fs_type, flags, dev_name, data, mtd);
-}
+	D1(printk(KERN_DEBUG "jffs2: read_super for device %s\n", kdevname(sb->s_dev)));
 
-static struct super_block *jffs2_get_sb(struct file_system_type *fs_type,
-					int flags, char *dev_name, void *data)
-{
-	int err;
-	struct nameidata nd;
-	int mtdnr;
-	kdev_t dev;
-
-	if (!dev_name)
-		return ERR_PTR(-EINVAL);
-
-	D1(printk(KERN_DEBUG "jffs2_get_sb(): dev_name \"%s\"\n", dev_name));
-
-	/* The preferred way of mounting in future; especially when
-	   CONFIG_BLK_DEV is implemented - we specify the underlying
-	   MTD device by number or by name, so that we don't require 
-	   block device support to be present in the kernel. */
-
-	/* FIXME: How to do the root fs this way? */
-
-	if (dev_name[0] == 'm' && dev_name[1] == 't' && dev_name[2] == 'd') {
-		/* Probably mounting without the blkdev crap */
-		if (dev_name[3] == ':') {
-			struct mtd_info *mtd;
-
-			/* Mount by MTD device name */
-			D1(printk(KERN_DEBUG "jffs2_get_sb(): mtd:%%s, name \"%s\"\n", dev_name+4));
-			for (mtdnr = 0; mtdnr < MAX_MTD_DEVICES; mtdnr++) {
-				mtd = get_mtd_device(NULL, mtdnr);
-				if (mtd) {
-					if (!strcmp(mtd->name, dev_name+4))
-						return jffs2_get_sb_mtd(fs_type, flags, dev_name, data, mtd);
-					put_mtd_device(mtd);
-				}
-			}
-			printk(KERN_NOTICE "jffs2_get_sb(): MTD device with name \"%s\" not found.\n", dev_name+4);
-		} else if (isdigit(dev_name[3])) {
-			/* Mount by MTD device number name */
-			char *endptr;
-			
-			mtdnr = simple_strtoul(dev_name+3, &endptr, 0);
-			if (!*endptr) {
-				/* It was a valid number */
-				D1(printk(KERN_DEBUG "jffs2_get_sb(): mtd%%d, mtdnr %d\n", mtdnr));
-				return jffs2_get_sb_mtdnr(fs_type, flags, dev_name, data, mtdnr);
-			}
-		}
+	if (MAJOR(sb->s_dev) != MTD_BLOCK_MAJOR) {
+		if (!silent)
+			printk(KERN_DEBUG "jffs2: attempt to mount non-MTD device %s\n", kdevname(sb->s_dev));
+		return NULL;
 	}
 
-	/* Try the old way - the hack where we allowed users to mount 
-	   /dev/mtdblock$(n) but didn't actually _use_ the blkdev */
-
-	err = path_lookup(dev_name, LOOKUP_FOLLOW, &nd);
-
-	D1(printk(KERN_DEBUG "jffs2_get_sb(): path_lookup() returned %d, inode %p\n",
-		  err, nd.dentry->d_inode));
-
-	if (err)
-		return ERR_PTR(err);
-
-	if (!S_ISBLK(nd.dentry->d_inode->i_mode)) {
-		path_release(&nd);
-		return ERR_PTR(-EINVAL);
+	c = JFFS2_SB_INFO(sb);
+	memset(c, 0, sizeof(*c));
+	
+	c->mtd = get_mtd_device(NULL, MINOR(sb->s_dev));
+	if (!c->mtd) {
+		D1(printk(KERN_DEBUG "jffs2: MTD device #%u doesn't appear to exist\n", MINOR(sb->s_dev)));
+		return NULL;
 	}
-	if (nd.mnt->mnt_flags & MNT_NODEV) {
-		path_release(&nd);
-		return ERR_PTR(-EACCES);
+	c->sector_size = c->mtd->erasesize;
+	c->free_size = c->flash_size = c->mtd->size;
+	c->nr_blocks = c->mtd->size / c->mtd->erasesize;
+	c->blocks = kmalloc(sizeof(struct jffs2_eraseblock) * c->nr_blocks, GFP_KERNEL);
+	if (!c->blocks)
+		goto out_mtd;
+	for (i=0; i<c->nr_blocks; i++) {
+		INIT_LIST_HEAD(&c->blocks[i].list);
+		c->blocks[i].offset = i * c->sector_size;
+		c->blocks[i].free_size = c->sector_size;
+		c->blocks[i].dirty_size = 0;
+		c->blocks[i].used_size = 0;
+		c->blocks[i].first_node = NULL;
+		c->blocks[i].last_node = NULL;
+	}
+		
+	spin_lock_init(&c->nodelist_lock);
+	init_MUTEX(&c->alloc_sem);
+	init_waitqueue_head(&c->erase_wait);
+	spin_lock_init(&c->erase_completion_lock);
+	spin_lock_init(&c->inocache_lock);
+
+	INIT_LIST_HEAD(&c->clean_list);
+	INIT_LIST_HEAD(&c->dirty_list);
+	INIT_LIST_HEAD(&c->erasing_list);
+	INIT_LIST_HEAD(&c->erase_pending_list);
+	INIT_LIST_HEAD(&c->erase_complete_list);
+	INIT_LIST_HEAD(&c->free_list);
+	INIT_LIST_HEAD(&c->bad_list);
+	INIT_LIST_HEAD(&c->bad_used_list);
+	c->highest_ino = 1;
+
+	if (jffs2_build_filesystem(c)) {
+		D1(printk(KERN_DEBUG "build_fs failed\n"));
+		goto out_nodes;
 	}
 
-	dev = nd.dentry->d_inode->i_rdev;
-	path_release(&nd);
+	sb->s_op = &jffs2_super_operations;
 
-	if (major(dev) != MTD_BLOCK_MAJOR) {
-		if (!(flags & MS_VERBOSE)) /* Yes I mean this. Strangely */
-			printk(KERN_NOTICE "Attempt to mount non-MTD device \"%s\" as JFFS2\n",
-			       dev_name);
-		return ERR_PTR(-EINVAL);
-	}
+	D1(printk(KERN_DEBUG "jffs2_read_super(): Getting root inode\n"));
+	root_i = iget(sb, 1);
+	if (is_bad_inode(root_i)) {
+		D1(printk(KERN_WARNING "get root inode failed\n"));
+		goto out_nodes;
+	}
+
+	D1(printk(KERN_DEBUG "jffs2_read_super(): d_alloc_root()\n"));
+	sb->s_root = d_alloc_root(root_i);
+	if (!sb->s_root)
+		goto out_root_i;
+
+#if LINUX_VERSION_CODE >= 0x20403
+	sb->s_maxbytes = 0xFFFFFFFF;
+#endif
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	sb->s_magic = JFFS2_SUPER_MAGIC;
+	if (!(sb->s_flags & MS_RDONLY))
+		jffs2_start_garbage_collect_thread(c);
+	return sb;
 
-	return jffs2_get_sb_mtdnr(fs_type, flags, dev_name, data, minor(dev));
+ out_root_i:
+	iput(root_i);
+ out_nodes:
+	jffs2_free_ino_caches(c);
+	jffs2_free_raw_node_refs(c);
+	kfree(c->blocks);
+ out_mtd:
+	put_mtd_device(c->mtd);
+	return NULL;
 }
 
-
 void jffs2_put_super (struct super_block *sb)
 {
 	struct jffs2_sb_info *c = JFFS2_SB_INFO(sb);
@@ -258,83 +293,91 @@
 
 	if (!(sb->s_flags & MS_RDONLY))
 		jffs2_stop_garbage_collect_thread(c);
-	down(&c->alloc_sem);
-	jffs2_flush_wbuf(c, 1);
-	up(&c->alloc_sem);
 	jffs2_free_ino_caches(c);
 	jffs2_free_raw_node_refs(c);
 	kfree(c->blocks);
-	if (c->wbuf)
-		kfree(c->wbuf);
-	kfree(c->inocache_list);
 	if (c->mtd->sync)
 		c->mtd->sync(c->mtd);
-
+	put_mtd_device(c->mtd);
+	
 	D1(printk(KERN_DEBUG "jffs2_put_super returning\n"));
 }
 
-static void jffs2_kill_sb(struct super_block *sb)
+int jffs2_remount_fs (struct super_block *sb, int *flags, char *data)
 {
 	struct jffs2_sb_info *c = JFFS2_SB_INFO(sb);
-	generic_shutdown_super(sb);
-	put_mtd_device(c->mtd);
-	kfree(c);
+
+	if (c->flags & JFFS2_SB_FLAG_RO && !(sb->s_flags & MS_RDONLY))
+		return -EROFS;
+
+	/* We stop if it was running, then restart if it needs to.
+	   This also catches the case where it was stopped and this
+	   is just a remount to restart it */
+	if (!(sb->s_flags & MS_RDONLY))
+		jffs2_stop_garbage_collect_thread(c);
+
+	if (!(*flags & MS_RDONLY))
+		jffs2_start_garbage_collect_thread(c);
+	
+	sb->s_flags = (sb->s_flags & ~MS_RDONLY)|(*flags & MS_RDONLY);
+
+	return 0;
 }
- 
-static struct file_system_type jffs2_fs_type = {
-	.owner =	THIS_MODULE,
-	.name =		"jffs2",
-	.get_sb =	jffs2_get_sb,
-	.kill_sb =	jffs2_kill_sb,
-};
 
+void jffs2_write_super (struct super_block *sb)
+{
+	struct jffs2_sb_info *c = JFFS2_SB_INFO(sb);
+	sb->s_dirt = 0;
+
+	if (sb->s_flags & MS_RDONLY)
+		return;
+
+	jffs2_garbage_collect_trigger(c);
+	jffs2_erase_pending_blocks(c);
+	jffs2_mark_erased_blocks(c);
+}
 
 
+static DECLARE_FSTYPE_DEV(jffs2_fs_type, "jffs2", jffs2_read_super);
+
 static int __init init_jffs2_fs(void)
 {
 	int ret;
 
-	printk(KERN_INFO "JFFS2 version 2.1. (C) 2001, 2002 Red Hat, Inc.\n");
+	printk(KERN_NOTICE "JFFS2 version 2.1. (C) 2001 Red Hat, Inc., designed by Axis Communications AB.\n");
 
-	jffs2_inode_cachep = kmem_cache_create("jffs2_i",
-					     sizeof(struct jffs2_inode_info),
-					     0, SLAB_HWCACHE_ALIGN,
-					     jffs2_i_init_once, NULL);
-	if (!jffs2_inode_cachep) {
-		printk(KERN_ERR "JFFS2 error: Failed to initialise inode cache\n");
-		return -ENOMEM;
-	}
-	ret = jffs2_zlib_init();
-	if (ret) {
-		printk(KERN_ERR "JFFS2 error: Failed to initialise zlib workspaces\n");
-		goto out;
+#ifdef JFFS2_OUT_OF_KERNEL
+	/* sanity checks. Could we do these at compile time? */
+	if (sizeof(struct jffs2_sb_info) > sizeof (((struct super_block *)NULL)->u)) {
+		printk(KERN_ERR "JFFS2 error: struct jffs2_sb_info (%d bytes) doesn't fit in the super_block union (%d bytes)\n", 
+		       sizeof(struct jffs2_sb_info), sizeof (((struct super_block *)NULL)->u));
+		return -EIO;
+	}
+
+	if (sizeof(struct jffs2_inode_info) > sizeof (((struct inode *)NULL)->u)) {
+		printk(KERN_ERR "JFFS2 error: struct jffs2_inode_info (%d bytes) doesn't fit in the inode union (%d bytes)\n", 
+		       sizeof(struct jffs2_inode_info), sizeof (((struct inode *)NULL)->u));
+		return -EIO;
 	}
+#endif
+
 	ret = jffs2_create_slab_caches();
 	if (ret) {
 		printk(KERN_ERR "JFFS2 error: Failed to initialise slab caches\n");
-		goto out_zlib;
+		return ret;
 	}
 	ret = register_filesystem(&jffs2_fs_type);
 	if (ret) {
 		printk(KERN_ERR "JFFS2 error: Failed to register filesystem\n");
-		goto out_slab;
+		jffs2_destroy_slab_caches();
 	}
-	return 0;
-
- out_slab:
-	jffs2_destroy_slab_caches();
- out_zlib:
-	jffs2_zlib_exit();
- out:
 	return ret;
 }
 
 static void __exit exit_jffs2_fs(void)
 {
-	unregister_filesystem(&jffs2_fs_type);
 	jffs2_destroy_slab_caches();
-	jffs2_zlib_exit();
-	kmem_cache_destroy(jffs2_inode_cachep);
+	unregister_filesystem(&jffs2_fs_type);
 }
 
 module_init(init_jffs2_fs);
diff -Nur linux/fs/jffs2/symlink.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/symlink.c
--- linux/fs/jffs2/symlink.c	2003-05-13 16:19:13.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/symlink.c	2003-06-23 01:47:04.000000000 +0700
@@ -5,9 +5,33 @@
  *
  * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: symlink.c,v 1.11 2002/07/23 17:00:45 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: symlink.c,v 1.5.2.1 2002/01/15 10:39:06 dwmw2 Exp $
  *
  */
 
@@ -15,6 +39,7 @@
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/fs.h>
+#include <linux/jffs2.h>
 #include "nodelist.h"
 
 int jffs2_readlink(struct dentry *dentry, char *buffer, int buflen);
@@ -22,17 +47,45 @@
 
 struct inode_operations jffs2_symlink_inode_operations =
 {	
-	.readlink =	jffs2_readlink,
-	.follow_link =	jffs2_follow_link,
-	.setattr =	jffs2_setattr
+	readlink:	jffs2_readlink,
+	follow_link:	jffs2_follow_link,
+	setattr:	jffs2_setattr
 };
 
+static char *jffs2_getlink(struct dentry *dentry)
+{
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(dentry->d_inode);
+	char *buf;
+	int ret;
+
+	down(&f->sem);
+	if (!f->metadata) {
+		up(&f->sem);
+		printk(KERN_NOTICE "No metadata for symlink inode #%lu\n", dentry->d_inode->i_ino);
+		return ERR_PTR(-EINVAL);
+	}
+	buf = kmalloc(f->metadata->size+1, GFP_USER);
+	if (!buf) {
+		up(&f->sem);
+		return ERR_PTR(-ENOMEM);
+	}
+	buf[f->metadata->size]=0;
+
+	ret = jffs2_read_dnode(JFFS2_SB_INFO(dentry->d_inode->i_sb), f->metadata, buf, 0, f->metadata->size);
+	up(&f->sem);
+	if (ret) {
+		kfree(buf);
+		return ERR_PTR(ret);
+	}
+	return buf;
+
+}
 int jffs2_readlink(struct dentry *dentry, char *buffer, int buflen)
 {
 	unsigned char *kbuf;
 	int ret;
 
-	kbuf = jffs2_getlink(JFFS2_SB_INFO(dentry->d_inode->i_sb), JFFS2_INODE_INFO(dentry->d_inode));
+	kbuf = jffs2_getlink(dentry);
 	if (IS_ERR(kbuf))
 		return PTR_ERR(kbuf);
 
@@ -46,7 +99,7 @@
 	unsigned char *buf;
 	int ret;
 
-	buf = jffs2_getlink(JFFS2_SB_INFO(dentry->d_inode->i_sb), JFFS2_INODE_INFO(dentry->d_inode));
+	buf = jffs2_getlink(dentry);
 
 	if (IS_ERR(buf))
 		return PTR_ERR(buf);
diff -Nur linux/fs/jffs2/test/compr_rubin.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/test/compr_rubin.h
--- linux/fs/jffs2/test/compr_rubin.h	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/test/compr_rubin.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,13 +0,0 @@
-/* Rubin encoder/decoder header       */
-/* work started at   : aug   3, 1994  */
-/* last modification : aug  15, 1994  */
-
-#define RUBIN_REG_SIZE   16
-#define UPPER_BIT_RUBIN    (((long) 1)<<RUBIN_REG_SIZE-1)
-#define LOWER_BITS_RUBIN   ((((long) 1)<<RUBIN_REG_SIZE-1)-1)
-
-void init_rubin (void);
-void encode (long, long, int);
-void end_rubin (void);
-void init_decod (void);
-int decode (long, long);
diff -Nur linux/fs/jffs2/test/histo.cc /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/test/histo.cc
--- linux/fs/jffs2/test/histo.cc	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/test/histo.cc	1970-01-01 07:00:00.000000000 +0700
@@ -1,80 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <assert.h>
-
-int histo[256];
-int histo2[256];
-int bits[8];
-int total;
-void main() 
-{
-	FILE *file;
-	int i,i2;
-
-	int max=0; 
-	
-/*	file = fopen("/lib/libc-2.2.so","r"); */
-	file = fopen("bigsymb2","r");
-	assert(file!=NULL);
-	while (!feof(file)) {
-		unsigned char cr;
-		fread(&cr,1,1,file);
-		histo[cr]++;		
-		if (histo[cr]>max)
-			max = histo[cr];
-	}	
-	fclose(file);
-
-	i2 = 0;
-
-#if 0
-	printf("static int xlate[257] = { ");
-
-
-	
-	/* Ugh slow */
-	while (max>=0) {	
-		for (i=0;i<256;i++) {	
-			if (histo[i]==max) {
-				printf("\t%i,\n",i);
-				histo2[i2++]=histo[i];
-			}
-		}
-		max--;
-	}	
-
-	printf(" };\n");
-
-	if (i2!=256)
-		printf("/* Uh oh: %i != 256 */ \n");
-#endif
-	
-	for (i=0;i<256;i++) {
-		if (i&128)
-			bits[7]+=histo[i];
-		if (i&64)
-			bits[6]+=histo[i];
-		if (i&32)
-			bits[5]+=histo[i];
-		if (i&16)
-			bits[4]+=histo[i];
-		if (i&8)
-			bits[3]+=histo[i];
-		if (i&4)
-			bits[2]+=histo[i];
-		if (i&2)
-			bits[1]+=histo[i];
-		if (i&1)
-			bits[0]+=histo[i];
-		total+=histo[i];
-	}
-	
-	printf("#define BIT_DIVIDER %i \n",total>>12);
-	printf("static int bits[9] = { ");
-	for (i=0;i<8;i++)
-		if ((bits[i]>>12)>0)
-			printf("%i,",bits[i]>>12);
-		else 
-			printf("1, ");
-	printf("};\n");
-}
\ No newline at end of file
diff -Nur linux/fs/jffs2/test/histo.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/test/histo.h
--- linux/fs/jffs2/test/histo.h	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/test/histo.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,2 +0,0 @@
-#define BIT_DIVIDER 1043 
-static int bits[9] = { 277,249,290,267,229,341,212,241,};
diff -Nur linux/fs/jffs2/test/histo1.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/test/histo1.h
--- linux/fs/jffs2/test/histo1.h	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/test/histo1.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,2 +0,0 @@
-#define BIT_DIVIDER 755 
-static int bits[9] = { 108,125,128,93,84,89,119,94,};
diff -Nur linux/fs/jffs2/test/histo2.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/test/histo2.h
--- linux/fs/jffs2/test/histo2.h	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/test/histo2.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,2 +0,0 @@
-#define BIT_DIVIDER 504 
-static int bits[9] = { 250,210,239,238,233,307,237,144,};
diff -Nur linux/fs/jffs2/test/histo_html.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/test/histo_html.h
--- linux/fs/jffs2/test/histo_html.h	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/test/histo_html.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,2 +0,0 @@
-#define BIT_DIVIDER 631 
-static int bits[9] = { 268,247,324,252,199,529,436,1, };
diff -Nur linux/fs/jffs2/test/histo_text.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/test/histo_text.h
--- linux/fs/jffs2/test/histo_text.h	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/test/histo_text.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,2 +0,0 @@
-#define BIT_DIVIDER 1187 
-static int bits[9] = { 518,418,533,414,310,1069,822,1, };
diff -Nur linux/fs/jffs2/test/main.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/test/main.c
--- linux/fs/jffs2/test/main.c	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/test/main.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,56 +0,0 @@
-#include <stdio.h>
-
-#include "compr_rubin.h"
-
-#define __u32 int
-
-/* _compress returns the compressed size, -1 if bigger */
-int rtime_compress(unsigned char *data_in, unsigned char *cpage_out, 
-		   __u32 *sourcelen, __u32 *dstlen);
-
-void rtime_decompress(unsigned char *data_in, unsigned char *cpage_out,
-		      __u32 srclen, __u32 destlen);
-
-void main()
-{
-	unsigned char source[4096];
-	unsigned char compr[40960];
-	unsigned char dest[4096];
-
-	int result;
-	int i;
-	int len,maxlen;
-	FILE *file;
-	
-	memset(dest,0xA5,sizeof(dest));
-	
-	for (i=0;i<4096;i++)
-		source[i] = i;
-		
-	file=fopen("asd","r");
-	while (!feof(file)) {
-		fread(source,1,4096,file);
-	
-		len = 4096;
-		maxlen = 40960;
-		result = rubin_compress(source,compr,&len, &maxlen);
-		if (result) {
-			printf("result is %d, exiting\n",result);
-			exit(0);
-		}
-		printf("Compressed to %i bytes \n",maxlen);
-		
-		if (maxlen>4096)
-			continue;
-	
-		rubin_decompress(compr,dest,4096,4096);
-		for (i=0;i<4096;i++)
-			if (source[i]!=dest[i]) {
-				printf("Mismatch at position %i: %i -> %i \n",i,source[i],dest[i]);
-			
-			}
-		
-	}
-	fclose(file);
-}
-
diff -Nur linux/fs/jffs2/test/pushpull.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/test/pushpull.h
--- linux/fs/jffs2/test/pushpull.h	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/test/pushpull.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,11 +0,0 @@
-#define  PPBUFSIZ   2048
-void pushinit(unsigned char *buffer, unsigned int max);
-void pushbit(int bit);
-void pushblk(int blk, int bitsinblk);
-void pushexit(void);
-int pushedbits(void);
-void pullinit(unsigned char *buffer);
-int pullbit(void);
-int pullblk(int bitsinblk);
-void pullexit(void);
-int pulledbits(void);
diff -Nur linux/fs/jffs2/test/rtime.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/test/rtime.h
--- linux/fs/jffs2/test/rtime.h	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/test/rtime.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,8 +0,0 @@
-#define __u32 int
-
-/* _compress returns the compressed size, -1 if bigger */
-int rtime_compress(unsigned char *data_in, unsigned char *cpage_out, 
-		   __u32 *sourcelen, __u32 *dstlen);
-
-void rtime_decompress(unsigned char *data_in, unsigned char *cpage_out,
-		      __u32 srclen, __u32 destlen);
diff -Nur linux/fs/jffs2/wbuf.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/wbuf.c
--- linux/fs/jffs2/wbuf.c	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/wbuf.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,867 +0,0 @@
-/*
- * JFFS2 -- Journalling Flash File System, Version 2.
- *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
- *
- * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
- *
- * For licensing information, see the file 'LICENCE' in this directory.
- *
- * $Id: wbuf.c,v 1.17 2002/08/29 21:45:54 gleixner Exp $
- *
- * ChangeLog:
- *     25-Oct-2002 Lineo Japan, Inc.  deal with 1bit corruption of oob area
- *     08-Oct-2002 Lineo Japan, Inc.  move failure counter pos in oob
- *     04-Oct-2002 Lineo Japan, Inc.  correct jeb->bad_count value when
- *       failure count is 0xff
- *     25-Sep-2002 Lineo Japan, Inc.  take hamming distance for oob value
- *       into consideration
- *     17-Sep-2002 Lineo Japan, Inc.  add code for post-badblock 
- *
- * ChangeLog:
- *     24-Nov-2002 SHARP  add erasing_dirty_size
- *     25-Oct-2002 Lineo Japan, Inc.  deal with 1bit corruption of oob area
- *     08-Oct-2002 Lineo Japan, Inc.  move failure counter pos in oob
- *     04-Oct-2002 Lineo Japan, Inc.  correct jeb->bad_count value when
- *       failure count is 0xff
- *     25-Sep-2002 Lineo Japan, Inc.  take hamming distance for oob value
- *       into consideration
- *     17-Sep-2002 Lineo Japan, Inc.  add code for post-badblock 
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/mtd/mtd.h>
-#include <linux/interrupt.h>
-#include "crc32.h"
-#include <linux/mtd/nand.h>
-#include "nodelist.h"
-
-/* max. erase failures before we mark a block bad */
-#define MAX_ERASE_FAILURES 	5
-
-/* two seconds timeout for timed wbuf-flushing */
-#define WBUF_FLUSH_TIMEOUT	2 * HZ
-
-#ifdef CONFIG_ARCH_SHARP_SL
-#define FAILURECOUNTER_POS NAND_POSTBADBLOCK_POS
-#else
-#define FAILURECOUNTER_POS NAND_BADBLOCK_POS
-#endif
-
-static inline void jffs2_refile_wbuf_blocks(struct jffs2_sb_info *c)
-{
-	struct list_head *this, *next;
-	static int n;
-
-	if (list_empty(&c->erasable_pending_wbuf_list))
-		return;
-
-	list_for_each_safe(this, next, &c->erasable_pending_wbuf_list) {
-		struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
-
-		D1(printk(KERN_DEBUG "Removing eraseblock at 0x%08x from erasable_pending_wbuf_list...\n", jeb->offset));
-		list_del(this);
-		if ((jiffies + (n++)) & 127) {
-			/* Most of the time, we just erase it immediately. Otherwise we
-			   spend ages scanning it on mount, etc. */
-			D1(printk(KERN_DEBUG "...and adding to erase_pending_list\n"));
-			list_add_tail(&jeb->list, &c->erase_pending_list);
-			c->erasing_dirty_size += jeb->dirty_size;
-			c->nr_erasing_blocks++;
-			jffs2_erase_pending_trigger(c);
-		} else {
-			/* Sometimes, however, we leave it elsewhere so it doesn't get
-			   immediately reused, and we spread the load a bit. */
-			D1(printk(KERN_DEBUG "...and adding to erasable_list\n"));
-			list_add_tail(&jeb->list, &c->erasable_list);
-		}
-	}
-}
-
-/*
- * return true if hamming distance between a and b is <= 1.
- *
- * [NOTE]
- *	assume that higher 3 bytes are zero
- */
-static inline int jffs2_hamming_distance(unsigned int a, unsigned int b)
-{
-#ifdef __ARM_ARCH_5TE__
-	unsigned int n;
-	a ^= b;
-	asm (
-		"clz	%0, %1\n"
-		: "=r" (n)
-		: "r" (a)
-	);
-	return (a << (n + 1)) == 0;
-#else
-	unsigned int n;
-	a ^= b;
-	for (n = 0; n < 8; n++)
-		if (! (a & ~(1 << n)))
-			return 1;
-	return 0;
-#endif
-}
-
-static inline void jffs2_correct_cleanmarker(unsigned char* oob, unsigned char* correct_data, int len)
-{
-	int i;
-	for (i = 0; i < len; i++)
-		if (jffs2_hamming_distance(oob[i], correct_data[i]))
-			oob[i] = correct_data[i];
-}
-
-/*
- * correct badblock marker value
- */
-static inline void jffs2_correct_badblock_val(unsigned char* oob)
-{
-#ifdef CONFIG_MTD_NAND_POST_BADBLOCK
-	if (jffs2_hamming_distance(oob[NAND_POSTBADBLOCK_POS], 0xff))
-		oob[NAND_POSTBADBLOCK_POS] = 0xff;
-#endif
-	if (jffs2_hamming_distance(oob[NAND_BADBLOCK_POS], 0xff))
-		oob[NAND_BADBLOCK_POS] = 0xff;
-}
-
-static inline void jffs2_correct_failedblock_val(unsigned char* oob)
-{
-	if (jffs2_hamming_distance(oob[FAILURECOUNTER_POS], 0xff))
-		oob[FAILURECOUNTER_POS] = 0xff;
-}
-
-/*
- * return true if it is badblock
- */
-static inline int jffs2_is_badblock(const unsigned char* oob)
-{
-#ifdef CONFIG_MTD_NAND_POST_BADBLOCK
-	return ! (oob[NAND_POSTBADBLOCK_POS] == 0xff &&
-		  oob[NAND_BADBLOCK_POS] == 0xff);
-#else
-	return oob[NAND_BADBLOCK_POS] != 0xff;
-#endif
-}
-
-static inline int jffs2_is_failedblock(const unsigned char* oob)
-{
-	return oob[FAILURECOUNTER_POS] != 0xff;
-}
-
-/* 
-*	Timed flushing of wbuf. If we have no consecutive write to wbuf, within	
-*	the specified time, we flush the contents with padding !
-*/
-void jffs2_wbuf_timeout (unsigned long data)
-{
-	struct jffs2_sb_info *c = (struct jffs2_sb_info *) data;
-	/* 
-	* Wake up the flush process, we need process context to have the right 
-	* to sleep on flash write
-	*/
-	D1(printk(KERN_DEBUG "jffs2_wbuf_timeout(): timer expired\n"));
-	schedule_task(&c->wbuf_task);
-}
-
-/*
-*	Process for timed wbuf flush
-*
-*	FIXME What happens, if we have a write failure there ????
-*/
-void jffs2_wbuf_process (void *data)
-{
-	struct jffs2_sb_info *c = (struct jffs2_sb_info *) data;	
-	
-	D1(printk(KERN_DEBUG "jffs2_wbuf_process() entered\n"));
-	
-	/* Check, if the timer is active again */
-	if (timer_pending (&c->wbuf_timer)) {
-		D1(printk (KERN_DEBUG "Nothing to do, timer is active again\n"));
-		return;
-	}
-
-	if (down_trylock(&c->alloc_sem)) {
-		/* If someone else has the alloc_sem, they're about to
-		   write anyway. So no need to waste space by
-		   padding */
-		D1(printk (KERN_DEBUG "jffs2_wbuf_process() alloc_sem already occupied\n"));
-		return;
-	}	
-
-	D1(printk (KERN_DEBUG "jffs2_wbuf_process() alloc_sem got\n"));
-
-	if (!c->nextblock) {
-		D1(printk(KERN_DEBUG "jffs2_wbuf_process(): nextblock NULL, nothing to do\n"));
-		if (c->wbuf_len) {
-			printk(KERN_WARNING "jffs2_wbuf_process(): c->wbuf_len is 0x%03x but nextblock is NULL!\n", c->wbuf_len);
-			up(&c->alloc_sem);
-			BUG();
-		}
-		return;
-	}
-	
-	
-	/* if !c->nextblock then the tail will have got flushed from
-	   jffs2_do_reserve_space() anyway. */
-	if(c->nextblock)
-		jffs2_flush_wbuf(c, 2); /* pad and adjust nextblock */
-
-	up(&c->alloc_sem);
-}
-
-
-/* Meaning of pad argument:
-   0: Do not pad. Probably pointless - we only ever use this when we can't pad anyway.
-   1: Pad, do not adjust nextblock free_size
-   2: Pad, adjust nextblock free_size
-*/
-int jffs2_flush_wbuf(struct jffs2_sb_info *c, int pad)
-{
-	int ret;
-	size_t retlen;
-	
-	if (!down_trylock(&c->alloc_sem)) {
-		up(&c->alloc_sem);
-		printk(KERN_CRIT "jffs2_flush_wbuf() called with alloc_sem not locked!\n");
-		BUG();
-	}
-
-	/* delete a eventually started timed wbuf flush */
-	del_timer_sync(&c->wbuf_timer);
-
-	if(!c->wbuf || !c->wbuf_len)
-		return 0;
-
-	/* claim remaining space on the page
-	   this happens, if we have a change to a new block,
-	   or if fsync forces us to flush the writebuffer.
-	   if we have a switch to next page, we will not have
-	   enough remaining space for this. 
-	*/
-	if (pad) {
-		c->wbuf_len = PAD(c->wbuf_len);
-		
-		if ( c->wbuf_len + sizeof(struct jffs2_unknown_node) < c->wbuf_pagesize) {
-			struct jffs2_unknown_node *padnode = (void *)(c->wbuf + c->wbuf_len);
-			padnode->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
-			padnode->nodetype = cpu_to_je16(JFFS2_NODETYPE_PADDING);
-			padnode->totlen = cpu_to_je32(c->wbuf_pagesize - c->wbuf_len);
-			padnode->hdr_crc = cpu_to_je32(crc32(0, padnode, sizeof(*padnode)-4));
-		}
-	}
-	/* else jffs2_flash_writev has actually filled in the rest of the
-	   buffer for us, and will deal with the node refs etc. later. */
-	
-	ret = c->mtd->write_ecc(c->mtd, c->wbuf_ofs, c->wbuf_pagesize, &retlen, c->wbuf, NULL, NAND_JFFS2_OOB);
-	
-	if (ret || retlen != c->wbuf_pagesize) {
-		if (ret)
-			printk(KERN_CRIT "jffs2_flush_wbuf(): Write failed with %d\n",ret);
-		else
-			printk(KERN_CRIT "jffs2_flush_wbuf(): Write was short %d instead of %d\n",retlen,c->wbuf_pagesize);
-			
-		ret = -EIO;		
-		/* CHECKME NAND 
-		   So that the caller knows what happened. If
-		   we were called from jffs2_flash_writev(), it'll
-		   know to return failure and _its_ caller will
-		   try again. writev gives back to jffs2_write_xxx 
-		   in write.c. There are the real fixme's
-		 */
-
-		/*  FIXME NAND
-		   If we were called from GC or fsync, there's no repair kit yet
-		*/
-		    
-		return ret; 
-	}
-
-	/* Adjusting free size of next block only, if it's called from fsync ! */
-	if (pad == 2) {
-		D1(printk(KERN_DEBUG "jffs2_flush_wbuf() adjusting free_size of c->nextblock\n"));
-		spin_lock_bh(&c->erase_completion_lock);
-		if (!c->nextblock)
-			BUG();
-		/* wbuf_pagesize - wbuf_len is the amount of space that's to be 
-		   padded. If there is less free space in the block than that,
-		   something screwed up */
-		if (c->nextblock->free_size < (c->wbuf_pagesize - c->wbuf_len)) {
-			printk(KERN_CRIT "jffs2_flush_wbuf(): Accounting error. wbuf at 0x%08x has 0x%03x bytes, 0x%03x left.\n",
-			       c->wbuf_ofs, c->wbuf_len, c->wbuf_pagesize-c->wbuf_len);
-			printk(KERN_CRIT "jffs2_flush_wbuf(): But free_size for block at 0x%08x is only 0x%08x\n",
-			       c->nextblock->offset, c->nextblock->free_size);
-			BUG();
-		}
-		c->nextblock->free_size -= (c->wbuf_pagesize - c->wbuf_len);
-		c->free_size -= (c->wbuf_pagesize - c->wbuf_len);
-		c->nextblock->wasted_size += (c->wbuf_pagesize - c->wbuf_len);
-		c->wasted_size += (c->wbuf_pagesize - c->wbuf_len);
-		spin_unlock_bh(&c->erase_completion_lock);
-	}
-
-	/* Stick any now-obsoleted blocks on the erase_pending_list */
-	spin_lock_bh(&c->erase_completion_lock);
-	jffs2_refile_wbuf_blocks(c);
-	spin_unlock_bh(&c->erase_completion_lock);
-
-	memset(c->wbuf,0xff,c->wbuf_pagesize);
-	/* adjust write buffer offset, else we get a non contigous write bug */
-	c->wbuf_ofs+= c->wbuf_pagesize;
-	c->wbuf_len = 0;
-	return 0;
-}
-
-#define PAGE_DIV(x) ( (x) & (~(c->wbuf_pagesize - 1)) )
-#define PAGE_MOD(x) ( (x) & (c->wbuf_pagesize - 1) )
-int jffs2_flash_writev(struct jffs2_sb_info *c, const struct iovec *invecs, unsigned long count, loff_t to, size_t *retlen)
-{
-	struct iovec outvecs[3];
-	uint32_t totlen = 0;
-	uint32_t split_ofs = 0;
-	uint32_t old_totlen;
-	int ret, splitvec = -1;
-	int invec, outvec;
-	size_t wbuf_retlen;
-	unsigned char *wbuf_ptr;
-	size_t donelen = 0;
-	uint32_t outvec_to = to;
-
-	/* If not NAND flash, don't bother */
-	if (!c->wbuf)
-		return jffs2_flash_direct_writev(c, invecs, count, to, retlen);
-	
-	/* If wbuf_ofs is not initialized, set it to target adress */
-	if (c->wbuf_ofs == 0xFFFFFFFF) {
-		c->wbuf_ofs = PAGE_DIV(to);
-		c->wbuf_len = PAGE_MOD(to);			
-		memset(c->wbuf,0xff,c->wbuf_pagesize);
-	}
-
-	/* Sanity checks on target address. 
-	   It's permitted to write at PAD(c->wbuf_len+c->wbuf_ofs), 
-	   and it's permitted to write at the beginning of a new 
-	   erase block. Anything else, and you die.
-	   New block starts at xxx000c (0-b = block header)
-	*/
-	if ( (to & ~(c->sector_size-1)) != (c->wbuf_ofs & ~(c->sector_size-1)) ) {
-		/* It's a write to a new block */
-		if (c->wbuf_len) {
-			D1(printk(KERN_DEBUG "jffs2_flash_writev() to 0x%lx causes flush of wbuf at 0x%08x\n", (unsigned long)to, c->wbuf_ofs));
-			ret = jffs2_flush_wbuf(c, 1);
-			if (ret) {
-				/* the underlying layer has to check wbuf_len to do the cleanup */
-				D1(printk(KERN_WARNING "jffs2_flush_wbuf() called from jffs2_flash_writev() failed %d\n", ret));
-				*retlen = 0;
-				return ret;
-			}
-		}
-		/* set pointer to new block */
-		c->wbuf_ofs = PAGE_DIV(to);
-		c->wbuf_len = PAGE_MOD(to);			
-	} 
-
-	if (to != PAD(c->wbuf_ofs + c->wbuf_len)) {
-		/* We're not writing immediately after the writebuffer. Bad. */
-		printk(KERN_CRIT "jffs2_flash_writev(): Non-contiguous write to %08lx\n", (unsigned long)to);
-		if (c->wbuf_len)
-			printk(KERN_CRIT "wbuf was previously %08x-%08x\n",
-					  c->wbuf_ofs, c->wbuf_ofs+c->wbuf_len);
-		BUG();
-	}
-
-	/* Note outvecs[3] above. We know count is never greater than 2 */
-	if (count > 2) {
-		printk(KERN_CRIT "jffs2_flash_writev(): count is %ld\n", count);
-		BUG();
-	}
-
-	invec = 0;
-	outvec = 0;
-
-
-	/* Fill writebuffer first, if already in use */	
-	if (c->wbuf_len) {
-		uint32_t invec_ofs = 0;
-
-		/* adjust alignment offset */ 
-		if (c->wbuf_len != PAGE_MOD(to)) {
-			c->wbuf_len = PAGE_MOD(to);
-			/* take care of alignment to next page */
-			if (!c->wbuf_len)
-				c->wbuf_len = c->wbuf_pagesize;
-		}
-		
-		while(c->wbuf_len < c->wbuf_pagesize) {
-			uint32_t thislen;
-			
-			if (invec == count)
-				goto alldone;
-
-			thislen = c->wbuf_pagesize - c->wbuf_len;
-
-			if (thislen >= invecs[invec].iov_len)
-				thislen = invecs[invec].iov_len;
-	
-			invec_ofs = thislen;
-
-			memcpy(c->wbuf + c->wbuf_len, invecs[invec].iov_base, thislen);
-			c->wbuf_len += thislen;
-			donelen += thislen;
-			/* Get next invec, if actual did not fill the buffer */
-			if (c->wbuf_len < c->wbuf_pagesize) 
-				invec++;
-		}			
-		
-		/* write buffer is full, flush buffer */
-		ret = jffs2_flush_wbuf(c, 0);
-		if (ret) {
-			/* the underlying layer has to check wbuf_len to do the cleanup */
-			D1(printk(KERN_WARNING "jffs2_flush_wbuf() called from jffs2_flash_writev() failed %d\n", ret));
-			*retlen = 0;
-			return ret;
-		}
-		outvec_to += donelen;
-		c->wbuf_ofs = outvec_to;
-		
-		/* All invecs done ? */
-		if (invec == count)
-			goto alldone;
-
-		/* Set up the first outvec, containing the remainder of the
-		   invec we partially used */
-		if (invecs[invec].iov_len > invec_ofs) {
-			outvecs[0].iov_base = invecs[invec].iov_base+invec_ofs;
-			totlen = outvecs[0].iov_len = invecs[invec].iov_len-invec_ofs;
-			if (totlen > c->wbuf_pagesize) {
-				splitvec = outvec;
-				split_ofs = outvecs[0].iov_len - PAGE_MOD(totlen);
-			}
-			outvec++;
-		}
-		invec++;
-	}
-
-	/* OK, now we've flushed the wbuf and the start of the bits
-	   we have been asked to write, now to write the rest.... */
-
-	/* totlen holds the amount of data still to be written */
-	old_totlen = totlen;
-	for ( ; invec < count; invec++,outvec++ ) {
-		outvecs[outvec].iov_base = invecs[invec].iov_base;
-		totlen += outvecs[outvec].iov_len = invecs[invec].iov_len;
-		if (PAGE_DIV(totlen) != PAGE_DIV(old_totlen)) {
-			splitvec = outvec;
-			split_ofs = outvecs[outvec].iov_len - PAGE_MOD(totlen);
-			old_totlen = totlen;
-		}
-	}
-
-	/* Now the outvecs array holds all the remaining data to write */
-	/* Up to splitvec,split_ofs is to be written immediately. The rest
-	   goes into the (now-empty) wbuf */
-
-	if (splitvec != -1) {
-		uint32_t remainder;
-		int ret;
-
-		remainder = outvecs[splitvec].iov_len - split_ofs;
-		outvecs[splitvec].iov_len = split_ofs;
-
-		/* We did cross a page boundary, so we write some now */
-		ret = c->mtd->writev_ecc(c->mtd, outvecs, splitvec+1, outvec_to, &wbuf_retlen, NULL, NAND_JFFS2_OOB); 
-		if (ret < 0 || wbuf_retlen != PAGE_DIV(totlen)) {
-			/* At this point we have no problem,
-			   c->wbuf is empty. 
-			*/
-			*retlen = donelen;
-			return ret;
-		}
-		
-		donelen += wbuf_retlen;
-		c->wbuf_ofs = PAGE_DIV(outvec_to) + PAGE_DIV(totlen);
-
-		if (remainder) {
-			outvecs[splitvec].iov_base += split_ofs;
-			outvecs[splitvec].iov_len = remainder;
-		} else {
-			splitvec++;
-		}
-
-	} else {
-		splitvec = 0;
-	}
-
-	/* Now splitvec points to the start of the bits we have to copy
-	   into the wbuf */
-	wbuf_ptr = c->wbuf;
-
-	for ( ; splitvec < outvec; splitvec++) {
-		/* Don't copy the wbuf into itself */
-		if (outvecs[splitvec].iov_base == c->wbuf)
-			continue;
-		memcpy(wbuf_ptr, outvecs[splitvec].iov_base, outvecs[splitvec].iov_len);
-		wbuf_ptr += outvecs[splitvec].iov_len;
-		donelen += outvecs[splitvec].iov_len;
-	}
-	c->wbuf_len = wbuf_ptr - c->wbuf;
-
-alldone:	
-	*retlen = donelen;
-	/* Setup timed wbuf flush, if buffer len != 0 */
-	if (c->wbuf_len) {
-		D1(printk (KERN_DEBUG "jffs2_flash_writev: mod wbuf_timer\n"));	
-		mod_timer(&c->wbuf_timer, jiffies + WBUF_FLUSH_TIMEOUT);
-	}
-	return 0;
-}
-
-/*
-	This is the entry for NOR-Flash. We use it also for NAND to flush wbuf
-*/
-int jffs2_flash_write(struct jffs2_sb_info *c, loff_t ofs, size_t len, size_t *retlen, const u_char *buf)
-{
-	return c->mtd->write(c->mtd, ofs, len, retlen, buf);
-}
-
-/*
-	Handle readback from writebuffer and ECC failure return
-*/
-int jffs2_flash_read(struct jffs2_sb_info *c, loff_t ofs, size_t len, size_t *retlen, u_char *buf)
-{
-	loff_t	orbf = 0, owbf = 0, lwbf = 0;
-	int	ret;
-
-	/* Read flash */
-	if (!jffs2_can_mark_obsolete(c)) {
-		ret = c->mtd->read_ecc(c->mtd, ofs, len, retlen, buf, NULL, NAND_JFFS2_OOB);
-
-		if ( (ret == -EIO) && (*retlen == len) ) {
-			printk(KERN_WARNING "mtd->read(0x%x bytes from 0x%llx) returned ECC error\n", len, ofs);
-			/* 
-			 * We have the raw data without ECC correction in the buffer, maybe 
-			 * we are lucky and all data or parts are correct. We check the node.
-			 * If data are corrupted node check will sort it out.
-			 * We keep this block, it will fail on write or erase and the we
-			 * mark it bad. Or should we do that now? But we should give him a chance.
-			 * Maybe we had a system crash or power loss before the ecc write or  
-			 * a erase was completed.
-			 * So we return success. :)
-			 */
-		 	ret = 0;
-		 }	
-	} else
-		return c->mtd->read(c->mtd, ofs, len, retlen, buf);
-
-	/* if no writebuffer available or write buffer empty, return */
-	if (!c->wbuf_pagesize || !c->wbuf_len)
-		return ret;
-
-	/* if we read in a different block, return */
-	if ( (ofs & ~(c->sector_size-1)) != (c->wbuf_ofs & ~(c->sector_size-1)) )
-		return ret;
-
-	if (ofs >= c->wbuf_ofs) {
-		owbf = (ofs - c->wbuf_ofs);	/* offset in write buffer */
-		if (owbf > c->wbuf_len)		/* is read beyond write buffer ? */
-			return ret;
-		lwbf = c->wbuf_len - owbf;	/* number of bytes to copy */
-		if (lwbf > len)	
-			lwbf = len;
-	} else {	
-		orbf = (c->wbuf_ofs - ofs);	/* offset in read buffer */
-		if (orbf > len)			/* is write beyond write buffer ? */
-			return ret;
-		lwbf = len - orbf; 		/* number of bytes to copy */
-		if (lwbf > c->wbuf_len)	
-			lwbf = c->wbuf_len;
-	}	
-	if (lwbf > 0)
-		memcpy(buf+orbf,c->wbuf+owbf,lwbf);
-
-	return ret;
-}
-
-/*
- *	Check, if the out of band area is empty
- */
-int jffs2_check_oob_empty( struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, int mode)
-{
-	unsigned char *buf;
-	int 	ret = 0;
-	int	i,len;
-	size_t  retlen;
-	int	fsdata_pos,oob_size;
-
-	oob_size = c->mtd->oobsize;
-
-	switch(c->mtd->ecctype) {
-	case MTD_ECC_SW:		
-		fsdata_pos = (c->wbuf_pagesize == 256) ? NAND_JFFS2_OOB8_FSDAPOS : NAND_JFFS2_OOB16_FSDAPOS;
-		break;
-	default:
-		D1(printk(KERN_WARNING "jffs2_write_oob_empty(): Invalid ECC type\n"));
-		return -EINVAL;
-	}	
-
-	/* allocate a buffer for all oob data in this sector */
-	len = 4 * oob_size;
-	buf = kmalloc(len, GFP_KERNEL);
-	if (!buf) {
-		printk(KERN_NOTICE "jffs2_check_oob_empty(): allocation of temporary data buffer for oob check failed\n");
-		return -ENOMEM;
-	}
-	/* 
-	 * if mode = 0, we scan for a total empty oob area, else we have
-	 * to take care of the cleanmarker in the first page of the block
-	*/
-	ret = jffs2_flash_read_oob(c, jeb->offset, len , &retlen, buf);
-	if (ret) {
-		D1(printk(KERN_WARNING "jffs2_check_oob_empty(): Read OOB failed %d for block at %08x\n", ret, jeb->offset));
-		goto out;
-	}
-	
-	if (retlen < len) {
-		D1(printk(KERN_WARNING "jffs2_check_oob_empty(): Read OOB return short read "
-			  "(%d bytes not %d) for block at %08x\n", retlen, len, jeb->offset));
-		ret = -EIO;
-		goto out;
-	}
-	
-	/* Special check for first two pages */
-	jffs2_correct_badblock_val(buf);
-	if (jffs2_is_badblock(buf)) {
-		D1(printk(KERN_WARNING "jffs2_check_oob_empty(): Bad block at %08x\n",jeb->offset));
-		/* Return 2 for bad and 3 for failed block 
-		   bad goes to list_bad and failed to list_erase */
-		ret = 2;
-		goto out;
-	}
-	for(i = 0; i < fsdata_pos ; i++) {
-		if (! jffs2_hamming_distance(buf[i], 0xff)) {
-			ret = 1;
-			goto out;
-		}
-	}
-
-	jffs2_correct_failedblock_val(&buf[oob_size]);
-	if (jffs2_is_failedblock(&buf[oob_size])) {
-		D1(printk(KERN_WARNING "jffs2_check_oob_empty(): Failed block at %08x\n",jeb->offset));
-		/* Return 2 for bad and 3 for failed block 
-		   bad goes to list_bad and failed to list_erase */
-		ret = 3;
-		goto out;
-	}
-	for(i = oob_size; i < len; i++) {
-		if (! jffs2_hamming_distance(buf[i], 0xff)) {
-			ret = 1; 
-			goto out;
-		}
-	}
-
-out:
-	kfree(buf);	
-	
-	return ret;
-}
-
-int jffs2_check_nand_cleanmarker(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)
-{
-	struct jffs2_unknown_node n;
-	unsigned char buf[32];
-	unsigned char *p;
-	int ret,i;
-	size_t retlen;
-	int	fsdata_pos,fsdata_len, oob_size;
-
-	oob_size = c->mtd->oobsize;
-
-	switch(c->mtd->ecctype) {
-	case MTD_ECC_SW:	
-		fsdata_pos = (c->wbuf_pagesize == 256) ? NAND_JFFS2_OOB8_FSDAPOS : NAND_JFFS2_OOB16_FSDAPOS;
-		fsdata_len = (c->wbuf_pagesize == 256) ? NAND_JFFS2_OOB8_FSDALEN : NAND_JFFS2_OOB16_FSDALEN;
-		break;
-	default:
-		D1(printk(KERN_WARNING "jffs2_write_nand_cleanmarker(): Invalid ECC type\n"));
-		return -EINVAL;
-	}	
-
-	/*
-	*	We read oob data from page 0 and 1 of the block.
-	*	page 0 contains cleanmarker and badblock info
-	*	page 2 contains failure count of this block
-	*/
-	ret = c->mtd->read_oob(c->mtd, jeb->offset, oob_size << 1 , &retlen, buf);
-	
-	if (ret) {
-		D1(printk(KERN_WARNING "jffs2_check_nand_cleanmarker(): Read OOB failed %d for block at %08x\n", ret, jeb->offset));
-		return ret;
-	}
-	if (retlen < (oob_size << 1) ) {
-		D1(printk(KERN_WARNING "jffs2_check_nand_cleanmarker(): Read OOB return short read (%d bytes not %d) for block at %08x\n", retlen, oob_size << 1 , jeb->offset));
-		return -EIO;
-	}
-
-	/* Check for bad block marker */
-	jffs2_correct_badblock_val(buf);
-	if (jffs2_is_badblock(buf)) {
-		D1(printk(KERN_WARNING "jffs2_check_nand_cleanmarker(): Bad block at %08x\n",jeb->offset));
-		return 2;
-	}
-
-	/* Check for failure counter in the second page */
-	jffs2_correct_failedblock_val(&buf[oob_size]);
-	if (jffs2_is_failedblock(&buf[oob_size])) {
-		D1(printk(KERN_WARNING "jffs2_check_nand_cleanmarker(): Block marked as failed at %08x, fail count:%d\n",jeb->offset,buf[FAILURECOUNTER_POS+oob_size]));
-		return 3;
-	}
-
-	n.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
-	n.nodetype = cpu_to_je16(JFFS2_NODETYPE_CLEANMARKER);
-	n.totlen = cpu_to_je32(8);
-	p = (unsigned char *) &n;
-
-	jffs2_correct_cleanmarker(&buf[fsdata_pos], p, fsdata_len);
-	for (i = 0; i < fsdata_len; i++) {
-		if (buf[fsdata_pos+i] != p[i]) {
-			D2(printk(KERN_WARNING "jffs2_check_nand_cleanmarker(): Cleanmarker node not detected in block at %08x\n", jeb->offset));
-			return 1;
-		}
-	}
-	
-	return 0;
-}
-
-int jffs2_write_nand_cleanmarker(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)
-{
-	struct 	jffs2_unknown_node n;
-	int 	ret;
-	int	fsdata_pos,fsdata_len;
-	size_t 	retlen;
-
-	switch(c->mtd->ecctype) {
-	case MTD_ECC_SW:	
-		fsdata_pos = (c->wbuf_pagesize == 256) ? NAND_JFFS2_OOB8_FSDAPOS : NAND_JFFS2_OOB16_FSDAPOS;
-		fsdata_len = (c->wbuf_pagesize == 256) ? NAND_JFFS2_OOB8_FSDALEN : NAND_JFFS2_OOB16_FSDALEN;
-		break;
-	default:
-		D1(printk(KERN_WARNING "jffs2_write_nand_cleanmarker(): Invalid ECC type\n"));
-		return -EINVAL;
-	}	
-	
-	n.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
-	n.nodetype = cpu_to_je16(JFFS2_NODETYPE_CLEANMARKER);
-	n.totlen = cpu_to_je32(8);
-
-	ret = jffs2_flash_write_oob(c, jeb->offset + fsdata_pos, fsdata_len, &retlen, (unsigned char *)&n);
-	
-	if (ret) {
-		D1(printk(KERN_WARNING "jffs2_write_nand_cleanmarker(): Write failed for block at %08x: error %d\n", jeb->offset, ret));
-		return ret;
-	}
-	if (retlen != fsdata_len) {
-		D1(printk(KERN_WARNING "jffs2_write_nand_cleanmarker(): Short write for block at %08x: %d not %d\n", jeb->offset, retlen, fsdata_len));
-		return ret;
-	}
-	return 0;
-}
-
-/* 
- * We try to get the failure count of this block.
- */
-int jffs2_nand_read_failcnt(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)
-{
-
-	signed char buf[16];
-	int	ret;
-	size_t 	retlen;
-	int	oob_size, badblock_pos;
-
-	oob_size = c->mtd->oobsize;
-
-	switch(c->mtd->ecctype) {
-	case MTD_ECC_SW:	
-		badblock_pos = FAILURECOUNTER_POS;
-		break;
-	default:
-		D1(printk(KERN_WARNING "jffs2_nand_read_failcnt(): Invalid ECC type\n"));
-		return -EINVAL;
-	}	
-	
-	ret = c->mtd->read_oob(c->mtd, jeb->offset + c->mtd->oobblock, oob_size , &retlen, buf);
-	
-	if (ret) {
-		D1(printk(KERN_WARNING "jffs2_nand_read_failcnt(): Read OOB failed %d for block at %08x\n", ret, jeb->offset));
-		return ret;
-	}
-
-	if (retlen < oob_size) {
-		D1(printk(KERN_WARNING "jffs2_nand_read_failcnt(): Read OOB return short read (%d bytes not %d) for block at %08x\n", retlen, oob_size, jeb->offset));
-		return -EIO;
-	}
-
-	jeb->bad_count =
-		(buf[badblock_pos] >= -1 && buf[badblock_pos] < MAX_ERASE_FAILURES) ?
-		buf[badblock_pos] :
-		MAX_ERASE_FAILURES - 1;
-	return 0;
-}
-
-/* 
- * On NAND we try to mark this block bad. We try to write how often
- * the block was erased and mark it finaly bad, if the count
- * is > MAX_ERASE_FAILURES. We read this information on mount !
- * jeb->bad_count contains the count before this erase.
- * Don't care about failures. This block remains on the erase-pending
- * or badblock list as long as nobody manipulates the flash with
- * a bootloader or something like that.
- */
-
-int jffs2_write_nand_badblock(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)
-{
-	unsigned char buf = 0x0;
-	int 	ret,pos;
-	size_t 	retlen;
-
-	switch(c->mtd->ecctype) {
-	case MTD_ECC_SW:	
-		break;
-	default:
-		D1(printk(KERN_WARNING "jffs2_write_nand_badblock(): Invalid ECC type\n"));
-		return -EINVAL;
-	}	
-
-	/* if the count is < max, we try to write the counter to the 2nd page oob area */
-	if( ++jeb->bad_count < MAX_ERASE_FAILURES) {
-		buf = (unsigned char)jeb->bad_count;
-		pos = c->mtd->oobblock + FAILURECOUNTER_POS;
-	}
-	else {
-#ifdef CONFIG_MTD_NAND_POST_BADBLOCK
-		pos = NAND_POSTBADBLOCK_POS;
-#else
-		pos = NAND_BADBLOCK_POS;
-#endif
-	}
-	
-	ret = jffs2_flash_write_oob(c, jeb->offset + pos, 1, &retlen, &buf);
-	
-	if (ret) {
-		D1(printk(KERN_WARNING "jffs2_write_nand_badblock(): Write failed for block at %08x: error %d\n", jeb->offset, ret));
-		return ret;
-	}
-	if (retlen != 1) {
-		D1(printk(KERN_WARNING "jffs2_write_nand_badblock(): Short write for block at %08x: %d not 1\n", jeb->offset, retlen));
-		return ret;
-	}
-	return 0;
-}
-
-/*
- * Local variables:
- *   c-basic-offset: 8
- * End:
- */
diff -Nur linux/fs/jffs2/write.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/write.c
--- linux/fs/jffs2/write.c	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/write.c	2003-06-23 01:47:04.000000000 +0700
@@ -1,66 +1,152 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
+ * Copyright (C) 2001 Red Hat, Inc.
  *
  * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in this directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: write.c,v 1.59 2002/09/06 16:46:30 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: write.c,v 1.30 2001/12/30 16:01:11 dwmw2 Exp $
  *
  */
 
 #include <linux/kernel.h>
 #include <linux/fs.h>
-#include "crc32.h"
-#include <linux/slab.h>
-#include <linux/pagemap.h>
+#include <linux/jffs2.h>
 #include <linux/mtd/mtd.h>
 #include "nodelist.h"
+#include "crc32.h"
 
-
-int jffs2_do_new_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, uint32_t mode, struct jffs2_raw_inode *ri)
+/* jffs2_new_inode: allocate a new inode and inocache, add it to the hash,
+   fill in the raw_inode while you're at it. */
+struct inode *jffs2_new_inode (struct inode *dir_i, int mode, struct jffs2_raw_inode *ri)
 {
+	struct inode *inode;
+	struct super_block *sb = dir_i->i_sb;
 	struct jffs2_inode_cache *ic;
+	struct jffs2_sb_info *c;
+	struct jffs2_inode_info *f;
+
+	D1(printk(KERN_DEBUG "jffs2_new_inode(): dir_i %ld, mode 0x%x\n", dir_i->i_ino, mode));
+
+	c = JFFS2_SB_INFO(sb);
+	memset(ri, 0, sizeof(*ri));
 
 	ic = jffs2_alloc_inode_cache();
 	if (!ic) {
-		return -ENOMEM;
+		return ERR_PTR(-ENOMEM);
 	}
-
 	memset(ic, 0, sizeof(*ic));
+	
+	inode = new_inode(sb);
+	
+	if (!inode) {
+		jffs2_free_inode_cache(ic);
+		return ERR_PTR(-ENOMEM);
+	}
 
+	/* Alloc jffs2_inode_info when that's split in 2.5 */
+
+	f = JFFS2_INODE_INFO(inode);
+	memset(f, 0, sizeof(*f));
 	init_MUTEX_LOCKED(&f->sem);
 	f->inocache = ic;
-	f->inocache->nlink = 1;
+	inode->i_nlink = f->inocache->nlink = 1;
 	f->inocache->nodes = (struct jffs2_raw_node_ref *)f->inocache;
-	f->inocache->ino = ++c->highest_ino;
-	ri->ino = cpu_to_je32(f->inocache->ino);
-
-	D1(printk(KERN_DEBUG "jffs2_do_new_inode(): Assigned ino# %d\n", f->inocache->ino));
+	f->inocache->ino = ri->ino = inode->i_ino = ++c->highest_ino;
+	D1(printk(KERN_DEBUG "jffs2_new_inode(): Assigned ino# %d\n", ri->ino));
 	jffs2_add_ino_cache(c, f->inocache);
 
-	ri->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
-	ri->nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);
-	ri->totlen = cpu_to_je32(PAD(sizeof(*ri)));
-	ri->hdr_crc = cpu_to_je32(crc32(0, ri, sizeof(struct jffs2_unknown_node)-4));
-	ri->mode = cpu_to_je32(mode);
+	ri->magic = JFFS2_MAGIC_BITMASK;
+	ri->nodetype = JFFS2_NODETYPE_INODE;
+	ri->totlen = PAD(sizeof(*ri));
+	ri->hdr_crc = crc32(0, ri, sizeof(struct jffs2_unknown_node)-4);
+	ri->mode = mode;
+	f->highest_version = ri->version = 1;
+	ri->uid = current->fsuid;
+	if (dir_i->i_mode & S_ISGID) {
+		ri->gid = dir_i->i_gid;
+		if (S_ISDIR(mode))
+			ri->mode |= S_ISGID;
+	} else {
+		ri->gid = current->fsgid;
+	}
+	inode->i_mode = ri->mode;
+	inode->i_gid = ri->gid;
+	inode->i_uid = ri->uid;
+	inode->i_atime = inode->i_ctime = inode->i_mtime = 
+		ri->atime = ri->mtime = ri->ctime = CURRENT_TIME;
+	inode->i_blksize = PAGE_SIZE;
+	inode->i_blocks = 0;
+	inode->i_size = 0;
 
-	f->highest_version = 1;
-	ri->version = cpu_to_je32(f->highest_version);
+	insert_inode_hash(inode);
 
-	return 0;
+	return inode;
 }
 
-static void writecheck(struct jffs2_sb_info *c, uint32_t ofs)
+/* This ought to be in core MTD code. All registered MTD devices without writev should have
+   this put in place. Bug the MTD maintainer */
+static int mtd_fake_writev(struct mtd_info *mtd, const struct iovec *vecs, unsigned long count, loff_t to, size_t *retlen)
+{
+	unsigned long i;
+	size_t totlen = 0, thislen;
+	int ret = 0;
+
+	for (i=0; i<count; i++) {
+		mtd->write(mtd, to, vecs[i].iov_len, &thislen, vecs[i].iov_base);
+		totlen += thislen;
+		if (ret || thislen != vecs[i].iov_len)
+			break;
+		to += vecs[i].iov_len;
+	}
+	if (retlen)
+		*retlen = totlen;
+	return ret;
+}
+
+
+static inline int mtd_writev(struct mtd_info *mtd, const struct iovec *vecs, unsigned long count, loff_t to, size_t *retlen)
+{
+	if (mtd->writev)
+		return mtd->writev(mtd,vecs,count,to,retlen);
+	else
+		return mtd_fake_writev(mtd, vecs, count, to, retlen);
+}
+
+static void writecheck(struct mtd_info *mtd, __u32 ofs)
 {
 	unsigned char buf[16];
-	size_t retlen;
+	ssize_t retlen;
 	int ret, i;
 
-	ret = jffs2_flash_read(c, ofs, 16, &retlen, buf);
-	if (ret || (retlen != 16)) {
+	ret = mtd->read(mtd, ofs, 16, &retlen, buf);
+	if (ret && retlen != 16) {
 		D1(printk(KERN_DEBUG "read failed or short in writecheck(). ret %d, retlen %d\n", ret, retlen));
 		return;
 	}
@@ -70,7 +156,7 @@
 			ret = 1;
 	}
 	if (ret) {
-		printk(KERN_WARNING "ARGH. About to write node to 0x%08x on flash, but there are data already there:\n", ofs);
+		printk(KERN_WARNING "ARGH. About to write node to 0x%08x on flash, but there's data already there:\n", ofs);
 		printk(KERN_WARNING "0x%08x: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n", 
 		       ofs,
 		       buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7],
@@ -78,22 +164,24 @@
 	}
 }
 
-
+	
+	
 
 /* jffs2_write_dnode - given a raw_inode, allocate a full_dnode for it, 
    write it to the flash, link it into the existing inode/fragment list */
 
-struct jffs2_full_dnode *jffs2_write_dnode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_raw_inode *ri, const unsigned char *data, uint32_t datalen, uint32_t flash_ofs,  uint32_t *writelen)
+struct jffs2_full_dnode *jffs2_write_dnode(struct inode *inode, struct jffs2_raw_inode *ri, const unsigned char *data, __u32 datalen, __u32 flash_ofs,  __u32 *writelen)
 
 {
+	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
 	struct jffs2_raw_node_ref *raw;
 	struct jffs2_full_dnode *fn;
-	size_t retlen;
+	ssize_t retlen;
 	struct iovec vecs[2];
 	int ret;
-	unsigned long cnt = 2;
 
-	D1(if(je32_to_cpu(ri->hdr_crc) != crc32(0, ri, sizeof(struct jffs2_unknown_node)-4)) {
+	D1(if(ri->hdr_crc != crc32(0, ri, sizeof(struct jffs2_unknown_node)-4)) {
 		printk(KERN_CRIT "Eep. CRC not correct in jffs2_write_dnode()\n");
 		BUG();
 	}
@@ -103,10 +191,10 @@
 	vecs[1].iov_base = (unsigned char *)data;
 	vecs[1].iov_len = datalen;
 
-	writecheck(c, flash_ofs);
+	writecheck(c->mtd, flash_ofs);
 
-	if (je32_to_cpu(ri->totlen) != sizeof(*ri) + datalen) {
-		printk(KERN_WARNING "jffs2_write_dnode: ri->totlen (0x%08x) != sizeof(*ri) (0x%08x) + datalen (0x%08x)\n", je32_to_cpu(ri->totlen), sizeof(*ri), datalen);
+	if (ri->totlen != sizeof(*ri) + datalen) {
+		printk(KERN_WARNING "jffs2_write_dnode: ri->totlen (0x%08x) != sizeof(*ri) (0x%08x) + datalen (0x%08x)\n", ri->totlen, sizeof(*ri), datalen);
 	}
 	raw = jffs2_alloc_raw_node_ref();
 	if (!raw)
@@ -118,20 +206,15 @@
 		return ERR_PTR(-ENOMEM);
 	}
 	raw->flash_offset = flash_ofs;
-	raw->totlen = PAD(sizeof(*ri)+datalen);
+	raw->totlen = PAD(ri->totlen);
 	raw->next_phys = NULL;
 
-	fn->ofs = je32_to_cpu(ri->offset);
-	fn->size = je32_to_cpu(ri->dsize);
+	fn->ofs = ri->offset;
+	fn->size = ri->dsize;
 	fn->frags = 0;
 	fn->raw = raw;
 
-	/* check number of valid vecs */
-	if (!datalen || !data)
-		cnt = 1;
-
-	ret = jffs2_flash_writev(c, vecs, cnt, flash_ofs, &retlen);
-		
+	ret = mtd_writev(c->mtd, vecs, 2, flash_ofs, &retlen);
 	if (ret || (retlen != sizeof(*ri) + datalen)) {
 		printk(KERN_NOTICE "Write of %d bytes at 0x%08x failed. returned %d, retlen %d\n", 
 		       sizeof(*ri)+datalen, flash_ofs, ret, retlen);
@@ -145,8 +228,7 @@
 			   seem corrupted, in which case the scan would skip over
 			   any node we write before the original intended end of 
 			   this node */
-			raw->flash_offset |= REF_OBSOLETE;
-			jffs2_add_physical_node_ref(c, raw);
+			jffs2_add_physical_node_ref(c, raw, sizeof(*ri)+datalen, 1);
 			jffs2_mark_node_obsolete(c, raw);
 		} else {
 			printk(KERN_NOTICE "Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\n", raw->flash_offset);
@@ -160,20 +242,13 @@
 		return ERR_PTR(ret?ret:-EIO);
 	}
 	/* Mark the space used */
-	if (datalen == PAGE_CACHE_SIZE)
-		raw->flash_offset |= REF_PRISTINE;
-	else
-		raw->flash_offset |= REF_NORMAL;
-	jffs2_add_physical_node_ref(c, raw);
+	jffs2_add_physical_node_ref(c, raw, retlen, 0);
 
 	/* Link into per-inode list */
 	raw->next_in_ino = f->inocache->nodes;
 	f->inocache->nodes = raw;
 
-	D1(printk(KERN_DEBUG "jffs2_write_dnode wrote node at 0x%08x with dsize 0x%x, csize 0x%x, node_crc 0x%08x, data_crc 0x%08x, totlen 0x%08x\n",
-		  flash_ofs, je32_to_cpu(ri->dsize), je32_to_cpu(ri->csize),
-		  je32_to_cpu(ri->node_crc), je32_to_cpu(ri->data_crc), 
-		  je32_to_cpu(ri->totlen)));
+	D1(printk(KERN_DEBUG "jffs2_write_dnode wrote node at 0x%08x with dsize 0x%x, csize 0x%x, node_crc 0x%08x, data_crc 0x%08x, totlen 0x%08x\n", flash_ofs, ri->dsize, ri->csize, ri->node_crc, ri->data_crc, ri->totlen));
 	if (writelen)
 		*writelen = retlen;
 
@@ -181,20 +256,20 @@
 	return fn;
 }
 
-struct jffs2_full_dirent *jffs2_write_dirent(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_raw_dirent *rd, const unsigned char *name, uint32_t namelen, uint32_t flash_ofs,  uint32_t *writelen)
+struct jffs2_full_dirent *jffs2_write_dirent(struct inode *inode, struct jffs2_raw_dirent *rd, const unsigned char *name, __u32 namelen, __u32 flash_ofs,  __u32 *writelen)
 {
+	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
 	struct jffs2_raw_node_ref *raw;
 	struct jffs2_full_dirent *fd;
-	size_t retlen;
+	ssize_t retlen;
 	struct iovec vecs[2];
 	int ret;
 
-	D1(printk(KERN_DEBUG "jffs2_write_dirent(ino #%u, name at *0x%p \"%s\"->ino #%u, name_crc 0x%08x)\n", 
-		  je32_to_cpu(rd->pino), name, name, je32_to_cpu(rd->ino),
-		  je32_to_cpu(rd->name_crc)));
-	writecheck(c, flash_ofs);
+	D1(printk(KERN_DEBUG "jffs2_write_dirent(ino #%u, name at *0x%p \"%s\"->ino #%u, name_crc 0x%08x)\n", rd->pino, name, name, rd->ino, rd->name_crc));
+	writecheck(c->mtd, flash_ofs);
 
-	D1(if(je32_to_cpu(rd->hdr_crc) != crc32(0, rd, sizeof(struct jffs2_unknown_node)-4)) {
+	D1(if(rd->hdr_crc != crc32(0, rd, sizeof(struct jffs2_unknown_node)-4)) {
 		printk(KERN_CRIT "Eep. CRC not correct in jffs2_write_dirent()\n");
 		BUG();
 	}
@@ -216,32 +291,31 @@
 		return ERR_PTR(-ENOMEM);
 	}
 	raw->flash_offset = flash_ofs;
-	raw->totlen = PAD(sizeof(*rd)+namelen);
+	raw->totlen = PAD(rd->totlen);
 	raw->next_in_ino = f->inocache->nodes;
 	f->inocache->nodes = raw;
 	raw->next_phys = NULL;
 
-	fd->version = je32_to_cpu(rd->version);
-	fd->ino = je32_to_cpu(rd->ino);
+	fd->version = rd->version;
+	fd->ino = rd->ino;
 	fd->nhash = full_name_hash(name, strlen(name));
 	fd->type = rd->type;
 	memcpy(fd->name, name, namelen);
 	fd->name[namelen]=0;
 	fd->raw = raw;
 
-	ret = jffs2_flash_writev(c, vecs, 2, flash_ofs, &retlen);
-	if (ret || (retlen != sizeof(*rd) + namelen)) {
-		printk(KERN_NOTICE "Write of %d bytes at 0x%08x failed. returned %d, retlen %d\n", 
+	ret = mtd_writev(c->mtd, vecs, 2, flash_ofs, &retlen);
+		if (ret || (retlen != sizeof(*rd) + namelen)) {
+			printk(KERN_NOTICE "Write of %d bytes at 0x%08x failed. returned %d, retlen %d\n", 
 			       sizeof(*rd)+namelen, flash_ofs, ret, retlen);
 		/* Mark the space as dirtied */
-		if (retlen) {
-			raw->flash_offset |= REF_OBSOLETE;
-			jffs2_add_physical_node_ref(c, raw);
-			jffs2_mark_node_obsolete(c, raw);
-		} else {
-			printk(KERN_NOTICE "Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\n", raw->flash_offset);
-			jffs2_free_raw_node_ref(raw);
-		}
+			if (retlen) {
+				jffs2_add_physical_node_ref(c, raw, sizeof(*rd)+namelen, 1);
+				jffs2_mark_node_obsolete(c, raw);
+			} else {
+				printk(KERN_NOTICE "Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\n", raw->flash_offset);
+				jffs2_free_raw_node_ref(raw);
+			}
 
 		/* Release the full_dnode which is now useless, and return */
 		jffs2_free_full_dirent(fd);
@@ -250,359 +324,10 @@
 		return ERR_PTR(ret?ret:-EIO);
 	}
 	/* Mark the space used */
-	raw->flash_offset |= REF_PRISTINE;
-	jffs2_add_physical_node_ref(c, raw);
+	jffs2_add_physical_node_ref(c, raw, retlen, 0);
 	if (writelen)
 		*writelen = retlen;
 
 	f->inocache->nodes = raw;
 	return fd;
 }
-
-/* The OS-specific code fills in the metadata in the jffs2_raw_inode for us, so that
-   we don't have to go digging in struct inode or its equivalent. It should set:
-   mode, uid, gid, (starting)isize, atime, ctime, mtime */
-int jffs2_write_inode_range(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
-			    struct jffs2_raw_inode *ri, unsigned char *buf, 
-			    uint32_t offset, uint32_t writelen, uint32_t *retlen)
-{
-	int ret = 0;
-	uint32_t writtenlen = 0;
-
-       	D1(printk(KERN_DEBUG "jffs2_write_inode_range(): Ino #%u, ofs 0x%x, len 0x%x\n",
-		  f->inocache->ino, offset, writelen));
-		
-	while(writelen) {
-		struct jffs2_full_dnode *fn;
-		unsigned char *comprbuf = NULL;
-		unsigned char comprtype = JFFS2_COMPR_NONE;
-		uint32_t phys_ofs, alloclen;
-		uint32_t datalen, cdatalen;
-
-		D2(printk(KERN_DEBUG "jffs2_commit_write() loop: 0x%x to write to 0x%x\n", writelen, offset));
-
-		ret = jffs2_reserve_space(c, sizeof(*ri) + JFFS2_MIN_DATA_LEN, &phys_ofs, &alloclen, ALLOC_NORMAL);
-		if (ret) {
-			D1(printk(KERN_DEBUG "jffs2_reserve_space returned %d\n", ret));
-			break;
-		}
-		down(&f->sem);
-		datalen = writelen;
-		cdatalen = min(alloclen - sizeof(*ri), writelen);
-
-		comprbuf = kmalloc(cdatalen, GFP_KERNEL);
-		if (comprbuf) {
-			comprtype = jffs2_compress(buf, comprbuf, &datalen, &cdatalen);
-		}
-		if (comprtype == JFFS2_COMPR_NONE) {
-			/* Either compression failed, or the allocation of comprbuf failed */
-			if (comprbuf)
-				kfree(comprbuf);
-			comprbuf = buf;
-			datalen = cdatalen;
-		}
-		/* Now comprbuf points to the data to be written, be it compressed or not.
-		   comprtype holds the compression type, and comprtype == JFFS2_COMPR_NONE means
-		   that the comprbuf doesn't need to be kfree()d. 
-		*/
-
-		ri->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
-		ri->nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);
-		ri->totlen = cpu_to_je32(sizeof(*ri) + cdatalen);
-		ri->hdr_crc = cpu_to_je32(crc32(0, ri, sizeof(struct jffs2_unknown_node)-4));
-
-		ri->ino = cpu_to_je32(f->inocache->ino);
-		ri->version = cpu_to_je32(++f->highest_version);
-		ri->isize = cpu_to_je32(max(je32_to_cpu(ri->isize), offset + datalen));
-		ri->offset = cpu_to_je32(offset);
-		ri->csize = cpu_to_je32(cdatalen);
-		ri->dsize = cpu_to_je32(datalen);
-		ri->compr = comprtype;
-		ri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));
-		ri->data_crc = cpu_to_je32(crc32(0, comprbuf, cdatalen));
-
-		fn = jffs2_write_dnode(c, f, ri, comprbuf, cdatalen, phys_ofs, NULL);
-
-		if (comprtype != JFFS2_COMPR_NONE)
-			kfree(comprbuf);
-
-		if (IS_ERR(fn)) {
-			ret = PTR_ERR(fn);
-			up(&f->sem);
-			jffs2_complete_reservation(c);
-			break;
-		}
-		ret = jffs2_add_full_dnode_to_inode(c, f, fn);
-		if (f->metadata) {
-			jffs2_mark_node_obsolete(c, f->metadata->raw);
-			jffs2_free_full_dnode(f->metadata);
-			f->metadata = NULL;
-		}
-		if (ret) {
-			/* Eep */
-			D1(printk(KERN_DEBUG "Eep. add_full_dnode_to_inode() failed in commit_write, returned %d\n", ret));
-			jffs2_mark_node_obsolete(c, fn->raw);
-			jffs2_free_full_dnode(fn);
-
-			up(&f->sem);
-			jffs2_complete_reservation(c);
-			break;
-		}
-		up(&f->sem);
-		jffs2_complete_reservation(c);
-		if (!datalen) {
-			printk(KERN_WARNING "Eep. We didn't actually write any data in jffs2_write_inode_range()\n");
-			ret = -EIO;
-			break;
-		}
-		D1(printk(KERN_DEBUG "increasing writtenlen by %d\n", datalen));
-		writtenlen += datalen;
-		offset += datalen;
-		writelen -= datalen;
-		buf += datalen;
-	}
-	*retlen = writtenlen;
-	return ret;
-}
-
-int jffs2_do_create(struct jffs2_sb_info *c, struct jffs2_inode_info *dir_f, struct jffs2_inode_info *f, struct jffs2_raw_inode *ri, const char *name, int namelen)
-{
-	struct jffs2_raw_dirent *rd;
-	struct jffs2_full_dnode *fn;
-	struct jffs2_full_dirent *fd;
-	uint32_t alloclen, phys_ofs;
-	uint32_t writtenlen;
-	int ret;
-
-	/* Try to reserve enough space for both node and dirent. 
-	 * Just the node will do for now, though 
-	 */
-	ret = jffs2_reserve_space(c, sizeof(*ri), &phys_ofs, &alloclen, ALLOC_NORMAL);
-	D1(printk(KERN_DEBUG "jffs2_do_create(): reserved 0x%x bytes\n", alloclen));
-	if (ret) {
-		up(&f->sem);
-		return ret;
-	}
-
-	ri->data_crc = cpu_to_je32(0);
-	ri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));
-
-	fn = jffs2_write_dnode(c, f, ri, NULL, 0, phys_ofs, &writtenlen);
-
-	D1(printk(KERN_DEBUG "jffs2_do_create created file with mode 0x%x\n",
-		  je32_to_cpu(ri->mode)));
-
-	if (IS_ERR(fn)) {
-		D1(printk(KERN_DEBUG "jffs2_write_dnode() failed\n"));
-		/* Eeek. Wave bye bye */
-		up(&f->sem);
-		jffs2_complete_reservation(c);
-		return PTR_ERR(fn);
-	}
-	/* No data here. Only a metadata node, which will be 
-	   obsoleted by the first data write
-	*/
-	f->metadata = fn;
-
-	/* Work out where to put the dirent node now. */
-	writtenlen = PAD(writtenlen);
-	phys_ofs += writtenlen;
-	alloclen -= writtenlen;
-	up(&f->sem);
-
-	if (alloclen < sizeof(*rd)+namelen) {
-		/* Not enough space left in this chunk. Get some more */
-		jffs2_complete_reservation(c);
-		ret = jffs2_reserve_space(c, sizeof(*rd)+namelen, &phys_ofs, &alloclen, ALLOC_NORMAL);
-		
-		if (ret) {
-			/* Eep. */
-			D1(printk(KERN_DEBUG "jffs2_reserve_space() for dirent failed\n"));
-			return ret;
-		}
-	}
-
-	rd = jffs2_alloc_raw_dirent();
-	if (!rd) {
-		/* Argh. Now we treat it like a normal delete */
-		jffs2_complete_reservation(c);
-		return -ENOMEM;
-	}
-
-	down(&dir_f->sem);
-
-	rd->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
-	rd->nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);
-	rd->totlen = cpu_to_je32(sizeof(*rd) + namelen);
-	rd->hdr_crc = cpu_to_je32(crc32(0, rd, sizeof(struct jffs2_unknown_node)-4));
-
-	rd->pino = cpu_to_je32(dir_f->inocache->ino);
-	rd->version = cpu_to_je32(++dir_f->highest_version);
-	rd->ino = ri->ino;
-	rd->mctime = ri->ctime;
-	rd->nsize = namelen;
-	rd->type = DT_REG;
-	rd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));
-	rd->name_crc = cpu_to_je32(crc32(0, name, namelen));
-
-	fd = jffs2_write_dirent(c, dir_f, rd, name, namelen, phys_ofs, &writtenlen);
-
-	jffs2_free_raw_dirent(rd);
-	
-	if (IS_ERR(fd)) {
-		/* dirent failed to write. Delete the inode normally 
-		   as if it were the final unlink() */
-		jffs2_complete_reservation(c);
-		up(&dir_f->sem);
-		return PTR_ERR(fd);
-	}
-
-	/* Link the fd into the inode's list, obsoleting an old
-	   one if necessary. */
-	jffs2_add_fd_to_list(c, fd, &dir_f->dents);
-
-	jffs2_complete_reservation(c);
-	up(&dir_f->sem);
-
-	return 0;
-}
-
-
-int jffs2_do_unlink(struct jffs2_sb_info *c, struct jffs2_inode_info *dir_f,
-		    const char *name, int namelen, struct jffs2_inode_info *dead_f)
-{
-	struct jffs2_raw_dirent *rd;
-	struct jffs2_full_dirent *fd;
-	uint32_t alloclen, phys_ofs;
-	int ret;
-
-	rd = jffs2_alloc_raw_dirent();
-	if (!rd)
-		return -ENOMEM;
-
-	ret = jffs2_reserve_space(c, sizeof(*rd)+namelen, &phys_ofs, &alloclen, ALLOC_DELETION);
-	if (ret) {
-		jffs2_free_raw_dirent(rd);
-		return ret;
-	}
-
-	down(&dir_f->sem);
-
-	/* Build a deletion node */
-	rd->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
-	rd->nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);
-	rd->totlen = cpu_to_je32(sizeof(*rd) + namelen);
-	rd->hdr_crc = cpu_to_je32(crc32(0, rd, sizeof(struct jffs2_unknown_node)-4));
-
-	rd->pino = cpu_to_je32(dir_f->inocache->ino);
-	rd->version = cpu_to_je32(++dir_f->highest_version);
-	rd->ino = cpu_to_je32(0);
-	rd->mctime = cpu_to_je32(CURRENT_TIME);
-	rd->nsize = namelen;
-	rd->type = DT_UNKNOWN;
-	rd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));
-	rd->name_crc = cpu_to_je32(crc32(0, name, namelen));
-
-	fd = jffs2_write_dirent(c, dir_f, rd, name, namelen, phys_ofs, NULL);
-	
-	jffs2_free_raw_dirent(rd);
-
-	if (IS_ERR(fd)) {
-		jffs2_complete_reservation(c);
-		up(&dir_f->sem);
-		return PTR_ERR(fd);
-	}
-
-	/* File it. This will mark the old one obsolete. */
-	jffs2_add_fd_to_list(c, fd, &dir_f->dents);
-
-	up(&dir_f->sem);
-	
-	/* dead_f is NULL if this was a rename not a real unlink */
-	/* Also catch the !f->inocache case, where there was a dirent
-	   pointing to an inode which didn't exist. */
-	if (dead_f && dead_f->inocache) { 
-
-		down(&dead_f->sem);
-
-		while (dead_f->dents) {
-			/* There can be only deleted ones */
-			fd = dead_f->dents;
-			
-			dead_f->dents = fd->next;
-			
-			if (fd->ino) {
-				printk(KERN_WARNING "Deleting inode #%u with active dentry \"%s\"->ino #%u\n",
-				       dead_f->inocache->ino, fd->name, fd->ino);
-			} else {
-				D1(printk(KERN_DEBUG "Removing deletion dirent for \"%s\" from dir ino #%u\n", fd->name, dead_f->inocache->ino));
-			}
-			jffs2_mark_node_obsolete(c, fd->raw);
-			jffs2_free_full_dirent(fd);
-		}
-
-		dead_f->inocache->nlink--;
-		/* NB: Caller must set inode nlink if appropriate */
-		up(&dead_f->sem);
-	}
-
-	jffs2_complete_reservation(c);
-
-	return 0;
-}
-
-
-int jffs2_do_link (struct jffs2_sb_info *c, struct jffs2_inode_info *dir_f, uint32_t ino, uint8_t type, const char *name, int namelen)
-{
-	struct jffs2_raw_dirent *rd;
-	struct jffs2_full_dirent *fd;
-	uint32_t alloclen, phys_ofs;
-	int ret;
-
-	rd = jffs2_alloc_raw_dirent();
-	if (!rd)
-		return -ENOMEM;
-
-	ret = jffs2_reserve_space(c, sizeof(*rd)+namelen, &phys_ofs, &alloclen, ALLOC_NORMAL);
-	if (ret) {
-		jffs2_free_raw_dirent(rd);
-		return ret;
-	}
-	
-	down(&dir_f->sem);
-
-	/* Build a deletion node */
-	rd->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
-	rd->nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);
-	rd->totlen = cpu_to_je32(sizeof(*rd) + namelen);
-	rd->hdr_crc = cpu_to_je32(crc32(0, rd, sizeof(struct jffs2_unknown_node)-4));
-
-	rd->pino = cpu_to_je32(dir_f->inocache->ino);
-	rd->version = cpu_to_je32(++dir_f->highest_version);
-	rd->ino = cpu_to_je32(ino);
-	rd->mctime = cpu_to_je32(CURRENT_TIME);
-	rd->nsize = namelen;
-
-	rd->type = type;
-
-	rd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));
-	rd->name_crc = cpu_to_je32(crc32(0, name, namelen));
-
-	fd = jffs2_write_dirent(c, dir_f, rd, name, namelen, phys_ofs, NULL);
-	
-	jffs2_free_raw_dirent(rd);
-
-	if (IS_ERR(fd)) {
-		jffs2_complete_reservation(c);
-		up(&dir_f->sem);
-		return PTR_ERR(fd);
-	}
-
-	/* File it. This will mark the old one obsolete. */
-	jffs2_add_fd_to_list(c, fd, &dir_f->dents);
-
-	jffs2_complete_reservation(c);
-	up(&dir_f->sem);
-
-	return 0;
-}
diff -Nur linux/fs/jffs2/writev.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/writev.c
--- linux/fs/jffs2/writev.c	2003-05-13 16:19:14.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/writev.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,50 +0,0 @@
-/*
- * JFFS2 -- Journalling Flash File System, Version 2.
- *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
- *
- * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
- *
- * For licensing information, see the file 'LICENCE' in this directory.
- *
- * $Id: writev.c,v 1.3 2002/08/08 08:35:21 dwmw2 Exp $
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/mtd/mtd.h>
-#include "nodelist.h"
-
-/* This ought to be in core MTD code. All registered MTD devices
-   without writev should have this put in place. Bug the MTD
-   maintainer */
-static inline int mtd_fake_writev(struct mtd_info *mtd, const struct iovec *vecs,
-				  unsigned long count, loff_t to, size_t *retlen)
-{
-	unsigned long i;
-	size_t totlen = 0, thislen;
-	int ret = 0;
-
-	for (i=0; i<count; i++) {
-		if (!vecs[i].iov_len)
-			continue;
-		ret = mtd->write(mtd, to, vecs[i].iov_len, &thislen, vecs[i].iov_base);
-		totlen += thislen;
-		if (ret || thislen != vecs[i].iov_len)
-			break;
-		to += vecs[i].iov_len;
-	}
-	if (retlen)
-		*retlen = totlen;
-	return ret;
-}
-
-int jffs2_flash_direct_writev(struct jffs2_sb_info *c, const struct iovec *vecs,
-			      unsigned long count, loff_t to, size_t *retlen)
-{
-	if (c->mtd->writev)
-		return c->mtd->writev(c->mtd, vecs, count, to, retlen);
-	else
-		return mtd_fake_writev(c->mtd, vecs, count, to, retlen);
-}
-
diff -Nur linux/fs/jffs2/zlib.c /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/zlib.c
--- linux/fs/jffs2/zlib.c	1970-01-01 07:00:00.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/zlib.c	2003-06-23 01:47:04.000000000 +0700
@@ -0,0 +1,5382 @@
+/*
+ * This file is derived from various .h and .c files from the zlib-1.0.4
+ * distribution by Jean-loup Gailly and Mark Adler, with some additions
+ * by Paul Mackerras to aid in implementing Deflate compression and
+ * decompression for PPP packets.  See zlib.h for conditions of
+ * distribution and use.
+ *
+ * Changes that have been made include:
+ * - added Z_PACKET_FLUSH (see zlib.h for details)
+ * - added inflateIncomp and deflateOutputPending
+ * - allow strm->next_out to be NULL, meaning discard the output
+ *
+ * $Id: zlib.c,v 1.3 1997/12/23 10:47:42 paulus Exp $
+ */
+
+#include <linux/config.h>
+
+#ifndef CONFIG_PPP_DEFLATE
+
+/* 
+ *  ==FILEVERSION 20020318==
+ *
+ * This marker is used by the Linux installation script to determine
+ * whether an up-to-date version of this file is already installed.
+ */
+
+#define NO_DUMMY_DECL
+#define NO_ZCFUNCS
+#define MY_ZCALLOC
+
+#if defined(__FreeBSD__) && (defined(KERNEL) || defined(_KERNEL))
+#define inflate	inflate_ppp	/* FreeBSD already has an inflate :-( */
+#endif
+
+
+/* +++ zutil.h */
+/* zutil.h -- internal interface and configuration of the compression library
+ * Copyright (C) 1995-1996 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* From: zutil.h,v 1.16 1996/07/24 13:41:13 me Exp $ */
+
+#ifndef _Z_UTIL_H
+#define _Z_UTIL_H
+
+#include "zlib.h"
+
+#if defined(KERNEL) || defined(_KERNEL)
+/* Assume this is a *BSD or SVR4 kernel */
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/systm.h>
+#  define HAVE_MEMCPY
+#  define memcpy(d, s, n)	bcopy((s), (d), (n))
+#  define memset(d, v, n)	bzero((d), (n))
+#  define memcmp		bcmp
+
+#else
+#if defined(__KERNEL__)
+/* Assume this is a Linux kernel */
+#include <linux/string.h>
+#define HAVE_MEMCPY
+
+#else /* not kernel */
+
+#if defined(MSDOS)||defined(VMS)||defined(CRAY)||defined(WIN32)||defined(RISCOS)
+#   include <stddef.h>
+#   include <errno.h>
+#else
+    extern int errno;
+#endif
+#ifdef STDC
+#  include <string.h>
+#  include <stdlib.h>
+#endif
+#endif /* __KERNEL__ */
+#endif /* _KERNEL || KERNEL */
+
+#ifndef local
+#  define local static
+#endif
+/* compile with -Dlocal if your debugger can't find static symbols */
+
+typedef unsigned char  uch;
+typedef uch FAR uchf;
+typedef unsigned short ush;
+typedef ush FAR ushf;
+typedef unsigned long  ulg;
+
+extern const char *z_errmsg[10]; /* indexed by 2-zlib_error */
+/* (size given to avoid silly warnings with Visual C++) */
+
+#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
+
+#define ERR_RETURN(strm,err) \
+  return (strm->msg = (char*)ERR_MSG(err), (err))
+/* To be used only when the state is known to be valid */
+
+        /* common constants */
+
+#ifndef DEF_WBITS
+#  define DEF_WBITS MAX_WBITS
+#endif
+/* default windowBits for decompression. MAX_WBITS is for compression only */
+
+#if MAX_MEM_LEVEL >= 8
+#  define DEF_MEM_LEVEL 8
+#else
+#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
+#endif
+/* default memLevel */
+
+#define STORED_BLOCK 0
+#define STATIC_TREES 1
+#define DYN_TREES    2
+/* The three kinds of block type */
+
+#define MIN_MATCH  3
+#define MAX_MATCH  258
+/* The minimum and maximum match lengths */
+
+#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */
+
+        /* target dependencies */
+
+#ifdef MSDOS
+#  define OS_CODE  0x00
+#  ifdef __TURBOC__
+#    include <alloc.h>
+#  else /* MSC or DJGPP */
+#    include <malloc.h>
+#  endif
+#endif
+
+#ifdef OS2
+#  define OS_CODE  0x06
+#endif
+
+#ifdef WIN32 /* Window 95 & Windows NT */
+#  define OS_CODE  0x0b
+#endif
+
+#if defined(VAXC) || defined(VMS)
+#  define OS_CODE  0x02
+#  define FOPEN(name, mode) \
+     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
+#endif
+
+#ifdef AMIGA
+#  define OS_CODE  0x01
+#endif
+
+#if defined(ATARI) || defined(atarist)
+#  define OS_CODE  0x05
+#endif
+
+#ifdef MACOS
+#  define OS_CODE  0x07
+#endif
+
+#ifdef __50SERIES /* Prime/PRIMOS */
+#  define OS_CODE  0x0F
+#endif
+
+#ifdef TOPS20
+#  define OS_CODE  0x0a
+#endif
+
+#if defined(_BEOS_) || defined(RISCOS)
+#  define fdopen(fd,mode) NULL /* No fdopen() */
+#endif
+
+        /* Common defaults */
+
+#ifndef OS_CODE
+#  define OS_CODE  0x03  /* assume Unix */
+#endif
+
+#ifndef FOPEN
+#  define FOPEN(name, mode) fopen((name), (mode))
+#endif
+
+         /* functions */
+
+#ifdef HAVE_STRERROR
+   extern char *strerror OF((int));
+#  define zstrerror(errnum) strerror(errnum)
+#else
+#  define zstrerror(errnum) ""
+#endif
+
+#if defined(pyr)
+#  define NO_MEMCPY
+#endif
+#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(_MSC_VER)
+ /* Use our own functions for small and medium model with MSC <= 5.0.
+  * You may have to use the same strategy for Borland C (untested).
+  */
+#  define NO_MEMCPY
+#endif
+#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
+#  define HAVE_MEMCPY
+#endif
+#ifdef HAVE_MEMCPY
+#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
+#    define zmemcpy _fmemcpy
+#    define zmemcmp _fmemcmp
+#    define zmemzero(dest, len) _fmemset(dest, 0, len)
+#  else
+#    define zmemcpy memcpy
+#    define zmemcmp memcmp
+#    define zmemzero(dest, len) memset(dest, 0, len)
+#  endif
+#else
+   extern void zmemcpy  OF((Bytef* dest, Bytef* source, uInt len));
+   extern int  zmemcmp  OF((Bytef* s1,   Bytef* s2, uInt len));
+   extern void zmemzero OF((Bytef* dest, uInt len));
+#endif
+
+/* Diagnostic functions */
+#ifdef DEBUG_ZLIB
+#  include <stdio.h>
+#  ifndef verbose
+#    define verbose 0
+#  endif
+   extern void z_error    OF((char *m));
+#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
+#  define Trace(x) fprintf x
+#  define Tracev(x) {if (verbose) fprintf x ;}
+#  define Tracevv(x) {if (verbose>1) fprintf x ;}
+#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}
+#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}
+#else
+#  define Assert(cond,msg)
+#  define Trace(x)
+#  define Tracev(x)
+#  define Tracevv(x)
+#  define Tracec(c,x)
+#  define Tracecv(c,x)
+#endif
+
+
+typedef uLong (*check_func) OF((uLong check, const Bytef *buf, uInt len));
+
+voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size));
+void   zcfree  OF((voidpf opaque, voidpf ptr));
+
+#define ZALLOC(strm, items, size) \
+           (*((strm)->zalloc))((strm)->opaque, (items), (size))
+#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
+#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}
+
+#endif /* _Z_UTIL_H */
+/* --- zutil.h */
+
+/* +++ deflate.h */
+/* deflate.h -- internal compression state
+ * Copyright (C) 1995-1996 Jean-loup Gailly
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* From: deflate.h,v 1.10 1996/07/02 12:41:00 me Exp $ */
+
+#ifndef _DEFLATE_H
+#define _DEFLATE_H
+
+/* #include "zutil.h" */
+
+/* ===========================================================================
+ * Internal compression state.
+ */
+
+#define LENGTH_CODES 29
+/* number of length codes, not counting the special END_BLOCK code */
+
+#define LITERALS  256
+/* number of literal bytes 0..255 */
+
+#define L_CODES (LITERALS+1+LENGTH_CODES)
+/* number of Literal or Length codes, including the END_BLOCK code */
+
+#define D_CODES   30
+/* number of distance codes */
+
+#define BL_CODES  19
+/* number of codes used to transfer the bit lengths */
+
+#define HEAP_SIZE (2*L_CODES+1)
+/* maximum heap size */
+
+#define MAX_BITS 15
+/* All codes must not exceed MAX_BITS bits */
+
+#define INIT_STATE    42
+#define BUSY_STATE   113
+#define FINISH_STATE 666
+/* Stream status */
+
+
+/* Data structure describing a single value and its code string. */
+typedef struct ct_data_s {
+    union {
+        ush  freq;       /* frequency count */
+        ush  code;       /* bit string */
+    } fc;
+    union {
+        ush  dad;        /* father node in Huffman tree */
+        ush  len;        /* length of bit string */
+    } dl;
+} FAR ct_data;
+
+#define Freq fc.freq
+#define Code fc.code
+#define Dad  dl.dad
+#define Len  dl.len
+
+typedef struct static_tree_desc_s  static_tree_desc;
+
+typedef struct tree_desc_s {
+    ct_data *dyn_tree;           /* the dynamic tree */
+    int     max_code;            /* largest code with non zero frequency */
+    static_tree_desc *stat_desc; /* the corresponding static tree */
+} FAR tree_desc;
+
+typedef ush Pos;
+typedef Pos FAR Posf;
+typedef unsigned IPos;
+
+/* A Pos is an index in the character window. We use short instead of int to
+ * save space in the various tables. IPos is used only for parameter passing.
+ */
+
+typedef struct deflate_state {
+    z_streamp strm;      /* pointer back to this zlib stream */
+    int   status;        /* as the name implies */
+    Bytef *pending_buf;  /* output still pending */
+    ulg   pending_buf_size; /* size of pending_buf */
+    Bytef *pending_out;  /* next pending byte to output to the stream */
+    int   pending;       /* nb of bytes in the pending buffer */
+    int   noheader;      /* suppress zlib header and adler32 */
+    Byte  data_type;     /* UNKNOWN, BINARY or ASCII */
+    Byte  method;        /* STORED (for zip only) or DEFLATED */
+    int   last_flush;    /* value of flush param for previous deflate call */
+
+                /* used by deflate.c: */
+
+    uInt  w_size;        /* LZ77 window size (32K by default) */
+    uInt  w_bits;        /* log2(w_size)  (8..16) */
+    uInt  w_mask;        /* w_size - 1 */
+
+    Bytef *window;
+    /* Sliding window. Input bytes are read into the second half of the window,
+     * and move to the first half later to keep a dictionary of at least wSize
+     * bytes. With this organization, matches are limited to a distance of
+     * wSize-MAX_MATCH bytes, but this ensures that IO is always
+     * performed with a length multiple of the block size. Also, it limits
+     * the window size to 64K, which is quite useful on MSDOS.
+     * To do: use the user input buffer as sliding window.
+     */
+
+    ulg window_size;
+    /* Actual size of window: 2*wSize, except when the user input buffer
+     * is directly used as sliding window.
+     */
+
+    Posf *prev;
+    /* Link to older string with same hash index. To limit the size of this
+     * array to 64K, this link is maintained only for the last 32K strings.
+     * An index in this array is thus a window index modulo 32K.
+     */
+
+    Posf *head; /* Heads of the hash chains or NIL. */
+
+    uInt  ins_h;          /* hash index of string to be inserted */
+    uInt  hash_size;      /* number of elements in hash table */
+    uInt  hash_bits;      /* log2(hash_size) */
+    uInt  hash_mask;      /* hash_size-1 */
+
+    uInt  hash_shift;
+    /* Number of bits by which ins_h must be shifted at each input
+     * step. It must be such that after MIN_MATCH steps, the oldest
+     * byte no longer takes part in the hash key, that is:
+     *   hash_shift * MIN_MATCH >= hash_bits
+     */
+
+    long block_start;
+    /* Window position at the beginning of the current output block. Gets
+     * negative when the window is moved backwards.
+     */
+
+    uInt match_length;           /* length of best match */
+    IPos prev_match;             /* previous match */
+    int match_available;         /* set if previous match exists */
+    uInt strstart;               /* start of string to insert */
+    uInt match_start;            /* start of matching string */
+    uInt lookahead;              /* number of valid bytes ahead in window */
+
+    uInt prev_length;
+    /* Length of the best match at previous step. Matches not greater than this
+     * are discarded. This is used in the lazy match evaluation.
+     */
+
+    uInt max_chain_length;
+    /* To speed up deflation, hash chains are never searched beyond this
+     * length.  A higher limit improves compression ratio but degrades the
+     * speed.
+     */
+
+    uInt max_lazy_match;
+    /* Attempt to find a better match only when the current match is strictly
+     * smaller than this value. This mechanism is used only for compression
+     * levels >= 4.
+     */
+#   define max_insert_length  max_lazy_match
+    /* Insert new strings in the hash table only if the match length is not
+     * greater than this length. This saves time but degrades compression.
+     * max_insert_length is used only for compression levels <= 3.
+     */
+
+    int level;    /* compression level (1..9) */
+    int strategy; /* favor or force Huffman coding*/
+
+    uInt good_match;
+    /* Use a faster search when the previous match is longer than this */
+
+    int nice_match; /* Stop searching when current match exceeds this */
+
+                /* used by trees.c: */
+    /* Didn't use ct_data typedef below to supress compiler warning */
+    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
+    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
+    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
+
+    struct tree_desc_s l_desc;               /* desc. for literal tree */
+    struct tree_desc_s d_desc;               /* desc. for distance tree */
+    struct tree_desc_s bl_desc;              /* desc. for bit length tree */
+
+    ush bl_count[MAX_BITS+1];
+    /* number of codes at each bit length for an optimal tree */
+
+    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
+    int heap_len;               /* number of elements in the heap */
+    int heap_max;               /* element of largest frequency */
+    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
+     * The same heap array is used to build all trees.
+     */
+
+    uch depth[2*L_CODES+1];
+    /* Depth of each subtree used as tie breaker for trees of equal frequency
+     */
+
+    uchf *l_buf;          /* buffer for literals or lengths */
+
+    uInt  lit_bufsize;
+    /* Size of match buffer for literals/lengths.  There are 4 reasons for
+     * limiting lit_bufsize to 64K:
+     *   - frequencies can be kept in 16 bit counters
+     *   - if compression is not successful for the first block, all input
+     *     data is still in the window so we can still emit a stored block even
+     *     when input comes from standard input.  (This can also be done for
+     *     all blocks if lit_bufsize is not greater than 32K.)
+     *   - if compression is not successful for a file smaller than 64K, we can
+     *     even emit a stored file instead of a stored block (saving 5 bytes).
+     *     This is applicable only for zip (not gzip or zlib).
+     *   - creating new Huffman trees less frequently may not provide fast
+     *     adaptation to changes in the input data statistics. (Take for
+     *     example a binary file with poorly compressible code followed by
+     *     a highly compressible string table.) Smaller buffer sizes give
+     *     fast adaptation but have of course the overhead of transmitting
+     *     trees more frequently.
+     *   - I can't count above 4
+     */
+
+    uInt last_lit;      /* running index in l_buf */
+
+    ushf *d_buf;
+    /* Buffer for distances. To simplify the code, d_buf and l_buf have
+     * the same number of elements. To use different lengths, an extra flag
+     * array would be necessary.
+     */
+
+    ulg opt_len;        /* bit length of current block with optimal trees */
+    ulg static_len;     /* bit length of current block with static trees */
+    ulg compressed_len; /* total bit length of compressed file */
+    uInt matches;       /* number of string matches in current block */
+    int last_eob_len;   /* bit length of EOB code for last block */
+
+#ifdef DEBUG_ZLIB
+    ulg bits_sent;      /* bit length of the compressed data */
+#endif
+
+    ush bi_buf;
+    /* Output buffer. bits are inserted starting at the bottom (least
+     * significant bits).
+     */
+    int bi_valid;
+    /* Number of valid bits in bi_buf.  All bits above the last valid bit
+     * are always zero.
+     */
+
+} FAR deflate_state;
+
+/* Output a byte on the stream.
+ * IN assertion: there is enough room in pending_buf.
+ */
+#define put_byte(s, c) {s->pending_buf[s->pending++] = (c);}
+
+
+#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
+/* Minimum amount of lookahead, except at the end of the input file.
+ * See deflate.c for comments about the MIN_MATCH+1.
+ */
+
+#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
+/* In order to simplify the code, particularly on 16 bit machines, match
+ * distances are limited to MAX_DIST instead of WSIZE.
+ */
+
+        /* in trees.c */
+void _tr_init         OF((deflate_state *s));
+int  _tr_tally        OF((deflate_state *s, unsigned dist, unsigned lc));
+ulg  _tr_flush_block  OF((deflate_state *s, charf *buf, ulg stored_len,
+			  int eof));
+void _tr_align        OF((deflate_state *s));
+void _tr_stored_block OF((deflate_state *s, charf *buf, ulg stored_len,
+                          int eof));
+void _tr_stored_type_only OF((deflate_state *));
+
+#endif
+/* --- deflate.h */
+
+/* +++ deflate.c */
+/* deflate.c -- compress data using the deflation algorithm
+ * Copyright (C) 1995-1996 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/*
+ *  ALGORITHM
+ *
+ *      The "deflation" process depends on being able to identify portions
+ *      of the input text which are identical to earlier input (within a
+ *      sliding window trailing behind the input currently being processed).
+ *
+ *      The most straightforward technique turns out to be the fastest for
+ *      most input files: try all possible matches and select the longest.
+ *      The key feature of this algorithm is that insertions into the string
+ *      dictionary are very simple and thus fast, and deletions are avoided
+ *      completely. Insertions are performed at each input character, whereas
+ *      string matches are performed only when the previous match ends. So it
+ *      is preferable to spend more time in matches to allow very fast string
+ *      insertions and avoid deletions. The matching algorithm for small
+ *      strings is inspired from that of Rabin & Karp. A brute force approach
+ *      is used to find longer strings when a small match has been found.
+ *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
+ *      (by Leonid Broukhis).
+ *         A previous version of this file used a more sophisticated algorithm
+ *      (by Fiala and Greene) which is guaranteed to run in linear amortized
+ *      time, but has a larger average cost, uses more memory and is patented.
+ *      However the F&G algorithm may be faster for some highly redundant
+ *      files if the parameter max_chain_length (described below) is too large.
+ *
+ *  ACKNOWLEDGEMENTS
+ *
+ *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
+ *      I found it in 'freeze' written by Leonid Broukhis.
+ *      Thanks to many people for bug reports and testing.
+ *
+ *  REFERENCES
+ *
+ *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
+ *      Available in ftp://ds.internic.net/rfc/rfc1951.txt
+ *
+ *      A description of the Rabin and Karp algorithm is given in the book
+ *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
+ *
+ *      Fiala,E.R., and Greene,D.H.
+ *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
+ *
+ */
+
+/* From: deflate.c,v 1.15 1996/07/24 13:40:58 me Exp $ */
+
+/* #include "deflate.h" */
+
+char deflate_copyright[] = " deflate 1.0.4 Copyright 1995-1996 Jean-loup Gailly ";
+/*
+  If you use the zlib library in a product, an acknowledgment is welcome
+  in the documentation of your product. If for some reason you cannot
+  include such an acknowledgment, I would appreciate that you keep this
+  copyright string in the executable of your product.
+ */
+
+/* ===========================================================================
+ *  Function prototypes.
+ */
+typedef enum {
+    need_more,      /* block not completed, need more input or more output */
+    block_done,     /* block flush performed */
+    finish_started, /* finish started, need only more output at next deflate */
+    finish_done     /* finish done, accept no more input or output */
+} block_state;
+
+typedef block_state (*compress_func) OF((deflate_state *s, int flush));
+/* Compression function. Returns the block state after the call. */
+
+local void fill_window    OF((deflate_state *s));
+local block_state deflate_stored OF((deflate_state *s, int flush));
+local block_state deflate_fast   OF((deflate_state *s, int flush));
+local block_state deflate_slow   OF((deflate_state *s, int flush));
+local void lm_init        OF((deflate_state *s));
+local void putShortMSB    OF((deflate_state *s, uInt b));
+local void flush_pending  OF((z_streamp strm));
+local int read_buf        OF((z_streamp strm, charf *buf, unsigned size));
+#ifdef ASMV
+      void match_init OF((void)); /* asm code initialization */
+      uInt longest_match  OF((deflate_state *s, IPos cur_match));
+#else
+local uInt longest_match  OF((deflate_state *s, IPos cur_match));
+#endif
+
+#ifdef DEBUG_ZLIB
+local  void check_match OF((deflate_state *s, IPos start, IPos match,
+                            int length));
+#endif
+
+/* ===========================================================================
+ * Local data
+ */
+
+#define NIL 0
+/* Tail of hash chains */
+
+#ifndef TOO_FAR
+#  define TOO_FAR 4096
+#endif
+/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
+
+#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
+/* Minimum amount of lookahead, except at the end of the input file.
+ * See deflate.c for comments about the MIN_MATCH+1.
+ */
+
+/* Values for max_lazy_match, good_match and max_chain_length, depending on
+ * the desired pack level (0..9). The values given below have been tuned to
+ * exclude worst case performance for pathological files. Better values may be
+ * found for specific files.
+ */
+typedef struct config_s {
+   ush good_length; /* reduce lazy search above this match length */
+   ush max_lazy;    /* do not perform lazy search above this match length */
+   ush nice_length; /* quit search above this match length */
+   ush max_chain;
+   compress_func func;
+} config;
+
+local config configuration_table[10] = {
+/*      good lazy nice chain */
+/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
+/* 1 */ {4,    4,  8,    4, deflate_fast}, /* maximum speed, no lazy matches */
+/* 2 */ {4,    5, 16,    8, deflate_fast},
+/* 3 */ {4,    6, 32,   32, deflate_fast},
+
+/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
+/* 5 */ {8,   16, 32,   32, deflate_slow},
+/* 6 */ {8,   16, 128, 128, deflate_slow},
+/* 7 */ {8,   32, 128, 256, deflate_slow},
+/* 8 */ {32, 128, 258, 1024, deflate_slow},
+/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* maximum compression */
+
+/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
+ * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
+ * meaning.
+ */
+
+#define EQUAL 0
+/* result of memcmp for equal strings */
+
+#ifndef NO_DUMMY_DECL
+struct static_tree_desc_s {int dummy;}; /* for buggy compilers */
+#endif
+
+/* ===========================================================================
+ * Update a hash value with the given input byte
+ * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
+ *    input characters, so that a running hash key can be computed from the
+ *    previous key instead of complete recalculation each time.
+ */
+#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)
+
+
+/* ===========================================================================
+ * Insert string str in the dictionary and set match_head to the previous head
+ * of the hash chain (the most recent string with same hash key). Return
+ * the previous length of the hash chain.
+ * IN  assertion: all calls to to INSERT_STRING are made with consecutive
+ *    input characters and the first MIN_MATCH bytes of str are valid
+ *    (except for the last MIN_MATCH-1 bytes of the input file).
+ */
+#define INSERT_STRING(s, str, match_head) \
+   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
+    s->prev[(str) & s->w_mask] = match_head = s->head[s->ins_h], \
+    s->head[s->ins_h] = (Pos)(str))
+
+/* ===========================================================================
+ * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
+ * prev[] will be initialized on the fly.
+ */
+#define CLEAR_HASH(s) \
+    s->head[s->hash_size-1] = NIL; \
+    zmemzero((charf *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));
+
+/* ========================================================================= */
+int deflateInit_(strm, level, version, stream_size)
+    z_streamp strm;
+    int level;
+    const char *version;
+    int stream_size;
+{
+    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
+			 Z_DEFAULT_STRATEGY, version, stream_size);
+    /* To do: ignore strm->next_in if we use it as window */
+}
+
+/* ========================================================================= */
+int deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
+		  version, stream_size)
+    z_streamp strm;
+    int  level;
+    int  method;
+    int  windowBits;
+    int  memLevel;
+    int  strategy;
+    const char *version;
+    int stream_size;
+{
+    deflate_state *s;
+    int noheader = 0;
+    static char* my_version = ZLIB_VERSION;
+
+    ushf *overlay;
+    /* We overlay pending_buf and d_buf+l_buf. This works since the average
+     * output size for (length,distance) codes is <= 24 bits.
+     */
+
+    if (version == Z_NULL || version[0] != my_version[0] ||
+        stream_size != sizeof(z_stream)) {
+	return Z_VERSION_ERROR;
+    }
+    if (strm == Z_NULL) return Z_STREAM_ERROR;
+
+    strm->msg = Z_NULL;
+#ifndef NO_ZCFUNCS
+    if (strm->zalloc == Z_NULL) {
+	strm->zalloc = zcalloc;
+	strm->opaque = (voidpf)0;
+    }
+    if (strm->zfree == Z_NULL) strm->zfree = zcfree;
+#endif
+
+    if (level == Z_DEFAULT_COMPRESSION) level = 6;
+
+    if (windowBits < 0) { /* undocumented feature: suppress zlib header */
+        noheader = 1;
+        windowBits = -windowBits;
+    }
+    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
+        windowBits < 9 || windowBits > 15 || level < 0 || level > 9 ||
+	strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
+        return Z_STREAM_ERROR;
+    }
+    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
+    if (s == Z_NULL) return Z_MEM_ERROR;
+    strm->state = (struct internal_state FAR *)s;
+    s->strm = strm;
+
+    s->noheader = noheader;
+    s->w_bits = windowBits;
+    s->w_size = 1 << s->w_bits;
+    s->w_mask = s->w_size - 1;
+
+    s->hash_bits = memLevel + 7;
+    s->hash_size = 1 << s->hash_bits;
+    s->hash_mask = s->hash_size - 1;
+    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
+
+    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
+    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
+    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
+
+    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
+
+    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
+    s->pending_buf = (uchf *) overlay;
+    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);
+
+    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
+        s->pending_buf == Z_NULL) {
+        strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);
+        deflateEnd (strm);
+        return Z_MEM_ERROR;
+    }
+    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
+    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
+
+    s->level = level;
+    s->strategy = strategy;
+    s->method = (Byte)method;
+
+    return deflateReset(strm);
+}
+
+/* ========================================================================= */
+int deflateSetDictionary (strm, dictionary, dictLength)
+    z_streamp strm;
+    const Bytef *dictionary;
+    uInt  dictLength;
+{
+    deflate_state *s;
+    uInt length = dictLength;
+    uInt n;
+    IPos hash_head = 0;
+
+    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL)
+	return Z_STREAM_ERROR;
+
+    s = (deflate_state *) strm->state;
+    if (s->status != INIT_STATE) return Z_STREAM_ERROR;
+
+    strm->adler = adler32(strm->adler, dictionary, dictLength);
+
+    if (length < MIN_MATCH) return Z_OK;
+    if (length > MAX_DIST(s)) {
+	length = MAX_DIST(s);
+#ifndef USE_DICT_HEAD
+	dictionary += dictLength - length; /* use the tail of the dictionary */
+#endif
+    }
+    zmemcpy((charf *)s->window, dictionary, length);
+    s->strstart = length;
+    s->block_start = (long)length;
+
+    /* Insert all strings in the hash table (except for the last two bytes).
+     * s->lookahead stays null, so s->ins_h will be recomputed at the next
+     * call of fill_window.
+     */
+    s->ins_h = s->window[0];
+    UPDATE_HASH(s, s->ins_h, s->window[1]);
+    for (n = 0; n <= length - MIN_MATCH; n++) {
+	INSERT_STRING(s, n, hash_head);
+    }
+    if (hash_head) hash_head = 0;  /* to make compiler happy */
+    return Z_OK;
+}
+
+/* ========================================================================= */
+int deflateReset (strm)
+    z_streamp strm;
+{
+    deflate_state *s;
+    
+    if (strm == Z_NULL || strm->state == Z_NULL ||
+        strm->zalloc == Z_NULL || strm->zfree == Z_NULL) return Z_STREAM_ERROR;
+
+    strm->total_in = strm->total_out = 0;
+    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
+    strm->data_type = Z_UNKNOWN;
+
+    s = (deflate_state *)strm->state;
+    s->pending = 0;
+    s->pending_out = s->pending_buf;
+
+    if (s->noheader < 0) {
+        s->noheader = 0; /* was set to -1 by deflate(..., Z_FINISH); */
+    }
+    s->status = s->noheader ? BUSY_STATE : INIT_STATE;
+    strm->adler = 1;
+    s->last_flush = Z_NO_FLUSH;
+
+    _tr_init(s);
+    lm_init(s);
+
+    return Z_OK;
+}
+
+/* ========================================================================= */
+int deflateParams(strm, level, strategy)
+    z_streamp strm;
+    int level;
+    int strategy;
+{
+    deflate_state *s;
+    compress_func func;
+    int err = Z_OK;
+
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    s = (deflate_state *) strm->state;
+
+    if (level == Z_DEFAULT_COMPRESSION) {
+	level = 6;
+    }
+    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
+	return Z_STREAM_ERROR;
+    }
+    func = configuration_table[s->level].func;
+
+    if (func != configuration_table[level].func && strm->total_in != 0) {
+	/* Flush the last buffer: */
+	err = deflate(strm, Z_PARTIAL_FLUSH);
+    }
+    if (s->level != level) {
+	s->level = level;
+	s->max_lazy_match   = configuration_table[level].max_lazy;
+	s->good_match       = configuration_table[level].good_length;
+	s->nice_match       = configuration_table[level].nice_length;
+	s->max_chain_length = configuration_table[level].max_chain;
+    }
+    s->strategy = strategy;
+    return err;
+}
+
+/* =========================================================================
+ * Put a short in the pending buffer. The 16-bit value is put in MSB order.
+ * IN assertion: the stream state is correct and there is enough room in
+ * pending_buf.
+ */
+local void putShortMSB (s, b)
+    deflate_state *s;
+    uInt b;
+{
+    put_byte(s, (Byte)(b >> 8));
+    put_byte(s, (Byte)(b & 0xff));
+}   
+
+/* =========================================================================
+ * Flush as much pending output as possible. All deflate() output goes
+ * through this function so some applications may wish to modify it
+ * to avoid allocating a large strm->next_out buffer and copying into it.
+ * (See also read_buf()).
+ */
+local void flush_pending(strm)
+    z_streamp strm;
+{
+    deflate_state *s = (deflate_state *) strm->state;
+    unsigned len = s->pending;
+
+    if (len > strm->avail_out) len = strm->avail_out;
+    if (len == 0) return;
+
+    if (strm->next_out != Z_NULL) {
+	zmemcpy(strm->next_out, s->pending_out, len);
+	strm->next_out += len;
+    }
+    s->pending_out += len;
+    strm->total_out += len;
+    strm->avail_out  -= len;
+    s->pending -= len;
+    if (s->pending == 0) {
+        s->pending_out = s->pending_buf;
+    }
+}
+
+/* ========================================================================= */
+int deflate (strm, flush)
+    z_streamp strm;
+    int flush;
+{
+    int old_flush; /* value of flush param for previous deflate call */
+    deflate_state *s;
+
+    if (strm == Z_NULL || strm->state == Z_NULL ||
+	flush > Z_FINISH || flush < 0) {
+        return Z_STREAM_ERROR;
+    }
+    s = (deflate_state *) strm->state;
+
+    if ((strm->next_in == Z_NULL && strm->avail_in != 0) ||
+	(s->status == FINISH_STATE && flush != Z_FINISH)) {
+        ERR_RETURN(strm, Z_STREAM_ERROR);
+    }
+    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);
+
+    s->strm = strm; /* just in case */
+    old_flush = s->last_flush;
+    s->last_flush = flush;
+
+    /* Write the zlib header */
+    if (s->status == INIT_STATE) {
+
+        uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
+        uInt level_flags = (s->level-1) >> 1;
+
+        if (level_flags > 3) level_flags = 3;
+        header |= (level_flags << 6);
+	if (s->strstart != 0) header |= PRESET_DICT;
+        header += 31 - (header % 31);
+
+        s->status = BUSY_STATE;
+        putShortMSB(s, header);
+
+	/* Save the adler32 of the preset dictionary: */
+	if (s->strstart != 0) {
+	    putShortMSB(s, (uInt)(strm->adler >> 16));
+	    putShortMSB(s, (uInt)(strm->adler & 0xffff));
+	}
+	strm->adler = 1L;
+    }
+
+    /* Flush as much pending output as possible */
+    if (s->pending != 0) {
+        flush_pending(strm);
+        if (strm->avail_out == 0) {
+	    /* Since avail_out is 0, deflate will be called again with
+	     * more output space, but possibly with both pending and
+	     * avail_in equal to zero. There won't be anything to do,
+	     * but this is not an error situation so make sure we
+	     * return OK instead of BUF_ERROR at next call of deflate:
+             */
+	    s->last_flush = -1;
+	    return Z_OK;
+	}
+
+    /* Make sure there is something to do and avoid duplicate consecutive
+     * flushes. For repeated and useless calls with Z_FINISH, we keep
+     * returning Z_STREAM_END instead of Z_BUFF_ERROR.
+     */
+    } else if (strm->avail_in == 0 && flush <= old_flush &&
+	       flush != Z_FINISH) {
+        ERR_RETURN(strm, Z_BUF_ERROR);
+    }
+
+    /* User must not provide more input after the first FINISH: */
+    if (s->status == FINISH_STATE && strm->avail_in != 0) {
+        ERR_RETURN(strm, Z_BUF_ERROR);
+    }
+
+    /* Start a new block or continue the current one.
+     */
+    if (strm->avail_in != 0 || s->lookahead != 0 ||
+        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
+        block_state bstate;
+
+	bstate = (*(configuration_table[s->level].func))(s, flush);
+
+        if (bstate == finish_started || bstate == finish_done) {
+            s->status = FINISH_STATE;
+        }
+        if (bstate == need_more || bstate == finish_started) {
+	    if (strm->avail_out == 0) {
+	        s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
+	    }
+	    return Z_OK;
+	    /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
+	     * of deflate should use the same flush parameter to make sure
+	     * that the flush is complete. So we don't have to output an
+	     * empty block here, this will be done at next call. This also
+	     * ensures that for a very small output buffer, we emit at most
+	     * one empty block.
+	     */
+	}
+        if (bstate == block_done) {
+            if (flush == Z_PARTIAL_FLUSH) {
+                _tr_align(s);
+	    } else if (flush == Z_PACKET_FLUSH) {
+		/* Output just the 3-bit `stored' block type value,
+		   but not a zero length. */
+		_tr_stored_type_only(s);
+            } else { /* FULL_FLUSH or SYNC_FLUSH */
+                _tr_stored_block(s, (char*)0, 0L, 0);
+                /* For a full flush, this empty block will be recognized
+                 * as a special marker by inflate_sync().
+                 */
+                if (flush == Z_FULL_FLUSH) {
+                    CLEAR_HASH(s);             /* forget history */
+                }
+            }
+            flush_pending(strm);
+	    if (strm->avail_out == 0) {
+	      s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
+	      return Z_OK;
+	    }
+        }
+    }
+    Assert(strm->avail_out > 0, "bug2");
+
+    if (flush != Z_FINISH) return Z_OK;
+    if (s->noheader) return Z_STREAM_END;
+
+    /* Write the zlib trailer (adler32) */
+    putShortMSB(s, (uInt)(strm->adler >> 16));
+    putShortMSB(s, (uInt)(strm->adler & 0xffff));
+    flush_pending(strm);
+    /* If avail_out is zero, the application will call deflate again
+     * to flush the rest.
+     */
+    s->noheader = -1; /* write the trailer only once! */
+    return s->pending != 0 ? Z_OK : Z_STREAM_END;
+}
+
+/* ========================================================================= */
+int deflateEnd (strm)
+    z_streamp strm;
+{
+    int status;
+    deflate_state *s;
+
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    s = (deflate_state *) strm->state;
+
+    status = s->status;
+    if (status != INIT_STATE && status != BUSY_STATE &&
+	status != FINISH_STATE) {
+      return Z_STREAM_ERROR;
+    }
+
+    /* Deallocate in reverse order of allocations: */
+    TRY_FREE(strm, s->pending_buf);
+    TRY_FREE(strm, s->head);
+    TRY_FREE(strm, s->prev);
+    TRY_FREE(strm, s->window);
+
+    ZFREE(strm, s);
+    strm->state = Z_NULL;
+
+    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
+}
+
+/* =========================================================================
+ * Copy the source state to the destination state.
+ */
+int deflateCopy (dest, source)
+    z_streamp dest;
+    z_streamp source;
+{
+    deflate_state *ds;
+    deflate_state *ss;
+    ushf *overlay;
+
+    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL)
+        return Z_STREAM_ERROR;
+    ss = (deflate_state *) source->state;
+
+    *dest = *source;
+
+    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
+    if (ds == Z_NULL) return Z_MEM_ERROR;
+    dest->state = (struct internal_state FAR *) ds;
+    *ds = *ss;
+    ds->strm = dest;
+
+    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
+    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
+    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
+    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
+    ds->pending_buf = (uchf *) overlay;
+
+    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
+        ds->pending_buf == Z_NULL) {
+        deflateEnd (dest);
+        return Z_MEM_ERROR;
+    }
+    /* ??? following zmemcpy doesn't work for 16-bit MSDOS */
+    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
+    zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));
+    zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));
+    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);
+
+    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
+    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
+    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;
+
+    ds->l_desc.dyn_tree = ds->dyn_ltree;
+    ds->d_desc.dyn_tree = ds->dyn_dtree;
+    ds->bl_desc.dyn_tree = ds->bl_tree;
+
+    return Z_OK;
+}
+
+/* ===========================================================================
+ * Return the number of bytes of output which are immediately available
+ * for output from the decompressor.
+ */
+int deflateOutputPending (strm)
+    z_streamp strm;
+{
+    if (strm == Z_NULL || strm->state == Z_NULL) return 0;
+    
+    return ((deflate_state *)(strm->state))->pending;
+}
+
+/* ===========================================================================
+ * Read a new buffer from the current input stream, update the adler32
+ * and total number of bytes read.  All deflate() input goes through
+ * this function so some applications may wish to modify it to avoid
+ * allocating a large strm->next_in buffer and copying from it.
+ * (See also flush_pending()).
+ */
+local int read_buf(strm, buf, size)
+    z_streamp strm;
+    charf *buf;
+    unsigned size;
+{
+    unsigned len = strm->avail_in;
+
+    if (len > size) len = size;
+    if (len == 0) return 0;
+
+    strm->avail_in  -= len;
+
+    if (!((deflate_state *)(strm->state))->noheader) {
+        strm->adler = adler32(strm->adler, strm->next_in, len);
+    }
+    zmemcpy(buf, strm->next_in, len);
+    strm->next_in  += len;
+    strm->total_in += len;
+
+    return (int)len;
+}
+
+/* ===========================================================================
+ * Initialize the "longest match" routines for a new zlib stream
+ */
+local void lm_init (s)
+    deflate_state *s;
+{
+    s->window_size = (ulg)2L*s->w_size;
+
+    CLEAR_HASH(s);
+
+    /* Set the default configuration parameters:
+     */
+    s->max_lazy_match   = configuration_table[s->level].max_lazy;
+    s->good_match       = configuration_table[s->level].good_length;
+    s->nice_match       = configuration_table[s->level].nice_length;
+    s->max_chain_length = configuration_table[s->level].max_chain;
+
+    s->strstart = 0;
+    s->block_start = 0L;
+    s->lookahead = 0;
+    s->match_length = s->prev_length = MIN_MATCH-1;
+    s->match_available = 0;
+    s->ins_h = 0;
+#ifdef ASMV
+    match_init(); /* initialize the asm code */
+#endif
+}
+
+/* ===========================================================================
+ * Set match_start to the longest match starting at the given string and
+ * return its length. Matches shorter or equal to prev_length are discarded,
+ * in which case the result is equal to prev_length and match_start is
+ * garbage.
+ * IN assertions: cur_match is the head of the hash chain for the current
+ *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
+ * OUT assertion: the match length is not greater than s->lookahead.
+ */
+#ifndef ASMV
+/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
+ * match.S. The code will be functionally equivalent.
+ */
+local uInt longest_match(s, cur_match)
+    deflate_state *s;
+    IPos cur_match;                             /* current match */
+{
+    unsigned chain_length = s->max_chain_length;/* max hash chain length */
+    register Bytef *scan = s->window + s->strstart; /* current string */
+    register Bytef *match;                       /* matched string */
+    register int len;                           /* length of current match */
+    int best_len = s->prev_length;              /* best match length so far */
+    int nice_match = s->nice_match;             /* stop if match long enough */
+    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
+        s->strstart - (IPos)MAX_DIST(s) : NIL;
+    /* Stop when cur_match becomes <= limit. To simplify the code,
+     * we prevent matches with the string of window index 0.
+     */
+    Posf *prev = s->prev;
+    uInt wmask = s->w_mask;
+
+#ifdef UNALIGNED_OK
+    /* Compare two bytes at a time. Note: this is not always beneficial.
+     * Try with and without -DUNALIGNED_OK to check.
+     */
+    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
+    register ush scan_start = *(ushf*)scan;
+    register ush scan_end   = *(ushf*)(scan+best_len-1);
+#else
+    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
+    register Byte scan_end1  = scan[best_len-1];
+    register Byte scan_end   = scan[best_len];
+#endif
+
+    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
+     * It is easy to get rid of this optimization if necessary.
+     */
+    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
+
+    /* Do not waste too much time if we already have a good match: */
+    if (s->prev_length >= s->good_match) {
+        chain_length >>= 2;
+    }
+    /* Do not look for matches beyond the end of the input. This is necessary
+     * to make deflate deterministic.
+     */
+    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
+
+    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
+
+    do {
+        Assert(cur_match < s->strstart, "no future");
+        match = s->window + cur_match;
+
+        /* Skip to next match if the match length cannot increase
+         * or if the match length is less than 2:
+         */
+#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
+        /* This code assumes sizeof(unsigned short) == 2. Do not use
+         * UNALIGNED_OK if your compiler uses a different size.
+         */
+        if (*(ushf*)(match+best_len-1) != scan_end ||
+            *(ushf*)match != scan_start) continue;
+
+        /* It is not necessary to compare scan[2] and match[2] since they are
+         * always equal when the other bytes match, given that the hash keys
+         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
+         * strstart+3, +5, ... up to strstart+257. We check for insufficient
+         * lookahead only every 4th comparison; the 128th check will be made
+         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
+         * necessary to put more guard bytes at the end of the window, or
+         * to check more often for insufficient lookahead.
+         */
+        Assert(scan[2] == match[2], "scan[2]?");
+        scan++, match++;
+        do {
+        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
+                 scan < strend);
+        /* The funny "do {}" generates better code on most compilers */
+
+        /* Here, scan <= window+strstart+257 */
+        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
+        if (*scan == *match) scan++;
+
+        len = (MAX_MATCH - 1) - (int)(strend-scan);
+        scan = strend - (MAX_MATCH-1);
+
+#else /* UNALIGNED_OK */
+
+        if (match[best_len]   != scan_end  ||
+            match[best_len-1] != scan_end1 ||
+            *match            != *scan     ||
+            *++match          != scan[1])      continue;
+
+        /* The check at best_len-1 can be removed because it will be made
+         * again later. (This heuristic is not always a win.)
+         * It is not necessary to compare scan[2] and match[2] since they
+         * are always equal when the other bytes match, given that
+         * the hash keys are equal and that HASH_BITS >= 8.
+         */
+        scan += 2, match++;
+        Assert(*scan == *match, "match[2]?");
+
+        /* We check for insufficient lookahead only every 8th comparison;
+         * the 256th check will be made at strstart+258.
+         */
+        do {
+        } while (*++scan == *++match && *++scan == *++match &&
+                 *++scan == *++match && *++scan == *++match &&
+                 *++scan == *++match && *++scan == *++match &&
+                 *++scan == *++match && *++scan == *++match &&
+                 scan < strend);
+
+        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
+
+        len = MAX_MATCH - (int)(strend - scan);
+        scan = strend - MAX_MATCH;
+
+#endif /* UNALIGNED_OK */
+
+        if (len > best_len) {
+            s->match_start = cur_match;
+            best_len = len;
+            if (len >= nice_match) break;
+#ifdef UNALIGNED_OK
+            scan_end = *(ushf*)(scan+best_len-1);
+#else
+            scan_end1  = scan[best_len-1];
+            scan_end   = scan[best_len];
+#endif
+        }
+    } while ((cur_match = prev[cur_match & wmask]) > limit
+             && --chain_length != 0);
+
+    if ((uInt)best_len <= s->lookahead) return best_len;
+    return s->lookahead;
+}
+#endif /* ASMV */
+
+#ifdef DEBUG_ZLIB
+/* ===========================================================================
+ * Check that the match at match_start is indeed a match.
+ */
+local void check_match(s, start, match, length)
+    deflate_state *s;
+    IPos start, match;
+    int length;
+{
+    /* check that the match is indeed a match */
+    if (zmemcmp((charf *)s->window + match,
+                (charf *)s->window + start, length) != EQUAL) {
+        fprintf(stderr, " start %u, match %u, length %d\n",
+		start, match, length);
+        do {
+	    fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
+	} while (--length != 0);
+        z_error("invalid match");
+    }
+    if (z_verbose > 1) {
+        fprintf(stderr,"\\[%d,%d]", start-match, length);
+        do { putc(s->window[start++], stderr); } while (--length != 0);
+    }
+}
+#else
+#  define check_match(s, start, match, length)
+#endif
+
+/* ===========================================================================
+ * Fill the window when the lookahead becomes insufficient.
+ * Updates strstart and lookahead.
+ *
+ * IN assertion: lookahead < MIN_LOOKAHEAD
+ * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
+ *    At least one byte has been read, or avail_in == 0; reads are
+ *    performed for at least two bytes (required for the zip translate_eol
+ *    option -- not supported here).
+ */
+local void fill_window(s)
+    deflate_state *s;
+{
+    register unsigned n, m;
+    register Posf *p;
+    unsigned more;    /* Amount of free space at the end of the window. */
+    uInt wsize = s->w_size;
+
+    do {
+        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
+
+        /* Deal with !@#$% 64K limit: */
+        if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
+            more = wsize;
+
+        } else if (more == (unsigned)(-1)) {
+            /* Very unlikely, but possible on 16 bit machine if strstart == 0
+             * and lookahead == 1 (input done one byte at time)
+             */
+            more--;
+
+        /* If the window is almost full and there is insufficient lookahead,
+         * move the upper half to the lower one to make room in the upper half.
+         */
+        } else if (s->strstart >= wsize+MAX_DIST(s)) {
+
+            zmemcpy((charf *)s->window, (charf *)s->window+wsize,
+                   (unsigned)wsize);
+            s->match_start -= wsize;
+            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
+            s->block_start -= (long) wsize;
+
+            /* Slide the hash table (could be avoided with 32 bit values
+               at the expense of memory usage). We slide even when level == 0
+               to keep the hash table consistent if we switch back to level > 0
+               later. (Using level 0 permanently is not an optimal usage of
+               zlib, so we don't care about this pathological case.)
+             */
+            n = s->hash_size;
+            p = &s->head[n];
+            do {
+                m = *--p;
+                *p = (Pos)(m >= wsize ? m-wsize : NIL);
+            } while (--n);
+
+            n = wsize;
+            p = &s->prev[n];
+            do {
+                m = *--p;
+                *p = (Pos)(m >= wsize ? m-wsize : NIL);
+                /* If n is not on any hash chain, prev[n] is garbage but
+                 * its value will never be used.
+                 */
+            } while (--n);
+            more += wsize;
+        }
+        if (s->strm->avail_in == 0) return;
+
+        /* If there was no sliding:
+         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
+         *    more == window_size - lookahead - strstart
+         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
+         * => more >= window_size - 2*WSIZE + 2
+         * In the BIG_MEM or MMAP case (not yet supported),
+         *   window_size == input_size + MIN_LOOKAHEAD  &&
+         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
+         * Otherwise, window_size == 2*WSIZE so more >= 2.
+         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
+         */
+        Assert(more >= 2, "more < 2");
+
+        n = read_buf(s->strm, (charf *)s->window + s->strstart + s->lookahead,
+                     more);
+        s->lookahead += n;
+
+        /* Initialize the hash value now that we have some input: */
+        if (s->lookahead >= MIN_MATCH) {
+            s->ins_h = s->window[s->strstart];
+            UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
+#if MIN_MATCH != 3
+            Call UPDATE_HASH() MIN_MATCH-3 more times
+#endif
+        }
+        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
+         * but this is not important since only literal bytes will be emitted.
+         */
+
+    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
+}
+
+/* ===========================================================================
+ * Flush the current block, with given end-of-file flag.
+ * IN assertion: strstart is set to the end of the current match.
+ */
+#define FLUSH_BLOCK_ONLY(s, eof) { \
+   _tr_flush_block(s, (s->block_start >= 0L ? \
+                   (charf *)&s->window[(unsigned)s->block_start] : \
+                   (charf *)Z_NULL), \
+		(ulg)((long)s->strstart - s->block_start), \
+		(eof)); \
+   s->block_start = s->strstart; \
+   flush_pending(s->strm); \
+   Tracev((stderr,"[FLUSH]")); \
+}
+
+/* Same but force premature exit if necessary. */
+#define FLUSH_BLOCK(s, eof) { \
+   FLUSH_BLOCK_ONLY(s, eof); \
+   if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \
+}
+
+/* ===========================================================================
+ * Copy without compression as much as possible from the input stream, return
+ * the current block state.
+ * This function does not insert new strings in the dictionary since
+ * uncompressible data is probably not useful. This function is used
+ * only for the level=0 compression option.
+ * NOTE: this function should be optimized to avoid extra copying from
+ * window to pending_buf.
+ */
+local block_state deflate_stored(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
+     * to pending_buf_size, and each stored block has a 5 byte header:
+     */
+    ulg max_block_size = 0xffff;
+    ulg max_start;
+
+    if (max_block_size > s->pending_buf_size - 5) {
+        max_block_size = s->pending_buf_size - 5;
+    }
+
+    /* Copy as much as possible from input to output: */
+    for (;;) {
+        /* Fill the window as much as possible: */
+        if (s->lookahead <= 1) {
+
+            Assert(s->strstart < s->w_size+MAX_DIST(s) ||
+		   s->block_start >= (long)s->w_size, "slide too late");
+
+            fill_window(s);
+            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;
+
+            if (s->lookahead == 0) break; /* flush the current block */
+        }
+	Assert(s->block_start >= 0L, "block gone");
+
+	s->strstart += s->lookahead;
+	s->lookahead = 0;
+
+	/* Emit a stored block if pending_buf will be full: */
+ 	max_start = s->block_start + max_block_size;
+        if (s->strstart == 0 || (ulg)s->strstart >= max_start) {
+	    /* strstart == 0 is possible when wraparound on 16-bit machine */
+	    s->lookahead = (uInt)(s->strstart - max_start);
+	    s->strstart = (uInt)max_start;
+            FLUSH_BLOCK(s, 0);
+	}
+	/* Flush if we may have to slide, otherwise block_start may become
+         * negative and the data will be gone:
+         */
+        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
+            FLUSH_BLOCK(s, 0);
+	}
+    }
+    FLUSH_BLOCK(s, flush == Z_FINISH);
+    return flush == Z_FINISH ? finish_done : block_done;
+}
+
+/* ===========================================================================
+ * Compress as much as possible from the input stream, return the current
+ * block state.
+ * This function does not perform lazy evaluation of matches and inserts
+ * new strings in the dictionary only for unmatched strings or for short
+ * matches. It is used only for the fast compression options.
+ */
+local block_state deflate_fast(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    IPos hash_head = NIL; /* head of the hash chain */
+    int bflush;           /* set if current block must be flushed */
+
+    for (;;) {
+        /* Make sure that we always have enough lookahead, except
+         * at the end of the input file. We need MAX_MATCH bytes
+         * for the next match, plus MIN_MATCH bytes to insert the
+         * string following the next match.
+         */
+        if (s->lookahead < MIN_LOOKAHEAD) {
+            fill_window(s);
+            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
+	        return need_more;
+	    }
+            if (s->lookahead == 0) break; /* flush the current block */
+        }
+
+        /* Insert the string window[strstart .. strstart+2] in the
+         * dictionary, and set hash_head to the head of the hash chain:
+         */
+        if (s->lookahead >= MIN_MATCH) {
+            INSERT_STRING(s, s->strstart, hash_head);
+        }
+
+        /* Find the longest match, discarding those <= prev_length.
+         * At this point we have always match_length < MIN_MATCH
+         */
+        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
+            /* To simplify the code, we prevent matches with the string
+             * of window index 0 (in particular we have to avoid a match
+             * of the string with itself at the start of the input file).
+             */
+            if (s->strategy != Z_HUFFMAN_ONLY) {
+                s->match_length = longest_match (s, hash_head);
+            }
+            /* longest_match() sets match_start */
+        }
+        if (s->match_length >= MIN_MATCH) {
+            check_match(s, s->strstart, s->match_start, s->match_length);
+
+            bflush = _tr_tally(s, s->strstart - s->match_start,
+                               s->match_length - MIN_MATCH);
+
+            s->lookahead -= s->match_length;
+
+            /* Insert new strings in the hash table only if the match length
+             * is not too large. This saves time but degrades compression.
+             */
+            if (s->match_length <= s->max_insert_length &&
+                s->lookahead >= MIN_MATCH) {
+                s->match_length--; /* string at strstart already in hash table */
+                do {
+                    s->strstart++;
+                    INSERT_STRING(s, s->strstart, hash_head);
+                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
+                     * always MIN_MATCH bytes ahead.
+                     */
+                } while (--s->match_length != 0);
+                s->strstart++; 
+            } else {
+                s->strstart += s->match_length;
+                s->match_length = 0;
+                s->ins_h = s->window[s->strstart];
+                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
+#if MIN_MATCH != 3
+                Call UPDATE_HASH() MIN_MATCH-3 more times
+#endif
+                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
+                 * matter since it will be recomputed at next deflate call.
+                 */
+            }
+        } else {
+            /* No match, output a literal byte */
+            Tracevv((stderr,"%c", s->window[s->strstart]));
+            bflush = _tr_tally (s, 0, s->window[s->strstart]);
+            s->lookahead--;
+            s->strstart++; 
+        }
+        if (bflush) FLUSH_BLOCK(s, 0);
+    }
+    FLUSH_BLOCK(s, flush == Z_FINISH);
+    return flush == Z_FINISH ? finish_done : block_done;
+}
+
+/* ===========================================================================
+ * Same as above, but achieves better compression. We use a lazy
+ * evaluation for matches: a match is finally adopted only if there is
+ * no better match at the next window position.
+ */
+local block_state deflate_slow(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    IPos hash_head = NIL;    /* head of hash chain */
+    int bflush;              /* set if current block must be flushed */
+
+    /* Process the input block. */
+    for (;;) {
+        /* Make sure that we always have enough lookahead, except
+         * at the end of the input file. We need MAX_MATCH bytes
+         * for the next match, plus MIN_MATCH bytes to insert the
+         * string following the next match.
+         */
+        if (s->lookahead < MIN_LOOKAHEAD) {
+            fill_window(s);
+            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
+	        return need_more;
+	    }
+            if (s->lookahead == 0) break; /* flush the current block */
+        }
+
+        /* Insert the string window[strstart .. strstart+2] in the
+         * dictionary, and set hash_head to the head of the hash chain:
+         */
+        if (s->lookahead >= MIN_MATCH) {
+            INSERT_STRING(s, s->strstart, hash_head);
+        }
+
+        /* Find the longest match, discarding those <= prev_length.
+         */
+        s->prev_length = s->match_length, s->prev_match = s->match_start;
+        s->match_length = MIN_MATCH-1;
+
+        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
+            s->strstart - hash_head <= MAX_DIST(s)) {
+            /* To simplify the code, we prevent matches with the string
+             * of window index 0 (in particular we have to avoid a match
+             * of the string with itself at the start of the input file).
+             */
+            if (s->strategy != Z_HUFFMAN_ONLY) {
+                s->match_length = longest_match (s, hash_head);
+            }
+            /* longest_match() sets match_start */
+
+            if (s->match_length <= 5 && (s->strategy == Z_FILTERED ||
+                 (s->match_length == MIN_MATCH &&
+                  s->strstart - s->match_start > TOO_FAR))) {
+
+                /* If prev_match is also MIN_MATCH, match_start is garbage
+                 * but we will ignore the current match anyway.
+                 */
+                s->match_length = MIN_MATCH-1;
+            }
+        }
+        /* If there was a match at the previous step and the current
+         * match is not better, output the previous match:
+         */
+        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
+            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
+            /* Do not insert strings in hash table beyond this. */
+
+            check_match(s, s->strstart-1, s->prev_match, s->prev_length);
+
+            bflush = _tr_tally(s, s->strstart -1 - s->prev_match,
+                               s->prev_length - MIN_MATCH);
+
+            /* Insert in hash table all strings up to the end of the match.
+             * strstart-1 and strstart are already inserted. If there is not
+             * enough lookahead, the last two strings are not inserted in
+             * the hash table.
+             */
+            s->lookahead -= s->prev_length-1;
+            s->prev_length -= 2;
+            do {
+                if (++s->strstart <= max_insert) {
+                    INSERT_STRING(s, s->strstart, hash_head);
+                }
+            } while (--s->prev_length != 0);
+            s->match_available = 0;
+            s->match_length = MIN_MATCH-1;
+            s->strstart++;
+
+            if (bflush) FLUSH_BLOCK(s, 0);
+
+        } else if (s->match_available) {
+            /* If there was no match at the previous position, output a
+             * single literal. If there was a match but the current match
+             * is longer, truncate the previous match to a single literal.
+             */
+            Tracevv((stderr,"%c", s->window[s->strstart-1]));
+            if (_tr_tally (s, 0, s->window[s->strstart-1])) {
+                FLUSH_BLOCK_ONLY(s, 0);
+            }
+            s->strstart++;
+            s->lookahead--;
+            if (s->strm->avail_out == 0) return need_more;
+        } else {
+            /* There is no previous match to compare with, wait for
+             * the next step to decide.
+             */
+            s->match_available = 1;
+            s->strstart++;
+            s->lookahead--;
+        }
+    }
+    Assert (flush != Z_NO_FLUSH, "no flush?");
+    if (s->match_available) {
+        Tracevv((stderr,"%c", s->window[s->strstart-1]));
+        _tr_tally (s, 0, s->window[s->strstart-1]);
+        s->match_available = 0;
+    }
+    FLUSH_BLOCK(s, flush == Z_FINISH);
+    return flush == Z_FINISH ? finish_done : block_done;
+}
+/* --- deflate.c */
+
+/* +++ trees.c */
+/* trees.c -- output deflated data using Huffman coding
+ * Copyright (C) 1995-1996 Jean-loup Gailly
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/*
+ *  ALGORITHM
+ *
+ *      The "deflation" process uses several Huffman trees. The more
+ *      common source values are represented by shorter bit sequences.
+ *
+ *      Each code tree is stored in a compressed form which is itself
+ * a Huffman encoding of the lengths of all the code strings (in
+ * ascending order by source values).  The actual code strings are
+ * reconstructed from the lengths in the inflate process, as described
+ * in the deflate specification.
+ *
+ *  REFERENCES
+ *
+ *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
+ *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
+ *
+ *      Storer, James A.
+ *          Data Compression:  Methods and Theory, pp. 49-50.
+ *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
+ *
+ *      Sedgewick, R.
+ *          Algorithms, p290.
+ *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
+ */
+
+/* From: trees.c,v 1.11 1996/07/24 13:41:06 me Exp $ */
+
+/* #include "deflate.h" */
+
+#ifdef DEBUG_ZLIB
+#  include <ctype.h>
+#endif
+
+/* ===========================================================================
+ * Constants
+ */
+
+#define MAX_BL_BITS 7
+/* Bit length codes must not exceed MAX_BL_BITS bits */
+
+#define END_BLOCK 256
+/* end of block literal code */
+
+#define REP_3_6      16
+/* repeat previous bit length 3-6 times (2 bits of repeat count) */
+
+#define REPZ_3_10    17
+/* repeat a zero length 3-10 times  (3 bits of repeat count) */
+
+#define REPZ_11_138  18
+/* repeat a zero length 11-138 times  (7 bits of repeat count) */
+
+local int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
+   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
+
+local int extra_dbits[D_CODES] /* extra bits for each distance code */
+   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
+
+local int extra_blbits[BL_CODES]/* extra bits for each bit length code */
+   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
+
+local uch bl_order[BL_CODES]
+   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
+/* The lengths of the bit length codes are sent in order of decreasing
+ * probability, to avoid transmitting the lengths for unused bit length codes.
+ */
+
+#define Buf_size (8 * 2*sizeof(char))
+/* Number of bits used within bi_buf. (bi_buf might be implemented on
+ * more than 16 bits on some systems.)
+ */
+
+/* ===========================================================================
+ * Local data. These are initialized only once.
+ */
+
+local ct_data static_ltree[L_CODES+2];
+/* The static literal tree. Since the bit lengths are imposed, there is no
+ * need for the L_CODES extra codes used during heap construction. However
+ * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
+ * below).
+ */
+
+local ct_data static_dtree[D_CODES];
+/* The static distance tree. (Actually a trivial tree since all codes use
+ * 5 bits.)
+ */
+
+local uch dist_code[512];
+/* distance codes. The first 256 values correspond to the distances
+ * 3 .. 258, the last 256 values correspond to the top 8 bits of
+ * the 15 bit distances.
+ */
+
+local uch length_code[MAX_MATCH-MIN_MATCH+1];
+/* length code for each normalized match length (0 == MIN_MATCH) */
+
+local int base_length[LENGTH_CODES];
+/* First normalized length for each code (0 = MIN_MATCH) */
+
+local int base_dist[D_CODES];
+/* First normalized distance for each code (0 = distance of 1) */
+
+struct static_tree_desc_s {
+    ct_data *static_tree;        /* static tree or NULL */
+    intf    *extra_bits;         /* extra bits for each code or NULL */
+    int     extra_base;          /* base index for extra_bits */
+    int     elems;               /* max number of elements in the tree */
+    int     max_length;          /* max bit length for the codes */
+};
+
+local static_tree_desc  static_l_desc =
+{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
+
+local static_tree_desc  static_d_desc =
+{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
+
+local static_tree_desc  static_bl_desc =
+{(ct_data *)0, extra_blbits, 0,      BL_CODES, MAX_BL_BITS};
+
+/* ===========================================================================
+ * Local (static) routines in this file.
+ */
+
+local void tr_static_init OF((void));
+local void init_block     OF((deflate_state *s));
+local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
+local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
+local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
+local void build_tree     OF((deflate_state *s, tree_desc *desc));
+local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
+local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
+local int  build_bl_tree  OF((deflate_state *s));
+local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
+                              int blcodes));
+local void compress_block OF((deflate_state *s, ct_data *ltree,
+                              ct_data *dtree));
+local void set_data_type  OF((deflate_state *s));
+local unsigned bi_reverse OF((unsigned value, int length));
+local void bi_windup      OF((deflate_state *s));
+local void bi_flush       OF((deflate_state *s));
+local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
+                              int header));
+
+#ifndef DEBUG_ZLIB
+#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
+   /* Send a code of the given tree. c and tree must not have side effects */
+
+#else /* DEBUG_ZLIB */
+#  define send_code(s, c, tree) \
+     { if (verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
+       send_bits(s, tree[c].Code, tree[c].Len); }
+#endif
+
+#define d_code(dist) \
+   ((dist) < 256 ? dist_code[dist] : dist_code[256+((dist)>>7)])
+/* Mapping from a distance to a distance code. dist is the distance - 1 and
+ * must not have side effects. dist_code[256] and dist_code[257] are never
+ * used.
+ */
+
+/* ===========================================================================
+ * Output a short LSB first on the stream.
+ * IN assertion: there is enough room in pendingBuf.
+ */
+#define put_short(s, w) { \
+    put_byte(s, (uch)((w) & 0xff)); \
+    put_byte(s, (uch)((ush)(w) >> 8)); \
+}
+
+/* ===========================================================================
+ * Send a value on a given number of bits.
+ * IN assertion: length <= 16 and value fits in length bits.
+ */
+#ifdef DEBUG_ZLIB
+local void send_bits      OF((deflate_state *s, int value, int length));
+
+local void send_bits(s, value, length)
+    deflate_state *s;
+    int value;  /* value to send */
+    int length; /* number of bits */
+{
+    Tracevv((stderr," l %2d v %4x ", length, value));
+    Assert(length > 0 && length <= 15, "invalid length");
+    s->bits_sent += (ulg)length;
+
+    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
+     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
+     * unused bits in value.
+     */
+    if (s->bi_valid > (int)Buf_size - length) {
+        s->bi_buf |= (value << s->bi_valid);
+        put_short(s, s->bi_buf);
+        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
+        s->bi_valid += length - Buf_size;
+    } else {
+        s->bi_buf |= value << s->bi_valid;
+        s->bi_valid += length;
+    }
+}
+#else /* !DEBUG_ZLIB */
+
+#define send_bits(s, value, length) \
+{ int len = length;\
+  if (s->bi_valid > (int)Buf_size - len) {\
+    int val = value;\
+    s->bi_buf |= (val << s->bi_valid);\
+    put_short(s, s->bi_buf);\
+    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
+    s->bi_valid += len - Buf_size;\
+  } else {\
+    s->bi_buf |= (value) << s->bi_valid;\
+    s->bi_valid += len;\
+  }\
+}
+#endif /* DEBUG_ZLIB */
+
+
+#define MAX(a,b) (a >= b ? a : b)
+/* the arguments must not have side effects */
+
+/* ===========================================================================
+ * Initialize the various 'constant' tables. In a multi-threaded environment,
+ * this function may be called by two threads concurrently, but this is
+ * harmless since both invocations do exactly the same thing.
+ */
+local void tr_static_init()
+{
+    static int static_init_done = 0;
+    int n;        /* iterates over tree elements */
+    int bits;     /* bit counter */
+    int length;   /* length value */
+    int code;     /* code value */
+    int dist;     /* distance index */
+    ush bl_count[MAX_BITS+1];
+    /* number of codes at each bit length for an optimal tree */
+
+    if (static_init_done) return;
+
+    /* Initialize the mapping length (0..255) -> length code (0..28) */
+    length = 0;
+    for (code = 0; code < LENGTH_CODES-1; code++) {
+        base_length[code] = length;
+        for (n = 0; n < (1<<extra_lbits[code]); n++) {
+            length_code[length++] = (uch)code;
+        }
+    }
+    Assert (length == 256, "tr_static_init: length != 256");
+    /* Note that the length 255 (match length 258) can be represented
+     * in two different ways: code 284 + 5 bits or code 285, so we
+     * overwrite length_code[255] to use the best encoding:
+     */
+    length_code[length-1] = (uch)code;
+
+    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
+    dist = 0;
+    for (code = 0 ; code < 16; code++) {
+        base_dist[code] = dist;
+        for (n = 0; n < (1<<extra_dbits[code]); n++) {
+            dist_code[dist++] = (uch)code;
+        }
+    }
+    Assert (dist == 256, "tr_static_init: dist != 256");
+    dist >>= 7; /* from now on, all distances are divided by 128 */
+    for ( ; code < D_CODES; code++) {
+        base_dist[code] = dist << 7;
+        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
+            dist_code[256 + dist++] = (uch)code;
+        }
+    }
+    Assert (dist == 256, "tr_static_init: 256+dist != 512");
+
+    /* Construct the codes of the static literal tree */
+    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
+    n = 0;
+    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
+    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
+    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
+    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
+    /* Codes 286 and 287 do not exist, but we must include them in the
+     * tree construction to get a canonical Huffman tree (longest code
+     * all ones)
+     */
+    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
+
+    /* The static distance tree is trivial: */
+    for (n = 0; n < D_CODES; n++) {
+        static_dtree[n].Len = 5;
+        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
+    }
+    static_init_done = 1;
+}
+
+/* ===========================================================================
+ * Initialize the tree data structures for a new zlib stream.
+ */
+void _tr_init(s)
+    deflate_state *s;
+{
+    tr_static_init();
+
+    s->compressed_len = 0L;
+
+    s->l_desc.dyn_tree = s->dyn_ltree;
+    s->l_desc.stat_desc = &static_l_desc;
+
+    s->d_desc.dyn_tree = s->dyn_dtree;
+    s->d_desc.stat_desc = &static_d_desc;
+
+    s->bl_desc.dyn_tree = s->bl_tree;
+    s->bl_desc.stat_desc = &static_bl_desc;
+
+    s->bi_buf = 0;
+    s->bi_valid = 0;
+    s->last_eob_len = 8; /* enough lookahead for inflate */
+#ifdef DEBUG_ZLIB
+    s->bits_sent = 0L;
+#endif
+
+    /* Initialize the first block of the first file: */
+    init_block(s);
+}
+
+/* ===========================================================================
+ * Initialize a new block.
+ */
+local void init_block(s)
+    deflate_state *s;
+{
+    int n; /* iterates over tree elements */
+
+    /* Initialize the trees. */
+    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
+    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
+    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;
+
+    s->dyn_ltree[END_BLOCK].Freq = 1;
+    s->opt_len = s->static_len = 0L;
+    s->last_lit = s->matches = 0;
+}
+
+#define SMALLEST 1
+/* Index within the heap array of least frequent node in the Huffman tree */
+
+
+/* ===========================================================================
+ * Remove the smallest element from the heap and recreate the heap with
+ * one less element. Updates heap and heap_len.
+ */
+#define pqremove(s, tree, top) \
+{\
+    top = s->heap[SMALLEST]; \
+    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
+    pqdownheap(s, tree, SMALLEST); \
+}
+
+/* ===========================================================================
+ * Compares to subtrees, using the tree depth as tie breaker when
+ * the subtrees have equal frequency. This minimizes the worst case length.
+ */
+#define smaller(tree, n, m, depth) \
+   (tree[n].Freq < tree[m].Freq || \
+   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
+
+/* ===========================================================================
+ * Restore the heap property by moving down the tree starting at node k,
+ * exchanging a node with the smallest of its two sons if necessary, stopping
+ * when the heap property is re-established (each father smaller than its
+ * two sons).
+ */
+local void pqdownheap(s, tree, k)
+    deflate_state *s;
+    ct_data *tree;  /* the tree to restore */
+    int k;               /* node to move down */
+{
+    int v = s->heap[k];
+    int j = k << 1;  /* left son of k */
+    while (j <= s->heap_len) {
+        /* Set j to the smallest of the two sons: */
+        if (j < s->heap_len &&
+            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
+            j++;
+        }
+        /* Exit if v is smaller than both sons */
+        if (smaller(tree, v, s->heap[j], s->depth)) break;
+
+        /* Exchange v with the smallest son */
+        s->heap[k] = s->heap[j];  k = j;
+
+        /* And continue down the tree, setting j to the left son of k */
+        j <<= 1;
+    }
+    s->heap[k] = v;
+}
+
+/* ===========================================================================
+ * Compute the optimal bit lengths for a tree and update the total bit length
+ * for the current block.
+ * IN assertion: the fields freq and dad are set, heap[heap_max] and
+ *    above are the tree nodes sorted by increasing frequency.
+ * OUT assertions: the field len is set to the optimal bit length, the
+ *     array bl_count contains the frequencies for each bit length.
+ *     The length opt_len is updated; static_len is also updated if stree is
+ *     not null.
+ */
+local void gen_bitlen(s, desc)
+    deflate_state *s;
+    tree_desc *desc;    /* the tree descriptor */
+{
+    ct_data *tree  = desc->dyn_tree;
+    int max_code   = desc->max_code;
+    ct_data *stree = desc->stat_desc->static_tree;
+    intf *extra    = desc->stat_desc->extra_bits;
+    int base       = desc->stat_desc->extra_base;
+    int max_length = desc->stat_desc->max_length;
+    int h;              /* heap index */
+    int n, m;           /* iterate over the tree elements */
+    int bits;           /* bit length */
+    int xbits;          /* extra bits */
+    ush f;              /* frequency */
+    int overflow = 0;   /* number of elements with bit length too large */
+
+    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
+
+    /* In a first pass, compute the optimal bit lengths (which may
+     * overflow in the case of the bit length tree).
+     */
+    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */
+
+    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
+        n = s->heap[h];
+        bits = tree[tree[n].Dad].Len + 1;
+        if (bits > max_length) bits = max_length, overflow++;
+        tree[n].Len = (ush)bits;
+        /* We overwrite tree[n].Dad which is no longer needed */
+
+        if (n > max_code) continue; /* not a leaf node */
+
+        s->bl_count[bits]++;
+        xbits = 0;
+        if (n >= base) xbits = extra[n-base];
+        f = tree[n].Freq;
+        s->opt_len += (ulg)f * (bits + xbits);
+        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
+    }
+    if (overflow == 0) return;
+
+    Trace((stderr,"\nbit length overflow\n"));
+    /* This happens for example on obj2 and pic of the Calgary corpus */
+
+    /* Find the first bit length which could increase: */
+    do {
+        bits = max_length-1;
+        while (s->bl_count[bits] == 0) bits--;
+        s->bl_count[bits]--;      /* move one leaf down the tree */
+        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
+        s->bl_count[max_length]--;
+        /* The brother of the overflow item also moves one step up,
+         * but this does not affect bl_count[max_length]
+         */
+        overflow -= 2;
+    } while (overflow > 0);
+
+    /* Now recompute all bit lengths, scanning in increasing frequency.
+     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
+     * lengths instead of fixing only the wrong ones. This idea is taken
+     * from 'ar' written by Haruhiko Okumura.)
+     */
+    for (bits = max_length; bits != 0; bits--) {
+        n = s->bl_count[bits];
+        while (n != 0) {
+            m = s->heap[--h];
+            if (m > max_code) continue;
+            if (tree[m].Len != (unsigned) bits) {
+                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
+                s->opt_len += ((long)bits - (long)tree[m].Len)
+                              *(long)tree[m].Freq;
+                tree[m].Len = (ush)bits;
+            }
+            n--;
+        }
+    }
+}
+
+/* ===========================================================================
+ * Generate the codes for a given tree and bit counts (which need not be
+ * optimal).
+ * IN assertion: the array bl_count contains the bit length statistics for
+ * the given tree and the field len is set for all tree elements.
+ * OUT assertion: the field code is set for all tree elements of non
+ *     zero code length.
+ */
+local void gen_codes (tree, max_code, bl_count)
+    ct_data *tree;             /* the tree to decorate */
+    int max_code;              /* largest code with non zero frequency */
+    ushf *bl_count;            /* number of codes at each bit length */
+{
+    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
+    ush code = 0;              /* running code value */
+    int bits;                  /* bit index */
+    int n;                     /* code index */
+
+    /* The distribution counts are first used to generate the code values
+     * without bit reversal.
+     */
+    for (bits = 1; bits <= MAX_BITS; bits++) {
+        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
+    }
+    /* Check that the bit counts in bl_count are consistent. The last code
+     * must be all ones.
+     */
+    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
+            "inconsistent bit counts");
+    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
+
+    for (n = 0;  n <= max_code; n++) {
+        int len = tree[n].Len;
+        if (len == 0) continue;
+        /* Now reverse the bits */
+        tree[n].Code = bi_reverse(next_code[len]++, len);
+
+        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
+             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
+    }
+}
+
+/* ===========================================================================
+ * Construct one Huffman tree and assigns the code bit strings and lengths.
+ * Update the total bit length for the current block.
+ * IN assertion: the field freq is set for all tree elements.
+ * OUT assertions: the fields len and code are set to the optimal bit length
+ *     and corresponding code. The length opt_len is updated; static_len is
+ *     also updated if stree is not null. The field max_code is set.
+ */
+local void build_tree(s, desc)
+    deflate_state *s;
+    tree_desc *desc; /* the tree descriptor */
+{
+    ct_data *tree   = desc->dyn_tree;
+    ct_data *stree  = desc->stat_desc->static_tree;
+    int elems       = desc->stat_desc->elems;
+    int n, m;          /* iterate over heap elements */
+    int max_code = -1; /* largest code with non zero frequency */
+    int node;          /* new node being created */
+
+    /* Construct the initial heap, with least frequent element in
+     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
+     * heap[0] is not used.
+     */
+    s->heap_len = 0, s->heap_max = HEAP_SIZE;
+
+    for (n = 0; n < elems; n++) {
+        if (tree[n].Freq != 0) {
+            s->heap[++(s->heap_len)] = max_code = n;
+            s->depth[n] = 0;
+        } else {
+            tree[n].Len = 0;
+        }
+    }
+
+    /* The pkzip format requires that at least one distance code exists,
+     * and that at least one bit should be sent even if there is only one
+     * possible code. So to avoid special checks later on we force at least
+     * two codes of non zero frequency.
+     */
+    while (s->heap_len < 2) {
+        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
+        tree[node].Freq = 1;
+        s->depth[node] = 0;
+        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
+        /* node is 0 or 1 so it does not have extra bits */
+    }
+    desc->max_code = max_code;
+
+    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
+     * establish sub-heaps of increasing lengths:
+     */
+    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);
+
+    /* Construct the Huffman tree by repeatedly combining the least two
+     * frequent nodes.
+     */
+    node = elems;              /* next internal node of the tree */
+    do {
+        pqremove(s, tree, n);  /* n = node of least frequency */
+        m = s->heap[SMALLEST]; /* m = node of next least frequency */
+
+        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
+        s->heap[--(s->heap_max)] = m;
+
+        /* Create a new node father of n and m */
+        tree[node].Freq = tree[n].Freq + tree[m].Freq;
+        s->depth[node] = (uch) (MAX(s->depth[n], s->depth[m]) + 1);
+        tree[n].Dad = tree[m].Dad = (ush)node;
+#ifdef DUMP_BL_TREE
+        if (tree == s->bl_tree) {
+            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
+                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
+        }
+#endif
+        /* and insert the new node in the heap */
+        s->heap[SMALLEST] = node++;
+        pqdownheap(s, tree, SMALLEST);
+
+    } while (s->heap_len >= 2);
+
+    s->heap[--(s->heap_max)] = s->heap[SMALLEST];
+
+    /* At this point, the fields freq and dad are set. We can now
+     * generate the bit lengths.
+     */
+    gen_bitlen(s, (tree_desc *)desc);
+
+    /* The field len is now set, we can generate the bit codes */
+    gen_codes ((ct_data *)tree, max_code, s->bl_count);
+}
+
+/* ===========================================================================
+ * Scan a literal or distance tree to determine the frequencies of the codes
+ * in the bit length tree.
+ */
+local void scan_tree (s, tree, max_code)
+    deflate_state *s;
+    ct_data *tree;   /* the tree to be scanned */
+    int max_code;    /* and its largest code of non zero frequency */
+{
+    int n;                     /* iterates over all tree elements */
+    int prevlen = -1;          /* last emitted length */
+    int curlen;                /* length of current code */
+    int nextlen = tree[0].Len; /* length of next code */
+    int count = 0;             /* repeat count of the current code */
+    int max_count = 7;         /* max repeat count */
+    int min_count = 4;         /* min repeat count */
+
+    if (nextlen == 0) max_count = 138, min_count = 3;
+    tree[max_code+1].Len = (ush)0xffff; /* guard */
+
+    for (n = 0; n <= max_code; n++) {
+        curlen = nextlen; nextlen = tree[n+1].Len;
+        if (++count < max_count && curlen == nextlen) {
+            continue;
+        } else if (count < min_count) {
+            s->bl_tree[curlen].Freq += count;
+        } else if (curlen != 0) {
+            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
+            s->bl_tree[REP_3_6].Freq++;
+        } else if (count <= 10) {
+            s->bl_tree[REPZ_3_10].Freq++;
+        } else {
+            s->bl_tree[REPZ_11_138].Freq++;
+        }
+        count = 0; prevlen = curlen;
+        if (nextlen == 0) {
+            max_count = 138, min_count = 3;
+        } else if (curlen == nextlen) {
+            max_count = 6, min_count = 3;
+        } else {
+            max_count = 7, min_count = 4;
+        }
+    }
+}
+
+/* ===========================================================================
+ * Send a literal or distance tree in compressed form, using the codes in
+ * bl_tree.
+ */
+local void send_tree (s, tree, max_code)
+    deflate_state *s;
+    ct_data *tree; /* the tree to be scanned */
+    int max_code;       /* and its largest code of non zero frequency */
+{
+    int n;                     /* iterates over all tree elements */
+    int prevlen = -1;          /* last emitted length */
+    int curlen;                /* length of current code */
+    int nextlen = tree[0].Len; /* length of next code */
+    int count = 0;             /* repeat count of the current code */
+    int max_count = 7;         /* max repeat count */
+    int min_count = 4;         /* min repeat count */
+
+    /* tree[max_code+1].Len = -1; */  /* guard already set */
+    if (nextlen == 0) max_count = 138, min_count = 3;
+
+    for (n = 0; n <= max_code; n++) {
+        curlen = nextlen; nextlen = tree[n+1].Len;
+        if (++count < max_count && curlen == nextlen) {
+            continue;
+        } else if (count < min_count) {
+            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);
+
+        } else if (curlen != 0) {
+            if (curlen != prevlen) {
+                send_code(s, curlen, s->bl_tree); count--;
+            }
+            Assert(count >= 3 && count <= 6, " 3_6?");
+            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);
+
+        } else if (count <= 10) {
+            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);
+
+        } else {
+            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
+        }
+        count = 0; prevlen = curlen;
+        if (nextlen == 0) {
+            max_count = 138, min_count = 3;
+        } else if (curlen == nextlen) {
+            max_count = 6, min_count = 3;
+        } else {
+            max_count = 7, min_count = 4;
+        }
+    }
+}
+
+/* ===========================================================================
+ * Construct the Huffman tree for the bit lengths and return the index in
+ * bl_order of the last bit length code to send.
+ */
+local int build_bl_tree(s)
+    deflate_state *s;
+{
+    int max_blindex;  /* index of last bit length code of non zero freq */
+
+    /* Determine the bit length frequencies for literal and distance trees */
+    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
+    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);
+
+    /* Build the bit length tree: */
+    build_tree(s, (tree_desc *)(&(s->bl_desc)));
+    /* opt_len now includes the length of the tree representations, except
+     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
+     */
+
+    /* Determine the number of bit length codes to send. The pkzip format
+     * requires that at least 4 bit length codes be sent. (appnote.txt says
+     * 3 but the actual value used is 4.)
+     */
+    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
+        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
+    }
+    /* Update opt_len to include the bit length tree and counts */
+    s->opt_len += 3*(max_blindex+1) + 5+5+4;
+    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
+            s->opt_len, s->static_len));
+
+    return max_blindex;
+}
+
+/* ===========================================================================
+ * Send the header for a block using dynamic Huffman trees: the counts, the
+ * lengths of the bit length codes, the literal tree and the distance tree.
+ * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
+ */
+local void send_all_trees(s, lcodes, dcodes, blcodes)
+    deflate_state *s;
+    int lcodes, dcodes, blcodes; /* number of codes for each tree */
+{
+    int rank;                    /* index in bl_order */
+
+    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
+    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
+            "too many codes");
+    Tracev((stderr, "\nbl counts: "));
+    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
+    send_bits(s, dcodes-1,   5);
+    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
+    for (rank = 0; rank < blcodes; rank++) {
+        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
+        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
+    }
+    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
+
+    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
+    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
+
+    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
+    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
+}
+
+/* ===========================================================================
+ * Send a stored block
+ */
+void _tr_stored_block(s, buf, stored_len, eof)
+    deflate_state *s;
+    charf *buf;       /* input block */
+    ulg stored_len;   /* length of input block */
+    int eof;          /* true if this is the last block for a file */
+{
+    send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */
+    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
+    s->compressed_len += (stored_len + 4) << 3;
+
+    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
+}
+
+/* Send just the `stored block' type code without any length bytes or data.
+ */
+void _tr_stored_type_only(s)
+    deflate_state *s;
+{
+    send_bits(s, (STORED_BLOCK << 1), 3);
+    bi_windup(s);
+    s->compressed_len = (s->compressed_len + 3) & ~7L;
+}
+
+
+/* ===========================================================================
+ * Send one empty static block to give enough lookahead for inflate.
+ * This takes 10 bits, of which 7 may remain in the bit buffer.
+ * The current inflate code requires 9 bits of lookahead. If the
+ * last two codes for the previous block (real code plus EOB) were coded
+ * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
+ * the last real code. In this case we send two empty static blocks instead
+ * of one. (There are no problems if the previous block is stored or fixed.)
+ * To simplify the code, we assume the worst case of last real code encoded
+ * on one bit only.
+ */
+void _tr_align(s)
+    deflate_state *s;
+{
+    send_bits(s, STATIC_TREES<<1, 3);
+    send_code(s, END_BLOCK, static_ltree);
+    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
+    bi_flush(s);
+    /* Of the 10 bits for the empty block, we have already sent
+     * (10 - bi_valid) bits. The lookahead for the last real code (before
+     * the EOB of the previous block) was thus at least one plus the length
+     * of the EOB plus what we have just sent of the empty static block.
+     */
+    if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {
+        send_bits(s, STATIC_TREES<<1, 3);
+        send_code(s, END_BLOCK, static_ltree);
+        s->compressed_len += 10L;
+        bi_flush(s);
+    }
+    s->last_eob_len = 7;
+}
+
+/* ===========================================================================
+ * Determine the best encoding for the current block: dynamic trees, static
+ * trees or store, and output the encoded block to the zip file. This function
+ * returns the total compressed length for the file so far.
+ */
+ulg _tr_flush_block(s, buf, stored_len, eof)
+    deflate_state *s;
+    charf *buf;       /* input block, or NULL if too old */
+    ulg stored_len;   /* length of input block */
+    int eof;          /* true if this is the last block for a file */
+{
+    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
+    int max_blindex = 0;  /* index of last bit length code of non zero freq */
+
+    /* Build the Huffman trees unless a stored block is forced */
+    if (s->level > 0) {
+
+	 /* Check if the file is ascii or binary */
+	if (s->data_type == Z_UNKNOWN) set_data_type(s);
+
+	/* Construct the literal and distance trees */
+	build_tree(s, (tree_desc *)(&(s->l_desc)));
+	Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
+		s->static_len));
+
+	build_tree(s, (tree_desc *)(&(s->d_desc)));
+	Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
+		s->static_len));
+	/* At this point, opt_len and static_len are the total bit lengths of
+	 * the compressed block data, excluding the tree representations.
+	 */
+
+	/* Build the bit length tree for the above two trees, and get the index
+	 * in bl_order of the last bit length code to send.
+	 */
+	max_blindex = build_bl_tree(s);
+
+	/* Determine the best encoding. Compute first the block length in bytes*/
+	opt_lenb = (s->opt_len+3+7)>>3;
+	static_lenb = (s->static_len+3+7)>>3;
+
+	Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
+		opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
+		s->last_lit));
+
+	if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
+
+    } else {
+        Assert(buf != (char*)0, "lost buf");
+	opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
+    }
+
+    /* If compression failed and this is the first and last block,
+     * and if the .zip file can be seeked (to rewrite the local header),
+     * the whole file is transformed into a stored file:
+     */
+#ifdef STORED_FILE_OK
+#  ifdef FORCE_STORED_FILE
+    if (eof && s->compressed_len == 0L) { /* force stored file */
+#  else
+    if (stored_len <= opt_lenb && eof && s->compressed_len==0L && seekable()) {
+#  endif
+        /* Since LIT_BUFSIZE <= 2*WSIZE, the input data must be there: */
+        if (buf == (charf*)0) error ("block vanished");
+
+        copy_block(s, buf, (unsigned)stored_len, 0); /* without header */
+        s->compressed_len = stored_len << 3;
+        s->method = STORED;
+    } else
+#endif /* STORED_FILE_OK */
+
+#ifdef FORCE_STORED
+    if (buf != (char*)0) { /* force stored block */
+#else
+    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
+                       /* 4: two words for the lengths */
+#endif
+        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
+         * Otherwise we can't have processed more than WSIZE input bytes since
+         * the last block flush, because compression would have been
+         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
+         * transform a block into a stored block.
+         */
+        _tr_stored_block(s, buf, stored_len, eof);
+
+#ifdef FORCE_STATIC
+    } else if (static_lenb >= 0) { /* force static trees */
+#else
+    } else if (static_lenb == opt_lenb) {
+#endif
+        send_bits(s, (STATIC_TREES<<1)+eof, 3);
+        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
+        s->compressed_len += 3 + s->static_len;
+    } else {
+        send_bits(s, (DYN_TREES<<1)+eof, 3);
+        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
+                       max_blindex+1);
+        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);
+        s->compressed_len += 3 + s->opt_len;
+    }
+    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
+    init_block(s);
+
+    if (eof) {
+        bi_windup(s);
+        s->compressed_len += 7;  /* align on byte boundary */
+    }
+    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
+           s->compressed_len-7*eof));
+
+    return s->compressed_len >> 3;
+}
+
+/* ===========================================================================
+ * Save the match info and tally the frequency counts. Return true if
+ * the current block must be flushed.
+ */
+int _tr_tally (s, dist, lc)
+    deflate_state *s;
+    unsigned dist;  /* distance of matched string */
+    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
+{
+    s->d_buf[s->last_lit] = (ush)dist;
+    s->l_buf[s->last_lit++] = (uch)lc;
+    if (dist == 0) {
+        /* lc is the unmatched char */
+        s->dyn_ltree[lc].Freq++;
+    } else {
+        s->matches++;
+        /* Here, lc is the match length - MIN_MATCH */
+        dist--;             /* dist = match distance - 1 */
+        Assert((ush)dist < (ush)MAX_DIST(s) &&
+               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
+               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
+
+        s->dyn_ltree[length_code[lc]+LITERALS+1].Freq++;
+        s->dyn_dtree[d_code(dist)].Freq++;
+    }
+
+    /* Try to guess if it is profitable to stop the current block here */
+    if (s->level > 2 && (s->last_lit & 0xfff) == 0) {
+        /* Compute an upper bound for the compressed length */
+        ulg out_length = (ulg)s->last_lit*8L;
+        ulg in_length = (ulg)((long)s->strstart - s->block_start);
+        int dcode;
+        for (dcode = 0; dcode < D_CODES; dcode++) {
+            out_length += (ulg)s->dyn_dtree[dcode].Freq *
+                (5L+extra_dbits[dcode]);
+        }
+        out_length >>= 3;
+        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
+               s->last_lit, in_length, out_length,
+               100L - out_length*100L/in_length));
+        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
+    }
+    return (s->last_lit == s->lit_bufsize-1);
+    /* We avoid equality with lit_bufsize because of wraparound at 64K
+     * on 16 bit machines and because stored blocks are restricted to
+     * 64K-1 bytes.
+     */
+}
+
+/* ===========================================================================
+ * Send the block data compressed using the given Huffman trees
+ */
+local void compress_block(s, ltree, dtree)
+    deflate_state *s;
+    ct_data *ltree; /* literal tree */
+    ct_data *dtree; /* distance tree */
+{
+    unsigned dist;      /* distance of matched string */
+    int lc;             /* match length or unmatched char (if dist == 0) */
+    unsigned lx = 0;    /* running index in l_buf */
+    unsigned code;      /* the code to send */
+    int extra;          /* number of extra bits to send */
+
+    if (s->last_lit != 0) do {
+        dist = s->d_buf[lx];
+        lc = s->l_buf[lx++];
+        if (dist == 0) {
+            send_code(s, lc, ltree); /* send a literal byte */
+            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
+        } else {
+            /* Here, lc is the match length - MIN_MATCH */
+            code = length_code[lc];
+            send_code(s, code+LITERALS+1, ltree); /* send the length code */
+            extra = extra_lbits[code];
+            if (extra != 0) {
+                lc -= base_length[code];
+                send_bits(s, lc, extra);       /* send the extra length bits */
+            }
+            dist--; /* dist is now the match distance - 1 */
+            code = d_code(dist);
+            Assert (code < D_CODES, "bad d_code");
+
+            send_code(s, code, dtree);       /* send the distance code */
+            extra = extra_dbits[code];
+            if (extra != 0) {
+                dist -= base_dist[code];
+                send_bits(s, dist, extra);   /* send the extra distance bits */
+            }
+        } /* literal or match pair ? */
+
+        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
+        Assert(s->pending < s->lit_bufsize + 2*lx, "pendingBuf overflow");
+
+    } while (lx < s->last_lit);
+
+    send_code(s, END_BLOCK, ltree);
+    s->last_eob_len = ltree[END_BLOCK].Len;
+}
+
+/* ===========================================================================
+ * Set the data type to ASCII or BINARY, using a crude approximation:
+ * binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.
+ * IN assertion: the fields freq of dyn_ltree are set and the total of all
+ * frequencies does not exceed 64K (to fit in an int on 16 bit machines).
+ */
+local void set_data_type(s)
+    deflate_state *s;
+{
+    int n = 0;
+    unsigned ascii_freq = 0;
+    unsigned bin_freq = 0;
+    while (n < 7)        bin_freq += s->dyn_ltree[n++].Freq;
+    while (n < 128)    ascii_freq += s->dyn_ltree[n++].Freq;
+    while (n < LITERALS) bin_freq += s->dyn_ltree[n++].Freq;
+    s->data_type = (Byte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);
+}
+
+/* ===========================================================================
+ * Reverse the first len bits of a code, using straightforward code (a faster
+ * method would use a table)
+ * IN assertion: 1 <= len <= 15
+ */
+local unsigned bi_reverse(code, len)
+    unsigned code; /* the value to invert */
+    int len;       /* its bit length */
+{
+    register unsigned res = 0;
+    do {
+        res |= code & 1;
+        code >>= 1, res <<= 1;
+    } while (--len > 0);
+    return res >> 1;
+}
+
+/* ===========================================================================
+ * Flush the bit buffer, keeping at most 7 bits in it.
+ */
+local void bi_flush(s)
+    deflate_state *s;
+{
+    if (s->bi_valid == 16) {
+        put_short(s, s->bi_buf);
+        s->bi_buf = 0;
+        s->bi_valid = 0;
+    } else if (s->bi_valid >= 8) {
+        put_byte(s, (Byte)s->bi_buf);
+        s->bi_buf >>= 8;
+        s->bi_valid -= 8;
+    }
+}
+
+/* ===========================================================================
+ * Flush the bit buffer and align the output on a byte boundary
+ */
+local void bi_windup(s)
+    deflate_state *s;
+{
+    if (s->bi_valid > 8) {
+        put_short(s, s->bi_buf);
+    } else if (s->bi_valid > 0) {
+        put_byte(s, (Byte)s->bi_buf);
+    }
+    s->bi_buf = 0;
+    s->bi_valid = 0;
+#ifdef DEBUG_ZLIB
+    s->bits_sent = (s->bits_sent+7) & ~7;
+#endif
+}
+
+/* ===========================================================================
+ * Copy a stored block, storing first the length and its
+ * one's complement if requested.
+ */
+local void copy_block(s, buf, len, header)
+    deflate_state *s;
+    charf    *buf;    /* the input data */
+    unsigned len;     /* its length */
+    int      header;  /* true if block header must be written */
+{
+    bi_windup(s);        /* align on byte boundary */
+    s->last_eob_len = 8; /* enough lookahead for inflate */
+
+    if (header) {
+        put_short(s, (ush)len);   
+        put_short(s, (ush)~len);
+#ifdef DEBUG_ZLIB
+        s->bits_sent += 2*16;
+#endif
+    }
+#ifdef DEBUG_ZLIB
+    s->bits_sent += (ulg)len<<3;
+#endif
+    /* bundle up the put_byte(s, *buf++) calls */
+    zmemcpy(&s->pending_buf[s->pending], buf, len);
+    s->pending += len;
+}
+/* --- trees.c */
+
+/* +++ inflate.c */
+/* inflate.c -- zlib interface to inflate modules
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* #include "zutil.h" */
+
+/* +++ infblock.h */
+/* infblock.h -- header to use infblock.c
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+struct inflate_blocks_state;
+typedef struct inflate_blocks_state FAR inflate_blocks_statef;
+
+extern inflate_blocks_statef * inflate_blocks_new OF((
+    z_streamp z,
+    check_func c,               /* check function */
+    uInt w));                   /* window size */
+
+extern int inflate_blocks OF((
+    inflate_blocks_statef *,
+    z_streamp ,
+    int));                      /* initial return code */
+
+extern void inflate_blocks_reset OF((
+    inflate_blocks_statef *,
+    z_streamp ,
+    uLongf *));                  /* check value on output */
+
+extern int inflate_blocks_free OF((
+    inflate_blocks_statef *,
+    z_streamp ,
+    uLongf *));                  /* check value on output */
+
+extern void inflate_set_dictionary OF((
+    inflate_blocks_statef *s,
+    const Bytef *d,  /* dictionary */
+    uInt  n));       /* dictionary length */
+
+extern int inflate_addhistory OF((
+    inflate_blocks_statef *,
+    z_streamp));
+
+extern int inflate_packet_flush OF((
+    inflate_blocks_statef *));
+/* --- infblock.h */
+
+#ifndef NO_DUMMY_DECL
+struct inflate_blocks_state {int dummy;}; /* for buggy compilers */
+#endif
+
+/* inflate private state */
+struct internal_state {
+
+  /* mode */
+  enum {
+      METHOD,   /* waiting for method byte */
+      FLAG,     /* waiting for flag byte */
+      DICT4,    /* four dictionary check bytes to go */
+      DICT3,    /* three dictionary check bytes to go */
+      DICT2,    /* two dictionary check bytes to go */
+      DICT1,    /* one dictionary check byte to go */
+      DICT0,    /* waiting for inflateSetDictionary */
+      BLOCKS,   /* decompressing blocks */
+      CHECK4,   /* four check bytes to go */
+      CHECK3,   /* three check bytes to go */
+      CHECK2,   /* two check bytes to go */
+      CHECK1,   /* one check byte to go */
+      DONE,     /* finished check, done */
+      BAD}      /* got an error--stay here */
+    mode;               /* current inflate mode */
+
+  /* mode dependent information */
+  union {
+    uInt method;        /* if FLAGS, method byte */
+    struct {
+      uLong was;                /* computed check value */
+      uLong need;               /* stream check value */
+    } check;            /* if CHECK, check values to compare */
+    uInt marker;        /* if BAD, inflateSync's marker bytes count */
+  } sub;        /* submode */
+
+  /* mode independent information */
+  int  nowrap;          /* flag for no wrapper */
+  uInt wbits;           /* log2(window size)  (8..15, defaults to 15) */
+  inflate_blocks_statef 
+    *blocks;            /* current inflate_blocks state */
+
+};
+
+
+int inflateReset(z)
+z_streamp z;
+{
+  uLong c;
+
+  if (z == Z_NULL || z->state == Z_NULL)
+    return Z_STREAM_ERROR;
+  z->total_in = z->total_out = 0;
+  z->msg = Z_NULL;
+  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;
+  inflate_blocks_reset(z->state->blocks, z, &c);
+  Trace((stderr, "inflate: reset\n"));
+  return Z_OK;
+}
+
+
+int inflateEnd(z)
+z_streamp z;
+{
+  uLong c;
+
+  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)
+    return Z_STREAM_ERROR;
+  if (z->state->blocks != Z_NULL)
+    inflate_blocks_free(z->state->blocks, z, &c);
+  ZFREE(z, z->state);
+  z->state = Z_NULL;
+  Trace((stderr, "inflate: end\n"));
+  return Z_OK;
+}
+
+
+int inflateInit2_(z, w, version, stream_size)
+z_streamp z;
+int w;
+const char *version;
+int stream_size;
+{
+  if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
+      stream_size != sizeof(z_stream))
+      return Z_VERSION_ERROR;
+
+  /* initialize state */
+  if (z == Z_NULL)
+    return Z_STREAM_ERROR;
+  z->msg = Z_NULL;
+#ifndef NO_ZCFUNCS
+  if (z->zalloc == Z_NULL)
+  {
+    z->zalloc = zcalloc;
+    z->opaque = (voidpf)0;
+  }
+  if (z->zfree == Z_NULL) z->zfree = zcfree;
+#endif
+  if ((z->state = (struct internal_state FAR *)
+       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)
+    return Z_MEM_ERROR;
+  z->state->blocks = Z_NULL;
+
+  /* handle undocumented nowrap option (no zlib header or check) */
+  z->state->nowrap = 0;
+  if (w < 0)
+  {
+    w = - w;
+    z->state->nowrap = 1;
+  }
+
+  /* set window size */
+  if (w < 8 || w > 15)
+  {
+    inflateEnd(z);
+    return Z_STREAM_ERROR;
+  }
+  z->state->wbits = (uInt)w;
+
+  /* create inflate_blocks state */
+  if ((z->state->blocks =
+      inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, (uInt)1 << w))
+      == Z_NULL)
+  {
+    inflateEnd(z);
+    return Z_MEM_ERROR;
+  }
+  Trace((stderr, "inflate: allocated\n"));
+
+  /* reset state */
+  inflateReset(z);
+  return Z_OK;
+}
+
+
+int inflateInit_(z, version, stream_size)
+z_streamp z;
+const char *version;
+int stream_size;
+{
+  return inflateInit2_(z, DEF_WBITS, version, stream_size);
+}
+
+
+#define NEEDBYTE {if(z->avail_in==0)goto empty;r=Z_OK;}
+#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)
+
+int inflate(z, f)
+z_streamp z;
+int f;
+{
+  int r;
+  uInt b;
+
+  if (z == Z_NULL || z->state == Z_NULL || z->next_in == Z_NULL || f < 0)
+    return Z_STREAM_ERROR;
+  r = Z_BUF_ERROR;
+  while (1) switch (z->state->mode)
+  {
+    case METHOD:
+      NEEDBYTE
+      if (((z->state->sub.method = NEXTBYTE) & 0xf) != Z_DEFLATED)
+      {
+        z->state->mode = BAD;
+        z->msg = (char*)"unknown compression method";
+        z->state->sub.marker = 5;       /* can't try inflateSync */
+        break;
+      }
+      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)
+      {
+        z->state->mode = BAD;
+        z->msg = (char*)"invalid window size";
+        z->state->sub.marker = 5;       /* can't try inflateSync */
+        break;
+      }
+      z->state->mode = FLAG;
+    case FLAG:
+      NEEDBYTE
+      b = NEXTBYTE;
+      if (((z->state->sub.method << 8) + b) % 31)
+      {
+        z->state->mode = BAD;
+        z->msg = (char*)"incorrect header check";
+        z->state->sub.marker = 5;       /* can't try inflateSync */
+        break;
+      }
+      Trace((stderr, "inflate: zlib header ok\n"));
+      if (!(b & PRESET_DICT))
+      {
+        z->state->mode = BLOCKS;
+	break;
+      }
+      z->state->mode = DICT4;
+    case DICT4:
+      NEEDBYTE
+      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
+      z->state->mode = DICT3;
+    case DICT3:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
+      z->state->mode = DICT2;
+    case DICT2:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
+      z->state->mode = DICT1;
+    case DICT1:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE;
+      z->adler = z->state->sub.check.need;
+      z->state->mode = DICT0;
+      return Z_NEED_DICT;
+    case DICT0:
+      z->state->mode = BAD;
+      z->msg = (char*)"need dictionary";
+      z->state->sub.marker = 0;       /* can try inflateSync */
+      return Z_STREAM_ERROR;
+    case BLOCKS:
+      r = inflate_blocks(z->state->blocks, z, r);
+      if (f == Z_PACKET_FLUSH && z->avail_in == 0 && z->avail_out != 0)
+	  r = inflate_packet_flush(z->state->blocks);
+      if (r == Z_DATA_ERROR)
+      {
+        z->state->mode = BAD;
+        z->state->sub.marker = 0;       /* can try inflateSync */
+        break;
+      }
+      if (r != Z_STREAM_END)
+        return r;
+      r = Z_OK;
+      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);
+      if (z->state->nowrap)
+      {
+        z->state->mode = DONE;
+        break;
+      }
+      z->state->mode = CHECK4;
+    case CHECK4:
+      NEEDBYTE
+      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
+      z->state->mode = CHECK3;
+    case CHECK3:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
+      z->state->mode = CHECK2;
+    case CHECK2:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
+      z->state->mode = CHECK1;
+    case CHECK1:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE;
+
+      if (z->state->sub.check.was != z->state->sub.check.need)
+      {
+        z->state->mode = BAD;
+        z->msg = (char*)"incorrect data check";
+        z->state->sub.marker = 5;       /* can't try inflateSync */
+        break;
+      }
+      Trace((stderr, "inflate: zlib check ok\n"));
+      z->state->mode = DONE;
+    case DONE:
+      return Z_STREAM_END;
+    case BAD:
+      return Z_DATA_ERROR;
+    default:
+      return Z_STREAM_ERROR;
+  }
+
+ empty:
+  if (f != Z_PACKET_FLUSH)
+    return r;
+  z->state->mode = BAD;
+  z->msg = (char *)"need more for packet flush";
+  z->state->sub.marker = 0;       /* can try inflateSync */
+  return Z_DATA_ERROR;
+}
+
+
+int inflateSetDictionary(z, dictionary, dictLength)
+z_streamp z;
+const Bytef *dictionary;
+uInt  dictLength;
+{
+  uInt length = dictLength;
+
+  if (z == Z_NULL || z->state == Z_NULL || z->state->mode != DICT0)
+    return Z_STREAM_ERROR;
+
+  if (adler32(1L, dictionary, dictLength) != z->adler) return Z_DATA_ERROR;
+  z->adler = 1L;
+
+  if (length >= ((uInt)1<<z->state->wbits))
+  {
+    length = (1<<z->state->wbits)-1;
+    dictionary += dictLength - length;
+  }
+  inflate_set_dictionary(z->state->blocks, dictionary, length);
+  z->state->mode = BLOCKS;
+  return Z_OK;
+}
+
+/*
+ * This subroutine adds the data at next_in/avail_in to the output history
+ * without performing any output.  The output buffer must be "caught up";
+ * i.e. no pending output (hence s->read equals s->write), and the state must
+ * be BLOCKS (i.e. we should be willing to see the start of a series of
+ * BLOCKS).  On exit, the output will also be caught up, and the checksum
+ * will have been updated if need be.
+ */
+
+int inflateIncomp(z)
+z_stream *z;
+{
+    if (z->state->mode != BLOCKS)
+	return Z_DATA_ERROR;
+    return inflate_addhistory(z->state->blocks, z);
+}
+
+
+int inflateSync(z)
+z_streamp z;
+{
+  uInt n;       /* number of bytes to look at */
+  Bytef *p;     /* pointer to bytes */
+  uInt m;       /* number of marker bytes found in a row */
+  uLong r, w;   /* temporaries to save total_in and total_out */
+
+  /* set up */
+  if (z == Z_NULL || z->state == Z_NULL)
+    return Z_STREAM_ERROR;
+  if (z->state->mode != BAD)
+  {
+    z->state->mode = BAD;
+    z->state->sub.marker = 0;
+  }
+  if ((n = z->avail_in) == 0)
+    return Z_BUF_ERROR;
+  p = z->next_in;
+  m = z->state->sub.marker;
+
+  /* search */
+  while (n && m < 4)
+  {
+    if (*p == (Byte)(m < 2 ? 0 : 0xff))
+      m++;
+    else if (*p)
+      m = 0;
+    else
+      m = 4 - m;
+    p++, n--;
+  }
+
+  /* restore */
+  z->total_in += p - z->next_in;
+  z->next_in = p;
+  z->avail_in = n;
+  z->state->sub.marker = m;
+
+  /* return no joy or set up to restart on a new block */
+  if (m != 4)
+    return Z_DATA_ERROR;
+  r = z->total_in;  w = z->total_out;
+  inflateReset(z);
+  z->total_in = r;  z->total_out = w;
+  z->state->mode = BLOCKS;
+  return Z_OK;
+}
+
+#undef NEEDBYTE
+#undef NEXTBYTE
+/* --- inflate.c */
+
+/* +++ infblock.c */
+/* infblock.c -- interpret and process block types to last block
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* #include "zutil.h" */
+/* #include "infblock.h" */
+
+/* +++ inftrees.h */
+/* inftrees.h -- header to use inftrees.c
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* Huffman code lookup table entry--this entry is four bytes for machines
+   that have 16-bit pointers (e.g. PC's in the small or medium model). */
+
+typedef struct inflate_huft_s FAR inflate_huft;
+
+struct inflate_huft_s {
+  union {
+    struct {
+      Byte Exop;        /* number of extra bits or operation */
+      Byte Bits;        /* number of bits in this code or subcode */
+    } what;
+    Bytef *pad;         /* pad structure to a power of 2 (4 bytes for */
+  } word;               /*  16-bit, 8 bytes for 32-bit machines) */
+  union {
+    uInt Base;          /* literal, length base, or distance base */
+    inflate_huft *Next; /* pointer to next level of table */
+  } more;
+};
+
+#ifdef DEBUG_ZLIB
+  extern uInt inflate_hufts;
+#endif
+
+extern int inflate_trees_bits OF((
+    uIntf *,                    /* 19 code lengths */
+    uIntf *,                    /* bits tree desired/actual depth */
+    inflate_huft * FAR *,       /* bits tree result */
+    z_streamp ));               /* for zalloc, zfree functions */
+
+extern int inflate_trees_dynamic OF((
+    uInt,                       /* number of literal/length codes */
+    uInt,                       /* number of distance codes */
+    uIntf *,                    /* that many (total) code lengths */
+    uIntf *,                    /* literal desired/actual bit depth */
+    uIntf *,                    /* distance desired/actual bit depth */
+    inflate_huft * FAR *,       /* literal/length tree result */
+    inflate_huft * FAR *,       /* distance tree result */
+    z_streamp ));               /* for zalloc, zfree functions */
+
+extern int inflate_trees_fixed OF((
+    uIntf *,                    /* literal desired/actual bit depth */
+    uIntf *,                    /* distance desired/actual bit depth */
+    inflate_huft * FAR *,       /* literal/length tree result */
+    inflate_huft * FAR *));     /* distance tree result */
+
+extern int inflate_trees_free OF((
+    inflate_huft *,             /* tables to free */
+    z_streamp ));               /* for zfree function */
+
+/* --- inftrees.h */
+
+/* +++ infcodes.h */
+/* infcodes.h -- header to use infcodes.c
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+struct inflate_codes_state;
+typedef struct inflate_codes_state FAR inflate_codes_statef;
+
+extern inflate_codes_statef *inflate_codes_new OF((
+    uInt, uInt,
+    inflate_huft *, inflate_huft *,
+    z_streamp ));
+
+extern int inflate_codes OF((
+    inflate_blocks_statef *,
+    z_streamp ,
+    int));
+
+extern void inflate_codes_free OF((
+    inflate_codes_statef *,
+    z_streamp ));
+
+/* --- infcodes.h */
+
+/* +++ infutil.h */
+/* infutil.h -- types and macros common to blocks and codes
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+#ifndef _INFUTIL_H
+#define _INFUTIL_H
+
+typedef enum {
+      TYPE,     /* get type bits (3, including end bit) */
+      LENS,     /* get lengths for stored */
+      STORED,   /* processing stored block */
+      TABLE,    /* get table lengths */
+      BTREE,    /* get bit lengths tree for a dynamic block */
+      DTREE,    /* get length, distance trees for a dynamic block */
+      CODES,    /* processing fixed or dynamic block */
+      DRY,      /* output remaining window bytes */
+      DONEB,    /* finished last block, done */
+      BADB}     /* got a data error--stuck here */
+inflate_block_mode;
+
+/* inflate blocks semi-private state */
+struct inflate_blocks_state {
+
+  /* mode */
+  inflate_block_mode  mode;     /* current inflate_block mode */
+
+  /* mode dependent information */
+  union {
+    uInt left;          /* if STORED, bytes left to copy */
+    struct {
+      uInt table;               /* table lengths (14 bits) */
+      uInt index;               /* index into blens (or border) */
+      uIntf *blens;             /* bit lengths of codes */
+      uInt bb;                  /* bit length tree depth */
+      inflate_huft *tb;         /* bit length decoding tree */
+    } trees;            /* if DTREE, decoding info for trees */
+    struct {
+      inflate_huft *tl;
+      inflate_huft *td;         /* trees to free */
+      inflate_codes_statef 
+         *codes;
+    } decode;           /* if CODES, current state */
+  } sub;                /* submode */
+  uInt last;            /* true if this block is the last block */
+
+  /* mode independent information */
+  uInt bitk;            /* bits in bit buffer */
+  uLong bitb;           /* bit buffer */
+  Bytef *window;        /* sliding window */
+  Bytef *end;           /* one byte after sliding window */
+  Bytef *read;          /* window read pointer */
+  Bytef *write;         /* window write pointer */
+  check_func checkfn;   /* check function */
+  uLong check;          /* check on output */
+
+};
+
+
+/* defines for inflate input/output */
+/*   update pointers and return */
+#define UPDBITS {s->bitb=b;s->bitk=k;}
+#define UPDIN {z->avail_in=n;z->total_in+=p-z->next_in;z->next_in=p;}
+#define UPDOUT {s->write=q;}
+#define UPDATE {UPDBITS UPDIN UPDOUT}
+#define LEAVE {UPDATE return inflate_flush(s,z,r);}
+/*   get bytes and bits */
+#define LOADIN {p=z->next_in;n=z->avail_in;b=s->bitb;k=s->bitk;}
+#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}
+#define NEXTBYTE (n--,*p++)
+#define NEEDBITS(j) {while(k<(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)<<k;k+=8;}}
+#define DUMPBITS(j) {b>>=(j);k-=(j);}
+/*   output bytes */
+#define WAVAIL (uInt)(q<s->read?s->read-q-1:s->end-q)
+#define LOADOUT {q=s->write;m=(uInt)WAVAIL;}
+#define WWRAP {if(q==s->end&&s->read!=s->window){q=s->window;m=(uInt)WAVAIL;}}
+#define FLUSH {UPDOUT r=inflate_flush(s,z,r); LOADOUT}
+#define NEEDOUT {if(m==0){WWRAP if(m==0){FLUSH WWRAP if(m==0) LEAVE}}r=Z_OK;}
+#define OUTBYTE(a) {*q++=(Byte)(a);m--;}
+/*   load local pointers */
+#define LOAD {LOADIN LOADOUT}
+
+/* masks for lower bits (size given to avoid silly warnings with Visual C++) */
+extern uInt inflate_mask[17];
+
+/* copy as much as possible from the sliding window to the output area */
+extern int inflate_flush OF((
+    inflate_blocks_statef *,
+    z_streamp ,
+    int));
+
+#ifndef NO_DUMMY_DECL
+struct internal_state      {int dummy;}; /* for buggy compilers */
+#endif
+
+#endif
+/* --- infutil.h */
+
+#ifndef NO_DUMMY_DECL
+struct inflate_codes_state {int dummy;}; /* for buggy compilers */
+#endif
+
+/* Table for deflate from PKZIP's appnote.txt. */
+local const uInt border[] = { /* Order of the bit length code lengths */
+        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
+
+/*
+   Notes beyond the 1.93a appnote.txt:
+
+   1. Distance pointers never point before the beginning of the output
+      stream.
+   2. Distance pointers can point back across blocks, up to 32k away.
+   3. There is an implied maximum of 7 bits for the bit length table and
+      15 bits for the actual data.
+   4. If only one code exists, then it is encoded using one bit.  (Zero
+      would be more efficient, but perhaps a little confusing.)  If two
+      codes exist, they are coded using one bit each (0 and 1).
+   5. There is no way of sending zero distance codes--a dummy must be
+      sent if there are none.  (History: a pre 2.0 version of PKZIP would
+      store blocks with no distance codes, but this was discovered to be
+      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
+      zero distance codes, which is sent as one code of zero bits in
+      length.
+   6. There are up to 286 literal/length codes.  Code 256 represents the
+      end-of-block.  Note however that the static length tree defines
+      288 codes just to fill out the Huffman codes.  Codes 286 and 287
+      cannot be used though, since there is no length base or extra bits
+      defined for them.  Similarily, there are up to 30 distance codes.
+      However, static trees define 32 codes (all 5 bits) to fill out the
+      Huffman codes, but the last two had better not show up in the data.
+   7. Unzip can check dynamic Huffman blocks for complete code sets.
+      The exception is that a single code would not be complete (see #4).
+   8. The five bits following the block type is really the number of
+      literal codes sent minus 257.
+   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
+      (1+6+6).  Therefore, to output three times the length, you output
+      three codes (1+1+1), whereas to output four times the same length,
+      you only need two codes (1+3).  Hmm.
+  10. In the tree reconstruction algorithm, Code = Code + Increment
+      only if BitLength(i) is not zero.  (Pretty obvious.)
+  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
+  12. Note: length code 284 can represent 227-258, but length code 285
+      really is 258.  The last length deserves its own, short code
+      since it gets used a lot in very redundant files.  The length
+      258 is special since 258 - 3 (the min match length) is 255.
+  13. The literal/length and distance code bit lengths are read as a
+      single stream of lengths.  It is possible (and advantageous) for
+      a repeat code (16, 17, or 18) to go across the boundary between
+      the two sets of lengths.
+ */
+
+
+void inflate_blocks_reset(s, z, c)
+inflate_blocks_statef *s;
+z_streamp z;
+uLongf *c;
+{
+  if (s->checkfn != Z_NULL)
+    *c = s->check;
+  if (s->mode == BTREE || s->mode == DTREE)
+    ZFREE(z, s->sub.trees.blens);
+  if (s->mode == CODES)
+  {
+    inflate_codes_free(s->sub.decode.codes, z);
+    inflate_trees_free(s->sub.decode.td, z);
+    inflate_trees_free(s->sub.decode.tl, z);
+  }
+  s->mode = TYPE;
+  s->bitk = 0;
+  s->bitb = 0;
+  s->read = s->write = s->window;
+  if (s->checkfn != Z_NULL)
+    z->adler = s->check = (*s->checkfn)(0L, Z_NULL, 0);
+  Trace((stderr, "inflate:   blocks reset\n"));
+}
+
+
+inflate_blocks_statef *inflate_blocks_new(z, c, w)
+z_streamp z;
+check_func c;
+uInt w;
+{
+  inflate_blocks_statef *s;
+
+  if ((s = (inflate_blocks_statef *)ZALLOC
+       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)
+    return s;
+  if ((s->window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)
+  {
+    ZFREE(z, s);
+    return Z_NULL;
+  }
+  s->end = s->window + w;
+  s->checkfn = c;
+  s->mode = TYPE;
+  Trace((stderr, "inflate:   blocks allocated\n"));
+  inflate_blocks_reset(s, z, &s->check);
+  return s;
+}
+
+
+#ifdef DEBUG_ZLIB
+  extern uInt inflate_hufts;
+#endif
+int inflate_blocks(s, z, r)
+inflate_blocks_statef *s;
+z_streamp z;
+int r;
+{
+  uInt t;               /* temporary storage */
+  uLong b;              /* bit buffer */
+  uInt k;               /* bits in bit buffer */
+  Bytef *p;             /* input data pointer */
+  uInt n;               /* bytes available there */
+  Bytef *q;             /* output window write pointer */
+  uInt m;               /* bytes to end of window or read pointer */
+
+  /* copy input/output information to locals (UPDATE macro restores) */
+  LOAD
+
+  /* process input based on current state */
+  while (1) switch (s->mode)
+  {
+    case TYPE:
+      NEEDBITS(3)
+      t = (uInt)b & 7;
+      s->last = t & 1;
+      switch (t >> 1)
+      {
+        case 0:                         /* stored */
+          Trace((stderr, "inflate:     stored block%s\n",
+                 s->last ? " (last)" : ""));
+          DUMPBITS(3)
+          t = k & 7;                    /* go to byte boundary */
+          DUMPBITS(t)
+          s->mode = LENS;               /* get length of stored block */
+          break;
+        case 1:                         /* fixed */
+          Trace((stderr, "inflate:     fixed codes block%s\n",
+                 s->last ? " (last)" : ""));
+          {
+            uInt bl, bd;
+            inflate_huft *tl, *td;
+
+            inflate_trees_fixed(&bl, &bd, &tl, &td);
+            s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);
+            if (s->sub.decode.codes == Z_NULL)
+            {
+              r = Z_MEM_ERROR;
+              LEAVE
+            }
+            s->sub.decode.tl = Z_NULL;  /* don't try to free these */
+            s->sub.decode.td = Z_NULL;
+          }
+          DUMPBITS(3)
+          s->mode = CODES;
+          break;
+        case 2:                         /* dynamic */
+          Trace((stderr, "inflate:     dynamic codes block%s\n",
+                 s->last ? " (last)" : ""));
+          DUMPBITS(3)
+          s->mode = TABLE;
+          break;
+        case 3:                         /* illegal */
+          DUMPBITS(3)
+          s->mode = BADB;
+          z->msg = (char*)"invalid block type";
+          r = Z_DATA_ERROR;
+          LEAVE
+      }
+      break;
+    case LENS:
+      NEEDBITS(32)
+      if ((((~b) >> 16) & 0xffff) != (b & 0xffff))
+      {
+        s->mode = BADB;
+        z->msg = (char*)"invalid stored block lengths";
+        r = Z_DATA_ERROR;
+        LEAVE
+      }
+      s->sub.left = (uInt)b & 0xffff;
+      b = k = 0;                      /* dump bits */
+      Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
+      s->mode = s->sub.left ? STORED : (s->last ? DRY : TYPE);
+      break;
+    case STORED:
+      if (n == 0)
+        LEAVE
+      NEEDOUT
+      t = s->sub.left;
+      if (t > n) t = n;
+      if (t > m) t = m;
+      zmemcpy(q, p, t);
+      p += t;  n -= t;
+      q += t;  m -= t;
+      if ((s->sub.left -= t) != 0)
+        break;
+      Tracev((stderr, "inflate:       stored end, %lu total out\n",
+              z->total_out + (q >= s->read ? q - s->read :
+              (s->end - s->read) + (q - s->window))));
+      s->mode = s->last ? DRY : TYPE;
+      break;
+    case TABLE:
+      NEEDBITS(14)
+      s->sub.trees.table = t = (uInt)b & 0x3fff;
+#ifndef PKZIP_BUG_WORKAROUND
+      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
+      {
+        s->mode = BADB;
+        z->msg = (char*)"too many length or distance symbols";
+        r = Z_DATA_ERROR;
+        LEAVE
+      }
+#endif
+      t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
+      if (t < 19)
+        t = 19;
+      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)
+      {
+        r = Z_MEM_ERROR;
+        LEAVE
+      }
+      DUMPBITS(14)
+      s->sub.trees.index = 0;
+      Tracev((stderr, "inflate:       table sizes ok\n"));
+      s->mode = BTREE;
+    case BTREE:
+      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))
+      {
+        NEEDBITS(3)
+        s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
+        DUMPBITS(3)
+      }
+      while (s->sub.trees.index < 19)
+        s->sub.trees.blens[border[s->sub.trees.index++]] = 0;
+      s->sub.trees.bb = 7;
+      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,
+                             &s->sub.trees.tb, z);
+      if (t != Z_OK)
+      {
+        r = t;
+        if (r == Z_DATA_ERROR)
+	{
+	  ZFREE(z, s->sub.trees.blens);
+          s->mode = BADB;
+	}
+        LEAVE
+      }
+      s->sub.trees.index = 0;
+      Tracev((stderr, "inflate:       bits tree ok\n"));
+      s->mode = DTREE;
+    case DTREE:
+      while (t = s->sub.trees.table,
+             s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))
+      {
+        inflate_huft *h;
+        uInt i, j, c;
+
+        t = s->sub.trees.bb;
+        NEEDBITS(t)
+        h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);
+        t = h->word.what.Bits;
+        c = h->more.Base;
+        if (c < 16)
+        {
+          DUMPBITS(t)
+          s->sub.trees.blens[s->sub.trees.index++] = c;
+        }
+        else /* c == 16..18 */
+        {
+          i = c == 18 ? 7 : c - 14;
+          j = c == 18 ? 11 : 3;
+          NEEDBITS(t + i)
+          DUMPBITS(t)
+          j += (uInt)b & inflate_mask[i];
+          DUMPBITS(i)
+          i = s->sub.trees.index;
+          t = s->sub.trees.table;
+          if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
+              (c == 16 && i < 1))
+          {
+            inflate_trees_free(s->sub.trees.tb, z);
+            ZFREE(z, s->sub.trees.blens);
+            s->mode = BADB;
+            z->msg = (char*)"invalid bit length repeat";
+            r = Z_DATA_ERROR;
+            LEAVE
+          }
+          c = c == 16 ? s->sub.trees.blens[i - 1] : 0;
+          do {
+            s->sub.trees.blens[i++] = c;
+          } while (--j);
+          s->sub.trees.index = i;
+        }
+      }
+      inflate_trees_free(s->sub.trees.tb, z);
+      s->sub.trees.tb = Z_NULL;
+      {
+        uInt bl, bd;
+        inflate_huft *tl, *td;
+        inflate_codes_statef *c;
+
+        bl = 9;         /* must be <= 9 for lookahead assumptions */
+        bd = 6;         /* must be <= 9 for lookahead assumptions */
+        t = s->sub.trees.table;
+#ifdef DEBUG_ZLIB
+      inflate_hufts = 0;
+#endif
+        t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),
+                                  s->sub.trees.blens, &bl, &bd, &tl, &td, z);
+        if (t != Z_OK)
+        {
+          if (t == (uInt)Z_DATA_ERROR)
+	  {
+	    ZFREE(z, s->sub.trees.blens);
+            s->mode = BADB;
+	  }
+          r = t;
+          LEAVE
+        }
+        Tracev((stderr, "inflate:       trees ok, %d * %d bytes used\n",
+              inflate_hufts, sizeof(inflate_huft)));
+        if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
+        {
+          inflate_trees_free(td, z);
+          inflate_trees_free(tl, z);
+          r = Z_MEM_ERROR;
+          LEAVE
+        }
+        ZFREE(z, s->sub.trees.blens);
+        s->sub.decode.codes = c;
+        s->sub.decode.tl = tl;
+        s->sub.decode.td = td;
+      }
+      s->mode = CODES;
+    case CODES:
+      UPDATE
+      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
+        return inflate_flush(s, z, r);
+      r = Z_OK;
+      inflate_codes_free(s->sub.decode.codes, z);
+      inflate_trees_free(s->sub.decode.td, z);
+      inflate_trees_free(s->sub.decode.tl, z);
+      LOAD
+      Tracev((stderr, "inflate:       codes end, %lu total out\n",
+              z->total_out + (q >= s->read ? q - s->read :
+              (s->end - s->read) + (q - s->window))));
+      if (!s->last)
+      {
+        s->mode = TYPE;
+        break;
+      }
+      if (k > 7)              /* return unused byte, if any */
+      {
+        Assert(k < 16, "inflate_codes grabbed too many bytes")
+        k -= 8;
+        n++;
+        p--;                    /* can always return one */
+      }
+      s->mode = DRY;
+    case DRY:
+      FLUSH
+      if (s->read != s->write)
+        LEAVE
+      s->mode = DONEB;
+    case DONEB:
+      r = Z_STREAM_END;
+      LEAVE
+    case BADB:
+      r = Z_DATA_ERROR;
+      LEAVE
+    default:
+      r = Z_STREAM_ERROR;
+      LEAVE
+  }
+}
+
+
+int inflate_blocks_free(s, z, c)
+inflate_blocks_statef *s;
+z_streamp z;
+uLongf *c;
+{
+  inflate_blocks_reset(s, z, c);
+  ZFREE(z, s->window);
+  ZFREE(z, s);
+  Trace((stderr, "inflate:   blocks freed\n"));
+  return Z_OK;
+}
+
+
+void inflate_set_dictionary(s, d, n)
+inflate_blocks_statef *s;
+const Bytef *d;
+uInt  n;
+{
+  zmemcpy((charf *)s->window, d, n);
+  s->read = s->write = s->window + n;
+}
+
+/*
+ * This subroutine adds the data at next_in/avail_in to the output history
+ * without performing any output.  The output buffer must be "caught up";
+ * i.e. no pending output (hence s->read equals s->write), and the state must
+ * be BLOCKS (i.e. we should be willing to see the start of a series of
+ * BLOCKS).  On exit, the output will also be caught up, and the checksum
+ * will have been updated if need be.
+ */
+int inflate_addhistory(s, z)
+inflate_blocks_statef *s;
+z_stream *z;
+{
+    uLong b;              /* bit buffer */  /* NOT USED HERE */
+    uInt k;               /* bits in bit buffer */ /* NOT USED HERE */
+    uInt t;               /* temporary storage */
+    Bytef *p;             /* input data pointer */
+    uInt n;               /* bytes available there */
+    Bytef *q;             /* output window write pointer */
+    uInt m;               /* bytes to end of window or read pointer */
+
+    if (s->read != s->write)
+	return Z_STREAM_ERROR;
+    if (s->mode != TYPE)
+	return Z_DATA_ERROR;
+
+    /* we're ready to rock */
+    LOAD
+    /* while there is input ready, copy to output buffer, moving
+     * pointers as needed.
+     */
+    while (n) {
+	t = n;  /* how many to do */
+	/* is there room until end of buffer? */
+	if (t > m) t = m;
+	/* update check information */
+	if (s->checkfn != Z_NULL)
+	    s->check = (*s->checkfn)(s->check, q, t);
+	zmemcpy(q, p, t);
+	q += t;
+	p += t;
+	n -= t;
+	z->total_out += t;
+	s->read = q;    /* drag read pointer forward */
+/*      WWRAP  */ 	/* expand WWRAP macro by hand to handle s->read */
+	if (q == s->end) {
+	    s->read = q = s->window;
+	    m = WAVAIL;
+	}
+    }
+    UPDATE
+    return Z_OK;
+}
+
+
+/*
+ * At the end of a Deflate-compressed PPP packet, we expect to have seen
+ * a `stored' block type value but not the (zero) length bytes.
+ */
+int inflate_packet_flush(s)
+    inflate_blocks_statef *s;
+{
+    if (s->mode != LENS)
+	return Z_DATA_ERROR;
+    s->mode = TYPE;
+    return Z_OK;
+}
+/* --- infblock.c */
+
+/* +++ inftrees.c */
+/* inftrees.c -- generate Huffman trees for efficient decoding
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* #include "zutil.h" */
+/* #include "inftrees.h" */
+
+char inflate_copyright[] = " inflate 1.0.4 Copyright 1995-1996 Mark Adler ";
+/*
+  If you use the zlib library in a product, an acknowledgment is welcome
+  in the documentation of your product. If for some reason you cannot
+  include such an acknowledgment, I would appreciate that you keep this
+  copyright string in the executable of your product.
+ */
+
+#ifndef NO_DUMMY_DECL
+struct internal_state  {int dummy;}; /* for buggy compilers */
+#endif
+
+/* simplify the use of the inflate_huft type with some defines */
+#define base more.Base
+#define next more.Next
+#define exop word.what.Exop
+#define bits word.what.Bits
+
+
+local int huft_build OF((
+    uIntf *,            /* code lengths in bits */
+    uInt,               /* number of codes */
+    uInt,               /* number of "simple" codes */
+    const uIntf *,      /* list of base values for non-simple codes */
+    const uIntf *,      /* list of extra bits for non-simple codes */
+    inflate_huft * FAR*,/* result: starting table */
+    uIntf *,            /* maximum lookup bits (returns actual) */
+    z_streamp ));       /* for zalloc function */
+
+local voidpf falloc OF((
+    voidpf,             /* opaque pointer (not used) */
+    uInt,               /* number of items */
+    uInt));             /* size of item */
+
+/* Tables for deflate from PKZIP's appnote.txt. */
+local const uInt cplens[31] = { /* Copy lengths for literal codes 257..285 */
+        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
+        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
+        /* see note #13 above about 258 */
+local const uInt cplext[31] = { /* Extra bits for literal codes 257..285 */
+        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
+        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112}; /* 112==invalid */
+local const uInt cpdist[30] = { /* Copy offsets for distance codes 0..29 */
+        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
+        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
+        8193, 12289, 16385, 24577};
+local const uInt cpdext[30] = { /* Extra bits for distance codes */
+        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
+        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
+        12, 12, 13, 13};
+
+/*
+   Huffman code decoding is performed using a multi-level table lookup.
+   The fastest way to decode is to simply build a lookup table whose
+   size is determined by the longest code.  However, the time it takes
+   to build this table can also be a factor if the data being decoded
+   is not very long.  The most common codes are necessarily the
+   shortest codes, so those codes dominate the decoding time, and hence
+   the speed.  The idea is you can have a shorter table that decodes the
+   shorter, more probable codes, and then point to subsidiary tables for
+   the longer codes.  The time it costs to decode the longer codes is
+   then traded against the time it takes to make longer tables.
+
+   This results of this trade are in the variables lbits and dbits
+   below.  lbits is the number of bits the first level table for literal/
+   length codes can decode in one step, and dbits is the same thing for
+   the distance codes.  Subsequent tables are also less than or equal to
+   those sizes.  These values may be adjusted either when all of the
+   codes are shorter than that, in which case the longest code length in
+   bits is used, or when the shortest code is *longer* than the requested
+   table size, in which case the length of the shortest code in bits is
+   used.
+
+   There are two different values for the two tables, since they code a
+   different number of possibilities each.  The literal/length table
+   codes 286 possible values, or in a flat code, a little over eight
+   bits.  The distance table codes 30 possible values, or a little less
+   than five bits, flat.  The optimum values for speed end up being
+   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
+   The optimum values may differ though from machine to machine, and
+   possibly even between compilers.  Your mileage may vary.
+ */
+
+
+/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */
+#define BMAX 15         /* maximum bit length of any code */
+#define N_MAX 288       /* maximum number of codes in any set */
+
+#ifdef DEBUG_ZLIB
+  uInt inflate_hufts;
+#endif
+
+local int huft_build(b, n, s, d, e, t, m, zs)
+uIntf *b;               /* code lengths in bits (all assumed <= BMAX) */
+uInt n;                 /* number of codes (assumed <= N_MAX) */
+uInt s;                 /* number of simple-valued codes (0..s-1) */
+const uIntf *d;         /* list of base values for non-simple codes */
+const uIntf *e;         /* list of extra bits for non-simple codes */
+inflate_huft * FAR *t;  /* result: starting table */
+uIntf *m;               /* maximum lookup bits, returns actual */
+z_streamp zs;           /* for zalloc function */
+/* Given a list of code lengths and a maximum table size, make a set of
+   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
+   if the given code set is incomplete (the tables are still built in this
+   case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of
+   lengths), or Z_MEM_ERROR if not enough memory. */
+{
+
+  uInt a;                       /* counter for codes of length k */
+  uInt c[BMAX+1];               /* bit length count table */
+  uInt f;                       /* i repeats in table every f entries */
+  int g;                        /* maximum code length */
+  int h;                        /* table level */
+  register uInt i;              /* counter, current code */
+  register uInt j;              /* counter */
+  register int k;               /* number of bits in current code */
+  int l;                        /* bits per table (returned in m) */
+  register uIntf *p;            /* pointer into c[], b[], or v[] */
+  inflate_huft *q;              /* points to current table */
+  struct inflate_huft_s r;      /* table entry for structure assignment */
+  inflate_huft *u[BMAX];        /* table stack */
+  uInt v[N_MAX];                /* values in order of bit length */
+  register int w;               /* bits before this table == (l * h) */
+  uInt x[BMAX+1];               /* bit offsets, then code stack */
+  uIntf *xp;                    /* pointer into x */
+  int y;                        /* number of dummy codes added */
+  uInt z;                       /* number of entries in current table */
+
+
+  /* Generate counts for each bit length */
+  p = c;
+#define C0 *p++ = 0;
+#define C2 C0 C0 C0 C0
+#define C4 C2 C2 C2 C2
+  C4                            /* clear c[]--assume BMAX+1 is 16 */
+  p = b;  i = n;
+  do {
+    c[*p++]++;                  /* assume all entries <= BMAX */
+  } while (--i);
+  if (c[0] == n)                /* null input--all zero length codes */
+  {
+    *t = (inflate_huft *)Z_NULL;
+    *m = 0;
+    return Z_OK;
+  }
+
+
+  /* Find minimum and maximum length, bound *m by those */
+  l = *m;
+  for (j = 1; j <= BMAX; j++)
+    if (c[j])
+      break;
+  k = j;                        /* minimum code length */
+  if ((uInt)l < j)
+    l = j;
+  for (i = BMAX; i; i--)
+    if (c[i])
+      break;
+  g = i;                        /* maximum code length */
+  if ((uInt)l > i)
+    l = i;
+  *m = l;
+
+
+  /* Adjust last length count to fill out codes, if needed */
+  for (y = 1 << j; j < i; j++, y <<= 1)
+    if ((y -= c[j]) < 0)
+      return Z_DATA_ERROR;
+  if ((y -= c[i]) < 0)
+    return Z_DATA_ERROR;
+  c[i] += y;
+
+
+  /* Generate starting offsets into the value table for each length */
+  x[1] = j = 0;
+  p = c + 1;  xp = x + 2;
+  while (--i) {                 /* note that i == g from above */
+    *xp++ = (j += *p++);
+  }
+
+
+  /* Make a table of values in order of bit lengths */
+  p = b;  i = 0;
+  do {
+    if ((j = *p++) != 0)
+      v[x[j]++] = i;
+  } while (++i < n);
+  n = x[g];                   /* set n to length of v */
+
+
+  /* Generate the Huffman codes and for each, make the table entries */
+  x[0] = i = 0;                 /* first Huffman code is zero */
+  p = v;                        /* grab values in bit order */
+  h = -1;                       /* no tables yet--level -1 */
+  w = -l;                       /* bits decoded == (l * h) */
+  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
+  q = (inflate_huft *)Z_NULL;   /* ditto */
+  z = 0;                        /* ditto */
+
+  /* go through the bit lengths (k already is bits in shortest code) */
+  for (; k <= g; k++)
+  {
+    a = c[k];
+    while (a--)
+    {
+      /* here i is the Huffman code of length k bits for value *p */
+      /* make tables up to required level */
+      while (k > w + l)
+      {
+        h++;
+        w += l;                 /* previous table always l bits */
+
+        /* compute minimum size table less than or equal to l bits */
+        z = g - w;
+        z = z > (uInt)l ? l : z;        /* table size upper limit */
+        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
+        {                       /* too few codes for k-w bit table */
+          f -= a + 1;           /* deduct codes from patterns left */
+          xp = c + k;
+          if (j < z)
+            while (++j < z)     /* try smaller tables up to z bits */
+            {
+              if ((f <<= 1) <= *++xp)
+                break;          /* enough codes to use up j bits */
+              f -= *xp;         /* else deduct codes from patterns */
+            }
+        }
+        z = 1 << j;             /* table entries for j-bit table */
+
+        /* allocate and link in new table */
+        if ((q = (inflate_huft *)ZALLOC
+             (zs,z + 1,sizeof(inflate_huft))) == Z_NULL)
+        {
+          if (h)
+            inflate_trees_free(u[0], zs);
+          return Z_MEM_ERROR;   /* not enough memory */
+        }
+#ifdef DEBUG_ZLIB
+        inflate_hufts += z + 1;
+#endif
+        *t = q + 1;             /* link to list for huft_free() */
+        *(t = &(q->next)) = Z_NULL;
+        u[h] = ++q;             /* table starts after link */
+
+        /* connect to last table, if there is one */
+        if (h)
+        {
+          x[h] = i;             /* save pattern for backing up */
+          r.bits = (Byte)l;     /* bits to dump before this table */
+          r.exop = (Byte)j;     /* bits in this table */
+          r.next = q;           /* pointer to this table */
+          j = i >> (w - l);     /* (get around Turbo C bug) */
+          u[h-1][j] = r;        /* connect to last table */
+        }
+      }
+
+      /* set up table entry in r */
+      r.bits = (Byte)(k - w);
+      if (p >= v + n)
+        r.exop = 128 + 64;      /* out of values--invalid code */
+      else if (*p < s)
+      {
+        r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */
+        r.base = *p++;          /* simple code is just the value */
+      }
+      else
+      {
+        r.exop = (Byte)(e[*p - s] + 16 + 64);/* non-simple--look up in lists */
+        r.base = d[*p++ - s];
+      }
+
+      /* fill code-like entries with r */
+      f = 1 << (k - w);
+      for (j = i >> w; j < z; j += f)
+        q[j] = r;
+
+      /* backwards increment the k-bit code i */
+      for (j = 1 << (k - 1); i & j; j >>= 1)
+        i ^= j;
+      i ^= j;
+
+      /* backup over finished tables */
+      while ((i & ((1 << w) - 1)) != x[h])
+      {
+        h--;                    /* don't need to update q */
+        w -= l;
+      }
+    }
+  }
+
+
+  /* Return Z_BUF_ERROR if we were given an incomplete table */
+  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
+}
+
+
+int inflate_trees_bits(c, bb, tb, z)
+uIntf *c;               /* 19 code lengths */
+uIntf *bb;              /* bits tree desired/actual depth */
+inflate_huft * FAR *tb; /* bits tree result */
+z_streamp z;            /* for zfree function */
+{
+  int r;
+
+  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL, tb, bb, z);
+  if (r == Z_DATA_ERROR)
+    z->msg = (char*)"oversubscribed dynamic bit lengths tree";
+  else if (r == Z_BUF_ERROR || *bb == 0)
+  {
+    inflate_trees_free(*tb, z);
+    z->msg = (char*)"incomplete dynamic bit lengths tree";
+    r = Z_DATA_ERROR;
+  }
+  return r;
+}
+
+
+int inflate_trees_dynamic(nl, nd, c, bl, bd, tl, td, z)
+uInt nl;                /* number of literal/length codes */
+uInt nd;                /* number of distance codes */
+uIntf *c;               /* that many (total) code lengths */
+uIntf *bl;              /* literal desired/actual bit depth */
+uIntf *bd;              /* distance desired/actual bit depth */
+inflate_huft * FAR *tl; /* literal/length tree result */
+inflate_huft * FAR *td; /* distance tree result */
+z_streamp z;            /* for zfree function */
+{
+  int r;
+
+  /* build literal/length tree */
+  r = huft_build(c, nl, 257, cplens, cplext, tl, bl, z);
+  if (r != Z_OK || *bl == 0)
+  {
+    if (r == Z_DATA_ERROR)
+      z->msg = (char*)"oversubscribed literal/length tree";
+    else if (r != Z_MEM_ERROR)
+    {
+      inflate_trees_free(*tl, z);
+      z->msg = (char*)"incomplete literal/length tree";
+      r = Z_DATA_ERROR;
+    }
+    return r;
+  }
+
+  /* build distance tree */
+  r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, z);
+  if (r != Z_OK || (*bd == 0 && nl > 257))
+  {
+    if (r == Z_DATA_ERROR)
+      z->msg = (char*)"oversubscribed distance tree";
+    else if (r == Z_BUF_ERROR) {
+#ifdef PKZIP_BUG_WORKAROUND
+      r = Z_OK;
+    }
+#else
+      inflate_trees_free(*td, z);
+      z->msg = (char*)"incomplete distance tree";
+      r = Z_DATA_ERROR;
+    }
+    else if (r != Z_MEM_ERROR)
+    {
+      z->msg = (char*)"empty distance tree with lengths";
+      r = Z_DATA_ERROR;
+    }
+    inflate_trees_free(*tl, z);
+    return r;
+#endif
+  }
+
+  /* done */
+  return Z_OK;
+}
+
+
+/* build fixed tables only once--keep them here */
+local int fixed_built = 0;
+#define FIXEDH 530      /* number of hufts used by fixed tables */
+local inflate_huft fixed_mem[FIXEDH];
+local uInt fixed_bl;
+local uInt fixed_bd;
+local inflate_huft *fixed_tl;
+local inflate_huft *fixed_td;
+
+
+local voidpf falloc(q, n, s)
+voidpf q;       /* opaque pointer */
+uInt n;         /* number of items */
+uInt s;         /* size of item */
+{
+  Assert(s == sizeof(inflate_huft) && n <= *(intf *)q,
+         "inflate_trees falloc overflow");
+  *(intf *)q -= n+s-s; /* s-s to avoid warning */
+  return (voidpf)(fixed_mem + *(intf *)q);
+}
+
+
+int inflate_trees_fixed(bl, bd, tl, td)
+uIntf *bl;               /* literal desired/actual bit depth */
+uIntf *bd;               /* distance desired/actual bit depth */
+inflate_huft * FAR *tl;  /* literal/length tree result */
+inflate_huft * FAR *td;  /* distance tree result */
+{
+  /* build fixed tables if not already (multiple overlapped executions ok) */
+  if (!fixed_built)
+  {
+    int k;              /* temporary variable */
+    unsigned c[288];    /* length list for huft_build */
+    z_stream z;         /* for falloc function */
+    int f = FIXEDH;     /* number of hufts left in fixed_mem */
+
+    /* set up fake z_stream for memory routines */
+    z.zalloc = falloc;
+    z.zfree = Z_NULL;
+    z.opaque = (voidpf)&f;
+
+    /* literal table */
+    for (k = 0; k < 144; k++)
+      c[k] = 8;
+    for (; k < 256; k++)
+      c[k] = 9;
+    for (; k < 280; k++)
+      c[k] = 7;
+    for (; k < 288; k++)
+      c[k] = 8;
+    fixed_bl = 7;
+    huft_build(c, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl, &z);
+
+    /* distance table */
+    for (k = 0; k < 30; k++)
+      c[k] = 5;
+    fixed_bd = 5;
+    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd, &z);
+
+    /* done */
+    Assert(f == 0, "invalid build of fixed tables");
+    fixed_built = 1;
+  }
+  *bl = fixed_bl;
+  *bd = fixed_bd;
+  *tl = fixed_tl;
+  *td = fixed_td;
+  return Z_OK;
+}
+
+
+int inflate_trees_free(t, z)
+inflate_huft *t;        /* table to free */
+z_streamp z;            /* for zfree function */
+/* Free the malloc'ed tables built by huft_build(), which makes a linked
+   list of the tables it made, with the links in a dummy first entry of
+   each table. */
+{
+  register inflate_huft *p, *q, *r;
+
+  /* Reverse linked list */
+  p = Z_NULL;
+  q = t;
+  while (q != Z_NULL)
+  {
+    r = (q - 1)->next;
+    (q - 1)->next = p;
+    p = q;
+    q = r;
+  }
+  /* Go through linked list, freeing from the malloced (t[-1]) address. */
+  while (p != Z_NULL)
+  {
+    q = (--p)->next;
+    ZFREE(z,p);
+    p = q;
+  } 
+  return Z_OK;
+}
+/* --- inftrees.c */
+
+/* +++ infcodes.c */
+/* infcodes.c -- process literals and length/distance pairs
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* #include "zutil.h" */
+/* #include "inftrees.h" */
+/* #include "infblock.h" */
+/* #include "infcodes.h" */
+/* #include "infutil.h" */
+
+/* +++ inffast.h */
+/* inffast.h -- header to use inffast.c
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+extern int inflate_fast OF((
+    uInt,
+    uInt,
+    inflate_huft *,
+    inflate_huft *,
+    inflate_blocks_statef *,
+    z_streamp ));
+/* --- inffast.h */
+
+/* simplify the use of the inflate_huft type with some defines */
+#define base more.Base
+#define next more.Next
+#define exop word.what.Exop
+#define bits word.what.Bits
+
+/* inflate codes private state */
+struct inflate_codes_state {
+
+  /* mode */
+  enum {        /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
+      START,    /* x: set up for LEN */
+      LEN,      /* i: get length/literal/eob next */
+      LENEXT,   /* i: getting length extra (have base) */
+      DIST,     /* i: get distance next */
+      DISTEXT,  /* i: getting distance extra */
+      COPY,     /* o: copying bytes in window, waiting for space */
+      LIT,      /* o: got literal, waiting for output space */
+      WASH,     /* o: got eob, possibly still output waiting */
+      END,      /* x: got eob and all data flushed */
+      BADCODE}  /* x: got error */
+    mode;               /* current inflate_codes mode */
+
+  /* mode dependent information */
+  uInt len;
+  union {
+    struct {
+      inflate_huft *tree;       /* pointer into tree */
+      uInt need;                /* bits needed */
+    } code;             /* if LEN or DIST, where in tree */
+    uInt lit;           /* if LIT, literal */
+    struct {
+      uInt get;                 /* bits to get for extra */
+      uInt dist;                /* distance back to copy from */
+    } copy;             /* if EXT or COPY, where and how much */
+  } sub;                /* submode */
+
+  /* mode independent information */
+  Byte lbits;           /* ltree bits decoded per branch */
+  Byte dbits;           /* dtree bits decoder per branch */
+  inflate_huft *ltree;          /* literal/length/eob tree */
+  inflate_huft *dtree;          /* distance tree */
+
+};
+
+
+inflate_codes_statef *inflate_codes_new(bl, bd, tl, td, z)
+uInt bl, bd;
+inflate_huft *tl;
+inflate_huft *td; /* need separate declaration for Borland C++ */
+z_streamp z;
+{
+  inflate_codes_statef *c;
+
+  if ((c = (inflate_codes_statef *)
+       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)
+  {
+    c->mode = START;
+    c->lbits = (Byte)bl;
+    c->dbits = (Byte)bd;
+    c->ltree = tl;
+    c->dtree = td;
+    Tracev((stderr, "inflate:       codes new\n"));
+  }
+  return c;
+}
+
+
+int inflate_codes(s, z, r)
+inflate_blocks_statef *s;
+z_streamp z;
+int r;
+{
+  uInt j;               /* temporary storage */
+  inflate_huft *t;      /* temporary pointer */
+  uInt e;               /* extra bits or operation */
+  uLong b;              /* bit buffer */
+  uInt k;               /* bits in bit buffer */
+  Bytef *p;             /* input data pointer */
+  uInt n;               /* bytes available there */
+  Bytef *q;             /* output window write pointer */
+  uInt m;               /* bytes to end of window or read pointer */
+  Bytef *f;             /* pointer to copy strings from */
+  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */
+
+  /* copy input/output information to locals (UPDATE macro restores) */
+  LOAD
+
+  /* process input and output based on current state */
+  while (1) switch (c->mode)
+  {             /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
+    case START:         /* x: set up for LEN */
+#ifndef SLOW
+      if (m >= 258 && n >= 10)
+      {
+        UPDATE
+        r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
+        LOAD
+        if (r != Z_OK)
+        {
+          c->mode = r == Z_STREAM_END ? WASH : BADCODE;
+          break;
+        }
+      }
+#endif /* !SLOW */
+      c->sub.code.need = c->lbits;
+      c->sub.code.tree = c->ltree;
+      c->mode = LEN;
+    case LEN:           /* i: get length/literal/eob next */
+      j = c->sub.code.need;
+      NEEDBITS(j)
+      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
+      DUMPBITS(t->bits)
+      e = (uInt)(t->exop);
+      if (e == 0)               /* literal */
+      {
+        c->sub.lit = t->base;
+        Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
+                 "inflate:         literal '%c'\n" :
+                 "inflate:         literal 0x%02x\n", t->base));
+        c->mode = LIT;
+        break;
+      }
+      if (e & 16)               /* length */
+      {
+        c->sub.copy.get = e & 15;
+        c->len = t->base;
+        c->mode = LENEXT;
+        break;
+      }
+      if ((e & 64) == 0)        /* next table */
+      {
+        c->sub.code.need = e;
+        c->sub.code.tree = t->next;
+        break;
+      }
+      if (e & 32)               /* end of block */
+      {
+        Tracevv((stderr, "inflate:         end of block\n"));
+        c->mode = WASH;
+        break;
+      }
+      c->mode = BADCODE;        /* invalid code */
+      z->msg = (char*)"invalid literal/length code";
+      r = Z_DATA_ERROR;
+      LEAVE
+    case LENEXT:        /* i: getting length extra (have base) */
+      j = c->sub.copy.get;
+      NEEDBITS(j)
+      c->len += (uInt)b & inflate_mask[j];
+      DUMPBITS(j)
+      c->sub.code.need = c->dbits;
+      c->sub.code.tree = c->dtree;
+      Tracevv((stderr, "inflate:         length %u\n", c->len));
+      c->mode = DIST;
+    case DIST:          /* i: get distance next */
+      j = c->sub.code.need;
+      NEEDBITS(j)
+      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
+      DUMPBITS(t->bits)
+      e = (uInt)(t->exop);
+      if (e & 16)               /* distance */
+      {
+        c->sub.copy.get = e & 15;
+        c->sub.copy.dist = t->base;
+        c->mode = DISTEXT;
+        break;
+      }
+      if ((e & 64) == 0)        /* next table */
+      {
+        c->sub.code.need = e;
+        c->sub.code.tree = t->next;
+        break;
+      }
+      c->mode = BADCODE;        /* invalid code */
+      z->msg = (char*)"invalid distance code";
+      r = Z_DATA_ERROR;
+      LEAVE
+    case DISTEXT:       /* i: getting distance extra */
+      j = c->sub.copy.get;
+      NEEDBITS(j)
+      c->sub.copy.dist += (uInt)b & inflate_mask[j];
+      DUMPBITS(j)
+      Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
+      c->mode = COPY;
+    case COPY:          /* o: copying bytes in window, waiting for space */
+#ifndef __TURBOC__ /* Turbo C bug for following expression */
+      f = (uInt)(q - s->window) < c->sub.copy.dist ?
+          s->end - (c->sub.copy.dist - (q - s->window)) :
+          q - c->sub.copy.dist;
+#else
+      f = q - c->sub.copy.dist;
+      if ((uInt)(q - s->window) < c->sub.copy.dist)
+        f = s->end - (c->sub.copy.dist - (uInt)(q - s->window));
+#endif
+      while (c->len)
+      {
+        NEEDOUT
+        OUTBYTE(*f++)
+        if (f == s->end)
+          f = s->window;
+        c->len--;
+      }
+      c->mode = START;
+      break;
+    case LIT:           /* o: got literal, waiting for output space */
+      NEEDOUT
+      OUTBYTE(c->sub.lit)
+      c->mode = START;
+      break;
+    case WASH:          /* o: got eob, possibly more output */
+      FLUSH
+      if (s->read != s->write)
+        LEAVE
+      c->mode = END;
+    case END:
+      r = Z_STREAM_END;
+      LEAVE
+    case BADCODE:       /* x: got error */
+      r = Z_DATA_ERROR;
+      LEAVE
+    default:
+      r = Z_STREAM_ERROR;
+      LEAVE
+  }
+}
+
+
+void inflate_codes_free(c, z)
+inflate_codes_statef *c;
+z_streamp z;
+{
+  ZFREE(z, c);
+  Tracev((stderr, "inflate:       codes free\n"));
+}
+/* --- infcodes.c */
+
+/* +++ infutil.c */
+/* inflate_util.c -- data and routines common to blocks and codes
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* #include "zutil.h" */
+/* #include "infblock.h" */
+/* #include "inftrees.h" */
+/* #include "infcodes.h" */
+/* #include "infutil.h" */
+
+#ifndef NO_DUMMY_DECL
+struct inflate_codes_state {int dummy;}; /* for buggy compilers */
+#endif
+
+/* And'ing with mask[n] masks the lower n bits */
+uInt inflate_mask[17] = {
+    0x0000,
+    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
+    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
+};
+
+
+/* copy as much as possible from the sliding window to the output area */
+int inflate_flush(s, z, r)
+inflate_blocks_statef *s;
+z_streamp z;
+int r;
+{
+  uInt n;
+  Bytef *p;
+  Bytef *q;
+
+  /* local copies of source and destination pointers */
+  p = z->next_out;
+  q = s->read;
+
+  /* compute number of bytes to copy as far as end of window */
+  n = (uInt)((q <= s->write ? s->write : s->end) - q);
+  if (n > z->avail_out) n = z->avail_out;
+  if (n && r == Z_BUF_ERROR) r = Z_OK;
+
+  /* update counters */
+  z->avail_out -= n;
+  z->total_out += n;
+
+  /* update check information */
+  if (s->checkfn != Z_NULL)
+    z->adler = s->check = (*s->checkfn)(s->check, q, n);
+
+  /* copy as far as end of window */
+  if (p != Z_NULL) {
+    zmemcpy(p, q, n);
+    p += n;
+  }
+  q += n;
+
+  /* see if more to copy at beginning of window */
+  if (q == s->end)
+  {
+    /* wrap pointers */
+    q = s->window;
+    if (s->write == s->end)
+      s->write = s->window;
+
+    /* compute bytes to copy */
+    n = (uInt)(s->write - q);
+    if (n > z->avail_out) n = z->avail_out;
+    if (n && r == Z_BUF_ERROR) r = Z_OK;
+
+    /* update counters */
+    z->avail_out -= n;
+    z->total_out += n;
+
+    /* update check information */
+    if (s->checkfn != Z_NULL)
+      z->adler = s->check = (*s->checkfn)(s->check, q, n);
+
+    /* copy */
+    if (p != Z_NULL) {
+      zmemcpy(p, q, n);
+      p += n;
+    }
+    q += n;
+  }
+
+  /* update pointers */
+  z->next_out = p;
+  s->read = q;
+
+  /* done */
+  return r;
+}
+/* --- infutil.c */
+
+/* +++ inffast.c */
+/* inffast.c -- process literals and length/distance pairs fast
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* #include "zutil.h" */
+/* #include "inftrees.h" */
+/* #include "infblock.h" */
+/* #include "infcodes.h" */
+/* #include "infutil.h" */
+/* #include "inffast.h" */
+
+#ifndef NO_DUMMY_DECL
+struct inflate_codes_state {int dummy;}; /* for buggy compilers */
+#endif
+
+/* simplify the use of the inflate_huft type with some defines */
+#define base more.Base
+#define next more.Next
+#define exop word.what.Exop
+#define bits word.what.Bits
+
+/* macros for bit input with no checking and for returning unused bytes */
+#define GRABBITS(j) {while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}
+#define UNGRAB {n+=(c=k>>3);p-=c;k&=7;}
+
+/* Called with number of bytes left to write in window at least 258
+   (the maximum string length) and number of input bytes available
+   at least ten.  The ten bytes are six bytes for the longest length/
+   distance pair plus four bytes for overloading the bit buffer. */
+
+int inflate_fast(bl, bd, tl, td, s, z)
+uInt bl, bd;
+inflate_huft *tl;
+inflate_huft *td; /* need separate declaration for Borland C++ */
+inflate_blocks_statef *s;
+z_streamp z;
+{
+  inflate_huft *t;      /* temporary pointer */
+  uInt e;               /* extra bits or operation */
+  uLong b;              /* bit buffer */
+  uInt k;               /* bits in bit buffer */
+  Bytef *p;             /* input data pointer */
+  uInt n;               /* bytes available there */
+  Bytef *q;             /* output window write pointer */
+  uInt m;               /* bytes to end of window or read pointer */
+  uInt ml;              /* mask for literal/length tree */
+  uInt md;              /* mask for distance tree */
+  uInt c;               /* bytes to copy */
+  uInt d;               /* distance back to copy from */
+  Bytef *r;             /* copy source pointer */
+
+  /* load input, output, bit values */
+  LOAD
+
+  /* initialize masks */
+  ml = inflate_mask[bl];
+  md = inflate_mask[bd];
+
+  /* do until not enough input or output space for fast loop */
+  do {                          /* assume called with m >= 258 && n >= 10 */
+    /* get literal/length code */
+    GRABBITS(20)                /* max bits for literal/length code */
+    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)
+    {
+      DUMPBITS(t->bits)
+      Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
+                "inflate:         * literal '%c'\n" :
+                "inflate:         * literal 0x%02x\n", t->base));
+      *q++ = (Byte)t->base;
+      m--;
+      continue;
+    }
+    do {
+      DUMPBITS(t->bits)
+      if (e & 16)
+      {
+        /* get extra bits for length */
+        e &= 15;
+        c = t->base + ((uInt)b & inflate_mask[e]);
+        DUMPBITS(e)
+        Tracevv((stderr, "inflate:         * length %u\n", c));
+
+        /* decode distance base of block to copy */
+        GRABBITS(15);           /* max bits for distance code */
+        e = (t = td + ((uInt)b & md))->exop;
+        do {
+          DUMPBITS(t->bits)
+          if (e & 16)
+          {
+            /* get extra bits to add to distance base */
+            e &= 15;
+            GRABBITS(e)         /* get extra bits (up to 13) */
+            d = t->base + ((uInt)b & inflate_mask[e]);
+            DUMPBITS(e)
+            Tracevv((stderr, "inflate:         * distance %u\n", d));
+
+            /* do the copy */
+            m -= c;
+            if ((uInt)(q - s->window) >= d)     /* offset before dest */
+            {                                   /*  just copy */
+              r = q - d;
+              *q++ = *r++;  c--;        /* minimum count is three, */
+              *q++ = *r++;  c--;        /*  so unroll loop a little */
+            }
+            else                        /* else offset after destination */
+            {
+              e = d - (uInt)(q - s->window); /* bytes from offset to end */
+              r = s->end - e;           /* pointer to offset */
+              if (c > e)                /* if source crosses, */
+              {
+                c -= e;                 /* copy to end of window */
+                do {
+                  *q++ = *r++;
+                } while (--e);
+                r = s->window;          /* copy rest from start of window */
+              }
+            }
+            do {                        /* copy all or what's left */
+              *q++ = *r++;
+            } while (--c);
+            break;
+          }
+          else if ((e & 64) == 0)
+            e = (t = t->next + ((uInt)b & inflate_mask[e]))->exop;
+          else
+          {
+            z->msg = (char*)"invalid distance code";
+            UNGRAB
+            UPDATE
+            return Z_DATA_ERROR;
+          }
+        } while (1);
+        break;
+      }
+      if ((e & 64) == 0)
+      {
+        if ((e = (t = t->next + ((uInt)b & inflate_mask[e]))->exop) == 0)
+        {
+          DUMPBITS(t->bits)
+          Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
+                    "inflate:         * literal '%c'\n" :
+                    "inflate:         * literal 0x%02x\n", t->base));
+          *q++ = (Byte)t->base;
+          m--;
+          break;
+        }
+      }
+      else if (e & 32)
+      {
+        Tracevv((stderr, "inflate:         * end of block\n"));
+        UNGRAB
+        UPDATE
+        return Z_STREAM_END;
+      }
+      else
+      {
+        z->msg = (char*)"invalid literal/length code";
+        UNGRAB
+        UPDATE
+        return Z_DATA_ERROR;
+      }
+    } while (1);
+  } while (m >= 258 && n >= 10);
+
+  /* not enough input or output--restore pointers and return */
+  UNGRAB
+  UPDATE
+  return Z_OK;
+}
+/* --- inffast.c */
+
+/* +++ zutil.c */
+/* zutil.c -- target dependent utility functions for the compression library
+ * Copyright (C) 1995-1996 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* From: zutil.c,v 1.17 1996/07/24 13:41:12 me Exp $ */
+
+/* #include "zutil.h" */
+
+#ifndef NO_DUMMY_DECL
+struct internal_state      {int dummy;}; /* for buggy compilers */
+#endif
+
+#ifndef STDC
+extern void exit OF((int));
+#endif
+
+const char *z_errmsg[10] = {
+"need dictionary",     /* Z_NEED_DICT       2  */
+"stream end",          /* Z_STREAM_END      1  */
+"",                    /* Z_OK              0  */
+"file error",          /* Z_ERRNO         (-1) */
+"stream error",        /* Z_STREAM_ERROR  (-2) */
+"data error",          /* Z_DATA_ERROR    (-3) */
+"insufficient memory", /* Z_MEM_ERROR     (-4) */
+"buffer error",        /* Z_BUF_ERROR     (-5) */
+"incompatible version",/* Z_VERSION_ERROR (-6) */
+""};
+
+
+const char *zlibVersion()
+{
+    return ZLIB_VERSION;
+}
+
+#ifdef DEBUG_ZLIB
+void z_error (m)
+    char *m;
+{
+    fprintf(stderr, "%s\n", m);
+    exit(1);
+}
+#endif
+
+#ifndef HAVE_MEMCPY
+
+void zmemcpy(dest, source, len)
+    Bytef* dest;
+    Bytef* source;
+    uInt  len;
+{
+    if (len == 0) return;
+    do {
+        *dest++ = *source++; /* ??? to be unrolled */
+    } while (--len != 0);
+}
+
+int zmemcmp(s1, s2, len)
+    Bytef* s1;
+    Bytef* s2;
+    uInt  len;
+{
+    uInt j;
+
+    for (j = 0; j < len; j++) {
+        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
+    }
+    return 0;
+}
+
+void zmemzero(dest, len)
+    Bytef* dest;
+    uInt  len;
+{
+    if (len == 0) return;
+    do {
+        *dest++ = 0;  /* ??? to be unrolled */
+    } while (--len != 0);
+}
+#endif
+
+#ifdef __TURBOC__
+#if (defined( __BORLANDC__) || !defined(SMALL_MEDIUM)) && !defined(__32BIT__)
+/* Small and medium model in Turbo C are for now limited to near allocation
+ * with reduced MAX_WBITS and MAX_MEM_LEVEL
+ */
+#  define MY_ZCALLOC
+
+/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
+ * and farmalloc(64K) returns a pointer with an offset of 8, so we
+ * must fix the pointer. Warning: the pointer must be put back to its
+ * original form in order to free it, use zcfree().
+ */
+
+#define MAX_PTR 10
+/* 10*64K = 640K */
+
+local int next_ptr = 0;
+
+typedef struct ptr_table_s {
+    voidpf org_ptr;
+    voidpf new_ptr;
+} ptr_table;
+
+local ptr_table table[MAX_PTR];
+/* This table is used to remember the original form of pointers
+ * to large buffers (64K). Such pointers are normalized with a zero offset.
+ * Since MSDOS is not a preemptive multitasking OS, this table is not
+ * protected from concurrent access. This hack doesn't work anyway on
+ * a protected system like OS/2. Use Microsoft C instead.
+ */
+
+voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
+{
+    voidpf buf = opaque; /* just to make some compilers happy */
+    ulg bsize = (ulg)items*size;
+
+    /* If we allocate less than 65520 bytes, we assume that farmalloc
+     * will return a usable pointer which doesn't have to be normalized.
+     */
+    if (bsize < 65520L) {
+        buf = farmalloc(bsize);
+        if (*(ush*)&buf != 0) return buf;
+    } else {
+        buf = farmalloc(bsize + 16L);
+    }
+    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
+    table[next_ptr].org_ptr = buf;
+
+    /* Normalize the pointer to seg:0 */
+    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
+    *(ush*)&buf = 0;
+    table[next_ptr++].new_ptr = buf;
+    return buf;
+}
+
+void  zcfree (voidpf opaque, voidpf ptr)
+{
+    int n;
+    if (*(ush*)&ptr != 0) { /* object < 64K */
+        farfree(ptr);
+        return;
+    }
+    /* Find the original pointer */
+    for (n = 0; n < next_ptr; n++) {
+        if (ptr != table[n].new_ptr) continue;
+
+        farfree(table[n].org_ptr);
+        while (++n < next_ptr) {
+            table[n-1] = table[n];
+        }
+        next_ptr--;
+        return;
+    }
+    ptr = opaque; /* just to make some compilers happy */
+    Assert(0, "zcfree: ptr not found");
+}
+#endif
+#endif /* __TURBOC__ */
+
+
+#if defined(M_I86) && !defined(__32BIT__)
+/* Microsoft C in 16-bit mode */
+
+#  define MY_ZCALLOC
+
+#if (!defined(_MSC_VER) || (_MSC_VER < 600))
+#  define _halloc  halloc
+#  define _hfree   hfree
+#endif
+
+voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
+{
+    if (opaque) opaque = 0; /* to make compiler happy */
+    return _halloc((long)items, size);
+}
+
+void  zcfree (voidpf opaque, voidpf ptr)
+{
+    if (opaque) opaque = 0; /* to make compiler happy */
+    _hfree(ptr);
+}
+
+#endif /* MSC */
+
+
+#ifndef MY_ZCALLOC /* Any system without a special alloc function */
+
+#ifndef STDC
+extern voidp  calloc OF((uInt items, uInt size));
+extern void   free   OF((voidpf ptr));
+#endif
+
+voidpf zcalloc (opaque, items, size)
+    voidpf opaque;
+    unsigned items;
+    unsigned size;
+{
+    if (opaque) items += size - size; /* make compiler happy */
+    return (voidpf)calloc(items, size);
+}
+
+void  zcfree (opaque, ptr)
+    voidpf opaque;
+    voidpf ptr;
+{
+    free(ptr);
+    if (opaque) return; /* make compiler happy */
+}
+
+#endif /* MY_ZCALLOC */
+/* --- zutil.c */
+
+/* +++ adler32.c */
+/* adler32.c -- compute the Adler-32 checksum of a data stream
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* From: adler32.c,v 1.10 1996/05/22 11:52:18 me Exp $ */
+
+/* #include "zlib.h" */
+
+#define BASE 65521L /* largest prime smaller than 65536 */
+#define NMAX 5552
+/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
+
+#define DO1(buf,i)  {s1 += buf[i]; s2 += s1;}
+#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
+#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
+#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
+#define DO16(buf)   DO8(buf,0); DO8(buf,8);
+
+/* ========================================================================= */
+uLong adler32(adler, buf, len)
+    uLong adler;
+    const Bytef *buf;
+    uInt len;
+{
+    unsigned long s1 = adler & 0xffff;
+    unsigned long s2 = (adler >> 16) & 0xffff;
+    int k;
+
+    if (buf == Z_NULL) return 1L;
+
+    while (len > 0) {
+        k = len < NMAX ? len : NMAX;
+        len -= k;
+        while (k >= 16) {
+            DO16(buf);
+	    buf += 16;
+            k -= 16;
+        }
+        if (k != 0) do {
+            s1 += *buf++;
+	    s2 += s1;
+        } while (--k);
+        s1 %= BASE;
+        s2 %= BASE;
+    }
+    return (s2 << 16) | s1;
+}
+/* --- adler32.c */
+
+#endif /* CONFIG_PPP_DEFLATE */
diff -Nur linux/fs/jffs2/zlib.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/zlib.h
--- linux/fs/jffs2/zlib.h	1970-01-01 07:00:00.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/fs/jffs2/zlib.h	2003-06-23 01:47:04.000000000 +0700
@@ -0,0 +1,1010 @@
+/*	$Id: zlib.h,v 1.2 1997/12/23 10:47:44 paulus Exp $	*/
+
+/*
+ * This file is derived from zlib.h and zconf.h from the zlib-1.0.4
+ * distribution by Jean-loup Gailly and Mark Adler, with some additions
+ * by Paul Mackerras to aid in implementing Deflate compression and
+ * decompression for PPP packets.
+ */
+
+/*
+ *  ==FILEVERSION 971127==
+ *
+ * This marker is used by the Linux installation script to determine
+ * whether an up-to-date version of this file is already installed.
+ */
+
+
+/* +++ zlib.h */
+/* zlib.h -- interface of the 'zlib' general purpose compression library
+  version 1.0.4, Jul 24th, 1996.
+
+  Copyright (C) 1995-1996 Jean-loup Gailly and Mark Adler
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Jean-loup Gailly        Mark Adler
+  gzip@prep.ai.mit.edu    madler@alumni.caltech.edu
+
+
+  The data format used by the zlib library is described by RFCs (Request for
+  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
+  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
+*/
+
+#ifndef _ZLIB_H
+#define _ZLIB_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* +++ zconf.h */
+/* zconf.h -- configuration of the zlib compression library
+ * Copyright (C) 1995-1996 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* From: zconf.h,v 1.20 1996/07/02 15:09:28 me Exp $ */
+
+#ifndef _ZCONF_H
+#define _ZCONF_H
+
+/*
+ * If you *really* need a unique prefix for all types and library functions,
+ * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
+ */
+#ifdef Z_PREFIX
+#  define deflateInit_	z_deflateInit_
+#  define deflate	z_deflate
+#  define deflateEnd	z_deflateEnd
+#  define inflateInit_ 	z_inflateInit_
+#  define inflate	z_inflate
+#  define inflateEnd	z_inflateEnd
+#  define deflateInit2_	z_deflateInit2_
+#  define deflateSetDictionary z_deflateSetDictionary
+#  define deflateCopy	z_deflateCopy
+#  define deflateReset	z_deflateReset
+#  define deflateParams	z_deflateParams
+#  define inflateInit2_	z_inflateInit2_
+#  define inflateSetDictionary z_inflateSetDictionary
+#  define inflateSync	z_inflateSync
+#  define inflateReset	z_inflateReset
+#  define compress	z_compress
+#  define uncompress	z_uncompress
+#  define adler32	z_adler32
+#  define crc32		z_crc32
+#  define get_crc_table z_get_crc_table
+
+#  define Byte		z_Byte
+#  define uInt		z_uInt
+#  define uLong		z_uLong
+#  define Bytef	        z_Bytef
+#  define charf		z_charf
+#  define intf		z_intf
+#  define uIntf		z_uIntf
+#  define uLongf	z_uLongf
+#  define voidpf	z_voidpf
+#  define voidp		z_voidp
+#endif
+
+#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
+#  define WIN32
+#endif
+#if defined(__GNUC__) || defined(WIN32) || defined(__386__) || defined(i386)
+#  ifndef __32BIT__
+#    define __32BIT__
+#  endif
+#endif
+#if defined(__MSDOS__) && !defined(MSDOS)
+#  define MSDOS
+#endif
+
+/*
+ * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
+ * than 64k bytes at a time (needed on systems with 16-bit int).
+ */
+#if defined(MSDOS) && !defined(__32BIT__)
+#  define MAXSEG_64K
+#endif
+#ifdef MSDOS
+#  define UNALIGNED_OK
+#endif
+
+#if (defined(MSDOS) || defined(_WINDOWS) || defined(WIN32))  && !defined(STDC)
+#  define STDC
+#endif
+#if (defined(__STDC__) || defined(__cplusplus)) && !defined(STDC)
+#  define STDC
+#endif
+
+#ifndef STDC
+#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
+#    define const
+#  endif
+#endif
+
+/* Some Mac compilers merge all .h files incorrectly: */
+#if defined(__MWERKS__) || defined(applec) ||defined(THINK_C) ||defined(__SC__)
+#  define NO_DUMMY_DECL
+#endif
+
+/* Maximum value for memLevel in deflateInit2 */
+#ifndef MAX_MEM_LEVEL
+#  ifdef MAXSEG_64K
+#    define MAX_MEM_LEVEL 8
+#  else
+#    define MAX_MEM_LEVEL 9
+#  endif
+#endif
+
+/* Maximum value for windowBits in deflateInit2 and inflateInit2 */
+#ifndef MAX_WBITS
+#  define MAX_WBITS   15 /* 32K LZ77 window */
+#endif
+
+/* The memory requirements for deflate are (in bytes):
+            1 << (windowBits+2)   +  1 << (memLevel+9)
+ that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
+ plus a few kilobytes for small objects. For example, if you want to reduce
+ the default memory requirements from 256K to 128K, compile with
+     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
+ Of course this will generally degrade compression (there's no free lunch).
+
+   The memory requirements for inflate are (in bytes) 1 << windowBits
+ that is, 32K for windowBits=15 (default value) plus a few kilobytes
+ for small objects.
+*/
+
+                        /* Type declarations */
+
+#ifndef OF /* function prototypes */
+#  ifdef STDC
+#    define OF(args)  args
+#  else
+#    define OF(args)  ()
+#  endif
+#endif
+
+/* The following definitions for FAR are needed only for MSDOS mixed
+ * model programming (small or medium model with some far allocations).
+ * This was tested only with MSC; for other MSDOS compilers you may have
+ * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
+ * just define FAR to be empty.
+ */
+#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(__32BIT__)
+   /* MSC small or medium model */
+#  define SMALL_MEDIUM
+#  ifdef _MSC_VER
+#    define FAR __far
+#  else
+#    define FAR far
+#  endif
+#endif
+#if defined(__BORLANDC__) && (defined(__SMALL__) || defined(__MEDIUM__))
+#  ifndef __32BIT__
+#    define SMALL_MEDIUM
+#    define FAR __far
+#  endif
+#endif
+#ifndef FAR
+#   define FAR
+#endif
+
+typedef unsigned char  Byte;  /* 8 bits */
+typedef unsigned int   uInt;  /* 16 bits or more */
+typedef unsigned long  uLong; /* 32 bits or more */
+
+#if defined(__BORLANDC__) && defined(SMALL_MEDIUM)
+   /* Borland C/C++ ignores FAR inside typedef */
+#  define Bytef Byte FAR
+#else
+   typedef Byte  FAR Bytef;
+#endif
+typedef char  FAR charf;
+typedef int   FAR intf;
+typedef uInt  FAR uIntf;
+typedef uLong FAR uLongf;
+
+#ifdef STDC
+   typedef void FAR *voidpf;
+   typedef void     *voidp;
+#else
+   typedef Byte FAR *voidpf;
+   typedef Byte     *voidp;
+#endif
+
+
+/* Compile with -DZLIB_DLL for Windows DLL support */
+#if (defined(_WINDOWS) || defined(WINDOWS)) && defined(ZLIB_DLL)
+#  include <windows.h>
+#  define EXPORT  WINAPI
+#else
+#  define EXPORT
+#endif
+
+#endif /* _ZCONF_H */
+/* --- zconf.h */
+
+#define ZLIB_VERSION "1.0.4P"
+
+/* 
+     The 'zlib' compression library provides in-memory compression and
+  decompression functions, including integrity checks of the uncompressed
+  data.  This version of the library supports only one compression method
+  (deflation) but other algorithms may be added later and will have the same
+  stream interface.
+
+     For compression the application must provide the output buffer and
+  may optionally provide the input buffer for optimization. For decompression,
+  the application must provide the input buffer and may optionally provide
+  the output buffer for optimization.
+
+     Compression can be done in a single step if the buffers are large
+  enough (for example if an input file is mmap'ed), or can be done by
+  repeated calls of the compression function.  In the latter case, the
+  application must provide more input and/or consume the output
+  (providing more output space) before each call.
+
+     The library does not install any signal handler. It is recommended to
+  add at least a handler for SIGSEGV when decompressing; the library checks
+  the consistency of the input data whenever possible but may go nuts
+  for some forms of corrupted input.
+*/
+
+typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
+typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
+
+struct internal_state;
+
+typedef struct z_stream_s {
+    Bytef    *next_in;  /* next input byte */
+    uInt     avail_in;  /* number of bytes available at next_in */
+    uLong    total_in;  /* total nb of input bytes read so far */
+
+    Bytef    *next_out; /* next output byte should be put there */
+    uInt     avail_out; /* remaining free space at next_out */
+    uLong    total_out; /* total nb of bytes output so far */
+
+    char     *msg;      /* last error message, NULL if no error */
+    struct internal_state FAR *state; /* not visible by applications */
+
+    alloc_func zalloc;  /* used to allocate the internal state */
+    free_func  zfree;   /* used to free the internal state */
+    voidpf     opaque;  /* private data object passed to zalloc and zfree */
+
+    int     data_type;  /* best guess about the data type: ascii or binary */
+    uLong   adler;      /* adler32 value of the uncompressed data */
+    uLong   reserved;   /* reserved for future use */
+} z_stream;
+
+typedef z_stream FAR *z_streamp;
+
+/*
+   The application must update next_in and avail_in when avail_in has
+   dropped to zero. It must update next_out and avail_out when avail_out
+   has dropped to zero. The application must initialize zalloc, zfree and
+   opaque before calling the init function. All other fields are set by the
+   compression library and must not be updated by the application.
+
+   The opaque value provided by the application will be passed as the first
+   parameter for calls of zalloc and zfree. This can be useful for custom
+   memory management. The compression library attaches no meaning to the
+   opaque value.
+
+   zalloc must return Z_NULL if there is not enough memory for the object.
+   On 16-bit systems, the functions zalloc and zfree must be able to allocate
+   exactly 65536 bytes, but will not be required to allocate more than this
+   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
+   pointers returned by zalloc for objects of exactly 65536 bytes *must*
+   have their offset normalized to zero. The default allocation function
+   provided by this library ensures this (see zutil.c). To reduce memory
+   requirements and avoid any allocation of 64K objects, at the expense of
+   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
+
+   The fields total_in and total_out can be used for statistics or
+   progress reports. After compression, total_in holds the total size of
+   the uncompressed data and may be saved for use in the decompressor
+   (particularly if the decompressor wants to decompress everything in
+   a single step).
+*/
+
+                        /* constants */
+
+#define Z_NO_FLUSH      0
+#define Z_PARTIAL_FLUSH 1
+#define Z_PACKET_FLUSH	2
+#define Z_SYNC_FLUSH    3
+#define Z_FULL_FLUSH    4
+#define Z_FINISH        5
+/* Allowed flush values; see deflate() below for details */
+
+#define Z_OK            0
+#define Z_STREAM_END    1
+#define Z_NEED_DICT     2
+#define Z_ERRNO        (-1)
+#define Z_STREAM_ERROR (-2)
+#define Z_DATA_ERROR   (-3)
+#define Z_MEM_ERROR    (-4)
+#define Z_BUF_ERROR    (-5)
+#define Z_VERSION_ERROR (-6)
+/* Return codes for the compression/decompression functions. Negative
+ * values are errors, positive values are used for special but normal events.
+ */
+
+#define Z_NO_COMPRESSION         0
+#define Z_BEST_SPEED             1
+#define Z_BEST_COMPRESSION       9
+#define Z_DEFAULT_COMPRESSION  (-1)
+/* compression levels */
+
+#define Z_FILTERED            1
+#define Z_HUFFMAN_ONLY        2
+#define Z_DEFAULT_STRATEGY    0
+/* compression strategy; see deflateInit2() below for details */
+
+#define Z_BINARY   0
+#define Z_ASCII    1
+#define Z_UNKNOWN  2
+/* Possible values of the data_type field */
+
+#define Z_DEFLATED   8
+/* The deflate compression method (the only one supported in this version) */
+
+#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
+
+#define zlib_version zlibVersion()
+/* for compatibility with versions < 1.0.2 */
+
+                        /* basic functions */
+
+extern const char * EXPORT zlibVersion OF((void));
+/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
+   If the first character differs, the library code actually used is
+   not compatible with the zlib.h header file used by the application.
+   This check is automatically made by deflateInit and inflateInit.
+ */
+
+/* 
+extern int EXPORT deflateInit OF((z_streamp strm, int level));
+
+     Initializes the internal stream state for compression. The fields
+   zalloc, zfree and opaque must be initialized before by the caller.
+   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
+   use default allocation functions.
+
+     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
+   1 gives best speed, 9 gives best compression, 0 gives no compression at
+   all (the input data is simply copied a block at a time).
+   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
+   compression (currently equivalent to level 6).
+
+     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
+   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
+   with the version assumed by the caller (ZLIB_VERSION).
+   msg is set to null if there is no error message.  deflateInit does not
+   perform any compression: this will be done by deflate().
+*/
+
+
+extern int EXPORT deflate OF((z_streamp strm, int flush));
+/*
+  Performs one or both of the following actions:
+
+  - Compress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in and avail_in are updated and
+    processing will resume at this point for the next call of deflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly. This action is forced if the parameter flush is non zero.
+    Forcing flush frequently degrades the compression ratio, so this parameter
+    should be set only when necessary (in interactive applications).
+    Some output may be provided even if flush is not set.
+
+  Before the call of deflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating avail_in or avail_out accordingly; avail_out
+  should never be zero before the call. The application can consume the
+  compressed output when it wants, for example when the output buffer is full
+  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
+  and with zero avail_out, it must be called again after making room in the
+  output buffer because there might be more output pending.
+
+    If the parameter flush is set to Z_PARTIAL_FLUSH, the current compression
+  block is terminated and flushed to the output buffer so that the
+  decompressor can get all input data available so far. For method 9, a future
+  variant on method 8, the current block will be flushed but not terminated.
+  Z_SYNC_FLUSH has the same effect as partial flush except that the compressed
+  output is byte aligned (the compressor can clear its internal bit buffer)
+  and the current block is always terminated; this can be useful if the
+  compressor has to be restarted from scratch after an interruption (in which
+  case the internal state of the compressor may be lost).
+    If flush is set to Z_FULL_FLUSH, the compression block is terminated, a
+  special marker is output and the compression dictionary is discarded; this
+  is useful to allow the decompressor to synchronize if one compressed block
+  has been damaged (see inflateSync below).  Flushing degrades compression and
+  so should be used only when necessary.  Using Z_FULL_FLUSH too often can
+  seriously degrade the compression. If deflate returns with avail_out == 0,
+  this function must be called again with the same value of the flush
+  parameter and more output space (updated avail_out), until the flush is
+  complete (deflate returns with non-zero avail_out).
+
+    If the parameter flush is set to Z_PACKET_FLUSH, the compression
+  block is terminated, and a zero-length stored block is output,
+  omitting the length bytes (the effect of this is that the 3-bit type
+  code 000 for a stored block is output, and the output is then
+  byte-aligned).  This is designed for use at the end of a PPP packet.
+
+    If the parameter flush is set to Z_FINISH, pending input is processed,
+  pending output is flushed and deflate returns with Z_STREAM_END if there
+  was enough output space; if deflate returns with Z_OK, this function must be
+  called again with Z_FINISH and more output space (updated avail_out) but no
+  more input data, until it returns with Z_STREAM_END or an error. After
+  deflate has returned Z_STREAM_END, the only possible operations on the
+  stream are deflateReset or deflateEnd.
+  
+    Z_FINISH can be used immediately after deflateInit if all the compression
+  is to be done in a single step. In this case, avail_out must be at least
+  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
+  Z_STREAM_END, then it must be called again as described above.
+
+    deflate() may update data_type if it can make a good guess about
+  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
+  binary. This field is only for information purposes and does not affect
+  the compression algorithm in any manner.
+
+    deflate() returns Z_OK if some progress has been made (more input
+  processed or more output produced), Z_STREAM_END if all input has been
+  consumed and all output has been produced (only when flush is set to
+  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
+  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible.
+*/
+
+
+extern int EXPORT deflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
+   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
+   prematurely (some input or output was discarded). In the error case,
+   msg may be set but then points to a static string (which must not be
+   deallocated).
+*/
+
+
+/* 
+extern int EXPORT inflateInit OF((z_streamp strm));
+
+     Initializes the internal stream state for decompression. The fields
+   zalloc, zfree and opaque must be initialized before by the caller.  If
+   zalloc and zfree are set to Z_NULL, inflateInit updates them to use default
+   allocation functions.
+
+     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_VERSION_ERROR if the zlib library version is incompatible
+   with the version assumed by the caller.  msg is set to null if there is no
+   error message. inflateInit does not perform any decompression: this will be
+   done by inflate().
+*/
+
+
+extern int EXPORT inflate OF((z_streamp strm, int flush));
+/*
+  Performs one or both of the following actions:
+
+  - Decompress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in is updated and processing
+    will resume at this point for the next call of inflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly.  inflate() provides as much output as possible, until there
+    is no more input data or no more space in the output buffer (see below
+    about the flush parameter).
+
+  Before the call of inflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating the next_* and avail_* values accordingly.
+  The application can consume the uncompressed output when it wants, for
+  example when the output buffer is full (avail_out == 0), or after each
+  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
+  must be called again after making room in the output buffer because there
+  might be more output pending.
+
+    If the parameter flush is set to Z_PARTIAL_FLUSH or Z_PACKET_FLUSH,
+  inflate flushes as much output as possible to the output buffer. The
+  flushing behavior of inflate is not specified for values of the flush
+  parameter other than Z_PARTIAL_FLUSH, Z_PACKET_FLUSH or Z_FINISH, but the
+  current implementation actually flushes as much output as possible
+  anyway.  For Z_PACKET_FLUSH, inflate checks that once all the input data
+  has been consumed, it is expecting to see the length field of a stored
+  block; if not, it returns Z_DATA_ERROR.
+
+    inflate() should normally be called until it returns Z_STREAM_END or an
+  error. However if all decompression is to be performed in a single step
+  (a single call of inflate), the parameter flush should be set to
+  Z_FINISH. In this case all pending input is processed and all pending
+  output is flushed; avail_out must be large enough to hold all the
+  uncompressed data. (The size of the uncompressed data may have been saved
+  by the compressor for this purpose.) The next operation on this stream must
+  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
+  is never required, but can be used to inform inflate that a faster routine
+  may be used for the single inflate() call.
+
+    inflate() returns Z_OK if some progress has been made (more input
+  processed or more output produced), Z_STREAM_END if the end of the
+  compressed data has been reached and all uncompressed output has been
+  produced, Z_NEED_DICT if a preset dictionary is needed at this point (see
+  inflateSetDictionary below), Z_DATA_ERROR if the input data was corrupted,
+  Z_STREAM_ERROR if the stream structure was inconsistent (for example if
+  next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,
+  Z_BUF_ERROR if no progress is possible or if there was not enough room in
+  the output buffer when Z_FINISH is used. In the Z_DATA_ERROR case, the
+  application may then call inflateSync to look for a good compression block.
+  In the Z_NEED_DICT case, strm->adler is set to the Adler32 value of the
+  dictionary chosen by the compressor.
+*/
+
+
+extern int EXPORT inflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
+   was inconsistent. In the error case, msg may be set but then points to a
+   static string (which must not be deallocated).
+*/
+
+                        /* Advanced functions */
+
+/*
+    The following functions are needed only in some special applications.
+*/
+
+/*   
+extern int EXPORT deflateInit2 OF((z_streamp strm,
+                                   int  level,
+                                   int  method,
+                                   int  windowBits,
+                                   int  memLevel,
+                                   int  strategy));
+
+     This is another version of deflateInit with more compression options. The
+   fields next_in, zalloc, zfree and opaque must be initialized before by
+   the caller.
+
+     The method parameter is the compression method. It must be Z_DEFLATED in
+   this version of the library. (Method 9 will allow a 64K history buffer and
+   partial block flushes.)
+
+     The windowBits parameter is the base two logarithm of the window size
+   (the size of the history buffer).  It should be in the range 8..15 for this
+   version of the library (the value 16 will be allowed for method 9). Larger
+   values of this parameter result in better compression at the expense of
+   memory usage. The default value is 15 if deflateInit is used instead.
+
+     The memLevel parameter specifies how much memory should be allocated
+   for the internal compression state. memLevel=1 uses minimum memory but
+   is slow and reduces compression ratio; memLevel=9 uses maximum memory
+   for optimal speed. The default value is 8. See zconf.h for total memory
+   usage as a function of windowBits and memLevel.
+
+     The strategy parameter is used to tune the compression algorithm. Use the
+   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
+   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
+   string match).  Filtered data consists mostly of small values with a
+   somewhat random distribution. In this case, the compression algorithm is
+   tuned to compress them better. The effect of Z_FILTERED is to force more
+   Huffman coding and less string matching; it is somewhat intermediate
+   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
+   the compression ratio but not the correctness of the compressed output even
+   if it is not set appropriately.
+
+     If next_in is not null, the library will use this buffer to hold also
+   some history information; the buffer must either hold the entire input
+   data, or have at least 1<<(windowBits+1) bytes and be writable. If next_in
+   is null, the library will allocate its own history buffer (and leave next_in
+   null). next_out need not be provided here but must be provided by the
+   application for the next call of deflate().
+
+     If the history buffer is provided by the application, next_in must
+   must never be changed by the application since the compressor maintains
+   information inside this buffer from call to call; the application
+   must provide more input only by increasing avail_in. next_in is always
+   reset by the library in this case.
+
+      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was
+   not enough memory, Z_STREAM_ERROR if a parameter is invalid (such as
+   an invalid method). msg is set to null if there is no error message.
+   deflateInit2 does not perform any compression: this will be done by
+   deflate(). 
+*/
+                            
+extern int EXPORT deflateSetDictionary OF((z_streamp strm,
+                                           const Bytef *dictionary,
+				           uInt  dictLength));
+/*
+     Initializes the compression dictionary (history buffer) from the given
+   byte sequence without producing any compressed output. This function must
+   be called immediately after deflateInit or deflateInit2, before any call
+   of deflate. The compressor and decompressor must use exactly the same
+   dictionary (see inflateSetDictionary).
+     The dictionary should consist of strings (byte sequences) that are likely
+   to be encountered later in the data to be compressed, with the most commonly
+   used strings preferably put towards the end of the dictionary. Using a
+   dictionary is most useful when the data to be compressed is short and
+   can be predicted with good accuracy; the data can then be compressed better
+   than with the default empty dictionary. In this version of the library,
+   only the last 32K bytes of the dictionary are used.
+     Upon return of this function, strm->adler is set to the Adler32 value
+   of the dictionary; the decompressor may later use this value to determine
+   which dictionary has been used by the compressor. (The Adler32 value
+   applies to the whole dictionary even if only a subset of the dictionary is
+   actually used by the compressor.)
+
+     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state
+   is inconsistent (for example if deflate has already been called for this
+   stream). deflateSetDictionary does not perform any compression: this will
+   be done by deflate(). 
+*/
+
+extern int EXPORT deflateCopy OF((z_streamp dest,
+                                  z_streamp source));
+/*
+     Sets the destination stream as a complete copy of the source stream.  If
+   the source stream is using an application-supplied history buffer, a new
+   buffer is allocated for the destination stream.  The compressed output
+   buffer is always application-supplied. It's the responsibility of the
+   application to provide the correct values of next_out and avail_out for the
+   next call of deflate.
+
+     This function can be useful when several compression strategies will be
+   tried, for example when there are several ways of pre-processing the input
+   data with a filter. The streams that will be discarded should then be freed
+   by calling deflateEnd.  Note that deflateCopy duplicates the internal
+   compression state which can be quite large, so this strategy is slow and
+   can consume lots of memory.
+
+     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+   (such as zalloc being NULL). msg is left unchanged in both source and
+   destination.
+*/
+
+extern int EXPORT deflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to deflateEnd followed by deflateInit,
+   but does not free and reallocate all the internal compression state.
+   The stream will keep the same compression level and any other attributes
+   that may have been set by deflateInit2.
+
+      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+extern int EXPORT deflateParams OF((z_streamp strm, int level, int strategy));
+/*
+     Dynamically update the compression level and compression strategy.
+   This can be used to switch between compression and straight copy of
+   the input data, or to switch to a different kind of input data requiring
+   a different strategy. If the compression level is changed, the input
+   available so far is compressed with the old level (and may be flushed);
+   the new level will take effect only at the next call of deflate().
+
+     Before the call of deflateParams, the stream state must be set as for
+   a call of deflate(), since the currently available input may have to
+   be compressed and flushed. In particular, strm->avail_out must be non-zero.
+
+     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
+   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
+   if strm->avail_out was zero.
+*/
+
+extern int EXPORT deflateOutputPending OF((z_streamp strm));
+/*
+     Returns the number of bytes of output which are immediately
+   available from the compressor (i.e. without any further input
+   or flush).
+*/
+
+/*   
+extern int EXPORT inflateInit2 OF((z_streamp strm,
+                                   int  windowBits));
+
+     This is another version of inflateInit with more compression options. The
+   fields next_out, zalloc, zfree and opaque must be initialized before by
+   the caller.
+
+     The windowBits parameter is the base two logarithm of the maximum window
+   size (the size of the history buffer).  It should be in the range 8..15 for
+   this version of the library (the value 16 will be allowed soon). The
+   default value is 15 if inflateInit is used instead. If a compressed stream
+   with a larger window size is given as input, inflate() will return with
+   the error code Z_DATA_ERROR instead of trying to allocate a larger window.
+
+     If next_out is not null, the library will use this buffer for the history
+   buffer; the buffer must either be large enough to hold the entire output
+   data, or have at least 1<<windowBits bytes.  If next_out is null, the
+   library will allocate its own buffer (and leave next_out null). next_in
+   need not be provided here but must be provided by the application for the
+   next call of inflate().
+
+     If the history buffer is provided by the application, next_out must
+   never be changed by the application since the decompressor maintains
+   history information inside this buffer from call to call; the application
+   can only reset next_out to the beginning of the history buffer when
+   avail_out is zero and all output has been consumed.
+
+      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was
+   not enough memory, Z_STREAM_ERROR if a parameter is invalid (such as
+   windowBits < 8). msg is set to null if there is no error message.
+   inflateInit2 does not perform any decompression: this will be done by
+   inflate().
+*/
+
+extern int EXPORT inflateSetDictionary OF((z_streamp strm,
+				           const Bytef *dictionary,
+					   uInt  dictLength));
+/*
+     Initializes the decompression dictionary (history buffer) from the given
+   uncompressed byte sequence. This function must be called immediately after
+   a call of inflate if this call returned Z_NEED_DICT. The dictionary chosen
+   by the compressor can be determined from the Adler32 value returned by this
+   call of inflate. The compressor and decompressor must use exactly the same
+   dictionary (see deflateSetDictionary).
+
+     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state is
+   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
+   expected one (incorrect Adler32 value). inflateSetDictionary does not
+   perform any decompression: this will be done by subsequent calls of
+   inflate().
+*/
+
+extern int EXPORT inflateSync OF((z_streamp strm));
+/* 
+    Skips invalid compressed data until the special marker (see deflate()
+  above) can be found, or until all available input is skipped. No output
+  is provided.
+
+    inflateSync returns Z_OK if the special marker has been found, Z_BUF_ERROR
+  if no more input was provided, Z_DATA_ERROR if no marker has been found,
+  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
+  case, the application may save the current current value of total_in which
+  indicates where valid compressed data was found. In the error case, the
+  application may repeatedly call inflateSync, providing more input each time,
+  until success or end of the input data.
+*/
+
+extern int EXPORT inflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to inflateEnd followed by inflateInit,
+   but does not free and reallocate all the internal decompression state.
+   The stream will keep attributes that may have been set by inflateInit2.
+
+      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+extern int inflateIncomp OF((z_stream *strm));
+/*
+     This function adds the data at next_in (avail_in bytes) to the output
+   history without performing any output.  There must be no pending output,
+   and the decompressor must be expecting to see the start of a block.
+   Calling this function is equivalent to decompressing a stored block
+   containing the data at next_in (except that the data is not output).
+*/
+
+                        /* utility functions */
+
+/*
+     The following utility functions are implemented on top of the
+   basic stream-oriented functions. To simplify the interface, some
+   default options are assumed (compression level, window size,
+   standard memory allocation functions). The source code of these
+   utility functions can easily be modified if you need special options.
+*/
+
+extern int EXPORT compress OF((Bytef *dest,   uLongf *destLen,
+			       const Bytef *source, uLong sourceLen));
+/*
+     Compresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be at least 0.1% larger than
+   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the
+   compressed buffer.
+     This function can be used to compress a whole file at once if the
+   input file is mmap'ed.
+     compress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer.
+*/
+
+extern int EXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
+				 const Bytef *source, uLong sourceLen));
+/*
+     Decompresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be large enough to hold the
+   entire uncompressed data. (The size of the uncompressed data must have
+   been saved previously by the compressor and transmitted to the decompressor
+   by some mechanism outside the scope of this compression library.)
+   Upon exit, destLen is the actual size of the compressed buffer.
+     This function can be used to decompress a whole file at once if the
+   input file is mmap'ed.
+
+     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer, or Z_DATA_ERROR if the input data was corrupted.
+*/
+
+
+typedef voidp gzFile;
+
+extern gzFile EXPORT gzopen  OF((const char *path, const char *mode));
+/*
+     Opens a gzip (.gz) file for reading or writing. The mode parameter
+   is as in fopen ("rb" or "wb") but can also include a compression level
+   ("wb9").  gzopen can be used to read a file which is not in gzip format;
+   in this case gzread will directly read from the file without decompression.
+     gzopen returns NULL if the file could not be opened or if there was
+   insufficient memory to allocate the (de)compression state; errno
+   can be checked to distinguish the two cases (if errno is zero, the
+   zlib error is Z_MEM_ERROR).
+*/
+
+extern gzFile EXPORT gzdopen  OF((int fd, const char *mode));
+/*
+     gzdopen() associates a gzFile with the file descriptor fd.  File
+   descriptors are obtained from calls like open, dup, creat, pipe or
+   fileno (in the file has been previously opened with fopen).
+   The mode parameter is as in gzopen.
+     The next call of gzclose on the returned gzFile will also close the
+   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
+   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
+     gzdopen returns NULL if there was insufficient memory to allocate
+   the (de)compression state.
+*/
+
+extern int EXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
+/*
+     Reads the given number of uncompressed bytes from the compressed file.
+   If the input file was not in gzip format, gzread copies the given number
+   of bytes into the buffer.
+     gzread returns the number of uncompressed bytes actually read (0 for
+   end of file, -1 for error). */
+
+extern int EXPORT    gzwrite OF((gzFile file, const voidp buf, unsigned len));
+/*
+     Writes the given number of uncompressed bytes into the compressed file.
+   gzwrite returns the number of uncompressed bytes actually written
+   (0 in case of error).
+*/
+
+extern int EXPORT    gzflush OF((gzFile file, int flush));
+/*
+     Flushes all pending output into the compressed file. The parameter
+   flush is as in the deflate() function. The return value is the zlib
+   error number (see function gzerror below). gzflush returns Z_OK if
+   the flush parameter is Z_FINISH and all output could be flushed.
+     gzflush should be called only when strictly necessary because it can
+   degrade compression.
+*/
+
+extern int EXPORT    gzclose OF((gzFile file));
+/*
+     Flushes all pending output if necessary, closes the compressed file
+   and deallocates all the (de)compression state. The return value is the zlib
+   error number (see function gzerror below).
+*/
+
+extern const char * EXPORT gzerror OF((gzFile file, int *errnum));
+/*
+     Returns the error message for the last error which occurred on the
+   given compressed file. errnum is set to zlib error number. If an
+   error occurred in the file system and not in the compression library,
+   errnum is set to Z_ERRNO and the application may consult errno
+   to get the exact error code.
+*/
+
+                        /* checksum functions */
+
+/*
+     These functions are not related to compression but are exported
+   anyway because they might be useful in applications using the
+   compression library.
+*/
+
+extern uLong EXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
+
+/*
+     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
+   return the updated checksum. If buf is NULL, this function returns
+   the required initial value for the checksum.
+   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
+   much faster. Usage example:
+
+     uLong adler = adler32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       adler = adler32(adler, buffer, length);
+     }
+     if (adler != original_adler) error();
+*/
+
+extern uLong EXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
+/*
+     Update a running crc with the bytes buf[0..len-1] and return the updated
+   crc. If buf is NULL, this function returns the required initial value
+   for the crc. Pre- and post-conditioning (one's complement) is performed
+   within this function so it shouldn't be done by the application.
+   Usage example:
+
+     uLong crc = crc32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       crc = crc32(crc, buffer, length);
+     }
+     if (crc != original_crc) error();
+*/
+
+
+                        /* various hacks, don't look :) */
+
+/* deflateInit and inflateInit are macros to allow checking the zlib version
+ * and the compiler's view of z_stream:
+ */
+extern int EXPORT deflateInit_ OF((z_streamp strm, int level,
+			           const char *version, int stream_size));
+extern int EXPORT inflateInit_ OF((z_streamp strm,
+				   const char *version, int stream_size));
+extern int EXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
+				    int windowBits, int memLevel, int strategy,
+				    const char *version, int stream_size));
+extern int EXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
+				    const char *version, int stream_size));
+#define deflateInit(strm, level) \
+        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit(strm) \
+        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
+#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
+        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
+		      (strategy),           ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit2(strm, windowBits) \
+        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
+
+#if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
+    struct internal_state {int dummy;}; /* hack for buggy compilers */
+#endif
+
+uLongf *get_crc_table OF((void)); /* can be used by asm versions of crc32() */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ZLIB_H */
+/* --- zlib.h */
diff -Nur linux/include/linux/jffs2.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/include/linux/jffs2.h
--- linux/include/linux/jffs2.h	2003-05-13 16:19:57.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/include/linux/jffs2.h	2003-06-23 01:47:04.000000000 +0700
@@ -1,20 +1,44 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001, 2002 Red Hat, Inc.
+ * Copyright (C) 2001 Red Hat, Inc.
  *
  * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
  *
- * For licensing information, see the file 'LICENCE' in the 
- * jffs2 directory.
+ * The original JFFS, from which the design for JFFS2 was derived,
+ * was designed and implemented by Axis Communications AB.
  *
- * $Id: jffs2.h,v 1.25 2002/08/20 21:37:27 dwmw2 Exp $
+ * The contents of this file are subject to the Red Hat eCos Public
+ * License Version 1.1 (the "Licence"); you may not use this file
+ * except in compliance with the Licence.  You may obtain a copy of
+ * the Licence at http://www.redhat.com/
+ *
+ * Software distributed under the Licence is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * See the Licence for the specific language governing rights and
+ * limitations under the Licence.
+ *
+ * The Original Code is JFFS2 - Journalling Flash File System, version 2
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the RHEPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the RHEPL or the GPL.
+ *
+ * $Id: jffs2.h,v 1.19 2001/10/09 13:20:23 dwmw2 Exp $
  *
  */
 
 #ifndef __LINUX_JFFS2_H__
 #define __LINUX_JFFS2_H__
 
+#include <asm/types.h>
 #define JFFS2_SUPER_MAGIC 0x72b6
 
 /* Values we may expect to find in the 'magic' field */
@@ -54,12 +78,16 @@
 #define JFFS2_NODETYPE_DIRENT (JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 1)
 #define JFFS2_NODETYPE_INODE (JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 2)
 #define JFFS2_NODETYPE_CLEANMARKER (JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 3)
-#define JFFS2_NODETYPE_PADDING (JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 4)
 
 // Maybe later...
 //#define JFFS2_NODETYPE_CHECKPOINT (JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 3)
 //#define JFFS2_NODETYPE_OPTIONS (JFFS2_FEATURE_RWCOMPAT_COPY | JFFS2_NODE_ACCURATE | 4)
 
+/* Same as the non_ECC versions, but with extra space for real 
+ * ECC instead of just the checksum. For use on NAND flash 
+ */
+//#define JFFS2_NODETYPE_DIRENT_ECC (JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 5)
+//#define JFFS2_NODETYPE_INODE_ECC (JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 6)
 
 #define JFFS2_INO_FLAG_PREREAD	  1	/* Do read_inode() for this one at 
 					   mount time, don't wait for it to 
@@ -68,66 +96,31 @@
 					   compression type */
 
 
-/* These can go once we've made sure we've caught all uses without
-   byteswapping */
-
-typedef struct {
-	uint32_t v32;
-} __attribute__((packed))  jint32_t;
-
-typedef struct {
-	uint16_t v16;
-} __attribute__((packed)) jint16_t;
-
-#define JFFS2_NATIVE_ENDIAN
-
-#if defined(JFFS2_NATIVE_ENDIAN)
-#define cpu_to_je16(x) ((jint16_t){x})
-#define cpu_to_je32(x) ((jint32_t){x})
-
-#define je16_to_cpu(x) ((x).v16)
-#define je32_to_cpu(x) ((x).v32)
-#elif defined(JFFS2_BIG_ENDIAN)
-#define cpu_to_je16(x) ((jint16_t){cpu_to_be16(x)})
-#define cpu_to_je32(x) ((jint32_t){cpu_to_be32(x)})
-
-#define je16_to_cpu(x) (be16_to_cpu(x.v16))
-#define je32_to_cpu(x) (be32_to_cpu(x.v32))
-#elif defined(JFFS2_LITTLE_ENDIAN)
-#define cpu_to_je16(x) ((jint16_t){cpu_to_le16(x)})
-#define cpu_to_je32(x) ((jint32_t){cpu_to_le32(x)})
-
-#define je16_to_cpu(x) (le16_to_cpu(x.v16))
-#define je32_to_cpu(x) (le32_to_cpu(x.v32))
-#else 
-#error wibble
-#endif
-
 struct jffs2_unknown_node
 {
 	/* All start like this */
-	jint16_t magic;
-	jint16_t nodetype;
-	jint32_t totlen; /* So we can skip over nodes we don't grok */
-	jint32_t hdr_crc;
+	__u16 magic;
+	__u16 nodetype;
+	__u32 totlen; /* So we can skip over nodes we don't grok */
+	__u32 hdr_crc;
 } __attribute__((packed));
 
 struct jffs2_raw_dirent
 {
-	jint16_t magic;
-	jint16_t nodetype;	/* == JFFS_NODETYPE_DIRENT */
-	jint32_t totlen;
-	jint32_t hdr_crc;
-	jint32_t pino;
-	jint32_t version;
-	jint32_t ino; /* == zero for unlink */
-	jint32_t mctime;
-	uint8_t nsize;
-	uint8_t type;
-	uint8_t unused[2];
-	jint32_t node_crc;
-	jint32_t name_crc;
-	uint8_t name[0];
+	__u16 magic;
+	__u16 nodetype;	/* == JFFS_NODETYPE_DIRENT */
+	__u32 totlen;
+	__u32 hdr_crc;
+	__u32 pino;
+	__u32 version;
+	__u32 ino; /* == zero for unlink */
+	__u32 mctime;
+	__u8 nsize;
+	__u8 type;
+	__u8 unused[2];
+	__u32 node_crc;
+	__u32 name_crc;
+	__u8 name[0];
 } __attribute__((packed));
 
 /* The JFFS2 raw inode structure: Used for storage on physical media.  */
@@ -138,28 +131,28 @@
 */
 struct jffs2_raw_inode
 {
-	jint16_t magic;      /* A constant magic number.  */
-	jint16_t nodetype;   /* == JFFS_NODETYPE_INODE */
-	jint32_t totlen;     /* Total length of this node (inc data, etc.) */
-	jint32_t hdr_crc;
-	jint32_t ino;        /* Inode number.  */
-	jint32_t version;    /* Version number.  */
-	jint32_t mode;       /* The file's type or mode.  */
-	jint16_t uid;        /* The file's owner.  */
-	jint16_t gid;        /* The file's group.  */
-	jint32_t isize;      /* Total resultant size of this inode (used for truncations)  */
-	jint32_t atime;      /* Last access time.  */
-	jint32_t mtime;      /* Last modification time.  */
-	jint32_t ctime;      /* Change time.  */
-	jint32_t offset;     /* Where to begin to write.  */
-	jint32_t csize;      /* (Compressed) data size */
-	jint32_t dsize;	     /* Size of the node's data. (after decompression) */
-	uint8_t compr;       /* Compression algorithm used */
-	uint8_t usercompr;   /* Compression algorithm requested by the user */
-	jint16_t flags;	     /* See JFFS2_INO_FLAG_* */
-	jint32_t data_crc;   /* CRC for the (compressed) data.  */
-	jint32_t node_crc;   /* CRC for the raw inode (excluding data)  */
-//	uint8_t data[dsize];
+	__u16 magic;      /* A constant magic number.  */
+	__u16 nodetype;   /* == JFFS_NODETYPE_INODE */
+	__u32 totlen;     /* Total length of this node (inc data, etc.) */
+	__u32 hdr_crc;
+	__u32 ino;        /* Inode number.  */
+	__u32 version;    /* Version number.  */
+	__u32 mode;       /* The file's type or mode.  */
+	__u16 uid;        /* The file's owner.  */
+	__u16 gid;        /* The file's group.  */
+	__u32 isize;      /* Total resultant size of this inode (used for truncations)  */
+	__u32 atime;      /* Last access time.  */
+	__u32 mtime;      /* Last modification time.  */
+	__u32 ctime;      /* Change time.  */
+	__u32 offset;     /* Where to begin to write.  */
+	__u32 csize;      /* (Compressed) data size */
+	__u32 dsize;	  /* Size of the node's data. (after decompression) */
+	__u8 compr;       /* Compression algorithm used */
+	__u8 usercompr;	  /* Compression algorithm requested by the user */
+	__u16 flags;	  /* See JFFS2_INO_FLAG_* */
+	__u32 data_crc;   /* CRC for the (compressed) data.  */
+	__u32 node_crc;   /* CRC for the raw inode (excluding data)  */
+//	__u8 data[dsize];
 } __attribute__((packed));
 
 union jffs2_node_union {
diff -Nur linux/include/linux/jffs2_fs_i.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/include/linux/jffs2_fs_i.h
--- linux/include/linux/jffs2_fs_i.h	2003-05-13 16:19:57.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/include/linux/jffs2_fs_i.h	2003-06-23 01:47:04.000000000 +0700
@@ -1,18 +1,22 @@
-/* $Id: jffs2_fs_i.h,v 1.14 2002/09/04 14:12:03 dwmw2 Exp $ */
-
-/*
- * ChangeLog:
- *     19-Nov-2002 Lineo Japan, Inc.  add dynamic construction of fragtree
- *
- */
+/* $Id: jffs2_fs_i.h,v 1.8 2001/04/18 13:05:28 dwmw2 Exp $ */
 
 #ifndef _JFFS2_FS_I
 #define _JFFS2_FS_I
 
-#include <linux/version.h>
-#include <linux/rbtree.h>
+/* Include the pipe_inode_info at the beginning so that we can still
+   use the storage space in the inode when we have a pipe inode.
+   This sucks.
+*/
+
+#undef THISSUCKS /* Only for 2.2 */
+#ifdef THISSUCKS
+#include <linux/pipe_fs_i.h>
+#endif
 
 struct jffs2_inode_info {
+#ifdef THISSUCKS
+        struct pipe_inode_info pipecrap;
+#endif
 	/* We need an internal semaphore similar to inode->i_sem.
 	   Unfortunately, we can't used the existing one, because
 	   either the GC would deadlock, or we'd have to release it
@@ -22,10 +26,10 @@
 	struct semaphore sem;
 
 	/* The highest (datanode) version number used for this ino */
-	uint32_t highest_version;
+	__u32 highest_version;
 
 	/* List of data fragments which make up the file */
-	rb_root_t fragtree;
+	struct jffs2_node_frag *fraglist;
 
 	/* There may be one datanode which isn't referenced by any of the
 	   above fragments, if it contains a metadata update but no actual
@@ -40,17 +44,19 @@
 	/* Some stuff we just have to keep in-core at all times, for each inode. */
 	struct jffs2_inode_cache *inocache;
 
-	uint16_t flags;
-	uint8_t usercompr;
-
-#ifdef CONFIG_JFFS2_DYNFRAGTREE
-	/* The number of frags linked to the fragtree */
-	uint32_t nr_frags;
-#endif
+	/* Keep a pointer to the last physical node in the list. We don't 
+	   use the doubly-linked lists because we don't want to increase
+	   the memory usage that much. This is simpler */
+	//	struct jffs2_raw_node_ref *lastnode;
+	__u16 flags;
+	__u8 usercompr;
+};
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,2)
-	struct inode vfs_inode;
+#ifdef JFFS2_OUT_OF_KERNEL
+#define JFFS2_INODE_INFO(i) ((struct jffs2_inode_info *) &(i)->u)
+#else
+#define JFFS2_INODE_INFO(i) (&i->u.jffs2_i)
 #endif
-};
 
 #endif /* _JFFS2_FS_I */
+
diff -Nur linux/include/linux/jffs2_fs_sb.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/include/linux/jffs2_fs_sb.h
--- linux/include/linux/jffs2_fs_sb.h	2003-05-13 16:19:57.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/include/linux/jffs2_fs_sb.h	2003-06-23 01:47:04.000000000 +0700
@@ -1,41 +1,18 @@
-/* $Id: jffs2_fs_sb.h,v 1.34 2002/09/09 16:29:07 dwmw2 Exp $ */
-
-/*
- * ChangeLog:
- *     27-Nov-2002 Lineo Japan, Inc.  add effective-gc mode
- *     15-Nov-2002 Lineo Japan, Inc.  add nodemerge facility
- *     05-Nov-2002 Lineo Japan, Inc.  modify nr_bad_blocks type
- *     29-Oct-2002 Lineo Japan, Inc.  add member nr_bad_blocks and cont_gc_count
- *
- */
-
-/*
- * ChangeLog:
- *     27-Nov-2002 Lineo Japan, Inc.  add effective-gc mode
- *     24-Nov-2002 SHARP  add erasing_dirty_size
- *     15-Nov-2002 Lineo Japan, Inc.  add nodemerge facility
- *     05-Nov-2002 Lineo Japan, Inc.  modify nr_bad_blocks type
- *     29-Oct-2002 Lineo Japan, Inc.  add member nr_bad_blocks and cont_gc_count
- *
- */
+/* $Id: jffs2_fs_sb.h,v 1.16.2.1 2002/02/23 14:13:34 dwmw2 Exp $ */
 
 #ifndef _JFFS2_FS_SB
 #define _JFFS2_FS_SB
 
 #include <linux/types.h>
 #include <linux/spinlock.h>
-#include <linux/tqueue.h>
 #include <linux/completion.h>
 #include <asm/semaphore.h>
 #include <linux/list.h>
 
+#define INOCACHE_HASHSIZE 1
+
 #define JFFS2_SB_FLAG_RO 1
 #define JFFS2_SB_FLAG_MOUNTING 2
-#ifdef CONFIG_JFFS2_NODEMERGE
-#define JFFS2_SB_FLAG_GCING_A_BLOCK 4
-#else
-#define JFFS2_SB_FLAG_GCING_A_BLOCK 0
-#endif
 
 /* A struct for the overall file system control.  Pointers to
    jffs2_sb_info structs are named `c' in the source code.  
@@ -44,41 +21,36 @@
 struct jffs2_sb_info {
 	struct mtd_info *mtd;
 
-	uint32_t highest_ino;
-	uint32_t checked_ino;
-
+	__u32 highest_ino;
 	unsigned int flags;
+	spinlock_t nodelist_lock;
 
+	//	pid_t thread_pid;		/* GC thread's PID */
 	struct task_struct *gc_task;	/* GC task struct */
 	struct semaphore gc_thread_start; /* GC thread start mutex */
 	struct completion gc_thread_exit; /* GC thread exit completion port */
+	//	__u32 gc_minfree_threshold;	/* GC trigger thresholds */
+	//	__u32 gc_maxdirty_threshold;
 
 	struct semaphore alloc_sem;	/* Used to protect all the following 
 					   fields, and also to protect against
 					   out-of-order writing of nodes.
 					   And GC.
 					*/
-	uint32_t cleanmarker_size;	/* Size of an _inline_ CLEANMARKER
-					 (i.e. zero for OOB CLEANMARKER */
-
-	uint32_t flash_size;
-	uint32_t used_size;
-	uint32_t dirty_size;
-	uint32_t wasted_size;
-	uint32_t free_size;
-	uint32_t erasing_size;
-	uint32_t bad_size;
-	uint32_t sector_size;
-	uint32_t unchecked_size;
-	uint32_t erasing_dirty_size;
-
-	uint32_t nr_free_blocks;
-	uint32_t nr_erasing_blocks;
-	int32_t nr_bad_blocks;
+	__u32 flash_size;
+	__u32 used_size;
+	__u32 dirty_size;
+	__u32 free_size;
+	__u32 erasing_size;
+	__u32 bad_size;
+	__u32 sector_size;
+	//	__u32 min_free_size;
+	//	__u32 max_chunk_size;
 
-	uint32_t cont_gc_count;
+	__u32 nr_free_blocks;
+	__u32 nr_erasing_blocks;
 
-	uint32_t nr_blocks;
+	__u32 nr_blocks;
 	struct jffs2_eraseblock *blocks;	/* The whole array of blocks. Used for getting blocks 
 						 * from the offset (blocks[ofs / sector_size]) */
 	struct jffs2_eraseblock *nextblock;	/* The block we're currently filling */
@@ -86,44 +58,27 @@
 	struct jffs2_eraseblock *gcblock;	/* The block we're currently garbage-collecting */
 
 	struct list_head clean_list;		/* Blocks 100% full of clean data */
-	struct list_head very_dirty_list;	/* Blocks with lots of dirty space */
 	struct list_head dirty_list;		/* Blocks with some dirty space */
-	struct list_head erasable_list;		/* Blocks which are completely dirty, and need erasing */
-	struct list_head erasable_pending_wbuf_list;	/* Blocks which need erasing but only after the current wbuf is flushed */
 	struct list_head erasing_list;		/* Blocks which are currently erasing */
-	struct list_head erase_pending_list;	/* Blocks which need erasing now */
+	struct list_head erase_pending_list;	/* Blocks which need erasing */
 	struct list_head erase_complete_list;	/* Blocks which are erased and need the clean marker written to them */
 	struct list_head free_list;		/* Blocks which are free and ready to be used */
 	struct list_head bad_list;		/* Bad blocks. */
 	struct list_head bad_used_list;		/* Bad blocks with valid data in. */
-#ifdef CONFIG_JFFS2_NODEMERGE
-	struct list_head nodemerge_list;	/* Blocks with node-merge */
-#endif
 
 	spinlock_t erase_completion_lock;	/* Protect free_list and erasing_list 
 						   against erase completion handler */
 	wait_queue_head_t erase_wait;		/* For waiting for erases to complete */
-
-	struct jffs2_inode_cache **inocache_list;
+	struct jffs2_inode_cache *inocache_list[INOCACHE_HASHSIZE];
 	spinlock_t inocache_lock;
-	
-	/* Sem to allow jffs2_garbage_collect_deletion_dirent to
-	   drop the erase_completion_lock while it's holding a pointer 
-	   to an obsoleted node. I don't like this. Alternatives welcomed. */
-	struct semaphore erase_free_sem;
-
-	/* Write-behind buffer for NAND flash */
-	unsigned char *wbuf;
-	uint32_t wbuf_ofs;
-	uint32_t wbuf_len;
-	uint32_t wbuf_pagesize;
-	struct tq_struct wbuf_task;		/* task for timed wbuf flush */
-	struct timer_list wbuf_timer;		/* timer for flushing wbuf */
+};
 
-	uint32_t effective_gc_count;
+#ifdef JFFS2_OUT_OF_KERNEL
+#define JFFS2_SB_INFO(sb) ((struct jffs2_sb_info *) &(sb)->u)
+#else
+#define JFFS2_SB_INFO(sb) (&sb->u.jffs2_sb)
+#endif
 
-	/* OS-private pointer for getting back to master superblock info */
-	void *os_priv;
-};
+#define OFNI_BS_2SFFJ(c)  ((struct super_block *) ( ((char *)c) - ((char *)(&((struct super_block *)NULL)->u)) ) )
 
 #endif /* _JFFS2_FB_SB */
diff -Nur linux/include/video/font.h /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/include/video/font.h
--- linux/include/video/font.h	2003-05-13 16:20:05.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/include/video/font.h	2003-06-23 01:47:04.000000000 +0700
@@ -28,6 +28,8 @@
 #define SUN8x16_IDX	4
 #define SUN12x22_IDX	5
 #define ACORN8x8_IDX	6
+#define CLEAN5x8_IDX	7
+#define CLEAN4x6_IDX	8
 
 extern struct fbcon_font_desc	font_vga_8x8,
 				font_vga_8x16,
@@ -35,7 +37,9 @@
 				font_vga_6x11,
 				font_sun_8x16,
 				font_sun_12x22,
-				font_acorn_8x8;
+				font_acorn_8x8,
+				font_clean_5x8,
+				font_clean_4x6;
 
 /* Find a font with a specific name */
 
diff -Nur linux/sl5000d_cacko /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/sl5000d_cacko
--- linux/sl5000d_cacko	1970-01-01 07:00:00.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/sl5000d_cacko	2003-06-23 01:47:04.000000000 +0700
@@ -0,0 +1,1051 @@
+#
+# Automatically generated by make menuconfig: don't edit
+#
+CONFIG_ARM=y
+# CONFIG_EISA is not set
+# CONFIG_SBUS is not set
+# CONFIG_MCA is not set
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+# CONFIG_GENERIC_BUST_SPINLOCK is not set
+# CONFIG_GENERIC_ISA_DMA is not set
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_OBSOLETE is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_KMOD is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_ANAKIN is not set
+# CONFIG_ARCH_ARCA5K is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_MX1ADS is not set
+# CONFIG_ARCH_RPC is not set
+CONFIG_ARCH_SA1100=y
+# CONFIG_ARCH_SHARK is not set
+
+#
+# Archimedes/A5000 Implementations
+#
+# CONFIG_ARCH_ARC is not set
+# CONFIG_ARCH_A5K is not set
+
+#
+# Footbridge Implementations
+#
+# CONFIG_ARCH_CATS is not set
+# CONFIG_ARCH_PERSONAL_SERVER is not set
+# CONFIG_ARCH_EBSA285_ADDIN is not set
+# CONFIG_ARCH_EBSA285_HOST is not set
+# CONFIG_ARCH_NETWINDER is not set
+
+#
+# SA11x0 Implementations
+#
+# CONFIG_SA1100_ASSABET is not set
+# CONFIG_ASSABET_NEPONSET is not set
+# CONFIG_SA1100_ADSBITSY is not set
+# CONFIG_SA1100_BRUTUS is not set
+# CONFIG_SA1100_CEP is not set
+# CONFIG_SA1100_CERF is not set
+CONFIG_SA1100_COLLIE=y
+CONFIG_LOCOMO=y
+# CONFIG_COLLIE_TS is not set
+# CONFIG_COLLIE_TR0 is not set
+# CONFIG_COLLIE_TR1 is not set
+CONFIG_COLLIE_DEV=y
+# CONFIG_COLLIE_G is not set
+# CONFIG_COLLIE_UP is not set
+# CONFIG_SA1100_H3100 is not set
+# CONFIG_SA1100_H3600 is not set
+# CONFIG_SA1100_H3800 is not set
+# CONFIG_SA1100_H3XXX is not set
+# CONFIG_SA1100_EXTENEX1 is not set
+# CONFIG_SA1100_FLEXANET is not set
+# CONFIG_SA1100_FREEBIRD is not set
+# CONFIG_SA1100_FRODO is not set
+# CONFIG_SA1100_GRAPHICSCLIENT is not set
+# CONFIG_SA1100_GRAPHICSMASTER is not set
+# CONFIG_SA1100_BADGE4 is not set
+# CONFIG_SA1100_JORNADA720 is not set
+# CONFIG_SA1100_HUW_WEBPANEL is not set
+# CONFIG_SA1100_ITSY is not set
+# CONFIG_SA1100_LART is not set
+# CONFIG_SA1100_NANOENGINE is not set
+# CONFIG_SA1100_OMNIMETER is not set
+# CONFIG_SA1100_PANGOLIN is not set
+# CONFIG_SA1100_PLEB is not set
+# CONFIG_SA1100_PT_SYSTEM3 is not set
+# CONFIG_SA1100_SHANNON is not set
+# CONFIG_SA1100_SHERMAN is not set
+# CONFIG_SA1100_SIMPAD is not set
+# CONFIG_SA1100_PFS168 is not set
+# CONFIG_SA1100_VICTOR is not set
+# CONFIG_SA1100_XP860 is not set
+# CONFIG_SA1100_YOPY is not set
+# CONFIG_SA1100_USB is not set
+# CONFIG_SA1100_USB_NETLINK is not set
+# CONFIG_SA1100_USB_CHAR is not set
+# CONFIG_H3600_SLEEVE is not set
+
+#
+# Intel PXA250/210 Implementations
+#
+# CONFIG_ARCH_LUBBOCK is not set
+# CONFIG_ARCH_PXA_IDP is not set
+# CONFIG_ARCH_PXA_CERF is not set
+# CONFIG_COTULLA_DMA is not set
+# CONFIG_SABINAL_DISCOVERY is not set
+# CONFIG_ARCH_SABINAL is not set
+# CONFIG_ARCH_PXA_POODLE is not set
+# CONFIG_POODLE_TR0 is not set
+# CONFIG_ARCH_PXA_CORGI is not set
+# CONFIG_CORGI_TR0 is not set
+CONFIG_ARCH_SHARP_SL=y
+# CONFIG_PXA_USB is not set
+# CONFIG_PXA_USB_NETLINK is not set
+# CONFIG_PXA_USB_CHAR is not set
+
+#
+# CLPS711X/EP721X Implementations
+#
+# CONFIG_ARCH_AUTCPU12 is not set
+# CONFIG_ARCH_CDB89712 is not set
+# CONFIG_ARCH_CLEP7312 is not set
+# CONFIG_ARCH_EDB7211 is not set
+# CONFIG_ARCH_P720T is not set
+# CONFIG_ARCH_FORTUNET is not set
+# CONFIG_ARCH_EP7211 is not set
+# CONFIG_ARCH_EP7212 is not set
+# CONFIG_ARCH_ACORN is not set
+# CONFIG_FOOTBRIDGE is not set
+# CONFIG_FOOTBRIDGE_HOST is not set
+# CONFIG_FOOTBRIDGE_ADDIN is not set
+CONFIG_CPU_32=y
+# CONFIG_CPU_26 is not set
+# CONFIG_CPU_32v3 is not set
+CONFIG_CPU_32v4=y
+# CONFIG_CPU_ARM610 is not set
+# CONFIG_CPU_ARM710 is not set
+# CONFIG_CPU_ARM720T is not set
+# CONFIG_CPU_ARM920T is not set
+# CONFIG_CPU_ARM922T is not set
+# CONFIG_PLD is not set
+# CONFIG_CPU_ARM926T is not set
+# CONFIG_CPU_ARM1020 is not set
+# CONFIG_CPU_SA110 is not set
+CONFIG_CPU_SA1100=y
+# CONFIG_ARM_THUMB is not set
+CONFIG_DISCONTIGMEM=y
+
+#
+# General setup
+#
+# CONFIG_PCI is not set
+CONFIG_ISA=y
+# CONFIG_ISA_DMA is not set
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+# CONFIG_CPU_FREQ is not set
+CONFIG_HOTPLUG=y
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=y
+CONFIG_PCMCIA_PROBE=y
+# CONFIG_I82092 is not set
+# CONFIG_I82365 is not set
+# CONFIG_TCIC is not set
+# CONFIG_PCMCIA_CLPS6700 is not set
+CONFIG_PCMCIA_SA1100=y
+# CONFIG_PCMCIA_PXA is not set
+CONFIG_NET=y
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_KCORE_ELF=y
+# CONFIG_KCORE_AOUT is not set
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_PM=y
+CONFIG_APM=y
+# CONFIG_APM_IGNORE_USER_SUSPEND is not set
+CONFIG_APM_CPU_IDLE=y
+CONFIG_APM_DISPLAY_BLANK=y
+CONFIG_APM_RTC_IS_GMT=y
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE="root=/dev/mtdblock4 mem=32M rootfstype=jffs2"
+# CONFIG_SHARPSL_BOOTLDR_PARAMS is not set
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+CONFIG_FREEPG_SIGNAL=y
+CONFIG_OOM_KILL_SURVIVAL=y
+CONFIG_DEVICEINFO=m
+CONFIG_COLLIE_DEVICEINFO=m
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_CACKO_HYBRID_PARTITIONS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+# CONFIG_MTD_GEN_PROBE is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+CONFIG_MTD_COLLIE=y
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+# CONFIG_MTD_AMDSTD is not set
+# CONFIG_MTD_SHARP is not set
+# CONFIG_MTD_JEDEC is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_LUBBOCK is not set
+# CONFIG_MTD_NORA is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_CDB89712 is not set
+CONFIG_MTD_SA1100=y
+# CONFIG_MTD_DC21285 is not set
+# CONFIG_MTD_IQ80310 is not set
+# CONFIG_MTD_FORTUNET is not set
+# CONFIG_MTD_PXA_CERF is not set
+# CONFIG_MTD_EPXA10DB is not set
+# CONFIG_MTD_AUTCPU12 is not set
+# CONFIG_MTD_EDB7312 is not set
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_DISCOVERY is not set
+# CONFIG_MTD_SHARP_SL is not set
+# CONFIG_MTD_PCI is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_MTDROM_SA1100 is not set
+# CONFIG_MTD_MTDRAM_SA1100 is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_MTDRAM_SHARP_SL is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_DOC1000 is not set
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOCPROBE is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=1024
+# CONFIG_BLK_DEV_INITRD is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_BLK_DEV_LVM is not set
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+# CONFIG_NETLINK_DEV is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_FILTER is not set
+CONFIG_UNIX=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_IPV6 is not set
+# CONFIG_KHTTPD is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_LLC is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_ARM_AM79C961A is not set
+# CONFIG_SUNLANCE is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_AT1700 is not set
+# CONFIG_DEPCA is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_NET_PCI is not set
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_MYRI_SBUS is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=y
+# CONFIG_PPP_SYNC_TTY is not set
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+# CONFIG_PPPOE is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+# CONFIG_STRIP is not set
+# CONFIG_WAVELAN is not set
+# CONFIG_ARLAN is not set
+# CONFIG_AIRONET4500 is not set
+# CONFIG_AIRONET4500_NONCS is not set
+# CONFIG_AIRONET4500_PROC is not set
+# CONFIG_AIRO is not set
+CONFIG_HERMES=y
+CONFIG_PCMCIA_HERMES=y
+CONFIG_AIRO_CS=y
+CONFIG_NET_WIRELESS=y
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# PCMCIA network device support
+#
+CONFIG_NET_PCMCIA=y
+# CONFIG_PCMCIA_3C589 is not set
+# CONFIG_PCMCIA_3C574 is not set
+# CONFIG_PCMCIA_FMVJ18X is not set
+CONFIG_PCMCIA_PCNET=y
+# CONFIG_PCMCIA_AXNET is not set
+# CONFIG_PCMCIA_NMCLAN is not set
+# CONFIG_PCMCIA_SMC91C92 is not set
+# CONFIG_PCMCIA_XIRC2PS is not set
+# CONFIG_ARCNET_COM20020_CS is not set
+# CONFIG_PCMCIA_IBMTR is not set
+# CONFIG_NET_PCMCIA_RADIO is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+CONFIG_IRDA=y
+CONFIG_IRLAN=y
+CONFIG_IRNET=y
+CONFIG_IRCOMM=y
+# CONFIG_IRDA_ULTRA is not set
+# CONFIG_IRDA_CACHE_LAST_LSAP is not set
+CONFIG_IRDA_FAST_RR=y
+# CONFIG_IRDA_DEBUG is not set
+
+#
+# Infrared-port device drivers
+#
+CONFIG_IRTTY_SIR=y
+CONFIG_IRPORT_SIR=y
+# CONFIG_DONGLE is not set
+# CONFIG_USB_IRDA is not set
+# CONFIG_NSC_FIR is not set
+# CONFIG_WINBOND_FIR is not set
+# CONFIG_TOSHIBA_FIR is not set
+# CONFIG_SMC_IRCC_FIR is not set
+# CONFIG_ALI_FIR is not set
+# CONFIG_VLSI_FIR is not set
+CONFIG_SA1100_FIR=y
+
+#
+# ATA/IDE/MFM/RLL support
+#
+CONFIG_IDE=y
+
+#
+# IDE, ATA and ATAPI Block devices
+#
+CONFIG_BLK_DEV_IDE=y
+# CONFIG_BLK_DEV_HD_IDE is not set
+# CONFIG_BLK_DEV_HD is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDEDISK_VENDOR is not set
+# CONFIG_BLK_DEV_IDEDISK_FUJITSU is not set
+# CONFIG_BLK_DEV_IDEDISK_IBM is not set
+# CONFIG_BLK_DEV_IDEDISK_MAXTOR is not set
+# CONFIG_BLK_DEV_IDEDISK_QUANTUM is not set
+# CONFIG_BLK_DEV_IDEDISK_SEAGATE is not set
+# CONFIG_BLK_DEV_IDEDISK_WD is not set
+# CONFIG_BLK_DEV_COMMERIAL is not set
+# CONFIG_BLK_DEV_TIVO is not set
+CONFIG_BLK_DEV_IDECS=y
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_CMD640_ENHANCED is not set
+# CONFIG_BLK_DEV_ISAPNP is not set
+# CONFIG_IDE_CHIPSETS is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_DMA_NONPCI is not set
+# CONFIG_BLK_DEV_IDE_MODES is not set
+# CONFIG_BLK_DEV_ATARAID is not set
+# CONFIG_BLK_DEV_ATARAID_PDC is not set
+# CONFIG_BLK_DEV_ATARAID_HPT is not set
+
+#
+# SCSI support
+#
+# CONFIG_SCSI is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+# CONFIG_I2O_BLOCK is not set
+# CONFIG_I2O_LAN is not set
+# CONFIG_I2O_SCSI is not set
+# CONFIG_I2O_PROC is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input core support
+#
+# CONFIG_INPUT is not set
+# CONFIG_INPUT_KEYBDEV is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+# CONFIG_VT_CONSOLE is not set
+CONFIG_SERIAL=m
+CONFIG_SERIAL_COLLIE=y
+# CONFIG_SERIAL_COLLIE_CONSOLE is not set
+CONFIG_COLLIE_DEFAULT_BAUDRATE=9600
+# CONFIG_SERIAL_EXTENDED is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_ANAKIN is not set
+# CONFIG_SERIAL_ANAKIN_CONSOLE is not set
+# CONFIG_SERIAL_AMBA is not set
+# CONFIG_SERIAL_AMBA_CONSOLE is not set
+# CONFIG_SERIAL_CLPS711X is not set
+# CONFIG_SERIAL_CLPS711X_CONSOLE is not set
+# CONFIG_SERIAL_21285 is not set
+# CONFIG_SERIAL_21285_OLD is not set
+# CONFIG_SERIAL_21285_CONSOLE is not set
+# CONFIG_SERIAL_UART00 is not set
+# CONFIG_SERIAL_UART00_CONSOLE is not set
+# CONFIG_SERIAL_SA1100 is not set
+# CONFIG_SERIAL_SA1100_CONSOLE is not set
+# CONFIG_SERIAL_8250 is not set
+# CONFIG_SERIAL_8250_CONSOLE is not set
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_MANY_PORTS is not set
+# CONFIG_SERIAL_8250_SHARE_IRQ is not set
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+# CONFIG_SERIAL_8250_MULTIPORT is not set
+# CONFIG_SERIAL_8250_HUB6 is not set
+CONFIG_UCB1200=y
+CONFIG_TOUCHSCREEN_UCB1200=y
+# CONFIG_AUDIO_UCB1200 is not set
+# CONFIG_ADC_UCB1200 is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=32
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# L3 serial bus support
+#
+# CONFIG_L3 is not set
+# CONFIG_L3_ALGOBIT is not set
+# CONFIG_L3_BIT_SA1100_GPIO is not set
+# CONFIG_L3_SA1111 is not set
+# CONFIG_BIT_SA1100_GPIO is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_QIC02_TAPE is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_INTEL_RNG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+CONFIG_SA1100_RTC=y
+# CONFIG_COTULLA_RTC is not set
+# CONFIG_ADS7846_TS is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+CONFIG_PCMCIA_SERIAL_CS=m
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FS_SYNC=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+CONFIG_VFAT_FS=y
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_PROC_FS is not set
+# CONFIG_JFFS2_NODEMERGE is not set
+# CONFIG_JFFS2_DYNFRAGTREE is not set
+CONFIG_CRAMFS=y
+CONFIG_TMPFS=y
+CONFIG_RAMFS=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+CONFIG_MINIX_FS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFSD is not set
+# CONFIG_NFSD_V3 is not set
+CONFIG_SUNRPC=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_SMB_FS=y
+CONFIG_SMB_NLS_DEFAULT=y
+CONFIG_SMB_NLS_REMOTE="cp437"
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+# CONFIG_ZISOFS_FS is not set
+CONFIG_ZLIB_FS_INFLATE=y
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_SMB_NLS=y
+CONFIG_NLS=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Console drivers
+#
+CONFIG_PC_KEYMAP=y
+# CONFIG_VGA_CONSOLE is not set
+
+#
+# Frame-buffer support
+#
+CONFIG_FB=y
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FB_COLLIE=y
+# CONFIG_FB_ACORN is not set
+# CONFIG_FB_ANAKIN is not set
+# CONFIG_FB_CLPS711X is not set
+# CONFIG_FB_SA1100 is not set
+# CONFIG_FB_PXA is not set
+# CONFIG_FB_COTULLA is not set
+# CONFIG_FB_POODLE is not set
+# CONFIG_FB_CORGI is not set
+# CONFIG_SHARP_LOGO_SCREEN is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_VIRTUAL is not set
+CONFIG_FBCON_ADVANCED=y
+# CONFIG_FBCON_MFB is not set
+# CONFIG_FBCON_CFB2 is not set
+# CONFIG_FBCON_CFB4 is not set
+# CONFIG_FBCON_CFB8 is not set
+CONFIG_FBCON_CFB16=y
+# CONFIG_FBCON_CFB24 is not set
+# CONFIG_FBCON_CFB32 is not set
+# CONFIG_FBCON_AFB is not set
+# CONFIG_FBCON_ILBM is not set
+# CONFIG_FBCON_IPLAN2P2 is not set
+# CONFIG_FBCON_IPLAN2P4 is not set
+# CONFIG_FBCON_IPLAN2P8 is not set
+# CONFIG_FBCON_MAC is not set
+# CONFIG_FBCON_VGA_PLANES is not set
+# CONFIG_FBCON_VGA is not set
+# CONFIG_FBCON_HGA is not set
+CONFIG_FBCON_ROTATE_R=y
+# CONFIG_FBCON_ROTATE_L is not set
+# CONFIG_FBCON_FONTWIDTH8_ONLY is not set
+CONFIG_FBCON_FONTS=y
+# CONFIG_FONT_8x8 is not set
+# CONFIG_FONT_8x16 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_5x8 is not set
+CONFIG_FONT_4x6=y
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+# CONFIG_SOUND_BT878 is not set
+CONFIG_SOUND_COLLIE_SSP=y
+CONFIG_COLLIE_PCM1741=y
+# CONFIG_COLLIE_PCM1717 is not set
+CONFIG_SOUND_COLLIE_TC35143=y
+# CONFIG_SOUND_CMPCI is not set
+# CONFIG_SOUND_EMU10K1 is not set
+# CONFIG_MIDI_EMU10K1 is not set
+# CONFIG_SOUND_FUSION is not set
+# CONFIG_SOUND_CS4281 is not set
+# CONFIG_SOUND_ES1370 is not set
+# CONFIG_SOUND_ES1371 is not set
+# CONFIG_SOUND_ESSSOLO1 is not set
+# CONFIG_SOUND_MAESTRO is not set
+# CONFIG_SOUND_MAESTRO3 is not set
+# CONFIG_SOUND_ICH is not set
+# CONFIG_SOUND_RME96XX is not set
+# CONFIG_SOUND_SONICVIBES is not set
+# CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+# CONFIG_SOUND_VIA82CXXX is not set
+# CONFIG_MIDI_VIA82CXXX is not set
+# CONFIG_SOUND_SA1100 is not set
+# CONFIG_SOUND_UDA1341 is not set
+# CONFIG_SOUND_ASSABET_UDA1341 is not set
+# CONFIG_SOUND_H3600_UDA1341 is not set
+# CONFIG_SOUND_PANGOLIN_UDA1341 is not set
+# CONFIG_SOUND_SA1111_UDA1341 is not set
+# CONFIG_SOUND_SA1100SSP is not set
+# CONFIG_SOUND_OSS is not set
+# CONFIG_SOUND_WAVEARTIST is not set
+# CONFIG_SOUND_PXA_AC97 is not set
+# CONFIG_SOUND_POODLE is not set
+# CONFIG_SOUND_CORGI is not set
+# CONFIG_SOUND_TVMIXER is not set
+
+#
+# Multimedia Capabilities Port drivers
+#
+# CONFIG_MCP is not set
+# CONFIG_MCP_SA1100 is not set
+# CONFIG_MCP_UCB1200 is not set
+# CONFIG_MCP_UCB1200_AUDIO is not set
+# CONFIG_MCP_UCB1200_TS is not set
+# CONFIG_MCP_UCB1400_TS is not set
+
+#
+# USB support
+#
+CONFIG_USB=m
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_LONG_TIMEOUT is not set
+# CONFIG_USB_UHCI is not set
+# CONFIG_USB_UHCI_ALT is not set
+# CONFIG_USB_OHCI is not set
+# CONFIG_USB_OHCI_SA1111 is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_BLUETOOTH is not set
+# CONFIG_USB_STORAGE is not set
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_HP8200e is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_DC2XX is not set
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_SCANNER is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_HPUSBSCSI is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_CDCETHER is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_USS720 is not set
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA28 is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA28X is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA28XA is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA28XB is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA19 is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA18X is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA19W is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA49W is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_RIO500 is not set
+
+#
+# USB Device Support
+#
+CONFIG_USBD=m
+CONFIG_USBD_VENDORID=4dd
+CONFIG_USBD_PRODUCTID=8002
+CONFIG_USBD_PRODUCT_NAME="SL Series"
+CONFIG_USBD_MANUFACTURER="Sharp"
+CONFIG_USBD_USE_SERIAL_NUMBER=y
+CONFIG_USBD_SERIAL_NUMBER_STR="A01234"
+CONFIG_USBD_SELFPOWERED=y
+CONFIG_USBD_MONITOR=m
+CONFIG_USBD_PROCFS=y
+
+#
+# Network Function
+#
+CONFIG_USBD_NET=m
+CONFIG_USBD_NET_VENDORID=4DD
+CONFIG_USBD_NET_PRODUCTID=8004
+CONFIG_USBD_NET_IFNAME="usbd"
+CONFIG_USBD_NET_OUT_ENDPOINT=1
+CONFIG_USBD_NET_OUT_PKTSIZE=64
+CONFIG_USBD_NET_IN_ENDPOINT=2
+CONFIG_USBD_NET_IN_PKTSIZE=64
+# CONFIG_USBD_NET_ALWAYSUP is not set
+# CONFIG_USBD_NET_SAFE is not set
+# CONFIG_USBD_NET_MDLM is not set
+CONFIG_USBD_NET_CDC=y
+CONFIG_USBD_NET_REMOTE_MACADDR=""
+CONFIG_USBD_NET_REMOTE_OUI=400002
+# CONFIG_USBD_MAC_AS_SERIAL_NUMBER is not set
+CONFIG_USBD_NET_LOCAL_MACADDR="400001000001"
+CONFIG_USBD_NET_LOCAL_OUI=400001
+
+#
+# Serial Function
+#
+CONFIG_USBD_SERIAL=m
+CONFIG_USBD_SERIAL_VENDORID=4dd
+CONFIG_USBD_SERIAL_PRODUCTID=8002
+# CONFIG_USBD_SERIAL_CDC is not set
+CONFIG_USBD_SERIAL_OUT_ENDPOINT=1
+CONFIG_USBD_SERIAL_IN_PKTSIZE=64
+CONFIG_USBD_SERIAL_IN_ENDPOINT=2
+CONFIG_USBD_SERIAL_OUT_PKTSIZE=64
+# CONFIG_USBD_SERIAL_SAFE is not set
+
+#
+# USB Device Bus Interface Support
+#
+CONFIG_USBD_SA1100_BUS=m
+# CONFIG_USBD_TRAFFIC_KEEPAWAKE is not set
+CONFIG_USBD_STALL_TIMEOUT=0
+CONFIG_USBD_STALL_DISCONNECT_DURATION=2
+# CONFIG_USBD_GENERIC_BUS is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BLUEZ is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_COREDUMP_SIGNAL is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_NO_PGT_CACHE is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_WAITQ is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_LL is not set
+# CONFIG_DEBUG_DC21285_PORT is not set
+# CONFIG_DEBUG_CLPS711X_UART2 is not set
diff -Nur linux/sl5000d_hybrid /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/sl5000d_hybrid
--- linux/sl5000d_hybrid	1970-01-01 07:00:00.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/sl5000d_hybrid	2003-06-23 01:47:04.000000000 +0700
@@ -0,0 +1,1051 @@
+#
+# Automatically generated by make menuconfig: don't edit
+#
+CONFIG_ARM=y
+# CONFIG_EISA is not set
+# CONFIG_SBUS is not set
+# CONFIG_MCA is not set
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+# CONFIG_GENERIC_BUST_SPINLOCK is not set
+# CONFIG_GENERIC_ISA_DMA is not set
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_OBSOLETE is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_KMOD is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_ANAKIN is not set
+# CONFIG_ARCH_ARCA5K is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_MX1ADS is not set
+# CONFIG_ARCH_RPC is not set
+CONFIG_ARCH_SA1100=y
+# CONFIG_ARCH_SHARK is not set
+
+#
+# Archimedes/A5000 Implementations
+#
+# CONFIG_ARCH_ARC is not set
+# CONFIG_ARCH_A5K is not set
+
+#
+# Footbridge Implementations
+#
+# CONFIG_ARCH_CATS is not set
+# CONFIG_ARCH_PERSONAL_SERVER is not set
+# CONFIG_ARCH_EBSA285_ADDIN is not set
+# CONFIG_ARCH_EBSA285_HOST is not set
+# CONFIG_ARCH_NETWINDER is not set
+
+#
+# SA11x0 Implementations
+#
+# CONFIG_SA1100_ASSABET is not set
+# CONFIG_ASSABET_NEPONSET is not set
+# CONFIG_SA1100_ADSBITSY is not set
+# CONFIG_SA1100_BRUTUS is not set
+# CONFIG_SA1100_CEP is not set
+# CONFIG_SA1100_CERF is not set
+CONFIG_SA1100_COLLIE=y
+CONFIG_LOCOMO=y
+# CONFIG_COLLIE_TS is not set
+# CONFIG_COLLIE_TR0 is not set
+# CONFIG_COLLIE_TR1 is not set
+CONFIG_COLLIE_DEV=y
+# CONFIG_COLLIE_G is not set
+# CONFIG_COLLIE_UP is not set
+# CONFIG_SA1100_H3100 is not set
+# CONFIG_SA1100_H3600 is not set
+# CONFIG_SA1100_H3800 is not set
+# CONFIG_SA1100_H3XXX is not set
+# CONFIG_SA1100_EXTENEX1 is not set
+# CONFIG_SA1100_FLEXANET is not set
+# CONFIG_SA1100_FREEBIRD is not set
+# CONFIG_SA1100_FRODO is not set
+# CONFIG_SA1100_GRAPHICSCLIENT is not set
+# CONFIG_SA1100_GRAPHICSMASTER is not set
+# CONFIG_SA1100_BADGE4 is not set
+# CONFIG_SA1100_JORNADA720 is not set
+# CONFIG_SA1100_HUW_WEBPANEL is not set
+# CONFIG_SA1100_ITSY is not set
+# CONFIG_SA1100_LART is not set
+# CONFIG_SA1100_NANOENGINE is not set
+# CONFIG_SA1100_OMNIMETER is not set
+# CONFIG_SA1100_PANGOLIN is not set
+# CONFIG_SA1100_PLEB is not set
+# CONFIG_SA1100_PT_SYSTEM3 is not set
+# CONFIG_SA1100_SHANNON is not set
+# CONFIG_SA1100_SHERMAN is not set
+# CONFIG_SA1100_SIMPAD is not set
+# CONFIG_SA1100_PFS168 is not set
+# CONFIG_SA1100_VICTOR is not set
+# CONFIG_SA1100_XP860 is not set
+# CONFIG_SA1100_YOPY is not set
+# CONFIG_SA1100_USB is not set
+# CONFIG_SA1100_USB_NETLINK is not set
+# CONFIG_SA1100_USB_CHAR is not set
+# CONFIG_H3600_SLEEVE is not set
+
+#
+# Intel PXA250/210 Implementations
+#
+# CONFIG_ARCH_LUBBOCK is not set
+# CONFIG_ARCH_PXA_IDP is not set
+# CONFIG_ARCH_PXA_CERF is not set
+# CONFIG_COTULLA_DMA is not set
+# CONFIG_SABINAL_DISCOVERY is not set
+# CONFIG_ARCH_SABINAL is not set
+# CONFIG_ARCH_PXA_POODLE is not set
+# CONFIG_POODLE_TR0 is not set
+# CONFIG_ARCH_PXA_CORGI is not set
+# CONFIG_CORGI_TR0 is not set
+CONFIG_ARCH_SHARP_SL=y
+# CONFIG_PXA_USB is not set
+# CONFIG_PXA_USB_NETLINK is not set
+# CONFIG_PXA_USB_CHAR is not set
+
+#
+# CLPS711X/EP721X Implementations
+#
+# CONFIG_ARCH_AUTCPU12 is not set
+# CONFIG_ARCH_CDB89712 is not set
+# CONFIG_ARCH_CLEP7312 is not set
+# CONFIG_ARCH_EDB7211 is not set
+# CONFIG_ARCH_P720T is not set
+# CONFIG_ARCH_FORTUNET is not set
+# CONFIG_ARCH_EP7211 is not set
+# CONFIG_ARCH_EP7212 is not set
+# CONFIG_ARCH_ACORN is not set
+# CONFIG_FOOTBRIDGE is not set
+# CONFIG_FOOTBRIDGE_HOST is not set
+# CONFIG_FOOTBRIDGE_ADDIN is not set
+CONFIG_CPU_32=y
+# CONFIG_CPU_26 is not set
+# CONFIG_CPU_32v3 is not set
+CONFIG_CPU_32v4=y
+# CONFIG_CPU_ARM610 is not set
+# CONFIG_CPU_ARM710 is not set
+# CONFIG_CPU_ARM720T is not set
+# CONFIG_CPU_ARM920T is not set
+# CONFIG_CPU_ARM922T is not set
+# CONFIG_PLD is not set
+# CONFIG_CPU_ARM926T is not set
+# CONFIG_CPU_ARM1020 is not set
+# CONFIG_CPU_SA110 is not set
+CONFIG_CPU_SA1100=y
+# CONFIG_ARM_THUMB is not set
+CONFIG_DISCONTIGMEM=y
+
+#
+# General setup
+#
+# CONFIG_PCI is not set
+CONFIG_ISA=y
+# CONFIG_ISA_DMA is not set
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+# CONFIG_CPU_FREQ is not set
+CONFIG_HOTPLUG=y
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=y
+CONFIG_PCMCIA_PROBE=y
+# CONFIG_I82092 is not set
+# CONFIG_I82365 is not set
+# CONFIG_TCIC is not set
+# CONFIG_PCMCIA_CLPS6700 is not set
+CONFIG_PCMCIA_SA1100=y
+# CONFIG_PCMCIA_PXA is not set
+CONFIG_NET=y
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_KCORE_ELF=y
+# CONFIG_KCORE_AOUT is not set
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_PM=y
+CONFIG_APM=y
+# CONFIG_APM_IGNORE_USER_SUSPEND is not set
+CONFIG_APM_CPU_IDLE=y
+CONFIG_APM_DISPLAY_BLANK=y
+CONFIG_APM_RTC_IS_GMT=y
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE="root=/dev/mtdblock4 mem=32M rootfstype=cramfs"
+# CONFIG_SHARPSL_BOOTLDR_PARAMS is not set
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+CONFIG_FREEPG_SIGNAL=y
+CONFIG_OOM_KILL_SURVIVAL=y
+CONFIG_DEVICEINFO=m
+CONFIG_COLLIE_DEVICEINFO=m
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_CACKO_HYBRID_PARTITIONS=y
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+# CONFIG_MTD_GEN_PROBE is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+CONFIG_MTD_COLLIE=y
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+# CONFIG_MTD_AMDSTD is not set
+# CONFIG_MTD_SHARP is not set
+# CONFIG_MTD_JEDEC is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_LUBBOCK is not set
+# CONFIG_MTD_NORA is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_CDB89712 is not set
+CONFIG_MTD_SA1100=y
+# CONFIG_MTD_DC21285 is not set
+# CONFIG_MTD_IQ80310 is not set
+# CONFIG_MTD_FORTUNET is not set
+# CONFIG_MTD_PXA_CERF is not set
+# CONFIG_MTD_EPXA10DB is not set
+# CONFIG_MTD_AUTCPU12 is not set
+# CONFIG_MTD_EDB7312 is not set
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_DISCOVERY is not set
+# CONFIG_MTD_SHARP_SL is not set
+# CONFIG_MTD_PCI is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_MTDROM_SA1100 is not set
+# CONFIG_MTD_MTDRAM_SA1100 is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_MTDRAM_SHARP_SL is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_DOC1000 is not set
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOCPROBE is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=1024
+# CONFIG_BLK_DEV_INITRD is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_BLK_DEV_LVM is not set
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+# CONFIG_NETLINK_DEV is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_FILTER is not set
+CONFIG_UNIX=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_IPV6 is not set
+# CONFIG_KHTTPD is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_LLC is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_ARM_AM79C961A is not set
+# CONFIG_SUNLANCE is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_AT1700 is not set
+# CONFIG_DEPCA is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_NET_PCI is not set
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_MYRI_SBUS is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=y
+# CONFIG_PPP_SYNC_TTY is not set
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+# CONFIG_PPPOE is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+# CONFIG_STRIP is not set
+# CONFIG_WAVELAN is not set
+# CONFIG_ARLAN is not set
+# CONFIG_AIRONET4500 is not set
+# CONFIG_AIRONET4500_NONCS is not set
+# CONFIG_AIRONET4500_PROC is not set
+# CONFIG_AIRO is not set
+CONFIG_HERMES=y
+CONFIG_PCMCIA_HERMES=y
+CONFIG_AIRO_CS=y
+CONFIG_NET_WIRELESS=y
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# PCMCIA network device support
+#
+CONFIG_NET_PCMCIA=y
+# CONFIG_PCMCIA_3C589 is not set
+# CONFIG_PCMCIA_3C574 is not set
+# CONFIG_PCMCIA_FMVJ18X is not set
+CONFIG_PCMCIA_PCNET=y
+# CONFIG_PCMCIA_AXNET is not set
+# CONFIG_PCMCIA_NMCLAN is not set
+# CONFIG_PCMCIA_SMC91C92 is not set
+# CONFIG_PCMCIA_XIRC2PS is not set
+# CONFIG_ARCNET_COM20020_CS is not set
+# CONFIG_PCMCIA_IBMTR is not set
+# CONFIG_NET_PCMCIA_RADIO is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+CONFIG_IRDA=y
+CONFIG_IRLAN=y
+CONFIG_IRNET=y
+CONFIG_IRCOMM=y
+# CONFIG_IRDA_ULTRA is not set
+# CONFIG_IRDA_CACHE_LAST_LSAP is not set
+CONFIG_IRDA_FAST_RR=y
+# CONFIG_IRDA_DEBUG is not set
+
+#
+# Infrared-port device drivers
+#
+CONFIG_IRTTY_SIR=y
+CONFIG_IRPORT_SIR=y
+# CONFIG_DONGLE is not set
+# CONFIG_USB_IRDA is not set
+# CONFIG_NSC_FIR is not set
+# CONFIG_WINBOND_FIR is not set
+# CONFIG_TOSHIBA_FIR is not set
+# CONFIG_SMC_IRCC_FIR is not set
+# CONFIG_ALI_FIR is not set
+# CONFIG_VLSI_FIR is not set
+CONFIG_SA1100_FIR=y
+
+#
+# ATA/IDE/MFM/RLL support
+#
+CONFIG_IDE=y
+
+#
+# IDE, ATA and ATAPI Block devices
+#
+CONFIG_BLK_DEV_IDE=y
+# CONFIG_BLK_DEV_HD_IDE is not set
+# CONFIG_BLK_DEV_HD is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDEDISK_VENDOR is not set
+# CONFIG_BLK_DEV_IDEDISK_FUJITSU is not set
+# CONFIG_BLK_DEV_IDEDISK_IBM is not set
+# CONFIG_BLK_DEV_IDEDISK_MAXTOR is not set
+# CONFIG_BLK_DEV_IDEDISK_QUANTUM is not set
+# CONFIG_BLK_DEV_IDEDISK_SEAGATE is not set
+# CONFIG_BLK_DEV_IDEDISK_WD is not set
+# CONFIG_BLK_DEV_COMMERIAL is not set
+# CONFIG_BLK_DEV_TIVO is not set
+CONFIG_BLK_DEV_IDECS=y
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_CMD640_ENHANCED is not set
+# CONFIG_BLK_DEV_ISAPNP is not set
+# CONFIG_IDE_CHIPSETS is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_DMA_NONPCI is not set
+# CONFIG_BLK_DEV_IDE_MODES is not set
+# CONFIG_BLK_DEV_ATARAID is not set
+# CONFIG_BLK_DEV_ATARAID_PDC is not set
+# CONFIG_BLK_DEV_ATARAID_HPT is not set
+
+#
+# SCSI support
+#
+# CONFIG_SCSI is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+# CONFIG_I2O_BLOCK is not set
+# CONFIG_I2O_LAN is not set
+# CONFIG_I2O_SCSI is not set
+# CONFIG_I2O_PROC is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input core support
+#
+# CONFIG_INPUT is not set
+# CONFIG_INPUT_KEYBDEV is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+# CONFIG_VT_CONSOLE is not set
+CONFIG_SERIAL=m
+CONFIG_SERIAL_COLLIE=y
+# CONFIG_SERIAL_COLLIE_CONSOLE is not set
+CONFIG_COLLIE_DEFAULT_BAUDRATE=9600
+# CONFIG_SERIAL_EXTENDED is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_ANAKIN is not set
+# CONFIG_SERIAL_ANAKIN_CONSOLE is not set
+# CONFIG_SERIAL_AMBA is not set
+# CONFIG_SERIAL_AMBA_CONSOLE is not set
+# CONFIG_SERIAL_CLPS711X is not set
+# CONFIG_SERIAL_CLPS711X_CONSOLE is not set
+# CONFIG_SERIAL_21285 is not set
+# CONFIG_SERIAL_21285_OLD is not set
+# CONFIG_SERIAL_21285_CONSOLE is not set
+# CONFIG_SERIAL_UART00 is not set
+# CONFIG_SERIAL_UART00_CONSOLE is not set
+# CONFIG_SERIAL_SA1100 is not set
+# CONFIG_SERIAL_SA1100_CONSOLE is not set
+# CONFIG_SERIAL_8250 is not set
+# CONFIG_SERIAL_8250_CONSOLE is not set
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_MANY_PORTS is not set
+# CONFIG_SERIAL_8250_SHARE_IRQ is not set
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+# CONFIG_SERIAL_8250_MULTIPORT is not set
+# CONFIG_SERIAL_8250_HUB6 is not set
+CONFIG_UCB1200=y
+CONFIG_TOUCHSCREEN_UCB1200=y
+# CONFIG_AUDIO_UCB1200 is not set
+# CONFIG_ADC_UCB1200 is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=32
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# L3 serial bus support
+#
+# CONFIG_L3 is not set
+# CONFIG_L3_ALGOBIT is not set
+# CONFIG_L3_BIT_SA1100_GPIO is not set
+# CONFIG_L3_SA1111 is not set
+# CONFIG_BIT_SA1100_GPIO is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_QIC02_TAPE is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_INTEL_RNG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+CONFIG_SA1100_RTC=y
+# CONFIG_COTULLA_RTC is not set
+# CONFIG_ADS7846_TS is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+CONFIG_PCMCIA_SERIAL_CS=m
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FS_SYNC=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+CONFIG_VFAT_FS=y
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_PROC_FS is not set
+# CONFIG_JFFS2_NODEMERGE is not set
+# CONFIG_JFFS2_DYNFRAGTREE is not set
+CONFIG_CRAMFS=y
+CONFIG_TMPFS=y
+CONFIG_RAMFS=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+CONFIG_MINIX_FS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFSD is not set
+# CONFIG_NFSD_V3 is not set
+CONFIG_SUNRPC=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_SMB_FS=y
+CONFIG_SMB_NLS_DEFAULT=y
+CONFIG_SMB_NLS_REMOTE="cp437"
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+# CONFIG_ZISOFS_FS is not set
+CONFIG_ZLIB_FS_INFLATE=y
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_SMB_NLS=y
+CONFIG_NLS=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Console drivers
+#
+CONFIG_PC_KEYMAP=y
+# CONFIG_VGA_CONSOLE is not set
+
+#
+# Frame-buffer support
+#
+CONFIG_FB=y
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FB_COLLIE=y
+# CONFIG_FB_ACORN is not set
+# CONFIG_FB_ANAKIN is not set
+# CONFIG_FB_CLPS711X is not set
+# CONFIG_FB_SA1100 is not set
+# CONFIG_FB_PXA is not set
+# CONFIG_FB_COTULLA is not set
+# CONFIG_FB_POODLE is not set
+# CONFIG_FB_CORGI is not set
+# CONFIG_SHARP_LOGO_SCREEN is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_VIRTUAL is not set
+CONFIG_FBCON_ADVANCED=y
+# CONFIG_FBCON_MFB is not set
+# CONFIG_FBCON_CFB2 is not set
+# CONFIG_FBCON_CFB4 is not set
+# CONFIG_FBCON_CFB8 is not set
+CONFIG_FBCON_CFB16=y
+# CONFIG_FBCON_CFB24 is not set
+# CONFIG_FBCON_CFB32 is not set
+# CONFIG_FBCON_AFB is not set
+# CONFIG_FBCON_ILBM is not set
+# CONFIG_FBCON_IPLAN2P2 is not set
+# CONFIG_FBCON_IPLAN2P4 is not set
+# CONFIG_FBCON_IPLAN2P8 is not set
+# CONFIG_FBCON_MAC is not set
+# CONFIG_FBCON_VGA_PLANES is not set
+# CONFIG_FBCON_VGA is not set
+# CONFIG_FBCON_HGA is not set
+CONFIG_FBCON_ROTATE_R=y
+# CONFIG_FBCON_ROTATE_L is not set
+# CONFIG_FBCON_FONTWIDTH8_ONLY is not set
+CONFIG_FBCON_FONTS=y
+# CONFIG_FONT_8x8 is not set
+# CONFIG_FONT_8x16 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_5x8 is not set
+CONFIG_FONT_4x6=y
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+# CONFIG_SOUND_BT878 is not set
+CONFIG_SOUND_COLLIE_SSP=y
+CONFIG_COLLIE_PCM1741=y
+# CONFIG_COLLIE_PCM1717 is not set
+CONFIG_SOUND_COLLIE_TC35143=y
+# CONFIG_SOUND_CMPCI is not set
+# CONFIG_SOUND_EMU10K1 is not set
+# CONFIG_MIDI_EMU10K1 is not set
+# CONFIG_SOUND_FUSION is not set
+# CONFIG_SOUND_CS4281 is not set
+# CONFIG_SOUND_ES1370 is not set
+# CONFIG_SOUND_ES1371 is not set
+# CONFIG_SOUND_ESSSOLO1 is not set
+# CONFIG_SOUND_MAESTRO is not set
+# CONFIG_SOUND_MAESTRO3 is not set
+# CONFIG_SOUND_ICH is not set
+# CONFIG_SOUND_RME96XX is not set
+# CONFIG_SOUND_SONICVIBES is not set
+# CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+# CONFIG_SOUND_VIA82CXXX is not set
+# CONFIG_MIDI_VIA82CXXX is not set
+# CONFIG_SOUND_SA1100 is not set
+# CONFIG_SOUND_UDA1341 is not set
+# CONFIG_SOUND_ASSABET_UDA1341 is not set
+# CONFIG_SOUND_H3600_UDA1341 is not set
+# CONFIG_SOUND_PANGOLIN_UDA1341 is not set
+# CONFIG_SOUND_SA1111_UDA1341 is not set
+# CONFIG_SOUND_SA1100SSP is not set
+# CONFIG_SOUND_OSS is not set
+# CONFIG_SOUND_WAVEARTIST is not set
+# CONFIG_SOUND_PXA_AC97 is not set
+# CONFIG_SOUND_POODLE is not set
+# CONFIG_SOUND_CORGI is not set
+# CONFIG_SOUND_TVMIXER is not set
+
+#
+# Multimedia Capabilities Port drivers
+#
+# CONFIG_MCP is not set
+# CONFIG_MCP_SA1100 is not set
+# CONFIG_MCP_UCB1200 is not set
+# CONFIG_MCP_UCB1200_AUDIO is not set
+# CONFIG_MCP_UCB1200_TS is not set
+# CONFIG_MCP_UCB1400_TS is not set
+
+#
+# USB support
+#
+CONFIG_USB=m
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_LONG_TIMEOUT is not set
+# CONFIG_USB_UHCI is not set
+# CONFIG_USB_UHCI_ALT is not set
+# CONFIG_USB_OHCI is not set
+# CONFIG_USB_OHCI_SA1111 is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_BLUETOOTH is not set
+# CONFIG_USB_STORAGE is not set
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_HP8200e is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_DC2XX is not set
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_SCANNER is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_HPUSBSCSI is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_CDCETHER is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_USS720 is not set
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA28 is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA28X is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA28XA is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA28XB is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA19 is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA18X is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA19W is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA49W is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_RIO500 is not set
+
+#
+# USB Device Support
+#
+CONFIG_USBD=m
+CONFIG_USBD_VENDORID=4dd
+CONFIG_USBD_PRODUCTID=8002
+CONFIG_USBD_PRODUCT_NAME="SL Series"
+CONFIG_USBD_MANUFACTURER="Sharp"
+CONFIG_USBD_USE_SERIAL_NUMBER=y
+CONFIG_USBD_SERIAL_NUMBER_STR="A01234"
+CONFIG_USBD_SELFPOWERED=y
+CONFIG_USBD_MONITOR=m
+CONFIG_USBD_PROCFS=y
+
+#
+# Network Function
+#
+CONFIG_USBD_NET=m
+CONFIG_USBD_NET_VENDORID=4DD
+CONFIG_USBD_NET_PRODUCTID=8004
+CONFIG_USBD_NET_IFNAME="usbd"
+CONFIG_USBD_NET_OUT_ENDPOINT=1
+CONFIG_USBD_NET_OUT_PKTSIZE=64
+CONFIG_USBD_NET_IN_ENDPOINT=2
+CONFIG_USBD_NET_IN_PKTSIZE=64
+# CONFIG_USBD_NET_ALWAYSUP is not set
+# CONFIG_USBD_NET_SAFE is not set
+# CONFIG_USBD_NET_MDLM is not set
+CONFIG_USBD_NET_CDC=y
+CONFIG_USBD_NET_REMOTE_MACADDR=""
+CONFIG_USBD_NET_REMOTE_OUI=400002
+# CONFIG_USBD_MAC_AS_SERIAL_NUMBER is not set
+CONFIG_USBD_NET_LOCAL_MACADDR="400001000001"
+CONFIG_USBD_NET_LOCAL_OUI=400001
+
+#
+# Serial Function
+#
+CONFIG_USBD_SERIAL=m
+CONFIG_USBD_SERIAL_VENDORID=4dd
+CONFIG_USBD_SERIAL_PRODUCTID=8002
+# CONFIG_USBD_SERIAL_CDC is not set
+CONFIG_USBD_SERIAL_OUT_ENDPOINT=1
+CONFIG_USBD_SERIAL_IN_PKTSIZE=64
+CONFIG_USBD_SERIAL_IN_ENDPOINT=2
+CONFIG_USBD_SERIAL_OUT_PKTSIZE=64
+# CONFIG_USBD_SERIAL_SAFE is not set
+
+#
+# USB Device Bus Interface Support
+#
+CONFIG_USBD_SA1100_BUS=m
+# CONFIG_USBD_TRAFFIC_KEEPAWAKE is not set
+CONFIG_USBD_STALL_TIMEOUT=0
+CONFIG_USBD_STALL_DISCONNECT_DURATION=2
+# CONFIG_USBD_GENERIC_BUS is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BLUEZ is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_COREDUMP_SIGNAL is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_NO_PGT_CACHE is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_WAITQ is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_LL is not set
+# CONFIG_DEBUG_DC21285_PORT is not set
+# CONFIG_DEBUG_CLPS711X_UART2 is not set
diff -Nur linux/sl5500_hybrid /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/sl5500_hybrid
--- linux/sl5500_hybrid	1970-01-01 07:00:00.000000000 +0700
+++ /home/sash/tmp/oe/buildroot-oz/build/linux-2.4.18/sl5500_hybrid	2003-06-23 01:47:04.000000000 +0700
@@ -0,0 +1,1065 @@
+#
+# Automatically generated by make menuconfig: don't edit
+#
+CONFIG_ARM=y
+# CONFIG_EISA is not set
+# CONFIG_SBUS is not set
+# CONFIG_MCA is not set
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+# CONFIG_GENERIC_BUST_SPINLOCK is not set
+# CONFIG_GENERIC_ISA_DMA is not set
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_OBSOLETE is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_KMOD is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_ANAKIN is not set
+# CONFIG_ARCH_ARCA5K is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_MX1ADS is not set
+# CONFIG_ARCH_RPC is not set
+CONFIG_ARCH_SA1100=y
+# CONFIG_ARCH_SHARK is not set
+
+#
+# Archimedes/A5000 Implementations
+#
+# CONFIG_ARCH_ARC is not set
+# CONFIG_ARCH_A5K is not set
+
+#
+# Footbridge Implementations
+#
+# CONFIG_ARCH_CATS is not set
+# CONFIG_ARCH_PERSONAL_SERVER is not set
+# CONFIG_ARCH_EBSA285_ADDIN is not set
+# CONFIG_ARCH_EBSA285_HOST is not set
+# CONFIG_ARCH_NETWINDER is not set
+
+#
+# SA11x0 Implementations
+#
+# CONFIG_SA1100_ASSABET is not set
+# CONFIG_ASSABET_NEPONSET is not set
+# CONFIG_SA1100_ADSBITSY is not set
+# CONFIG_SA1100_BRUTUS is not set
+# CONFIG_SA1100_CEP is not set
+# CONFIG_SA1100_CERF is not set
+CONFIG_SA1100_COLLIE=y
+CONFIG_LOCOMO=y
+# CONFIG_COLLIE_TS is not set
+# CONFIG_COLLIE_TR0 is not set
+# CONFIG_COLLIE_TR1 is not set
+# CONFIG_COLLIE_DEV is not set
+# CONFIG_COLLIE_G is not set
+CONFIG_COLLIE_UP=y
+# CONFIG_SA1100_H3100 is not set
+# CONFIG_SA1100_H3600 is not set
+# CONFIG_SA1100_H3800 is not set
+# CONFIG_SA1100_H3XXX is not set
+# CONFIG_SA1100_EXTENEX1 is not set
+# CONFIG_SA1100_FLEXANET is not set
+# CONFIG_SA1100_FREEBIRD is not set
+# CONFIG_SA1100_FRODO is not set
+# CONFIG_SA1100_GRAPHICSCLIENT is not set
+# CONFIG_SA1100_GRAPHICSMASTER is not set
+# CONFIG_SA1100_BADGE4 is not set
+# CONFIG_SA1100_JORNADA720 is not set
+# CONFIG_SA1100_HUW_WEBPANEL is not set
+# CONFIG_SA1100_ITSY is not set
+# CONFIG_SA1100_LART is not set
+# CONFIG_SA1100_NANOENGINE is not set
+# CONFIG_SA1100_OMNIMETER is not set
+# CONFIG_SA1100_PANGOLIN is not set
+# CONFIG_SA1100_PLEB is not set
+# CONFIG_SA1100_PT_SYSTEM3 is not set
+# CONFIG_SA1100_SHANNON is not set
+# CONFIG_SA1100_SHERMAN is not set
+# CONFIG_SA1100_SIMPAD is not set
+# CONFIG_SA1100_PFS168 is not set
+# CONFIG_SA1100_VICTOR is not set
+# CONFIG_SA1100_XP860 is not set
+# CONFIG_SA1100_YOPY is not set
+# CONFIG_SA1100_USB is not set
+# CONFIG_SA1100_USB_NETLINK is not set
+# CONFIG_SA1100_USB_CHAR is not set
+# CONFIG_H3600_SLEEVE is not set
+
+#
+# Intel PXA250/210 Implementations
+#
+# CONFIG_ARCH_LUBBOCK is not set
+# CONFIG_ARCH_PXA_IDP is not set
+# CONFIG_ARCH_PXA_CERF is not set
+# CONFIG_COTULLA_DMA is not set
+# CONFIG_SABINAL_DISCOVERY is not set
+# CONFIG_ARCH_SABINAL is not set
+# CONFIG_ARCH_PXA_POODLE is not set
+# CONFIG_POODLE_TR0 is not set
+# CONFIG_ARCH_PXA_CORGI is not set
+# CONFIG_CORGI_TR0 is not set
+CONFIG_ARCH_SHARP_SL=y
+# CONFIG_PXA_USB is not set
+# CONFIG_PXA_USB_NETLINK is not set
+# CONFIG_PXA_USB_CHAR is not set
+
+#
+# CLPS711X/EP721X Implementations
+#
+# CONFIG_ARCH_AUTCPU12 is not set
+# CONFIG_ARCH_CDB89712 is not set
+# CONFIG_ARCH_CLEP7312 is not set
+# CONFIG_ARCH_EDB7211 is not set
+# CONFIG_ARCH_P720T is not set
+# CONFIG_ARCH_FORTUNET is not set
+# CONFIG_ARCH_EP7211 is not set
+# CONFIG_ARCH_EP7212 is not set
+# CONFIG_ARCH_ACORN is not set
+# CONFIG_FOOTBRIDGE is not set
+# CONFIG_FOOTBRIDGE_HOST is not set
+# CONFIG_FOOTBRIDGE_ADDIN is not set
+CONFIG_CPU_32=y
+# CONFIG_CPU_26 is not set
+# CONFIG_CPU_32v3 is not set
+CONFIG_CPU_32v4=y
+# CONFIG_CPU_ARM610 is not set
+# CONFIG_CPU_ARM710 is not set
+# CONFIG_CPU_ARM720T is not set
+# CONFIG_CPU_ARM920T is not set
+# CONFIG_CPU_ARM922T is not set
+# CONFIG_PLD is not set
+# CONFIG_CPU_ARM926T is not set
+# CONFIG_CPU_ARM1020 is not set
+# CONFIG_CPU_SA110 is not set
+CONFIG_CPU_SA1100=y
+# CONFIG_ARM_THUMB is not set
+CONFIG_DISCONTIGMEM=y
+
+#
+# General setup
+#
+# CONFIG_PCI is not set
+CONFIG_ISA=y
+# CONFIG_ISA_DMA is not set
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+# CONFIG_CPU_FREQ is not set
+CONFIG_HOTPLUG=y
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=y
+CONFIG_PCMCIA_PROBE=y
+# CONFIG_I82092 is not set
+# CONFIG_I82365 is not set
+# CONFIG_TCIC is not set
+# CONFIG_PCMCIA_CLPS6700 is not set
+CONFIG_PCMCIA_SA1100=y
+# CONFIG_PCMCIA_PXA is not set
+CONFIG_NET=y
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_KCORE_ELF=y
+# CONFIG_KCORE_AOUT is not set
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_PM=y
+CONFIG_APM=y
+# CONFIG_APM_IGNORE_USER_SUSPEND is not set
+CONFIG_APM_CPU_IDLE=y
+CONFIG_APM_DISPLAY_BLANK=y
+CONFIG_APM_RTC_IS_GMT=y
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE="root=/dev/mtdblock4 rootfstype=cramfs mem=34M"
+# CONFIG_SHARPSL_BOOTLDR_PARAMS is not set
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+CONFIG_FREEPG_SIGNAL=y
+CONFIG_OOM_KILL_SURVIVAL=y
+CONFIG_DEVICEINFO=m
+CONFIG_COLLIE_DEVICEINFO=m
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+# CONFIG_MTD_GEN_PROBE is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+CONFIG_MTD_COLLIE=y
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+# CONFIG_MTD_AMDSTD is not set
+# CONFIG_MTD_SHARP is not set
+# CONFIG_MTD_JEDEC is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_LUBBOCK is not set
+# CONFIG_MTD_NORA is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_CDB89712 is not set
+CONFIG_MTD_SA1100=y
+# CONFIG_MTD_DC21285 is not set
+# CONFIG_MTD_IQ80310 is not set
+# CONFIG_MTD_FORTUNET is not set
+# CONFIG_MTD_PXA_CERF is not set
+# CONFIG_MTD_EPXA10DB is not set
+# CONFIG_MTD_AUTCPU12 is not set
+# CONFIG_MTD_EDB7312 is not set
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_DISCOVERY is not set
+# CONFIG_MTD_SHARP_SL is not set
+# CONFIG_MTD_PCI is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_MTDROM_SA1100 is not set
+CONFIG_MTD_MTDRAM_SA1100=y
+CONFIG_MTDRAM_TOTAL_SIZE=30720
+CONFIG_MTDRAM_ERASE_SIZE=1
+CONFIG_MTDRAM_ABS_POS=C2200000
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_MTDRAM_SHARP_SL is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_DOC1000 is not set
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOCPROBE is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=1024
+# CONFIG_BLK_DEV_INITRD is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_BLK_DEV_LVM is not set
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_NETLINK_DEV=y
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+# CONFIG_FILTER is not set
+CONFIG_UNIX=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+# CONFIG_SYN_COOKIES is not set
+
+#
+#   IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
+# CONFIG_IP_NF_COMPAT_IPFWADM is not set
+# CONFIG_IPV6 is not set
+# CONFIG_KHTTPD is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_LLC is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_ARM_AM79C961A is not set
+# CONFIG_SUNLANCE is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_AT1700 is not set
+# CONFIG_DEPCA is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_NET_PCI is not set
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_MYRI_SBUS is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=y
+# CONFIG_PPP_SYNC_TTY is not set
+# CONFIG_PPP_DEFLATE is not set
+CONFIG_PPP_BSDCOMP=y
+# CONFIG_PPPOE is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+# CONFIG_STRIP is not set
+# CONFIG_WAVELAN is not set
+# CONFIG_ARLAN is not set
+# CONFIG_AIRONET4500 is not set
+# CONFIG_AIRONET4500_NONCS is not set
+# CONFIG_AIRONET4500_PROC is not set
+# CONFIG_AIRO is not set
+CONFIG_HERMES=y
+CONFIG_PCMCIA_HERMES=y
+# CONFIG_AIRO_CS is not set
+CONFIG_NET_WIRELESS=y
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# PCMCIA network device support
+#
+CONFIG_NET_PCMCIA=y
+# CONFIG_PCMCIA_3C589 is not set
+# CONFIG_PCMCIA_3C574 is not set
+# CONFIG_PCMCIA_FMVJ18X is not set
+CONFIG_PCMCIA_PCNET=y
+# CONFIG_PCMCIA_AXNET is not set
+# CONFIG_PCMCIA_NMCLAN is not set
+# CONFIG_PCMCIA_SMC91C92 is not set
+# CONFIG_PCMCIA_XIRC2PS is not set
+# CONFIG_ARCNET_COM20020_CS is not set
+# CONFIG_PCMCIA_IBMTR is not set
+# CONFIG_NET_PCMCIA_RADIO is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+CONFIG_IRDA=y
+# CONFIG_IRLAN is not set
+CONFIG_IRNET=m
+CONFIG_IRCOMM=y
+# CONFIG_IRDA_ULTRA is not set
+# CONFIG_IRDA_CACHE_LAST_LSAP is not set
+CONFIG_IRDA_FAST_RR=y
+# CONFIG_IRDA_DEBUG is not set
+
+#
+# Infrared-port device drivers
+#
+CONFIG_IRTTY_SIR=y
+CONFIG_IRPORT_SIR=y
+# CONFIG_DONGLE is not set
+# CONFIG_USB_IRDA is not set
+# CONFIG_NSC_FIR is not set
+# CONFIG_WINBOND_FIR is not set
+# CONFIG_TOSHIBA_FIR is not set
+# CONFIG_SMC_IRCC_FIR is not set
+# CONFIG_ALI_FIR is not set
+# CONFIG_VLSI_FIR is not set
+CONFIG_SA1100_FIR=y
+
+#
+# ATA/IDE/MFM/RLL support
+#
+CONFIG_IDE=y
+
+#
+# IDE, ATA and ATAPI Block devices
+#
+CONFIG_BLK_DEV_IDE=y
+# CONFIG_BLK_DEV_HD_IDE is not set
+# CONFIG_BLK_DEV_HD is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDEDISK_VENDOR is not set
+# CONFIG_BLK_DEV_IDEDISK_FUJITSU is not set
+# CONFIG_BLK_DEV_IDEDISK_IBM is not set
+# CONFIG_BLK_DEV_IDEDISK_MAXTOR is not set
+# CONFIG_BLK_DEV_IDEDISK_QUANTUM is not set
+# CONFIG_BLK_DEV_IDEDISK_SEAGATE is not set
+# CONFIG_BLK_DEV_IDEDISK_WD is not set
+# CONFIG_BLK_DEV_COMMERIAL is not set
+# CONFIG_BLK_DEV_TIVO is not set
+CONFIG_BLK_DEV_IDECS=y
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_CMD640_ENHANCED is not set
+# CONFIG_BLK_DEV_ISAPNP is not set
+# CONFIG_IDE_CHIPSETS is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_DMA_NONPCI is not set
+# CONFIG_BLK_DEV_IDE_MODES is not set
+# CONFIG_BLK_DEV_ATARAID is not set
+# CONFIG_BLK_DEV_ATARAID_PDC is not set
+# CONFIG_BLK_DEV_ATARAID_HPT is not set
+
+#
+# SCSI support
+#
+# CONFIG_SCSI is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+# CONFIG_I2O_BLOCK is not set
+# CONFIG_I2O_LAN is not set
+# CONFIG_I2O_SCSI is not set
+# CONFIG_I2O_PROC is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input core support
+#
+# CONFIG_INPUT is not set
+# CONFIG_INPUT_KEYBDEV is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+# CONFIG_VT_CONSOLE is not set
+CONFIG_SERIAL=y
+# CONFIG_SERIAL_CONSOLE is not set
+CONFIG_SERIAL_COLLIE=y
+# CONFIG_SERIAL_COLLIE_CONSOLE is not set
+CONFIG_COLLIE_DEFAULT_BAUDRATE=9600
+# CONFIG_SERIAL_EXTENDED is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_ANAKIN is not set
+# CONFIG_SERIAL_ANAKIN_CONSOLE is not set
+# CONFIG_SERIAL_AMBA is not set
+# CONFIG_SERIAL_AMBA_CONSOLE is not set
+# CONFIG_SERIAL_CLPS711X is not set
+# CONFIG_SERIAL_CLPS711X_CONSOLE is not set
+# CONFIG_SERIAL_21285 is not set
+# CONFIG_SERIAL_21285_OLD is not set
+# CONFIG_SERIAL_21285_CONSOLE is not set
+# CONFIG_SERIAL_UART00 is not set
+# CONFIG_SERIAL_UART00_CONSOLE is not set
+# CONFIG_SERIAL_SA1100 is not set
+# CONFIG_SERIAL_SA1100_CONSOLE is not set
+# CONFIG_SERIAL_8250 is not set
+# CONFIG_SERIAL_8250_CONSOLE is not set
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_MANY_PORTS is not set
+# CONFIG_SERIAL_8250_SHARE_IRQ is not set
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+# CONFIG_SERIAL_8250_MULTIPORT is not set
+# CONFIG_SERIAL_8250_HUB6 is not set
+CONFIG_UCB1200=y
+CONFIG_TOUCHSCREEN_UCB1200=y
+# CONFIG_AUDIO_UCB1200 is not set
+# CONFIG_ADC_UCB1200 is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=32
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# L3 serial bus support
+#
+# CONFIG_L3 is not set
+# CONFIG_L3_ALGOBIT is not set
+# CONFIG_L3_BIT_SA1100_GPIO is not set
+# CONFIG_L3_SA1111 is not set
+# CONFIG_BIT_SA1100_GPIO is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_QIC02_TAPE is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_INTEL_RNG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+CONFIG_SA1100_RTC=y
+# CONFIG_COTULLA_RTC is not set
+# CONFIG_ADS7846_TS is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+CONFIG_PCMCIA_SERIAL_CS=y
+CONFIG_PCMCIA_CHRDEV=y
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FS_SYNC=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+CONFIG_VFAT_FS=y
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_PROC_FS is not set
+# CONFIG_JFFS2_NODEMERGE is not set
+# CONFIG_JFFS2_DYNFRAGTREE is not set
+CONFIG_CRAMFS=y
+CONFIG_TMPFS=y
+CONFIG_RAMFS=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+CONFIG_MINIX_FS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFSD is not set
+# CONFIG_NFSD_V3 is not set
+CONFIG_SUNRPC=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_SMB_FS=y
+CONFIG_SMB_NLS_DEFAULT=y
+CONFIG_SMB_NLS_REMOTE="UTF8"
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+# CONFIG_ZISOFS_FS is not set
+CONFIG_ZLIB_FS_INFLATE=y
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_SMB_NLS=y
+CONFIG_NLS=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS_DEFAULT="UFT8"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+CONFIG_NLS_CODEPAGE_866=y
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+CONFIG_NLS_CODEPAGE_1251=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+CONFIG_NLS_KOI8_R=y
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Console drivers
+#
+CONFIG_PC_KEYMAP=y
+# CONFIG_VGA_CONSOLE is not set
+
+#
+# Frame-buffer support
+#
+CONFIG_FB=y
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FB_COLLIE=y
+# CONFIG_FB_ACORN is not set
+# CONFIG_FB_ANAKIN is not set
+# CONFIG_FB_CLPS711X is not set
+# CONFIG_FB_SA1100 is not set
+# CONFIG_FB_PXA is not set
+# CONFIG_FB_COTULLA is not set
+# CONFIG_FB_POODLE is not set
+# CONFIG_FB_CORGI is not set
+# CONFIG_SHARP_LOGO_SCREEN is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_VIRTUAL is not set
+CONFIG_FBCON_ADVANCED=y
+# CONFIG_FBCON_MFB is not set
+# CONFIG_FBCON_CFB2 is not set
+# CONFIG_FBCON_CFB4 is not set
+# CONFIG_FBCON_CFB8 is not set
+CONFIG_FBCON_CFB16=y
+# CONFIG_FBCON_CFB24 is not set
+# CONFIG_FBCON_CFB32 is not set
+# CONFIG_FBCON_AFB is not set
+# CONFIG_FBCON_ILBM is not set
+# CONFIG_FBCON_IPLAN2P2 is not set
+# CONFIG_FBCON_IPLAN2P4 is not set
+# CONFIG_FBCON_IPLAN2P8 is not set
+# CONFIG_FBCON_MAC is not set
+# CONFIG_FBCON_VGA_PLANES is not set
+# CONFIG_FBCON_VGA is not set
+# CONFIG_FBCON_HGA is not set
+CONFIG_FBCON_ROTATE_R=y
+# CONFIG_FBCON_ROTATE_L is not set
+# CONFIG_FBCON_FONTWIDTH8_ONLY is not set
+CONFIG_FBCON_FONTS=y
+# CONFIG_FONT_8x8 is not set
+# CONFIG_FONT_8x16 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_5x8 is not set
+CONFIG_FONT_4x6=y
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+# CONFIG_SOUND_BT878 is not set
+CONFIG_SOUND_COLLIE_SSP=y
+CONFIG_COLLIE_PCM1741=y
+# CONFIG_COLLIE_PCM1717 is not set
+CONFIG_SOUND_COLLIE_TC35143=y
+# CONFIG_SOUND_CMPCI is not set
+# CONFIG_SOUND_EMU10K1 is not set
+# CONFIG_MIDI_EMU10K1 is not set
+# CONFIG_SOUND_FUSION is not set
+# CONFIG_SOUND_CS4281 is not set
+# CONFIG_SOUND_ES1370 is not set
+# CONFIG_SOUND_ES1371 is not set
+# CONFIG_SOUND_ESSSOLO1 is not set
+# CONFIG_SOUND_MAESTRO is not set
+# CONFIG_SOUND_MAESTRO3 is not set
+# CONFIG_SOUND_ICH is not set
+# CONFIG_SOUND_RME96XX is not set
+# CONFIG_SOUND_SONICVIBES is not set
+# CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+# CONFIG_SOUND_VIA82CXXX is not set
+# CONFIG_MIDI_VIA82CXXX is not set
+# CONFIG_SOUND_SA1100 is not set
+# CONFIG_SOUND_UDA1341 is not set
+# CONFIG_SOUND_ASSABET_UDA1341 is not set
+# CONFIG_SOUND_H3600_UDA1341 is not set
+# CONFIG_SOUND_PANGOLIN_UDA1341 is not set
+# CONFIG_SOUND_SA1111_UDA1341 is not set
+# CONFIG_SOUND_SA1100SSP is not set
+# CONFIG_SOUND_OSS is not set
+# CONFIG_SOUND_WAVEARTIST is not set
+# CONFIG_SOUND_PXA_AC97 is not set
+# CONFIG_SOUND_POODLE is not set
+# CONFIG_SOUND_CORGI is not set
+# CONFIG_SOUND_TVMIXER is not set
+
+#
+# Multimedia Capabilities Port drivers
+#
+# CONFIG_MCP is not set
+# CONFIG_MCP_SA1100 is not set
+# CONFIG_MCP_UCB1200 is not set
+# CONFIG_MCP_UCB1200_AUDIO is not set
+# CONFIG_MCP_UCB1200_TS is not set
+# CONFIG_MCP_UCB1400_TS is not set
+
+#
+# USB support
+#
+CONFIG_USB=m
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_LONG_TIMEOUT is not set
+# CONFIG_USB_UHCI is not set
+# CONFIG_USB_UHCI_ALT is not set
+# CONFIG_USB_OHCI is not set
+# CONFIG_USB_OHCI_SA1111 is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_BLUETOOTH is not set
+# CONFIG_USB_STORAGE is not set
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_HP8200e is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_DC2XX is not set
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_SCANNER is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_HPUSBSCSI is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_CDCETHER is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_USS720 is not set
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA28 is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA28X is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA28XA is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA28XB is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA19 is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA18X is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA19W is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA49W is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_RIO500 is not set
+
+#
+# USB Device Support
+#
+CONFIG_USBD=m
+CONFIG_USBD_VENDORID=4dd
+CONFIG_USBD_PRODUCTID=8002
+CONFIG_USBD_PRODUCT_NAME="SL Series"
+CONFIG_USBD_MANUFACTURER="Sharp"
+CONFIG_USBD_USE_SERIAL_NUMBER=y
+CONFIG_USBD_SERIAL_NUMBER_STR="A01234"
+CONFIG_USBD_SELFPOWERED=y
+CONFIG_USBD_MONITOR=m
+CONFIG_USBD_PROCFS=y
+
+#
+# Network Function
+#
+CONFIG_USBD_NET=m
+CONFIG_USBD_NET_VENDORID=4DD
+CONFIG_USBD_NET_PRODUCTID=8004
+CONFIG_USBD_NET_IFNAME="usbd"
+CONFIG_USBD_NET_OUT_ENDPOINT=1
+CONFIG_USBD_NET_OUT_PKTSIZE=64
+CONFIG_USBD_NET_IN_ENDPOINT=2
+CONFIG_USBD_NET_IN_PKTSIZE=64
+# CONFIG_USBD_NET_ALWAYSUP is not set
+# CONFIG_USBD_NET_SAFE is not set
+# CONFIG_USBD_NET_MDLM is not set
+CONFIG_USBD_NET_CDC=y
+CONFIG_USBD_NET_REMOTE_MACADDR=""
+CONFIG_USBD_NET_REMOTE_OUI=400002
+# CONFIG_USBD_MAC_AS_SERIAL_NUMBER is not set
+CONFIG_USBD_NET_LOCAL_MACADDR="400001000001"
+CONFIG_USBD_NET_LOCAL_OUI=400001
+
+#
+# Serial Function
+#
+CONFIG_USBD_SERIAL=m
+CONFIG_USBD_SERIAL_VENDORID=4dd
+CONFIG_USBD_SERIAL_PRODUCTID=8002
+# CONFIG_USBD_SERIAL_CDC is not set
+CONFIG_USBD_SERIAL_OUT_ENDPOINT=1
+CONFIG_USBD_SERIAL_IN_PKTSIZE=64
+CONFIG_USBD_SERIAL_IN_ENDPOINT=2
+CONFIG_USBD_SERIAL_OUT_PKTSIZE=64
+# CONFIG_USBD_SERIAL_SAFE is not set
+
+#
+# USB Device Bus Interface Support
+#
+CONFIG_USBD_SA1100_BUS=m
+# CONFIG_USBD_TRAFFIC_KEEPAWAKE is not set
+CONFIG_USBD_STALL_TIMEOUT=0
+CONFIG_USBD_STALL_DISCONNECT_DURATION=2
+# CONFIG_USBD_GENERIC_BUS is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BLUEZ is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_COREDUMP_SIGNAL is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_NO_PGT_CACHE is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_WAITQ is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_LL is not set
+# CONFIG_DEBUG_DC21285_PORT is not set
+# CONFIG_DEBUG_CLPS711X_UART2 is not set
