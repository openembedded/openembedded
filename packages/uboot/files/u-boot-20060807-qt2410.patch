diff --git a/Makefile b/Makefile
index 128ae59..5d7b5bb 100644
--- a/Makefile
+++ b/Makefile
@@ -1638,6 +1638,9 @@ omap730p2_cs3boot_config :	unconfig
 sbc2410x_config: unconfig
 	@./mkconfig $(@:_config=) arm arm920t sbc2410x NULL s3c24x0
 
+qt2410_config	:	unconfig
+	@./mkconfig $(@:_config=) arm arm920t qt2410 NULL s3c24x0
+
 scb9328_config	:	unconfig
 	@./mkconfig $(@:_config=) arm arm920t scb9328 NULL imx
 
diff --git a/board/qt2410/Makefile b/board/qt2410/Makefile
new file mode 100644
index 0000000..407b256
--- /dev/null
+++ b/board/qt2410/Makefile
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= qt2410.o flash.o
+SOBJS	:= lowlevel_init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff --git a/board/qt2410/config.mk b/board/qt2410/config.mk
new file mode 100644
index 0000000..1af85da
--- /dev/null
+++ b/board/qt2410/config.mk
@@ -0,0 +1,25 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+# David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+#
+# SAMSUNG SMDK2410 board with S3C2410X (ARM920T) cpu
+#
+# see http://www.samsung.com/ for more information on SAMSUNG
+#
+
+#
+# SMDK2410 has 1 bank of 64 MB DRAM
+#
+# 3000'0000 to 3400'0000
+#
+# Linux-Kernel is expected to be at 3000'8000, entry 3000'8000
+# optionally with a ramdisk at 3080'0000
+#
+# we load ourself to 33F8'0000
+#
+# download area is 3300'0000
+#
+
+
+TEXT_BASE = 0x33F80000
diff --git a/board/qt2410/flash.c b/board/qt2410/flash.c
new file mode 100644
index 0000000..993946b
--- /dev/null
+++ b/board/qt2410/flash.c
@@ -0,0 +1,433 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+ulong myflush (void);
+
+
+#define FLASH_BANK_SIZE	PHYS_FLASH_SIZE
+#define MAIN_SECT_SIZE  0x10000	/* 64 KB */
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+
+
+#define CMD_READ_ARRAY		0x000000F0
+#define CMD_UNLOCK1		0x000000AA
+#define CMD_UNLOCK2		0x00000055
+#define CMD_ERASE_SETUP		0x00000080
+#define CMD_ERASE_CONFIRM	0x00000030
+#define CMD_PROGRAM		0x000000A0
+#define CMD_UNLOCK_BYPASS	0x00000020
+
+#define MEM_FLASH_ADDR1		(*(volatile u16 *)(CFG_FLASH_BASE + (0x00000555 << 1)))
+#define MEM_FLASH_ADDR2		(*(volatile u16 *)(CFG_FLASH_BASE + (0x000002AA << 1)))
+
+#define BIT_ERASE_DONE		0x00000080
+#define BIT_RDY_MASK		0x00000080
+#define BIT_PROGRAM_ERROR	0x00000020
+#define BIT_TIMEOUT		0x80000000	/* our flag */
+
+#define READY 1
+#define ERR   2
+#define TMO   4
+
+/*-----------------------------------------------------------------------
+ */
+
+ulong flash_init (void)
+{
+	int i, j;
+	ulong size = 0;
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		ulong flashbase = 0;
+
+		flash_info[i].flash_id =
+#if defined(CONFIG_AMD_LV400)
+			(AMD_MANUFACT & FLASH_VENDMASK) |
+			(AMD_ID_LV400B & FLASH_TYPEMASK);
+#elif defined(CONFIG_AMD_LV800)
+			(AMD_MANUFACT & FLASH_VENDMASK) |
+			(AMD_ID_LV800B & FLASH_TYPEMASK);
+#else
+#error "Unknown flash configured"
+#endif
+			flash_info[i].size = FLASH_BANK_SIZE;
+		flash_info[i].sector_count = CFG_MAX_FLASH_SECT;
+		memset (flash_info[i].protect, 0, CFG_MAX_FLASH_SECT);
+		if (i == 0)
+			flashbase = PHYS_FLASH_1;
+		else
+			panic ("configured too many flash banks!\n");
+		for (j = 0; j < flash_info[i].sector_count; j++) {
+			if (j <= 3) {
+				/* 1st one is 16 KB */
+				if (j == 0) {
+					flash_info[i].start[j] =
+						flashbase + 0;
+				}
+
+				/* 2nd and 3rd are both 8 KB */
+				if ((j == 1) || (j == 2)) {
+					flash_info[i].start[j] =
+						flashbase + 0x4000 + (j -
+								      1) *
+						0x2000;
+				}
+
+				/* 4th 32 KB */
+				if (j == 3) {
+					flash_info[i].start[j] =
+						flashbase + 0x8000;
+				}
+			} else {
+				flash_info[i].start[j] =
+					flashbase + (j - 3) * MAIN_SECT_SIZE;
+			}
+		}
+		size += flash_info[i].size;
+	}
+
+	flash_protect (FLAG_PROTECT_SET,
+		       CFG_FLASH_BASE,
+		       CFG_FLASH_BASE + monitor_flash_len - 1,
+		       &flash_info[0]);
+
+	flash_protect (FLAG_PROTECT_SET,
+		       CFG_ENV_ADDR,
+		       CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[0]);
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		printf ("AMD: ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (AMD_ID_LV400B & FLASH_TYPEMASK):
+		printf ("1x Amd29LV400BB (4Mbit)\n");
+		break;
+	case (AMD_ID_LV800B & FLASH_TYPEMASK):
+		printf ("1x Amd29LV800BB (8Mbit)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		goto Done;
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+		info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s", info->start[i],
+			info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+
+      Done:;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	ushort result;
+	int iflag, cflag, prot, sect;
+	int rc = ERR_OK;
+	int chip;
+
+	/* first look for protection bits */
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) !=
+	    (AMD_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+	cflag = icache_status ();
+	icache_disable ();
+	iflag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+		printf ("Erasing sector %2d ... ", sect);
+
+		/* arm simple, non interrupt dependent timer */
+		reset_timer_masked ();
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			vu_short *addr = (vu_short *) (info->start[sect]);
+
+			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+			MEM_FLASH_ADDR1 = CMD_ERASE_SETUP;
+
+			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+			*addr = CMD_ERASE_CONFIRM;
+
+			/* wait until flash is ready */
+			chip = 0;
+
+			do {
+				result = *addr;
+
+				/* check timeout */
+				if (get_timer_masked () >
+				    CFG_FLASH_ERASE_TOUT) {
+					MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
+					chip = TMO;
+					break;
+				}
+
+				if (!chip
+				    && (result & 0xFFFF) & BIT_ERASE_DONE)
+					chip = READY;
+
+				if (!chip
+				    && (result & 0xFFFF) & BIT_PROGRAM_ERROR)
+					chip = ERR;
+
+			} while (!chip);
+
+			MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
+
+			if (chip == ERR) {
+				rc = ERR_PROG_ERROR;
+				goto outahere;
+			}
+			if (chip == TMO) {
+				rc = ERR_TIMOUT;
+				goto outahere;
+			}
+
+			printf ("ok.\n");
+		} else {	/* it was protected */
+
+			printf ("protected!\n");
+		}
+	}
+
+	if (ctrlc ())
+		printf ("User Interrupt!\n");
+
+      outahere:
+	/* allow flash to settle - wait 10 ms */
+	udelay_masked (10000);
+
+	if (iflag)
+		enable_interrupts ();
+
+	if (cflag)
+		icache_enable ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+volatile static int write_hword (flash_info_t * info, ulong dest, ushort data)
+{
+	vu_short *addr = (vu_short *) dest;
+	ushort result;
+	int rc = ERR_OK;
+	int cflag, iflag;
+	int chip;
+
+	/*
+	 * Check if Flash is (sufficiently) erased
+	 */
+	result = *addr;
+	if ((result & data) != data)
+		return ERR_NOT_ERASED;
+
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+	cflag = icache_status ();
+	icache_disable ();
+	iflag = disable_interrupts ();
+
+	MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+	MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+	MEM_FLASH_ADDR1 = CMD_UNLOCK_BYPASS;
+	*addr = CMD_PROGRAM;
+	*addr = data;
+
+	/* arm simple, non interrupt dependent timer */
+	reset_timer_masked ();
+
+	/* wait until flash is ready */
+	chip = 0;
+	do {
+		result = *addr;
+
+		/* check timeout */
+		if (get_timer_masked () > CFG_FLASH_ERASE_TOUT) {
+			chip = ERR | TMO;
+			break;
+		}
+		if (!chip && ((result & 0x80) == (data & 0x80)))
+			chip = READY;
+
+		if (!chip && ((result & 0xFFFF) & BIT_PROGRAM_ERROR)) {
+			result = *addr;
+
+			if ((result & 0x80) == (data & 0x80))
+				chip = READY;
+			else
+				chip = ERR;
+		}
+
+	} while (!chip);
+
+	*addr = CMD_READ_ARRAY;
+
+	if (chip == ERR || *addr != data)
+		rc = ERR_PROG_ERROR;
+
+	if (iflag)
+		enable_interrupts ();
+
+	if (cflag)
+		icache_enable ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	int l;
+	int i, rc;
+	ushort data;
+
+	wp = (addr & ~1);	/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+		for (; i < 2 && cnt > 0; ++i) {
+			data = (data >> 8) | (*src++ << 8);
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < 2; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+
+		if ((rc = write_hword (info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 2;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 2) {
+		data = *((vu_short *) src);
+		if ((rc = write_hword (info, wp, data)) != 0) {
+			return (rc);
+		}
+		src += 2;
+		wp += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 0) {
+		return ERR_OK;
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
+		data = (data >> 8) | (*src++ << 8);
+		--cnt;
+	}
+	for (; i < 2; ++i, ++cp) {
+		data = (data >> 8) | (*(uchar *) cp << 8);
+	}
+
+	return write_hword (info, wp, data);
+}
diff --git a/board/qt2410/lowlevel_init.S b/board/qt2410/lowlevel_init.S
new file mode 100644
index 0000000..310f2a0
--- /dev/null
+++ b/board/qt2410/lowlevel_init.S
@@ -0,0 +1,167 @@
+/*
+ * Memory Setup stuff - taken from blob memsetup.S
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
+ *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * Modified for the Samsung SMDK2410 by
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+
+
+/* some parameters for the board */
+
+/*
+ *
+ * Taken from linux/arch/arm/boot/compressed/head-s3c2410.S
+ *
+ * Copyright (C) 2002 Samsung Electronics SW.LEE  <hitchcar@sec.samsung.com>
+ *
+ */
+
+#define BWSCON	0x48000000
+
+/* BWSCON */
+#define DW8		 	(0x0)
+#define DW16		 	(0x1)
+#define DW32		 	(0x2)
+#define WAIT		 	(0x1<<2)
+#define UBLB		 	(0x1<<3)
+
+#define B1_BWSCON	  	(DW32)
+#define B2_BWSCON	  	(DW16)
+#define B3_BWSCON	  	(DW16 + WAIT + UBLB)
+#define B4_BWSCON	  	(DW16)
+#define B5_BWSCON	  	(DW16)
+#define B6_BWSCON	  	(DW32)
+#define B7_BWSCON	  	(DW32)
+
+/* BANK0CON */
+#define B0_Tacs		 	0x0	/*  0clk */
+#define B0_Tcos		 	0x0	/*  0clk */
+#define B0_Tacc		 	0x7	/* 14clk */
+#define B0_Tcoh		 	0x0	/*  0clk */
+#define B0_Tah		 	0x0	/*  0clk */
+#define B0_Tacp		 	0x0
+#define B0_PMC		 	0x0	/* normal */
+
+/* BANK1CON */
+#define B1_Tacs		 	0x0	/*  0clk */
+#define B1_Tcos		 	0x0	/*  0clk */
+#define B1_Tacc		 	0x7	/* 14clk */
+#define B1_Tcoh		 	0x0	/*  0clk */
+#define B1_Tah		 	0x0	/*  0clk */
+#define B1_Tacp		 	0x0
+#define B1_PMC		 	0x0
+
+#define B2_Tacs		 	0x0
+#define B2_Tcos		 	0x0
+#define B2_Tacc		 	0x7
+#define B2_Tcoh		 	0x0
+#define B2_Tah		 	0x0
+#define B2_Tacp		 	0x0
+#define B2_PMC		 	0x0
+
+#define B3_Tacs		 	0x0	/*  0clk */
+#define B3_Tcos		 	0x3	/*  4clk */
+#define B3_Tacc		 	0x7	/* 14clk */
+#define B3_Tcoh		 	0x1	/*  1clk */
+#define B3_Tah		 	0x0	/*  0clk */
+#define B3_Tacp		 	0x3     /*  6clk */
+#define B3_PMC		 	0x0	/* normal */
+
+#define B4_Tacs		 	0x0	/*  0clk */
+#define B4_Tcos		 	0x0	/*  0clk */
+#define B4_Tacc		 	0x7	/* 14clk */
+#define B4_Tcoh		 	0x0	/*  0clk */
+#define B4_Tah		 	0x0	/*  0clk */
+#define B4_Tacp		 	0x0
+#define B4_PMC		 	0x0	/* normal */
+
+#define B5_Tacs		 	0x0	/*  0clk */
+#define B5_Tcos		 	0x0	/*  0clk */
+#define B5_Tacc		 	0x7	/* 14clk */
+#define B5_Tcoh		 	0x0	/*  0clk */
+#define B5_Tah		 	0x0	/*  0clk */
+#define B5_Tacp		 	0x0
+#define B5_PMC		 	0x0	/* normal */
+
+#define B6_MT		 	0x3	/* SDRAM */
+#define B6_Trcd	 	 	0x1
+#define B6_SCAN		 	0x1	/* 9bit */
+
+#define B7_MT		 	0x3	/* SDRAM */
+#define B7_Trcd		 	0x1	/* 3clk */
+#define B7_SCAN		 	0x1	/* 9bit */
+
+/* REFRESH parameter */
+#define REFEN		 	0x1	/* Refresh enable */
+#define TREFMD		 	0x0	/* CBR(CAS before RAS)/Auto refresh */
+#define Trp		 	0x0	/* 2clk */
+#define Trc		 	0x3	/* 7clk */
+#define Tchr		 	0x2	/* 3clk */
+#define REFCNT		 	1113	/* period=15.6us, HCLK=60Mhz, (2048+1-15.6*60) */
+/**************************************/
+
+_TEXT_BASE:
+	.word	TEXT_BASE
+
+.globl lowlevel_init
+lowlevel_init:
+	/* memory control configuration */
+	/* make r0 relative the current location so that it */
+	/* reads SMRDATA out of FLASH rather than memory ! */
+	ldr     r0, =SMRDATA
+	ldr	r1, _TEXT_BASE
+	sub	r0, r0, r1
+	ldr	r1, =BWSCON	/* Bus Width Status Controller */
+	add     r2, r0, #13*4
+0:
+	ldr     r3, [r0], #4
+	str     r3, [r1], #4
+	cmp     r2, r0
+	bne     0b
+
+	/* everything is fine now */
+	mov	pc, lr
+
+	.ltorg
+/* the literal pools origin */
+
+SMRDATA:
+    .word (0+(B1_BWSCON<<4)+(B2_BWSCON<<8)+(B3_BWSCON<<12)+(B4_BWSCON<<16)+(B5_BWSCON<<20)+(B6_BWSCON<<24)+(B7_BWSCON<<28))
+    .word ((B0_Tacs<<13)+(B0_Tcos<<11)+(B0_Tacc<<8)+(B0_Tcoh<<6)+(B0_Tah<<4)+(B0_Tacp<<2)+(B0_PMC))
+    .word ((B1_Tacs<<13)+(B1_Tcos<<11)+(B1_Tacc<<8)+(B1_Tcoh<<6)+(B1_Tah<<4)+(B1_Tacp<<2)+(B1_PMC))
+    .word ((B2_Tacs<<13)+(B2_Tcos<<11)+(B2_Tacc<<8)+(B2_Tcoh<<6)+(B2_Tah<<4)+(B2_Tacp<<2)+(B2_PMC))
+    .word ((B3_Tacs<<13)+(B3_Tcos<<11)+(B3_Tacc<<8)+(B3_Tcoh<<6)+(B3_Tah<<4)+(B3_Tacp<<2)+(B3_PMC))
+    .word ((B4_Tacs<<13)+(B4_Tcos<<11)+(B4_Tacc<<8)+(B4_Tcoh<<6)+(B4_Tah<<4)+(B4_Tacp<<2)+(B4_PMC))
+    .word ((B5_Tacs<<13)+(B5_Tcos<<11)+(B5_Tacc<<8)+(B5_Tcoh<<6)+(B5_Tah<<4)+(B5_Tacp<<2)+(B5_PMC))
+    .word ((B6_MT<<15)+(B6_Trcd<<2)+(B6_SCAN))
+    .word ((B7_MT<<15)+(B7_Trcd<<2)+(B7_SCAN))
+    .word ((REFEN<<23)+(TREFMD<<22)+(Trp<<20)+(Trc<<18)+(Tchr<<16)+REFCNT)
+    .word 0x32
+    .word 0x30
+    .word 0x30
diff --git a/board/qt2410/qt2410.c b/board/qt2410/qt2410.c
new file mode 100644
index 0000000..133b748
--- /dev/null
+++ b/board/qt2410/qt2410.c
@@ -0,0 +1,130 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <s3c2410.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define FCLK_SPEED 1
+
+#if FCLK_SPEED==0		/* Fout = 203MHz, Fin = 12MHz for Audio */
+#define M_MDIV	0xC3
+#define M_PDIV	0x4
+#define M_SDIV	0x1
+#elif FCLK_SPEED==1		/* Fout = 202.8MHz */
+#if 0
+#define M_MDIV	0xA1
+#define M_PDIV	0x3
+#define M_SDIV	0x1
+#else
+#define M_MDIV	0x5c
+#define M_PDIV	0x4
+#define M_SDIV	0x0
+#endif
+#endif
+
+#define USB_CLOCK 1
+
+#if USB_CLOCK==0
+#define U_M_MDIV	0xA1
+#define U_M_PDIV	0x3
+#define U_M_SDIV	0x1
+#elif USB_CLOCK==1
+#define U_M_MDIV	0x48
+#define U_M_PDIV	0x3
+#define U_M_SDIV	0x2
+#endif
+
+static inline void delay (unsigned long loops)
+{
+	__asm__ volatile ("1:\n"
+	  "subs %0, %1, #1\n"
+	  "bne 1b":"=r" (loops):"0" (loops));
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+	S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+
+	/* to reduce PLL lock time, adjust the LOCKTIME register */
+	clk_power->LOCKTIME = 0xFFFFFF;
+
+	/* configure MPLL */
+	clk_power->MPLLCON = ((M_MDIV << 12) + (M_PDIV << 4) + M_SDIV);
+
+	/* some delay between MPLL and UPLL */
+	delay (4000);
+
+	/* configure UPLL */
+	clk_power->UPLLCON = ((U_M_MDIV << 12) + (U_M_PDIV << 4) + U_M_SDIV);
+
+	/* some delay between MPLL and UPLL */
+	delay (8000);
+
+	/* set up the I/O ports */
+	gpio->GPACON = 0x007FFFFF;
+	gpio->GPBCON = 0x00044555;
+	gpio->GPBUP = 0x000007FF;
+	gpio->GPCCON = 0xAAAAAAAA;
+	gpio->GPCUP = 0x0000FFFF;
+	gpio->GPDCON = 0xAAAAAAAA;
+	gpio->GPDUP = 0x0000FFFF;
+	gpio->GPECON = 0xAAAAAAAA;
+	gpio->GPEUP = 0x0000FFFF;
+	gpio->GPFCON = 0x000055AA;
+	gpio->GPFUP = 0x000000FF;
+	gpio->GPGCON = 0xFF95FFBA;
+	//gpio->GPGUP = 0x0000FFFF;
+	gpio->GPGUP = 0x0000AFEF;
+	gpio->GPHCON = 0x0028FAAA;
+	gpio->GPHUP = 0x000007FF;
+
+	/* arch number of SMDK2410-Board */
+	gd->bd->bi_arch_number = MACH_TYPE_QT2410;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x30000100;
+
+	icache_enable();
+	dcache_enable();
+
+	return 0;
+}
+
+int dram_init (void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+	return 0;
+}
diff --git a/board/qt2410/u-boot.lds b/board/qt2410/u-boot.lds
new file mode 100644
index 0000000..f4fbf96
--- /dev/null
+++ b/board/qt2410/u-boot.lds
@@ -0,0 +1,57 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+/*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/arm920t/start.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff --git a/cpu/arm920t/s3c24x0/Makefile b/cpu/arm920t/s3c24x0/Makefile
index af9e4ef..10f33f2 100644
--- a/cpu/arm920t/s3c24x0/Makefile
+++ b/cpu/arm920t/s3c24x0/Makefile
@@ -26,7 +26,7 @@ include $(TOPDIR)/config.mk
 LIB	= lib$(SOC).a
 
 OBJS	= i2c.o interrupts.o serial.o speed.o \
-	  usb_ohci.o
+	  usb_ohci.o mmc.o nand_read.o nand.o
 
 all:	.depend $(LIB)
 
diff --git a/cpu/arm920t/s3c24x0/mmc.c b/cpu/arm920t/s3c24x0/mmc.c
new file mode 100644
index 0000000..b7057e2
--- /dev/null
+++ b/cpu/arm920t/s3c24x0/mmc.c
@@ -0,0 +1,568 @@
+/*
+ * u-boot S3C2410 MMC/SD card driver
+ * (C) Copyright 2006 by Harald Welte <laforge@gnumonks.org>
+ *
+ * based on u-boot pxa MMC driver and linux/drivers/mmc/s3c2410mci.c
+ * (C) 2005-2005 Thomas Kleffel
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <mmc.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <s3c2410.h>
+#include <part.h>
+
+#ifdef CONFIG_MMC
+
+#define CONFIG_MMC_WIDE
+
+//#define MMC_DEBUG
+
+#ifdef MMC_DEBUG
+#ifdef debug
+#undef debug
+#endif
+#define debug printf
+#endif
+
+static S3C2410_SDI *sdi;
+
+extern int
+fat_register_device(block_dev_desc_t *dev_desc, int part_no);
+
+static block_dev_desc_t mmc_dev;
+
+block_dev_desc_t * mmc_get_dev(int dev)
+{
+	return ((block_dev_desc_t *)&mmc_dev);
+}
+
+/*
+ * FIXME needs to read cid and csd info to determine block size
+ * and other parameters
+ */
+static uchar mmc_buf[MMC_BLOCK_SIZE];
+static mmc_csd_t mmc_csd;
+static int mmc_ready = 0;
+static int wide = 0;
+
+
+#define CMD_F_RESP	0x01
+#define CMD_F_RESP_LONG	0x02
+
+static u_int32_t *
+/****************************************************/
+mmc_cmd(ushort cmd, ulong arg, ushort flags)
+/****************************************************/
+{
+	static u_int32_t resp[5];
+	ulong status;
+	int i;
+
+	u_int32_t ccon, csta;
+	u_int32_t csta_rdy_bit = S3C2410_SDICMDSTAT_CMDSENT;
+
+	memset(resp, 0, sizeof(resp));
+
+	debug("mmc_cmd CMD%d arg=0x%08x flags=%x\n", cmd, arg, flags);
+
+	sdi->SDICSTA = 0xffffffff;
+	sdi->SDIDSTA = 0xffffffff;
+	sdi->SDIFSTA = 0xffffffff;
+
+	sdi->SDICARG = arg;
+
+	ccon = cmd & S3C2410_SDICMDCON_INDEX;
+	ccon |= S3C2410_SDICMDCON_SENDERHOST|S3C2410_SDICMDCON_CMDSTART;
+	
+	if (flags & CMD_F_RESP) {
+		ccon |= S3C2410_SDICMDCON_WAITRSP;
+		csta_rdy_bit = S3C2410_SDICMDSTAT_RSPFIN; /* 1 << 9 */
+	}
+
+	if (flags & CMD_F_RESP_LONG)
+		ccon |= S3C2410_SDICMDCON_LONGRSP;
+
+	sdi->SDICCON = ccon;
+
+	while (1) {
+		csta = sdi->SDICSTA;
+		if (csta & csta_rdy_bit)
+			break;
+		if (csta & S3C2410_SDICMDSTAT_CMDTIMEOUT) {
+			printf("===============> MMC CMD Timeout\n");
+			sdi->SDICSTA |= S3C2410_SDICMDSTAT_CMDTIMEOUT;
+			break;
+		}
+	}
+
+	debug("final MMC CMD status 0x%x\n", csta);
+
+	sdi->SDICSTA |= csta_rdy_bit;
+
+	if (flags & CMD_F_RESP) {
+		resp[0] = sdi->SDIRSP0;
+		resp[1] = sdi->SDIRSP1;
+		resp[2] = sdi->SDIRSP2;
+		resp[3] = sdi->SDIRSP3;
+	} 
+
+#if 0
+	for (i=0; i<4; i ++) {
+		debug("MMC resp[%d] = 0x%08x\n", i, resp[i]);
+	}
+#endif
+
+	return resp;
+}
+
+#define FIFO_FILL(host) ((host->SDIFSTA & S3C2410_SDIFSTA_COUNTMASK) >> 2)
+
+static int
+/****************************************************/
+mmc_block_read(uchar *dst, ulong src, ulong len)
+/****************************************************/
+{
+	u_int32_t dcon, fifo;
+	u_int32_t *dst_u32 = (u_int32_t *)dst;
+	u_int32_t *resp;
+
+	if (len == 0) {
+		return 0;
+	}
+
+	debug("mmc_block_rd dst %lx src %lx len %d\n", (ulong)dst, src, len);
+
+	/* set block len */
+	resp = mmc_cmd(MMC_CMD_SET_BLOCKLEN, len, CMD_F_RESP);
+	sdi->SDIBSIZE = len;
+
+	//sdi->SDIPRE = 0xff;
+
+	/* setup data */
+	dcon = (len >> 9) & S3C2410_SDIDCON_BLKNUM_MASK;
+	dcon |= S3C2410_SDIDCON_BLOCKMODE;
+	dcon |= S3C2410_SDIDCON_RXAFTERCMD|S3C2410_SDIDCON_XFER_RXSTART;
+	if (wide)
+		dcon |= S3C2410_SDIDCON_WIDEBUS;
+	sdi->SDIDCON = dcon;
+
+	/* send read command */
+	resp = mmc_cmd(MMC_CMD_READ_BLOCK, src, CMD_F_RESP);
+
+	while (len > 0) {
+		u_int32_t sdidsta = sdi->SDIDSTA;
+		fifo = FIFO_FILL(sdi);
+		if (sdidsta & (S3C2410_SDIDSTA_FIFOFAIL|
+				S3C2410_SDIDSTA_CRCFAIL|
+				S3C2410_SDIDSTA_RXCRCFAIL|
+				S3C2410_SDIDSTA_DATATIMEOUT)) {
+			printf("mmc_block_read: err SDIDSTA=0x%08x\n", sdidsta);
+			return -EIO;
+		}
+
+		while (fifo--) {
+			//debug("dst_u32 = 0x%08x\n", dst_u32);
+			*(dst_u32++) = sdi->SDIDAT;
+			if (len >= 4)
+				len -= 4;
+			else {
+				len = 0;
+				break;
+			}
+		}
+	}
+
+#if 1
+	debug("waiting for SDIDSTA  (currently 0x%08x\n", sdi->SDIDSTA);
+	while (!(sdi->SDIDSTA & (1 << 4))) {}
+	debug("done waiting for SDIDSTA (currently 0x%08x\n", sdi->SDIDSTA);
+#endif
+
+	sdi->SDIDCON = 0;
+
+#if 0
+	if (!(sdi->SDIDSTA & S3C2410_SDIDSTA_XFERFINISH))
+		printf("mmc_block_read; transfer not finished!\n");
+#endif
+
+	return 0;
+}
+
+static int
+/****************************************************/
+mmc_block_write(ulong dst, uchar *src, int len)
+/****************************************************/
+{
+#if 0
+	uchar *resp;
+	ushort argh, argl;
+	ulong status;
+
+	if (len == 0) {
+		return 0;
+	}
+
+	debug("mmc_block_wr dst %lx src %lx len %d\n", dst, (ulong)src, len);
+
+	argh = len >> 16;
+	argl = len & 0xffff;
+
+	/* set block len */
+	resp = mmc_cmd(MMC_CMD_SET_BLOCKLEN, argh, argl, CMD_F_RESP);
+
+	/* send write command */
+	argh = dst >> 16;
+	argl = dst & 0xffff;
+	MMC_STRPCL = MMC_STRPCL_STOP_CLK;
+	MMC_NOB = 1;
+	MMC_BLKLEN = len;
+	resp = mmc_cmd(MMC_CMD_WRITE_BLOCK, dst, CMD_F_RESP,
+			MMC_CMDAT_R1|MMC_CMDAT_WRITE|MMC_CMDAT_BLOCK|MMC_CMDAT_DATA_EN);
+
+	MMC_I_MASK = ~MMC_I_MASK_TXFIFO_WR_REQ;
+	while (len) {
+		if (MMC_I_REG & MMC_I_REG_TXFIFO_WR_REQ) {
+			int i, bytes = min(32,len);
+
+			for (i=0; i<bytes; i++) {
+				MMC_TXFIFO = *src++;
+			}
+			if (bytes < 32) {
+				MMC_PRTBUF = MMC_PRTBUF_BUF_PART_FULL;
+			}
+			len -= bytes;
+		}
+		status = MMC_STAT;
+		if (status & MMC_STAT_ERRORS) {
+			printf("MMC_STAT error %lx\n", status);
+			return -1;
+		}
+	}
+	MMC_I_MASK = ~MMC_I_MASK_DATA_TRAN_DONE;
+	while (!(MMC_I_REG & MMC_I_REG_DATA_TRAN_DONE));
+	MMC_I_MASK = ~MMC_I_MASK_PRG_DONE;
+	while (!(MMC_I_REG & MMC_I_REG_PRG_DONE));
+	status = MMC_STAT;
+	if (status & MMC_STAT_ERRORS) {
+		printf("MMC_STAT error %lx\n", status);
+		return -1;
+	}
+#endif
+	return 0;
+}
+
+
+int
+/****************************************************/
+mmc_read(ulong src, uchar *dst, int size)
+/****************************************************/
+{
+	ulong end, part_start, part_end, part_len, aligned_start, aligned_end;
+	ulong mmc_block_size, mmc_block_address;
+
+	if (size == 0) {
+		return 0;
+	}
+
+	if (!mmc_ready) {
+		printf("Please initialize the MMC first\n");
+		return -1;
+	}
+
+	mmc_block_size = MMC_BLOCK_SIZE;
+	mmc_block_address = ~(mmc_block_size - 1);
+
+	src -= CFG_MMC_BASE;
+	end = src + size;
+	part_start = ~mmc_block_address & src;
+	part_end = ~mmc_block_address & end;
+	aligned_start = mmc_block_address & src;
+	aligned_end = mmc_block_address & end;
+
+	/* all block aligned accesses */
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_start) {
+		part_len = mmc_block_size - part_start;
+		debug("ps src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_start, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(dst, mmc_buf+part_start, part_len);
+		dst += part_len;
+		src += part_len;
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	for (; src < aligned_end; src += mmc_block_size, dst += mmc_block_size) {
+		debug("al src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read((uchar *)(dst), src, mmc_block_size)) < 0) {
+			return -1;
+		}
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_end && src < end) {
+		debug("pe src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_end, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(dst, mmc_buf, part_end);
+	}
+	return 0;
+}
+
+int
+/****************************************************/
+mmc_write(uchar *src, ulong dst, int size)
+/****************************************************/
+{
+	ulong end, part_start, part_end, part_len, aligned_start, aligned_end;
+	ulong mmc_block_size, mmc_block_address;
+
+	if (size == 0) {
+		return 0;
+	}
+
+	if (!mmc_ready) {
+		printf("Please initialize the MMC first\n");
+		return -1;
+	}
+
+	mmc_block_size = MMC_BLOCK_SIZE;
+	mmc_block_address = ~(mmc_block_size - 1);
+
+	dst -= CFG_MMC_BASE;
+	end = dst + size;
+	part_start = ~mmc_block_address & dst;
+	part_end = ~mmc_block_address & end;
+	aligned_start = mmc_block_address & dst;
+	aligned_end = mmc_block_address & end;
+
+	/* all block aligned accesses */
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_start) {
+		part_len = mmc_block_size - part_start;
+		debug("ps src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		(ulong)src, dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_start, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(mmc_buf+part_start, src, part_len);
+		if ((mmc_block_write(aligned_start, mmc_buf, mmc_block_size)) < 0) {
+			return -1;
+		}
+		dst += part_len;
+		src += part_len;
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	for (; dst < aligned_end; src += mmc_block_size, dst += mmc_block_size) {
+		debug("al src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_write(dst, (uchar *)src, mmc_block_size)) < 0) {
+			return -1;
+		}
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_end && dst < end) {
+		debug("pe src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_end, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(mmc_buf, src, part_end);
+		if ((mmc_block_write(aligned_end, mmc_buf, mmc_block_size)) < 0) {
+			return -1;
+		}
+	}
+	return 0;
+}
+
+ulong
+/****************************************************/
+mmc_bread(int dev_num, ulong blknr, ulong blkcnt, ulong *dst)
+/****************************************************/
+{
+	int mmc_block_size = MMC_BLOCK_SIZE;
+	ulong src = blknr * mmc_block_size + CFG_MMC_BASE;
+
+	mmc_read(src, (uchar *)dst, blkcnt*mmc_block_size);
+	return blkcnt;
+}
+
+static u_int16_t rca = MMC_DEFAULT_RCA;
+
+static u_int32_t mmc_size(const struct mmc_csd *csd)
+{
+	u_int32_t block_len, mult, blocknr;
+
+	block_len = csd->read_bl_len << 12;
+	mult = csd->c_size_mult1 << 8;
+	blocknr = (csd->c_size+1) * mult;
+
+	return blocknr * block_len;
+}
+
+int
+/****************************************************/
+mmc_init(int verbose)
+/****************************************************/
+{
+ 	int retries, rc = -ENODEV;
+	int is_sd = 0;
+	u_int32_t *resp;
+	S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+	
+	sdi = S3C2410_GetBase_SDI();
+
+	debug("mmc_init(PCLK=%u)\n", get_PCLK());
+
+	clk_power->CLKCON |= (1 << 9);
+
+	/* S3C2410 has some bug that prevents reliable operation at higher speed */
+	//sdi->SDIPRE = 0x3e;  /* SDCLK = PCLK/2 / (SDIPRE+1) = 396kHz */
+	sdi->SDIPRE = 0x02;  /* SDCLK = PCLK/2 / (SDIPRE+1) = 396kHz */
+	sdi->SDIBSIZE = 512;
+	sdi->SDIDTIMER = 0xffff;
+	sdi->SDIIMSK = 0x0;
+	sdi->SDICON = S3C2410_SDICON_FIFORESET|S3C2440_SDICON_MMCCLOCK;
+	udelay(125000); /* FIXME: 74 SDCLK cycles */
+
+	mmc_csd.c_size = 0;
+
+	/* reset */
+	retries = 10;
+	resp = mmc_cmd(MMC_CMD_RESET, 0, 0);
+
+	printf("trying to detect SD Card...\n");
+	while (retries--) {
+		int i;
+		udelay(100000);
+		resp = mmc_cmd(55, 0x00000000, CMD_F_RESP);
+		resp = mmc_cmd(41, 0x00300000, CMD_F_RESP);
+
+		if (resp[0] & (1 << 31)) {
+			is_sd = 1;
+			break;
+		}
+	}
+
+	if (retries == 0 && !is_sd) {
+		retries = 10;
+		printf("failed to detect SD Card, trying MMC\n");
+		resp = mmc_cmd(MMC_CMD_SEND_OP_COND, 0x00ffc000, CMD_F_RESP);
+		while (retries-- && resp && !(resp[4] & 0x80)) {
+			debug("resp %x %x\n", resp[0], resp[1]);
+			udelay(50);
+			resp = mmc_cmd(1, 0x00ffff00, CMD_F_RESP);
+		}
+	}
+
+	/* try to get card id */
+	resp = mmc_cmd(MMC_CMD_ALL_SEND_CID, 0, CMD_F_RESP|CMD_F_RESP_LONG);
+	if (resp) {
+		/* TODO configure mmc driver depending on card attributes */
+		mmc_cid_t *cid = (mmc_cid_t *)resp;
+		if (verbose) {
+			printf("MMC found. Card desciption is:\n");
+			printf("Manufacturer ID = %02x%02x%02x\n",
+							cid->id[0], cid->id[1], cid->id[2]);
+			printf("HW/FW Revision = %x %x\n",cid->hwrev, cid->fwrev);
+			cid->hwrev = cid->fwrev = 0;	/* null terminate string */
+			printf("Product Name = %s\n",cid->name);
+			printf("Serial Number = %02x%02x%02x\n",
+							cid->sn[0], cid->sn[1], cid->sn[2]);
+			printf("Month = %d\n",cid->month);
+			printf("Year = %d\n",1997 + cid->year);
+		}
+		/* fill in device description */
+		mmc_dev.if_type = IF_TYPE_MMC;
+		mmc_dev.part_type = PART_TYPE_DOS;
+		mmc_dev.dev = 0;
+		mmc_dev.lun = 0;
+		mmc_dev.type = 0;
+		/* FIXME fill in the correct size (is set to 32MByte) */
+		mmc_dev.blksz = 512;
+		mmc_dev.lba = 0x10000;
+		sprintf(mmc_dev.vendor,"Man %02x%02x%02x Snr %02x%02x%02x",
+				cid->id[0], cid->id[1], cid->id[2],
+				cid->sn[0], cid->sn[1], cid->sn[2]);
+		sprintf(mmc_dev.product,"%s",cid->name);
+		sprintf(mmc_dev.revision,"%x %x",cid->hwrev, cid->fwrev);
+		mmc_dev.removable = 0;
+		mmc_dev.block_read = mmc_bread;
+
+		/* MMC exists, get CSD too */
+		resp = mmc_cmd(MMC_CMD_SET_RCA, MMC_DEFAULT_RCA, CMD_F_RESP);
+		if (is_sd)
+			rca = resp[0] >> 16;
+			
+		resp = mmc_cmd(MMC_CMD_SEND_CSD, rca<<16, CMD_F_RESP|CMD_F_RESP_LONG);
+		if (resp) {
+			mmc_csd_t *csd = (mmc_csd_t *)resp;
+			memcpy(&mmc_csd, csd, sizeof(csd));
+			rc = 0;
+			mmc_ready = 1;
+			/* FIXME add verbose printout for csd */
+			printf("READ_BL_LEN=%u, C_SIZE_MULT=%u, C_SIZE=%u\n", 
+				csd->read_bl_len, csd->c_size_mult1, csd->c_size);
+			printf("size = %u\n", mmc_size(csd));
+		}
+	}
+
+	resp = mmc_cmd(MMC_CMD_SELECT_CARD, rca<<16, CMD_F_RESP);
+
+#ifdef CONFIG_MMC_WIDE
+	if (is_sd) {
+		resp = mmc_cmd(55, rca<<16, CMD_F_RESP);
+		resp = mmc_cmd(6, 0x02, CMD_F_RESP);
+		wide = 1;
+	}
+#endif
+
+	fat_register_device(&mmc_dev,1); /* partitions start counting with 1 */
+
+	return rc;
+}
+
+int
+mmc_ident(block_dev_desc_t *dev)
+{
+	return 0;
+}
+
+int
+mmc2info(ulong addr)
+{
+	/* FIXME hard codes to 32 MB device */
+	if (addr >= CFG_MMC_BASE && addr < CFG_MMC_BASE + 0x02000000) {
+		return 1;
+	}
+	return 0;
+}
+
+#endif	/* CONFIG_MMC */
diff --git a/cpu/arm920t/s3c24x0/nand.c b/cpu/arm920t/s3c24x0/nand.c
new file mode 100644
index 0000000..f720229
--- /dev/null
+++ b/cpu/arm920t/s3c24x0/nand.c
@@ -0,0 +1,212 @@
+/*
+ * (C) Copyright 2006 Harald Welte <hwelte@hmw-consulting.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#if 0
+#define DEBUGN	printf
+#else
+#define DEBUGN(x, args ...) {}
+#endif
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+#if !defined(CFG_NAND_LEGACY)
+
+#include <nand.h>
+#include <s3c2410.h>
+
+#define __REGb(x)	(*(volatile unsigned char *)(x))
+#define __REGi(x)	(*(volatile unsigned int *)(x))
+
+#define	NF_BASE		0x4e000000
+#define	NFCONF		__REGi(NF_BASE + 0x0)
+#define	NFCMD		__REGb(NF_BASE + 0x4)
+#define	NFADDR		__REGb(NF_BASE + 0x8)
+#define	NFDATA		__REGb(NF_BASE + 0xc)
+#define	NFSTAT		__REGb(NF_BASE + 0x10)
+
+#define S3C2410_NFCONF_EN          (1<<15)
+#define S3C2410_NFCONF_512BYTE     (1<<14)
+#define S3C2410_NFCONF_4STEP       (1<<13)
+#define S3C2410_NFCONF_INITECC     (1<<12)
+#define S3C2410_NFCONF_nFCE        (1<<11)
+#define S3C2410_NFCONF_TACLS(x)    ((x)<<8)
+#define S3C2410_NFCONF_TWRPH0(x)   ((x)<<4)
+#define S3C2410_NFCONF_TWRPH1(x)   ((x)<<0)
+
+static u16 s3c2410_read_word(struct mtd_info *mtd)
+{
+	unsigned char byte = 0;
+
+	printf("s3c2410_read_word: WARNING, this function is not implemented yet\n");
+	return byte;	
+}
+
+static void s3c2410_write_word(struct mtd_info *mtd, u16 word)
+{
+	printf("s3c2410_write_word: WARNING, this function is not implemented yet\n");
+}
+
+static void s3c2410_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	DEBUGN("hwcontrol(): 0x%02x: ", cmd);
+
+	switch (cmd) {
+	case NAND_CTL_SETNCE:
+		NFCONF &= ~S3C2410_NFCONF_nFCE;
+		DEBUGN("NFCONF=0x%08x\n", NFCONF);
+		break;
+	case NAND_CTL_CLRNCE:
+		NFCONF |= S3C2410_NFCONF_nFCE;
+		DEBUGN("NFCONF=0x%08x\n", NFCONF);
+		break;
+	case NAND_CTL_SETALE:
+		chip->IO_ADDR_W = NF_BASE + 0x8;
+		DEBUGN("SETALE\n");
+		break;
+	case NAND_CTL_SETCLE:
+		chip->IO_ADDR_W = NF_BASE + 0x4;
+		DEBUGN("SETCLE\n");
+		break;
+	default:
+		chip->IO_ADDR_W = NF_BASE + 0xc;
+		break;
+	}
+	return;
+}
+
+static int s3c2410_dev_ready(struct mtd_info *mtd)
+{
+	DEBUGN("dev_ready\n");
+	return (NFSTAT & 0x01);
+}
+
+static void s3c2410_cmdfunc(struct mtd_info *mtd, unsigned cmd,
+			    int column, int page_addr)
+{
+	DEBUGN("cmdfunc(): 0x%02x, col=%d, page=%d\n", cmd, column, page_addr);
+
+	switch (cmd) {
+	case NAND_CMD_READ0:
+	case NAND_CMD_READ1:
+	case NAND_CMD_READOOB:
+		NFCMD = cmd;
+		NFADDR = column & 0xff;
+		NFADDR = page_addr & 0xff;
+		NFADDR = (page_addr >> 8) & 0xff;
+		NFADDR = (page_addr >> 16) & 0xff;
+		break;
+	case NAND_CMD_READID:
+		NFCMD = cmd;
+		NFADDR = 0;
+		break;
+	case NAND_CMD_PAGEPROG:
+		NFCMD = cmd;
+		printf("PAGEPROG not implemented\n");
+		break;
+	case NAND_CMD_ERASE1:
+		NFCMD = cmd;
+		NFADDR = page_addr & 0xff;
+		NFADDR = (page_addr >> 8) & 0xff;
+		NFADDR = (page_addr >> 16) & 0xff;
+		break;
+	case NAND_CMD_ERASE2:
+		NFCMD = cmd;
+		break;
+	case NAND_CMD_SEQIN:
+		printf("SEQIN not implemented\n");
+		break;
+	case NAND_CMD_STATUS:
+		NFCMD = cmd;
+		break;
+	case NAND_CMD_RESET:
+		NFCMD = cmd;
+		break;
+	default:
+		break;
+	}
+
+	while (!s3c2410_dev_ready(mtd));
+}
+
+void board_nand_init(struct nand_chip *nand)
+{
+	u_int32_t cfg;
+	u_int8_t tacls, twrph0, twrph1;
+	S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+
+	DEBUGN("board_nand_init()\n");
+
+	clk_power->CLKCON |= (1 << 4);
+
+	/* initialize hardware */
+	twrph0 = 3; twrph1 = 0; tacls = 0;
+
+	/* default timings: maximum */
+	//twrph0 = 8; twrph1 = 8; tacls = 8;
+
+	cfg = S3C2410_NFCONF_EN;
+	cfg |= S3C2410_NFCONF_TACLS(tacls - 1);
+	cfg |= S3C2410_NFCONF_TWRPH0(twrph0 - 1);
+	cfg |= S3C2410_NFCONF_TWRPH1(twrph1 - 1);
+
+	//NFCONF = cfg;
+	NFCONF = 0xf842;
+
+	/* initialize nand_chip data structure */
+	nand->IO_ADDR_R = nand->IO_ADDR_W = 0x4e00000c;
+
+	/* read_buf and write_buf are default */
+	/* read_byte and write_byte are default */
+
+	/* need to override word read/write since default routines try 16bit wide
+	 * register access of an (in our case) 8bit register */
+	nand->read_word = s3c2410_read_word;
+	nand->write_word = s3c2410_write_word;
+
+	/* hwcontrol always must be implemented */
+	nand->hwcontrol = s3c2410_hwcontrol;
+
+	nand->dev_ready = s3c2410_dev_ready;
+
+	nand->eccmode = NAND_ECC_SOFT;
+	nand->options = 0;
+	//nand->waitfunc = dfc_wait;
+
+	//nand->cmdfunc = s3c2410_cmdfunc;
+	//nand->autooob = &delta_oob;
+	//nand->badblock_pattern = &delta_bbt_descr;
+	
+#if 0
+	/* reset */
+	nand->hwcontrol(NULL, NAND_CTL_SETNCE);
+	nand->cmdfunc(NULL, NAND_CMD_RESET, -1, -1);
+	while (nand->dev_ready(NULL) == 0) {}
+	nand->hwcontrol(NULL, NAND_CTL_CLRNCE);
+#endif
+
+	DEBUGN("end of nand_init\n");
+}
+
+#else
+ #error "U-Boot legacy NAND support not available for S3C2410"
+#endif
+#endif
diff --git a/cpu/arm920t/s3c24x0/nand_read.c b/cpu/arm920t/s3c24x0/nand_read.c
new file mode 100644
index 0000000..9d97932
--- /dev/null
+++ b/cpu/arm920t/s3c24x0/nand_read.c
@@ -0,0 +1,75 @@
+/* 
+ * nand_read.c: Simple NAND read functions for booting from NAND
+ *
+ * Taken from GPLv2 licensed vivi bootloader,
+ * Copyright (C) 2002 MIZI Research, Inc.
+ *
+ * Author: Hwang, Chideok <hwang@mizi.com>
+ * Date  : $Date: 2004/02/04 10:37:37 $
+ *
+ * u-boot integration (C) 2006 by Harald Welte <hwelte@hmw-consulting.de>
+ */
+
+#include <common.h>
+
+#ifdef CONFIG_S3C2410_NAND_BOOT
+
+#define __REGb(x)	(*(volatile unsigned char *)(x))
+#define __REGi(x)	(*(volatile unsigned int *)(x))
+#define NF_BASE		0x4e000000
+#define NFCONF		__REGi(NF_BASE + 0x0)
+#define NFCMD		__REGb(NF_BASE + 0x4)
+#define NFADDR		__REGb(NF_BASE + 0x8)
+#define NFDATA		__REGb(NF_BASE + 0xc)
+#define NFSTAT		__REGb(NF_BASE + 0x10)
+
+#define BUSY 1
+inline void wait_idle(void) {
+    int i;
+
+    while(!(NFSTAT & BUSY))
+      for(i=0; i<10; i++);
+}
+
+#define NAND_SECTOR_SIZE	512
+#define NAND_BLOCK_MASK		(NAND_SECTOR_SIZE - 1)
+
+/* low level nand read function */
+int
+nand_read_ll(unsigned char *buf, unsigned long start_addr, int size)
+{
+    int i, j;
+
+    if ((start_addr & NAND_BLOCK_MASK) || (size & NAND_BLOCK_MASK)) {
+        return -1;	/* invalid alignment */
+    }
+
+    /* chip Enable */
+    NFCONF &= ~0x800;
+    for(i=0; i<10; i++);
+
+    for(i=start_addr; i < (start_addr + size);) {
+      /* READ0 */
+      NFCMD = 0;
+
+      /* Write Address */
+      NFADDR = i & 0xff;
+      NFADDR = (i >> 9) & 0xff;
+      NFADDR = (i >> 17) & 0xff;
+      NFADDR = (i >> 25) & 0xff;
+
+      wait_idle();
+
+      for(j=0; j < NAND_SECTOR_SIZE; j++, i++) {
+	*buf = (NFDATA & 0xff);
+	buf++;
+      }
+    }
+
+    /* chip Disable */
+    NFCONF |= 0x800;	/* chip disable */
+
+    return 0;
+}
+
+#endif /* CONFIG_S3C2410_NAND_BOOT */
diff --git a/cpu/arm920t/start.S b/cpu/arm920t/start.S
index 346f0d0..232e2c2 100644
--- a/cpu/arm920t/start.S
+++ b/cpu/arm920t/start.S
@@ -5,6 +5,10 @@
  *  Copyright (c) 2002	Alex Züpke <azu@sysgo.de>
  *  Copyright (c) 2002	Gary Jennejohn <gj@denx.de>
  *
+ * S3C2410 NAND portions
+ *  Copyright (c) 2001  MIZI Research, Inc.
+ *  Copyright (c) 2006  Harald Welte <hwelte@hmw-consulting.de>
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -27,6 +31,7 @@
 
 #include <config.h>
 #include <version.h>
+#include <s3c2410.h>
 
 
 /*
@@ -161,6 +166,7 @@ #ifndef CONFIG_SKIP_LOWLEVEL_INIT
 #endif
 
 #ifndef CONFIG_SKIP_RELOCATE_UBOOT
+#ifndef CONFIG_S3C2410_NAND_BOOT
 relocate:				/* relocate U-Boot to RAM	    */
 	adr	r0, _start		/* r0 <- current position of code   */
 	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
@@ -177,6 +183,93 @@ copy_loop:
 	stmia	r1!, {r3-r10}		/* copy to   target address [r1]    */
 	cmp	r0, r2			/* until source end addreee [r2]    */
 	ble	copy_loop
+#else /* NAND_BOOT */
+relocate:
+copy_myself:
+	/* mov	r10, lr */
+
+	@ reset NAND
+	mov	r1, #S3C2410_NAND_BASE
+	ldr	r2, =0xf842		@ initial value enable tacls=3,rph0=6,rph1=0
+	str	r2, [r1, #oNFCONF]
+	ldr	r2, [r1, #oNFCONF]
+	bic	r2, r2, #0x800		@ enable chip
+	str	r2, [r1, #oNFCONF]
+	mov	r2, #0xff		@ RESET command
+	strb	r2, [r1, #oNFCMD]
+	mov	r3, #0			@ wait 
+1:	add	r3, r3, #0x1
+	cmp	r3, #0xa
+	blt	1b
+2:	ldr	r2, [r1, #oNFSTAT]	@ wait ready
+	tst	r2, #0x1
+	beq	2b
+	ldr	r2, [r1, #oNFCONF]
+	orr	r2, r2, #0x800		@ disable chip
+	str	r2, [r1, #oNFCONF]
+
+#if 0
+	@ get ready to call C functions (for nand_read())
+	ldr	sp, DW_STACK_START	@ setup stack pointer
+	mov	fp, #0			@ no previous frame, so fp=0
+#else
+	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
+	sub	r0, r0, #CFG_MALLOC_LEN	/* malloc area                      */
+	sub	r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */
+#ifdef CONFIG_USE_IRQ
+	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
+#endif
+	sub	sp, r0, #12		/* leave 3 words for abort-stack    */
+#endif
+
+	@ copy u-boot to RAM
+	ldr	r0, _TEXT_BASE
+	mov     r1, #0x0
+	mov	r2, #0x30000
+	bl	nand_read_ll
+
+	tst	r0, #0x0
+	beq	ok_nand_read
+#ifdef CONFIG_DEBUG_LL
+bad_nand_read: 
+	ldr	r0, STR_FAIL
+	ldr	r1, SerBase
+	bl	PrintWord
+1:	b	1b		@ infinite loop 
+#endif
+	
+ok_nand_read:
+#ifdef CONFIG_DEBUG_LL
+	ldr	r0, STR_OK
+	ldr	r1, SerBase
+	bl	PrintWord
+#endif
+
+	@ verify
+	mov	r0, #0
+	@ldr	r1, =0x33f00000
+	ldr	r1, _TEXT_BASE
+	mov	r2, #0x400	@ 4 bytes * 1024 = 4K-bytes
+go_next:
+	ldr	r3, [r0], #4
+	ldr	r4, [r1], #4
+	teq	r3, r4
+	bne	notmatch
+	subs	r2, r2, #4
+	beq	done_nand_read	
+	bne	go_next
+notmatch:
+#ifdef CONFIG_DEBUG_LL
+	sub	r0, r0, #4
+	ldr	r1, SerBase
+	bl	PrintHexWord
+	ldr	r0, STR_FAIL
+	ldr	r1, SerBase
+	bl	PrintWord
+#endif
+1:	b	1b
+done_nand_read:
+#endif /* NAND_BOOT */
 #endif	/* CONFIG_SKIP_RELOCATE_UBOOT */
 
 	/* Set up the stack						    */
diff --git a/drivers/Makefile b/drivers/Makefile
index 9be95c7..eef266a 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -50,7 +50,7 @@ OBJS	= 3c589.o 5701rls.o ali512x.o \
 	  videomodes.o w83c553f.o \
 	  ks8695eth.o \
 	  pxa_pcmcia.o mpc8xx_pcmcia.o tqm8xx_pcmcia.o	\
-	  rpx_pcmcia.o
+	  rpx_pcmcia.o s3c2410_fb.o
 
 all:	$(LIB)
 
diff --git a/drivers/cs8900.c b/drivers/cs8900.c
index 082434c..1cce622 100644
--- a/drivers/cs8900.c
+++ b/drivers/cs8900.c
@@ -120,6 +120,7 @@ void cs8900_get_enetaddr (uchar * addr)
 	unsigned char env_enetaddr[6];
 	char *tmp = getenv ("ethaddr");
 	char *end;
+	unsigned short chip_id;
 
 	for (i=0; i<6; i++) {
 		env_enetaddr[i] = tmp ? simple_strtoul(tmp, &end, 16) : 0;
@@ -128,7 +129,9 @@ void cs8900_get_enetaddr (uchar * addr)
 	}
 
 	/* verify chip id */
-	if (get_reg_init_bus (PP_ChipID) != 0x630e)
+	chip_id = get_reg_init_bus (PP_ChipID);
+	printf("\ncs8900a chipid 0x%04x\n", chip_id);
+	if (chip_id != 0x630e)
 		return;
 	eth_reset ();
 	if ((get_reg (PP_SelfST) & (PP_SelfSTAT_EEPROM | PP_SelfSTAT_EEPROM_OK)) ==
diff --git a/drivers/s3c2410_fb.c b/drivers/s3c2410_fb.c
new file mode 100644
index 0000000..fc389a9
--- /dev/null
+++ b/drivers/s3c2410_fb.c
@@ -0,0 +1,182 @@
+/*
+ * (C) Copyright 2006 Harald Welte <hwelte@hmw-consulting.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#if defined(CONFIG_VIDEO_S3C2410)
+
+#include <video_fb.h>
+#include "videomodes.h"
+#include <s3c2410.h>
+/*
+ * Export Graphic Device
+ */
+GraphicDevice smi;
+
+#define VIDEO_MEM_SIZE	0x200000
+
+/*******************************************************************************
+ *
+ * Init video chip with common Linux graphic modes (lilo)
+ */
+void *video_hw_init (void)
+{
+	S3C24X0_LCD * const lcd = S3C24X0_GetBase_LCD();
+	GraphicDevice *pGD = (GraphicDevice *)&smi;
+	int videomode;
+	unsigned long t1, hsynch, vsynch;
+	char *penv;
+	int tmp, i, bits_per_pixel;
+	struct ctfb_res_modes *res_mode;
+	struct ctfb_res_modes var_mode;
+	unsigned char videoout;
+	unsigned int *vm;
+
+	/* Search for video chip */
+	printf("Video: ");
+
+	tmp = 0;
+
+	videomode = CFG_DEFAULT_VIDEO_MODE;
+	/* get video mode via environment */
+	if ((penv = getenv ("videomode")) != NULL) {
+		/* deceide if it is a string */
+		if (penv[0] <= '9') {
+			videomode = (int) simple_strtoul (penv, NULL, 16);
+			tmp = 1;
+		}
+	} else {
+		tmp = 1;
+	}
+	if (tmp) {
+		/* parameter are vesa modes */
+		/* search params */
+		for (i = 0; i < VESA_MODES_COUNT; i++) {
+			if (vesa_modes[i].vesanr == videomode)
+				break;
+		}
+		if (i == VESA_MODES_COUNT) {
+			printf ("no VESA Mode found, switching to mode 0x%x ", CFG_DEFAULT_VIDEO_MODE);
+			i = 0;
+		}
+		res_mode =
+			(struct ctfb_res_modes *) &res_mode_init[vesa_modes[i].
+								 resindex];
+		bits_per_pixel = vesa_modes[i].bits_per_pixel;
+	} else {
+
+		res_mode = (struct ctfb_res_modes *) &var_mode;
+		bits_per_pixel = video_get_params (res_mode, penv);
+	}
+
+	/* calculate hsynch and vsynch freq (info only) */
+	t1 = (res_mode->left_margin + res_mode->xres +
+	      res_mode->right_margin + res_mode->hsync_len) / 8;
+	t1 *= 8;
+	t1 *= res_mode->pixclock;
+	t1 /= 1000;
+	hsynch = 1000000000L / t1;
+	t1 *=
+		(res_mode->upper_margin + res_mode->yres +
+		 res_mode->lower_margin + res_mode->vsync_len);
+	t1 /= 1000;
+	vsynch = 1000000000L / t1;
+
+	/* fill in Graphic device struct */
+	sprintf (pGD->modeIdent, "%dx%dx%d %ldkHz %ldHz", res_mode->xres,
+		 res_mode->yres, bits_per_pixel, (hsynch / 1000),
+		 (vsynch / 1000));
+	printf ("%s\n", pGD->modeIdent);
+	pGD->winSizeX = res_mode->xres;
+	pGD->winSizeY = res_mode->yres;
+	pGD->plnSizeX = res_mode->xres;
+	pGD->plnSizeY = res_mode->yres;
+	switch (bits_per_pixel) {
+	case 8:
+		pGD->gdfBytesPP = 1;
+		pGD->gdfIndex = GDF__8BIT_INDEX;
+		break;
+	case 15:
+		pGD->gdfBytesPP = 2;
+		pGD->gdfIndex = GDF_15BIT_555RGB;
+		break;
+	case 16:
+		pGD->gdfBytesPP = 2;
+		pGD->gdfIndex = GDF_16BIT_565RGB;
+		break;
+	case 24:
+		pGD->gdfBytesPP = 3;
+		pGD->gdfIndex = GDF_24BIT_888RGB;
+		break;
+	}
+
+#if 0
+	pGD->isaBase = CFG_ISA_IO;
+	pGD->pciBase = pci_mem_base;
+	pGD->dprBase = (pci_mem_base + 0x400000 + 0x8000);
+	pGD->vprBase = (pci_mem_base + 0x400000 + 0xc000);
+	pGD->cprBase = (pci_mem_base + 0x400000 + 0xe000);
+#endif
+	pGD->frameAdrs = LCD_VIDEO_ADDR;
+	pGD->memSize = VIDEO_MEM_SIZE;
+
+	lcd->LCDSADDR1 = LCD_VIDEO_ADDR >> 1;
+	lcd->LCDSADDR2 = (LCD_VIDEO_ADDR + 0x4b000) >> 1;
+	lcd->LCDSADDR3 = 0x000000f0;
+
+	lcd->LCDCON1 = 0x00000479;
+	lcd->LCDCON2 = 0x014fc183;
+	lcd->LCDCON3 = 0x0060ef07;
+	lcd->LCDCON4 = 0x00000003;
+	lcd->LCDCON5 = 0x00000b09;
+	lcd->LPCSEL  = 0x00000cf0;
+
+	pGD->winSizeX = pGD->plnSizeX = 240;
+	pGD->winSizeY = pGD->plnSizeY = 320;
+	pGD->gdfBytesPP = 2;
+	pGD->gdfIndex = GDF_16BIT_565RGB;
+
+	/* Enable  Display  */
+	videoout = 2;	    /* Default output is CRT */
+	if ((penv = getenv ("videoout")) != NULL) {
+		/* deceide if it is a string */
+		videoout = (int) simple_strtoul (penv, NULL, 16);
+	}
+
+	printf("clearing video memory\n");
+	/* Clear video memory */
+	i = pGD->memSize/4;
+	vm = (unsigned int *)pGD->frameAdrs;
+	while(i--)
+		*vm++ = 0;
+
+	printf("returning from video_hw_init\n");
+	return ((void*)&smi);
+}
+
+void
+video_set_lut (unsigned int index,	/* color number */
+	       unsigned char r,	/* red */
+	       unsigned char g,	/* green */
+	       unsigned char b	/* blue */
+    )
+{
+}
+
+#endif /* CONFIG_VIDEO_S3C2410 */
diff --git a/drivers/usbdcore_s3c2410.c b/drivers/usbdcore_s3c2410.c
new file mode 100644
index 0000000..143fdf2
--- /dev/null
+++ b/drivers/usbdcore_s3c2410.c
@@ -0,0 +1,1609 @@
+/*
+ * (C) Copyright 2003
+ * Gerry Hamel, geh@ti.com, Texas Instruments
+ *
+ * Based on
+ * linux/drivers/usb/device/bi/omap.c
+ * TI OMAP1510 USB bus interface driver
+ *
+ * Author: MontaVista Software, Inc.
+ *	   source@mvista.com
+ *	   (C) Copyright 2002
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
+ *
+ */
+
+#include <common.h>
+
+#if defined(CONFIG_S3C2410) && defined(CONFIG_USB_DEVICE)
+
+#include <asm/io.h>
+
+#include "usbdcore.h"
+#include "usbdcore_s3c2410.h"
+#include "usbdcore_ep0.h"
+
+
+#define UDC_INIT_MDELAY		     80 /* Device settle delay */
+#define UDC_MAX_ENDPOINTS	     31 /* Number of endpoints on this UDC */
+
+/* Some kind of debugging output... */
+#if 1
+#define UDCDBG(str)
+#define UDCDBGA(fmt,args...)
+#else  /* The bugs still exists... */
+#define UDCDBG(str) serial_printf("[%s] %s:%d: " str "\n", __FILE__,__FUNCTION__,__LINE__)
+#define UDCDBGA(fmt,args...) serial_printf("[%s] %s:%d: " fmt "\n", __FILE__,__FUNCTION__,__LINE__, ##args)
+#endif
+
+#if 1
+#define UDCREG(name)
+#define UDCREGL(name)
+#else  /* The bugs still exists... */
+#define UDCREG(name)	 serial_printf("%s():%d: %s[%08x]=%.4x\n",__FUNCTION__,__LINE__, (#name), name, inw(name))	/* For 16-bit regs */
+#define UDCREGL(name)	 serial_printf("%s():%d: %s[%08x]=%.8x\n",__FUNCTION__,__LINE__, (#name), name, inl(name))	/* For 32-bit regs */
+#endif
+
+
+static struct urb *ep0_urb = NULL;
+
+static struct usb_device_instance *udc_device;	/* Used in interrupt handler */
+static u16 udc_devstat = 0;	/* UDC status (DEVSTAT) */
+static u32 udc_interrupts = 0;
+
+static void udc_stall_ep (unsigned int ep_addr);
+
+
+static struct usb_endpoint_instance *s3c2410_find_ep (int ep)
+{
+	int i;
+
+	for (i = 0; i < udc_device->bus->max_endpoints; i++) {
+		if (udc_device->bus->endpoint_array[i].endpoint_address == ep)
+			return &udc_device->bus->endpoint_array[i];
+	}
+	return NULL;
+}
+
+/* ************************************************************************** */
+/* IO
+ */
+
+/*
+ * omap1510_prepare_endpoint_for_rx
+ *
+ * This function implements TRM Figure 14-11.
+ *
+ * The endpoint to prepare for transfer is specified as a physical endpoint
+ * number.  For OUT (rx) endpoints 1 through 15, the corresponding endpoint
+ * configuration register is checked to see if the endpoint is ISO or not.
+ * If the OUT endpoint is valid and is non-ISO then its FIFO is enabled.
+ * No action is taken for endpoint 0 or for IN (tx) endpoints 16 through 30.
+ */
+static void omap1510_prepare_endpoint_for_rx (int ep_addr)
+{
+	int ep_num = ep_addr & USB_ENDPOINT_NUMBER_MASK;
+
+	UDCDBGA ("omap1510_prepare_endpoint %x", ep_addr);
+	if (((ep_addr & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT)) {
+		if ((inw (UDC_EP_RX (ep_num)) &
+		     (UDC_EPn_RX_Valid | UDC_EPn_RX_Iso)) ==
+		    UDC_EPn_RX_Valid) {
+			/* rx endpoint is valid, non-ISO, so enable its FIFO */
+			outw (UDC_EP_Sel | ep_num, UDC_EP_NUM);
+			outw (UDC_Set_FIFO_En, UDC_CTRL);
+			outw (0, UDC_EP_NUM);
+		}
+	}
+}
+
+/* omap1510_configure_endpoints
+ *
+ * This function implements TRM Figure 14-10.
+ */
+static void omap1510_configure_endpoints (struct usb_device_instance *device)
+{
+	int ep;
+	struct usb_bus_instance *bus;
+	struct usb_endpoint_instance *endpoint;
+	unsigned short ep_ptr;
+	unsigned short ep_size;
+	unsigned short ep_isoc;
+	unsigned short ep_doublebuffer;
+	int ep_addr;
+	int packet_size;
+	int buffer_size;
+	int attributes;
+
+	bus = device->bus;
+
+	/* There is a dedicated 2048 byte buffer for USB packets that may be
+	 * arbitrarily partitioned among the endpoints on 8-byte boundaries.
+	 * The first 8 bytes are reserved for receiving setup packets on
+	 * endpoint 0.
+	 */
+	ep_ptr = 8;		/* reserve the first 8 bytes for the setup fifo */
+
+	for (ep = 0; ep < bus->max_endpoints; ep++) {
+		endpoint = bus->endpoint_array + ep;
+		ep_addr = endpoint->endpoint_address;
+		if ((ep_addr & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN) {
+			/* IN endpoint */
+			packet_size = endpoint->tx_packetSize;
+			attributes = endpoint->tx_attributes;
+		} else {
+			/* OUT endpoint */
+			packet_size = endpoint->rcv_packetSize;
+			attributes = endpoint->rcv_attributes;
+		}
+
+		switch (packet_size) {
+		case 0:
+			ep_size = 0;
+			break;
+		case 8:
+			ep_size = 0;
+			break;
+		case 16:
+			ep_size = 1;
+			break;
+		case 32:
+			ep_size = 2;
+			break;
+		case 64:
+			ep_size = 3;
+			break;
+		case 128:
+			ep_size = 4;
+			break;
+		case 256:
+			ep_size = 5;
+			break;
+		case 512:
+			ep_size = 6;
+			break;
+		default:
+			UDCDBGA ("ep 0x%02x has bad packet size %d",
+				 ep_addr, packet_size);
+			packet_size = 0;
+			ep_size = 0;
+			break;
+		}
+
+		switch (attributes & USB_ENDPOINT_XFERTYPE_MASK) {
+		case USB_ENDPOINT_XFER_CONTROL:
+		case USB_ENDPOINT_XFER_BULK:
+		case USB_ENDPOINT_XFER_INT:
+		default:
+			/* A non-isochronous endpoint may optionally be
+			 * double-buffered. For now we disable
+			 * double-buffering.
+			 */
+			ep_doublebuffer = 0;
+			ep_isoc = 0;
+			if (packet_size > 64)
+				packet_size = 0;
+			if (!ep || !ep_doublebuffer)
+				buffer_size = packet_size;
+			else
+				buffer_size = packet_size * 2;
+			break;
+		case USB_ENDPOINT_XFER_ISOC:
+			/* Isochronous endpoints are always double-
+			 * buffered, but the double-buffering bit
+			 * in the endpoint configuration register
+			 * becomes the msb of the endpoint size so we
+			 * set the double-buffering flag to zero.
+			 */
+			ep_doublebuffer = 0;
+			ep_isoc = 1;
+			buffer_size = packet_size * 2;
+			break;
+		}
+
+		/* check to see if our packet buffer RAM is exhausted */
+		if ((ep_ptr + buffer_size) > 2048) {
+			UDCDBGA ("out of packet RAM for ep 0x%02x buf size %d", ep_addr, buffer_size);
+			buffer_size = packet_size = 0;
+		}
+
+		/* force a default configuration for endpoint 0 since it is
+		 * always enabled
+		 */
+		if (!ep && ((packet_size < 8) || (packet_size > 64))) {
+			buffer_size = packet_size = 64;
+			ep_size = 3;
+		}
+
+		if (!ep) {
+			/* configure endpoint 0 */
+			outw ((ep_size << 12) | (ep_ptr >> 3), UDC_EP0);
+			/*UDCDBGA("ep 0 buffer offset 0x%03x packet size 0x%03x", */
+			/*	ep_ptr, packet_size); */
+		} else if ((ep_addr & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN) {
+			/* IN endpoint */
+			if (packet_size) {
+				outw ((1 << 15) | (ep_doublebuffer << 14) |
+				      (ep_size << 12) | (ep_isoc << 11) |
+				      (ep_ptr >> 3),
+				      UDC_EP_TX (ep_addr &
+						 USB_ENDPOINT_NUMBER_MASK));
+				UDCDBGA ("IN ep %d buffer offset 0x%03x"
+					 " packet size 0x%03x",
+					 ep_addr & USB_ENDPOINT_NUMBER_MASK,
+					 ep_ptr, packet_size);
+			} else {
+				outw (0,
+				      UDC_EP_TX (ep_addr &
+						 USB_ENDPOINT_NUMBER_MASK));
+			}
+		} else {
+			/* OUT endpoint */
+			if (packet_size) {
+				outw ((1 << 15) | (ep_doublebuffer << 14) |
+				      (ep_size << 12) | (ep_isoc << 11) |
+				      (ep_ptr >> 3),
+				      UDC_EP_RX (ep_addr &
+						 USB_ENDPOINT_NUMBER_MASK));
+				UDCDBGA ("OUT ep %d buffer offset 0x%03x"
+					 " packet size 0x%03x",
+					 ep_addr & USB_ENDPOINT_NUMBER_MASK,
+					 ep_ptr, packet_size);
+			} else {
+				outw (0,
+				      UDC_EP_RX (ep_addr &
+						 USB_ENDPOINT_NUMBER_MASK));
+			}
+		}
+		ep_ptr += buffer_size;
+	}
+}
+
+static void s3c2410_deconfigure_device (void)
+{
+	int epnum;
+
+	UDCDBG ("clear Cfg_Lock");
+	outw (inw (UDC_SYSCON1) & ~UDC_Cfg_Lock, UDC_SYSCON1);
+	UDCREG (UDC_SYSCON1);
+
+	/* deconfigure all endpoints */
+	for (epnum = 1; epnum <= 15; epnum++) {
+		outw (0, UDC_EP_RX (epnum));
+		outw (0, UDC_EP_TX (epnum));
+	}
+}
+
+static void s3c2410_configure_device (struct usb_device_instance *device)
+{
+	u_int32_t tmp;
+
+	s3c2410_configure_endpoints(device);
+
+	/* disable EP0-4 SUBD interrupts ? */
+	outw(0x00, S3C2410_UDC_USB_INT_EN_REG);
+
+	/* UPLL already configured by board-level init code */
+
+	/* configure USB pads to device mode */
+	tmp = inw(S3C2410_MISCCR);
+	tmp &= ~(S3C2410_MISCCR_USBHOST|S3C2410_MISCCR_USBSUSPND1);
+	outw(tmp, S3C2410_MISCCR);
+
+	tmp = inb(S3C2410_CLKSLOW);
+	tmp &= ~S3C2410_CLKSLOW_USB_CLK_DISABLE;
+	outw(tmp, S3C2410_CLKSLOW);
+
+	/* clear interrupt registers */
+	inb(S3C2410_UDC_EP_INT_REG);
+	inb(S3C2410_UDC_USB_INT_REG);
+
+	/* enable USB interrupts for RESET and SUSPEND/RESUME */
+	outb(S3C2410_UDC_USBINT_RESET|S3C2410_UDC_USBINT_SUSPEND,
+	     S3C2410_UDC_USB_INT_EN_REG);
+
+}
+
+/* omap1510_write_noniso_tx_fifo
+ *
+ * This function implements TRM Figure 14-30.
+ *
+ * If the endpoint has an active tx_urb, then the next packet of data from the
+ * URB is written to the tx FIFO.  The total amount of data in the urb is given
+ * by urb->actual_length.  The maximum amount of data that can be sent in any
+ * one packet is given by endpoint->tx_packetSize.  The number of data bytes
+ * from this URB that have already been transmitted is given by endpoint->sent.
+ * endpoint->last is updated by this routine with the number of data bytes
+ * transmitted in this packet.
+ *
+ * In accordance with Figure 14-30, the EP_NUM register must already have been
+ * written with the value to select the appropriate tx FIFO before this routine
+ * is called.
+ */
+static void omap1510_write_noniso_tx_fifo (struct usb_endpoint_instance
+					   *endpoint)
+{
+	struct urb *urb = endpoint->tx_urb;
+
+	if (urb) {
+		unsigned int last, i;
+
+		UDCDBGA ("urb->buffer %p, buffer_length %d, actual_length %d",
+			 urb->buffer, urb->buffer_length, urb->actual_length);
+		if ((last =
+		     MIN (urb->actual_length - endpoint->sent,
+			  endpoint->tx_packetSize))) {
+			u8 *cp = urb->buffer + endpoint->sent;
+
+			UDCDBGA ("endpoint->sent %d, tx_packetSize %d, last %d", endpoint->sent, endpoint->tx_packetSize, last);
+
+			if (((u32) cp & 1) == 0) {	/* word aligned? */
+				outsw (UDC_DATA, cp, last >> 1);
+			} else {	/* byte aligned. */
+				for (i = 0; i < (last >> 1); i++) {
+					u16 w = ((u16) cp[2 * i + 1] << 8) |
+						(u16) cp[2 * i];
+					outw (w, UDC_DATA);
+				}
+			}
+			if (last & 1) {
+				outb (*(cp + last - 1), UDC_DATA);
+			}
+		}
+		endpoint->last = last;
+	}
+}
+
+/* omap1510_read_noniso_rx_fifo
+ *
+ * This function implements TRM Figure 14-28.
+ *
+ * If the endpoint has an active rcv_urb, then the next packet of data is read
+ * from the rcv FIFO and written to rcv_urb->buffer at offset
+ * rcv_urb->actual_length to append the packet data to the data from any
+ * previous packets for this transfer.	We assume that there is sufficient room
+ * left in the buffer to hold an entire packet of data.
+ *
+ * The return value is the number of bytes read from the FIFO for this packet.
+ *
+ * In accordance with Figure 14-28, the EP_NUM register must already have been
+ * written with the value to select the appropriate rcv FIFO before this routine
+ * is called.
+ */
+static int omap1510_read_noniso_rx_fifo (struct usb_endpoint_instance
+					 *endpoint)
+{
+	struct urb *urb = endpoint->rcv_urb;
+	int len = 0;
+
+	if (urb) {
+		len = inw (UDC_RXFSTAT);
+
+		if (len) {
+			unsigned char *cp = urb->buffer + urb->actual_length;
+
+			insw (UDC_DATA, cp, len >> 1);
+			if (len & 1)
+				*(cp + len - 1) = inb (UDC_DATA);
+		}
+	}
+	return len;
+}
+
+/* omap1510_prepare_for_control_write_status
+ *
+ * This function implements TRM Figure 14-17.
+ *
+ * We have to deal here with non-autodecoded control writes that haven't already
+ * been dealt with by ep0_recv_setup.  The non-autodecoded standard control
+ * write requests are:	set/clear endpoint feature, set configuration, set
+ * interface, and set descriptor.  ep0_recv_setup handles set/clear requests for
+ * ENDPOINT_HALT by halting the endpoint for a set request and resetting the
+ * endpoint for a clear request.  ep0_recv_setup returns an error for
+ * SET_DESCRIPTOR requests which causes them to be terminated with a stall by
+ * the setup handler.  A SET_INTERFACE request is handled by ep0_recv_setup by
+ * generating a DEVICE_SET_INTERFACE event.  This leaves only the
+ * SET_CONFIGURATION event for us to deal with here.
+ *
+ */
+static void omap1510_prepare_for_control_write_status (struct urb *urb)
+{
+	struct usb_device_request *request = &urb->device_request;;
+
+	/* check for a SET_CONFIGURATION request */
+	if (request->bRequest == USB_REQ_SET_CONFIGURATION) {
+		int configuration = le16_to_cpu (request->wValue) & 0xff;
+		unsigned short devstat = inw (UDC_DEVSTAT);
+
+		if ((devstat & (UDC_ADD | UDC_CFG)) == UDC_ADD) {
+			/* device is currently in ADDRESSED state */
+			if (configuration) {
+				/* Assume the specified non-zero configuration
+				 * value is valid and switch to the CONFIGURED
+				 * state.
+				 */
+				outw (UDC_Dev_Cfg, UDC_SYSCON2);
+			}
+		} else if ((devstat & UDC_CFG) == UDC_CFG) {
+			/* device is currently in CONFIGURED state */
+			if (!configuration) {
+				/* Switch to ADDRESSED state. */
+				outw (UDC_Clr_Cfg, UDC_SYSCON2);
+			}
+		}
+	}
+
+	/* select EP0 tx FIFO */
+	outw (UDC_EP_Dir | UDC_EP_Sel, UDC_EP_NUM);
+	/* clear endpoint (no data bytes in status stage) */
+	outw (UDC_Clr_EP, UDC_CTRL);
+	/* enable the EP0 tx FIFO */
+	outw (UDC_Set_FIFO_En, UDC_CTRL);
+	/* deselect the endpoint */
+	outw (UDC_EP_Dir, UDC_EP_NUM);
+}
+
+/* udc_state_transition_up
+ * udc_state_transition_down
+ *
+ * Helper functions to implement device state changes.	The device states and
+ * the events that transition between them are:
+ *
+ *				STATE_ATTACHED
+ *				||	/\
+ *				\/	||
+ *	DEVICE_HUB_CONFIGURED			DEVICE_HUB_RESET
+ *				||	/\
+ *				\/	||
+ *				STATE_POWERED
+ *				||	/\
+ *				\/	||
+ *	DEVICE_RESET				DEVICE_POWER_INTERRUPTION
+ *				||	/\
+ *				\/	||
+ *				STATE_DEFAULT
+ *				||	/\
+ *				\/	||
+ *	DEVICE_ADDRESS_ASSIGNED			DEVICE_RESET
+ *				||	/\
+ *				\/	||
+ *				STATE_ADDRESSED
+ *				||	/\
+ *				\/	||
+ *	DEVICE_CONFIGURED			DEVICE_DE_CONFIGURED
+ *				||	/\
+ *				\/	||
+ *				STATE_CONFIGURED
+ *
+ * udc_state_transition_up transitions up (in the direction from STATE_ATTACHED
+ * to STATE_CONFIGURED) from the specified initial state to the specified final
+ * state, passing through each intermediate state on the way.  If the initial
+ * state is at or above (i.e. nearer to STATE_CONFIGURED) the final state, then
+ * no state transitions will take place.
+ *
+ * udc_state_transition_down transitions down (in the direction from
+ * STATE_CONFIGURED to STATE_ATTACHED) from the specified initial state to the
+ * specified final state, passing through each intermediate state on the way.
+ * If the initial state is at or below (i.e. nearer to STATE_ATTACHED) the final
+ * state, then no state transitions will take place.
+ *
+ * These functions must only be called with interrupts disabled.
+ */
+static void udc_state_transition_up (usb_device_state_t initial,
+				     usb_device_state_t final)
+{
+	if (initial < final) {
+		switch (initial) {
+		case STATE_ATTACHED:
+			usbd_device_event_irq (udc_device,
+					       DEVICE_HUB_CONFIGURED, 0);
+			if (final == STATE_POWERED)
+				break;
+		case STATE_POWERED:
+			usbd_device_event_irq (udc_device, DEVICE_RESET, 0);
+			if (final == STATE_DEFAULT)
+				break;
+		case STATE_DEFAULT:
+			usbd_device_event_irq (udc_device,
+					       DEVICE_ADDRESS_ASSIGNED, 0);
+			if (final == STATE_ADDRESSED)
+				break;
+		case STATE_ADDRESSED:
+			usbd_device_event_irq (udc_device, DEVICE_CONFIGURED,
+					       0);
+		case STATE_CONFIGURED:
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+static void udc_state_transition_down (usb_device_state_t initial,
+				       usb_device_state_t final)
+{
+	if (initial > final) {
+		switch (initial) {
+		case STATE_CONFIGURED:
+			usbd_device_event_irq (udc_device, DEVICE_DE_CONFIGURED, 0);
+			if (final == STATE_ADDRESSED)
+				break;
+		case STATE_ADDRESSED:
+			usbd_device_event_irq (udc_device, DEVICE_RESET, 0);
+			if (final == STATE_DEFAULT)
+				break;
+		case STATE_DEFAULT:
+			usbd_device_event_irq (udc_device, DEVICE_POWER_INTERRUPTION, 0);
+			if (final == STATE_POWERED)
+				break;
+		case STATE_POWERED:
+			usbd_device_event_irq (udc_device, DEVICE_HUB_RESET, 0);
+		case STATE_ATTACHED:
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+/* Handle all device state changes.
+ * This function implements TRM Figure 14-21.
+ */
+static void omap1510_udc_state_changed (void)
+{
+	u16 bits;
+	u16 devstat = inw (UDC_DEVSTAT);
+
+	UDCDBGA ("state changed, devstat %x, old %x", devstat, udc_devstat);
+
+	bits = devstat ^ udc_devstat;
+	if (bits) {
+		if (bits & UDC_ATT) {
+			if (devstat & UDC_ATT) {
+				UDCDBG ("device attached and powered");
+				udc_state_transition_up (udc_device->device_state, STATE_POWERED);
+			} else {
+				UDCDBG ("device detached or unpowered");
+				udc_state_transition_down (udc_device->device_state, STATE_ATTACHED);
+			}
+		}
+		if (bits & UDC_USB_Reset) {
+			if (devstat & UDC_USB_Reset) {
+				UDCDBG ("device reset in progess");
+				udc_state_transition_down (udc_device->device_state, STATE_POWERED);
+			} else {
+				UDCDBG ("device reset completed");
+			}
+		}
+		if (bits & UDC_DEF) {
+			if (devstat & UDC_DEF) {
+				UDCDBG ("device entering default state");
+				udc_state_transition_up (udc_device->device_state, STATE_DEFAULT);
+			} else {
+				UDCDBG ("device leaving default state");
+				udc_state_transition_down (udc_device->device_state, STATE_POWERED);
+			}
+		}
+		if (bits & UDC_SUS) {
+			if (devstat & UDC_SUS) {
+				UDCDBG ("entering suspended state");
+				usbd_device_event_irq (udc_device, DEVICE_BUS_INACTIVE, 0);
+			} else {
+				UDCDBG ("leaving suspended state");
+				usbd_device_event_irq (udc_device, DEVICE_BUS_ACTIVITY, 0);
+			}
+		}
+		if (bits & UDC_R_WK_OK) {
+			UDCDBGA ("remote wakeup %s", (devstat & UDC_R_WK_OK)
+				 ? "enabled" : "disabled");
+		}
+		if (bits & UDC_ADD) {
+			if (devstat & UDC_ADD) {
+				UDCDBG ("default -> addressed");
+				udc_state_transition_up (udc_device->device_state, STATE_ADDRESSED);
+			} else {
+				UDCDBG ("addressed -> default");
+				udc_state_transition_down (udc_device->device_state, STATE_DEFAULT);
+			}
+		}
+		if (bits & UDC_CFG) {
+			if (devstat & UDC_CFG) {
+				UDCDBG ("device configured");
+				/* The ep0_recv_setup function generates the
+				 * DEVICE_CONFIGURED event when a
+				 * USB_REQ_SET_CONFIGURATION setup packet is
+				 * received, so we should already be in the
+				 * state STATE_CONFIGURED.
+				 */
+				udc_state_transition_up (udc_device->device_state, STATE_CONFIGURED);
+			} else {
+				UDCDBG ("device deconfigured");
+				udc_state_transition_down (udc_device->device_state, STATE_ADDRESSED);
+			}
+		}
+	}
+
+	/* Clear interrupt source */
+	outw (UDC_DS_Chg, UDC_IRQ_SRC);
+
+	/* Save current DEVSTAT */
+	udc_devstat = devstat;
+}
+
+static void s3c2410_udc_ep0(void)
+{
+	u_int8_t ep0csr;
+
+	UDCDBG("-> Entering EP0 handler");
+
+	S3C2410_UDC_SETIX(EP0);
+	ep0csr = inb(S3C2410_UDC_IN_CSR1_REG);
+
+	/* clear stall status */
+	if (ep0csr & S3C2410_UDC_EP0_CSR_SENTSTL) {
+		clear_sp0_sst;
+		/* FIXME */
+		ep0_idle();
+	}
+
+	if (ep0csr & S3C2410_UDC_EP0_CSR_SE
+	    && dev->ep0state != EP0_IDLE) {
+	    	clear_ep0_se;
+		ep0_idle();
+	}
+
+	switch (dev->ep0state) {
+	case EP0_IDLE:
+		if (ep0crs & S3C2410_UDC_EP0_CSR_OPKRDY) {
+		}
+		break;
+	case EP0_IN_DATA_PHASE:
+		break;
+	case EP0_OUT_DATA_PHASE:
+		break;
+	case EP0_END_XFER:
+		break;
+	case EP0_STALL:
+		set_ep0_ss;
+		break;
+	}
+}
+
+
+}
+
+/* Handle SETUP USB interrupt.
+ * This function implements TRM Figure 14-14.
+ */
+static void omap1510_udc_setup (struct usb_endpoint_instance *endpoint)
+{
+	UDCDBG ("-> Entering device setup");
+
+	do {
+		const int setup_pktsize = 8;
+		unsigned char *datap =
+			(unsigned char *) &ep0_urb->device_request;
+
+		/* Gain access to EP 0 setup FIFO */
+		outw (UDC_Setup_Sel, UDC_EP_NUM);
+
+		/* Read control request data */
+		insb (UDC_DATA, datap, setup_pktsize);
+
+		UDCDBGA ("EP0 setup read [%x %x %x %x %x %x %x %x]",
+			 *(datap + 0), *(datap + 1), *(datap + 2),
+			 *(datap + 3), *(datap + 4), *(datap + 5),
+			 *(datap + 6), *(datap + 7));
+
+		/* Reset EP0 setup FIFO */
+		outw (0, UDC_EP_NUM);
+	} while (inw (UDC_IRQ_SRC) & UDC_Setup);
+
+	/* Try to process setup packet */
+	if (ep0_recv_setup (ep0_urb)) {
+		/* Not a setup packet, stall next EP0 transaction */
+		udc_stall_ep (0);
+		UDCDBG ("can't parse setup packet, still waiting for setup");
+		return;
+	}
+
+	/* Check direction */
+	if ((ep0_urb->device_request.bmRequestType & USB_REQ_DIRECTION_MASK)
+	    == USB_REQ_HOST2DEVICE) {
+		UDCDBG ("control write on EP0");
+		if (le16_to_cpu (ep0_urb->device_request.wLength)) {
+			/* We don't support control write data stages.
+			 * The only standard control write request with a data
+			 * stage is SET_DESCRIPTOR, and ep0_recv_setup doesn't
+			 * support that so we just stall those requests.  A
+			 * function driver might support a non-standard
+			 * write request with a data stage, but it isn't
+			 * obvious what we would do with the data if we read it
+			 * so we'll just stall it.  It seems like the API isn't
+			 * quite right here.
+			 */
+#if 0
+			/* Here is what we would do if we did support control
+			 * write data stages.
+			 */
+			ep0_urb->actual_length = 0;
+			outw (0, UDC_EP_NUM);
+			/* enable the EP0 rx FIFO */
+			outw (UDC_Set_FIFO_En, UDC_CTRL);
+#else
+			/* Stall this request */
+			UDCDBG ("Stalling unsupported EP0 control write data "
+				"stage.");
+			udc_stall_ep (0);
+#endif
+		} else {
+			omap1510_prepare_for_control_write_status (ep0_urb);
+		}
+	} else {
+		UDCDBG ("control read on EP0");
+		/* The ep0_recv_setup function has already placed our response
+		 * packet data in ep0_urb->buffer and the packet length in
+		 * ep0_urb->actual_length.
+		 */
+		endpoint->tx_urb = ep0_urb;
+		endpoint->sent = 0;
+		/* select the EP0 tx FIFO */
+		outw (UDC_EP_Dir | UDC_EP_Sel, UDC_EP_NUM);
+		/* Write packet data to the FIFO.  omap1510_write_noniso_tx_fifo
+		 * will update endpoint->last with the number of bytes written
+		 * to the FIFO.
+		 */
+		omap1510_write_noniso_tx_fifo (endpoint);
+		/* enable the FIFO to start the packet transmission */
+		outw (UDC_Set_FIFO_En, UDC_CTRL);
+		/* deselect the EP0 tx FIFO */
+		outw (UDC_EP_Dir, UDC_EP_NUM);
+	}
+
+	UDCDBG ("<- Leaving device setup");
+}
+
+/* Handle endpoint 0 RX interrupt
+ * This routine implements TRM Figure 14-16.
+ */
+static void omap1510_udc_ep0_rx (struct usb_endpoint_instance *endpoint)
+{
+	unsigned short status;
+
+	UDCDBG ("RX on EP0");
+	/* select EP0 rx FIFO */
+	outw (UDC_EP_Sel, UDC_EP_NUM);
+
+	status = inw (UDC_STAT_FLG);
+
+	if (status & UDC_ACK) {
+		/* Check direction */
+		if ((ep0_urb->device_request.bmRequestType
+		     & USB_REQ_DIRECTION_MASK) == USB_REQ_HOST2DEVICE) {
+			/* This rx interrupt must be for a control write data
+			 * stage packet.
+			 *
+			 * We don't support control write data stages.
+			 * We should never end up here.
+			 */
+
+			/* clear the EP0 rx FIFO */
+			outw (UDC_Clr_EP, UDC_CTRL);
+
+			/* deselect the EP0 rx FIFO */
+			outw (0, UDC_EP_NUM);
+
+			UDCDBG ("Stalling unexpected EP0 control write "
+				"data stage packet");
+			udc_stall_ep (0);
+		} else {
+			/* This rx interrupt must be for a control read status
+			 * stage packet.
+			 */
+			UDCDBG ("ACK on EP0 control read status stage packet");
+			/* deselect EP0 rx FIFO */
+			outw (0, UDC_EP_NUM);
+		}
+	} else if (status & UDC_STALL) {
+		UDCDBG ("EP0 stall during RX");
+		/* deselect EP0 rx FIFO */
+		outw (0, UDC_EP_NUM);
+	} else {
+		/* deselect EP0 rx FIFO */
+		outw (0, UDC_EP_NUM);
+	}
+}
+
+/* Handle endpoint 0 TX interrupt
+ * This routine implements TRM Figure 14-18.
+ */
+static void omap1510_udc_ep0_tx (struct usb_endpoint_instance *endpoint)
+{
+	unsigned short status;
+	struct usb_device_request *request = &ep0_urb->device_request;
+
+	UDCDBG ("TX on EP0");
+	/* select EP0 TX FIFO */
+	outw (UDC_EP_Dir | UDC_EP_Sel, UDC_EP_NUM);
+
+	status = inw (UDC_STAT_FLG);
+	if (status & UDC_ACK) {
+		/* Check direction */
+		if ((request->bmRequestType & USB_REQ_DIRECTION_MASK) ==
+		    USB_REQ_HOST2DEVICE) {
+			/* This tx interrupt must be for a control write status
+			 * stage packet.
+			 */
+			UDCDBG ("ACK on EP0 control write status stage packet");
+			/* deselect EP0 TX FIFO */
+			outw (UDC_EP_Dir, UDC_EP_NUM);
+		} else {
+			/* This tx interrupt must be for a control read data
+			 * stage packet.
+			 */
+			int wLength = le16_to_cpu (request->wLength);
+
+			/* Update our count of bytes sent so far in this
+			 * transfer.
+			 */
+			endpoint->sent += endpoint->last;
+
+			/* We are finished with this transfer if we have sent
+			 * all of the bytes in our tx urb (urb->actual_length)
+			 * unless we need a zero-length terminating packet.  We
+			 * need a zero-length terminating packet if we returned
+			 * fewer bytes than were requested (wLength) by the host,
+			 * and the number of bytes we returned is an exact
+			 * multiple of the packet size endpoint->tx_packetSize.
+			 */
+			if ((endpoint->sent == ep0_urb->actual_length)
+			    && ((ep0_urb->actual_length == wLength)
+				|| (endpoint->last !=
+				    endpoint->tx_packetSize))) {
+				/* Done with control read data stage. */
+				UDCDBG ("control read data stage complete");
+				/* deselect EP0 TX FIFO */
+				outw (UDC_EP_Dir, UDC_EP_NUM);
+				/* select EP0 RX FIFO to prepare for control
+				 * read status stage.
+				 */
+				outw (UDC_EP_Sel, UDC_EP_NUM);
+				/* clear the EP0 RX FIFO */
+				outw (UDC_Clr_EP, UDC_CTRL);
+				/* enable the EP0 RX FIFO */
+				outw (UDC_Set_FIFO_En, UDC_CTRL);
+				/* deselect the EP0 RX FIFO */
+				outw (0, UDC_EP_NUM);
+			} else {
+				/* We still have another packet of data to send
+				 * in this control read data stage or else we
+				 * need a zero-length terminating packet.
+				 */
+				UDCDBG ("ACK control read data stage packet");
+				omap1510_write_noniso_tx_fifo (endpoint);
+				/* enable the EP0 tx FIFO to start transmission */
+				outw (UDC_Set_FIFO_En, UDC_CTRL);
+				/* deselect EP0 TX FIFO */
+				outw (UDC_EP_Dir, UDC_EP_NUM);
+			}
+		}
+	} else if (status & UDC_STALL) {
+		UDCDBG ("EP0 stall during TX");
+		/* deselect EP0 TX FIFO */
+		outw (UDC_EP_Dir, UDC_EP_NUM);
+	} else {
+		/* deselect EP0 TX FIFO */
+		outw (UDC_EP_Dir, UDC_EP_NUM);
+	}
+}
+
+/* Handle RX transaction on non-ISO endpoint.
+ * This function implements TRM Figure 14-27.
+ * The ep argument is a physical endpoint number for a non-ISO OUT endpoint
+ * in the range 1 to 15.
+ */
+static void omap1510_udc_epn_rx (int ep)
+{
+	unsigned short status;
+
+	/* Check endpoint status */
+	status = inw (UDC_STAT_FLG);
+
+	if (status & UDC_ACK) {
+		int nbytes;
+		struct usb_endpoint_instance *endpoint =
+			omap1510_find_ep (ep);
+
+		nbytes = omap1510_read_noniso_rx_fifo (endpoint);
+		usbd_rcv_complete (endpoint, nbytes, 0);
+
+		/* enable rx FIFO to prepare for next packet */
+		outw (UDC_Set_FIFO_En, UDC_CTRL);
+	} else if (status & UDC_STALL) {
+		UDCDBGA ("STALL on RX endpoint %d", ep);
+	} else if (status & UDC_NAK) {
+		UDCDBGA ("NAK on RX ep %d", ep);
+	} else {
+		serial_printf ("omap-bi: RX on ep %d with status %x", ep,
+			       status);
+	}
+}
+
+/* Handle TX transaction on non-ISO endpoint.
+ * This function implements TRM Figure 14-29.
+ * The ep argument is a physical endpoint number for a non-ISO IN endpoint
+ * in the range 16 to 30.
+ */
+static void omap1510_udc_epn_tx (int ep)
+{
+	unsigned short status;
+
+	/*serial_printf("omap1510_udc_epn_tx( %x )\n",ep); */
+
+	/* Check endpoint status */
+	status = inw (UDC_STAT_FLG);
+
+	if (status & UDC_ACK) {
+		struct usb_endpoint_instance *endpoint =
+			omap1510_find_ep (ep);
+
+		/* We need to transmit a terminating zero-length packet now if
+		 * we have sent all of the data in this URB and the transfer
+		 * size was an exact multiple of the packet size.
+		 */
+		if (endpoint->tx_urb
+		    && (endpoint->last == endpoint->tx_packetSize)
+		    && (endpoint->tx_urb->actual_length - endpoint->sent -
+			endpoint->last == 0)) {
+			/* Prepare to transmit a zero-length packet. */
+			endpoint->sent += endpoint->last;
+			/* write 0 bytes of data to FIFO */
+			omap1510_write_noniso_tx_fifo (endpoint);
+			/* enable tx FIFO to start transmission */
+			outw (UDC_Set_FIFO_En, UDC_CTRL);
+		} else if (endpoint->tx_urb
+			   && endpoint->tx_urb->actual_length) {
+			/* retire the data that was just sent */
+			usbd_tx_complete (endpoint);
+			/* Check to see if we have more data ready to transmit
+			 * now.
+			 */
+			if (endpoint->tx_urb
+			    && endpoint->tx_urb->actual_length) {
+				/* write data to FIFO */
+				omap1510_write_noniso_tx_fifo (endpoint);
+				/* enable tx FIFO to start transmission */
+				outw (UDC_Set_FIFO_En, UDC_CTRL);
+			}
+		}
+	} else if (status & UDC_STALL) {
+		UDCDBGA ("STALL on TX endpoint %d", ep);
+	} else if (status & UDC_NAK) {
+		UDCDBGA ("NAK on TX endpoint %d", ep);
+	} else {
+		/*serial_printf("omap-bi: TX on ep %d with status %x\n", ep, status); */
+	}
+}
+
+
+/*
+-------------------------------------------------------------------------------
+*/
+
+/* Handle general USB interrupts and dispatch according to type.
+ * This function implements TRM Figure 14-13.
+ */
+void s3c2410_udc_irq (void)
+{
+	u_int8_t save_idx = inb(S3C2410_UDC_INDEX_REG);
+	u_int8_t usb_status = inb(S3C2410_UDC_USB_INT_REG);
+	u_int8_t usbd_status = inb(S3C2410_UDC_EP_INT_REG);
+
+	UDCDBGA("< IRQ usbs=0x%02x, usbds=0x%02x start >", usb_status,
+		usbd_status);
+
+	if (usb_status & S3C2410_UDC_USBINT_RESET) {
+		valid_irq++;
+	}
+
+	if (usb_status & S3C2410_UDC_USBINT_RESUME) {
+		valid_irq++;
+
+	}
+
+	if (usb_status & S3C2410_UDC_USBINT_SUSPEND) {
+		valid_irq++;
+
+	}
+
+	/* Endpoint Interrupts */
+	if (usbd_status) {
+		int i;
+
+		if (usbd_status & S3C2410_UDC_INT_EP0) {
+			s3c2410_udc_ep0();
+			outb(S3C2410_UDC_INT_EP0, S3C2410_UDC_EP_INT_REG);
+			valid_irq++;
+		}
+
+		for (i = 1; i < 5; i++) {
+			u_int32_t tmp = 1 << i;
+
+			if (usbd_status & tmp) {
+				/* FIXME: Handle EP X */
+				s3c2410_udc_epn(i);
+				outb(tmp, S3C2410_UDC_EP_INT_REG);
+				valid_irq++;
+			}
+		}
+	}
+	outb(save_idx, S3C2410_UDC_INDEX_REG);
+
+#if 0
+	if (!(irq_src & ~UDC_SOF_Flg))	/* ignore SOF interrupts ) */
+		return;
+
+	UDCDBGA ("< IRQ #%d start >- %x", udc_interrupts, irq_src);
+	/*serial_printf("< IRQ #%d start >- %x\n", udc_interrupts, irq_src); */
+
+	if (irq_src & UDC_DS_Chg) {
+		/* Device status changed */
+		omap1510_udc_state_changed ();
+		valid_irq++;
+	}
+	if (irq_src & UDC_EP0_RX) {
+		/* Endpoint 0 receive */
+		outw (UDC_EP0_RX, UDC_IRQ_SRC); /* ack interrupt */
+		omap1510_udc_ep0_rx (udc_device->bus->endpoint_array + 0);
+		valid_irq++;
+	}
+	if (irq_src & UDC_EP0_TX) {
+		/* Endpoint 0 transmit */
+		outw (UDC_EP0_TX, UDC_IRQ_SRC); /* ack interrupt */
+		omap1510_udc_ep0_tx (udc_device->bus->endpoint_array + 0);
+		valid_irq++;
+	}
+	if (irq_src & UDC_Setup) {
+		/* Device setup */
+		omap1510_udc_setup (udc_device->bus->endpoint_array + 0);
+		valid_irq++;
+	}
+	/*if (!valid_irq) */
+	/*	serial_printf("unknown interrupt, IRQ_SRC %.4x\n", irq_src); */
+#endif
+	UDCDBGA ("< IRQ end >", udc_interrupts);
+
+	udc_interrupts++;
+}
+
+/* This function implements TRM Figure 14-26. */
+void omap1510_udc_noniso_irq (void)
+{
+	unsigned short epnum;
+	unsigned short irq_src = inw (UDC_IRQ_SRC);
+	int valid_irq = 0;
+
+	if (!(irq_src & (UDC_EPn_RX | UDC_EPn_TX)))
+		return;
+
+	UDCDBGA ("non-ISO IRQ, IRQ_SRC %x", inw (UDC_IRQ_SRC));
+
+	if (irq_src & UDC_EPn_RX) {	/* Endpoint N OUT transaction */
+		/* Determine the endpoint number for this interrupt */
+		epnum = (inw (UDC_EPN_STAT) & 0x0f00) >> 8;
+		UDCDBGA ("RX on ep %x", epnum);
+
+		/* acknowledge interrupt */
+		outw (UDC_EPn_RX, UDC_IRQ_SRC);
+
+		if (epnum) {
+			/* select the endpoint FIFO */
+			outw (UDC_EP_Sel | epnum, UDC_EP_NUM);
+
+			omap1510_udc_epn_rx (epnum);
+
+			/* deselect the endpoint FIFO */
+			outw (epnum, UDC_EP_NUM);
+		}
+		valid_irq++;
+	}
+	if (irq_src & UDC_EPn_TX) {	/* Endpoint N IN transaction */
+		/* Determine the endpoint number for this interrupt */
+		epnum = (inw (UDC_EPN_STAT) & 0x000f) | USB_DIR_IN;
+		UDCDBGA ("TX on ep %x", epnum);
+
+		/* acknowledge interrupt */
+		outw (UDC_EPn_TX, UDC_IRQ_SRC);
+
+		if (epnum) {
+			/* select the endpoint FIFO */
+			outw (UDC_EP_Sel | UDC_EP_Dir | epnum, UDC_EP_NUM);
+
+			omap1510_udc_epn_tx (epnum);
+
+			/* deselect the endpoint FIFO */
+			outw (UDC_EP_Dir | epnum, UDC_EP_NUM);
+		}
+		valid_irq++;
+	}
+	if (!valid_irq)
+		serial_printf (": unknown non-ISO interrupt, IRQ_SRC %.4x\n",
+			       irq_src);
+}
+
+/*
+-------------------------------------------------------------------------------
+*/
+
+
+/*
+ * Start of public functions.
+ */
+
+/* Called to start packet transmission. */
+void udc_endpoint_write (struct usb_endpoint_instance *endpoint)
+{
+	unsigned short epnum =
+		endpoint->endpoint_address & USB_ENDPOINT_NUMBER_MASK;
+
+	UDCDBGA ("Starting transmit on ep %x", epnum);
+
+	if (endpoint->tx_urb) {
+		/* select the endpoint FIFO */
+		outw (UDC_EP_Sel | UDC_EP_Dir | epnum, UDC_EP_NUM);
+		/* write data to FIFO */
+		omap1510_write_noniso_tx_fifo (endpoint);
+		/* enable tx FIFO to start transmission */
+		outw (UDC_Set_FIFO_En, UDC_CTRL);
+		/* deselect the endpoint FIFO */
+		outw (UDC_EP_Dir | epnum, UDC_EP_NUM);
+	}
+}
+
+/* Start to initialize h/w stuff */
+int udc_init (void)
+{
+	u16 udc_rev;
+	uchar value;
+	ulong gpio;
+	int i;
+
+	/* Let the device settle down before we start */
+	for (i = 0; i < UDC_INIT_MDELAY; i++) udelay(1000);
+
+	udc_device = NULL;
+
+	UDCDBG ("starting");
+
+	/* Check peripheral reset. Must be 1 to make sure
+	   MPU TIPB peripheral reset is inactive */
+	UDCREG (ARM_RSTCT2);
+
+	/* Set and check clock control.
+	 * We might ought to be using the clock control API to do
+	 * this instead of fiddling with the clock registers directly
+	 * here.
+	 */
+	outw ((1 << 4) | (1 << 5), CLOCK_CTRL);
+	UDCREG (CLOCK_CTRL);
+	/* Set and check APLL */
+	outw (0x0008, APLL_CTRL);
+	UDCREG (APLL_CTRL);
+	/* Set and check DPLL */
+	outw (0x2210, DPLL_CTRL);
+	UDCREG (DPLL_CTRL);
+	/* Set and check SOFT */
+	outw ((1 << 4) | (1 << 3) | 1, SOFT_REQ);
+	/* Short delay to wait for DPLL */
+	udelay (1000);
+
+	/* Print banner with device revision */
+	udc_rev = inw (UDC_REV) & 0xff;
+	printf ("USB:   TI OMAP1510 USB function module rev %d.%d\n",
+		udc_rev >> 4, udc_rev & 0xf);
+
+#ifdef CONFIG_OMAP_SX1
+	i2c_read (0x32, 0x04, 1, &value, 1);
+	value |= 0x04;
+	i2c_write (0x32, 0x04, 1, &value, 1);
+
+	i2c_read (0x32, 0x03, 1, &value, 1);
+	value |= 0x01;
+	i2c_write (0x32, 0x03, 1, &value, 1);
+
+	gpio = inl(GPIO_PIN_CONTROL_REG);
+	gpio |=  0x0002; /* A_IRDA_OFF */
+	gpio |=  0x0800; /* A_SWITCH   */
+	gpio |=  0x8000; /* A_USB_ON   */
+	outl (gpio, GPIO_PIN_CONTROL_REG);
+
+	gpio = inl(GPIO_DIR_CONTROL_REG);
+	gpio &= ~0x0002; /* A_IRDA_OFF */
+	gpio &= ~0x0800; /* A_SWITCH   */
+	gpio &= ~0x8000; /* A_USB_ON   */
+	outl (gpio, GPIO_DIR_CONTROL_REG);
+
+	gpio = inl(GPIO_DATA_OUTPUT_REG);
+	gpio |=  0x0002; /* A_IRDA_OFF */
+	gpio &= ~0x0800; /* A_SWITCH   */
+	gpio &= ~0x8000; /* A_USB_ON   */
+	outl (gpio, GPIO_DATA_OUTPUT_REG);
+#endif
+
+	/* The VBUS_MODE bit selects whether VBUS detection is done via
+	 * software (1) or hardware (0).  When software detection is
+	 * selected, VBUS_CTRL selects whether USB is not connected (0)
+	 * or connected (1).
+	 */
+	outl (inl (FUNC_MUX_CTRL_0) | UDC_VBUS_MODE, FUNC_MUX_CTRL_0);
+	outl (inl (FUNC_MUX_CTRL_0) & ~UDC_VBUS_CTRL, FUNC_MUX_CTRL_0);
+	UDCREGL (FUNC_MUX_CTRL_0);
+
+	/*
+	 * At this point, device is ready for configuration...
+	 */
+
+	UDCDBG ("disable USB interrupts");
+	outw (0, UDC_IRQ_EN);
+	UDCREG (UDC_IRQ_EN);
+
+	UDCDBG ("disable USB DMA");
+	outw (0, UDC_DMA_IRQ_EN);
+	UDCREG (UDC_DMA_IRQ_EN);
+
+	UDCDBG ("initialize SYSCON1");
+	outw (UDC_Self_Pwr | UDC_Pullup_En, UDC_SYSCON1);
+	UDCREG (UDC_SYSCON1);
+
+	return 0;
+}
+
+/* Stall endpoint */
+static void udc_stall_ep (unsigned int ep_addr)
+{
+	/*int ep_addr = PHYS_EP_TO_EP_ADDR(ep); */
+	int ep_num = ep_addr & USB_ENDPOINT_NUMBER_MASK;
+
+	UDCDBGA ("stall ep_addr %d", ep_addr);
+
+	/* REVISIT?
+	 * The OMAP TRM section 14.2.4.2 says we must check that the FIFO
+	 * is empty before halting the endpoint.  The current implementation
+	 * doesn't check that the FIFO is empty.
+	 */
+
+	if (!ep_num) {
+		outw (UDC_Stall_Cmd, UDC_SYSCON2);
+	} else if ((ep_addr & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT) {
+		if (inw (UDC_EP_RX (ep_num)) & UDC_EPn_RX_Valid) {
+			/* we have a valid rx endpoint, so halt it */
+			outw (UDC_EP_Sel | ep_num, UDC_EP_NUM);
+			outw (UDC_Set_Halt, UDC_CTRL);
+			outw (ep_num, UDC_EP_NUM);
+		}
+	} else {
+		if (inw (UDC_EP_TX (ep_num)) & UDC_EPn_TX_Valid) {
+			/* we have a valid tx endpoint, so halt it */
+			outw (UDC_EP_Sel | UDC_EP_Dir | ep_num, UDC_EP_NUM);
+			outw (UDC_Set_Halt, UDC_CTRL);
+			outw (ep_num, UDC_EP_NUM);
+		}
+	}
+}
+
+/* Reset endpoint */
+#if 0
+static void udc_reset_ep (unsigned int ep_addr)
+{
+	/*int ep_addr = PHYS_EP_TO_EP_ADDR(ep); */
+	int ep_num = ep_addr & USB_ENDPOINT_NUMBER_MASK;
+
+	UDCDBGA ("reset ep_addr %d", ep_addr);
+
+	if (!ep_num) {
+		/* control endpoint 0 can't be reset */
+	} else if ((ep_addr & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT) {
+		UDCDBGA ("UDC_EP_RX(%d) = 0x%04x", ep_num,
+			 inw (UDC_EP_RX (ep_num)));
+		if (inw (UDC_EP_RX (ep_num)) & UDC_EPn_RX_Valid) {
+			/* we have a valid rx endpoint, so reset it */
+			outw (ep_num | UDC_EP_Sel, UDC_EP_NUM);
+			outw (UDC_Reset_EP, UDC_CTRL);
+			outw (ep_num, UDC_EP_NUM);
+			UDCDBGA ("OUT endpoint %d reset", ep_num);
+		}
+	} else {
+		UDCDBGA ("UDC_EP_TX(%d) = 0x%04x", ep_num,
+			 inw (UDC_EP_TX (ep_num)));
+		/* Resetting of tx endpoints seems to be causing the USB function
+		 * module to fail, which causes problems when the driver is
+		 * uninstalled.	 We'll skip resetting tx endpoints for now until
+		 * we figure out what the problem is.
+		 */
+#if 0
+		if (inw (UDC_EP_TX (ep_num)) & UDC_EPn_TX_Valid) {
+			/* we have a valid tx endpoint, so reset it */
+			outw (ep_num | UDC_EP_Dir | UDC_EP_Sel, UDC_EP_NUM);
+			outw (UDC_Reset_EP, UDC_CTRL);
+			outw (ep_num | UDC_EP_Dir, UDC_EP_NUM);
+			UDCDBGA ("IN endpoint %d reset", ep_num);
+		}
+#endif
+	}
+}
+#endif
+
+/* ************************************************************************** */
+
+/**
+ * udc_check_ep - check logical endpoint
+  *
+ * Return physical endpoint number to use for this logical endpoint or zero if not valid.
+ */
+#if 0
+int udc_check_ep (int logical_endpoint, int packetsize)
+{
+	if ((logical_endpoint == 0x80) ||
+	    ((logical_endpoint & 0x8f) != logical_endpoint)) {
+		return 0;
+	}
+
+	switch (packetsize) {
+	case 8:
+	case 16:
+	case 32:
+	case 64:
+	case 128:
+	case 256:
+	case 512:
+		break;
+	default:
+		return 0;
+	}
+
+	return EP_ADDR_TO_PHYS_EP (logical_endpoint);
+}
+#endif
+
+/*
+ * udc_setup_ep - setup endpoint
+ *
+ * Associate a physical endpoint with endpoint_instance
+ */
+void udc_setup_ep (struct usb_device_instance *device,
+		   unsigned int ep, struct usb_endpoint_instance *endpoint)
+{
+	UDCDBGA ("setting up endpoint addr %x", endpoint->endpoint_address);
+
+	/* This routine gets called by bi_modinit for endpoint 0 and from
+	 * bi_config for all of the other endpoints.  bi_config gets called
+	 * during the DEVICE_CREATE, DEVICE_CONFIGURED, and
+	 * DEVICE_SET_INTERFACE events.	 We need to reconfigure the OMAP packet
+	 * RAM after bi_config scans the selected device configuration and
+	 * initializes the endpoint structures, but before this routine enables
+	 * the OUT endpoint FIFOs.  Since bi_config calls this routine in a
+	 * loop for endpoints 1 through UDC_MAX_ENDPOINTS, we reconfigure our
+	 * packet RAM here when ep==1.
+	 * I really hate to do this here, but it seems like the API exported
+	 * by the USB bus interface controller driver to the usbd-bi module
+	 * isn't quite right so there is no good place to do this.
+	 */
+	if (ep == 1) {
+		omap1510_deconfigure_device ();
+		omap1510_configure_device (device);
+	}
+
+	if (endpoint && (ep < UDC_MAX_ENDPOINTS)) {
+		int ep_addr = endpoint->endpoint_address;
+
+		if (!ep_addr) {
+			/* nothing to do for endpoint 0 */
+		} else if ((ep_addr & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN) {
+			/* nothing to do for IN (tx) endpoints */
+		} else {	/* OUT (rx) endpoint */
+			if (endpoint->rcv_packetSize) {
+				/*struct urb* urb = &(urb_out_array[ep&0xFF]); */
+				/*urb->endpoint = endpoint; */
+				/*urb->device = device; */
+				/*urb->buffer_length = sizeof(urb->buffer); */
+
+				/*endpoint->rcv_urb = urb; */
+				omap1510_prepare_endpoint_for_rx (ep_addr);
+			}
+		}
+	}
+}
+
+/**
+ * udc_disable_ep - disable endpoint
+ * @ep:
+ *
+ * Disable specified endpoint
+ */
+#if 0
+void udc_disable_ep (unsigned int ep_addr)
+{
+	/*int ep_addr = PHYS_EP_TO_EP_ADDR(ep); */
+	int ep_num = ep_addr & USB_ENDPOINT_NUMBER_MASK;
+	struct usb_endpoint_instance *endpoint = omap1510_find_ep (ep_addr);	/*udc_device->bus->endpoint_array + ep; */
+
+	UDCDBGA ("disable ep_addr %d", ep_addr);
+
+	if (!ep_num) {
+		/* nothing to do for endpoint 0 */ ;
+	} else if ((ep_addr & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN) {
+		if (endpoint->tx_packetSize) {
+			/* we have a valid tx endpoint */
+			/*usbd_flush_tx(endpoint); */
+			endpoint->tx_urb = NULL;
+		}
+	} else {
+		if (endpoint->rcv_packetSize) {
+			/* we have a valid rx endpoint */
+			/*usbd_flush_rcv(endpoint); */
+			endpoint->rcv_urb = NULL;
+		}
+	}
+}
+#endif
+
+/* ************************************************************************** */
+
+/**
+ * udc_connected - is the USB cable connected
+ *
+ * Return non-zero if cable is connected.
+ */
+#if 0
+int udc_connected (void)
+{
+	return ((inw (UDC_DEVSTAT) & UDC_ATT) == UDC_ATT);
+}
+#endif
+
+/* Turn on the USB connection by enabling the pullup resistor */
+void udc_connect (void)
+{
+	UDCDBG ("connect, enable Pullup");
+}
+
+/* Turn off the USB connection by disabling the pullup resistor */
+void udc_disconnect (void)
+{
+	UDCDBG ("disconnect, disable Pullup");
+}
+
+/* ************************************************************************** */
+
+
+/*
+ * udc_disable_interrupts - disable interrupts
+ * switch off interrupts
+ */
+#if 0
+void udc_disable_interrupts (struct usb_device_instance *device)
+{
+	UDCDBG ("disabling all interrupts");
+	outw (0, UDC_IRQ_EN);
+}
+#endif
+
+/* ************************************************************************** */
+
+/**
+ * udc_ep0_packetsize - return ep0 packetsize
+ */
+#if 0
+int udc_ep0_packetsize (void)
+{
+	return EP0_PACKETSIZE;
+}
+#endif
+
+/* Switch on the UDC */
+void udc_enable (struct usb_device_instance *device)
+{
+	UDCDBGA ("enable device %p, status %d", device, device->status);
+
+	/* initialize driver state variables */
+	udc_devstat = 0;
+
+	/* Save the device structure pointer */
+	udc_device = device;
+
+	/* Setup ep0 urb */
+	if (!ep0_urb) {
+		ep0_urb =
+			usbd_alloc_urb (udc_device,
+					udc_device->bus->endpoint_array);
+	} else {
+		serial_printf ("udc_enable: ep0_urb already allocated %p\n",
+			       ep0_urb);
+	}
+
+#ifdef FIXME
+	/* The VBUS_MODE bit selects whether VBUS detection is done via
+	 * software (1) or hardware (0).  When software detection is
+	 * selected, VBUS_CTRL selects whether USB is not connected (0)
+	 * or connected (1).
+	 */
+	outl (inl (FUNC_MUX_CTRL_0) | UDC_VBUS_CTRL | UDC_VBUS_MODE,
+	      FUNC_MUX_CTRL_0);
+	UDCREGL (FUNC_MUX_CTRL_0);
+#endif
+
+	s3c2410_configure_device(device);
+}
+
+/* Switch off the UDC */
+void udc_disable (void)
+{
+	UDCDBG ("disable UDC");
+
+	s3c2410_deconfigure_device();
+
+#ifdef FIXME
+	/* The VBUS_MODE bit selects whether VBUS detection is done via
+	 * software (1) or hardware (0).  When software detection is
+	 * selected, VBUS_CTRL selects whether USB is not connected (0)
+	 * or connected (1).
+	 */
+	outl (inl (FUNC_MUX_CTRL_0) | UDC_VBUS_MODE, FUNC_MUX_CTRL_0);
+	outl (inl (FUNC_MUX_CTRL_0) & ~UDC_VBUS_CTRL, FUNC_MUX_CTRL_0);
+	UDCREGL (FUNC_MUX_CTRL_0);
+#endif
+
+	/* Free ep0 URB */
+	if (ep0_urb) {
+		/*usbd_dealloc_urb(ep0_urb); */
+		ep0_urb = NULL;
+	}
+
+	/* Reset device pointer.
+	 * We ought to do this here to balance the initialization of udc_device
+	 * in udc_enable, but some of our other exported functions get called
+	 * by the bus interface driver after udc_disable, so we have to hang on
+	 * to the device pointer to avoid a null pointer dereference. */
+	/* udc_device = NULL; */
+}
+
+/**
+ * udc_startup - allow udc code to do any additional startup
+ */
+void udc_startup_events (struct usb_device_instance *device)
+{
+	/* The DEVICE_INIT event puts the USB device in the state STATE_INIT. */
+	usbd_device_event_irq (device, DEVICE_INIT, 0);
+
+	/* The DEVICE_CREATE event puts the USB device in the state
+	 * STATE_ATTACHED.
+	 */
+	usbd_device_event_irq (device, DEVICE_CREATE, 0);
+
+	/* Some USB controller driver implementations signal
+	 * DEVICE_HUB_CONFIGURED and DEVICE_RESET events here.
+	 * DEVICE_HUB_CONFIGURED causes a transition to the state STATE_POWERED,
+	 * and DEVICE_RESET causes a transition to the state STATE_DEFAULT.
+	 * The OMAP USB client controller has the capability to detect when the
+	 * USB cable is connected to a powered USB bus via the ATT bit in the
+	 * DEVSTAT register, so we will defer the DEVICE_HUB_CONFIGURED and
+	 * DEVICE_RESET events until later.
+	 */
+
+	udc_enable (device);
+}
+
+#endif
diff --git a/examples/Makefile b/examples/Makefile
index a342d75..082e52e 100644
--- a/examples/Makefile
+++ b/examples/Makefile
@@ -60,7 +60,7 @@ endif
 include $(TOPDIR)/config.mk
 
 SREC	= hello_world.srec
-BIN	= hello_world.bin hello_world
+BIN	= hello_world hello_world.bin
 
 ifeq ($(CPU),mpc8xx)
 SREC	= test_burst.srec
@@ -122,7 +122,7 @@ clibdir := $(shell dirname `$(CC) $(CFLA
 
 CPPFLAGS += -I..
 
-all:	.depend $(OBJS) $(LIB) $(SREC) $(BIN)
+all:	.depend $(OBJS) $(LIB) $(BIN) $(SREC)
 
 #########################################################################
 $(LIB): .depend $(LIBOBJS)
diff --git a/include/asm-arm/arch-s3c24x0/mmc.h b/include/asm-arm/arch-s3c24x0/mmc.h
new file mode 100644
index 0000000..d9178f3
--- /dev/null
+++ b/include/asm-arm/arch-s3c24x0/mmc.h
@@ -0,0 +1,112 @@
+/*
+ *  linux/drivers/mmc/mmc_pxa.h
+ *
+ *  Author: Vladimir Shebordaev, Igor Oblakov
+ *  Copyright:  MontaVista Software Inc.
+ *
+ *  $Id: mmc_pxa.h,v 0.3.1.6 2002/09/25 19:25:48 ted Exp ted $
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+#ifndef __MMC_PXA_P_H__
+#define __MMC_PXA_P_H__
+
+#include <asm/arch/regs-sdi.h>
+
+#define MMC_DEFAULT_RCA			(1<<16)
+
+#define MMC_BLOCK_SIZE			512
+#define MMC_CMD_RESET			0
+#define MMC_CMD_SEND_OP_COND		1
+#define MMC_CMD_ALL_SEND_CID 		2
+#define MMC_CMD_SET_RCA			3
+#define MMC_CMD_SELECT_CARD		7
+#define MMC_CMD_SEND_CSD 		9
+#define MMC_CMD_SEND_CID 		10
+#define MMC_CMD_SEND_STATUS		13
+#define MMC_CMD_SET_BLOCKLEN		16
+#define MMC_CMD_READ_BLOCK		17
+#define MMC_CMD_RD_BLK_MULTI		18
+#define MMC_CMD_WRITE_BLOCK		24
+
+#define MMC_MAX_BLOCK_SIZE		512
+
+#define MMC_R1_IDLE_STATE		0x01
+#define MMC_R1_ERASE_STATE		0x02
+#define MMC_R1_ILLEGAL_CMD		0x04
+#define MMC_R1_COM_CRC_ERR		0x08
+#define MMC_R1_ERASE_SEQ_ERR		0x01
+#define MMC_R1_ADDR_ERR			0x02
+#define MMC_R1_PARAM_ERR		0x04
+
+#define MMC_R1B_WP_ERASE_SKIP		0x0002
+#define MMC_R1B_ERR			0x0004
+#define MMC_R1B_CC_ERR			0x0008
+#define MMC_R1B_CARD_ECC_ERR		0x0010
+#define MMC_R1B_WP_VIOLATION		0x0020
+#define MMC_R1B_ERASE_PARAM		0x0040
+#define MMC_R1B_OOR			0x0080
+#define MMC_R1B_IDLE_STATE		0x0100
+#define MMC_R1B_ERASE_RESET		0x0200
+#define MMC_R1B_ILLEGAL_CMD		0x0400
+#define MMC_R1B_COM_CRC_ERR		0x0800
+#define MMC_R1B_ERASE_SEQ_ERR		0x1000
+#define MMC_R1B_ADDR_ERR		0x2000
+#define MMC_R1B_PARAM_ERR		0x4000
+
+typedef struct mmc_cid
+{
+/* FIXME: BYTE_ORDER */
+   uchar year:4,
+   month:4;
+   uchar sn[3];
+   uchar fwrev:4,
+   hwrev:4;
+   uchar name[6];
+   uchar id[3];
+} mmc_cid_t;
+
+typedef struct mmc_csd
+{
+	uchar	ecc:2,
+		file_format:2,
+		tmp_write_protect:1,
+		perm_write_protect:1,
+		copy:1,
+		file_format_grp:1;
+	uint64_t content_prot_app:1,
+		rsvd3:4,
+		write_bl_partial:1,
+		write_bl_len:4,
+		r2w_factor:3,
+		default_ecc:2,
+		wp_grp_enable:1,
+		wp_grp_size:5,
+		erase_grp_mult:5,
+		erase_grp_size:5,
+		c_size_mult1:3,
+		vdd_w_curr_max:3,
+		vdd_w_curr_min:3,
+		vdd_r_curr_max:3,
+		vdd_r_curr_min:3,
+		c_size:12,
+		rsvd2:2,
+		dsr_imp:1,
+		read_blk_misalign:1,
+		write_blk_misalign:1,
+		read_bl_partial:1;
+
+	ushort	read_bl_len:4,
+		ccc:12;
+	uchar	tran_speed;
+	uchar	nsac;
+	uchar	taac;
+	uchar	rsvd1:2,
+  		spec_vers:4,
+		csd_structure:2;
+} mmc_csd_t;
+
+
+#endif /* __MMC_PXA_P_H__ */
diff --git a/include/asm-arm/arch-s3c24x0/regs-sdi.h b/include/asm-arm/arch-s3c24x0/regs-sdi.h
new file mode 100644
index 0000000..9b5b9d1
--- /dev/null
+++ b/include/asm-arm/arch-s3c24x0/regs-sdi.h
@@ -0,0 +1,110 @@
+/* linux/include/asm/arch-s3c2410/regs-sdi.h
+ *
+ * Copyright (c) 2004 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 MMC/SDIO register definitions
+ *
+ *  Changelog:
+ *    18-Aug-2004 Ben Dooks      Created initial file
+ *    29-Nov-2004 Koen Martens   Added some missing defines, fixed duplicates
+ *    29-Nov-2004 Ben Dooks	 Updated Koen's patch
+*/
+
+#ifndef __ASM_ARM_REGS_SDI
+#define __ASM_ARM_REGS_SDI "regs-sdi.h"
+
+#define S3C2440_SDICON_SDRESET        (1<<8)
+#define S3C2440_SDICON_MMCCLOCK       (1<<5)
+#define S3C2410_SDICON_BYTEORDER      (1<<4)
+#define S3C2410_SDICON_SDIOIRQ        (1<<3)
+#define S3C2410_SDICON_RWAITEN        (1<<2)
+#define S3C2410_SDICON_FIFORESET      (1<<1)
+#define S3C2410_SDICON_CLOCKTYPE      (1<<0)
+
+#define S3C2410_SDICMDCON_ABORT       (1<<12)
+#define S3C2410_SDICMDCON_WITHDATA    (1<<11)
+#define S3C2410_SDICMDCON_LONGRSP     (1<<10)
+#define S3C2410_SDICMDCON_WAITRSP     (1<<9)
+#define S3C2410_SDICMDCON_CMDSTART    (1<<8)
+#define S3C2410_SDICMDCON_SENDERHOST  (1<<6)
+#define S3C2410_SDICMDCON_INDEX       (0x3f)
+
+#define S3C2410_SDICMDSTAT_CRCFAIL    (1<<12)
+#define S3C2410_SDICMDSTAT_CMDSENT    (1<<11)
+#define S3C2410_SDICMDSTAT_CMDTIMEOUT (1<<10)
+#define S3C2410_SDICMDSTAT_RSPFIN     (1<<9)
+#define S3C2410_SDICMDSTAT_XFERING    (1<<8)
+#define S3C2410_SDICMDSTAT_INDEX      (0xff)
+
+#define S3C2440_SDIDCON_DS_BYTE       (0<<22)
+#define S3C2440_SDIDCON_DS_HALFWORD   (1<<22)
+#define S3C2440_SDIDCON_DS_WORD       (2<<22)
+#define S3C2410_SDIDCON_IRQPERIOD     (1<<21)
+#define S3C2410_SDIDCON_TXAFTERRESP   (1<<20)
+#define S3C2410_SDIDCON_RXAFTERCMD    (1<<19)
+#define S3C2410_SDIDCON_BUSYAFTERCMD  (1<<18)
+#define S3C2410_SDIDCON_BLOCKMODE     (1<<17)
+#define S3C2410_SDIDCON_WIDEBUS       (1<<16)
+#define S3C2410_SDIDCON_DMAEN         (1<<15)
+#define S3C2410_SDIDCON_STOP          (1<<14)
+#define S3C2440_SDIDCON_DATSTART      (1<<14)
+#define S3C2410_SDIDCON_DATMODE	      (3<<12)
+#define S3C2410_SDIDCON_BLKNUM        (0x7ff)
+
+/* constants for S3C2410_SDIDCON_DATMODE */
+#define S3C2410_SDIDCON_XFER_READY    (0<<12)
+#define S3C2410_SDIDCON_XFER_CHKSTART (1<<12)
+#define S3C2410_SDIDCON_XFER_RXSTART  (2<<12)
+#define S3C2410_SDIDCON_XFER_TXSTART  (3<<12)
+
+#define S3C2410_SDIDCON_BLKNUM_MASK   (0xFFF)
+#define S3C2410_SDIDCNT_BLKNUM_SHIFT  (12)
+
+#define S3C2410_SDIDSTA_RDYWAITREQ    (1<<10)
+#define S3C2410_SDIDSTA_SDIOIRQDETECT (1<<9)
+#define S3C2410_SDIDSTA_FIFOFAIL      (1<<8)	/* reserved on 2440 */
+#define S3C2410_SDIDSTA_CRCFAIL       (1<<7)
+#define S3C2410_SDIDSTA_RXCRCFAIL     (1<<6)
+#define S3C2410_SDIDSTA_DATATIMEOUT   (1<<5)
+#define S3C2410_SDIDSTA_XFERFINISH    (1<<4)
+#define S3C2410_SDIDSTA_BUSYFINISH    (1<<3)
+#define S3C2410_SDIDSTA_SBITERR       (1<<2)	/* reserved on 2410a/2440 */
+#define S3C2410_SDIDSTA_TXDATAON      (1<<1)
+#define S3C2410_SDIDSTA_RXDATAON      (1<<0)
+
+#define S3C2440_SDIFSTA_FIFORESET      (1<<16)
+#define S3C2440_SDIFSTA_FIFOFAIL       (3<<14)  /* 3 is correct (2 bits) */
+#define S3C2410_SDIFSTA_TFDET          (1<<13)
+#define S3C2410_SDIFSTA_RFDET          (1<<12)
+#define S3C2410_SDIFSTA_TFHALF         (1<<11)
+#define S3C2410_SDIFSTA_TFEMPTY        (1<<10)
+#define S3C2410_SDIFSTA_RFLAST         (1<<9)
+#define S3C2410_SDIFSTA_RFFULL         (1<<8)
+#define S3C2410_SDIFSTA_RFHALF         (1<<7)
+#define S3C2410_SDIFSTA_COUNTMASK      (0x7f)
+
+#define S3C2410_SDIIMSK_RESPONSECRC    (1<<17)
+#define S3C2410_SDIIMSK_CMDSENT        (1<<16)
+#define S3C2410_SDIIMSK_CMDTIMEOUT     (1<<15)
+#define S3C2410_SDIIMSK_RESPONSEND     (1<<14)
+#define S3C2410_SDIIMSK_READWAIT       (1<<13)
+#define S3C2410_SDIIMSK_SDIOIRQ        (1<<12)
+#define S3C2410_SDIIMSK_FIFOFAIL       (1<<11)
+#define S3C2410_SDIIMSK_CRCSTATUS      (1<<10)
+#define S3C2410_SDIIMSK_DATACRC        (1<<9)
+#define S3C2410_SDIIMSK_DATATIMEOUT    (1<<8)
+#define S3C2410_SDIIMSK_DATAFINISH     (1<<7)
+#define S3C2410_SDIIMSK_BUSYFINISH     (1<<6)
+#define S3C2410_SDIIMSK_SBITERR        (1<<5)	/* reserved 2440/2410a */
+#define S3C2410_SDIIMSK_TXFIFOHALF     (1<<4)
+#define S3C2410_SDIIMSK_TXFIFOEMPTY    (1<<3)
+#define S3C2410_SDIIMSK_RXFIFOLAST     (1<<2)
+#define S3C2410_SDIIMSK_RXFIFOFULL     (1<<1)
+#define S3C2410_SDIIMSK_RXFIFOHALF     (1<<0)
+
+#endif /* __ASM_ARM_REGS_SDI */
diff --git a/include/asm-arm/mach-types.h b/include/asm-arm/mach-types.h
index 7d7888e..4e9c6d9 100644
--- a/include/asm-arm/mach-types.h
+++ b/include/asm-arm/mach-types.h
@@ -424,7 +424,7 @@ #define MACH_TYPE_MT02                 4
 #define MACH_TYPE_MPORT3S              411
 #define MACH_TYPE_RA_ALPHA             412
 #define MACH_TYPE_XCEP                 413
-#define MACH_TYPE_ARCOM_MERCURY        414
+#define MACH_TYPE_ARCOM_VULCAN         414
 #define MACH_TYPE_STARGATE             415
 #define MACH_TYPE_ARMADILLOJ           416
 #define MACH_TYPE_ELROY_JACK           417
@@ -457,7 +457,7 @@ #define MACH_TYPE_ESL_SARVA            4
 #define MACH_TYPE_XM250                444
 #define MACH_TYPE_T6TC1XB              445
 #define MACH_TYPE_ESS710               446
-#define MACH_TYPE_MX3ADS               447
+#define MACH_TYPE_MX31ADS              447
 #define MACH_TYPE_HIMALAYA             448
 #define MACH_TYPE_BOLFENK              449
 #define MACH_TYPE_AT91RM9200KR         450
@@ -736,7 +736,308 @@ #define MACH_TYPE_ADSPORTAL            7
 #define MACH_TYPE_LN2410SBC            725
 #define MACH_TYPE_CB3RUFC              726
 #define MACH_TYPE_MP2USB               727
-#define MACH_TYPE_PDNB3               1002
+#define MACH_TYPE_NTNP425C             728
+#define MACH_TYPE_COLIBRI              729
+#define MACH_TYPE_PCM7220              730
+#define MACH_TYPE_GATEWAY7001          731
+#define MACH_TYPE_PCM027               732
+#define MACH_TYPE_CMPXA                733
+#define MACH_TYPE_ANUBIS               734
+#define MACH_TYPE_ITE8152              735
+#define MACH_TYPE_LPC3XXX              736
+#define MACH_TYPE_PUPPETEER            737
+#define MACH_TYPE_MACH_VADATECH        738
+#define MACH_TYPE_E570                 739
+#define MACH_TYPE_X50                  740
+#define MACH_TYPE_RECON                741
+#define MACH_TYPE_XBOARDGP8            742
+#define MACH_TYPE_FPIC2                743
+#define MACH_TYPE_AKITA                744
+#define MACH_TYPE_A81                  745
+#define MACH_TYPE_SVM_SC25X            746
+#define MACH_TYPE_VADATECH020          747
+#define MACH_TYPE_TLI                  748
+#define MACH_TYPE_EDB9315LC            749
+#define MACH_TYPE_PASSEC               750
+#define MACH_TYPE_DS_TIGER             751
+#define MACH_TYPE_E310                 752
+#define MACH_TYPE_E330                 753
+#define MACH_TYPE_RT3000               754
+#define MACH_TYPE_NOKIA770             755
+#define MACH_TYPE_PNX0106              756
+#define MACH_TYPE_HX21XX               757
+#define MACH_TYPE_FARADAY              758
+#define MACH_TYPE_SBC9312              759
+#define MACH_TYPE_BATMAN               760
+#define MACH_TYPE_JPD201               761
+#define MACH_TYPE_MIPSA                762
+#define MACH_TYPE_KACOM                763
+#define MACH_TYPE_SWARCOCPU            764
+#define MACH_TYPE_SWARCODSL            765
+#define MACH_TYPE_BLUEANGEL            766
+#define MACH_TYPE_HAIRYGRAMA           767
+#define MACH_TYPE_BANFF                768
+#define MACH_TYPE_CARMEVA              769
+#define MACH_TYPE_SAM255               770
+#define MACH_TYPE_PPM10                771
+#define MACH_TYPE_EDB9315A             772
+#define MACH_TYPE_SUNSET               773
+#define MACH_TYPE_STARGATE2            774
+#define MACH_TYPE_INTELMOTE2           775
+#define MACH_TYPE_TRIZEPS4             776
+#define MACH_TYPE_MAINSTONE2           777
+#define MACH_TYPE_EZ_IXP42X            778
+#define MACH_TYPE_TAPWAVE_ZODIAC       779
+#define MACH_TYPE_UNIVERSALMETER       780
+#define MACH_TYPE_HICOARM9             781
+#define MACH_TYPE_PNX4008              782
+#define MACH_TYPE_KWS6000              783
+#define MACH_TYPE_PORTUX920T           784
+#define MACH_TYPE_EZ_X5                785
+#define MACH_TYPE_OMAP_RUDOLPH         786
+#define MACH_TYPE_CPUAT91              787
+#define MACH_TYPE_REA9200              788
+#define MACH_TYPE_ACTS_PUNE_SA1110     789
+#define MACH_TYPE_IXP425               790
+#define MACH_TYPE_ARGONPLUSODYSSEY     791
+#define MACH_TYPE_PERCH                792
+#define MACH_TYPE_EIS05R1              793
+#define MACH_TYPE_PEPPERPAD            794
+#define MACH_TYPE_SB3010               795
+#define MACH_TYPE_RM9200               796
+#define MACH_TYPE_DMA03                797
+#define MACH_TYPE_ROAD_S101            798
+#define MACH_TYPE_IQ_NEXTGEN_A         799
+#define MACH_TYPE_IQ_NEXTGEN_B         800
+#define MACH_TYPE_IQ_NEXTGEN_C         801
+#define MACH_TYPE_IQ_NEXTGEN_D         802
+#define MACH_TYPE_IQ_NEXTGEN_E         803
+#define MACH_TYPE_MALLOW_AT91          804
+#define MACH_TYPE_CYBERTRACKER_I       805
+#define MACH_TYPE_GESBC931X            806
+#define MACH_TYPE_CENTIPAD             807
+#define MACH_TYPE_ARMSOC               808
+#define MACH_TYPE_SE4200               809
+#define MACH_TYPE_EMS197A              810
+#define MACH_TYPE_MICRO9               811
+#define MACH_TYPE_MICRO9L              812
+#define MACH_TYPE_UC5471DSP            813
+#define MACH_TYPE_SJ5471ENG            814
+#define MACH_TYPE_CMPXA26X             815
+#define MACH_TYPE_NC                   816
+#define MACH_TYPE_OMAP_PALMTE          817
+#define MACH_TYPE_AJAX52X              818
+#define MACH_TYPE_SIRIUSTAR            819
+#define MACH_TYPE_IODATA_HDLG          820
+#define MACH_TYPE_AT91RM9200UTL        821
+#define MACH_TYPE_BIOSAFE              822
+#define MACH_TYPE_MP1000               823
+#define MACH_TYPE_PARSY                824
+#define MACH_TYPE_CCXP                 825
+#define MACH_TYPE_OMAP_GSAMPLE         826
+#define MACH_TYPE_REALVIEW_EB          827
+#define MACH_TYPE_SAMOA                828
+#define MACH_TYPE_T3XSCALE             829
+#define MACH_TYPE_I878                 830
+#define MACH_TYPE_BORZOI               831
+#define MACH_TYPE_GECKO                832
+#define MACH_TYPE_DS101                833
+#define MACH_TYPE_OMAP_PALMTT2         834
+#define MACH_TYPE_XSCALE_PALMLD        835
+#define MACH_TYPE_CC9C                 836
+#define MACH_TYPE_SBC1670              837
+#define MACH_TYPE_IXDP28X5             838
+#define MACH_TYPE_OMAP_PALMTT          839
+#define MACH_TYPE_ML696K               840
+#define MACH_TYPE_ARCOM_ZEUS           841
+#define MACH_TYPE_OSIRIS               842
+#define MACH_TYPE_MAESTRO              843
+#define MACH_TYPE_TUNGE2               844
+#define MACH_TYPE_IXBBM                845
+#define MACH_TYPE_MX27                 846
+#define MACH_TYPE_AX8004               847
+#define MACH_TYPE_AT91SAM9261EK        848
+#define MACH_TYPE_LOFT                 849
+#define MACH_TYPE_MAGPIE               850
+#define MACH_TYPE_MX21                 851
+#define MACH_TYPE_MB87M3400            852
+#define MACH_TYPE_MGUARD_DELTA         853
+#define MACH_TYPE_DAVINCI_DVDP         854
+#define MACH_TYPE_HTCUNIVERSAL         855
+#define MACH_TYPE_TPAD                 856
+#define MACH_TYPE_ROVERP3              857
+#define MACH_TYPE_JORNADA928           858
+#define MACH_TYPE_MV88FXX81            859
+#define MACH_TYPE_STMP36XX             860
+#define MACH_TYPE_SXNI79524            861
+#define MACH_TYPE_AMS_DELTA            862
+#define MACH_TYPE_URANIUM              863
+#define MACH_TYPE_UCON                 864
+#define MACH_TYPE_NAS100D              865
+#define MACH_TYPE_L083_1000            866
+#define MACH_TYPE_EZX                  867
+#define MACH_TYPE_PNX5220              868
+#define MACH_TYPE_BUTTE                869
+#define MACH_TYPE_SRM2                 870
+#define MACH_TYPE_DSBR                 871
+#define MACH_TYPE_CRYSTALBALL          872
+#define MACH_TYPE_TINYPXA27X           873
+#define MACH_TYPE_HERBIE               874
+#define MACH_TYPE_MAGICIAN             875
+#define MACH_TYPE_CM4002               876
+#define MACH_TYPE_B4                   877
+#define MACH_TYPE_MAUI                 878
+#define MACH_TYPE_CYBERTRACKER_G       879
+#define MACH_TYPE_NXDKN                880
+#define MACH_TYPE_MIO8390              881
+#define MACH_TYPE_OMI_BOARD            882
+#define MACH_TYPE_MX21CIV              883
+#define MACH_TYPE_MAHI_CDAC            884
+#define MACH_TYPE_XSCALE_PALMTX        885
+#define MACH_TYPE_S3C2413              887
+#define MACH_TYPE_SAMSYS_EP0           888
+#define MACH_TYPE_WG302V1              889
+#define MACH_TYPE_WG302V2              890
+#define MACH_TYPE_EB42X                891
+#define MACH_TYPE_IQ331ES              892
+#define MACH_TYPE_COSYDSP              893
+#define MACH_TYPE_UPLAT7D              894
+#define MACH_TYPE_PTDAVINCI            895
+#define MACH_TYPE_MBUS                 896
+#define MACH_TYPE_NADIA2VB             897
+#define MACH_TYPE_R1000                898
+#define MACH_TYPE_HW90250              899
+#define MACH_TYPE_OMAP_2430SDP         900
+#define MACH_TYPE_DAVINCI_EVM          901
+#define MACH_TYPE_OMAP_TORNADO         902
+#define MACH_TYPE_OLOCREEK             903
+#define MACH_TYPE_PALMZ72              904
+#define MACH_TYPE_NXDB500              905
+#define MACH_TYPE_APF9328              906
+#define MACH_TYPE_OMAP_WIPOQ           907
+#define MACH_TYPE_OMAP_TWIP            908
+#define MACH_TYPE_XSCALE_PALMTREO650   909
+#define MACH_TYPE_ACUMEN               910
+#define MACH_TYPE_XP100                911
+#define MACH_TYPE_FS2410               912
+#define MACH_TYPE_PXA270_CERF          913
+#define MACH_TYPE_SQ2FTLPALM           914
+#define MACH_TYPE_BSEMSERVER           915
+#define MACH_TYPE_NETCLIENT            916
+#define MACH_TYPE_XSCALE_PALMTT5       917
+#define MACH_TYPE_OMAP_PALMTC          918
+#define MACH_TYPE_OMAP_APOLLON         919
+#define MACH_TYPE_ARGONLVEVB           920
+#define MACH_TYPE_REA_2D               921
+#define MACH_TYPE_TI3E524              922
+#define MACH_TYPE_ATEB9200             923
+#define MACH_TYPE_AUCKLAND             924
+#define MACH_TYPE_AK3320M              925
+#define MACH_TYPE_DURAMAX              926
+#define MACH_TYPE_N35                  927
+#define MACH_TYPE_PRONGHORN            928
+#define MACH_TYPE_FUNDY                929
+#define MACH_TYPE_LOGICPD_PXA270       930
+#define MACH_TYPE_CPU777               931
+#define MACH_TYPE_SIMICON9201          932
+#define MACH_TYPE_LEAP2_HPM            933
+#define MACH_TYPE_CM922TXA10           934
+#define MACH_TYPE_PXA                  935
+#define MACH_TYPE_SANDGATE2            936
+#define MACH_TYPE_SANDGATE2G           937
+#define MACH_TYPE_SANDGATE2P           938
+#define MACH_TYPE_FRED_JACK            939
+#define MACH_TYPE_TTG_COLOR1           940
+#define MACH_TYPE_NXEB500HMI           941
+#define MACH_TYPE_NETDCU8              942
+#define MACH_TYPE_ML675050_CPU_BOA     943
+#define MACH_TYPE_NG_FVX538            944
+#define MACH_TYPE_NG_FVS338            945
+#define MACH_TYPE_PNX4103              946
+#define MACH_TYPE_HESDB                947
+#define MACH_TYPE_XSILO                948
+#define MACH_TYPE_ESPRESSO             949
+#define MACH_TYPE_EMLC                 950
+#define MACH_TYPE_SISTERON             951
+#define MACH_TYPE_RX1950               952
+#define MACH_TYPE_TSC_VENUS            953
+#define MACH_TYPE_DS101J               954
+#define MACH_TYPE_MXC30030ADS          955
+#define MACH_TYPE_FUJITSU_WIMAXSOC     956
+#define MACH_TYPE_DUALPCMODEM          957
+#define MACH_TYPE_GESBC9312            958
+#define MACH_TYPE_HTCAPACHE            959
+#define MACH_TYPE_IXDP435              960
+#define MACH_TYPE_CATPROVT100          961
+#define MACH_TYPE_PICOTUX1XX           962
+#define MACH_TYPE_PICOTUX2XX           963
+#define MACH_TYPE_DSMG600              964
+#define MACH_TYPE_EMPC2                965
+#define MACH_TYPE_VENTURA              966
+#define MACH_TYPE_PHIDGET_SBC          967
+#define MACH_TYPE_IJ3K                 968
+#define MACH_TYPE_PISGAH               969
+#define MACH_TYPE_OMAP_FSAMPLE         970
+#define MACH_TYPE_SG720                971
+#define MACH_TYPE_REDFOX               972
+#define MACH_TYPE_MYSH_EP9315_1        973
+#define MACH_TYPE_TPF106               974
+#define MACH_TYPE_AT91RM9200KG         975
+#define MACH_TYPE_SLEDB                976
+#define MACH_TYPE_ONTRACK              977
+#define MACH_TYPE_PM1200               978
+#define MACH_TYPE_ESS24XXX             979
+#define MACH_TYPE_COREMP7              980
+#define MACH_TYPE_NEXCODER_6446        981
+#define MACH_TYPE_STVC8380             982
+#define MACH_TYPE_TEKLYNX              983
+#define MACH_TYPE_CARBONADO            984
+#define MACH_TYPE_SYSMOS_MP730         985
+#define MACH_TYPE_SNAPPER_CL15         986
+#define MACH_TYPE_PGIGIM               987
+#define MACH_TYPE_PTX9160P2            988
+#define MACH_TYPE_DCORE1               989
+#define MACH_TYPE_VICTORPXA            990
+#define MACH_TYPE_MX2DTB               991
+#define MACH_TYPE_PXA_IREX_ER0100      992
+#define MACH_TYPE_OMAP_PALMZ71         993
+#define MACH_TYPE_BARTEC_DEG           994
+#define MACH_TYPE_HW50251              995
+#define MACH_TYPE_IBOX                 996
+#define MACH_TYPE_ATLASLH7A404         997
+#define MACH_TYPE_PT2026               998
+#define MACH_TYPE_HTCALPINE            999
+#define MACH_TYPE_BARTEC_VTU           1000
+#define MACH_TYPE_VCOREII              1001
+#define MACH_TYPE_PDNB3                1002
+#define MACH_TYPE_HTCBEETLES           1003
+#define MACH_TYPE_S3C6400              1004
+#define MACH_TYPE_S3C2443              1005
+#define MACH_TYPE_OMAP_LDK             1006
+#define MACH_TYPE_SMDK2460             1007
+#define MACH_TYPE_SMDK2440             1008
+#define MACH_TYPE_SMDK2412             1009
+#define MACH_TYPE_WEBBOX               1010
+#define MACH_TYPE_CWWNDP               1011
+#define MACH_TYPE_DRAGON               1012
+#define MACH_TYPE_OPENDO_CPU_BOARD     1013
+#define MACH_TYPE_CCM2200              1014
+#define MACH_TYPE_ETWARM               1015
+#define MACH_TYPE_M93030               1016
+#define MACH_TYPE_CC7U                 1017
+#define MACH_TYPE_MTT_RANGER           1018
+#define MACH_TYPE_NEXUS                1019
+#define MACH_TYPE_DESMAN               1020
+#define MACH_TYPE_BKDE303              1021
+#define MACH_TYPE_SMDK2413             1022
+#define MACH_TYPE_AML_M7200            1023
+#define MACH_TYPE_AML_M5900            1024
+#define MACH_TYPE_SG640                1025
+#define MACH_TYPE_EDG79524             1026
+#define MACH_TYPE_AI2410               1027
+#define MACH_TYPE_IXP465               1028
+#define MACH_TYPE_BALLOON3             1029
+#define MACH_TYPE_QT2410               1108
 
 #ifdef CONFIG_ARCH_EBSA110
 # ifdef machine_arch_type
@@ -3541,9 +3842,9 @@ #  define machine_arch_type	__machine_ar
 # else
 #  define machine_arch_type	MACH_TYPE_RAMSES
 # endif
-# define machine_is_ramses()	(machine_arch_type == MACH_TYPE_RAMSES)
+# define machine_is_mnci()	(machine_arch_type == MACH_TYPE_RAMSES)
 #else
-# define machine_is_ramses()	(0)
+# define machine_is_mnci()	(0)
 #endif
 
 #ifdef CONFIG_ARCH_S28X
@@ -4501,9 +4802,9 @@ #  define machine_arch_type	__machine_ar
 # else
 #  define machine_arch_type	MACH_TYPE_M825XX
 # endif
-# define machine_is_m825xx()	(machine_arch_type == MACH_TYPE_M825XX)
+# define machine_is_comcerto()	(machine_arch_type == MACH_TYPE_M825XX)
 #else
-# define machine_is_m825xx()	(0)
+# define machine_is_comcerto()	(0)
 #endif
 
 #ifdef CONFIG_SA1100_M7100
@@ -5658,16 +5959,16 @@ #else
 # define machine_is_xcep()	(0)
 #endif
 
-#ifdef CONFIG_MACH_ARCOM_MERCURY
+#ifdef CONFIG_MACH_ARCOM_VULCAN
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_ARCOM_MERCURY
+#  define machine_arch_type	MACH_TYPE_ARCOM_VULCAN
 # endif
-# define machine_is_arcom_mercury()	(machine_arch_type == MACH_TYPE_ARCOM_MERCURY)
+# define machine_is_arcom_vulcan()	(machine_arch_type == MACH_TYPE_ARCOM_VULCAN)
 #else
-# define machine_is_arcom_mercury()	(0)
+# define machine_is_arcom_vulcan()	(0)
 #endif
 
 #ifdef CONFIG_MACH_STARGATE
@@ -6054,16 +6355,16 @@ #else
 # define machine_is_ess710()	(0)
 #endif
 
-#ifdef CONFIG_MACH_MX3ADS
+#ifdef CONFIG_MACH_MX31ADS
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_MX3ADS
+#  define machine_arch_type	MACH_TYPE_MX31ADS
 # endif
-# define machine_is_mx3ads()	(machine_arch_type == MACH_TYPE_MX3ADS)
+# define machine_is_mx31ads()	(machine_arch_type == MACH_TYPE_MX31ADS)
 #else
-# define machine_is_mx3ads()	(0)
+# define machine_is_mx31ads()	(0)
 #endif
 
 #ifdef CONFIG_MACH_HIMALAYA
@@ -7333,9 +7634,9 @@ #  define machine_arch_type	__machine_ar
 # else
 #  define machine_arch_type	MACH_TYPE_ARGONPLUSEVB
 # endif
-# define machine_is_argonplusevb()	(machine_arch_type == MACH_TYPE_ARGONPLUSEVB)
+# define machine_is_i30030evb()	(machine_arch_type == MACH_TYPE_ARGONPLUSEVB)
 #else
-# define machine_is_argonplusevb()	(0)
+# define machine_is_i30030evb()	(0)
 #endif
 
 #ifdef CONFIG_MACH_SCMA11EVB
@@ -7345,9 +7646,9 @@ #  define machine_arch_type	__machine_ar
 # else
 #  define machine_arch_type	MACH_TYPE_SCMA11EVB
 # endif
-# define machine_is_scma11evb()	(machine_arch_type == MACH_TYPE_SCMA11EVB)
+# define machine_is_mxc27530evb()	(machine_arch_type == MACH_TYPE_SCMA11EVB)
 #else
-# define machine_is_scma11evb()	(0)
+# define machine_is_mxc27530evb()	(0)
 #endif
 
 #ifdef CONFIG_MACH_SMDK2800
@@ -8305,9 +8606,9 @@ #  define machine_arch_type	__machine_ar
 # else
 #  define machine_arch_type	MACH_TYPE_SCMA11BB
 # endif
-# define machine_is_scma11bb()	(machine_arch_type == MACH_TYPE_SCMA11BB)
+# define machine_is_mxc27530ads()	(machine_arch_type == MACH_TYPE_SCMA11BB)
 #else
-# define machine_is_scma11bb()	(0)
+# define machine_is_mxc27530ads()	(0)
 #endif
 
 #ifdef CONFIG_MACH_TRIZEPS3
@@ -9193,9 +9494,9 @@ #  define machine_arch_type	__machine_ar
 # else
 #  define machine_arch_type	MACH_TYPE_ZEUSEVB
 # endif
-# define machine_is_zeusevb()	(machine_arch_type == MACH_TYPE_ZEUSEVB)
+# define machine_is_mxc91131evb()	(machine_arch_type == MACH_TYPE_ZEUSEVB)
 #else
-# define machine_is_zeusevb()	(0)
+# define machine_is_mxc91131evb()	(0)
 #endif
 
 #ifdef CONFIG_MACH_P700
@@ -9402,6 +9703,3630 @@ #else
 # define machine_is_mp2usb()	(0)
 #endif
 
+#ifdef CONFIG_MACH_NTNP425C
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NTNP425C
+# endif
+# define machine_is_ntnp425c()	(machine_arch_type == MACH_TYPE_NTNP425C)
+#else
+# define machine_is_ntnp425c()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI
+# endif
+# define machine_is_colibri()	(machine_arch_type == MACH_TYPE_COLIBRI)
+#else
+# define machine_is_colibri()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM7220
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM7220
+# endif
+# define machine_is_pcm7220()	(machine_arch_type == MACH_TYPE_PCM7220)
+#else
+# define machine_is_pcm7220()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GATEWAY7001
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GATEWAY7001
+# endif
+# define machine_is_gateway7001()	(machine_arch_type == MACH_TYPE_GATEWAY7001)
+#else
+# define machine_is_gateway7001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM027
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM027
+# endif
+# define machine_is_pcm027()	(machine_arch_type == MACH_TYPE_PCM027)
+#else
+# define machine_is_pcm027()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CMPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CMPXA
+# endif
+# define machine_is_cmpxa()	(machine_arch_type == MACH_TYPE_CMPXA)
+#else
+# define machine_is_cmpxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANUBIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANUBIS
+# endif
+# define machine_is_anubis()	(machine_arch_type == MACH_TYPE_ANUBIS)
+#else
+# define machine_is_anubis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ITE8152
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ITE8152
+# endif
+# define machine_is_ite8152()	(machine_arch_type == MACH_TYPE_ITE8152)
+#else
+# define machine_is_ite8152()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPC3XXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPC3XXX
+# endif
+# define machine_is_lpc3xxx()	(machine_arch_type == MACH_TYPE_LPC3XXX)
+#else
+# define machine_is_lpc3xxx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PUPPETEER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PUPPETEER
+# endif
+# define machine_is_puppeteer()	(machine_arch_type == MACH_TYPE_PUPPETEER)
+#else
+# define machine_is_puppeteer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MACH_VADATECH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACH_VADATECH
+# endif
+# define machine_is_vt001()	(machine_arch_type == MACH_TYPE_MACH_VADATECH)
+#else
+# define machine_is_vt001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E570
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E570
+# endif
+# define machine_is_e570()	(machine_arch_type == MACH_TYPE_E570)
+#else
+# define machine_is_e570()	(0)
+#endif
+
+#ifdef CONFIG_MACH_X50
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_X50
+# endif
+# define machine_is_x50()	(machine_arch_type == MACH_TYPE_X50)
+#else
+# define machine_is_x50()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RECON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RECON
+# endif
+# define machine_is_recon()	(machine_arch_type == MACH_TYPE_RECON)
+#else
+# define machine_is_recon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XBOARDGP8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XBOARDGP8
+# endif
+# define machine_is_xboardgp8()	(machine_arch_type == MACH_TYPE_XBOARDGP8)
+#else
+# define machine_is_xboardgp8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FPIC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FPIC2
+# endif
+# define machine_is_fpic2()	(machine_arch_type == MACH_TYPE_FPIC2)
+#else
+# define machine_is_fpic2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AKITA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AKITA
+# endif
+# define machine_is_akita()	(machine_arch_type == MACH_TYPE_AKITA)
+#else
+# define machine_is_akita()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A81
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A81
+# endif
+# define machine_is_a81()	(machine_arch_type == MACH_TYPE_A81)
+#else
+# define machine_is_a81()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SVM_SC25X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVM_SC25X
+# endif
+# define machine_is_svm_sc25x()	(machine_arch_type == MACH_TYPE_SVM_SC25X)
+#else
+# define machine_is_svm_sc25x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VADATECH020
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VADATECH020
+# endif
+# define machine_is_vt020()	(machine_arch_type == MACH_TYPE_VADATECH020)
+#else
+# define machine_is_vt020()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TLI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TLI
+# endif
+# define machine_is_tli()	(machine_arch_type == MACH_TYPE_TLI)
+#else
+# define machine_is_tli()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9315LC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9315LC
+# endif
+# define machine_is_edb9315lc()	(machine_arch_type == MACH_TYPE_EDB9315LC)
+#else
+# define machine_is_edb9315lc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PASSEC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PASSEC
+# endif
+# define machine_is_passec()	(machine_arch_type == MACH_TYPE_PASSEC)
+#else
+# define machine_is_passec()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DS_TIGER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DS_TIGER
+# endif
+# define machine_is_ds_tiger()	(machine_arch_type == MACH_TYPE_DS_TIGER)
+#else
+# define machine_is_ds_tiger()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E310
+# endif
+# define machine_is_e310()	(machine_arch_type == MACH_TYPE_E310)
+#else
+# define machine_is_e310()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E330
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E330
+# endif
+# define machine_is_e330()	(machine_arch_type == MACH_TYPE_E330)
+#else
+# define machine_is_e330()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RT3000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RT3000
+# endif
+# define machine_is_rt3000()	(machine_arch_type == MACH_TYPE_RT3000)
+#else
+# define machine_is_rt3000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA770
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA770
+# endif
+# define machine_is_nokia770()	(machine_arch_type == MACH_TYPE_NOKIA770)
+#else
+# define machine_is_nokia770()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX0106
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX0106
+# endif
+# define machine_is_pnx0106()	(machine_arch_type == MACH_TYPE_PNX0106)
+#else
+# define machine_is_pnx0106()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HX21XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HX21XX
+# endif
+# define machine_is_hx21xx()	(machine_arch_type == MACH_TYPE_HX21XX)
+#else
+# define machine_is_hx21xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FARADAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FARADAY
+# endif
+# define machine_is_faraday()	(machine_arch_type == MACH_TYPE_FARADAY)
+#else
+# define machine_is_faraday()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC9312
+# endif
+# define machine_is_sbc9312()	(machine_arch_type == MACH_TYPE_SBC9312)
+#else
+# define machine_is_sbc9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BATMAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BATMAN
+# endif
+# define machine_is_batman()	(machine_arch_type == MACH_TYPE_BATMAN)
+#else
+# define machine_is_batman()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JPD201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JPD201
+# endif
+# define machine_is_jpd201()	(machine_arch_type == MACH_TYPE_JPD201)
+#else
+# define machine_is_jpd201()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIPSA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIPSA
+# endif
+# define machine_is_mipsa()	(machine_arch_type == MACH_TYPE_MIPSA)
+#else
+# define machine_is_mipsa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KACOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KACOM
+# endif
+# define machine_is_kacom()	(machine_arch_type == MACH_TYPE_KACOM)
+#else
+# define machine_is_kacom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWARCOCPU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWARCOCPU
+# endif
+# define machine_is_swarcocpu()	(machine_arch_type == MACH_TYPE_SWARCOCPU)
+#else
+# define machine_is_swarcocpu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWARCODSL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWARCODSL
+# endif
+# define machine_is_swarcodsl()	(machine_arch_type == MACH_TYPE_SWARCODSL)
+#else
+# define machine_is_swarcodsl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLUEANGEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUEANGEL
+# endif
+# define machine_is_blueangel()	(machine_arch_type == MACH_TYPE_BLUEANGEL)
+#else
+# define machine_is_blueangel()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HAIRYGRAMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HAIRYGRAMA
+# endif
+# define machine_is_hairygrama()	(machine_arch_type == MACH_TYPE_HAIRYGRAMA)
+#else
+# define machine_is_hairygrama()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BANFF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BANFF
+# endif
+# define machine_is_banff()	(machine_arch_type == MACH_TYPE_BANFF)
+#else
+# define machine_is_banff()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARMEVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARMEVA
+# endif
+# define machine_is_carmeva()	(machine_arch_type == MACH_TYPE_CARMEVA)
+#else
+# define machine_is_carmeva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAM255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM255
+# endif
+# define machine_is_sam255()	(machine_arch_type == MACH_TYPE_SAM255)
+#else
+# define machine_is_sam255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PPM10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PPM10
+# endif
+# define machine_is_ppm10()	(machine_arch_type == MACH_TYPE_PPM10)
+#else
+# define machine_is_ppm10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9315A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9315A
+# endif
+# define machine_is_edb9315a()	(machine_arch_type == MACH_TYPE_EDB9315A)
+#else
+# define machine_is_edb9315a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SUNSET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SUNSET
+# endif
+# define machine_is_sunset()	(machine_arch_type == MACH_TYPE_SUNSET)
+#else
+# define machine_is_sunset()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STARGATE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STARGATE2
+# endif
+# define machine_is_stargate2()	(machine_arch_type == MACH_TYPE_STARGATE2)
+#else
+# define machine_is_stargate2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INTELMOTE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INTELMOTE2
+# endif
+# define machine_is_intelmote2()	(machine_arch_type == MACH_TYPE_INTELMOTE2)
+#else
+# define machine_is_intelmote2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIZEPS4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS4
+# endif
+# define machine_is_trizeps4()	(machine_arch_type == MACH_TYPE_TRIZEPS4)
+#else
+# define machine_is_trizeps4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAINSTONE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAINSTONE2
+# endif
+# define machine_is_mainstone2()	(machine_arch_type == MACH_TYPE_MAINSTONE2)
+#else
+# define machine_is_mainstone2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_IXP42X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_IXP42X
+# endif
+# define machine_is_ez_ixp42x()	(machine_arch_type == MACH_TYPE_EZ_IXP42X)
+#else
+# define machine_is_ez_ixp42x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAPWAVE_ZODIAC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAPWAVE_ZODIAC
+# endif
+# define machine_is_tapwave_zodiac()	(machine_arch_type == MACH_TYPE_TAPWAVE_ZODIAC)
+#else
+# define machine_is_tapwave_zodiac()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNIVERSALMETER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNIVERSALMETER
+# endif
+# define machine_is_universalmeter()	(machine_arch_type == MACH_TYPE_UNIVERSALMETER)
+#else
+# define machine_is_universalmeter()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HICOARM9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HICOARM9
+# endif
+# define machine_is_hicoarm9()	(machine_arch_type == MACH_TYPE_HICOARM9)
+#else
+# define machine_is_hicoarm9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX4008
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX4008
+# endif
+# define machine_is_pnx4008()	(machine_arch_type == MACH_TYPE_PNX4008)
+#else
+# define machine_is_pnx4008()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KWS6000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KWS6000
+# endif
+# define machine_is_kws6000()	(machine_arch_type == MACH_TYPE_KWS6000)
+#else
+# define machine_is_kws6000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PORTUX920T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PORTUX920T
+# endif
+# define machine_is_portux920t()	(machine_arch_type == MACH_TYPE_PORTUX920T)
+#else
+# define machine_is_portux920t()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_X5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_X5
+# endif
+# define machine_is_ez_x5()	(machine_arch_type == MACH_TYPE_EZ_X5)
+#else
+# define machine_is_ez_x5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_RUDOLPH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_RUDOLPH
+# endif
+# define machine_is_omap_rudolph()	(machine_arch_type == MACH_TYPE_OMAP_RUDOLPH)
+#else
+# define machine_is_omap_rudolph()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUAT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUAT91
+# endif
+# define machine_is_cpuat91()	(machine_arch_type == MACH_TYPE_CPUAT91)
+#else
+# define machine_is_cpuat91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REA9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REA9200
+# endif
+# define machine_is_rea9200()	(machine_arch_type == MACH_TYPE_REA9200)
+#else
+# define machine_is_rea9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACTS_PUNE_SA1110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACTS_PUNE_SA1110
+# endif
+# define machine_is_acts_pune_sa1110()	(machine_arch_type == MACH_TYPE_ACTS_PUNE_SA1110)
+#else
+# define machine_is_acts_pune_sa1110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXP425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP425
+# endif
+# define machine_is_ixp425()	(machine_arch_type == MACH_TYPE_IXP425)
+#else
+# define machine_is_ixp425()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARGONPLUSODYSSEY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARGONPLUSODYSSEY
+# endif
+# define machine_is_i30030ads()	(machine_arch_type == MACH_TYPE_ARGONPLUSODYSSEY)
+#else
+# define machine_is_i30030ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PERCH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PERCH
+# endif
+# define machine_is_perch()	(machine_arch_type == MACH_TYPE_PERCH)
+#else
+# define machine_is_perch()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EIS05R1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EIS05R1
+# endif
+# define machine_is_eis05r1()	(machine_arch_type == MACH_TYPE_EIS05R1)
+#else
+# define machine_is_eis05r1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PEPPERPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PEPPERPAD
+# endif
+# define machine_is_pepperpad()	(machine_arch_type == MACH_TYPE_PEPPERPAD)
+#else
+# define machine_is_pepperpad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SB3010
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SB3010
+# endif
+# define machine_is_sb3010()	(machine_arch_type == MACH_TYPE_SB3010)
+#else
+# define machine_is_sb3010()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RM9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RM9200
+# endif
+# define machine_is_rm9200()	(machine_arch_type == MACH_TYPE_RM9200)
+#else
+# define machine_is_rm9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DMA03
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DMA03
+# endif
+# define machine_is_dma03()	(machine_arch_type == MACH_TYPE_DMA03)
+#else
+# define machine_is_dma03()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROAD_S101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROAD_S101
+# endif
+# define machine_is_road_s101()	(machine_arch_type == MACH_TYPE_ROAD_S101)
+#else
+# define machine_is_road_s101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ_NEXTGEN_A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ_NEXTGEN_A
+# endif
+# define machine_is_iq_nextgen_a()	(machine_arch_type == MACH_TYPE_IQ_NEXTGEN_A)
+#else
+# define machine_is_iq_nextgen_a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ_NEXTGEN_B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ_NEXTGEN_B
+# endif
+# define machine_is_iq_nextgen_b()	(machine_arch_type == MACH_TYPE_IQ_NEXTGEN_B)
+#else
+# define machine_is_iq_nextgen_b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ_NEXTGEN_C
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ_NEXTGEN_C
+# endif
+# define machine_is_iq_nextgen_c()	(machine_arch_type == MACH_TYPE_IQ_NEXTGEN_C)
+#else
+# define machine_is_iq_nextgen_c()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ_NEXTGEN_D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ_NEXTGEN_D
+# endif
+# define machine_is_iq_nextgen_d()	(machine_arch_type == MACH_TYPE_IQ_NEXTGEN_D)
+#else
+# define machine_is_iq_nextgen_d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ_NEXTGEN_E
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ_NEXTGEN_E
+# endif
+# define machine_is_iq_nextgen_e()	(machine_arch_type == MACH_TYPE_IQ_NEXTGEN_E)
+#else
+# define machine_is_iq_nextgen_e()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MALLOW_AT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MALLOW_AT91
+# endif
+# define machine_is_mallow_at91()	(machine_arch_type == MACH_TYPE_MALLOW_AT91)
+#else
+# define machine_is_mallow_at91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CYBERTRACKER_I
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CYBERTRACKER_I
+# endif
+# define machine_is_cybertracker_i()	(machine_arch_type == MACH_TYPE_CYBERTRACKER_I)
+#else
+# define machine_is_cybertracker_i()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GESBC931X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GESBC931X
+# endif
+# define machine_is_gesbc931x()	(machine_arch_type == MACH_TYPE_GESBC931X)
+#else
+# define machine_is_gesbc931x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CENTIPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CENTIPAD
+# endif
+# define machine_is_centipad()	(machine_arch_type == MACH_TYPE_CENTIPAD)
+#else
+# define machine_is_centipad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMSOC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMSOC
+# endif
+# define machine_is_armsoc()	(machine_arch_type == MACH_TYPE_ARMSOC)
+#else
+# define machine_is_armsoc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SE4200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SE4200
+# endif
+# define machine_is_se4200()	(machine_arch_type == MACH_TYPE_SE4200)
+#else
+# define machine_is_se4200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMS197A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMS197A
+# endif
+# define machine_is_ems197a()	(machine_arch_type == MACH_TYPE_EMS197A)
+#else
+# define machine_is_ems197a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9
+# endif
+# define machine_is_micro9()	(machine_arch_type == MACH_TYPE_MICRO9)
+#else
+# define machine_is_micro9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9L
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9L
+# endif
+# define machine_is_micro9l()	(machine_arch_type == MACH_TYPE_MICRO9L)
+#else
+# define machine_is_micro9l()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UC5471DSP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UC5471DSP
+# endif
+# define machine_is_uc5471dsp()	(machine_arch_type == MACH_TYPE_UC5471DSP)
+#else
+# define machine_is_uc5471dsp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SJ5471ENG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SJ5471ENG
+# endif
+# define machine_is_sj5471eng()	(machine_arch_type == MACH_TYPE_SJ5471ENG)
+#else
+# define machine_is_sj5471eng()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CMPXA26X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CMPXA26X
+# endif
+# define machine_is_none()	(machine_arch_type == MACH_TYPE_CMPXA26X)
+#else
+# define machine_is_none()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NC
+# endif
+# define machine_is_nc1()	(machine_arch_type == MACH_TYPE_NC)
+#else
+# define machine_is_nc1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTE
+# endif
+# define machine_is_omap_palmte()	(machine_arch_type == MACH_TYPE_OMAP_PALMTE)
+#else
+# define machine_is_omap_palmte()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AJAX52X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AJAX52X
+# endif
+# define machine_is_ajax52x()	(machine_arch_type == MACH_TYPE_AJAX52X)
+#else
+# define machine_is_ajax52x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIRIUSTAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIRIUSTAR
+# endif
+# define machine_is_siriustar()	(machine_arch_type == MACH_TYPE_SIRIUSTAR)
+#else
+# define machine_is_siriustar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IODATA_HDLG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IODATA_HDLG
+# endif
+# define machine_is_iodata_hdlg()	(machine_arch_type == MACH_TYPE_IODATA_HDLG)
+#else
+# define machine_is_iodata_hdlg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200UTL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200UTL
+# endif
+# define machine_is_at91rm9200utl()	(machine_arch_type == MACH_TYPE_AT91RM9200UTL)
+#else
+# define machine_is_at91rm9200utl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIOSAFE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIOSAFE
+# endif
+# define machine_is_biosafe()	(machine_arch_type == MACH_TYPE_BIOSAFE)
+#else
+# define machine_is_biosafe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MP1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MP1000
+# endif
+# define machine_is_mp1000()	(machine_arch_type == MACH_TYPE_MP1000)
+#else
+# define machine_is_mp1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PARSY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PARSY
+# endif
+# define machine_is_parsy()	(machine_arch_type == MACH_TYPE_PARSY)
+#else
+# define machine_is_parsy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCXP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCXP
+# endif
+# define machine_is_ccxp270()	(machine_arch_type == MACH_TYPE_CCXP)
+#else
+# define machine_is_ccxp270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_GSAMPLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_GSAMPLE
+# endif
+# define machine_is_omap_gsample()	(machine_arch_type == MACH_TYPE_OMAP_GSAMPLE)
+#else
+# define machine_is_omap_gsample()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_EB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_EB
+# endif
+# define machine_is_realview_eb()	(machine_arch_type == MACH_TYPE_REALVIEW_EB)
+#else
+# define machine_is_realview_eb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAMOA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAMOA
+# endif
+# define machine_is_samoa()	(machine_arch_type == MACH_TYPE_SAMOA)
+#else
+# define machine_is_samoa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T3XSCALE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T3XSCALE
+# endif
+# define machine_is_t3xscale()	(machine_arch_type == MACH_TYPE_T3XSCALE)
+#else
+# define machine_is_t3xscale()	(0)
+#endif
+
+#ifdef CONFIG_MACH_I878
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I878
+# endif
+# define machine_is_i878()	(machine_arch_type == MACH_TYPE_I878)
+#else
+# define machine_is_i878()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BORZOI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BORZOI
+# endif
+# define machine_is_borzoi()	(machine_arch_type == MACH_TYPE_BORZOI)
+#else
+# define machine_is_borzoi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GECKO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GECKO
+# endif
+# define machine_is_gecko()	(machine_arch_type == MACH_TYPE_GECKO)
+#else
+# define machine_is_gecko()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DS101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DS101
+# endif
+# define machine_is_ds101()	(machine_arch_type == MACH_TYPE_DS101)
+#else
+# define machine_is_ds101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTT2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTT2
+# endif
+# define machine_is_omap_palmtt2()	(machine_arch_type == MACH_TYPE_OMAP_PALMTT2)
+#else
+# define machine_is_omap_palmtt2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSCALE_PALMLD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSCALE_PALMLD
+# endif
+# define machine_is_xscale_palmld()	(machine_arch_type == MACH_TYPE_XSCALE_PALMLD)
+#else
+# define machine_is_xscale_palmld()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9C
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9C
+# endif
+# define machine_is_cc9c()	(machine_arch_type == MACH_TYPE_CC9C)
+#else
+# define machine_is_cc9c()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC1670
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC1670
+# endif
+# define machine_is_sbc1670()	(machine_arch_type == MACH_TYPE_SBC1670)
+#else
+# define machine_is_sbc1670()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP28X5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP28X5
+# endif
+# define machine_is_ixdp28x5()	(machine_arch_type == MACH_TYPE_IXDP28X5)
+#else
+# define machine_is_ixdp28x5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTT
+# endif
+# define machine_is_omap_palmtt()	(machine_arch_type == MACH_TYPE_OMAP_PALMTT)
+#else
+# define machine_is_omap_palmtt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ML696K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ML696K
+# endif
+# define machine_is_ml696k()	(machine_arch_type == MACH_TYPE_ML696K)
+#else
+# define machine_is_ml696k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCOM_ZEUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCOM_ZEUS
+# endif
+# define machine_is_arcom_zeus()	(machine_arch_type == MACH_TYPE_ARCOM_ZEUS)
+#else
+# define machine_is_arcom_zeus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSIRIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSIRIS
+# endif
+# define machine_is_osiris()	(machine_arch_type == MACH_TYPE_OSIRIS)
+#else
+# define machine_is_osiris()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAESTRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAESTRO
+# endif
+# define machine_is_maestro()	(machine_arch_type == MACH_TYPE_MAESTRO)
+#else
+# define machine_is_maestro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TUNGE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TUNGE2
+# endif
+# define machine_is_tunge2()	(machine_arch_type == MACH_TYPE_TUNGE2)
+#else
+# define machine_is_tunge2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXBBM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXBBM
+# endif
+# define machine_is_ixbbm()	(machine_arch_type == MACH_TYPE_IXBBM)
+#else
+# define machine_is_ixbbm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27
+# endif
+# define machine_is_mx27ads()	(machine_arch_type == MACH_TYPE_MX27)
+#else
+# define machine_is_mx27ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AX8004
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AX8004
+# endif
+# define machine_is_ax8004()	(machine_arch_type == MACH_TYPE_AX8004)
+#else
+# define machine_is_ax8004()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9261EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9261EK
+# endif
+# define machine_is_at91sam9261ek()	(machine_arch_type == MACH_TYPE_AT91SAM9261EK)
+#else
+# define machine_is_at91sam9261ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOFT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOFT
+# endif
+# define machine_is_loft()	(machine_arch_type == MACH_TYPE_LOFT)
+#else
+# define machine_is_loft()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGPIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGPIE
+# endif
+# define machine_is_magpie()	(machine_arch_type == MACH_TYPE_MAGPIE)
+#else
+# define machine_is_magpie()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX21
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX21
+# endif
+# define machine_is_mx21ads()	(machine_arch_type == MACH_TYPE_MX21)
+#else
+# define machine_is_mx21ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB87M3400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB87M3400
+# endif
+# define machine_is_mb87m3400()	(machine_arch_type == MACH_TYPE_MB87M3400)
+#else
+# define machine_is_mb87m3400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MGUARD_DELTA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MGUARD_DELTA
+# endif
+# define machine_is_mguard_delta()	(machine_arch_type == MACH_TYPE_MGUARD_DELTA)
+#else
+# define machine_is_mguard_delta()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DVDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DVDP
+# endif
+# define machine_is_davinci_dvdp()	(machine_arch_type == MACH_TYPE_DAVINCI_DVDP)
+#else
+# define machine_is_davinci_dvdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCUNIVERSAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCUNIVERSAL
+# endif
+# define machine_is_htcuniversal()	(machine_arch_type == MACH_TYPE_HTCUNIVERSAL)
+#else
+# define machine_is_htcuniversal()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPAD
+# endif
+# define machine_is_tpad()	(machine_arch_type == MACH_TYPE_TPAD)
+#else
+# define machine_is_tpad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERP3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERP3
+# endif
+# define machine_is_roverp3()	(machine_arch_type == MACH_TYPE_ROVERP3)
+#else
+# define machine_is_roverp3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JORNADA928
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JORNADA928
+# endif
+# define machine_is_jornada928()	(machine_arch_type == MACH_TYPE_JORNADA928)
+#else
+# define machine_is_jornada928()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV88FXX81
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV88FXX81
+# endif
+# define machine_is_mv88fxx81()	(machine_arch_type == MACH_TYPE_MV88FXX81)
+#else
+# define machine_is_mv88fxx81()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STMP36XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STMP36XX
+# endif
+# define machine_is_stmp36xx()	(machine_arch_type == MACH_TYPE_STMP36XX)
+#else
+# define machine_is_stmp36xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SXNI79524
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SXNI79524
+# endif
+# define machine_is_sxni79524()	(machine_arch_type == MACH_TYPE_SXNI79524)
+#else
+# define machine_is_sxni79524()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMS_DELTA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMS_DELTA
+# endif
+# define machine_is_ams_delta()	(machine_arch_type == MACH_TYPE_AMS_DELTA)
+#else
+# define machine_is_ams_delta()	(0)
+#endif
+
+#ifdef CONFIG_MACH_URANIUM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_URANIUM
+# endif
+# define machine_is_uranium()	(machine_arch_type == MACH_TYPE_URANIUM)
+#else
+# define machine_is_uranium()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UCON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UCON
+# endif
+# define machine_is_ucon()	(machine_arch_type == MACH_TYPE_UCON)
+#else
+# define machine_is_ucon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAS100D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAS100D
+# endif
+# define machine_is_nas100d()	(machine_arch_type == MACH_TYPE_NAS100D)
+#else
+# define machine_is_nas100d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_L083_1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_L083_1000
+# endif
+# define machine_is_l083()	(machine_arch_type == MACH_TYPE_L083_1000)
+#else
+# define machine_is_l083()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX
+# endif
+# define machine_is_ezx()	(machine_arch_type == MACH_TYPE_EZX)
+#else
+# define machine_is_ezx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX5220
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX5220
+# endif
+# define machine_is_pnx5220()	(machine_arch_type == MACH_TYPE_PNX5220)
+#else
+# define machine_is_pnx5220()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BUTTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUTTE
+# endif
+# define machine_is_butte()	(machine_arch_type == MACH_TYPE_BUTTE)
+#else
+# define machine_is_butte()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SRM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SRM2
+# endif
+# define machine_is_srm2()	(machine_arch_type == MACH_TYPE_SRM2)
+#else
+# define machine_is_srm2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSBR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSBR
+# endif
+# define machine_is_dsbr()	(machine_arch_type == MACH_TYPE_DSBR)
+#else
+# define machine_is_dsbr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CRYSTALBALL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CRYSTALBALL
+# endif
+# define machine_is_crystalball()	(machine_arch_type == MACH_TYPE_CRYSTALBALL)
+#else
+# define machine_is_crystalball()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TINYPXA27X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TINYPXA27X
+# endif
+# define machine_is_tinypxa27x()	(machine_arch_type == MACH_TYPE_TINYPXA27X)
+#else
+# define machine_is_tinypxa27x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HERBIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HERBIE
+# endif
+# define machine_is_herbie()	(machine_arch_type == MACH_TYPE_HERBIE)
+#else
+# define machine_is_herbie()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGICIAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGICIAN
+# endif
+# define machine_is_magician()	(machine_arch_type == MACH_TYPE_MAGICIAN)
+#else
+# define machine_is_magician()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM4002
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM4002
+# endif
+# define machine_is_cm4002()	(machine_arch_type == MACH_TYPE_CM4002)
+#else
+# define machine_is_cm4002()	(0)
+#endif
+
+#ifdef CONFIG_MACH_B4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_B4
+# endif
+# define machine_is_b4()	(machine_arch_type == MACH_TYPE_B4)
+#else
+# define machine_is_b4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAUI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAUI
+# endif
+# define machine_is_maui()	(machine_arch_type == MACH_TYPE_MAUI)
+#else
+# define machine_is_maui()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CYBERTRACKER_G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CYBERTRACKER_G
+# endif
+# define machine_is_cybertracker_g()	(machine_arch_type == MACH_TYPE_CYBERTRACKER_G)
+#else
+# define machine_is_cybertracker_g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXDKN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXDKN
+# endif
+# define machine_is_nxdkn()	(machine_arch_type == MACH_TYPE_NXDKN)
+#else
+# define machine_is_nxdkn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIO8390
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIO8390
+# endif
+# define machine_is_mio8390()	(machine_arch_type == MACH_TYPE_MIO8390)
+#else
+# define machine_is_mio8390()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMI_BOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMI_BOARD
+# endif
+# define machine_is_omi_board()	(machine_arch_type == MACH_TYPE_OMI_BOARD)
+#else
+# define machine_is_omi_board()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX21CIV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX21CIV
+# endif
+# define machine_is_mx21civ()	(machine_arch_type == MACH_TYPE_MX21CIV)
+#else
+# define machine_is_mx21civ()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAHI_CDAC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAHI_CDAC
+# endif
+# define machine_is_mahi_cdac()	(machine_arch_type == MACH_TYPE_MAHI_CDAC)
+#else
+# define machine_is_mahi_cdac()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSCALE_PALMTX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSCALE_PALMTX
+# endif
+# define machine_is_xscale_palmtx()	(machine_arch_type == MACH_TYPE_XSCALE_PALMTX)
+#else
+# define machine_is_xscale_palmtx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2413
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2413
+# endif
+# define machine_is_s3c2413()	(machine_arch_type == MACH_TYPE_S3C2413)
+#else
+# define machine_is_s3c2413()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAMSYS_EP0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAMSYS_EP0
+# endif
+# define machine_is_samsys_ep0()	(machine_arch_type == MACH_TYPE_SAMSYS_EP0)
+#else
+# define machine_is_samsys_ep0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WG302V1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WG302V1
+# endif
+# define machine_is_wg302v1()	(machine_arch_type == MACH_TYPE_WG302V1)
+#else
+# define machine_is_wg302v1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WG302V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WG302V2
+# endif
+# define machine_is_wg302v2()	(machine_arch_type == MACH_TYPE_WG302V2)
+#else
+# define machine_is_wg302v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EB42X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EB42X
+# endif
+# define machine_is_eb42x()	(machine_arch_type == MACH_TYPE_EB42X)
+#else
+# define machine_is_eb42x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ331ES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ331ES
+# endif
+# define machine_is_iq331es()	(machine_arch_type == MACH_TYPE_IQ331ES)
+#else
+# define machine_is_iq331es()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COSYDSP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COSYDSP
+# endif
+# define machine_is_cosydsp()	(machine_arch_type == MACH_TYPE_COSYDSP)
+#else
+# define machine_is_cosydsp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UPLAT7D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UPLAT7D
+# endif
+# define machine_is_uplat7d_proto()	(machine_arch_type == MACH_TYPE_UPLAT7D)
+#else
+# define machine_is_uplat7d_proto()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PTDAVINCI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PTDAVINCI
+# endif
+# define machine_is_ptdavinci()	(machine_arch_type == MACH_TYPE_PTDAVINCI)
+#else
+# define machine_is_ptdavinci()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MBUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MBUS
+# endif
+# define machine_is_mbus()	(machine_arch_type == MACH_TYPE_MBUS)
+#else
+# define machine_is_mbus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NADIA2VB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NADIA2VB
+# endif
+# define machine_is_nadia2vb()	(machine_arch_type == MACH_TYPE_NADIA2VB)
+#else
+# define machine_is_nadia2vb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_R1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_R1000
+# endif
+# define machine_is_r1000()	(machine_arch_type == MACH_TYPE_R1000)
+#else
+# define machine_is_r1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW90250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW90250
+# endif
+# define machine_is_hw90250()	(machine_arch_type == MACH_TYPE_HW90250)
+#else
+# define machine_is_hw90250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_2430SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_2430SDP
+# endif
+# define machine_is_omap_2430sdp()	(machine_arch_type == MACH_TYPE_OMAP_2430SDP)
+#else
+# define machine_is_omap_2430sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_EVM
+# endif
+# define machine_is_davinci_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_EVM)
+#else
+# define machine_is_davinci_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_TORNADO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_TORNADO
+# endif
+# define machine_is_omap_tornado()	(machine_arch_type == MACH_TYPE_OMAP_TORNADO)
+#else
+# define machine_is_omap_tornado()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OLOCREEK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OLOCREEK
+# endif
+# define machine_is_olocreek()	(machine_arch_type == MACH_TYPE_OLOCREEK)
+#else
+# define machine_is_olocreek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMZ72
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMZ72
+# endif
+# define machine_is_palmz72()	(machine_arch_type == MACH_TYPE_PALMZ72)
+#else
+# define machine_is_palmz72()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXDB500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXDB500
+# endif
+# define machine_is_nxdb500()	(machine_arch_type == MACH_TYPE_NXDB500)
+#else
+# define machine_is_nxdb500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APF9328
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APF9328
+# endif
+# define machine_is_apf9328()	(machine_arch_type == MACH_TYPE_APF9328)
+#else
+# define machine_is_apf9328()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_WIPOQ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_WIPOQ
+# endif
+# define machine_is_omap_wipoq()	(machine_arch_type == MACH_TYPE_OMAP_WIPOQ)
+#else
+# define machine_is_omap_wipoq()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_TWIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_TWIP
+# endif
+# define machine_is_omap_twip()	(machine_arch_type == MACH_TYPE_OMAP_TWIP)
+#else
+# define machine_is_omap_twip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSCALE_PALMTREO650
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSCALE_PALMTREO650
+# endif
+# define machine_is_xscale_treo650()	(machine_arch_type == MACH_TYPE_XSCALE_PALMTREO650)
+#else
+# define machine_is_xscale_treo650()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACUMEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACUMEN
+# endif
+# define machine_is_acumen()	(machine_arch_type == MACH_TYPE_ACUMEN)
+#else
+# define machine_is_acumen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XP100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XP100
+# endif
+# define machine_is_xp100()	(machine_arch_type == MACH_TYPE_XP100)
+#else
+# define machine_is_xp100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FS2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FS2410
+# endif
+# define machine_is_fs2410()	(machine_arch_type == MACH_TYPE_FS2410)
+#else
+# define machine_is_fs2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA270_CERF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA270_CERF
+# endif
+# define machine_is_pxa270_cerf()	(machine_arch_type == MACH_TYPE_PXA270_CERF)
+#else
+# define machine_is_pxa270_cerf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SQ2FTLPALM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SQ2FTLPALM
+# endif
+# define machine_is_sq2ftlpalm()	(machine_arch_type == MACH_TYPE_SQ2FTLPALM)
+#else
+# define machine_is_sq2ftlpalm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BSEMSERVER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BSEMSERVER
+# endif
+# define machine_is_bsemserver()	(machine_arch_type == MACH_TYPE_BSEMSERVER)
+#else
+# define machine_is_bsemserver()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETCLIENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETCLIENT
+# endif
+# define machine_is_netclient()	(machine_arch_type == MACH_TYPE_NETCLIENT)
+#else
+# define machine_is_netclient()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSCALE_PALMTT5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSCALE_PALMTT5
+# endif
+# define machine_is_xscale_palmtt5()	(machine_arch_type == MACH_TYPE_XSCALE_PALMTT5)
+#else
+# define machine_is_xscale_palmtt5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTC
+# endif
+# define machine_is_xscale_palmtc()	(machine_arch_type == MACH_TYPE_OMAP_PALMTC)
+#else
+# define machine_is_xscale_palmtc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_APOLLON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_APOLLON
+# endif
+# define machine_is_omap_apollon()	(machine_arch_type == MACH_TYPE_OMAP_APOLLON)
+#else
+# define machine_is_omap_apollon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARGONLVEVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARGONLVEVB
+# endif
+# define machine_is_mxc30030evb()	(machine_arch_type == MACH_TYPE_ARGONLVEVB)
+#else
+# define machine_is_mxc30030evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REA_2D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REA_2D
+# endif
+# define machine_is_rea_2d()	(machine_arch_type == MACH_TYPE_REA_2D)
+#else
+# define machine_is_rea_2d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TI3E524
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TI3E524
+# endif
+# define machine_is_eti3e524()	(machine_arch_type == MACH_TYPE_TI3E524)
+#else
+# define machine_is_eti3e524()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATEB9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATEB9200
+# endif
+# define machine_is_ateb9200()	(machine_arch_type == MACH_TYPE_ATEB9200)
+#else
+# define machine_is_ateb9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AUCKLAND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AUCKLAND
+# endif
+# define machine_is_auckland()	(machine_arch_type == MACH_TYPE_AUCKLAND)
+#else
+# define machine_is_auckland()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AK3320M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AK3320M
+# endif
+# define machine_is_ak3220m()	(machine_arch_type == MACH_TYPE_AK3320M)
+#else
+# define machine_is_ak3220m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DURAMAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DURAMAX
+# endif
+# define machine_is_duramax()	(machine_arch_type == MACH_TYPE_DURAMAX)
+#else
+# define machine_is_duramax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N35
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N35
+# endif
+# define machine_is_n35()	(machine_arch_type == MACH_TYPE_N35)
+#else
+# define machine_is_n35()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRONGHORN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRONGHORN
+# endif
+# define machine_is_pronghorn()	(machine_arch_type == MACH_TYPE_PRONGHORN)
+#else
+# define machine_is_pronghorn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FUNDY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FUNDY
+# endif
+# define machine_is_fundy()	(machine_arch_type == MACH_TYPE_FUNDY)
+#else
+# define machine_is_fundy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOGICPD_PXA270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOGICPD_PXA270
+# endif
+# define machine_is_logicpd_pxa270()	(machine_arch_type == MACH_TYPE_LOGICPD_PXA270)
+#else
+# define machine_is_logicpd_pxa270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPU777
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPU777
+# endif
+# define machine_is_cpu777()	(machine_arch_type == MACH_TYPE_CPU777)
+#else
+# define machine_is_cpu777()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIMICON9201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMICON9201
+# endif
+# define machine_is_simicon9201()	(machine_arch_type == MACH_TYPE_SIMICON9201)
+#else
+# define machine_is_simicon9201()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEAP2_HPM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEAP2_HPM
+# endif
+# define machine_is_leap2_hpm()	(machine_arch_type == MACH_TYPE_LEAP2_HPM)
+#else
+# define machine_is_leap2_hpm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM922TXA10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM922TXA10
+# endif
+# define machine_is_cm922txa10()	(machine_arch_type == MACH_TYPE_CM922TXA10)
+#else
+# define machine_is_cm922txa10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA
+# endif
+# define machine_is_sandgate()	(machine_arch_type == MACH_TYPE_PXA)
+#else
+# define machine_is_sandgate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANDGATE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANDGATE2
+# endif
+# define machine_is_sandgate2()	(machine_arch_type == MACH_TYPE_SANDGATE2)
+#else
+# define machine_is_sandgate2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANDGATE2G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANDGATE2G
+# endif
+# define machine_is_sandgate2g()	(machine_arch_type == MACH_TYPE_SANDGATE2G)
+#else
+# define machine_is_sandgate2g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANDGATE2P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANDGATE2P
+# endif
+# define machine_is_sandgate2p()	(machine_arch_type == MACH_TYPE_SANDGATE2P)
+#else
+# define machine_is_sandgate2p()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FRED_JACK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FRED_JACK
+# endif
+# define machine_is_fred_jack()	(machine_arch_type == MACH_TYPE_FRED_JACK)
+#else
+# define machine_is_fred_jack()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TTG_COLOR1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TTG_COLOR1
+# endif
+# define machine_is_ttg_color1()	(machine_arch_type == MACH_TYPE_TTG_COLOR1)
+#else
+# define machine_is_ttg_color1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXEB500HMI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXEB500HMI
+# endif
+# define machine_is_nxeb500hmi()	(machine_arch_type == MACH_TYPE_NXEB500HMI)
+#else
+# define machine_is_nxeb500hmi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETDCU8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETDCU8
+# endif
+# define machine_is_netdcu8()	(machine_arch_type == MACH_TYPE_NETDCU8)
+#else
+# define machine_is_netdcu8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ML675050_CPU_BOA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ML675050_CPU_BOA
+# endif
+# define machine_is_ml675050_cpu_boa()	(machine_arch_type == MACH_TYPE_ML675050_CPU_BOA)
+#else
+# define machine_is_ml675050_cpu_boa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NG_FVX538
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NG_FVX538
+# endif
+# define machine_is_ng_fvx538()	(machine_arch_type == MACH_TYPE_NG_FVX538)
+#else
+# define machine_is_ng_fvx538()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NG_FVS338
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NG_FVS338
+# endif
+# define machine_is_ng_fvs338()	(machine_arch_type == MACH_TYPE_NG_FVS338)
+#else
+# define machine_is_ng_fvs338()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX4103
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX4103
+# endif
+# define machine_is_pnx4103()	(machine_arch_type == MACH_TYPE_PNX4103)
+#else
+# define machine_is_pnx4103()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HESDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HESDB
+# endif
+# define machine_is_hesdb()	(machine_arch_type == MACH_TYPE_HESDB)
+#else
+# define machine_is_hesdb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSILO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSILO
+# endif
+# define machine_is_xsilo()	(machine_arch_type == MACH_TYPE_XSILO)
+#else
+# define machine_is_xsilo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESPRESSO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESPRESSO
+# endif
+# define machine_is_espresso()	(machine_arch_type == MACH_TYPE_ESPRESSO)
+#else
+# define machine_is_espresso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMLC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMLC
+# endif
+# define machine_is_emlc()	(machine_arch_type == MACH_TYPE_EMLC)
+#else
+# define machine_is_emlc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SISTERON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SISTERON
+# endif
+# define machine_is_sisteron()	(machine_arch_type == MACH_TYPE_SISTERON)
+#else
+# define machine_is_sisteron()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RX1950
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RX1950
+# endif
+# define machine_is_rx1950()	(machine_arch_type == MACH_TYPE_RX1950)
+#else
+# define machine_is_rx1950()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TSC_VENUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TSC_VENUS
+# endif
+# define machine_is_tsc_venus()	(machine_arch_type == MACH_TYPE_TSC_VENUS)
+#else
+# define machine_is_tsc_venus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DS101J
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DS101J
+# endif
+# define machine_is_ds101j()	(machine_arch_type == MACH_TYPE_DS101J)
+#else
+# define machine_is_ds101j()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC30030ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC30030ADS
+# endif
+# define machine_is_mxc30030ads()	(machine_arch_type == MACH_TYPE_MXC30030ADS)
+#else
+# define machine_is_mxc30030ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FUJITSU_WIMAXSOC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FUJITSU_WIMAXSOC
+# endif
+# define machine_is_fujitsu_wimaxsoc()	(machine_arch_type == MACH_TYPE_FUJITSU_WIMAXSOC)
+#else
+# define machine_is_fujitsu_wimaxsoc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DUALPCMODEM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DUALPCMODEM
+# endif
+# define machine_is_dualpcmodem()	(machine_arch_type == MACH_TYPE_DUALPCMODEM)
+#else
+# define machine_is_dualpcmodem()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GESBC9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GESBC9312
+# endif
+# define machine_is_gesbc9312()	(machine_arch_type == MACH_TYPE_GESBC9312)
+#else
+# define machine_is_gesbc9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCAPACHE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCAPACHE
+# endif
+# define machine_is_htcapache()	(machine_arch_type == MACH_TYPE_HTCAPACHE)
+#else
+# define machine_is_htcapache()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP435
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP435
+# endif
+# define machine_is_ixdp435()	(machine_arch_type == MACH_TYPE_IXDP435)
+#else
+# define machine_is_ixdp435()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CATPROVT100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CATPROVT100
+# endif
+# define machine_is_catprovt100()	(machine_arch_type == MACH_TYPE_CATPROVT100)
+#else
+# define machine_is_catprovt100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOTUX1XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOTUX1XX
+# endif
+# define machine_is_picotux1xx()	(machine_arch_type == MACH_TYPE_PICOTUX1XX)
+#else
+# define machine_is_picotux1xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOTUX2XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOTUX2XX
+# endif
+# define machine_is_picotux2xx()	(machine_arch_type == MACH_TYPE_PICOTUX2XX)
+#else
+# define machine_is_picotux2xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSMG600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSMG600
+# endif
+# define machine_is_dsmg600()	(machine_arch_type == MACH_TYPE_DSMG600)
+#else
+# define machine_is_dsmg600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPC2
+# endif
+# define machine_is_empc2()	(machine_arch_type == MACH_TYPE_EMPC2)
+#else
+# define machine_is_empc2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VENTURA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VENTURA
+# endif
+# define machine_is_ventura()	(machine_arch_type == MACH_TYPE_VENTURA)
+#else
+# define machine_is_ventura()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHIDGET_SBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHIDGET_SBC
+# endif
+# define machine_is_phidget_sbc()	(machine_arch_type == MACH_TYPE_PHIDGET_SBC)
+#else
+# define machine_is_phidget_sbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IJ3K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IJ3K
+# endif
+# define machine_is_ij3k()	(machine_arch_type == MACH_TYPE_IJ3K)
+#else
+# define machine_is_ij3k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PISGAH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PISGAH
+# endif
+# define machine_is_pisgah()	(machine_arch_type == MACH_TYPE_PISGAH)
+#else
+# define machine_is_pisgah()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_FSAMPLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_FSAMPLE
+# endif
+# define machine_is_omap_fsample()	(machine_arch_type == MACH_TYPE_OMAP_FSAMPLE)
+#else
+# define machine_is_omap_fsample()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG720
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG720
+# endif
+# define machine_is_sg720()	(machine_arch_type == MACH_TYPE_SG720)
+#else
+# define machine_is_sg720()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REDFOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REDFOX
+# endif
+# define machine_is_redfox()	(machine_arch_type == MACH_TYPE_REDFOX)
+#else
+# define machine_is_redfox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MYSH_EP9315_1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MYSH_EP9315_1
+# endif
+# define machine_is_mysh_ep9315_1()	(machine_arch_type == MACH_TYPE_MYSH_EP9315_1)
+#else
+# define machine_is_mysh_ep9315_1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPF106
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPF106
+# endif
+# define machine_is_tpf106()	(machine_arch_type == MACH_TYPE_TPF106)
+#else
+# define machine_is_tpf106()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200KG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200KG
+# endif
+# define machine_is_at91rm9200kg()	(machine_arch_type == MACH_TYPE_AT91RM9200KG)
+#else
+# define machine_is_at91rm9200kg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SLEDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SLEDB
+# endif
+# define machine_is_racemt2()	(machine_arch_type == MACH_TYPE_SLEDB)
+#else
+# define machine_is_racemt2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ONTRACK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ONTRACK
+# endif
+# define machine_is_ontrack()	(machine_arch_type == MACH_TYPE_ONTRACK)
+#else
+# define machine_is_ontrack()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PM1200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PM1200
+# endif
+# define machine_is_pm1200()	(machine_arch_type == MACH_TYPE_PM1200)
+#else
+# define machine_is_pm1200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESS24XXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESS24XXX
+# endif
+# define machine_is_ess24562()	(machine_arch_type == MACH_TYPE_ESS24XXX)
+#else
+# define machine_is_ess24562()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COREMP7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COREMP7
+# endif
+# define machine_is_coremp7()	(machine_arch_type == MACH_TYPE_COREMP7)
+#else
+# define machine_is_coremp7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEXCODER_6446
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXCODER_6446
+# endif
+# define machine_is_nexcoder_6446()	(machine_arch_type == MACH_TYPE_NEXCODER_6446)
+#else
+# define machine_is_nexcoder_6446()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STVC8380
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STVC8380
+# endif
+# define machine_is_stvc8380()	(machine_arch_type == MACH_TYPE_STVC8380)
+#else
+# define machine_is_stvc8380()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEKLYNX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEKLYNX
+# endif
+# define machine_is_teklynx()	(machine_arch_type == MACH_TYPE_TEKLYNX)
+#else
+# define machine_is_teklynx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARBONADO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARBONADO
+# endif
+# define machine_is_carbonado()	(machine_arch_type == MACH_TYPE_CARBONADO)
+#else
+# define machine_is_carbonado()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SYSMOS_MP730
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYSMOS_MP730
+# endif
+# define machine_is_sysmos_mp730()	(machine_arch_type == MACH_TYPE_SYSMOS_MP730)
+#else
+# define machine_is_sysmos_mp730()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPER_CL15
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPER_CL15
+# endif
+# define machine_is_snapper_cl15()	(machine_arch_type == MACH_TYPE_SNAPPER_CL15)
+#else
+# define machine_is_snapper_cl15()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PGIGIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PGIGIM
+# endif
+# define machine_is_pgigim()	(machine_arch_type == MACH_TYPE_PGIGIM)
+#else
+# define machine_is_pgigim()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PTX9160P2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PTX9160P2
+# endif
+# define machine_is_ptx9160p2()	(machine_arch_type == MACH_TYPE_PTX9160P2)
+#else
+# define machine_is_ptx9160p2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DCORE1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DCORE1
+# endif
+# define machine_is_dcore1()	(machine_arch_type == MACH_TYPE_DCORE1)
+#else
+# define machine_is_dcore1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VICTORPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VICTORPXA
+# endif
+# define machine_is_victorpxa()	(machine_arch_type == MACH_TYPE_VICTORPXA)
+#else
+# define machine_is_victorpxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX2DTB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX2DTB
+# endif
+# define machine_is_mx2dtb()	(machine_arch_type == MACH_TYPE_MX2DTB)
+#else
+# define machine_is_mx2dtb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_IREX_ER0100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_IREX_ER0100
+# endif
+# define machine_is_pxa_irex_er0100()	(machine_arch_type == MACH_TYPE_PXA_IREX_ER0100)
+#else
+# define machine_is_pxa_irex_er0100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMZ71
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMZ71
+# endif
+# define machine_is_omap_palmz71()	(machine_arch_type == MACH_TYPE_OMAP_PALMZ71)
+#else
+# define machine_is_omap_palmz71()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BARTEC_DEG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BARTEC_DEG
+# endif
+# define machine_is_bartec_deg()	(machine_arch_type == MACH_TYPE_BARTEC_DEG)
+#else
+# define machine_is_bartec_deg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW50251
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW50251
+# endif
+# define machine_is_hw50251()	(machine_arch_type == MACH_TYPE_HW50251)
+#else
+# define machine_is_hw50251()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IBOX
+# endif
+# define machine_is_ibox()	(machine_arch_type == MACH_TYPE_IBOX)
+#else
+# define machine_is_ibox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATLASLH7A404
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATLASLH7A404
+# endif
+# define machine_is_atlaslh7a404()	(machine_arch_type == MACH_TYPE_ATLASLH7A404)
+#else
+# define machine_is_atlaslh7a404()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PT2026
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PT2026
+# endif
+# define machine_is_pt2026()	(machine_arch_type == MACH_TYPE_PT2026)
+#else
+# define machine_is_pt2026()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCALPINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCALPINE
+# endif
+# define machine_is_htcalpine()	(machine_arch_type == MACH_TYPE_HTCALPINE)
+#else
+# define machine_is_htcalpine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BARTEC_VTU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BARTEC_VTU
+# endif
+# define machine_is_bartec_vtu()	(machine_arch_type == MACH_TYPE_BARTEC_VTU)
+#else
+# define machine_is_bartec_vtu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VCOREII
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VCOREII
+# endif
+# define machine_is_vcoreii()	(machine_arch_type == MACH_TYPE_VCOREII)
+#else
+# define machine_is_vcoreii()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PDNB3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PDNB3
+# endif
+# define machine_is_pdnb3()	(machine_arch_type == MACH_TYPE_PDNB3)
+#else
+# define machine_is_pdnb3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCBEETLES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCBEETLES
+# endif
+# define machine_is_htcbeetles()	(machine_arch_type == MACH_TYPE_HTCBEETLES)
+#else
+# define machine_is_htcbeetles()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C6400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C6400
+# endif
+# define machine_is_s3c6400()	(machine_arch_type == MACH_TYPE_S3C6400)
+#else
+# define machine_is_s3c6400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2443
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2443
+# endif
+# define machine_is_s3c2443()	(machine_arch_type == MACH_TYPE_S3C2443)
+#else
+# define machine_is_s3c2443()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_LDK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_LDK
+# endif
+# define machine_is_omap_ldk()	(machine_arch_type == MACH_TYPE_OMAP_LDK)
+#else
+# define machine_is_omap_ldk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2460
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2460
+# endif
+# define machine_is_smdk2460()	(machine_arch_type == MACH_TYPE_SMDK2460)
+#else
+# define machine_is_smdk2460()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2440
+# endif
+# define machine_is_smdk2440()	(machine_arch_type == MACH_TYPE_SMDK2440)
+#else
+# define machine_is_smdk2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2412
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2412
+# endif
+# define machine_is_smdk2412()	(machine_arch_type == MACH_TYPE_SMDK2412)
+#else
+# define machine_is_smdk2412()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WEBBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEBBOX
+# endif
+# define machine_is_webbox()	(machine_arch_type == MACH_TYPE_WEBBOX)
+#else
+# define machine_is_webbox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWWNDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWWNDP
+# endif
+# define machine_is_cwwndp()	(machine_arch_type == MACH_TYPE_CWWNDP)
+#else
+# define machine_is_cwwndp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DRAGON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DRAGON
+# endif
+# define machine_is_dragon()	(machine_arch_type == MACH_TYPE_DRAGON)
+#else
+# define machine_is_dragon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENDO_CPU_BOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENDO_CPU_BOARD
+# endif
+# define machine_is_opendo_cpu_board()	(machine_arch_type == MACH_TYPE_OPENDO_CPU_BOARD)
+#else
+# define machine_is_opendo_cpu_board()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCM2200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCM2200
+# endif
+# define machine_is_ccm2200()	(machine_arch_type == MACH_TYPE_CCM2200)
+#else
+# define machine_is_ccm2200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETWARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETWARM
+# endif
+# define machine_is_etwarm()	(machine_arch_type == MACH_TYPE_ETWARM)
+#else
+# define machine_is_etwarm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_M93030
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M93030
+# endif
+# define machine_is_m93030()	(machine_arch_type == MACH_TYPE_M93030)
+#else
+# define machine_is_m93030()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC7U
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC7U
+# endif
+# define machine_is_cc7u()	(machine_arch_type == MACH_TYPE_CC7U)
+#else
+# define machine_is_cc7u()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MTT_RANGER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MTT_RANGER
+# endif
+# define machine_is_mtt_ranger()	(machine_arch_type == MACH_TYPE_MTT_RANGER)
+#else
+# define machine_is_mtt_ranger()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEXUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXUS
+# endif
+# define machine_is_nexus()	(machine_arch_type == MACH_TYPE_NEXUS)
+#else
+# define machine_is_nexus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DESMAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DESMAN
+# endif
+# define machine_is_desman()	(machine_arch_type == MACH_TYPE_DESMAN)
+#else
+# define machine_is_desman()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BKDE303
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BKDE303
+# endif
+# define machine_is_bkde303()	(machine_arch_type == MACH_TYPE_BKDE303)
+#else
+# define machine_is_bkde303()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2413
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2413
+# endif
+# define machine_is_smdk2413()	(machine_arch_type == MACH_TYPE_SMDK2413)
+#else
+# define machine_is_smdk2413()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AML_M7200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AML_M7200
+# endif
+# define machine_is_aml_m7200()	(machine_arch_type == MACH_TYPE_AML_M7200)
+#else
+# define machine_is_aml_m7200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AML_M5900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AML_M5900
+# endif
+# define machine_is_aml_m5900()	(machine_arch_type == MACH_TYPE_AML_M5900)
+#else
+# define machine_is_aml_m5900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG640
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG640
+# endif
+# define machine_is_sg640()	(machine_arch_type == MACH_TYPE_SG640)
+#else
+# define machine_is_sg640()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDG79524
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDG79524
+# endif
+# define machine_is_edg79524()	(machine_arch_type == MACH_TYPE_EDG79524)
+#else
+# define machine_is_edg79524()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AI2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AI2410
+# endif
+# define machine_is_ai2410()	(machine_arch_type == MACH_TYPE_AI2410)
+#else
+# define machine_is_ai2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXP465
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP465
+# endif
+# define machine_is_ixp465()	(machine_arch_type == MACH_TYPE_IXP465)
+#else
+# define machine_is_ixp465()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BALLOON3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BALLOON3
+# endif
+# define machine_is_balloon3()	(machine_arch_type == MACH_TYPE_BALLOON3)
+#else
+# define machine_is_balloon3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QT2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QT2410
+# endif
+# define machine_is_qt2410()	(machine_arch_type == MACH_TYPE_QT2410)
+#else
+# define machine_is_qt2410()	(0)
+#endif
+
 /*
  * These have not yet been registered
  */
diff --git a/include/configs/qt2410.h b/include/configs/qt2410.h
new file mode 100644
index 0000000..627f365
--- /dev/null
+++ b/include/configs/qt2410.h
@@ -0,0 +1,256 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ * Gary Jennejohn <gj@denx.de>
+ * David Mueller <d.mueller@elsoft.ch>
+ *
+ * Configuation settings for the SAMSUNG SMDK2410 board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#if 0
+/* If we want to start u-boot from usb bootloader in NOR flash */
+#define CONFIG_SKIP_RELOCATE_UBOOT	1
+#define	CONFIG_SKIP_LOWLEVEL_INIT	1
+#else
+/* If we want to start u-boot directly from within NAND flash */
+#define CONFIG_S3C2410_NAND_BOOT	1
+#endif
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_ARM920T		1	/* This is an ARM920T Core	*/
+#define	CONFIG_S3C2410		1	/* in a SAMSUNG S3C2410 SoC     */
+#define CONFIG_SMDK2410		1	/* on a SAMSUNG SMDK2410 Board  */
+
+/* input clock of PLL */
+#define CONFIG_SYS_CLK_FREQ	12000000/* the SMDK2410 has 12MHz input clock */
+
+
+#define USE_920T_MMU		1
+#define CONFIG_USE_IRQ		1
+//#undef CONFIG_USE_IRQ			/* we don't need IRQ/FIQ stuff */
+
+/*
+ * Size of malloc() pool
+ */
+#define CFG_MALLOC_LEN		(CFG_ENV_SIZE + 128*1024)
+#define CFG_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Hardware drivers
+ */
+#define CONFIG_DRIVER_CS8900	1	/* we have a CS8900 on-board */
+#define CS8900_BASE		0x19000300
+#define CS8900_BUS16		1 /* the Linux driver does accesses as shorts */
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_SERIAL1          1	/* we use SERIAL 1 on SMDK2410 */
+#define CONFIG_HWFLOW		1
+
+/************************************************************
+ * RTC
+ ************************************************************/
+#define	CONFIG_RTC_S3C24X0	1
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_BAUDRATE		115200
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+#define CONFIG_COMMANDS \
+			(CONFIG_CMD_DFL	 | \
+			CFG_CMD_BSP	 | \
+			CFG_CMD_CACHE	 | \
+			CFG_CMD_DATE	 | \
+			CFG_CMD_DHCP	 | \
+			CFG_CMD_DIAG	 | \
+			CFG_CMD_ELF	 | \
+			CFG_CMD_EXT2	 | \
+			CFG_CMD_FAT	 | \
+			CFG_CMD_HWFLOW	 | \
+			/* CFG_CMD_IDE	 | */ \
+			/* CFG_CMD_IRQ	 | */ \
+			CFG_CMD_JFFS2	 | \
+			CFG_CMD_MMC	 | \
+			CFG_CMD_NAND	 | \
+			CFG_CMD_PING	 | \
+			CFG_CMD_PORTIO	 | \
+			CFG_CMD_REGINFO  | \
+			CFG_CMD_SAVES	 | \
+			CFG_CMD_USB)
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTARGS    	"root=/dev/sda1 console=ttySAC0,115200 loglevel=8 rootdelay=10"
+/*#define CONFIG_ETHADDR	08:00:3e:26:0a:5b */
+#define CONFIG_NETMASK          255.255.255.0
+#define CONFIG_IPADDR		10.0.0.110
+#define CONFIG_SERVERIP		10.0.0.1
+/*#define CONFIG_BOOTFILE	"elinos-lart" */
+#define CONFIG_BOOTCOMMAND	"mmcinit; ext2load mmc 0 0x32000000 uImage; bootm 0x32000000"
+
+#define CONFIG_DOS_PARTITION	1
+
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200		/* speed to run kgdb serial port */
+/* what's this ? it's not used anywhere */
+#define CONFIG_KGDB_SER_INDEX	1		/* which serial port to use */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory		*/
+#define	CFG_PROMPT		"QT2410 # "	/* Monitor Command Prompt	*/
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_BARGSIZE		CFG_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CFG_MEMTEST_START	0x30000000	/* memtest works on	*/
+#define CFG_MEMTEST_END		0x33F00000	/* 63 MB in DRAM	*/
+
+#undef  CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define	CFG_LOAD_ADDR		0x33000000	/* default load address	*/
+
+/* the PWM TImer 4 uses a counter of 15625 for 10 ms, so we need */
+/* it to wrap 100 times (total 1562500) to get 1 sec. */
+#define	CFG_HZ			1562500
+
+/* valid baudrates */
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+/* IDE/ATA config */
+
+#if 0
+#define CFG_IDE_MAXBUS		1
+#define CFG_IDE_MAXDEVICE	2
+#define CFG_IDE_PREINIT		0
+
+#define CFG_ATA_BASE_ADDR	
+#endif
+
+#define CONFIG_USB_OHCI		1
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   /* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x30000000 /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x04000000 /* 64 MB */
+#define PHYS_SDRAM_RES_SIZE	0x00200000 /* 2 MB for frame buffer */
+
+#define PHYS_FLASH_1		0x00000000 /* Flash Bank #1 */
+
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+
+#define CONFIG_AMD_LV400	1	/* uncomment this if you have a LV400 flash */
+#if 0
+#define CONFIG_AMD_LV800	1	/* uncomment this if you have a LV800 flash */
+#endif
+
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#ifdef CONFIG_AMD_LV800
+#define PHYS_FLASH_SIZE		0x00100000 /* 1MB */
+#define CFG_MAX_FLASH_SECT	(19)	/* max number of sectors on one chip */
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + 0x0F0000) /* addr of environment */
+#endif
+#ifdef CONFIG_AMD_LV400
+#define PHYS_FLASH_SIZE		0x00080000 /* 512KB */
+#define CFG_MAX_FLASH_SECT	(11)	/* max number of sectors on one chip */
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + 0x070000) /* addr of environment */
+#endif
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(5*CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(5*CFG_HZ) /* Timeout for Flash Write */
+
+#define	CFG_ENV_IS_IN_NAND	1
+#define CFG_ENV_SIZE		0x4000		/* 16k Total Size of Environment Sector */
+#define CFG_ENV_OFFSET		0x30000		/* environment after bootloader */
+
+#define NAND_MAX_CHIPS		1
+#define CFG_NAND_BASE		0x4e000000
+#define CFG_MAX_NAND_DEVICE	1
+
+#define CONFIG_MMC		1
+#define CFG_MMC_BASE		0xff000000
+
+#define CONFIG_EXT2		1
+
+/* FAT driver in u-boot is broken currently */
+#define CONFIG_FAT		1
+#define CONFIG_SUPPORT_VFAT
+
+/* ATAG configuration */
+#define CONFIG_INITRD_TAG		1
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_CMDLINE_TAG		1
+#if 0
+#define CONFIG_SERIAL_TAG		1
+#define CONFIG_REVISION_TAG		1
+#endif
+
+
+#if 0
+#define CONFIG_VIDEO
+#define CONFIG_VIDEO_S3C2410
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+
+#define VIDEO_KBD_INIT_FCT	0
+#define VIDEO_TSTC_FCT		serial_tstc
+#define VIDEO_GETC_FCT		serial_getc
+
+#define LCD_VIDEO_ADDR		0x33d00000
+#endif
+
+#endif	/* __CONFIG_H */
diff --git a/include/s3c2410.h b/include/s3c2410.h
index 86495f6..913521d 100644
--- a/include/s3c2410.h
+++ b/include/s3c2410.h
@@ -38,12 +38,6 @@ #define S3C24X0_SPI_CHANNELS	2
 #define S3C2410_ECCSIZE		512
 #define S3C2410_ECCBYTES	3
 
-typedef enum {
-	S3C24X0_UART0,
-	S3C24X0_UART1,
-	S3C24X0_UART2
-} S3C24X0_UARTS_NR;
-
 /* S3C2410 device base addresses */
 #define S3C24X0_MEMCTL_BASE		0x48000000
 #define S3C24X0_USB_HOST_BASE		0x49000000
@@ -65,9 +59,23 @@ #define S3C24X0_SPI_BASE		0x59000000
 #define S3C2410_SDI_BASE		0x5A000000
 
 
+#define oNFCONF			0x00
+#define oNFCMD			0x04
+#define oNFADDR			0x08
+#define oNFDATA			0x0C
+#define oNFSTAT			0x10
+#define oNFECC			0x14
+
+#ifndef __ASSEMBLER__
+
 /* include common stuff */
 #include <s3c24x0.h>
 
+typedef enum {
+	S3C24X0_UART0,
+	S3C24X0_UART1,
+	S3C24X0_UART2
+} S3C24X0_UARTS_NR;
 
 static inline S3C24X0_MEMCTL * const S3C24X0_GetBase_MEMCTL(void)
 {
@@ -142,6 +150,7 @@ static inline S3C2410_SDI * const S3C241
 	return (S3C2410_SDI * const)S3C2410_SDI_BASE;
 }
 
+#endif
 
 /* ISR */
 #define pISR_RESET		(*(unsigned *)(_ISR_STARTADDRESS+0x0))
diff --git a/include/s3c24x0.h b/include/s3c24x0.h
index 71f35a5..557b91f 100644
--- a/include/s3c24x0.h
+++ b/include/s3c24x0.h
@@ -637,13 +637,7 @@ typedef struct {
 	S3C24X0_REG32	SDIDCNT;
 	S3C24X0_REG32	SDIDSTA;
 	S3C24X0_REG32	SDIFSTA;
-#ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res[3];
-	S3C24X0_REG8	SDIDAT;
-#else
-	S3C24X0_REG8	SDIDAT;
-	S3C24X0_REG8	res[3];
-#endif
+	S3C24X0_REG32	SDIDAT;
 	S3C24X0_REG32	SDIIMSK;
 } /*__attribute__((__packed__))*/ S3C2410_SDI;
 
@@ -1123,11 +1117,7 @@ #define rSDIDatCon		(*(volatile unsigned
 #define rSDIDatCnt		(*(volatile unsigned *)0x5A000030)
 #define rSDIDatSta		(*(volatile unsigned *)0x5A000034)
 #define rSDIFSTA		(*(volatile unsigned *)0x5A000038)
-#ifdef __BIG_ENDIAN
-#define rSDIDAT			(*(volatile unsigned char *)0x5A00003F)
-#else
-#define rSDIDAT			(*(volatile unsigned char *)0x5A00003C)
-#endif
+#define rSDIDAT			(*(volatile unsigned *)0x5A00003C)
 #define rSDIIntMsk		(*(volatile unsigned *)0x5A000040)
 
 #endif
